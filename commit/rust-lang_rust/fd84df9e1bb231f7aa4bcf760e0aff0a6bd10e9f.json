{"sha": "fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkODRkZjllMWJiMjMxZjdhYTRiY2Y3NjBlMGFmZjBhNmJkMTBlOWY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-03T14:41:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-03T14:41:13Z"}, "message": "Merge #7541\n\n7541: Use block_def_map in body lowering (third time's the charm) r=jonas-schievink a=jonas-schievink\n\nAfter https://github.com/rust-analyzer/rust-analyzer/pull/7380 and https://github.com/rust-analyzer/rust-analyzer/pull/7506 both had to be reverted, this should have finally resolved all remaining bugs.\r\n\r\nMost importantly, the optimization to skip `block_def_map` computation when the block contains no inner items was fixed (which fortunately was simpler than expected).\r\n\r\nI've ran `analysis-stats` on libstd locally, which works fine, and also ran this PR locally for a short while without issues.\r\n\r\nNote that this *still* has no (or almost no) user-facing impact, because the rest of r-a still relies on some local item support hacks.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "57fbfe241dcd571b9376b23260299160e0312246", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57fbfe241dcd571b9376b23260299160e0312246"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgGrYJCRBK7hj4Ov3rIwAAdHIIAI7LF1/dFwe7uv0i4n6EWeua\nNlNlEsg1nkewPdQvMH6nu1dPd1W9eTLYc/ZjO6uex0PmlEZg7OftrlBSd4kW7nEW\nCjFjahhVfVgtkG4D7VQFNA8u9NEhhGGNI3p8+AaU6oZTAOuOdawLr1Jc7GXgRr02\nGjjFnGA+19bYcN6kaHfpX+LtVsEcGOxpBYNwk5bi/6hZr1eMMa/PiIIEie6xxL/R\nB18U4miMTwEqQDxBbwpr8MhUjdjutUdFEcQtxRQCZoYnY9y4HsoPLk7egMFoJtAz\nM2GGLfdvg8D/35X5nCbQRtRtG4sVJtSeWm7R0UcIQVjZeskvxCQCiFYaABJj5+U=\n=pPUi\n-----END PGP SIGNATURE-----\n", "payload": "tree 57fbfe241dcd571b9376b23260299160e0312246\nparent 93ecef53a370703a67f87b90c4640d3e8bf73934\nparent 63744fe128193464eb0ce63fbe6c30c4f98b6135\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1612363273 +0000\ncommitter GitHub <noreply@github.com> 1612363273 +0000\n\nMerge #7541\n\n7541: Use block_def_map in body lowering (third time's the charm) r=jonas-schievink a=jonas-schievink\n\nAfter https://github.com/rust-analyzer/rust-analyzer/pull/7380 and https://github.com/rust-analyzer/rust-analyzer/pull/7506 both had to be reverted, this should have finally resolved all remaining bugs.\r\n\r\nMost importantly, the optimization to skip `block_def_map` computation when the block contains no inner items was fixed (which fortunately was simpler than expected).\r\n\r\nI've ran `analysis-stats` on libstd locally, which works fine, and also ran this PR locally for a short while without issues.\r\n\r\nNote that this *still* has no (or almost no) user-facing impact, because the rest of r-a still relies on some local item support hacks.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "html_url": "https://github.com/rust-lang/rust/commit/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93ecef53a370703a67f87b90c4640d3e8bf73934", "url": "https://api.github.com/repos/rust-lang/rust/commits/93ecef53a370703a67f87b90c4640d3e8bf73934", "html_url": "https://github.com/rust-lang/rust/commit/93ecef53a370703a67f87b90c4640d3e8bf73934"}, {"sha": "63744fe128193464eb0ce63fbe6c30c4f98b6135", "url": "https://api.github.com/repos/rust-lang/rust/commits/63744fe128193464eb0ce63fbe6c30c4f98b6135", "html_url": "https://github.com/rust-lang/rust/commit/63744fe128193464eb0ce63fbe6c30c4f98b6135"}], "stats": {"total": 311, "additions": 211, "deletions": 100}, "files": [{"sha": "41abd8f83b5e1f3d7aaac39c67c290f90a32a68a", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -46,7 +46,7 @@ pub(crate) struct CfgExpander {\n \n pub(crate) struct Expander {\n     cfg_expander: CfgExpander,\n-    crate_def_map: Arc<DefMap>,\n+    def_map: Arc<DefMap>,\n     current_file_id: HirFileId,\n     ast_id_map: Arc<AstIdMap>,\n     module: ModuleId,\n@@ -91,7 +91,7 @@ impl Expander {\n         let ast_id_map = db.ast_id_map(current_file_id);\n         Expander {\n             cfg_expander,\n-            crate_def_map,\n+            def_map: crate_def_map,\n             current_file_id,\n             ast_id_map,\n             module,\n@@ -102,7 +102,6 @@ impl Expander {\n     pub(crate) fn enter_expand<T: ast::AstNode>(\n         &mut self,\n         db: &dyn DefDatabase,\n-        local_scope: Option<&ItemScope>,\n         macro_call: ast::MacroCall,\n     ) -> ExpandResult<Option<(Mark, T)>> {\n         if self.recursion_limit + 1 > EXPANSION_RECURSION_LIMIT {\n@@ -112,18 +111,12 @@ impl Expander {\n \n         let macro_call = InFile::new(self.current_file_id, &macro_call);\n \n-        let resolver = |path: ModPath| -> Option<MacroDefId> {\n-            if let Some(local_scope) = local_scope {\n-                if let Some(def) = path.as_ident().and_then(|n| local_scope.get_legacy_macro(n)) {\n-                    return Some(def);\n-                }\n-            }\n-            self.resolve_path_as_macro(db, &path)\n-        };\n+        let resolver =\n+            |path: ModPath| -> Option<MacroDefId> { self.resolve_path_as_macro(db, &path) };\n \n         let mut err = None;\n         let call_id =\n-            macro_call.as_call_id_with_errors(db, self.crate_def_map.krate(), resolver, &mut |e| {\n+            macro_call.as_call_id_with_errors(db, self.def_map.krate(), resolver, &mut |e| {\n                 err.get_or_insert(e);\n             });\n         let call_id = match call_id {\n@@ -204,7 +197,7 @@ impl Expander {\n     }\n \n     fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroDefId> {\n-        self.crate_def_map\n+        self.def_map\n             .resolve_path(db, self.module.local_id, path, BuiltinShadowMode::Other)\n             .0\n             .take_macros()"}, {"sha": "540c6c9ada7b6f281cf65a305bc8c1822204efa6", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -1,7 +1,7 @@\n //! Transforms `ast::Expr` into an equivalent `hir_def::expr::Expr`\n //! representation.\n \n-use std::{any::type_name, sync::Arc};\n+use std::{any::type_name, mem, sync::Arc};\n \n use either::Either;\n use hir_expand::{\n@@ -36,8 +36,8 @@ use crate::{\n     item_tree::{ItemTree, ItemTreeId, ItemTreeNode},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n-    AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern, ModuleDefId,\n-    StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n+    AdtId, BlockLoc, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern,\n+    ModuleDefId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n \n use super::{diagnostics::BodyDiagnostic, ExprSource, PatSource};\n@@ -152,8 +152,8 @@ impl ExprCollector<'_> {\n     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n         self.make_expr(expr, Err(SyntheticSyntax))\n     }\n-    fn empty_block(&mut self) -> ExprId {\n-        self.alloc_expr_desugared(Expr::Block { statements: Vec::new(), tail: None, label: None })\n+    fn unit(&mut self) -> ExprId {\n+        self.alloc_expr_desugared(Expr::Tuple { exprs: Vec::new() })\n     }\n     fn missing_expr(&mut self) -> ExprId {\n         self.alloc_expr_desugared(Expr::Missing)\n@@ -222,7 +222,7 @@ impl ExprCollector<'_> {\n                                 MatchArm { pat, expr: then_branch, guard: None },\n                                 MatchArm {\n                                     pat: placeholder_pat,\n-                                    expr: else_branch.unwrap_or_else(|| self.empty_block()),\n+                                    expr: else_branch.unwrap_or_else(|| self.unit()),\n                                     guard: None,\n                                 },\n                             ];\n@@ -561,7 +561,7 @@ impl ExprCollector<'_> {\n         let outer_file = self.expander.current_file_id;\n \n         let macro_call = self.expander.to_source(AstPtr::new(&e));\n-        let res = self.expander.enter_expand(self.db, Some(&self.body.item_scope), e);\n+        let res = self.expander.enter_expand(self.db, e);\n \n         match &res.err {\n             Some(ExpandError::UnresolvedProcMacro) => {\n@@ -697,12 +697,30 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n-        let syntax_node_ptr = AstPtr::new(&block.clone().into());\n+        let ast_id = self.expander.ast_id(&block);\n+        let block_loc = BlockLoc { ast_id, module: self.expander.module };\n+        let block_id = self.db.intern_block(block_loc);\n+        let opt_def_map = self.db.block_def_map(block_id);\n+        let has_def_map = opt_def_map.is_some();\n+        let def_map = opt_def_map.unwrap_or_else(|| self.expander.def_map.clone());\n+        let module =\n+            if has_def_map { def_map.module_id(def_map.root()) } else { self.expander.module };\n+        let prev_def_map = mem::replace(&mut self.expander.def_map, def_map);\n+        let prev_module = mem::replace(&mut self.expander.module, module);\n+\n         self.collect_stmts_items(block.statements());\n         let statements =\n             block.statements().filter_map(|s| self.collect_stmt(s)).flatten().collect();\n         let tail = block.tail_expr().map(|e| self.collect_expr(e));\n-        self.alloc_expr(Expr::Block { statements, tail, label: None }, syntax_node_ptr)\n+        let syntax_node_ptr = AstPtr::new(&block.clone().into());\n+        let expr_id = self.alloc_expr(\n+            Expr::Block { id: block_id, statements, tail, label: None },\n+            syntax_node_ptr,\n+        );\n+\n+        self.expander.def_map = prev_def_map;\n+        self.expander.module = prev_module;\n+        expr_id\n     }\n \n     fn collect_stmts_items(&mut self, stmts: ast::AstChildren<ast::Stmt>) {\n@@ -832,7 +850,7 @@ impl ExprCollector<'_> {\n                 if annotation == BindingAnnotation::Unannotated && subpat.is_none() {\n                     // This could also be a single-segment path pattern. To\n                     // decide that, we need to try resolving the name.\n-                    let (resolved, _) = self.expander.crate_def_map.resolve_path(\n+                    let (resolved, _) = self.expander.def_map.resolve_path(\n                         self.db,\n                         self.expander.module.local_id,\n                         &name.clone().into(),"}, {"sha": "404603360844f1f3a17440954ebb6810cfef8922", "filename": "crates/hir_def/src/body/tests.rs", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -1,7 +1,10 @@\n-use base_db::{fixture::WithFixture, SourceDatabase};\n+mod block;\n+\n+use base_db::{fixture::WithFixture, FilePosition, SourceDatabase};\n+use expect_test::Expect;\n use test_utils::mark;\n \n-use crate::{test_db::TestDB, ModuleDefId};\n+use crate::{test_db::TestDB, BlockId, ModuleDefId};\n \n use super::*;\n \n@@ -31,6 +34,115 @@ fn check_diagnostics(ra_fixture: &str) {\n     db.check_diagnostics();\n }\n \n+fn block_def_map_at(ra_fixture: &str) -> Arc<DefMap> {\n+    let (db, position) = crate::test_db::TestDB::with_position(ra_fixture);\n+\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let def_map = db.crate_def_map(krate);\n+\n+    let mut block =\n+        block_at_pos(&db, &def_map, position).expect(\"couldn't find enclosing function or block\");\n+    loop {\n+        let def_map = db.block_def_map(block).unwrap_or_else(|| def_map.clone());\n+        let new_block = block_at_pos(&db, &def_map, position);\n+        match new_block {\n+            Some(new_block) => {\n+                assert_ne!(block, new_block);\n+                block = new_block;\n+            }\n+            None => {\n+                return def_map;\n+            }\n+        }\n+    }\n+}\n+\n+fn block_at_pos(db: &dyn DefDatabase, def_map: &DefMap, position: FilePosition) -> Option<BlockId> {\n+    // Find the smallest (innermost) function containing the cursor.\n+    let mut size = None;\n+    let mut fn_def = None;\n+    for (_, module) in def_map.modules() {\n+        let file_id = module.definition_source(db).file_id;\n+        if file_id != position.file_id.into() {\n+            continue;\n+        }\n+        let root = db.parse_or_expand(file_id).unwrap();\n+        let ast_map = db.ast_id_map(file_id);\n+        let item_tree = db.item_tree(file_id);\n+        for decl in module.scope.declarations() {\n+            if let ModuleDefId::FunctionId(it) = decl {\n+                let ast = ast_map.get(item_tree[it.lookup(db).id.value].ast_id).to_node(&root);\n+                let range = ast.syntax().text_range();\n+\n+                if !range.contains(position.offset) {\n+                    continue;\n+                }\n+\n+                let new_size = match size {\n+                    None => range.len(),\n+                    Some(size) => {\n+                        if range.len() < size {\n+                            range.len()\n+                        } else {\n+                            size\n+                        }\n+                    }\n+                };\n+                if size != Some(new_size) {\n+                    size = Some(new_size);\n+                    fn_def = Some(it);\n+                }\n+            }\n+        }\n+    }\n+\n+    let (body, source_map) = db.body_with_source_map(fn_def?.into());\n+\n+    // Now find the smallest encompassing block expression in the function body.\n+    let mut size = None;\n+    let mut block_id = None;\n+    for (expr_id, expr) in body.exprs.iter() {\n+        if let Expr::Block { id, .. } = expr {\n+            if let Ok(ast) = source_map.expr_syntax(expr_id) {\n+                if ast.file_id != position.file_id.into() {\n+                    continue;\n+                }\n+\n+                let root = db.parse_or_expand(ast.file_id).unwrap();\n+                let ast = ast.value.to_node(&root);\n+                let range = ast.syntax().text_range();\n+\n+                if !range.contains(position.offset) {\n+                    continue;\n+                }\n+\n+                let new_size = match size {\n+                    None => range.len(),\n+                    Some(size) => {\n+                        if range.len() < size {\n+                            range.len()\n+                        } else {\n+                            size\n+                        }\n+                    }\n+                };\n+                if size != Some(new_size) {\n+                    size = Some(new_size);\n+                    block_id = Some(*id);\n+                }\n+            }\n+        }\n+    }\n+\n+    Some(block_id.expect(\"can't find block containing cursor\"))\n+}\n+\n+fn check_at(ra_fixture: &str, expect: Expect) {\n+    let def_map = block_def_map_at(ra_fixture);\n+    let actual = def_map.dump();\n+    expect.assert_eq(&actual);\n+}\n+\n #[test]\n fn your_stack_belongs_to_me() {\n     mark::check!(your_stack_belongs_to_me);"}, {"sha": "d5f3ac4c5612557c9cd57bcd4554aeeeff4bb5d4", "filename": "crates/hir_def/src/body/tests/block.rs", "status": "renamed", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use expect_test::expect;\n \n #[test]\n fn inner_item_smoke() {\n@@ -184,3 +185,36 @@ pub mod mark {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn macro_resolve_legacy() {\n+    check_at(\n+        r#\"\n+//- /lib.rs\n+mod module;\n+\n+//- /module.rs\n+macro_rules! m {\n+    () => {\n+        struct Def {}\n+    };\n+}\n+\n+fn f() {\n+    {\n+        m!();\n+        $0\n+    }\n+}\n+        \"#,\n+        expect![[r#\"\n+            block scope\n+            Def: t\n+            crate\n+            module: t\n+\n+            crate::module\n+            f: v\n+        \"#]],\n+    )\n+}", "previous_filename": "crates/hir_def/src/nameres/tests/block.rs"}, {"sha": "c2b0dc00714a9e1fae5345f439170ce47300c6e7", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -262,7 +262,7 @@ fn collect_items(\n                 let root = db.parse_or_expand(file_id).unwrap();\n                 let call = ast_id_map.get(call.ast_id).to_node(&root);\n \n-                if let Some((mark, mac)) = expander.enter_expand(db, None, call).value {\n+                if let Some((mark, mac)) = expander.enter_expand(db, call).value {\n                     let src: InFile<ast::MacroItems> = expander.to_source(mac);\n                     let item_tree = db.item_tree(src.file_id);\n                     let iter ="}, {"sha": "7fe6f6346a5998fc1dcbe1e720b859c66205638b", "filename": "crates/hir_def/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -59,7 +59,7 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     fn crate_def_map_query(&self, krate: CrateId) -> Arc<DefMap>;\n \n     #[salsa::invoke(DefMap::block_def_map_query)]\n-    fn block_def_map(&self, block: BlockId) -> Arc<DefMap>;\n+    fn block_def_map(&self, block: BlockId) -> Option<Arc<DefMap>>;\n \n     #[salsa::invoke(StructData::struct_data_query)]\n     fn struct_data(&self, id: StructId) -> Arc<StructData>;"}, {"sha": "4d72eaeaff9aa4269d9d42bdb102b993a977d101", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -20,6 +20,7 @@ use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n+    BlockId,\n };\n \n pub type ExprId = Idx<Expr>;\n@@ -56,6 +57,7 @@ pub enum Expr {\n         else_branch: Option<ExprId>,\n     },\n     Block {\n+        id: BlockId,\n         statements: Vec<Statement>,\n         tail: Option<ExprId>,\n         label: Option<LabelId>,"}, {"sha": "4bde676490ec2a613a3cc548dddf0e08b6f790bc", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -24,7 +24,7 @@ use la_arena::{Arena, Idx, RawIdx};\n use profile::Count;\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n-use syntax::{ast, match_ast};\n+use syntax::{ast, match_ast, SyntaxKind};\n use test_utils::mark;\n \n use crate::{\n@@ -80,6 +80,10 @@ impl ItemTree {\n     pub(crate) fn item_tree_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<ItemTree> {\n         let _p = profile::span(\"item_tree_query\").detail(|| format!(\"{:?}\", file_id));\n         let syntax = if let Some(node) = db.parse_or_expand(file_id) {\n+            if node.kind() == SyntaxKind::ERROR {\n+                // FIXME: not 100% sure why these crop up, but return an empty tree to avoid a panic\n+                return Default::default();\n+            }\n             node\n         } else {\n             return Default::default();"}, {"sha": "5dd3705b0bbdd16bdba80de71f33c03bda592078", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -81,7 +81,13 @@ pub struct ModuleId {\n impl ModuleId {\n     pub fn def_map(&self, db: &dyn db::DefDatabase) -> Arc<DefMap> {\n         match self.block {\n-            Some(block) => db.block_def_map(block),\n+            Some(block) => {\n+                db.block_def_map(block).unwrap_or_else(|| {\n+                    // NOTE: This should be unreachable - all `ModuleId`s come from their `DefMap`s,\n+                    // so the `DefMap` here must exist.\n+                    panic!(\"no `block_def_map` for `ModuleId` {:?}\", self);\n+                })\n+            }\n             None => db.crate_def_map(self.krate),\n         }\n     }\n@@ -239,6 +245,7 @@ pub struct BlockId(salsa::InternId);\n #[derive(Debug, Hash, PartialEq, Eq, Clone)]\n pub struct BlockLoc {\n     ast_id: AstId<ast::BlockExpr>,\n+    /// The containing module.\n     module: ModuleId,\n }\n impl_intern!(BlockId, BlockLoc, intern_block, lookup_intern_block);"}, {"sha": "ece5958f4a49c30d0df1103d8f03fbce38c3295e", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -197,12 +197,17 @@ impl DefMap {\n         Arc::new(def_map)\n     }\n \n-    pub(crate) fn block_def_map_query(db: &dyn DefDatabase, block_id: BlockId) -> Arc<DefMap> {\n+    pub(crate) fn block_def_map_query(\n+        db: &dyn DefDatabase,\n+        block_id: BlockId,\n+    ) -> Option<Arc<DefMap>> {\n         let block: BlockLoc = db.lookup_intern_block(block_id);\n         let parent = block.module.def_map(db);\n \n-        // FIXME: It would be good to just return the parent map when the block has no items, but\n-        // we rely on `def_map.block` in a few places, which is `Some` for the inner `DefMap`.\n+        let item_tree = db.item_tree(block.ast_id.file_id);\n+        if item_tree.inner_items_of_block(block.ast_id.value).is_empty() {\n+            return None;\n+        }\n \n         let block_info =\n             BlockInfo { block: block_id, parent, parent_module: block.module.local_id };\n@@ -211,7 +216,7 @@ impl DefMap {\n         def_map.block = Some(block_info);\n \n         let def_map = collector::collect_defs(db, def_map, Some(block.ast_id));\n-        Arc::new(def_map)\n+        Some(Arc::new(def_map))\n     }\n \n     fn empty(krate: CrateId, edition: Edition) -> DefMap {"}, {"sha": "723481c367fc243caa9403f36f7c7f71289efcc7", "filename": "crates/hir_def/src/nameres/tests.rs", "status": "modified", "additions": 2, "deletions": 66, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -4,91 +4,27 @@ mod macros;\n mod mod_resolution;\n mod diagnostics;\n mod primitives;\n-mod block;\n \n use std::sync::Arc;\n \n-use base_db::{fixture::WithFixture, FilePosition, SourceDatabase};\n+use base_db::{fixture::WithFixture, SourceDatabase};\n use expect_test::{expect, Expect};\n-use syntax::AstNode;\n use test_utils::mark;\n \n-use crate::{db::DefDatabase, nameres::*, test_db::TestDB, Lookup};\n+use crate::{db::DefDatabase, nameres::*, test_db::TestDB};\n \n fn compute_crate_def_map(ra_fixture: &str) -> Arc<DefMap> {\n     let db = TestDB::with_files(ra_fixture);\n     let krate = db.crate_graph().iter().next().unwrap();\n     db.crate_def_map(krate)\n }\n \n-fn compute_block_def_map(ra_fixture: &str) -> Arc<DefMap> {\n-    let (db, position) = TestDB::with_position(ra_fixture);\n-\n-    // FIXME: perhaps we should make this use body lowering tests instead?\n-\n-    let module = db.module_for_file(position.file_id);\n-    let mut def_map = db.crate_def_map(module.krate);\n-    while let Some(new_def_map) = descend_def_map_at_position(&db, position, def_map.clone()) {\n-        def_map = new_def_map;\n-    }\n-\n-    // FIXME: select the right module, not the root\n-\n-    def_map\n-}\n-\n-fn descend_def_map_at_position(\n-    db: &dyn DefDatabase,\n-    position: FilePosition,\n-    def_map: Arc<DefMap>,\n-) -> Option<Arc<DefMap>> {\n-    for (local_id, module_data) in def_map.modules() {\n-        let mod_def = module_data.origin.definition_source(db);\n-        let ast_map = db.ast_id_map(mod_def.file_id);\n-        let item_tree = db.item_tree(mod_def.file_id);\n-        let root = db.parse_or_expand(mod_def.file_id).unwrap();\n-        for item in module_data.scope.declarations() {\n-            match item {\n-                ModuleDefId::FunctionId(it) => {\n-                    // Technically blocks can be inside any type (due to arrays and const generics),\n-                    // and also in const/static initializers. For tests we only really care about\n-                    // functions though.\n-\n-                    let ast = ast_map.get(item_tree[it.lookup(db).id.value].ast_id).to_node(&root);\n-\n-                    if ast.syntax().text_range().contains(position.offset) {\n-                        // Cursor inside function, descend into its body's DefMap.\n-                        // Note that we don't handle block *expressions* inside function bodies.\n-                        let ast_map = db.ast_id_map(position.file_id.into());\n-                        let ast_id = ast_map.ast_id(&ast.body().unwrap());\n-                        let block = BlockLoc {\n-                            ast_id: InFile::new(position.file_id.into(), ast_id),\n-                            module: def_map.module_id(local_id),\n-                        };\n-                        let block_id = db.intern_block(block);\n-                        return Some(db.block_def_map(block_id));\n-                    }\n-                }\n-                _ => continue,\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n fn check(ra_fixture: &str, expect: Expect) {\n     let def_map = compute_crate_def_map(ra_fixture);\n     let actual = def_map.dump();\n     expect.assert_eq(&actual);\n }\n \n-fn check_at(ra_fixture: &str, expect: Expect) {\n-    let def_map = compute_block_def_map(ra_fixture);\n-    let actual = def_map.dump();\n-    expect.assert_eq(&actual);\n-}\n-\n #[test]\n fn crate_def_map_smoke_test() {\n     check("}, {"sha": "12f1591c81f266b2d2a09f64aa33c9e78c77b109", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "patch": "@@ -137,7 +137,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.coerce_merge_branch(&then_ty, &else_ty)\n             }\n-            Expr::Block { statements, tail, label } => match label {\n+            Expr::Block { statements, tail, label, id: _ } => match label {\n                 Some(_) => {\n                     let break_ty = self.table.new_type_var();\n                     self.breakables.push(BreakableContext {"}]}