{"sha": "edbde25ca2f13ffacfd006ada7b38618d36d97c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYmRlMjVjYTJmMTNmZmFjZmQwMDZhZGE3YjM4NjE4ZDM2ZDk3YzY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-21T17:51:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-21T17:51:53Z"}, "message": "Merge #8856\n\n8856: Use Chalk for unification r=flodiebold a=flodiebold\n\n - use Chalk's unification, get rid of our own `unify`\r\n - rewrite coercion to not use unification internals and to be more analogous to rustc\r\n - fix various coercion bugs\r\n - rewrite handling of obligations, since the old hacky optimization where we noted when an inference variable changes wasn't possible anymore\r\n - stop trying to deeply resolve types all the time during inference, instead only do it shallowly where necessary\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "b1c5208c74ce56a36c8a9c454b9c479a3312ee94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1c5208c74ce56a36c8a9c454b9c479a3312ee94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edbde25ca2f13ffacfd006ada7b38618d36d97c6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgp/M5CRBK7hj4Ov3rIwAAc+wIAFCRnbHIRshOVAyTzhKqYsIl\njd050OMLVpHHsNc1fRd9tVN9MrQlAlJAX75L3C7SUsvM3q2ZAdaegXY/XBpG6mw3\ndCkzN3NvY0ZdyQWdbwJjm+kRxRKv0LluCU5EDVhhKlFSyll2dmibbfuZcHTujTuc\nSkkmlU9iAdJdcoQe3ml+vTScxPSLLNG2v2QfEcOMOyhXO8fuunyYlitAS2SPaPYf\nRcZTa0Y3iYRT/viPUQPcNWO3deWNfv9ZYDg/LkCSBi+eklfOipNQRokf9Fx7Y8Us\ng0PZafP84z7VQ/2ogxtCE2Ta1AAiyPjthu3hJYfXAQalPoIH9urM1E5YP3Lo3Dc=\n=WW7b\n-----END PGP SIGNATURE-----\n", "payload": "tree b1c5208c74ce56a36c8a9c454b9c479a3312ee94\nparent de403b10448e23f232804596538de92fc57203d6\nparent ef558c97d09b0be8639c92f490e5ad380aa04288\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621619513 +0000\ncommitter GitHub <noreply@github.com> 1621619513 +0000\n\nMerge #8856\n\n8856: Use Chalk for unification r=flodiebold a=flodiebold\n\n - use Chalk's unification, get rid of our own `unify`\r\n - rewrite coercion to not use unification internals and to be more analogous to rustc\r\n - fix various coercion bugs\r\n - rewrite handling of obligations, since the old hacky optimization where we noted when an inference variable changes wasn't possible anymore\r\n - stop trying to deeply resolve types all the time during inference, instead only do it shallowly where necessary\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edbde25ca2f13ffacfd006ada7b38618d36d97c6", "html_url": "https://github.com/rust-lang/rust/commit/edbde25ca2f13ffacfd006ada7b38618d36d97c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edbde25ca2f13ffacfd006ada7b38618d36d97c6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de403b10448e23f232804596538de92fc57203d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/de403b10448e23f232804596538de92fc57203d6", "html_url": "https://github.com/rust-lang/rust/commit/de403b10448e23f232804596538de92fc57203d6"}, {"sha": "ef558c97d09b0be8639c92f490e5ad380aa04288", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef558c97d09b0be8639c92f490e5ad380aa04288", "html_url": "https://github.com/rust-lang/rust/commit/ef558c97d09b0be8639c92f490e5ad380aa04288"}], "stats": {"total": 2283, "additions": 1206, "deletions": 1077}, "files": [{"sha": "52d72c3c529b25d3c1077df96c96d9031ffb0ecf", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -1712,15 +1712,17 @@ impl Type {\n         resolver: &Resolver,\n         ty: Ty,\n     ) -> Type {\n-        let environment =\n-            resolver.generic_def().map_or_else(Default::default, |d| db.trait_environment(d));\n+        let environment = resolver\n+            .generic_def()\n+            .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n         Type { krate, env: environment, ty }\n     }\n \n     fn new(db: &dyn HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n         let resolver = lexical_env.resolver(db.upcast());\n-        let environment =\n-            resolver.generic_def().map_or_else(Default::default, |d| db.trait_environment(d));\n+        let environment = resolver\n+            .generic_def()\n+            .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n         Type { krate, env: environment, ty }\n     }\n \n@@ -2051,11 +2053,7 @@ impl Type {\n         name: Option<&Name>,\n         mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n     ) -> Option<T> {\n-        // There should be no inference vars in types passed here\n-        // FIXME check that?\n-        // FIXME replace Unknown by bound vars here\n-        let canonical =\n-            Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(&Interner) };\n+        let canonical = hir_ty::replace_errors_with_variables(self.ty.clone());\n \n         let env = self.env.clone();\n         let krate = krate.id;\n@@ -2223,8 +2221,9 @@ impl Type {\n         walk_type(db, self, &mut cb);\n     }\n \n-    pub fn could_unify_with(&self, other: &Type) -> bool {\n-        could_unify(&self.ty, &other.ty)\n+    pub fn could_unify_with(&self, db: &dyn HirDatabase, other: &Type) -> bool {\n+        let tys = hir_ty::replace_errors_with_variables((self.ty.clone(), other.ty.clone()));\n+        could_unify(db, self.env.clone(), &tys)\n     }\n }\n "}, {"sha": "893e727c2e1b5b4d522c06ca259af2884f0ccfd8", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -6,15 +6,15 @@ use chalk_ir::{\n     cast::{Cast, CastTo, Caster},\n     fold::Fold,\n     interner::HasInterner,\n-    AdtId, BoundVar, DebruijnIndex, Safety, Scalar,\n+    AdtId, BoundVar, DebruijnIndex, Scalar,\n };\n use hir_def::{builtin_type::BuiltinType, GenericDefId, TraitId, TypeAliasId};\n use smallvec::SmallVec;\n \n use crate::{\n     db::HirDatabase, primitive, to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders,\n-    CallableSig, FnPointer, FnSig, FnSubst, GenericArg, Interner, ProjectionTy, Substitution,\n-    TraitRef, Ty, TyDefId, TyExt, TyKind, ValueTyDefId,\n+    CallableSig, GenericArg, Interner, ProjectionTy, Substitution, TraitRef, Ty, TyDefId, TyExt,\n+    TyKind, ValueTyDefId,\n };\n \n /// This is a builder for `Ty` or anything that needs a `Substitution`.\n@@ -77,15 +77,7 @@ impl TyBuilder<()> {\n     }\n \n     pub fn fn_ptr(sig: CallableSig) -> Ty {\n-        TyKind::Function(FnPointer {\n-            num_binders: 0,\n-            sig: FnSig { abi: (), safety: Safety::Safe, variadic: sig.is_varargs },\n-            substitution: FnSubst(Substitution::from_iter(\n-                &Interner,\n-                sig.params_and_return.iter().cloned(),\n-            )),\n-        })\n-        .intern(&Interner)\n+        TyKind::Function(sig.to_fn_ptr()).intern(&Interner)\n     }\n \n     pub fn builtin(builtin: BuiltinType) -> Ty {"}, {"sha": "b108fd559c431a15a55a467830a738e21f80ca95", "filename": "crates/hir_ty/src/chalk_db.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -344,20 +344,20 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     }\n \n     fn unification_database(&self) -> &dyn chalk_ir::UnificationDatabase<Interner> {\n-        self\n+        &self.db\n     }\n }\n \n-impl<'a> chalk_ir::UnificationDatabase<Interner> for ChalkContext<'a> {\n+impl<'a> chalk_ir::UnificationDatabase<Interner> for &'a dyn HirDatabase {\n     fn fn_def_variance(\n         &self,\n         fn_def_id: chalk_ir::FnDefId<Interner>,\n     ) -> chalk_ir::Variances<Interner> {\n-        self.db.fn_def_variance(self.krate, fn_def_id)\n+        HirDatabase::fn_def_variance(*self, fn_def_id)\n     }\n \n     fn adt_variance(&self, adt_id: chalk_ir::AdtId<Interner>) -> chalk_ir::Variances<Interner> {\n-        self.db.adt_variance(self.krate, adt_id)\n+        HirDatabase::adt_variance(*self, adt_id)\n     }\n }\n \n@@ -651,11 +651,7 @@ pub(crate) fn fn_def_datum_query(\n     Arc::new(datum)\n }\n \n-pub(crate) fn fn_def_variance_query(\n-    db: &dyn HirDatabase,\n-    _krate: CrateId,\n-    fn_def_id: FnDefId,\n-) -> Variances {\n+pub(crate) fn fn_def_variance_query(db: &dyn HirDatabase, fn_def_id: FnDefId) -> Variances {\n     let callable_def: CallableDefId = from_chalk(db, fn_def_id);\n     let generic_params = generics(db.upcast(), callable_def.into());\n     Variances::from_iter(\n@@ -666,7 +662,6 @@ pub(crate) fn fn_def_variance_query(\n \n pub(crate) fn adt_variance_query(\n     db: &dyn HirDatabase,\n-    _krate: CrateId,\n     chalk_ir::AdtId(adt_id): AdtId,\n ) -> Variances {\n     let generic_params = generics(db.upcast(), adt_id.into());"}, {"sha": "df340a6ca17abb61326472a3d5f28a1c2c633c72", "filename": "crates/hir_ty/src/chalk_ext.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -18,6 +18,7 @@ pub trait TyExt {\n     fn is_unit(&self) -> bool;\n     fn is_never(&self) -> bool;\n     fn is_unknown(&self) -> bool;\n+    fn is_ty_var(&self) -> bool;\n \n     fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)>;\n     fn as_builtin(&self) -> Option<BuiltinType>;\n@@ -55,6 +56,10 @@ impl TyExt for Ty {\n         matches!(self.kind(&Interner), TyKind::Error)\n     }\n \n+    fn is_ty_var(&self) -> bool {\n+        matches!(self.kind(&Interner), TyKind::InferenceVar(_, _))\n+    }\n+\n     fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)> {\n         match self.kind(&Interner) {\n             TyKind::Adt(AdtId(adt), parameters) => Some((*adt, parameters)),"}, {"sha": "be5b9110ed95fe4335bb1619ff333fd9677037b1", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -117,10 +117,10 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn fn_def_datum(&self, krate: CrateId, fn_def_id: FnDefId) -> Arc<chalk_db::FnDefDatum>;\n \n     #[salsa::invoke(chalk_db::fn_def_variance_query)]\n-    fn fn_def_variance(&self, krate: CrateId, fn_def_id: FnDefId) -> chalk_db::Variances;\n+    fn fn_def_variance(&self, fn_def_id: FnDefId) -> chalk_db::Variances;\n \n     #[salsa::invoke(chalk_db::adt_variance_query)]\n-    fn adt_variance(&self, krate: CrateId, adt_id: chalk_db::AdtId) -> chalk_db::Variances;\n+    fn adt_variance(&self, adt_id: chalk_db::AdtId) -> chalk_db::Variances;\n \n     #[salsa::invoke(chalk_db::associated_ty_value_query)]\n     fn associated_ty_value(\n@@ -134,14 +134,14 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn trait_solve(\n         &self,\n         krate: CrateId,\n-        goal: crate::Canonical<crate::InEnvironment<crate::DomainGoal>>,\n+        goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n     ) -> Option<crate::Solution>;\n \n     #[salsa::invoke(crate::traits::trait_solve_query)]\n     fn trait_solve_query(\n         &self,\n         krate: CrateId,\n-        goal: crate::Canonical<crate::InEnvironment<crate::DomainGoal>>,\n+        goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n     ) -> Option<crate::Solution>;\n \n     #[salsa::invoke(chalk_db::program_clauses_for_chalk_env_query)]\n@@ -168,7 +168,7 @@ fn infer_wait(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult>\n fn trait_solve_wait(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n-    goal: crate::Canonical<crate::InEnvironment<crate::DomainGoal>>,\n+    goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n ) -> Option<crate::Solution> {\n     let _p = profile::span(\"trait_solve::wait\");\n     db.trait_solve_query(krate, goal)"}, {"sha": "f1cebbdb983f70c21c20f7d26de02030ff839b68", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 83, "deletions": 109, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -13,8 +13,6 @@\n //! to certain types. To record this, we use the union-find implementation from\n //! the `ena` crate, which is extracted from rustc.\n \n-use std::borrow::Cow;\n-use std::mem;\n use std::ops::Index;\n use std::sync::Arc;\n \n@@ -27,22 +25,20 @@ use hir_def::{\n     path::{path, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::TypeRef,\n-    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, Lookup, TraitId,\n-    TypeAliasId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule, Lookup,\n+    TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name::name};\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n use stdx::impl_from;\n use syntax::SmolStr;\n \n-use super::{\n-    DomainGoal, Guidance, InEnvironment, ProjectionTy, Solution, TraitEnvironment, TraitRef, Ty,\n-};\n+use super::{DomainGoal, InEnvironment, ProjectionTy, TraitEnvironment, TraitRef, Ty};\n use crate::{\n     db::HirDatabase, fold_tys, infer::diagnostics::InferenceDiagnostic,\n-    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Canonical, Interner,\n-    TyBuilder, TyExt, TyKind,\n+    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Goal, Interner, TyBuilder,\n+    TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -106,6 +102,14 @@ impl Default for BindingMode {\n     }\n }\n \n+#[derive(Debug)]\n+pub(crate) struct InferOk {\n+    goals: Vec<InEnvironment<Goal>>,\n+}\n+#[derive(Debug)]\n+pub(crate) struct TypeError;\n+pub(crate) type InferResult = Result<InferOk, TypeError>;\n+\n /// A mismatch between an expected and an inferred type.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct TypeMismatch {\n@@ -217,10 +221,8 @@ struct InferenceContext<'a> {\n     owner: DefWithBodyId,\n     body: Arc<Body>,\n     resolver: Resolver,\n-    table: unify::InferenceTable,\n+    table: unify::InferenceTable<'a>,\n     trait_env: Arc<TraitEnvironment>,\n-    obligations: Vec<DomainGoal>,\n-    last_obligations_check: Option<u32>,\n     result: InferenceResult,\n     /// The return type of the function being inferred, or the closure if we're\n     /// currently within one.\n@@ -252,15 +254,15 @@ fn find_breakable<'c>(\n \n impl<'a> InferenceContext<'a> {\n     fn new(db: &'a dyn HirDatabase, owner: DefWithBodyId, resolver: Resolver) -> Self {\n+        let krate = owner.module(db.upcast()).krate();\n+        let trait_env = owner\n+            .as_generic_def_id()\n+            .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n         InferenceContext {\n             result: InferenceResult::default(),\n-            table: unify::InferenceTable::new(),\n-            obligations: Vec::default(),\n-            last_obligations_check: None,\n+            table: unify::InferenceTable::new(db, trait_env.clone()),\n+            trait_env,\n             return_ty: TyKind::Error.intern(&Interner), // set in collect_fn_signature\n-            trait_env: owner\n-                .as_generic_def_id()\n-                .map_or_else(Default::default, |d| db.trait_environment(d)),\n             db,\n             owner,\n             body: db.body(owner),\n@@ -271,19 +273,25 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn err_ty(&self) -> Ty {\n-        TyKind::Error.intern(&Interner)\n+        self.result.standard_types.unknown.clone()\n     }\n \n     fn resolve_all(mut self) -> InferenceResult {\n         // FIXME resolve obligations as well (use Guidance if necessary)\n+        self.table.resolve_obligations_as_possible();\n+\n+        // make sure diverging type variables are marked as such\n+        self.table.propagate_diverging_flag();\n         let mut result = std::mem::take(&mut self.result);\n         for ty in result.type_of_expr.values_mut() {\n-            let resolved = self.table.resolve_ty_completely(ty.clone());\n-            *ty = resolved;\n+            *ty = self.table.resolve_ty_completely(ty.clone());\n         }\n         for ty in result.type_of_pat.values_mut() {\n-            let resolved = self.table.resolve_ty_completely(ty.clone());\n-            *ty = resolved;\n+            *ty = self.table.resolve_ty_completely(ty.clone());\n+        }\n+        for mismatch in result.type_mismatches.values_mut() {\n+            mismatch.expected = self.table.resolve_ty_completely(mismatch.expected.clone());\n+            mismatch.actual = self.table.resolve_ty_completely(mismatch.actual.clone());\n         }\n         result\n     }\n@@ -337,6 +345,14 @@ impl<'a> InferenceContext<'a> {\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty.kind(&Interner) {\n             TyKind::Error => self.table.new_type_var(),\n+            TyKind::InferenceVar(..) => {\n+                let ty_resolved = self.resolve_ty_shallow(&ty);\n+                if ty_resolved.is_unknown() {\n+                    self.table.new_type_var()\n+                } else {\n+                    ty\n+                }\n+            }\n             _ => ty,\n         }\n     }\n@@ -346,66 +362,19 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_obligations_as_possible(&mut self) {\n-        if self.last_obligations_check == Some(self.table.revision) {\n-            // no change\n-            return;\n-        }\n-        let _span = profile::span(\"resolve_obligations_as_possible\");\n-\n-        self.last_obligations_check = Some(self.table.revision);\n-        let obligations = mem::replace(&mut self.obligations, Vec::new());\n-        for obligation in obligations {\n-            let in_env = InEnvironment::new(&self.trait_env.env, obligation.clone());\n-            let canonicalized = self.canonicalizer().canonicalize_obligation(in_env);\n-            let solution =\n-                self.db.trait_solve(self.resolver.krate().unwrap(), canonicalized.value.clone());\n-\n-            match solution {\n-                Some(Solution::Unique(canonical_subst)) => {\n-                    canonicalized.apply_solution(\n-                        self,\n-                        Canonical {\n-                            binders: canonical_subst.binders,\n-                            // FIXME: handle constraints\n-                            value: canonical_subst.value.subst,\n-                        },\n-                    );\n-                }\n-                Some(Solution::Ambig(Guidance::Definite(substs))) => {\n-                    canonicalized.apply_solution(self, substs);\n-                    self.obligations.push(obligation);\n-                }\n-                Some(_) => {\n-                    // FIXME use this when trying to resolve everything at the end\n-                    self.obligations.push(obligation);\n-                }\n-                None => {\n-                    // FIXME obligation cannot be fulfilled => diagnostic\n-                }\n-            };\n-        }\n+        self.table.resolve_obligations_as_possible();\n     }\n \n     fn push_obligation(&mut self, o: DomainGoal) {\n-        self.obligations.push(o);\n-        self.last_obligations_check = None;\n+        self.table.register_obligation(o.cast(&Interner));\n     }\n \n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n         self.table.unify(ty1, ty2)\n     }\n \n-    /// Resolves the type as far as currently possible, replacing type variables\n-    /// by their known types. All types returned by the infer_* functions should\n-    /// be resolved as far as possible, i.e. contain no type variables with\n-    /// known type.\n-    fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n+    fn resolve_ty_shallow(&mut self, ty: &Ty) -> Ty {\n         self.resolve_obligations_as_possible();\n-\n-        self.table.resolve_ty_as_possible(ty)\n-    }\n-\n-    fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n         self.table.resolve_ty_shallow(ty)\n     }\n \n@@ -439,7 +408,7 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 self.push_obligation(trait_ref.cast(&Interner));\n                 self.push_obligation(alias_eq.cast(&Interner));\n-                self.resolve_ty_as_possible(ty)\n+                ty\n             }\n             None => self.err_ty(),\n         }\n@@ -452,25 +421,7 @@ impl<'a> InferenceContext<'a> {\n     /// call). `make_ty` handles this already, but e.g. for field types we need\n     /// to do it as well.\n     fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n-        let ty = self.resolve_ty_as_possible(ty);\n-        fold_tys(\n-            ty,\n-            |ty, _| match ty.kind(&Interner) {\n-                TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n-                    self.normalize_projection_ty(proj_ty.clone())\n-                }\n-                _ => ty,\n-            },\n-            DebruijnIndex::INNERMOST,\n-        )\n-    }\n-\n-    fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {\n-        let var = self.table.new_type_var();\n-        let alias_eq = AliasEq { alias: AliasTy::Projection(proj_ty), ty: var.clone() };\n-        let obligation = alias_eq.cast(&Interner);\n-        self.push_obligation(obligation);\n-        var\n+        self.table.normalize_associated_types_in(ty)\n     }\n \n     fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantId>) {\n@@ -720,17 +671,23 @@ impl<'a> InferenceContext<'a> {\n /// When inferring an expression, we propagate downward whatever type hint we\n /// are able in the form of an `Expectation`.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-struct Expectation {\n-    ty: Ty,\n-    /// See the `rvalue_hint` method.\n-    rvalue_hint: bool,\n+enum Expectation {\n+    None,\n+    HasType(Ty),\n+    // Castable(Ty), // rustc has this, we currently just don't propagate an expectation for casts\n+    RValueLikeUnsized(Ty),\n }\n \n impl Expectation {\n     /// The expectation that the type of the expression needs to equal the given\n     /// type.\n     fn has_type(ty: Ty) -> Self {\n-        Expectation { ty, rvalue_hint: false }\n+        if ty.is_unknown() {\n+            // FIXME: get rid of this?\n+            Expectation::None\n+        } else {\n+            Expectation::HasType(ty)\n+        }\n     }\n \n     /// The following explanation is copied straight from rustc:\n@@ -754,24 +711,41 @@ impl Expectation {\n     /// See the test case `test/ui/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n     fn rvalue_hint(ty: Ty) -> Self {\n-        Expectation { ty, rvalue_hint: true }\n+        match ty.strip_references().kind(&Interner) {\n+            TyKind::Slice(_) | TyKind::Str | TyKind::Dyn(_) => Expectation::RValueLikeUnsized(ty),\n+            _ => Expectation::has_type(ty),\n+        }\n     }\n \n     /// This expresses no expectation on the type.\n     fn none() -> Self {\n-        Expectation {\n-            // FIXME\n-            ty: TyKind::Error.intern(&Interner),\n-            rvalue_hint: false,\n+        Expectation::None\n+    }\n+\n+    fn resolve(&self, table: &mut unify::InferenceTable) -> Expectation {\n+        match self {\n+            Expectation::None => Expectation::None,\n+            Expectation::HasType(t) => Expectation::HasType(table.resolve_ty_shallow(t)),\n+            Expectation::RValueLikeUnsized(t) => {\n+                Expectation::RValueLikeUnsized(table.resolve_ty_shallow(t))\n+            }\n         }\n     }\n \n-    fn coercion_target(&self) -> Ty {\n-        if self.rvalue_hint {\n-            // FIXME\n-            TyKind::Error.intern(&Interner)\n-        } else {\n-            self.ty.clone()\n+    fn to_option(&self, table: &mut unify::InferenceTable) -> Option<Ty> {\n+        match self.resolve(table) {\n+            Expectation::None => None,\n+            Expectation::HasType(t) |\n+            // Expectation::Castable(t) |\n+            Expectation::RValueLikeUnsized(t) => Some(t),\n+        }\n+    }\n+\n+    fn only_has_type(&self, table: &mut unify::InferenceTable) -> Option<Ty> {\n+        match self {\n+            Expectation::HasType(t) => Some(table.resolve_ty_shallow(t)),\n+            // Expectation::Castable(_) |\n+            Expectation::RValueLikeUnsized(_) | Expectation::None => None,\n         }\n     }\n }"}, {"sha": "765a02b1ced8a434fdd048fac4c894d04ed4aa98", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 370, "deletions": 110, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -2,195 +2,455 @@\n //! happen in certain places, e.g. weakening `&mut` to `&` or deref coercions\n //! like going from `&Vec<T>` to `&[T]`.\n //!\n-//! See: https://doc.rust-lang.org/nomicon/coercions.html\n+//! See https://doc.rust-lang.org/nomicon/coercions.html and\n+//! librustc_typeck/check/coercion.rs.\n \n use chalk_ir::{cast::Cast, Mutability, TyVariableKind};\n-use hir_def::lang_item::LangItemTarget;\n+use hir_def::{expr::ExprId, lang_item::LangItemTarget};\n \n-use crate::{autoderef, Canonical, Interner, Solution, Ty, TyBuilder, TyExt, TyKind};\n+use crate::{\n+    autoderef, infer::TypeMismatch, static_lifetime, Canonical, DomainGoal, FnPointer, FnSig,\n+    Interner, Solution, Substitution, Ty, TyBuilder, TyExt, TyKind,\n+};\n \n-use super::{InEnvironment, InferenceContext};\n+use super::{InEnvironment, InferOk, InferResult, InferenceContext, TypeError};\n \n impl<'a> InferenceContext<'a> {\n     /// Unify two types, but may coerce the first one to the second one\n     /// using \"implicit coercion rules\" if needed.\n     pub(super) fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n-        let from_ty = self.resolve_ty_shallow(from_ty).into_owned();\n+        let from_ty = self.resolve_ty_shallow(from_ty);\n         let to_ty = self.resolve_ty_shallow(to_ty);\n-        self.coerce_inner(from_ty, &to_ty)\n+        match self.coerce_inner(from_ty, &to_ty) {\n+            Ok(result) => {\n+                self.table.register_infer_ok(result);\n+                true\n+            }\n+            Err(_) => {\n+                // FIXME deal with error\n+                false\n+            }\n+        }\n     }\n \n     /// Merge two types from different branches, with possible coercion.\n     ///\n     /// Mostly this means trying to coerce one to the other, but\n-    ///  - if we have two function types for different functions, we need to\n+    ///  - if we have two function types for different functions or closures, we need to\n     ///    coerce both to function pointers;\n     ///  - if we were concerned with lifetime subtyping, we'd need to look for a\n     ///    least upper bound.\n-    pub(super) fn coerce_merge_branch(&mut self, ty1: &Ty, ty2: &Ty) -> Ty {\n-        if self.coerce(ty1, ty2) {\n-            ty2.clone()\n-        } else if self.coerce(ty2, ty1) {\n+    pub(super) fn coerce_merge_branch(&mut self, id: Option<ExprId>, ty1: &Ty, ty2: &Ty) -> Ty {\n+        let ty1 = self.resolve_ty_shallow(ty1);\n+        let ty2 = self.resolve_ty_shallow(ty2);\n+        // Special case: two function types. Try to coerce both to\n+        // pointers to have a chance at getting a match. See\n+        // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n+        let sig = match (ty1.kind(&Interner), ty2.kind(&Interner)) {\n+            (TyKind::FnDef(..), TyKind::FnDef(..))\n+            | (TyKind::Closure(..), TyKind::FnDef(..))\n+            | (TyKind::FnDef(..), TyKind::Closure(..))\n+            | (TyKind::Closure(..), TyKind::Closure(..)) => {\n+                // FIXME: we're ignoring safety here. To be more correct, if we have one FnDef and one Closure,\n+                // we should be coercing the closure to a fn pointer of the safety of the FnDef\n+                cov_mark::hit!(coerce_fn_reification);\n+                let sig = ty1.callable_sig(self.db).expect(\"FnDef without callable sig\");\n+                Some(sig)\n+            }\n+            _ => None,\n+        };\n+        if let Some(sig) = sig {\n+            let target_ty = TyKind::Function(sig.to_fn_ptr()).intern(&Interner);\n+            let result1 = self.coerce_inner(ty1.clone(), &target_ty);\n+            let result2 = self.coerce_inner(ty2.clone(), &target_ty);\n+            if let (Ok(result1), Ok(result2)) = (result1, result2) {\n+                self.table.register_infer_ok(result1);\n+                self.table.register_infer_ok(result2);\n+                return target_ty;\n+            }\n+        }\n+\n+        // It might not seem like it, but order is important here: ty1 is our\n+        // \"previous\" type, ty2 is the \"new\" one being added. If the previous\n+        // type is a type variable and the new one is `!`, trying it the other\n+        // way around first would mean we make the type variable `!`, instead of\n+        // just marking it as possibly diverging.\n+        if self.coerce(&ty2, &ty1) {\n             ty1.clone()\n+        } else if self.coerce(&ty1, &ty2) {\n+            ty2.clone()\n         } else {\n-            if let (TyKind::FnDef(..), TyKind::FnDef(..)) =\n-                (ty1.kind(&Interner), ty2.kind(&Interner))\n-            {\n-                cov_mark::hit!(coerce_fn_reification);\n-                // Special case: two function types. Try to coerce both to\n-                // pointers to have a chance at getting a match. See\n-                // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n-                let sig1 = ty1.callable_sig(self.db).expect(\"FnDef without callable sig\");\n-                let sig2 = ty2.callable_sig(self.db).expect(\"FnDef without callable sig\");\n-                let ptr_ty1 = TyBuilder::fn_ptr(sig1);\n-                let ptr_ty2 = TyBuilder::fn_ptr(sig2);\n-                self.coerce_merge_branch(&ptr_ty1, &ptr_ty2)\n-            } else {\n-                cov_mark::hit!(coerce_merge_fail_fallback);\n-                ty1.clone()\n+            if let Some(id) = id {\n+                self.result\n+                    .type_mismatches\n+                    .insert(id.into(), TypeMismatch { expected: ty1.clone(), actual: ty2.clone() });\n             }\n+            cov_mark::hit!(coerce_merge_fail_fallback);\n+            ty1.clone()\n         }\n     }\n \n-    fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n-        match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n-            // Never type will make type variable to fallback to Never Type instead of Unknown.\n-            (TyKind::Never, TyKind::InferenceVar(tv, TyVariableKind::General)) => {\n-                self.table.type_variable_table.set_diverging(*tv, true);\n-                return true;\n+    fn coerce_inner(&mut self, from_ty: Ty, to_ty: &Ty) -> InferResult {\n+        if from_ty.is_never() {\n+            // Subtle: If we are coercing from `!` to `?T`, where `?T` is an unbound\n+            // type variable, we want `?T` to fallback to `!` if not\n+            // otherwise constrained. An example where this arises:\n+            //\n+            //     let _: Option<?T> = Some({ return; });\n+            //\n+            // here, we would coerce from `!` to `?T`.\n+            match to_ty.kind(&Interner) {\n+                TyKind::InferenceVar(tv, TyVariableKind::General) => {\n+                    self.table.set_diverging(*tv, true);\n+                }\n+                _ => {}\n             }\n-            (TyKind::Never, _) => return true,\n+            return Ok(InferOk { goals: Vec::new() });\n+        }\n \n-            // Trivial cases, this should go after `never` check to\n-            // avoid infer result type to be never\n-            _ => {\n-                if self.table.unify_inner_trivial(&from_ty, &to_ty, 0) {\n-                    return true;\n-                }\n+        // Consider coercing the subtype to a DST\n+        if let Ok(ret) = self.try_coerce_unsized(&from_ty, &to_ty) {\n+            return Ok(ret);\n+        }\n+\n+        // Examine the supertype and consider auto-borrowing.\n+        match to_ty.kind(&Interner) {\n+            TyKind::Raw(mt, _) => {\n+                return self.coerce_ptr(from_ty, to_ty, *mt);\n             }\n+            TyKind::Ref(mt, _, _) => {\n+                return self.coerce_ref(from_ty, to_ty, *mt);\n+            }\n+            _ => {}\n         }\n \n-        // Pointer weakening and function to pointer\n-        match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n-            // `*mut T` -> `*const T`\n-            (TyKind::Raw(_, inner), TyKind::Raw(m2 @ Mutability::Not, ..)) => {\n-                from_ty = TyKind::Raw(*m2, inner.clone()).intern(&Interner);\n+        match from_ty.kind(&Interner) {\n+            TyKind::FnDef(..) => {\n+                // Function items are coercible to any closure\n+                // type; function pointers are not (that would\n+                // require double indirection).\n+                // Additionally, we permit coercion of function\n+                // items to drop the unsafe qualifier.\n+                self.coerce_from_fn_item(from_ty, to_ty)\n             }\n-            // `&mut T` -> `&T`\n-            (TyKind::Ref(_, lt, inner), TyKind::Ref(m2 @ Mutability::Not, ..)) => {\n-                from_ty = TyKind::Ref(*m2, lt.clone(), inner.clone()).intern(&Interner);\n+            TyKind::Function(from_fn_ptr) => {\n+                // We permit coercion of fn pointers to drop the\n+                // unsafe qualifier.\n+                self.coerce_from_fn_pointer(from_ty.clone(), from_fn_ptr, to_ty)\n             }\n-            // `&T` -> `*const T`\n-            // `&mut T` -> `*mut T`/`*const T`\n-            (TyKind::Ref(.., substs), &TyKind::Raw(m2 @ Mutability::Not, ..))\n-            | (TyKind::Ref(Mutability::Mut, _, substs), &TyKind::Raw(m2, ..)) => {\n-                from_ty = TyKind::Raw(m2, substs.clone()).intern(&Interner);\n+            TyKind::Closure(_, from_substs) => {\n+                // Non-capturing closures are coercible to\n+                // function pointers or unsafe function pointers.\n+                // It cannot convert closures that require unsafe.\n+                self.coerce_closure_to_fn(from_ty.clone(), from_substs, to_ty)\n             }\n+            _ => {\n+                // Otherwise, just use unification rules.\n+                self.table.try_unify(&from_ty, to_ty)\n+            }\n+        }\n+    }\n \n-            // Illegal mutability conversion\n-            (TyKind::Raw(Mutability::Not, ..), TyKind::Raw(Mutability::Mut, ..))\n-            | (TyKind::Ref(Mutability::Not, ..), TyKind::Ref(Mutability::Mut, ..)) => return false,\n+    fn coerce_ptr(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> InferResult {\n+        let (_is_ref, from_mt, from_inner) = match from_ty.kind(&Interner) {\n+            TyKind::Ref(mt, _, ty) => (true, mt, ty),\n+            TyKind::Raw(mt, ty) => (false, mt, ty),\n+            _ => return self.table.try_unify(&from_ty, to_ty),\n+        };\n \n-            // `{function_type}` -> `fn()`\n-            (TyKind::FnDef(..), TyKind::Function { .. }) => match from_ty.callable_sig(self.db) {\n-                None => return false,\n-                Some(sig) => {\n-                    from_ty = TyBuilder::fn_ptr(sig);\n-                }\n+        coerce_mutabilities(*from_mt, to_mt)?;\n+\n+        // Check that the types which they point at are compatible.\n+        let from_raw = TyKind::Raw(to_mt, from_inner.clone()).intern(&Interner);\n+        // FIXME: behavior differs based on is_ref once we're computing adjustments\n+        self.table.try_unify(&from_raw, to_ty)\n+    }\n+\n+    /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n+    /// To match `A` with `B`, autoderef will be performed,\n+    /// calling `deref`/`deref_mut` where necessary.\n+    fn coerce_ref(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> InferResult {\n+        match from_ty.kind(&Interner) {\n+            TyKind::Ref(mt, _, _) => {\n+                coerce_mutabilities(*mt, to_mt)?;\n+            }\n+            _ => return self.table.try_unify(&from_ty, to_ty),\n+        };\n+\n+        // NOTE: this code is mostly copied and adapted from rustc, and\n+        // currently more complicated than necessary, carrying errors around\n+        // etc.. This complication will become necessary when we actually track\n+        // details of coercion errors though, so I think it's useful to leave\n+        // the structure like it is.\n+\n+        let canonicalized = self.canonicalize(from_ty.clone());\n+        let autoderef = autoderef::autoderef(\n+            self.db,\n+            self.resolver.krate(),\n+            InEnvironment {\n+                goal: canonicalized.value.clone(),\n+                environment: self.trait_env.env.clone(),\n             },\n+        );\n+        let mut first_error = None;\n+        let mut found = None;\n \n-            (TyKind::Closure(.., substs), TyKind::Function { .. }) => {\n-                from_ty = substs.at(&Interner, 0).assert_ty_ref(&Interner).clone();\n+        for (autoderefs, referent_ty) in autoderef.enumerate() {\n+            if autoderefs == 0 {\n+                // Don't let this pass, otherwise it would cause\n+                // &T to autoref to &&T.\n+                continue;\n             }\n \n-            _ => {}\n+            let referent_ty = canonicalized.decanonicalize_ty(referent_ty.value);\n+\n+            // At this point, we have deref'd `a` to `referent_ty`.  So\n+            // imagine we are coercing from `&'a mut Vec<T>` to `&'b mut [T]`.\n+            // In the autoderef loop for `&'a mut Vec<T>`, we would get\n+            // three callbacks:\n+            //\n+            // - `&'a mut Vec<T>` -- 0 derefs, just ignore it\n+            // - `Vec<T>` -- 1 deref\n+            // - `[T]` -- 2 deref\n+            //\n+            // At each point after the first callback, we want to\n+            // check to see whether this would match out target type\n+            // (`&'b mut [T]`) if we autoref'd it. We can't just\n+            // compare the referent types, though, because we still\n+            // have to consider the mutability. E.g., in the case\n+            // we've been considering, we have an `&mut` reference, so\n+            // the `T` in `[T]` needs to be unified with equality.\n+            //\n+            // Therefore, we construct reference types reflecting what\n+            // the types will be after we do the final auto-ref and\n+            // compare those. Note that this means we use the target\n+            // mutability [1], since it may be that we are coercing\n+            // from `&mut T` to `&U`.\n+            let lt = static_lifetime(); // FIXME: handle lifetimes correctly, see rustc\n+            let derefd_from_ty = TyKind::Ref(to_mt, lt, referent_ty).intern(&Interner);\n+            match self.table.try_unify(&derefd_from_ty, to_ty) {\n+                Ok(result) => {\n+                    found = Some(result);\n+                    break;\n+                }\n+                Err(err) => {\n+                    if first_error.is_none() {\n+                        first_error = Some(err);\n+                    }\n+                }\n+            }\n         }\n \n-        if let Some(ret) = self.try_coerce_unsized(&from_ty, &to_ty) {\n-            return ret;\n+        // Extract type or return an error. We return the first error\n+        // we got, which should be from relating the \"base\" type\n+        // (e.g., in example above, the failure from relating `Vec<T>`\n+        // to the target type), since that should be the least\n+        // confusing.\n+        let result = match found {\n+            Some(d) => d,\n+            None => {\n+                let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n+                return Err(err);\n+            }\n+        };\n+\n+        Ok(result)\n+    }\n+\n+    /// Attempts to coerce from the type of a Rust function item into a function pointer.\n+    fn coerce_from_fn_item(&mut self, from_ty: Ty, to_ty: &Ty) -> InferResult {\n+        match to_ty.kind(&Interner) {\n+            TyKind::Function(_) => {\n+                let from_sig = from_ty.callable_sig(self.db).expect(\"FnDef had no sig\");\n+\n+                // FIXME check ABI: Intrinsics are not coercible to function pointers\n+                // FIXME Safe `#[target_feature]` functions are not assignable to safe fn pointers (RFC 2396)\n+\n+                // FIXME rustc normalizes assoc types in the sig here, not sure if necessary\n+\n+                let from_sig = from_sig.to_fn_ptr();\n+                let from_fn_pointer = TyKind::Function(from_sig.clone()).intern(&Interner);\n+                let ok = self.coerce_from_safe_fn(from_fn_pointer, &from_sig, to_ty)?;\n+\n+                Ok(ok)\n+            }\n+            _ => self.table.try_unify(&from_ty, to_ty),\n         }\n+    }\n+\n+    fn coerce_from_fn_pointer(\n+        &mut self,\n+        from_ty: Ty,\n+        from_f: &FnPointer,\n+        to_ty: &Ty,\n+    ) -> InferResult {\n+        self.coerce_from_safe_fn(from_ty, from_f, to_ty)\n+    }\n \n-        // Auto Deref if cannot coerce\n-        match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n-            // FIXME: DerefMut\n-            (TyKind::Ref(.., st1), TyKind::Ref(.., st2)) => {\n-                self.unify_autoderef_behind_ref(st1, st2)\n+    fn coerce_from_safe_fn(\n+        &mut self,\n+        from_ty: Ty,\n+        from_fn_ptr: &FnPointer,\n+        to_ty: &Ty,\n+    ) -> InferResult {\n+        if let TyKind::Function(to_fn_ptr) = to_ty.kind(&Interner) {\n+            if let (chalk_ir::Safety::Safe, chalk_ir::Safety::Unsafe) =\n+                (from_fn_ptr.sig.safety, to_fn_ptr.sig.safety)\n+            {\n+                let from_unsafe =\n+                    TyKind::Function(safe_to_unsafe_fn_ty(from_fn_ptr.clone())).intern(&Interner);\n+                return self.table.try_unify(&from_unsafe, to_ty);\n             }\n+        }\n+        self.table.try_unify(&from_ty, to_ty)\n+    }\n \n-            // Otherwise, normal unify\n-            _ => self.unify(&from_ty, to_ty),\n+    /// Attempts to coerce from the type of a non-capturing closure into a\n+    /// function pointer.\n+    fn coerce_closure_to_fn(\n+        &mut self,\n+        from_ty: Ty,\n+        from_substs: &Substitution,\n+        to_ty: &Ty,\n+    ) -> InferResult {\n+        match to_ty.kind(&Interner) {\n+            TyKind::Function(fn_ty) /* if from_substs is non-capturing (FIXME) */ => {\n+                // We coerce the closure, which has fn type\n+                //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n+                // to\n+                //     `fn(arg0,arg1,...) -> _`\n+                // or\n+                //     `unsafe fn(arg0,arg1,...) -> _`\n+                let safety = fn_ty.sig.safety;\n+                let pointer_ty = coerce_closure_fn_ty(from_substs, safety);\n+                self.table.try_unify(&pointer_ty, to_ty)\n+            }\n+            _ => self.table.try_unify(&from_ty, to_ty),\n         }\n     }\n \n     /// Coerce a type using `from_ty: CoerceUnsized<ty_ty>`\n     ///\n     /// See: https://doc.rust-lang.org/nightly/std/marker/trait.CoerceUnsized.html\n-    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> Option<bool> {\n+    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> InferResult {\n+        // These 'if' statements require some explanation.\n+        // The `CoerceUnsized` trait is special - it is only\n+        // possible to write `impl CoerceUnsized<B> for A` where\n+        // A and B have 'matching' fields. This rules out the following\n+        // two types of blanket impls:\n+        //\n+        // `impl<T> CoerceUnsized<T> for SomeType`\n+        // `impl<T> CoerceUnsized<SomeType> for T`\n+        //\n+        // Both of these trigger a special `CoerceUnsized`-related error (E0376)\n+        //\n+        // We can take advantage of this fact to avoid performing unecessary work.\n+        // If either `source` or `target` is a type variable, then any applicable impl\n+        // would need to be generic over the self-type (`impl<T> CoerceUnsized<SomeType> for T`)\n+        // or generic over the `CoerceUnsized` type parameter (`impl<T> CoerceUnsized<T> for\n+        // SomeType`).\n+        //\n+        // However, these are exactly the kinds of impls which are forbidden by\n+        // the compiler! Therefore, we can be sure that coercion will always fail\n+        // when either the source or target type is a type variable. This allows us\n+        // to skip performing any trait selection, and immediately bail out.\n+        if from_ty.is_ty_var() {\n+            return Err(TypeError);\n+        }\n+        if to_ty.is_ty_var() {\n+            return Err(TypeError);\n+        }\n+\n+        // Handle reborrows before trying to solve `Source: CoerceUnsized<Target>`.\n+        let coerce_from = match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n+            (TyKind::Ref(from_mt, _, from_inner), TyKind::Ref(to_mt, _, _)) => {\n+                coerce_mutabilities(*from_mt, *to_mt)?;\n+\n+                let lt = static_lifetime();\n+                TyKind::Ref(*to_mt, lt, from_inner.clone()).intern(&Interner)\n+            }\n+            (TyKind::Ref(from_mt, _, from_inner), TyKind::Raw(to_mt, _)) => {\n+                coerce_mutabilities(*from_mt, *to_mt)?;\n+\n+                TyKind::Raw(*to_mt, from_inner.clone()).intern(&Interner)\n+            }\n+            _ => from_ty.clone(),\n+        };\n+\n         let krate = self.resolver.krate().unwrap();\n         let coerce_unsized_trait = match self.db.lang_item(krate, \"coerce_unsized\".into()) {\n             Some(LangItemTarget::TraitId(trait_)) => trait_,\n-            _ => return None,\n+            _ => return Err(TypeError),\n         };\n \n         let trait_ref = {\n             let b = TyBuilder::trait_ref(self.db, coerce_unsized_trait);\n             if b.remaining() != 2 {\n                 // The CoerceUnsized trait should have two generic params: Self and T.\n-                return None;\n+                return Err(TypeError);\n             }\n-            b.push(from_ty.clone()).push(to_ty.clone()).build()\n+            b.push(coerce_from.clone()).push(to_ty.clone()).build()\n         };\n \n-        let goal = InEnvironment::new(&self.trait_env.env, trait_ref.cast(&Interner));\n+        let goal: InEnvironment<DomainGoal> =\n+            InEnvironment::new(&self.trait_env.env, trait_ref.cast(&Interner));\n \n-        let canonicalizer = self.canonicalizer();\n-        let canonicalized = canonicalizer.canonicalize_obligation(goal);\n+        let canonicalized = self.canonicalize(goal);\n \n-        let solution = self.db.trait_solve(krate, canonicalized.value.clone())?;\n+        // FIXME: rustc's coerce_unsized is more specialized -- it only tries to\n+        // solve `CoerceUnsized` and `Unsize` goals at this point and leaves the\n+        // rest for later. Also, there's some logic about sized type variables.\n+        // Need to find out in what cases this is necessary\n+        let solution = self\n+            .db\n+            .trait_solve(krate, canonicalized.value.clone().cast(&Interner))\n+            .ok_or(TypeError)?;\n \n         match solution {\n             Solution::Unique(v) => {\n                 canonicalized.apply_solution(\n-                    self,\n+                    &mut self.table,\n                     Canonical {\n                         binders: v.binders,\n                         // FIXME handle constraints\n                         value: v.value.subst,\n                     },\n                 );\n             }\n-            _ => return None,\n+            // FIXME: should we accept ambiguous results here?\n+            _ => return Err(TypeError),\n         };\n \n-        Some(true)\n+        Ok(InferOk { goals: Vec::new() })\n     }\n+}\n \n-    /// Unify `from_ty` to `to_ty` with optional auto Deref\n-    ///\n-    /// Note that the parameters are already stripped the outer reference.\n-    fn unify_autoderef_behind_ref(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n-        let canonicalized = self.canonicalizer().canonicalize_ty(from_ty.clone());\n-        let to_ty = self.resolve_ty_shallow(&to_ty);\n-        // FIXME: Auto DerefMut\n-        for derefed_ty in autoderef::autoderef(\n-            self.db,\n-            self.resolver.krate(),\n-            InEnvironment {\n-                goal: canonicalized.value.clone(),\n-                environment: self.trait_env.env.clone(),\n-            },\n-        ) {\n-            let derefed_ty = canonicalized.decanonicalize_ty(derefed_ty.value);\n-            let from_ty = self.resolve_ty_shallow(&derefed_ty);\n-            // Stop when constructor matches.\n-            if from_ty.equals_ctor(&to_ty) {\n-                // It will not recurse to `coerce`.\n-                return self.table.unify(&from_ty, &to_ty);\n-            } else if self.table.unify_inner_trivial(&derefed_ty, &to_ty, 0) {\n-                return true;\n-            }\n-        }\n+fn coerce_closure_fn_ty(closure_substs: &Substitution, safety: chalk_ir::Safety) -> Ty {\n+    let closure_sig = closure_substs.at(&Interner, 0).assert_ty_ref(&Interner).clone();\n+    match closure_sig.kind(&Interner) {\n+        TyKind::Function(fn_ty) => TyKind::Function(FnPointer {\n+            num_binders: fn_ty.num_binders,\n+            sig: FnSig { safety, ..fn_ty.sig },\n+            substitution: fn_ty.substitution.clone(),\n+        })\n+        .intern(&Interner),\n+        _ => TyKind::Error.intern(&Interner),\n+    }\n+}\n+\n+fn safe_to_unsafe_fn_ty(fn_ty: FnPointer) -> FnPointer {\n+    FnPointer {\n+        num_binders: fn_ty.num_binders,\n+        sig: FnSig { safety: chalk_ir::Safety::Unsafe, ..fn_ty.sig },\n+        substitution: fn_ty.substitution,\n+    }\n+}\n \n-        false\n+fn coerce_mutabilities(from: Mutability, to: Mutability) -> Result<(), TypeError> {\n+    match (from, to) {\n+        (Mutability::Mut, Mutability::Mut)\n+        | (Mutability::Mut, Mutability::Not)\n+        | (Mutability::Not, Mutability::Not) => Ok(()),\n+        (Mutability::Not, Mutability::Mut) => Err(TypeError),\n     }\n }"}, {"sha": "08c05c67cc906261d022b6cbee3c1fcd5e9bf135", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 84, "deletions": 58, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -35,39 +35,43 @@ use super::{\n impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(tgt_expr, expected);\n-        if ty.is_never() {\n+        if self.resolve_ty_shallow(&ty).is_never() {\n             // Any expression that produces a value of type `!` must have diverged\n             self.diverges = Diverges::Always;\n         }\n-        let could_unify = self.unify(&ty, &expected.ty);\n-        if !could_unify {\n-            self.result.type_mismatches.insert(\n-                tgt_expr.into(),\n-                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n-            );\n+        if let Some(expected_ty) = expected.only_has_type(&mut self.table) {\n+            let could_unify = self.unify(&ty, &expected_ty);\n+            if !could_unify {\n+                self.result.type_mismatches.insert(\n+                    tgt_expr.into(),\n+                    TypeMismatch { expected: expected_ty.clone(), actual: ty.clone() },\n+                );\n+            }\n         }\n-        self.resolve_ty_as_possible(ty)\n+        ty\n     }\n \n     /// Infer type of expression with possibly implicit coerce to the expected type.\n     /// Return the type after possible coercion.\n     pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(expr, &expected);\n-        let ty = if !self.coerce(&ty, &expected.coercion_target()) {\n-            self.result.type_mismatches.insert(\n-                expr.into(),\n-                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n-            );\n-            // Return actual type when type mismatch.\n-            // This is needed for diagnostic when return type mismatch.\n-            ty\n-        } else if expected.coercion_target().is_unknown() {\n-            ty\n+        let ty = if let Some(target) = expected.only_has_type(&mut self.table) {\n+            if !self.coerce(&ty, &target) {\n+                self.result.type_mismatches.insert(\n+                    expr.into(),\n+                    TypeMismatch { expected: target.clone(), actual: ty.clone() },\n+                );\n+                // Return actual type when type mismatch.\n+                // This is needed for diagnostic when return type mismatch.\n+                ty\n+            } else {\n+                target.clone()\n+            }\n         } else {\n-            expected.ty.clone()\n+            ty\n         };\n \n-        self.resolve_ty_as_possible(ty)\n+        ty\n     }\n \n     fn callable_sig_from_fn_trait(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n@@ -98,10 +102,10 @@ impl<'a> InferenceContext<'a> {\n             goal: projection.trait_ref(self.db).cast(&Interner),\n             environment: trait_env,\n         };\n-        let canonical = self.canonicalizer().canonicalize_obligation(obligation.clone());\n-        if self.db.trait_solve(krate, canonical.value).is_some() {\n+        let canonical = self.canonicalize(obligation.clone());\n+        if self.db.trait_solve(krate, canonical.value.cast(&Interner)).is_some() {\n             self.push_obligation(obligation.goal);\n-            let return_ty = self.normalize_projection_ty(projection);\n+            let return_ty = self.table.normalize_projection_ty(projection);\n             Some((arg_tys, return_ty))\n         } else {\n             None\n@@ -131,17 +135,21 @@ impl<'a> InferenceContext<'a> {\n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut both_arms_diverge = Diverges::Always;\n \n+                let mut result_ty = self.table.new_type_var();\n                 let then_ty = self.infer_expr_inner(*then_branch, &expected);\n                 both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n+                result_ty = self.coerce_merge_branch(Some(*then_branch), &result_ty, &then_ty);\n                 let else_ty = match else_branch {\n                     Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n                     None => TyBuilder::unit(),\n                 };\n                 both_arms_diverge &= self.diverges;\n+                // FIXME: create a synthetic `else {}` so we have something to refer to here instead of None?\n+                result_ty = self.coerce_merge_branch(*else_branch, &result_ty, &else_ty);\n \n                 self.diverges = condition_diverges | both_arms_diverge;\n \n-                self.coerce_merge_branch(&then_ty, &else_ty)\n+                result_ty\n             }\n             Expr::Block { statements, tail, label, id: _ } => {\n                 let old_resolver = mem::replace(\n@@ -277,12 +285,13 @@ impl<'a> InferenceContext<'a> {\n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n                 // infer the body.\n-                self.coerce(&closure_ty, &expected.ty);\n+                if let Some(t) = expected.only_has_type(&mut self.table) {\n+                    self.coerce(&closure_ty, &t);\n+                }\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n-                    let resolved = self.resolve_ty_as_possible(arg_ty);\n-                    self.infer_pat(*arg_pat, &resolved, BindingMode::default());\n+                    self.infer_pat(*arg_pat, &arg_ty, BindingMode::default());\n                 }\n \n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n@@ -297,13 +306,13 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n-                let canonicalized = self.canonicalizer().canonicalize_ty(callee_ty.clone());\n+                let canonicalized = self.canonicalize(callee_ty.clone());\n                 let mut derefs = autoderef(\n                     self.db,\n                     self.resolver.krate(),\n                     InEnvironment {\n                         goal: canonicalized.value.clone(),\n-                        environment: self.trait_env.env.clone(),\n+                        environment: self.table.trait_env.env.clone(),\n                     },\n                 );\n                 let (param_tys, ret_ty): (Vec<Ty>, Ty) = derefs\n@@ -350,7 +359,7 @@ impl<'a> InferenceContext<'a> {\n \n                     let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n                     all_arms_diverge &= self.diverges;\n-                    result_ty = self.coerce_merge_branch(&result_ty, &arm_ty);\n+                    result_ty = self.coerce_merge_branch(Some(arm.expr), &result_ty, &arm_ty);\n                 }\n \n                 self.diverges = matchee_diverges | all_arms_diverge;\n@@ -364,20 +373,21 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Continue { .. } => TyKind::Never.intern(&Interner),\n             Expr::Break { expr, label } => {\n-                let val_ty = if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::none())\n-                } else {\n-                    TyBuilder::unit()\n-                };\n-\n                 let last_ty =\n                     if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n                         ctxt.break_ty.clone()\n                     } else {\n                         self.err_ty()\n                     };\n \n-                let merged_type = self.coerce_merge_branch(&last_ty, &val_ty);\n+                let val_ty = if let Some(expr) = expr {\n+                    self.infer_expr(*expr, &Expectation::none())\n+                } else {\n+                    TyBuilder::unit()\n+                };\n+\n+                // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n+                let merged_type = self.coerce_merge_branch(*expr, &last_ty, &val_ty);\n \n                 if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n                     ctxt.break_ty = merged_type;\n@@ -411,7 +421,9 @@ impl<'a> InferenceContext<'a> {\n                     self.write_variant_resolution(tgt_expr.into(), variant);\n                 }\n \n-                self.unify(&ty, &expected.ty);\n+                if let Some(t) = expected.only_has_type(&mut self.table) {\n+                    self.unify(&ty, &t);\n+                }\n \n                 let substs = ty\n                     .as_adt()\n@@ -442,7 +454,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Field { expr, name } => {\n                 let receiver_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                let canonicalized = self.canonicalizer().canonicalize_ty(receiver_ty);\n+                let canonicalized = self.canonicalize(receiver_ty);\n                 let ty = autoderef::autoderef(\n                     self.db,\n                     self.resolver.krate(),\n@@ -514,22 +526,25 @@ impl<'a> InferenceContext<'a> {\n                 self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok())\n             }\n             Expr::Cast { expr, type_ref } => {\n+                // FIXME: propagate the \"castable to\" expectation (and find a test case that shows this is necessary)\n                 let _inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let cast_ty = self.make_ty(type_ref);\n                 // FIXME check the cast...\n                 cast_ty\n             }\n             Expr::Ref { expr, rawness, mutability } => {\n                 let mutability = lower_to_chalk_mutability(*mutability);\n-                let expectation = if let Some((exp_inner, exp_rawness, exp_mutability)) =\n-                    &expected.ty.as_reference_or_ptr()\n+                let expectation = if let Some((exp_inner, exp_rawness, exp_mutability)) = expected\n+                    .only_has_type(&mut self.table)\n+                    .as_ref()\n+                    .and_then(|t| t.as_reference_or_ptr())\n                 {\n-                    if *exp_mutability == Mutability::Mut && mutability == Mutability::Not {\n-                        // FIXME: throw type error - expected mut reference but found shared ref,\n+                    if exp_mutability == Mutability::Mut && mutability == Mutability::Not {\n+                        // FIXME: record type error - expected mut reference but found shared ref,\n                         // which cannot be coerced\n                     }\n-                    if *exp_rawness == Rawness::Ref && *rawness == Rawness::RawPtr {\n-                        // FIXME: throw type error - expected reference but found ptr,\n+                    if exp_rawness == Rawness::Ref && *rawness == Rawness::RawPtr {\n+                        // FIXME: record type error - expected reference but found ptr,\n                         // which cannot be coerced\n                     }\n                     Expectation::rvalue_hint(Ty::clone(exp_inner))\n@@ -556,10 +571,11 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::UnaryOp { expr, op } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n+                let inner_ty = self.resolve_ty_shallow(&inner_ty);\n                 match op {\n                     UnaryOp::Deref => match self.resolver.krate() {\n                         Some(krate) => {\n-                            let canonicalized = self.canonicalizer().canonicalize_ty(inner_ty);\n+                            let canonicalized = self.canonicalize(inner_ty);\n                             match autoderef::deref(\n                                 self.db,\n                                 krate,\n@@ -612,8 +628,10 @@ impl<'a> InferenceContext<'a> {\n                         _ => Expectation::none(),\n                     };\n                     let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n+                    let lhs_ty = self.resolve_ty_shallow(&lhs_ty);\n                     let rhs_expectation = op::binary_op_rhs_expectation(*op, lhs_ty.clone());\n                     let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation));\n+                    let rhs_ty = self.resolve_ty_shallow(&rhs_ty);\n \n                     let ret = op::binary_op_return_ty(*op, lhs_ty.clone(), rhs_ty.clone());\n \n@@ -676,7 +694,7 @@ impl<'a> InferenceContext<'a> {\n                 if let (Some(index_trait), Some(krate)) =\n                     (self.resolve_ops_index(), self.resolver.krate())\n                 {\n-                    let canonicalized = self.canonicalizer().canonicalize_ty(base_ty);\n+                    let canonicalized = self.canonicalize(base_ty);\n                     let self_ty = method_resolution::resolve_indexing_op(\n                         self.db,\n                         &canonicalized.value,\n@@ -696,8 +714,12 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             Expr::Tuple { exprs } => {\n-                let mut tys = match expected.ty.kind(&Interner) {\n-                    TyKind::Tuple(_, substs) => substs\n+                let mut tys = match expected\n+                    .only_has_type(&mut self.table)\n+                    .as_ref()\n+                    .map(|t| t.kind(&Interner))\n+                {\n+                    Some(TyKind::Tuple(_, substs)) => substs\n                         .iter(&Interner)\n                         .map(|a| a.assert_ty_ref(&Interner).clone())\n                         .chain(repeat_with(|| self.table.new_type_var()))\n@@ -713,14 +735,16 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Tuple(tys.len(), Substitution::from_iter(&Interner, tys)).intern(&Interner)\n             }\n             Expr::Array(array) => {\n-                let elem_ty = match expected.ty.kind(&Interner) {\n-                    TyKind::Array(st, _) | TyKind::Slice(st) => st.clone(),\n-                    _ => self.table.new_type_var(),\n-                };\n+                let elem_ty =\n+                    match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(&Interner)) {\n+                        Some(TyKind::Array(st, _)) | Some(TyKind::Slice(st)) => st.clone(),\n+                        _ => self.table.new_type_var(),\n+                    };\n \n                 let len = match array {\n                     Array::ElementList(items) => {\n                         for expr in items.iter() {\n+                            // FIXME: use CoerceMany (coerce_merge_branch)\n                             self.infer_expr_coerce(*expr, &Expectation::has_type(elem_ty.clone()));\n                         }\n                         Some(items.len() as u64)\n@@ -785,7 +809,6 @@ impl<'a> InferenceContext<'a> {\n         };\n         // use a new type variable if we got unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n-        let ty = self.resolve_ty_as_possible(ty);\n         self.write_expr_ty(tgt_expr, ty.clone());\n         ty\n     }\n@@ -813,7 +836,6 @@ impl<'a> InferenceContext<'a> {\n                         }\n                     }\n \n-                    let ty = self.resolve_ty_as_possible(ty);\n                     self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr { expr, .. } => {\n@@ -836,7 +858,9 @@ impl<'a> InferenceContext<'a> {\n                 // we don't even make an attempt at coercion\n                 self.table.new_maybe_never_var()\n             } else {\n-                self.coerce(&TyBuilder::unit(), &expected.coercion_target());\n+                if let Some(t) = expected.only_has_type(&mut self.table) {\n+                    self.coerce(&TyBuilder::unit(), &t);\n+                }\n                 TyBuilder::unit()\n             }\n         };\n@@ -852,7 +876,7 @@ impl<'a> InferenceContext<'a> {\n         generic_args: Option<&GenericArgs>,\n     ) -> Ty {\n         let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n-        let canonicalized_receiver = self.canonicalizer().canonicalize_ty(receiver_ty.clone());\n+        let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n \n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n@@ -891,7 +915,8 @@ impl<'a> InferenceContext<'a> {\n         };\n         // Apply autoref so the below unification works correctly\n         // FIXME: return correct autorefs from lookup_method\n-        let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n+        let actual_receiver_ty = match self.resolve_ty_shallow(&expected_receiver_ty).as_reference()\n+        {\n             Some((_, lifetime, mutability)) => {\n                 TyKind::Ref(mutability, lifetime, derefed_receiver_ty).intern(&Interner)\n             }\n@@ -971,6 +996,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn register_obligations_for_call(&mut self, callable_ty: &Ty) {\n+        let callable_ty = self.resolve_ty_shallow(&callable_ty);\n         if let TyKind::FnDef(fn_def, parameters) = callable_ty.kind(&Interner) {\n             let def: CallableDefId = from_chalk(self.db, *fn_def);\n             let generic_predicates = self.db.generic_predicates(def.into());"}, {"sha": "9c8e3b6aea99dd02b607524d5a08a77f9e5538dd", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -94,14 +94,15 @@ impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_pat(\n         &mut self,\n         pat: PatId,\n-        mut expected: &Ty,\n+        expected: &Ty,\n         mut default_bm: BindingMode,\n     ) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n+        let mut expected = self.resolve_ty_shallow(expected);\n \n         if is_non_ref_pat(&body, pat) {\n             while let Some((inner, _lifetime, mutability)) = expected.as_reference() {\n-                expected = inner;\n+                expected = self.resolve_ty_shallow(inner);\n                 default_bm = match default_bm {\n                     BindingMode::Move => BindingMode::Ref(mutability),\n                     BindingMode::Ref(Mutability::Not) => BindingMode::Ref(Mutability::Not),\n@@ -147,9 +148,9 @@ impl<'a> InferenceContext<'a> {\n             }\n             Pat::Or(ref pats) => {\n                 if let Some((first_pat, rest)) = pats.split_first() {\n-                    let ty = self.infer_pat(*first_pat, expected, default_bm);\n+                    let ty = self.infer_pat(*first_pat, &expected, default_bm);\n                     for pat in rest {\n-                        self.infer_pat(*pat, expected, default_bm);\n+                        self.infer_pat(*pat, &expected, default_bm);\n                     }\n                     ty\n                 } else {\n@@ -173,13 +174,13 @@ impl<'a> InferenceContext<'a> {\n             Pat::TupleStruct { path: p, args: subpats, ellipsis } => self.infer_tuple_struct_pat(\n                 p.as_deref(),\n                 subpats,\n-                expected,\n+                &expected,\n                 default_bm,\n                 pat,\n                 *ellipsis,\n             ),\n             Pat::Record { path: p, args: fields, ellipsis: _ } => {\n-                self.infer_record_pat(p.as_deref(), fields, expected, default_bm, pat)\n+                self.infer_record_pat(p.as_deref(), fields, &expected, default_bm, pat)\n             }\n             Pat::Path(path) => {\n                 // FIXME use correct resolver for the surrounding expression\n@@ -193,7 +194,7 @@ impl<'a> InferenceContext<'a> {\n                     BindingMode::convert(*mode)\n                 };\n                 let inner_ty = if let Some(subpat) = subpat {\n-                    self.infer_pat(*subpat, expected, default_bm)\n+                    self.infer_pat(*subpat, &expected, default_bm)\n                 } else {\n                     expected.clone()\n                 };\n@@ -206,7 +207,6 @@ impl<'a> InferenceContext<'a> {\n                     }\n                     BindingMode::Move => inner_ty.clone(),\n                 };\n-                let bound_ty = self.resolve_ty_as_possible(bound_ty);\n                 self.write_pat_ty(pat, bound_ty);\n                 return inner_ty;\n             }\n@@ -265,13 +265,12 @@ impl<'a> InferenceContext<'a> {\n         };\n         // use a new type variable if we got error type here\n         let ty = self.insert_type_vars_shallow(ty);\n-        if !self.unify(&ty, expected) {\n+        if !self.unify(&ty, &expected) {\n             self.result.type_mismatches.insert(\n                 pat.into(),\n                 TypeMismatch { expected: expected.clone(), actual: ty.clone() },\n             );\n         }\n-        let ty = self.resolve_ty_as_possible(ty);\n         self.write_pat_ty(pat, ty.clone());\n         ty\n     }"}, {"sha": "14c99eafd31bcf82644e179454ceac417430f7b7", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -65,7 +65,6 @@ impl<'a> InferenceContext<'a> {\n         let typable: ValueTyDefId = match value {\n             ValueNs::LocalBinding(pat) => {\n                 let ty = self.result.type_of_pat.get(pat)?.clone();\n-                let ty = self.resolve_ty_as_possible(ty);\n                 return Some(ty);\n             }\n             ValueNs::FunctionId(it) => it.into(),\n@@ -218,14 +217,14 @@ impl<'a> InferenceContext<'a> {\n             return Some(result);\n         }\n \n-        let canonical_ty = self.canonicalizer().canonicalize_ty(ty.clone());\n+        let canonical_ty = self.canonicalize(ty.clone());\n         let krate = self.resolver.krate()?;\n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n         method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n             self.db,\n-            self.trait_env.clone(),\n+            self.table.trait_env.clone(),\n             krate,\n             &traits_in_scope,\n             None,\n@@ -275,6 +274,7 @@ impl<'a> InferenceContext<'a> {\n         name: &Name,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substitution>)> {\n+        let ty = self.resolve_ty_shallow(ty);\n         let (enum_id, subst) = match ty.as_adt() {\n             Some((AdtId::EnumId(e), subst)) => (e, subst),\n             _ => return None,"}, {"sha": "21d3fb54e9de2938d401ce83e223355e67660d49", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 382, "deletions": 479, "changes": 861, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -1,177 +1,95 @@\n //! Unification and canonicalization logic.\n \n-use std::borrow::Cow;\n+use std::{fmt, mem, sync::Arc};\n \n use chalk_ir::{\n-    cast::Cast, fold::Fold, interner::HasInterner, FloatTy, IntTy, TyVariableKind, UniverseIndex,\n-    VariableKind,\n+    cast::Cast, fold::Fold, interner::HasInterner, zip::Zip, FloatTy, IntTy, TyVariableKind,\n+    UniverseIndex,\n };\n-use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n+use chalk_solve::infer::ParameterEnaVariableExt;\n+use ena::unify::UnifyKey;\n \n-use super::{DomainGoal, InferenceContext};\n+use super::{InferOk, InferResult, InferenceContext, TypeError};\n use crate::{\n-    fold_tys, static_lifetime, AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds,\n-    DebruijnIndex, FnPointer, FnSubst, InEnvironment, InferenceVar, Interner, Scalar, Substitution,\n-    Ty, TyExt, TyKind, WhereClause,\n+    db::HirDatabase, fold_tys, static_lifetime, AliasEq, AliasTy, BoundVar, Canonical,\n+    DebruijnIndex, GenericArg, Goal, Guidance, InEnvironment, InferenceVar, Interner, ProjectionTy,\n+    Scalar, Solution, Substitution, TraitEnvironment, Ty, TyKind, VariableKind,\n };\n \n impl<'a> InferenceContext<'a> {\n-    pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b>\n+    pub(super) fn canonicalize<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n+        &mut self,\n+        t: T,\n+    ) -> Canonicalized<T::Result>\n     where\n-        'a: 'b,\n+        T::Result: HasInterner<Interner = Interner>,\n     {\n-        Canonicalizer { ctx: self, free_vars: Vec::new(), var_stack: Vec::new() }\n+        // try to resolve obligations before canonicalizing, since this might\n+        // result in new knowledge about variables\n+        self.resolve_obligations_as_possible();\n+        self.table.canonicalize(t)\n     }\n }\n \n-pub(super) struct Canonicalizer<'a, 'b>\n-where\n-    'a: 'b,\n-{\n-    ctx: &'b mut InferenceContext<'a>,\n-    free_vars: Vec<(InferenceVar, TyVariableKind)>,\n-    /// A stack of type variables that is used to detect recursive types (which\n-    /// are an error, but we need to protect against them to avoid stack\n-    /// overflows).\n-    var_stack: Vec<TypeVarId>,\n-}\n-\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub(super) struct Canonicalized<T>\n where\n     T: HasInterner<Interner = Interner>,\n {\n     pub(super) value: Canonical<T>,\n-    free_vars: Vec<(InferenceVar, TyVariableKind)>,\n-}\n-\n-impl<'a, 'b> Canonicalizer<'a, 'b> {\n-    fn add(&mut self, free_var: InferenceVar, kind: TyVariableKind) -> usize {\n-        self.free_vars.iter().position(|&(v, _)| v == free_var).unwrap_or_else(|| {\n-            let next_index = self.free_vars.len();\n-            self.free_vars.push((free_var, kind));\n-            next_index\n-        })\n-    }\n-\n-    fn do_canonicalize<T: Fold<Interner, Result = T> + HasInterner<Interner = Interner>>(\n-        &mut self,\n-        t: T,\n-        binders: DebruijnIndex,\n-    ) -> T {\n-        fold_tys(\n-            t,\n-            |ty, binders| match ty.kind(&Interner) {\n-                &TyKind::InferenceVar(var, kind) => {\n-                    let inner = from_inference_var(var);\n-                    if self.var_stack.contains(&inner) {\n-                        // recursive type\n-                        return self.ctx.table.type_variable_table.fallback_value(var, kind);\n-                    }\n-                    if let Some(known_ty) =\n-                        self.ctx.table.var_unification_table.inlined_probe_value(inner).known()\n-                    {\n-                        self.var_stack.push(inner);\n-                        let result = self.do_canonicalize(known_ty.clone(), binders);\n-                        self.var_stack.pop();\n-                        result\n-                    } else {\n-                        let root = self.ctx.table.var_unification_table.find(inner);\n-                        let position = self.add(to_inference_var(root), kind);\n-                        TyKind::BoundVar(BoundVar::new(binders, position)).intern(&Interner)\n-                    }\n-                }\n-                _ => ty,\n-            },\n-            binders,\n-        )\n-    }\n-\n-    fn into_canonicalized<T: HasInterner<Interner = Interner>>(\n-        self,\n-        result: T,\n-    ) -> Canonicalized<T> {\n-        let kinds = self\n-            .free_vars\n-            .iter()\n-            .map(|&(_, k)| chalk_ir::WithKind::new(VariableKind::Ty(k), UniverseIndex::ROOT));\n-        Canonicalized {\n-            value: Canonical {\n-                value: result,\n-                binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n-            },\n-            free_vars: self.free_vars,\n-        }\n-    }\n-\n-    pub(crate) fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n-        let result = self.do_canonicalize(ty, DebruijnIndex::INNERMOST);\n-        self.into_canonicalized(result)\n-    }\n-\n-    pub(crate) fn canonicalize_obligation(\n-        mut self,\n-        obligation: InEnvironment<DomainGoal>,\n-    ) -> Canonicalized<InEnvironment<DomainGoal>> {\n-        let result = match obligation.goal {\n-            DomainGoal::Holds(wc) => {\n-                DomainGoal::Holds(self.do_canonicalize(wc, DebruijnIndex::INNERMOST))\n-            }\n-            _ => unimplemented!(),\n-        };\n-        self.into_canonicalized(InEnvironment { goal: result, environment: obligation.environment })\n-    }\n+    free_vars: Vec<GenericArg>,\n }\n \n impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n     pub(super) fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n-        crate::fold_free_vars(ty, |bound, _binders| {\n-            let (v, k) = self.free_vars[bound.index];\n-            TyKind::InferenceVar(v, k).intern(&Interner)\n-        })\n+        chalk_ir::Substitute::apply(&self.free_vars, ty, &Interner)\n     }\n \n     pub(super) fn apply_solution(\n         &self,\n-        ctx: &mut InferenceContext<'_>,\n+        ctx: &mut InferenceTable,\n         solution: Canonical<Substitution>,\n     ) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n         let new_vars = Substitution::from_iter(\n             &Interner,\n             solution.binders.iter(&Interner).map(|k| match k.kind {\n-                VariableKind::Ty(TyVariableKind::General) => {\n-                    ctx.table.new_type_var().cast(&Interner)\n-                }\n-                VariableKind::Ty(TyVariableKind::Integer) => {\n-                    ctx.table.new_integer_var().cast(&Interner)\n-                }\n-                VariableKind::Ty(TyVariableKind::Float) => {\n-                    ctx.table.new_float_var().cast(&Interner)\n-                }\n+                VariableKind::Ty(TyVariableKind::General) => ctx.new_type_var().cast(&Interner),\n+                VariableKind::Ty(TyVariableKind::Integer) => ctx.new_integer_var().cast(&Interner),\n+                VariableKind::Ty(TyVariableKind::Float) => ctx.new_float_var().cast(&Interner),\n                 // Chalk can sometimes return new lifetime variables. We just use the static lifetime everywhere\n                 VariableKind::Lifetime => static_lifetime().cast(&Interner),\n                 _ => panic!(\"const variable in solution\"),\n             }),\n         );\n-        for (i, ty) in solution.value.iter(&Interner).enumerate() {\n-            let (v, k) = self.free_vars[i];\n-            // eagerly replace projections in the type; we may be getting types\n-            // e.g. from where clauses where this hasn't happened yet\n-            let ty = ctx.normalize_associated_types_in(\n-                new_vars.apply(ty.assert_ty_ref(&Interner).clone(), &Interner),\n-            );\n-            ctx.table.unify(&TyKind::InferenceVar(v, k).intern(&Interner), &ty);\n+        for (i, v) in solution.value.iter(&Interner).enumerate() {\n+            let var = self.free_vars[i].clone();\n+            if let Some(ty) = v.ty(&Interner) {\n+                // eagerly replace projections in the type; we may be getting types\n+                // e.g. from where clauses where this hasn't happened yet\n+                let ty = ctx.normalize_associated_types_in(new_vars.apply(ty.clone(), &Interner));\n+                ctx.unify(var.assert_ty_ref(&Interner), &ty);\n+            } else {\n+                let _ = ctx.try_unify(&var, &new_vars.apply(v.clone(), &Interner));\n+            }\n         }\n     }\n }\n \n-pub fn could_unify(t1: &Ty, t2: &Ty) -> bool {\n-    InferenceTable::new().unify(t1, t2)\n+pub fn could_unify(\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    tys: &Canonical<(Ty, Ty)>,\n+) -> bool {\n+    unify(db, env, tys).is_some()\n }\n \n-pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n-    let mut table = InferenceTable::new();\n+pub(crate) fn unify(\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    tys: &Canonical<(Ty, Ty)>,\n+) -> Option<Substitution> {\n+    let mut table = InferenceTable::new(db, env);\n     let vars = Substitution::from_iter(\n         &Interner,\n         tys.binders\n@@ -187,77 +105,151 @@ pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n     }\n     // default any type vars that weren't unified back to their original bound vars\n     // (kind of hacky)\n-    for (i, var) in vars.iter(&Interner).enumerate() {\n-        let var = var.assert_ty_ref(&Interner);\n-        if &*table.resolve_ty_shallow(var) == var {\n-            table.unify(\n-                var,\n-                &TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i)).intern(&Interner),\n-            );\n-        }\n-    }\n+    let find_var = |iv| {\n+        vars.iter(&Interner).position(|v| match v.interned() {\n+            chalk_ir::GenericArgData::Ty(ty) => ty.inference_var(&Interner),\n+            chalk_ir::GenericArgData::Lifetime(lt) => lt.inference_var(&Interner),\n+            chalk_ir::GenericArgData::Const(c) => c.inference_var(&Interner),\n+        } == Some(iv))\n+    };\n+    let fallback = |iv, kind, default, binder| match kind {\n+        chalk_ir::VariableKind::Ty(_ty_kind) => find_var(iv)\n+            .map_or(default, |i| BoundVar::new(binder, i).to_ty(&Interner).cast(&Interner)),\n+        chalk_ir::VariableKind::Lifetime => find_var(iv)\n+            .map_or(default, |i| BoundVar::new(binder, i).to_lifetime(&Interner).cast(&Interner)),\n+        chalk_ir::VariableKind::Const(ty) => find_var(iv)\n+            .map_or(default, |i| BoundVar::new(binder, i).to_const(&Interner, ty).cast(&Interner)),\n+    };\n     Some(Substitution::from_iter(\n         &Interner,\n         vars.iter(&Interner)\n-            .map(|v| table.resolve_ty_completely(v.assert_ty_ref(&Interner).clone())),\n+            .map(|v| table.resolve_with_fallback(v.assert_ty_ref(&Interner).clone(), fallback)),\n     ))\n }\n \n-#[derive(Clone, Debug)]\n-pub(super) struct TypeVariableTable {\n-    inner: Vec<TypeVariableData>,\n+#[derive(Copy, Clone, Debug)]\n+pub(crate) struct TypeVariableData {\n+    diverging: bool,\n }\n \n-impl TypeVariableTable {\n-    fn push(&mut self, data: TypeVariableData) {\n-        self.inner.push(data);\n+type ChalkInferenceTable = chalk_solve::infer::InferenceTable<Interner>;\n+\n+#[derive(Clone)]\n+pub(crate) struct InferenceTable<'a> {\n+    pub(crate) db: &'a dyn HirDatabase,\n+    pub(crate) trait_env: Arc<TraitEnvironment>,\n+    var_unification_table: ChalkInferenceTable,\n+    type_variable_table: Vec<TypeVariableData>,\n+    pending_obligations: Vec<Canonicalized<InEnvironment<Goal>>>,\n+}\n+\n+impl<'a> InferenceTable<'a> {\n+    pub(crate) fn new(db: &'a dyn HirDatabase, trait_env: Arc<TraitEnvironment>) -> Self {\n+        InferenceTable {\n+            db,\n+            trait_env,\n+            var_unification_table: ChalkInferenceTable::new(),\n+            type_variable_table: Vec::new(),\n+            pending_obligations: Vec::new(),\n+        }\n     }\n \n-    pub(super) fn set_diverging(&mut self, iv: InferenceVar, diverging: bool) {\n-        self.inner[from_inference_var(iv).0 as usize].diverging = diverging;\n+    /// Chalk doesn't know about the `diverging` flag, so when it unifies two\n+    /// type variables of which one is diverging, the chosen root might not be\n+    /// diverging and we have no way of marking it as such at that time. This\n+    /// function goes through all type variables and make sure their root is\n+    /// marked as diverging if necessary, so that resolving them gives the right\n+    /// result.\n+    pub(super) fn propagate_diverging_flag(&mut self) {\n+        for i in 0..self.type_variable_table.len() {\n+            if !self.type_variable_table[i].diverging {\n+                continue;\n+            }\n+            let v = InferenceVar::from(i as u32);\n+            let root = self.var_unification_table.inference_var_root(v);\n+            if let Some(data) = self.type_variable_table.get_mut(root.index() as usize) {\n+                data.diverging = true;\n+            }\n+        }\n     }\n \n-    fn is_diverging(&mut self, iv: InferenceVar) -> bool {\n-        self.inner[from_inference_var(iv).0 as usize].diverging\n+    pub(super) fn set_diverging(&mut self, iv: InferenceVar, diverging: bool) {\n+        self.type_variable_table[iv.index() as usize].diverging = diverging;\n     }\n \n     fn fallback_value(&self, iv: InferenceVar, kind: TyVariableKind) -> Ty {\n         match kind {\n-            _ if self.inner[from_inference_var(iv).0 as usize].diverging => TyKind::Never,\n+            _ if self\n+                .type_variable_table\n+                .get(iv.index() as usize)\n+                .map_or(false, |data| data.diverging) =>\n+            {\n+                TyKind::Never\n+            }\n             TyVariableKind::General => TyKind::Error,\n             TyVariableKind::Integer => TyKind::Scalar(Scalar::Int(IntTy::I32)),\n             TyVariableKind::Float => TyKind::Scalar(Scalar::Float(FloatTy::F64)),\n         }\n         .intern(&Interner)\n     }\n-}\n \n-#[derive(Copy, Clone, Debug)]\n-pub(crate) struct TypeVariableData {\n-    diverging: bool,\n-}\n+    pub(super) fn canonicalize<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n+        &mut self,\n+        t: T,\n+    ) -> Canonicalized<T::Result>\n+    where\n+        T::Result: HasInterner<Interner = Interner>,\n+    {\n+        let result = self.var_unification_table.canonicalize(&Interner, t);\n+        let free_vars = result\n+            .free_vars\n+            .into_iter()\n+            .map(|free_var| free_var.to_generic_arg(&Interner))\n+            .collect();\n+        Canonicalized { value: result.quantified, free_vars }\n+    }\n+\n+    /// Recurses through the given type, normalizing associated types mentioned\n+    /// in it by replacing them by type variables and registering obligations to\n+    /// resolve later. This should be done once for every type we get from some\n+    /// type annotation (e.g. from a let type annotation, field type or function\n+    /// call). `make_ty` handles this already, but e.g. for field types we need\n+    /// to do it as well.\n+    pub(super) fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n+        fold_tys(\n+            ty,\n+            |ty, _| match ty.kind(&Interner) {\n+                TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n+                    self.normalize_projection_ty(proj_ty.clone())\n+                }\n+                _ => ty,\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n+    }\n \n-#[derive(Clone, Debug)]\n-pub(crate) struct InferenceTable {\n-    pub(super) var_unification_table: InPlaceUnificationTable<TypeVarId>,\n-    pub(super) type_variable_table: TypeVariableTable,\n-    pub(super) revision: u32,\n-}\n+    pub(super) fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {\n+        let var = self.new_type_var();\n+        let alias_eq = AliasEq { alias: AliasTy::Projection(proj_ty), ty: var.clone() };\n+        let obligation = alias_eq.cast(&Interner);\n+        self.register_obligation(obligation);\n+        var\n+    }\n \n-impl InferenceTable {\n-    pub(crate) fn new() -> Self {\n-        InferenceTable {\n-            var_unification_table: InPlaceUnificationTable::new(),\n-            type_variable_table: TypeVariableTable { inner: Vec::new() },\n-            revision: 0,\n-        }\n+    fn extend_type_variable_table(&mut self, to_index: usize) {\n+        self.type_variable_table.extend(\n+            (0..1 + to_index - self.type_variable_table.len())\n+                .map(|_| TypeVariableData { diverging: false }),\n+        );\n     }\n \n     fn new_var(&mut self, kind: TyVariableKind, diverging: bool) -> Ty {\n-        self.type_variable_table.push(TypeVariableData { diverging });\n-        let key = self.var_unification_table.new_key(TypeVarValue::Unknown);\n-        assert_eq!(key.0 as usize, self.type_variable_table.inner.len() - 1);\n-        TyKind::InferenceVar(to_inference_var(key), kind).intern(&Interner)\n+        let var = self.var_unification_table.new_variable(UniverseIndex::ROOT);\n+        // Chalk might have created some type variables for its own purposes that we don't know about...\n+        self.extend_type_variable_table(var.index() as usize);\n+        assert_eq!(var.index() as usize, self.type_variable_table.len() - 1);\n+        self.type_variable_table[var.index() as usize].diverging = diverging;\n+        var.to_ty_with_kind(&Interner, kind)\n     }\n \n     pub(crate) fn new_type_var(&mut self) -> Ty {\n@@ -276,350 +268,261 @@ impl InferenceTable {\n         self.new_var(TyVariableKind::General, true)\n     }\n \n-    pub(crate) fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n-        self.resolve_ty_completely_inner(&mut Vec::new(), ty)\n+    pub(crate) fn resolve_with_fallback<T>(\n+        &mut self,\n+        t: T,\n+        fallback: impl Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg,\n+    ) -> T::Result\n+    where\n+        T: HasInterner<Interner = Interner> + Fold<Interner>,\n+    {\n+        self.resolve_with_fallback_inner(&mut Vec::new(), t, &fallback)\n     }\n \n-    pub(crate) fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n-        self.resolve_ty_as_possible_inner(&mut Vec::new(), ty)\n+    fn resolve_with_fallback_inner<T>(\n+        &mut self,\n+        var_stack: &mut Vec<InferenceVar>,\n+        t: T,\n+        fallback: &impl Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg,\n+    ) -> T::Result\n+    where\n+        T: HasInterner<Interner = Interner> + Fold<Interner>,\n+    {\n+        t.fold_with(\n+            &mut resolve::Resolver { table: self, var_stack, fallback },\n+            DebruijnIndex::INNERMOST,\n+        )\n+        .expect(\"fold failed unexpectedly\")\n     }\n \n-    pub(crate) fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        self.unify_inner(ty1, ty2, 0)\n+    pub(crate) fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n+        self.resolve_with_fallback(ty, |_, _, d, _| d)\n     }\n \n-    pub(crate) fn unify_substs(\n-        &mut self,\n-        substs1: &Substitution,\n-        substs2: &Substitution,\n-        depth: usize,\n-    ) -> bool {\n-        substs1.iter(&Interner).zip(substs2.iter(&Interner)).all(|(t1, t2)| {\n-            self.unify_inner(t1.assert_ty_ref(&Interner), t2.assert_ty_ref(&Interner), depth)\n-        })\n+    /// Unify two types and register new trait goals that arise from that.\n+    pub(crate) fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        let result = if let Ok(r) = self.try_unify(ty1, ty2) {\n+            r\n+        } else {\n+            return false;\n+        };\n+        self.register_infer_ok(result);\n+        true\n     }\n \n-    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n-        if depth > 1000 {\n-            // prevent stackoverflows\n-            panic!(\"infinite recursion in unification\");\n-        }\n-        if ty1 == ty2 {\n-            return true;\n-        }\n-        // try to resolve type vars first\n-        let ty1 = self.resolve_ty_shallow(ty1);\n-        let ty2 = self.resolve_ty_shallow(ty2);\n-        if ty1.equals_ctor(&ty2) {\n-            match (ty1.kind(&Interner), ty2.kind(&Interner)) {\n-                (TyKind::Adt(_, substs1), TyKind::Adt(_, substs2))\n-                | (TyKind::FnDef(_, substs1), TyKind::FnDef(_, substs2))\n-                | (\n-                    TyKind::Function(FnPointer { substitution: FnSubst(substs1), .. }),\n-                    TyKind::Function(FnPointer { substitution: FnSubst(substs2), .. }),\n-                )\n-                | (TyKind::Tuple(_, substs1), TyKind::Tuple(_, substs2))\n-                | (TyKind::OpaqueType(_, substs1), TyKind::OpaqueType(_, substs2))\n-                | (TyKind::AssociatedType(_, substs1), TyKind::AssociatedType(_, substs2))\n-                | (TyKind::Closure(.., substs1), TyKind::Closure(.., substs2)) => {\n-                    self.unify_substs(substs1, substs2, depth + 1)\n-                }\n-                (TyKind::Array(ty1, c1), TyKind::Array(ty2, c2)) if c1 == c2 => {\n-                    self.unify_inner(ty1, ty2, depth + 1)\n-                }\n-                (TyKind::Ref(_, _, ty1), TyKind::Ref(_, _, ty2))\n-                | (TyKind::Raw(_, ty1), TyKind::Raw(_, ty2))\n-                | (TyKind::Slice(ty1), TyKind::Slice(ty2)) => self.unify_inner(ty1, ty2, depth + 1),\n-                _ => true, /* we checked equals_ctor already */\n-            }\n-        } else if let (TyKind::Closure(.., substs1), TyKind::Closure(.., substs2)) =\n-            (ty1.kind(&Interner), ty2.kind(&Interner))\n-        {\n-            self.unify_substs(substs1, substs2, depth + 1)\n-        } else {\n-            self.unify_inner_trivial(&ty1, &ty2, depth)\n+    /// Unify two types and return new trait goals arising from it, so the\n+    /// caller needs to deal with them.\n+    pub(crate) fn try_unify<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult {\n+        match self.var_unification_table.relate(\n+            &Interner,\n+            &self.db,\n+            &self.trait_env.env,\n+            chalk_ir::Variance::Invariant,\n+            t1,\n+            t2,\n+        ) {\n+            Ok(result) => Ok(InferOk { goals: result.goals }),\n+            Err(chalk_ir::NoSolution) => Err(TypeError),\n         }\n     }\n \n-    pub(super) fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n-        match (ty1.kind(&Interner), ty2.kind(&Interner)) {\n-            (TyKind::Error, _) | (_, TyKind::Error) => true,\n+    /// If `ty` is a type variable with known type, returns that type;\n+    /// otherwise, return ty.\n+    pub(crate) fn resolve_ty_shallow(&mut self, ty: &Ty) -> Ty {\n+        self.var_unification_table.normalize_ty_shallow(&Interner, ty).unwrap_or_else(|| ty.clone())\n+    }\n \n-            (TyKind::Placeholder(p1), TyKind::Placeholder(p2)) if *p1 == *p2 => true,\n+    pub(crate) fn register_obligation(&mut self, goal: Goal) {\n+        let in_env = InEnvironment::new(&self.trait_env.env, goal);\n+        self.register_obligation_in_env(in_env)\n+    }\n \n-            (TyKind::Dyn(dyn1), TyKind::Dyn(dyn2))\n-                if dyn1.bounds.skip_binders().interned().len()\n-                    == dyn2.bounds.skip_binders().interned().len() =>\n-            {\n-                for (pred1, pred2) in dyn1\n-                    .bounds\n-                    .skip_binders()\n-                    .interned()\n-                    .iter()\n-                    .zip(dyn2.bounds.skip_binders().interned().iter())\n-                {\n-                    if !self.unify_preds(pred1.skip_binders(), pred2.skip_binders(), depth + 1) {\n-                        return false;\n-                    }\n-                }\n-                true\n-            }\n+    fn register_obligation_in_env(&mut self, goal: InEnvironment<Goal>) {\n+        let canonicalized = self.canonicalize(goal);\n+        if !self.try_resolve_obligation(&canonicalized) {\n+            self.pending_obligations.push(canonicalized);\n+        }\n+    }\n \n-            (\n-                TyKind::InferenceVar(tv1, TyVariableKind::General),\n-                TyKind::InferenceVar(tv2, TyVariableKind::General),\n-            )\n-            | (\n-                TyKind::InferenceVar(tv1, TyVariableKind::Integer),\n-                TyKind::InferenceVar(tv2, TyVariableKind::Integer),\n-            )\n-            | (\n-                TyKind::InferenceVar(tv1, TyVariableKind::Float),\n-                TyKind::InferenceVar(tv2, TyVariableKind::Float),\n-            ) if self.type_variable_table.is_diverging(*tv1)\n-                == self.type_variable_table.is_diverging(*tv2) =>\n-            {\n-                // both type vars are unknown since we tried to resolve them\n-                if !self\n-                    .var_unification_table\n-                    .unioned(from_inference_var(*tv1), from_inference_var(*tv2))\n-                {\n-                    self.var_unification_table\n-                        .union(from_inference_var(*tv1), from_inference_var(*tv2));\n-                    self.revision += 1;\n-                }\n-                true\n-            }\n+    pub(crate) fn register_infer_ok(&mut self, infer_ok: InferOk) {\n+        infer_ok.goals.into_iter().for_each(|goal| self.register_obligation_in_env(goal));\n+    }\n \n-            // The order of MaybeNeverTypeVar matters here.\n-            // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n-            // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n-            (TyKind::InferenceVar(tv, TyVariableKind::General), other)\n-            | (other, TyKind::InferenceVar(tv, TyVariableKind::General))\n-            | (\n-                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n-                other @ TyKind::Scalar(Scalar::Int(_)),\n-            )\n-            | (\n-                other @ TyKind::Scalar(Scalar::Int(_)),\n-                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n-            )\n-            | (\n-                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n-                other @ TyKind::Scalar(Scalar::Uint(_)),\n-            )\n-            | (\n-                other @ TyKind::Scalar(Scalar::Uint(_)),\n-                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n-            )\n-            | (\n-                TyKind::InferenceVar(tv, TyVariableKind::Float),\n-                other @ TyKind::Scalar(Scalar::Float(_)),\n-            )\n-            | (\n-                other @ TyKind::Scalar(Scalar::Float(_)),\n-                TyKind::InferenceVar(tv, TyVariableKind::Float),\n-            ) => {\n-                // the type var is unknown since we tried to resolve it\n-                self.var_unification_table.union_value(\n-                    from_inference_var(*tv),\n-                    TypeVarValue::Known(other.clone().intern(&Interner)),\n+    pub(crate) fn resolve_obligations_as_possible(&mut self) {\n+        let _span = profile::span(\"resolve_obligations_as_possible\");\n+        let mut changed = true;\n+        let mut obligations = Vec::new();\n+        while changed {\n+            changed = false;\n+            mem::swap(&mut self.pending_obligations, &mut obligations);\n+            for canonicalized in obligations.drain(..) {\n+                if !self.check_changed(&canonicalized) {\n+                    self.pending_obligations.push(canonicalized);\n+                    continue;\n+                }\n+                changed = true;\n+                let uncanonical = chalk_ir::Substitute::apply(\n+                    &canonicalized.free_vars,\n+                    canonicalized.value.value,\n+                    &Interner,\n                 );\n-                self.revision += 1;\n-                true\n+                self.register_obligation_in_env(uncanonical);\n             }\n-\n-            _ => false,\n         }\n     }\n \n-    fn unify_preds(&mut self, pred1: &WhereClause, pred2: &WhereClause, depth: usize) -> bool {\n-        match (pred1, pred2) {\n-            (WhereClause::Implemented(tr1), WhereClause::Implemented(tr2))\n-                if tr1.trait_id == tr2.trait_id =>\n-            {\n-                self.unify_substs(&tr1.substitution, &tr2.substitution, depth + 1)\n+    /// This checks whether any of the free variables in the `canonicalized`\n+    /// have changed (either been unified with another variable, or with a\n+    /// value). If this is not the case, we don't need to try to solve the goal\n+    /// again -- it'll give the same result as last time.\n+    fn check_changed(&mut self, canonicalized: &Canonicalized<InEnvironment<Goal>>) -> bool {\n+        canonicalized.free_vars.iter().any(|var| {\n+            let iv = match var.data(&Interner) {\n+                chalk_ir::GenericArgData::Ty(ty) => ty.inference_var(&Interner),\n+                chalk_ir::GenericArgData::Lifetime(lt) => lt.inference_var(&Interner),\n+                chalk_ir::GenericArgData::Const(c) => c.inference_var(&Interner),\n             }\n-            (\n-                WhereClause::AliasEq(AliasEq { alias: alias1, ty: ty1 }),\n-                WhereClause::AliasEq(AliasEq { alias: alias2, ty: ty2 }),\n-            ) => {\n-                let (substitution1, substitution2) = match (alias1, alias2) {\n-                    (AliasTy::Projection(projection_ty1), AliasTy::Projection(projection_ty2))\n-                        if projection_ty1.associated_ty_id == projection_ty2.associated_ty_id =>\n-                    {\n-                        (&projection_ty1.substitution, &projection_ty2.substitution)\n-                    }\n-                    (AliasTy::Opaque(opaque1), AliasTy::Opaque(opaque2))\n-                        if opaque1.opaque_ty_id == opaque2.opaque_ty_id =>\n-                    {\n-                        (&opaque1.substitution, &opaque2.substitution)\n-                    }\n-                    _ => return false,\n-                };\n-                self.unify_substs(&substitution1, &substitution2, depth + 1)\n-                    && self.unify_inner(&ty1, &ty2, depth + 1)\n+            .expect(\"free var is not inference var\");\n+            if self.var_unification_table.probe_var(iv).is_some() {\n+                return true;\n             }\n-            _ => false,\n-        }\n+            let root = self.var_unification_table.inference_var_root(iv);\n+            iv != root\n+        })\n     }\n \n-    /// If `ty` is a type variable with known type, returns that type;\n-    /// otherwise, return ty.\n-    pub(crate) fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n-        let mut ty = Cow::Borrowed(ty);\n-        // The type variable could resolve to a int/float variable. Hence try\n-        // resolving up to three times; each type of variable shouldn't occur\n-        // more than once\n-        for i in 0..3 {\n-            if i > 0 {\n-                cov_mark::hit!(type_var_resolves_to_int_var);\n+    fn try_resolve_obligation(\n+        &mut self,\n+        canonicalized: &Canonicalized<InEnvironment<Goal>>,\n+    ) -> bool {\n+        let solution = self.db.trait_solve(self.trait_env.krate, canonicalized.value.clone());\n+\n+        match solution {\n+            Some(Solution::Unique(canonical_subst)) => {\n+                canonicalized.apply_solution(\n+                    self,\n+                    Canonical {\n+                        binders: canonical_subst.binders,\n+                        // FIXME: handle constraints\n+                        value: canonical_subst.value.subst,\n+                    },\n+                );\n+                true\n             }\n-            match ty.kind(&Interner) {\n-                TyKind::InferenceVar(tv, _) => {\n-                    let inner = from_inference_var(*tv);\n-                    match self.var_unification_table.inlined_probe_value(inner).known() {\n-                        Some(known_ty) => {\n-                            // The known_ty can't be a type var itself\n-                            ty = Cow::Owned(known_ty.clone());\n-                        }\n-                        _ => return ty,\n-                    }\n-                }\n-                _ => return ty,\n+            Some(Solution::Ambig(Guidance::Definite(substs))) => {\n+                canonicalized.apply_solution(self, substs);\n+                false\n+            }\n+            Some(_) => {\n+                // FIXME use this when trying to resolve everything at the end\n+                false\n+            }\n+            None => {\n+                // FIXME obligation cannot be fulfilled => diagnostic\n+                true\n             }\n         }\n-        log::error!(\"Inference variable still not resolved: {:?}\", ty);\n-        ty\n-    }\n-\n-    /// Resolves the type as far as currently possible, replacing type variables\n-    /// by their known types. All types returned by the infer_* functions should\n-    /// be resolved as far as possible, i.e. contain no type variables with\n-    /// known type.\n-    fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        fold_tys(\n-            ty,\n-            |ty, _| match ty.kind(&Interner) {\n-                &TyKind::InferenceVar(tv, kind) => {\n-                    let inner = from_inference_var(tv);\n-                    if tv_stack.contains(&inner) {\n-                        cov_mark::hit!(type_var_cycles_resolve_as_possible);\n-                        // recursive type\n-                        return self.type_variable_table.fallback_value(tv, kind);\n-                    }\n-                    if let Some(known_ty) =\n-                        self.var_unification_table.inlined_probe_value(inner).known()\n-                    {\n-                        // known_ty may contain other variables that are known by now\n-                        tv_stack.push(inner);\n-                        let result = self.resolve_ty_as_possible_inner(tv_stack, known_ty.clone());\n-                        tv_stack.pop();\n-                        result\n-                    } else {\n-                        ty\n-                    }\n-                }\n-                _ => ty,\n-            },\n-            DebruijnIndex::INNERMOST,\n-        )\n-    }\n-\n-    /// Resolves the type completely; type variables without known type are\n-    /// replaced by TyKind::Unknown.\n-    fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        fold_tys(\n-            ty,\n-            |ty, _| match ty.kind(&Interner) {\n-                &TyKind::InferenceVar(tv, kind) => {\n-                    let inner = from_inference_var(tv);\n-                    if tv_stack.contains(&inner) {\n-                        cov_mark::hit!(type_var_cycles_resolve_completely);\n-                        // recursive type\n-                        return self.type_variable_table.fallback_value(tv, kind);\n-                    }\n-                    if let Some(known_ty) =\n-                        self.var_unification_table.inlined_probe_value(inner).known()\n-                    {\n-                        // known_ty may contain other variables that are known by now\n-                        tv_stack.push(inner);\n-                        let result = self.resolve_ty_completely_inner(tv_stack, known_ty.clone());\n-                        tv_stack.pop();\n-                        result\n-                    } else {\n-                        self.type_variable_table.fallback_value(tv, kind)\n-                    }\n-                }\n-                _ => ty,\n-            },\n-            DebruijnIndex::INNERMOST,\n-        )\n     }\n }\n \n-/// The ID of a type variable.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub(super) struct TypeVarId(pub(super) u32);\n-\n-impl UnifyKey for TypeVarId {\n-    type Value = TypeVarValue;\n-\n-    fn index(&self) -> u32 {\n-        self.0\n-    }\n-\n-    fn from_index(i: u32) -> Self {\n-        TypeVarId(i)\n+impl<'a> fmt::Debug for InferenceTable<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"InferenceTable\").field(\"num_vars\", &self.type_variable_table.len()).finish()\n     }\n-\n-    fn tag() -> &'static str {\n-        \"TypeVarId\"\n-    }\n-}\n-\n-fn from_inference_var(var: InferenceVar) -> TypeVarId {\n-    TypeVarId(var.index())\n-}\n-\n-fn to_inference_var(TypeVarId(index): TypeVarId) -> InferenceVar {\n-    index.into()\n-}\n-\n-/// The value of a type variable: either we already know the type, or we don't\n-/// know it yet.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub(super) enum TypeVarValue {\n-    Known(Ty),\n-    Unknown,\n }\n \n-impl TypeVarValue {\n-    fn known(&self) -> Option<&Ty> {\n-        match self {\n-            TypeVarValue::Known(ty) => Some(ty),\n-            TypeVarValue::Unknown => None,\n+mod resolve {\n+    use super::InferenceTable;\n+    use crate::{\n+        ConcreteConst, Const, ConstData, ConstValue, DebruijnIndex, GenericArg, InferenceVar,\n+        Interner, Ty, TyVariableKind, VariableKind,\n+    };\n+    use chalk_ir::{\n+        cast::Cast,\n+        fold::{Fold, Folder},\n+        Fallible,\n+    };\n+    use hir_def::type_ref::ConstScalar;\n+\n+    pub(super) struct Resolver<'a, 'b, F> {\n+        pub(super) table: &'a mut InferenceTable<'b>,\n+        pub(super) var_stack: &'a mut Vec<InferenceVar>,\n+        pub(super) fallback: F,\n+    }\n+    impl<'a, 'b, 'i, F> Folder<'i, Interner> for Resolver<'a, 'b, F>\n+    where\n+        F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg + 'i,\n+    {\n+        fn as_dyn(&mut self) -> &mut dyn Folder<'i, Interner> {\n+            self\n         }\n-    }\n-}\n-\n-impl UnifyValue for TypeVarValue {\n-    type Error = NoError;\n \n-    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n-        match (value1, value2) {\n-            // We should never equate two type variables, both of which have\n-            // known types. Instead, we recursively equate those types.\n-            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n-                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n-                t1, t2\n-            ),\n+        fn interner(&self) -> &'i Interner {\n+            &Interner\n+        }\n \n-            // If one side is known, prefer that one.\n-            (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n-            (TypeVarValue::Unknown, TypeVarValue::Known(..)) => Ok(value2.clone()),\n+        fn fold_inference_ty(\n+            &mut self,\n+            var: InferenceVar,\n+            kind: TyVariableKind,\n+            outer_binder: DebruijnIndex,\n+        ) -> Fallible<Ty> {\n+            let var = self.table.var_unification_table.inference_var_root(var);\n+            if self.var_stack.contains(&var) {\n+                // recursive type\n+                let default = self.table.fallback_value(var, kind).cast(&Interner);\n+                return Ok((self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n+                    .assert_ty_ref(&Interner)\n+                    .clone());\n+            }\n+            let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n+                // known_ty may contain other variables that are known by now\n+                self.var_stack.push(var);\n+                let result =\n+                    known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n+                self.var_stack.pop();\n+                result.assert_ty_ref(&Interner).clone()\n+            } else {\n+                let default = self.table.fallback_value(var, kind).cast(&Interner);\n+                (self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n+                    .assert_ty_ref(&Interner)\n+                    .clone()\n+            };\n+            Ok(result)\n+        }\n \n-            (TypeVarValue::Unknown, TypeVarValue::Unknown) => Ok(TypeVarValue::Unknown),\n+        fn fold_inference_const(\n+            &mut self,\n+            ty: Ty,\n+            var: InferenceVar,\n+            outer_binder: DebruijnIndex,\n+        ) -> Fallible<Const> {\n+            let var = self.table.var_unification_table.inference_var_root(var);\n+            let default = ConstData {\n+                ty: ty.clone(),\n+                value: ConstValue::Concrete(ConcreteConst { interned: ConstScalar::Unknown }),\n+            }\n+            .intern(&Interner)\n+            .cast(&Interner);\n+            if self.var_stack.contains(&var) {\n+                // recursive\n+                return Ok((self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n+                    .assert_const_ref(&Interner)\n+                    .clone());\n+            }\n+            let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n+                // known_ty may contain other variables that are known by now\n+                self.var_stack.push(var);\n+                let result =\n+                    known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n+                self.var_stack.pop();\n+                result.assert_const_ref(&Interner).clone()\n+            } else {\n+                (self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n+                    .assert_const_ref(&Interner)\n+                    .clone()\n+            };\n+            Ok(result)\n         }\n     }\n }"}, {"sha": "29ffdd9b7f3940da7059ceca683e1a94d28ea422", "filename": "crates/hir_ty/src/interner.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finterner.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -15,9 +15,15 @@ use std::{fmt, sync::Arc};\n #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]\n pub struct Interner;\n \n-#[derive(PartialEq, Eq, Hash, Debug)]\n+#[derive(PartialEq, Eq, Hash)]\n pub struct InternedWrapper<T>(T);\n \n+impl<T: fmt::Debug> fmt::Debug for InternedWrapper<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&self.0, f)\n+    }\n+}\n+\n impl<T> std::ops::Deref for InternedWrapper<T> {\n     type Target = T;\n \n@@ -101,66 +107,65 @@ impl chalk_ir::interner::Interner for Interner {\n         opaque_ty: &chalk_ir::OpaqueTy<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_opaque_ty(opaque_ty, fmt)))\n+        Some(write!(fmt, \"{:?}\", opaque_ty.opaque_ty_id))\n     }\n \n     fn debug_opaque_ty_id(\n         opaque_ty_id: chalk_ir::OpaqueTyId<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_opaque_ty_id(opaque_ty_id, fmt)))\n+        Some(fmt.debug_struct(\"OpaqueTyId\").field(\"index\", &opaque_ty_id.0).finish())\n     }\n \n     fn debug_ty(ty: &chalk_ir::Ty<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_ty(ty, fmt)))\n+        Some(write!(fmt, \"{:?}\", ty.data(&Interner)))\n     }\n \n     fn debug_lifetime(\n         lifetime: &chalk_ir::Lifetime<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_lifetime(lifetime, fmt)))\n+        Some(write!(fmt, \"{:?}\", lifetime.data(&Interner)))\n     }\n \n     fn debug_generic_arg(\n         parameter: &GenericArg,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_generic_arg(parameter, fmt)))\n+        Some(write!(fmt, \"{:?}\", parameter.data(&Interner).inner_debug()))\n     }\n \n     fn debug_goal(goal: &Goal<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_goal(goal, fmt)))\n+        let goal_data = goal.data(&Interner);\n+        Some(write!(fmt, \"{:?}\", goal_data))\n     }\n \n     fn debug_goals(\n         goals: &chalk_ir::Goals<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_goals(goals, fmt)))\n+        Some(write!(fmt, \"{:?}\", goals.debug(&Interner)))\n     }\n \n     fn debug_program_clause_implication(\n         pci: &chalk_ir::ProgramClauseImplication<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_program_clause_implication(pci, fmt)))\n+        Some(write!(fmt, \"{:?}\", pci.debug(&Interner)))\n     }\n \n     fn debug_substitution(\n         substitution: &chalk_ir::Substitution<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_substitution(substitution, fmt)))\n+        Some(write!(fmt, \"{:?}\", substitution.debug(&Interner)))\n     }\n \n     fn debug_separator_trait_ref(\n         separator_trait_ref: &chalk_ir::SeparatorTraitRef<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| {\n-            Some(prog?.debug_separator_trait_ref(separator_trait_ref, fmt))\n-        })\n+        Some(write!(fmt, \"{:?}\", separator_trait_ref.debug(&Interner)))\n     }\n \n     fn debug_fn_def_id(\n@@ -173,47 +178,43 @@ impl chalk_ir::interner::Interner for Interner {\n         constant: &chalk_ir::Const<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_const(constant, fmt)))\n+        Some(write!(fmt, \"{:?}\", constant.data(&Interner)))\n     }\n     fn debug_variable_kinds(\n         variable_kinds: &chalk_ir::VariableKinds<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_variable_kinds(variable_kinds, fmt)))\n+        Some(write!(fmt, \"{:?}\", variable_kinds.as_slice(&Interner)))\n     }\n     fn debug_variable_kinds_with_angles(\n         variable_kinds: &chalk_ir::VariableKinds<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| {\n-            Some(prog?.debug_variable_kinds_with_angles(variable_kinds, fmt))\n-        })\n+        Some(write!(fmt, \"{:?}\", variable_kinds.inner_debug(&Interner)))\n     }\n     fn debug_canonical_var_kinds(\n         canonical_var_kinds: &chalk_ir::CanonicalVarKinds<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| {\n-            Some(prog?.debug_canonical_var_kinds(canonical_var_kinds, fmt))\n-        })\n+        Some(write!(fmt, \"{:?}\", canonical_var_kinds.as_slice(&Interner)))\n     }\n     fn debug_program_clause(\n         clause: &chalk_ir::ProgramClause<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_program_clause(clause, fmt)))\n+        Some(write!(fmt, \"{:?}\", clause.data(&Interner)))\n     }\n     fn debug_program_clauses(\n         clauses: &chalk_ir::ProgramClauses<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_program_clauses(clauses, fmt)))\n+        Some(write!(fmt, \"{:?}\", clauses.as_slice(&Interner)))\n     }\n     fn debug_quantified_where_clauses(\n         clauses: &chalk_ir::QuantifiedWhereClauses<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_quantified_where_clauses(clauses, fmt)))\n+        Some(write!(fmt, \"{:?}\", clauses.as_slice(&Interner)))\n     }\n \n     fn intern_ty(&self, kind: chalk_ir::TyKind<Self>) -> Self::InternedType {"}, {"sha": "72093d75a2e03528e0fa67eaf0eedb4609e8740f", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -43,8 +43,9 @@ use hir_def::{\n     type_ref::{ConstScalar, Rawness},\n     TypeParamId,\n };\n+use stdx::always;\n \n-use crate::{db::HirDatabase, display::HirDisplay, utils::generics};\n+use crate::{db::HirDatabase, utils::generics};\n \n pub use autoderef::autoderef;\n pub use builder::TyBuilder;\n@@ -113,6 +114,7 @@ pub type FnSig = chalk_ir::FnSig<Interner>;\n \n pub type InEnvironment<T> = chalk_ir::InEnvironment<T>;\n pub type DomainGoal = chalk_ir::DomainGoal<Interner>;\n+pub type Goal = chalk_ir::Goal<Interner>;\n pub type AliasEq = chalk_ir::AliasEq<Interner>;\n pub type Solution = chalk_solve::Solution<Interner>;\n pub type ConstrainedSubst = chalk_ir::ConstrainedSubst<Interner>;\n@@ -167,6 +169,7 @@ pub fn make_canonical<T: HasInterner<Interner = Interner>>(\n     Canonical { value, binders: chalk_ir::CanonicalVarKinds::from_iter(&Interner, kinds) }\n }\n \n+// FIXME: get rid of this, just replace it by FnPointer\n /// A function signature as seen by type inference: Several parameter types and\n /// one return type.\n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -203,6 +206,17 @@ impl CallableSig {\n         }\n     }\n \n+    pub fn to_fn_ptr(&self) -> FnPointer {\n+        FnPointer {\n+            num_binders: 0,\n+            sig: FnSig { abi: (), safety: Safety::Safe, variadic: self.is_varargs },\n+            substitution: FnSubst(Substitution::from_iter(\n+                &Interner,\n+                self.params_and_return.iter().cloned(),\n+            )),\n+        }\n+    }\n+\n     pub fn params(&self) -> &[Ty] {\n         &self.params_and_return[0..self.params_and_return.len() - 1]\n     }\n@@ -314,3 +328,58 @@ pub(crate) fn fold_tys<T: HasInterner<Interner = Interner> + Fold<Interner>>(\n     }\n     t.fold_with(&mut TyFolder(f), binders).expect(\"fold failed unexpectedly\")\n }\n+\n+pub fn replace_errors_with_variables<T>(t: T) -> Canonical<T::Result>\n+where\n+    T: HasInterner<Interner = Interner> + Fold<Interner>,\n+    T::Result: HasInterner<Interner = Interner>,\n+{\n+    use chalk_ir::{\n+        fold::{Folder, SuperFold},\n+        Fallible,\n+    };\n+    struct ErrorReplacer {\n+        vars: usize,\n+    }\n+    impl<'i> Folder<'i, Interner> for ErrorReplacer {\n+        fn as_dyn(&mut self) -> &mut dyn Folder<'i, Interner> {\n+            self\n+        }\n+\n+        fn interner(&self) -> &'i Interner {\n+            &Interner\n+        }\n+\n+        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n+            if let TyKind::Error = ty.kind(&Interner) {\n+                let index = self.vars;\n+                self.vars += 1;\n+                Ok(TyKind::BoundVar(BoundVar::new(outer_binder, index)).intern(&Interner))\n+            } else {\n+                let ty = ty.super_fold_with(self.as_dyn(), outer_binder)?;\n+                Ok(ty)\n+            }\n+        }\n+\n+        fn fold_inference_ty(\n+            &mut self,\n+            var: InferenceVar,\n+            kind: TyVariableKind,\n+            _outer_binder: DebruijnIndex,\n+        ) -> Fallible<Ty> {\n+            always!(false);\n+            Ok(TyKind::InferenceVar(var, kind).intern(&Interner))\n+        }\n+    }\n+    let mut error_replacer = ErrorReplacer { vars: 0 };\n+    let value = t\n+        .fold_with(&mut error_replacer, DebruijnIndex::INNERMOST)\n+        .expect(\"fold failed unexpectedly\");\n+    let kinds = (0..error_replacer.vars).map(|_| {\n+        chalk_ir::CanonicalVarKind::new(\n+            chalk_ir::VariableKind::Ty(TyVariableKind::General),\n+            chalk_ir::UniverseIndex::ROOT,\n+        )\n+    });\n+    Canonical { value, binders: chalk_ir::CanonicalVarKinds::from_iter(&Interner, kinds) }\n+}"}, {"sha": "8a375b97348072c4ad6a897ae1186a0930af1d98", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -1035,9 +1035,11 @@ pub(crate) fn trait_environment_query(\n         clauses.push(program_clause.into_from_env_clause(&Interner));\n     }\n \n+    let krate = def.module(db.upcast()).krate();\n+\n     let env = chalk_ir::Environment::new(&Interner).add_clauses(&Interner, clauses);\n \n-    Arc::new(TraitEnvironment { traits_from_clauses: traits_in_scope, env })\n+    Arc::new(TraitEnvironment { krate, traits_from_clauses: traits_in_scope, env })\n }\n \n /// Resolve the where clause(s) of an item with generics."}, {"sha": "08e385a42c8019b187cdb449311c22e699706177", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -577,6 +577,7 @@ fn iterate_method_candidates_by_receiver(\n         if iterate_inherent_methods(\n             self_ty,\n             db,\n+            env.clone(),\n             name,\n             Some(receiver_ty),\n             krate,\n@@ -613,8 +614,16 @@ fn iterate_method_candidates_for_self_ty(\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n ) -> bool {\n-    if iterate_inherent_methods(self_ty, db, name, None, krate, visible_from_module, &mut callback)\n-    {\n+    if iterate_inherent_methods(\n+        self_ty,\n+        db,\n+        env.clone(),\n+        name,\n+        None,\n+        krate,\n+        visible_from_module,\n+        &mut callback,\n+    ) {\n         return true;\n     }\n     iterate_trait_method_candidates(self_ty, db, env, krate, traits_in_scope, name, None, callback)\n@@ -653,12 +662,12 @@ fn iterate_trait_method_candidates(\n         for (_name, item) in data.items.iter() {\n             // Don't pass a `visible_from_module` down to `is_valid_candidate`,\n             // since only inherent methods should be included into visibility checking.\n-            if !is_valid_candidate(db, name, receiver_ty, *item, self_ty, None) {\n+            if !is_valid_candidate(db, env.clone(), name, receiver_ty, *item, self_ty, None) {\n                 continue;\n             }\n             if !known_implemented {\n                 let goal = generic_implements_goal(db, env.clone(), t, self_ty.clone());\n-                if db.trait_solve(krate, goal).is_none() {\n+                if db.trait_solve(krate, goal.cast(&Interner)).is_none() {\n                     continue 'traits;\n                 }\n             }\n@@ -675,6 +684,7 @@ fn iterate_trait_method_candidates(\n fn iterate_inherent_methods(\n     self_ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n     krate: CrateId,\n@@ -690,14 +700,24 @@ fn iterate_inherent_methods(\n \n         for &impl_def in impls.for_self_ty(&self_ty.value) {\n             for &item in db.impl_data(impl_def).items.iter() {\n-                if !is_valid_candidate(db, name, receiver_ty, item, self_ty, visible_from_module) {\n+                if !is_valid_candidate(\n+                    db,\n+                    env.clone(),\n+                    name,\n+                    receiver_ty,\n+                    item,\n+                    self_ty,\n+                    visible_from_module,\n+                ) {\n                     continue;\n                 }\n                 // we have to check whether the self type unifies with the type\n                 // that the impl is for. If we have a receiver type, this\n                 // already happens in `is_valid_candidate` above; if not, we\n                 // check it here\n-                if receiver_ty.is_none() && inherent_impl_substs(db, impl_def, self_ty).is_none() {\n+                if receiver_ty.is_none()\n+                    && inherent_impl_substs(db, env.clone(), impl_def, self_ty).is_none()\n+                {\n                     cov_mark::hit!(impl_self_type_match_without_receiver);\n                     continue;\n                 }\n@@ -722,7 +742,7 @@ pub fn resolve_indexing_op(\n     let deref_chain = autoderef_method_receiver(db, krate, ty);\n     for ty in deref_chain {\n         let goal = generic_implements_goal(db, env.clone(), index_trait, ty.clone());\n-        if db.trait_solve(krate, goal).is_some() {\n+        if db.trait_solve(krate, goal.cast(&Interner)).is_some() {\n             return Some(ty);\n         }\n     }\n@@ -731,6 +751,7 @@ pub fn resolve_indexing_op(\n \n fn is_valid_candidate(\n     db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n     item: AssocItemId,\n@@ -749,7 +770,7 @@ fn is_valid_candidate(\n                 if !data.has_self_param() {\n                     return false;\n                 }\n-                let transformed_receiver_ty = match transform_receiver_ty(db, m, self_ty) {\n+                let transformed_receiver_ty = match transform_receiver_ty(db, env, m, self_ty) {\n                     Some(ty) => ty,\n                     None => return false,\n                 };\n@@ -776,6 +797,7 @@ fn is_valid_candidate(\n \n pub(crate) fn inherent_impl_substs(\n     db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     impl_id: ImplId,\n     self_ty: &Canonical<Ty>,\n ) -> Option<Substitution> {\n@@ -798,7 +820,7 @@ pub(crate) fn inherent_impl_substs(\n         binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n         value: (self_ty_with_vars, self_ty.value.clone()),\n     };\n-    let substs = super::infer::unify(&tys)?;\n+    let substs = super::infer::unify(db, env, &tys)?;\n     // We only want the substs for the vars we added, not the ones from self_ty.\n     // Also, if any of the vars we added are still in there, we replace them by\n     // Unknown. I think this can only really happen if self_ty contained\n@@ -823,6 +845,7 @@ fn fallback_bound_vars(s: Substitution, num_vars_to_keep: usize) -> Substitution\n \n fn transform_receiver_ty(\n     db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     function_id: FunctionId,\n     self_ty: &Canonical<Ty>,\n ) -> Option<Ty> {\n@@ -832,7 +855,7 @@ fn transform_receiver_ty(\n             .fill_with_unknown()\n             .build(),\n         AssocContainerId::ImplId(impl_id) => {\n-            let impl_substs = inherent_impl_substs(db, impl_id, &self_ty)?;\n+            let impl_substs = inherent_impl_substs(db, env, impl_id, &self_ty)?;\n             TyBuilder::subst_for_def(db, function_id)\n                 .use_parent_substs(&impl_substs)\n                 .fill_with_unknown()\n@@ -852,7 +875,7 @@ pub fn implements_trait(\n     trait_: TraitId,\n ) -> bool {\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n-    let solution = db.trait_solve(krate, goal);\n+    let solution = db.trait_solve(krate, goal.cast(&Interner));\n \n     solution.is_some()\n }\n@@ -865,7 +888,7 @@ pub fn implements_trait_unique(\n     trait_: TraitId,\n ) -> bool {\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n-    let solution = db.trait_solve(krate, goal);\n+    let solution = db.trait_solve(krate, goal.cast(&Interner));\n \n     matches!(solution, Some(crate::Solution::Unique(_)))\n }"}, {"sha": "bb568ea372eda1f3cf69bbeed33172c9a00a8ece", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -1,6 +1,6 @@\n use expect_test::expect;\n \n-use super::{check_infer, check_infer_with_mismatches};\n+use super::{check_infer, check_infer_with_mismatches, check_types};\n \n #[test]\n fn infer_block_expr_type_mismatch() {\n@@ -858,3 +858,57 @@ fn coerce_unsize_generic() {\n         \"]],\n     );\n }\n+\n+#[test]\n+fn infer_two_closures_lub() {\n+    check_types(\n+        r#\"\n+fn foo(c: i32) {\n+    let add = |a: i32, b: i32| a + b;\n+    let sub = |a, b| a - b;\n+            //^ |i32, i32| -> i32\n+    if c > 42 { add } else { sub };\n+  //^ fn(i32, i32) -> i32\n+}\n+        \"#,\n+    )\n+}\n+\n+#[test]\n+fn infer_match_diverging_branch_1() {\n+    check_types(\n+        r#\"\n+enum Result<T> { Ok(T), Err }\n+fn parse<T>() -> T { loop {} }\n+\n+fn test() -> i32 {\n+    let a = match parse() {\n+        Ok(val) => val,\n+        Err => return 0,\n+    };\n+    a\n+  //^ i32\n+}\n+        \"#,\n+    )\n+}\n+\n+#[test]\n+fn infer_match_diverging_branch_2() {\n+    // same as 1 except for order of branches\n+    check_types(\n+        r#\"\n+enum Result<T> { Ok(T), Err }\n+fn parse<T>() -> T { loop {} }\n+\n+fn test() -> i32 {\n+    let a = match parse() {\n+        Err => return 0,\n+        Ok(val) => val,\n+    };\n+    a\n+  //^ i32\n+}\n+        \"#,\n+    )\n+}"}, {"sha": "cd08b5c7a5723c5637bab7c2b29c97ef64718d95", "filename": "crates/hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -747,7 +747,7 @@ fn foo(tuple: (u8, i16, f32)) {\n             209..210 '_': (u8, i16, f32)\n             214..216 '{}': ()\n             136..142: expected (u8, i16, f32), got (u8, i16)\n-            170..182: expected (u8, i16, f32), got (u8, i16, f32, _)\n+            170..182: expected (u8, i16, f32), got (u8, i16, f32, {unknown})\n         \"#]],\n     );\n }"}, {"sha": "ad9edf11cd722ea574117c1a29eff5fb615fda6d", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -86,8 +86,6 @@ fn bug_651() {\n \n #[test]\n fn recursive_vars() {\n-    cov_mark::check!(type_var_cycles_resolve_completely);\n-    cov_mark::check!(type_var_cycles_resolve_as_possible);\n     check_infer(\n         r#\"\n         fn test() {\n@@ -97,12 +95,12 @@ fn recursive_vars() {\n         \"#,\n         expect![[r#\"\n             10..47 '{     ...&y]; }': ()\n-            20..21 'y': &{unknown}\n-            24..31 'unknown': &{unknown}\n-            37..44 '[y, &y]': [&&{unknown}; 2]\n-            38..39 'y': &{unknown}\n-            41..43 '&y': &&{unknown}\n-            42..43 'y': &{unknown}\n+            20..21 'y': {unknown}\n+            24..31 'unknown': {unknown}\n+            37..44 '[y, &y]': [{unknown}; 2]\n+            38..39 'y': {unknown}\n+            41..43 '&y': &{unknown}\n+            42..43 'y': {unknown}\n         \"#]],\n     );\n }\n@@ -119,19 +117,19 @@ fn recursive_vars_2() {\n         \"#,\n         expect![[r#\"\n             10..79 '{     ...x)]; }': ()\n-            20..21 'x': &&{unknown}\n-            24..31 'unknown': &&{unknown}\n-            41..42 'y': &&{unknown}\n-            45..52 'unknown': &&{unknown}\n-            58..76 '[(x, y..., &x)]': [(&&&{unknown}, &&&{unknown}); 2]\n-            59..65 '(x, y)': (&&&{unknown}, &&&{unknown})\n-            60..61 'x': &&{unknown}\n-            63..64 'y': &&{unknown}\n-            67..75 '(&y, &x)': (&&&{unknown}, &&&{unknown})\n-            68..70 '&y': &&&{unknown}\n-            69..70 'y': &&{unknown}\n-            72..74 '&x': &&&{unknown}\n-            73..74 'x': &&{unknown}\n+            20..21 'x': &{unknown}\n+            24..31 'unknown': &{unknown}\n+            41..42 'y': {unknown}\n+            45..52 'unknown': {unknown}\n+            58..76 '[(x, y..., &x)]': [(&{unknown}, {unknown}); 2]\n+            59..65 '(x, y)': (&{unknown}, {unknown})\n+            60..61 'x': &{unknown}\n+            63..64 'y': {unknown}\n+            67..75 '(&y, &x)': (&{unknown}, {unknown})\n+            68..70 '&y': &{unknown}\n+            69..70 'y': {unknown}\n+            72..74 '&x': &&{unknown}\n+            73..74 'x': &{unknown}\n         \"#]],\n     );\n }\n@@ -165,7 +163,6 @@ fn infer_std_crash_1() {\n \n #[test]\n fn infer_std_crash_2() {\n-    cov_mark::check!(type_var_resolves_to_int_var);\n     // caused \"equating two type variables, ...\", taken from std\n     check_infer(\n         r#\"\n@@ -257,27 +254,27 @@ fn infer_std_crash_5() {\n         expect![[r#\"\n             26..322 '{     ...   } }': ()\n             32..320 'for co...     }': ()\n-            36..43 'content': &{unknown}\n+            36..43 'content': {unknown}\n             47..60 'doesnt_matter': {unknown}\n             61..320 '{     ...     }': ()\n-            75..79 'name': &&{unknown}\n-            82..166 'if doe...     }': &&{unknown}\n+            75..79 'name': &{unknown}\n+            82..166 'if doe...     }': &{unknown}\n             85..98 'doesnt_matter': bool\n-            99..128 '{     ...     }': &&{unknown}\n-            113..118 'first': &&{unknown}\n-            134..166 '{     ...     }': &&{unknown}\n-            148..156 '&content': &&{unknown}\n-            149..156 'content': &{unknown}\n+            99..128 '{     ...     }': &{unknown}\n+            113..118 'first': &{unknown}\n+            134..166 '{     ...     }': &{unknown}\n+            148..156 '&content': &{unknown}\n+            149..156 'content': {unknown}\n             181..188 'content': &{unknown}\n             191..313 'if ICE...     }': &{unknown}\n             194..231 'ICE_RE..._VALUE': {unknown}\n             194..247 'ICE_RE...&name)': bool\n-            241..246 '&name': &&&{unknown}\n-            242..246 'name': &&{unknown}\n-            248..276 '{     ...     }': &&{unknown}\n-            262..266 'name': &&{unknown}\n-            282..313 '{     ...     }': &{unknown}\n-            296..303 'content': &{unknown}\n+            241..246 '&name': &&{unknown}\n+            242..246 'name': &{unknown}\n+            248..276 '{     ...     }': &{unknown}\n+            262..266 'name': &{unknown}\n+            282..313 '{     ...     }': {unknown}\n+            296..303 'content': {unknown}\n         \"#]],\n     );\n }"}, {"sha": "5c70a1fc01cc82011077463aaf60eb3b93f37195", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -1039,42 +1039,6 @@ fn infer_in_elseif() {\n     )\n }\n \n-#[test]\n-fn infer_closure_unify() {\n-    check_infer(\n-        r#\"\n-        fn foo(f: bool) {\n-            let a = |x| x;\n-            let b = |x| x;\n-            let id = if f { a } else { b };\n-            id(123);\n-        }\n-        \"#,\n-        expect![[r#\"\n-            7..8 'f': bool\n-            16..106 '{     ...23); }': ()\n-            26..27 'a': |i32| -> i32\n-            30..35 '|x| x': |i32| -> i32\n-            31..32 'x': i32\n-            34..35 'x': i32\n-            45..46 'b': |i32| -> i32\n-            49..54 '|x| x': |i32| -> i32\n-            50..51 'x': i32\n-            53..54 'x': i32\n-            64..66 'id': |i32| -> i32\n-            69..90 'if f {... { b }': |i32| -> i32\n-            72..73 'f': bool\n-            74..79 '{ a }': |i32| -> i32\n-            76..77 'a': |i32| -> i32\n-            85..90 '{ b }': |i32| -> i32\n-            87..88 'b': |i32| -> i32\n-            96..98 'id': |i32| -> i32\n-            96..103 'id(123)': i32\n-            99..102 '123': i32\n-        \"#]],\n-    )\n-}\n-\n #[test]\n fn infer_if_match_with_return() {\n     check_infer("}, {"sha": "a5a2df54cb69a92d881e2e692be58a86647a703f", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -3104,7 +3104,7 @@ fn foo() {\n             568..573 'f(&s)': FnOnce::Output<dyn FnOnce(&Option<i32>), (&Option<i32>,)>\n             570..572 '&s': &Option<i32>\n             571..572 's': Option<i32>\n-            549..562: expected Box<dyn FnOnce(&Option<i32>)>, got Box<|_| -> ()>\n+            549..562: expected Box<dyn FnOnce(&Option<i32>)>, got Box<|{unknown}| -> ()>\n         \"#]],\n     );\n }"}, {"sha": "708797c4772239230f0096252047ed1faa43118b", "filename": "crates/hir_ty/src/tls.rs", "status": "modified", "additions": 3, "deletions": 135, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftls.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -1,7 +1,7 @@\n //! Implementation of Chalk debug helper functions using TLS.\n-use std::fmt;\n+use std::fmt::{self, Debug};\n \n-use chalk_ir::{AliasTy, GenericArg, Goal, Goals, Lifetime, ProgramClauseImplication};\n+use chalk_ir::AliasTy;\n use itertools::Itertools;\n \n use crate::{\n@@ -53,22 +53,14 @@ impl DebugContext<'_> {\n         write!(fmt, \"{}::{}\", trait_data.name, type_alias_data.name)\n     }\n \n-    pub(crate) fn debug_opaque_ty_id(\n-        &self,\n-        opaque_ty_id: chalk_ir::OpaqueTyId<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Result<(), fmt::Error> {\n-        fmt.debug_struct(\"OpaqueTyId\").field(\"index\", &opaque_ty_id.0).finish()\n-    }\n-\n     pub(crate) fn debug_alias(\n         &self,\n         alias_ty: &AliasTy<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Result<(), fmt::Error> {\n         match alias_ty {\n             AliasTy::Projection(projection_ty) => self.debug_projection_ty(projection_ty, fmt),\n-            AliasTy::Opaque(opaque_ty) => self.debug_opaque_ty(opaque_ty, fmt),\n+            AliasTy::Opaque(opaque_ty) => opaque_ty.fmt(fmt),\n         }\n     }\n \n@@ -96,79 +88,6 @@ impl DebugContext<'_> {\n         write!(fmt, \">::{}\", type_alias_data.name)\n     }\n \n-    pub(crate) fn debug_opaque_ty(\n-        &self,\n-        opaque_ty: &chalk_ir::OpaqueTy<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Result<(), fmt::Error> {\n-        write!(fmt, \"{:?}\", opaque_ty.opaque_ty_id)\n-    }\n-\n-    pub(crate) fn debug_ty(\n-        &self,\n-        ty: &chalk_ir::Ty<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Result<(), fmt::Error> {\n-        write!(fmt, \"{:?}\", ty.data(&Interner))\n-    }\n-\n-    pub(crate) fn debug_lifetime(\n-        &self,\n-        lifetime: &Lifetime<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Result<(), fmt::Error> {\n-        write!(fmt, \"{:?}\", lifetime.data(&Interner))\n-    }\n-\n-    pub(crate) fn debug_generic_arg(\n-        &self,\n-        parameter: &GenericArg<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Result<(), fmt::Error> {\n-        write!(fmt, \"{:?}\", parameter.data(&Interner).inner_debug())\n-    }\n-\n-    pub(crate) fn debug_goal(\n-        &self,\n-        goal: &Goal<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Result<(), fmt::Error> {\n-        let goal_data = goal.data(&Interner);\n-        write!(fmt, \"{:?}\", goal_data)\n-    }\n-\n-    pub(crate) fn debug_goals(\n-        &self,\n-        goals: &Goals<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Result<(), fmt::Error> {\n-        write!(fmt, \"{:?}\", goals.debug(&Interner))\n-    }\n-\n-    pub(crate) fn debug_program_clause_implication(\n-        &self,\n-        pci: &ProgramClauseImplication<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Result<(), fmt::Error> {\n-        write!(fmt, \"{:?}\", pci.debug(&Interner))\n-    }\n-\n-    pub(crate) fn debug_substitution(\n-        &self,\n-        substitution: &chalk_ir::Substitution<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Result<(), fmt::Error> {\n-        write!(fmt, \"{:?}\", substitution.debug(&Interner))\n-    }\n-\n-    pub(crate) fn debug_separator_trait_ref(\n-        &self,\n-        separator_trait_ref: &chalk_ir::SeparatorTraitRef<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Result<(), fmt::Error> {\n-        write!(fmt, \"{:?}\", separator_trait_ref.debug(&Interner))\n-    }\n-\n     pub(crate) fn debug_fn_def_id(\n         &self,\n         fn_def_id: chalk_ir::FnDefId<Interner>,\n@@ -190,57 +109,6 @@ impl DebugContext<'_> {\n             }\n         }\n     }\n-\n-    pub(crate) fn debug_const(\n-        &self,\n-        _constant: &chalk_ir::Const<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result {\n-        write!(fmt, \"const\")\n-    }\n-\n-    pub(crate) fn debug_variable_kinds(\n-        &self,\n-        variable_kinds: &chalk_ir::VariableKinds<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result {\n-        write!(fmt, \"{:?}\", variable_kinds.as_slice(&Interner))\n-    }\n-    pub(crate) fn debug_variable_kinds_with_angles(\n-        &self,\n-        variable_kinds: &chalk_ir::VariableKinds<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result {\n-        write!(fmt, \"{:?}\", variable_kinds.inner_debug(&Interner))\n-    }\n-    pub(crate) fn debug_canonical_var_kinds(\n-        &self,\n-        canonical_var_kinds: &chalk_ir::CanonicalVarKinds<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result {\n-        write!(fmt, \"{:?}\", canonical_var_kinds.as_slice(&Interner))\n-    }\n-    pub(crate) fn debug_program_clause(\n-        &self,\n-        clause: &chalk_ir::ProgramClause<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result {\n-        write!(fmt, \"{:?}\", clause.data(&Interner))\n-    }\n-    pub(crate) fn debug_program_clauses(\n-        &self,\n-        clauses: &chalk_ir::ProgramClauses<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result {\n-        write!(fmt, \"{:?}\", clauses.as_slice(&Interner))\n-    }\n-    pub(crate) fn debug_quantified_where_clauses(\n-        &self,\n-        clauses: &chalk_ir::QuantifiedWhereClauses<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result {\n-        write!(fmt, \"{:?}\", clauses.as_slice(&Interner))\n-    }\n }\n \n mod unsafe_tls {"}, {"sha": "294cb531c8b0e85605ece79e8dcc8d727ed0f04e", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -2,15 +2,15 @@\n \n use std::env::var;\n \n-use chalk_ir::cast::Cast;\n+use chalk_ir::GoalData;\n use chalk_solve::{logging_db::LoggingRustIrDatabase, Solver};\n \n use base_db::CrateId;\n use hir_def::{lang_item::LangItemTarget, TraitId};\n use stdx::panic_context;\n \n use crate::{\n-    db::HirDatabase, AliasEq, AliasTy, Canonical, DomainGoal, Guidance, HirDisplay, InEnvironment,\n+    db::HirDatabase, AliasEq, AliasTy, Canonical, DomainGoal, Goal, Guidance, InEnvironment,\n     Interner, Solution, TraitRefExt, Ty, TyKind, WhereClause,\n };\n \n@@ -38,13 +38,22 @@ fn create_chalk_solver() -> chalk_recursive::RecursiveSolver<Interner> {\n /// we assume that `T: Default`.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TraitEnvironment {\n+    pub krate: CrateId,\n     // When we're using Chalk's Ty we can make this a BTreeMap since it's Ord,\n     // but for now it's too annoying...\n     pub(crate) traits_from_clauses: Vec<(Ty, TraitId)>,\n     pub env: chalk_ir::Environment<Interner>,\n }\n \n impl TraitEnvironment {\n+    pub fn empty(krate: CrateId) -> Self {\n+        TraitEnvironment {\n+            krate,\n+            traits_from_clauses: Vec::new(),\n+            env: chalk_ir::Environment::new(&Interner),\n+        }\n+    }\n+\n     pub(crate) fn traits_in_scope_from_clauses<'a>(\n         &'a self,\n         ty: &'a Ty,\n@@ -59,46 +68,35 @@ impl TraitEnvironment {\n     }\n }\n \n-impl Default for TraitEnvironment {\n-    fn default() -> Self {\n-        TraitEnvironment {\n-            traits_from_clauses: Vec::new(),\n-            env: chalk_ir::Environment::new(&Interner),\n-        }\n-    }\n-}\n-\n /// Solve a trait goal using Chalk.\n pub(crate) fn trait_solve_query(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n-    goal: Canonical<InEnvironment<DomainGoal>>,\n+    goal: Canonical<InEnvironment<Goal>>,\n ) -> Option<Solution> {\n-    let _p = profile::span(\"trait_solve_query\").detail(|| match &goal.value.goal {\n-        DomainGoal::Holds(WhereClause::Implemented(it)) => {\n+    let _p = profile::span(\"trait_solve_query\").detail(|| match &goal.value.goal.data(&Interner) {\n+        GoalData::DomainGoal(DomainGoal::Holds(WhereClause::Implemented(it))) => {\n             db.trait_data(it.hir_trait_id()).name.to_string()\n         }\n-        DomainGoal::Holds(WhereClause::AliasEq(_)) => \"alias_eq\".to_string(),\n+        GoalData::DomainGoal(DomainGoal::Holds(WhereClause::AliasEq(_))) => \"alias_eq\".to_string(),\n         _ => \"??\".to_string(),\n     });\n-    log::info!(\"trait_solve_query({})\", goal.value.goal.display(db));\n+    log::info!(\"trait_solve_query({:?})\", goal.value.goal);\n \n-    if let DomainGoal::Holds(WhereClause::AliasEq(AliasEq {\n+    if let GoalData::DomainGoal(DomainGoal::Holds(WhereClause::AliasEq(AliasEq {\n         alias: AliasTy::Projection(projection_ty),\n         ..\n-    })) = &goal.value.goal\n+    }))) = &goal.value.goal.data(&Interner)\n     {\n         if let TyKind::BoundVar(_) = projection_ty.self_type_parameter(&Interner).kind(&Interner) {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n             return Some(Solution::Ambig(Guidance::Unknown));\n         }\n     }\n \n-    let canonical = goal.cast(&Interner);\n-\n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)\n-    let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };\n+    let u_canonical = chalk_ir::UCanonical { canonical: goal, universes: 1 };\n     solve(db, krate, &u_canonical)\n }\n "}, {"sha": "6b04ee1648717d1176c82414e15c868696e389b7", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbde25ca2f13ffacfd006ada7b38618d36d97c6/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=edbde25ca2f13ffacfd006ada7b38618d36d97c6", "patch": "@@ -323,7 +323,7 @@ fn compute_type_match(\n \n     if completion_ty == expected_type {\n         Some(CompletionRelevanceTypeMatch::Exact)\n-    } else if expected_type.could_unify_with(completion_ty) {\n+    } else if expected_type.could_unify_with(ctx.db, completion_ty) {\n         Some(CompletionRelevanceTypeMatch::CouldUnify)\n     } else {\n         None"}]}