{"sha": "6ad140ca197a1147e476f34908c2b69a60cc6d2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZDE0MGNhMTk3YTExNDdlNDc2ZjM0OTA4YzJiNjlhNjBjYzZkMmY=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-23T10:13:44Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-23T10:16:58Z"}, "message": "const_eval_checked: deal with unused nodes + div", "tree": {"sha": "c865da58b170f1829027bcb0902897a4f39a35a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c865da58b170f1829027bcb0902897a4f39a35a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ad140ca197a1147e476f34908c2b69a60cc6d2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad140ca197a1147e476f34908c2b69a60cc6d2f", "html_url": "https://github.com/rust-lang/rust/commit/6ad140ca197a1147e476f34908c2b69a60cc6d2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ad140ca197a1147e476f34908c2b69a60cc6d2f/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9cd294cf2775441e713c7ee2918b728733b99f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cd294cf2775441e713c7ee2918b728733b99f5", "html_url": "https://github.com/rust-lang/rust/commit/a9cd294cf2775441e713c7ee2918b728733b99f5"}], "stats": {"total": 125, "additions": 113, "deletions": 12}, "files": [{"sha": "cb0950e3627418ab93fcf5cd3fbdfea119d08733", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6ad140ca197a1147e476f34908c2b69a60cc6d2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad140ca197a1147e476f34908c2b69a60cc6d2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=6ad140ca197a1147e476f34908c2b69a60cc6d2f", "patch": "@@ -227,7 +227,12 @@ struct AbstractConstBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n     /// The current WIP node tree.\n-    nodes: IndexVec<NodeId, Node<'tcx>>,\n+    ///\n+    /// We require all nodes to be used in the final abstract const,\n+    /// so we store this here. Note that we also consider nodes as used\n+    /// if they are mentioned in an assert, so some used nodes are never\n+    /// actually reachable by walking the [`AbstractConst`].\n+    nodes: IndexVec<NodeId, (Node<'tcx>, bool)>,\n     locals: IndexVec<mir::Local, NodeId>,\n     /// We only allow field accesses if they access\n     /// the result of a checked operation.\n@@ -274,6 +279,27 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         Ok(Some(builder))\n     }\n \n+    fn add_node(&mut self, n: Node<'tcx>) -> NodeId {\n+        // Mark used nodes.\n+        match n {\n+            Node::Leaf(_) => (),\n+            Node::Binop(_, lhs, rhs) => {\n+                self.nodes[lhs].1 = true;\n+                self.nodes[rhs].1 = true;\n+            }\n+            Node::UnaryOp(_, input) => {\n+                self.nodes[input].1 = true;\n+            }\n+            Node::FunctionCall(func, nodes) => {\n+                self.nodes[func].1 = true;\n+                nodes.iter().for_each(|&n| self.nodes[n].1 = true);\n+            }\n+        }\n+\n+        // Nodes start as unused.\n+        self.nodes.push((n, false))\n+    }\n+\n     fn place_to_local(\n         &mut self,\n         span: Span,\n@@ -311,7 +337,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 let local = self.place_to_local(span, p)?;\n                 Ok(self.locals[local])\n             }\n-            mir::Operand::Constant(ct) => Ok(self.nodes.push(Node::Leaf(ct.literal))),\n+            mir::Operand::Constant(ct) => Ok(self.add_node(Node::Leaf(ct.literal))),\n         }\n     }\n \n@@ -348,7 +374,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n                         let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n                         let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n-                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n                         if op.is_checkable() {\n                             bug!(\"unexpected unchecked checkable binary operation\");\n                         } else {\n@@ -358,13 +384,13 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n                         let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n                         let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n-                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n                         self.checked_op_locals.insert(local);\n                         Ok(())\n                     }\n                     Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n                         let operand = self.operand_to_node(stmt.source_info.span, operand)?;\n-                        self.locals[local] = self.nodes.push(Node::UnaryOp(op, operand));\n+                        self.locals[local] = self.add_node(Node::UnaryOp(op, operand));\n                         Ok(())\n                     }\n                     _ => self.error(Some(stmt.source_info.span), \"unsupported rvalue\")?,\n@@ -415,13 +441,9 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                         .map(|arg| self.operand_to_node(terminator.source_info.span, arg))\n                         .collect::<Result<Vec<NodeId>, _>>()?,\n                 );\n-                self.locals[local] = self.nodes.push(Node::FunctionCall(func, args));\n+                self.locals[local] = self.add_node(Node::FunctionCall(func, args));\n                 Ok(Some(target))\n             }\n-            // We only allow asserts for checked operations.\n-            //\n-            // These asserts seem to all have the form `!_local.0` so\n-            // we only allow exactly that.\n             TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n                 let p = match cond {\n                     mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n@@ -430,7 +452,15 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n                 const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n                 debug!(\"proj: {:?}\", p.projection);\n-                if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n+                if let Some(p) = p.as_local() {\n+                    debug_assert!(!self.checked_op_locals.contains(p));\n+                    // Mark locals directly used in asserts as used.\n+                    //\n+                    // This is needed because division does not use `CheckedBinop` but instead\n+                    // adds an explicit assert for `divisor != 0`.\n+                    self.nodes[self.locals[p]].1 = true;\n+                    return Ok(Some(target));\n+                } else if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n                     // Only allow asserts checking the result of a checked operation.\n                     if self.checked_op_locals.contains(p.local) {\n                         return Ok(Some(target));\n@@ -457,7 +487,16 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             if let Some(next) = self.build_terminator(block.terminator())? {\n                 block = &self.body.basic_blocks()[next];\n             } else {\n-                return Ok(self.tcx.arena.alloc_from_iter(self.nodes));\n+                assert_eq!(self.locals[mir::Local::from_usize(0)], self.nodes.last().unwrap());\n+                self.nodes[self.locals[mir::Local::from_usize(0)]].1 = true;\n+                if !self.nodes.iter().all(|n| n.1) {\n+                    self.error(None, \"unused node\")?;\n+                }\n+\n+                return Ok(self\n+                    .tcx\n+                    .arena\n+                    .alloc_from_iter(self.nodes.into_iter().map(|(n, _used)| n)));\n             }\n         }\n     }"}, {"sha": "71a5f2d3472013d457b6b623159c1313c5266c49", "filename": "src/test/ui/const-generics/const_evaluatable_checked/division.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6ad140ca197a1147e476f34908c2b69a60cc6d2f/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdivision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad140ca197a1147e476f34908c2b69a60cc6d2f/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdivision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdivision.rs?ref=6ad140ca197a1147e476f34908c2b69a60cc6d2f", "patch": "@@ -0,0 +1,11 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+fn with_bound<const N: usize>() where [u8; N / 2]: Sized {\n+    let _: [u8; N / 2] = [0; N / 2];\n+}\n+\n+fn main() {\n+    with_bound::<4>();\n+}"}, {"sha": "9c603c57a4818e16dc127e89c07702a29b60b625", "filename": "src/test/ui/const-generics/const_evaluatable_checked/unused_expr.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6ad140ca197a1147e476f34908c2b69a60cc6d2f/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad140ca197a1147e476f34908c2b69a60cc6d2f/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.rs?ref=6ad140ca197a1147e476f34908c2b69a60cc6d2f", "patch": "@@ -0,0 +1,25 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+fn add<const N: usize>() -> [u8; { N + 1; 5 }] {\n+    //~^ ERROR overly complex generic constant\n+    todo!()\n+}\n+\n+fn div<const N: usize>() -> [u8; { N / 1; 5 }] {\n+    //~^ ERROR overly complex generic constant\n+    todo!()\n+}\n+\n+const fn foo(n: usize) {}\n+\n+fn fn_call<const N: usize>() -> [u8; { foo(N); 5 }] {\n+    //~^ ERROR overly complex generic constant\n+    todo!()\n+}\n+\n+fn main() {\n+    add::<12>();\n+    div::<9>();\n+    fn_call::<14>();\n+}"}, {"sha": "73c6d9393ce7fad6f3f428450225b7f2eadab0f7", "filename": "src/test/ui/const-generics/const_evaluatable_checked/unused_expr.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ad140ca197a1147e476f34908c2b69a60cc6d2f/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ad140ca197a1147e476f34908c2b69a60cc6d2f/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr?ref=6ad140ca197a1147e476f34908c2b69a60cc6d2f", "patch": "@@ -0,0 +1,26 @@\n+error: overly complex generic constant\n+  --> $DIR/unused_expr.rs:4:34\n+   |\n+LL | fn add<const N: usize>() -> [u8; { N + 1; 5 }] {\n+   |                                  ^^^^^^^^^^^^ unused node\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: overly complex generic constant\n+  --> $DIR/unused_expr.rs:9:34\n+   |\n+LL | fn div<const N: usize>() -> [u8; { N / 1; 5 }] {\n+   |                                  ^^^^^^^^^^^^ unused node\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: overly complex generic constant\n+  --> $DIR/unused_expr.rs:16:38\n+   |\n+LL | fn fn_call<const N: usize>() -> [u8; { foo(N); 5 }] {\n+   |                                      ^^^^^^^^^^^^^ unused node\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: aborting due to 3 previous errors\n+"}]}