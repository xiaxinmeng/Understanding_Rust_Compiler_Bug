{"sha": "dd9df18792cd13b25a54406ef60e3b32ac358272", "node_id": "C_kwDOAAsO6NoAKGRkOWRmMTg3OTJjZDEzYjI1YTU0NDA2ZWY2MGUzYjMyYWMzNTgyNzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-06T13:00:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-06T13:00:33Z"}, "message": "Auto merge of #2867 - Vanille-N:tb-diags, r=RalfJung\n\nSimplify event selection in TB diagnostics\n\nAs discussed previously, getting the range from `RangeMap` can make the filtering of events much simpler without any user-visible diff.\n\nSee minor exception in [<9d8fc00>](https://github.com/rust-lang/miri/commit/9d8fc00a4a57dde06a9c42b809afed827c3b0d5c) and decide how to resolve it\n- add a boolean flag not to record events produced by deallocations ?\n- add a `help: deallocation counts as an implicit write` ? (Note: could be generalized to also include `help: reborrow counts as an implicit read`)\n- not bother and keep as-is ?\n- something else ?", "tree": {"sha": "2af71bec13b2ded6d309534b187dc1685b0ba639", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2af71bec13b2ded6d309534b187dc1685b0ba639"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd9df18792cd13b25a54406ef60e3b32ac358272", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd9df18792cd13b25a54406ef60e3b32ac358272", "html_url": "https://github.com/rust-lang/rust/commit/dd9df18792cd13b25a54406ef60e3b32ac358272", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd9df18792cd13b25a54406ef60e3b32ac358272/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "457a7a83c13fd803b47a5842686cee13eba47d6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/457a7a83c13fd803b47a5842686cee13eba47d6e", "html_url": "https://github.com/rust-lang/rust/commit/457a7a83c13fd803b47a5842686cee13eba47d6e"}, {"sha": "0677cd04450a9492277599eca1d875ff00518c28", "url": "https://api.github.com/repos/rust-lang/rust/commits/0677cd04450a9492277599eca1d875ff00518c28", "html_url": "https://github.com/rust-lang/rust/commit/0677cd04450a9492277599eca1d875ff00518c28"}], "stats": {"total": 203, "additions": 109, "deletions": 94}, "files": [{"sha": "29881bbcfca669c7ef7c1a213b255b38522d43e3", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=dd9df18792cd13b25a54406ef60e3b32ac358272", "patch": "@@ -459,7 +459,7 @@ impl<'tcx> Stack {\n impl Stacks {\n     pub fn remove_unreachable_tags(&mut self, live_tags: &FxHashSet<BorTag>) {\n         if self.modified_since_last_gc {\n-            for stack in self.stacks.iter_mut_all() {\n+            for (_stack_range, stack) in self.stacks.iter_mut_all() {\n                 if stack.len() > 64 {\n                     stack.retain(live_tags);\n                 }\n@@ -511,8 +511,8 @@ impl<'tcx> Stacks {\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         self.modified_since_last_gc = true;\n-        for (offset, stack) in self.stacks.iter_mut(range.start, range.size) {\n-            let mut dcx = dcx_builder.build(&mut self.history, offset);\n+        for (stack_range, stack) in self.stacks.iter_mut(range.start, range.size) {\n+            let mut dcx = dcx_builder.build(&mut self.history, Size::from_bytes(stack_range.start));\n             f(stack, &mut dcx, &mut self.exposed_tags)?;\n             dcx_builder = dcx.unbuild();\n         }"}, {"sha": "10873c46a6c5ddeec5eca89ff37cce4a2c6a2085", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/diagnostics.rs", "status": "modified", "additions": 48, "deletions": 62, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs?ref=dd9df18792cd13b25a54406ef60e3b32ac358272", "patch": "@@ -3,7 +3,6 @@ use std::ops::Range;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_span::{Span, SpanData};\n-use rustc_target::abi::Size;\n \n use crate::borrow_tracker::tree_borrows::{\n     perms::{PermTransition, Permission},\n@@ -14,18 +13,30 @@ use crate::borrow_tracker::{AccessKind, ProtectorKind};\n use crate::*;\n \n /// Complete data for an event:\n-/// - `kind` is what happened to the permissions\n-/// - `access_kind` and `access_range` describe the access that caused the event\n-/// - `offset` allows filtering only the relevant events for a given memory location\n-/// (see how we perform the filtering in `History::extract_relevant`.\n-/// - `span` is the line of code in question\n #[derive(Clone, Debug)]\n pub struct Event {\n+    /// Transformation of permissions that occured because of this event\n     pub transition: PermTransition,\n+    /// Kind of the access that triggered this event\n     pub access_kind: AccessKind,\n+    /// Relative position of the tag to the one used for the access\n     pub is_foreign: bool,\n+    /// User-visible range of the access\n     pub access_range: AllocRange,\n-    pub offset: Size,\n+    /// The transition recorded by this event only occured on a subrange of\n+    /// `access_range`: a single access on `access_range` triggers several events,\n+    /// each with their own mutually disjoint `transition_range`. No-op transitions\n+    /// should not be recorded as events, so the union of all `transition_range` is not\n+    /// necessarily the entire `access_range`.\n+    ///\n+    /// No data from any `transition_range` should ever be user-visible, because\n+    /// both the start and end of `transition_range` are entirely dependent on the\n+    /// internal representation of `RangeMap` which is supposed to be opaque.\n+    /// What will be shown in the error message is the first byte `error_offset` of\n+    /// the `TbError`, which should satisfy\n+    /// `event.transition_range.contains(error.error_offset)`.\n+    pub transition_range: Range<u64>,\n+    /// Line of code that triggered this event\n     pub span: Span,\n }\n \n@@ -35,9 +46,9 @@ pub struct Event {\n /// Available filtering methods include `History::forget` and `History::extract_relevant`.\n #[derive(Clone, Debug)]\n pub struct History {\n-    pub tag: BorTag,\n-    pub created: (Span, Permission),\n-    pub events: Vec<Event>,\n+    tag: BorTag,\n+    created: (Span, Permission),\n+    events: Vec<Event>,\n }\n \n /// History formatted for use by `src/diagnostics.rs`.\n@@ -60,12 +71,7 @@ impl HistoryData {\n     // Format events from `new_history` into those recorded by `self`.\n     //\n     // NOTE: also converts `Span` to `SpanData`.\n-    pub fn extend(\n-        &mut self,\n-        new_history: History,\n-        tag_name: &'static str,\n-        show_initial_state: bool,\n-    ) {\n+    fn extend(&mut self, new_history: History, tag_name: &'static str, show_initial_state: bool) {\n         let History { tag, created, events } = new_history;\n         let this = format!(\"the {tag_name} tag {tag:?}\");\n         let msg_initial_state = format!(\", in the initial state {}\", created.1);\n@@ -75,9 +81,16 @@ impl HistoryData {\n         );\n \n         self.events.push((Some(created.0.data()), msg_creation));\n-        for &Event { transition, access_kind, is_foreign, access_range, span, offset: _ } in &events\n+        for &Event {\n+            transition,\n+            access_kind,\n+            is_foreign,\n+            access_range,\n+            span,\n+            transition_range: _,\n+        } in &events\n         {\n-            // NOTE: `offset` is explicitly absent from the error message, it has no significance\n+            // NOTE: `transition_range` is explicitly absent from the error message, it has no significance\n             // to the user. The meaningful one is `access_range`.\n             self.events.push((Some(span.data()), format!(\"{this} then transitioned {transition} due to a {rel} {access_kind} at offsets {access_range:?}\", rel = if is_foreign { \"foreign\" } else { \"child\" })));\n             self.events.push((None, format!(\"this corresponds to {}\", transition.summary())));\n@@ -197,53 +210,28 @@ impl History {\n         History { events: Vec::new(), created: self.created, tag: self.tag }\n     }\n \n-    /// Reconstruct the history relevant to `error_offset` knowing that\n-    /// its permission followed `complete_transition`.\n-    ///\n-    /// Here's how we do this:\n-    /// - we know `full := complete_transition` the transition of the permission from\n-    /// its initialization to the state just before the error was caused,\n-    /// we want to find a chain of events that produces `full`\n-    /// - we decompose `full` into `pre o post` where\n-    /// `pre` is the best applicable transition from recorded events\n-    /// - we select the event that caused `pre` and iterate\n-    /// to find the chain of events that produces `full := post`\n-    ///\n-    /// To find the \"best applicable transition\" for full:\n-    /// - eliminate events that cannot be applied because their offset is too big\n-    /// - eliminate events that cannot be applied because their starting point is wrong\n-    /// - select the one that happened closest to the range of interest\n-    fn extract_relevant(&self, complete_transition: PermTransition, error_offset: Size) -> Self {\n-        let mut selected_events: Vec<Event> = Vec::new();\n-        let mut full = complete_transition;\n-        while !full.is_noop() {\n-            let (pre, post) = self\n+    /// Reconstruct the history relevant to `error_offset` by filtering\n+    /// only events whose range contains the offset we are interested in.\n+    fn extract_relevant(&self, error_offset: u64) -> Self {\n+        History {\n+            events: self\n                 .events\n                 .iter()\n-                .filter(|e| e.offset <= error_offset)\n-                .filter_map(|pre_canditate| {\n-                    full.apply_start(pre_canditate.transition)\n-                        .map(|post_canditate| (pre_canditate, post_canditate))\n-                })\n-                .max_by_key(|(pre_canditate, _post_candidate)| pre_canditate.offset)\n-                .unwrap();\n-            // If this occurs we will loop infinitely !\n-            // Make sure to only put non-noop transitions in `History`.\n-            assert!(!pre.transition.is_noop());\n-            full = post;\n-            selected_events.push(pre.clone());\n+                .filter(|e| e.transition_range.contains(&error_offset))\n+                .cloned()\n+                .collect::<Vec<_>>(),\n+            created: self.created,\n+            tag: self.tag,\n         }\n-\n-        History { events: selected_events, created: self.created, tag: self.tag }\n     }\n }\n \n /// Failures that can occur during the execution of Tree Borrows procedures.\n pub(super) struct TbError<'node> {\n     /// What failure occurred.\n     pub error_kind: TransitionError,\n-    /// The byte at which the conflict occured.\n-    pub error_offset: Size,\n+    /// The offset (into the allocation) at which the conflict occurred.\n+    pub error_offset: u64,\n     /// The tag on which the error was triggered.\n     /// On protector violations, this is the tag that was protected.\n     /// On accesses rejected due to insufficient permissions, this is the\n@@ -261,12 +249,11 @@ impl TbError<'_> {\n     /// Produce a UB error.\n     pub fn build<'tcx>(self) -> InterpError<'tcx> {\n         use TransitionError::*;\n-        let started_as = self.conflicting_info.history.created.1;\n         let kind = self.access_kind;\n         let accessed = self.accessed_info;\n         let conflicting = self.conflicting_info;\n         let accessed_is_conflicting = accessed.tag == conflicting.tag;\n-        let (pre_error, title, details, conflicting_tag_name) = match self.error_kind {\n+        let (title, details, conflicting_tag_name) = match self.error_kind {\n             ChildAccessForbidden(perm) => {\n                 let conflicting_tag_name =\n                     if accessed_is_conflicting { \"accessed\" } else { \"conflicting\" };\n@@ -280,7 +267,7 @@ impl TbError<'_> {\n                 details.push(format!(\n                     \"the {conflicting_tag_name} tag {conflicting} has state {perm} which forbids child {kind}es\"\n                 ));\n-                (perm, title, details, conflicting_tag_name)\n+                (title, details, conflicting_tag_name)\n             }\n             ProtectedTransition(transition) => {\n                 let conflicting_tag_name = \"protected\";\n@@ -297,7 +284,7 @@ impl TbError<'_> {\n                         loss = transition.summary(),\n                     ),\n                 ];\n-                (transition.started(), title, details, conflicting_tag_name)\n+                (title, details, conflicting_tag_name)\n             }\n             ProtectedDealloc => {\n                 let conflicting_tag_name = \"strongly protected\";\n@@ -308,16 +295,15 @@ impl TbError<'_> {\n                     ),\n                     format!(\"the {conflicting_tag_name} tag {conflicting} disallows deallocations\"),\n                 ];\n-                (started_as, title, details, conflicting_tag_name)\n+                (title, details, conflicting_tag_name)\n             }\n         };\n-        let pre_transition = PermTransition::from(started_as, pre_error).unwrap();\n         let mut history = HistoryData::default();\n         if !accessed_is_conflicting {\n             history.extend(self.accessed_info.history.forget(), \"accessed\", false);\n         }\n         history.extend(\n-            self.conflicting_info.history.extract_relevant(pre_transition, self.error_offset),\n+            self.conflicting_info.history.extract_relevant(self.error_offset),\n             conflicting_tag_name,\n             true,\n         );"}, {"sha": "eb19699d103b8f4dcd7fd58194b6ccb2c228a037", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/tree.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs?ref=dd9df18792cd13b25a54406ef60e3b32ac358272", "patch": "@@ -311,7 +311,7 @@ impl<'tcx> Tree {\n         parent_tag: BorTag,\n         new_tag: BorTag,\n         default_initial_perm: Permission,\n-        range: AllocRange,\n+        reborrow_range: AllocRange,\n         span: Span,\n     ) -> InterpResult<'tcx> {\n         assert!(!self.tag_mapping.contains_key(&new_tag));\n@@ -332,7 +332,8 @@ impl<'tcx> Tree {\n         self.nodes.get_mut(parent_idx).unwrap().children.push(idx);\n         // Initialize perms\n         let perm = LocationState::new(default_initial_perm).with_access();\n-        for (_range, perms) in self.rperms.iter_mut(range.start, range.size) {\n+        for (_perms_range, perms) in self.rperms.iter_mut(reborrow_range.start, reborrow_range.size)\n+        {\n             perms.insert(idx, perm);\n         }\n         Ok(())\n@@ -344,12 +345,12 @@ impl<'tcx> Tree {\n     pub fn dealloc(\n         &mut self,\n         tag: BorTag,\n-        range: AllocRange,\n+        access_range: AllocRange,\n         global: &GlobalState,\n         span: Span, // diagnostics\n     ) -> InterpResult<'tcx> {\n-        self.perform_access(AccessKind::Write, tag, range, global, span)?;\n-        for (offset, perms) in self.rperms.iter_mut(range.start, range.size) {\n+        self.perform_access(AccessKind::Write, tag, access_range, global, span)?;\n+        for (perms_range, perms) in self.rperms.iter_mut(access_range.start, access_range.size) {\n             TreeVisitor { nodes: &mut self.nodes, tag_mapping: &self.tag_mapping, perms }\n                 .traverse_parents_this_children_others(\n                     tag,\n@@ -368,7 +369,7 @@ impl<'tcx> Tree {\n                         TbError {\n                             conflicting_info,\n                             access_kind: AccessKind::Write,\n-                            error_offset: offset,\n+                            error_offset: perms_range.start,\n                             error_kind,\n                             accessed_info,\n                         }\n@@ -388,11 +389,11 @@ impl<'tcx> Tree {\n         &mut self,\n         access_kind: AccessKind,\n         tag: BorTag,\n-        range: AllocRange,\n+        access_range: AllocRange,\n         global: &GlobalState,\n         span: Span, // diagnostics\n     ) -> InterpResult<'tcx> {\n-        for (offset, perms) in self.rperms.iter_mut(range.start, range.size) {\n+        for (perms_range, perms) in self.rperms.iter_mut(access_range.start, access_range.size) {\n             TreeVisitor { nodes: &mut self.nodes, tag_mapping: &self.tag_mapping, perms }\n                 .traverse_parents_this_children_others(\n                     tag,\n@@ -456,9 +457,9 @@ impl<'tcx> Tree {\n                             node.debug_info.history.push(diagnostics::Event {\n                                 transition,\n                                 access_kind,\n-                                access_range: range,\n                                 is_foreign: rel_pos.is_foreign(),\n-                                offset,\n+                                access_range,\n+                                transition_range: perms_range.clone(),\n                                 span,\n                             });\n                             old_state.permission =\n@@ -472,7 +473,7 @@ impl<'tcx> Tree {\n                         TbError {\n                             conflicting_info,\n                             access_kind,\n-                            error_offset: offset,\n+                            error_offset: perms_range.start,\n                             error_kind,\n                             accessed_info,\n                         }\n@@ -530,7 +531,7 @@ impl Tree {\n             // the tag from the mapping.\n             let tag = node.tag;\n             self.nodes.remove(idx);\n-            for perms in self.rperms.iter_mut_all() {\n+            for (_perms_range, perms) in self.rperms.iter_mut_all() {\n                 perms.remove(idx);\n             }\n             self.tag_mapping.remove(&tag);"}, {"sha": "f6252c43f9fe26eecc5e525f845328738194b33f", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=dd9df18792cd13b25a54406ef60e3b32ac358272", "patch": "@@ -868,15 +868,17 @@ impl VClockAlloc {\n     pub fn read<'tcx>(\n         &self,\n         alloc_id: AllocId,\n-        range: AllocRange,\n+        access_range: AllocRange,\n         machine: &MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n         let current_span = machine.current_span();\n         let global = machine.data_race.as_ref().unwrap();\n         if global.race_detecting() {\n             let (index, mut thread_clocks) = global.current_thread_state_mut(&machine.threads);\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n-            for (offset, mem_clocks) in alloc_ranges.iter_mut(range.start, range.size) {\n+            for (mem_clocks_range, mem_clocks) in\n+                alloc_ranges.iter_mut(access_range.start, access_range.size)\n+            {\n                 if let Err(DataRace) =\n                     mem_clocks.read_race_detect(&mut thread_clocks, index, current_span)\n                 {\n@@ -888,7 +890,7 @@ impl VClockAlloc {\n                         mem_clocks,\n                         \"Read\",\n                         false,\n-                        Pointer::new(alloc_id, offset),\n+                        Pointer::new(alloc_id, Size::from_bytes(mem_clocks_range.start)),\n                     );\n                 }\n             }\n@@ -902,16 +904,16 @@ impl VClockAlloc {\n     fn unique_access<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n-        range: AllocRange,\n+        access_range: AllocRange,\n         write_type: WriteType,\n         machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n         let current_span = machine.current_span();\n         let global = machine.data_race.as_mut().unwrap();\n         if global.race_detecting() {\n             let (index, mut thread_clocks) = global.current_thread_state_mut(&machine.threads);\n-            for (offset, mem_clocks) in\n-                self.alloc_ranges.get_mut().iter_mut(range.start, range.size)\n+            for (mem_clocks_range, mem_clocks) in\n+                self.alloc_ranges.get_mut().iter_mut(access_range.start, access_range.size)\n             {\n                 if let Err(DataRace) = mem_clocks.write_race_detect(\n                     &mut thread_clocks,\n@@ -927,7 +929,7 @@ impl VClockAlloc {\n                         mem_clocks,\n                         write_type.get_descriptor(),\n                         false,\n-                        Pointer::new(alloc_id, offset),\n+                        Pointer::new(alloc_id, Size::from_bytes(mem_clocks_range.start)),\n                     );\n                 }\n             }\n@@ -1150,7 +1152,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n                     &this.machine.threads,\n                     current_span,\n                     |index, mut thread_clocks| {\n-                        for (offset, mem_clocks) in\n+                        for (mem_clocks_range, mem_clocks) in\n                             alloc_meta.alloc_ranges.borrow_mut().iter_mut(base_offset, size)\n                         {\n                             if let Err(DataRace) = op(mem_clocks, &mut thread_clocks, index, atomic)\n@@ -1162,7 +1164,10 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n                                     mem_clocks,\n                                     description,\n                                     true,\n-                                    Pointer::new(alloc_id, offset),\n+                                    Pointer::new(\n+                                        alloc_id,\n+                                        Size::from_bytes(mem_clocks_range.start),\n+                                    ),\n                                 )\n                                 .map(|_| true);\n                             }"}, {"sha": "048c25668e1c92482a9f06bdd013ce88b13c8f48", "filename": "src/tools/miri/src/range_map.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs?ref=dd9df18792cd13b25a54406ef60e3b32ac358272", "patch": "@@ -62,8 +62,10 @@ impl<T> RangeMap<T> {\n     /// *not* split items if they overlap with the edges. Do not use this to mutate\n     /// through interior mutability.\n     ///\n-    /// The iterator also provides the offset of the given element.\n-    pub fn iter(&self, offset: Size, len: Size) -> impl Iterator<Item = (Size, &T)> {\n+    /// The iterator also provides the range of the given element.\n+    /// How exactly the ranges are split can differ even for otherwise identical\n+    /// maps, so user-visible behavior should never depend on the exact range.\n+    pub fn iter(&self, offset: Size, len: Size) -> impl Iterator<Item = (ops::Range<u64>, &T)> {\n         let offset = offset.bytes();\n         let len = len.bytes();\n         // Compute a slice starting with the elements we care about.\n@@ -84,13 +86,21 @@ impl<T> RangeMap<T> {\n         slice\n             .iter()\n             .take_while(move |elem| elem.range.start < end)\n-            .map(|elem| (Size::from_bytes(elem.range.start), &elem.data))\n+            .map(|elem| (elem.range.clone(), &elem.data))\n     }\n \n-    pub fn iter_mut_all(&mut self) -> impl Iterator<Item = &mut T> {\n-        self.v.iter_mut().map(|elem| &mut elem.data)\n+    /// Provides mutable iteration over all elements.\n+    /// The iterator also provides the range of the given element.\n+    /// How exactly the ranges are split can differ even for otherwise identical\n+    /// maps, so user-visible behavior should never depend on the exact range.\n+    pub fn iter_mut_all(&mut self) -> impl Iterator<Item = (ops::Range<u64>, &mut T)> {\n+        self.v.iter_mut().map(|elem| (elem.range.clone(), &mut elem.data))\n     }\n \n+    /// Provides iteration over all elements.\n+    /// The iterator also provides the range of the given element.\n+    /// How exactly the ranges are split can differ even for otherwise identical\n+    /// maps, so user-visible behavior should never depend on the exact range.\n     pub fn iter_all(&self) -> impl Iterator<Item = (ops::Range<u64>, &T)> {\n         self.v.iter().map(|elem| (elem.range.clone(), &elem.data))\n     }\n@@ -126,8 +136,15 @@ impl<T> RangeMap<T> {\n     /// to make sure that when they are mutated, the effect is constrained to the given range.\n     /// Moreover, this will opportunistically merge neighbouring equal blocks.\n     ///\n-    /// The iterator also provides the offset of the given element.\n-    pub fn iter_mut(&mut self, offset: Size, len: Size) -> impl Iterator<Item = (Size, &mut T)>\n+    /// The iterator also provides the range of the given element.\n+    /// How exactly the ranges are split (both prior to and resulting from the execution of this\n+    /// function) can differ even for otherwise identical maps,\n+    /// so user-visible behavior should never depend on the exact range.\n+    pub fn iter_mut(\n+        &mut self,\n+        offset: Size,\n+        len: Size,\n+    ) -> impl Iterator<Item = (ops::Range<u64>, &mut T)>\n     where\n         T: Clone + PartialEq,\n     {\n@@ -208,7 +225,7 @@ impl<T> RangeMap<T> {\n             // Now we yield the slice. `end` is inclusive.\n             &mut self.v[first_idx..=end_idx]\n         };\n-        slice.iter_mut().map(|elem| (Size::from_bytes(elem.range.start), &mut elem.data))\n+        slice.iter_mut().map(|elem| (elem.range.clone(), &mut elem.data))\n     }\n }\n "}, {"sha": "071b216ff982befde074245a6f69d5183205d9e2", "filename": "src/tools/miri/tests/fail/tree-borrows/strongly-protected.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr?ref=dd9df18792cd13b25a54406ef60e3b32ac358272", "patch": "@@ -17,6 +17,12 @@ help: the strongly protected tag <TAG> was created here, in the initial state Re\n    |\n LL | fn inner(x: &mut i32, f: fn(&mut i32)) {\n    |          ^\n+help: the strongly protected tag <TAG> then transitioned from Reserved to Active due to a child write access at offsets [0x0..0x4]\n+  --> $DIR/strongly-protected.rs:LL:CC\n+   |\n+LL |         drop(unsafe { Box::from_raw(raw) });\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: this corresponds to an activation\n    = note: BACKTRACE (of the first span):\n    = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n    = note: inside `<std::alloc::Global as std::alloc::Allocator>::deallocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC"}]}