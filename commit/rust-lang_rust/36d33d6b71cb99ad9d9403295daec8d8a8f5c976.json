{"sha": "36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZDMzZDZiNzFjYjk5YWQ5ZDk0MDMyOTVkYWVjOGQ4YThmNWM5NzY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-28T03:09:28Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-28T03:09:28Z"}, "message": "rustc_privacy: visit Ty instead of HIR types in EmbargoVisitor.", "tree": {"sha": "8721020e8babd68c3b6c545a3db99f1df0b205e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8721020e8babd68c3b6c545a3db99f1df0b205e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "html_url": "https://github.com/rust-lang/rust/commit/36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9aaf26e7aa4068d7e5643b136fb70ecd689a746d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aaf26e7aa4068d7e5643b136fb70ecd689a746d", "html_url": "https://github.com/rust-lang/rust/commit/9aaf26e7aa4068d7e5643b136fb70ecd689a746d"}], "stats": {"total": 376, "additions": 218, "deletions": 158}, "files": [{"sha": "767886a23157729a7d3e356284b5ad0aaeb5ba0a", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "patch": "@@ -298,7 +298,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // Nothing to recurse on for these\n             ast_map::NodeForeignItem(_) |\n             ast_map::NodeVariant(_) |\n-            ast_map::NodeStructCtor(_) => {}\n+            ast_map::NodeStructCtor(_) |\n+            ast_map::NodeTy(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n                      self.tcx.map.node_to_string(search_item))"}, {"sha": "10754825a8c1873c9b7100ea262ee5643daf09b7", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "patch": "@@ -191,6 +191,10 @@ pub trait TypeVisitor<'tcx> : Sized {\n         t.super_visit_with(self)\n     }\n \n+    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n+        trait_ref.super_visit_with(self)\n+    }\n+\n     fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n         r.super_visit_with(self)\n     }"}, {"sha": "844fc58cec37b9864d2d7db4594c7a90570f9b79", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "patch": "@@ -1280,8 +1280,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(ast_map::NodeExpr(expr)) => {\n                 // This is a convenience to allow closures to work.\n-                if let hir::ExprClosure(..) = expr.node {\n-                    ParameterEnvironment::for_item(tcx, tcx.map.get_parent(id))\n+                if let hir::ExprClosure(.., ref body, _) = expr.node {\n+                    let def_id = tcx.map.local_def_id(id);\n+                    let base_def_id = tcx.closure_base_def_id(def_id);\n+                    tcx.construct_parameter_environment(\n+                        expr.span,\n+                        base_def_id,\n+                        tcx.region_maps.call_site_extent(id, body.id))\n                 } else {\n                     tcx.empty_parameter_environment()\n                 }"}, {"sha": "c8618cd154781b8f3a848920da8a929e8d4c2ae8", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "patch": "@@ -599,6 +599,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.substs.visit_with(visitor)\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_trait_ref(*self)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialTraitRef<'tcx> {\n@@ -766,6 +770,36 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::Generics {\n+            parent: self.parent,\n+            parent_regions: self.parent_regions,\n+            parent_types: self.parent_types,\n+            regions: self.regions.fold_with(folder),\n+            types: self.types.fold_with(folder),\n+            has_self: self.has_self,\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.regions.visit_with(visitor) || self.types.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::GenericPredicates {\n+            parent: self.parent,\n+            predicates: self.predicates.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.predicates.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {"}, {"sha": "797371001d8d64c509c916082df6f217f2b25e6f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 115, "deletions": 119, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "patch": "@@ -35,7 +35,8 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::lint;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n+use rustc::ty::fold::TypeVisitor;\n use rustc::util::nodemap::NodeSet;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -62,40 +63,32 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n }\n \n struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n+    item_def_id: DefId,\n     ev: &'b mut EmbargoVisitor<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n-    fn ty_level(&self, ty: &hir::Ty) -> Option<AccessLevel> {\n-        if let hir::TyPath(ref qpath) = ty.node {\n-            let def = match *qpath {\n-                hir::QPath::Resolved(_, ref path) => path.def,\n-                hir::QPath::TypeRelative(..) => self.tcx.tables().type_relative_path_defs[&ty.id]\n-            };\n-            match def {\n-                Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n-                    Some(AccessLevel::Public)\n-                }\n-                def => {\n-                    if let Some(node_id) = self.tcx.map.as_local_node_id(def.def_id()) {\n-                        self.get(node_id)\n-                    } else {\n-                        Some(AccessLevel::Public)\n-                    }\n-                }\n-            }\n+    fn item_ty_level(&self, item_def_id: DefId) -> Option<AccessLevel> {\n+        let ty_def_id = match self.tcx.item_type(item_def_id).sty {\n+            ty::TyAdt(adt, _) => adt.did,\n+            ty::TyTrait(ref obj) => obj.principal.def_id(),\n+            ty::TyProjection(ref proj) => proj.trait_ref.def_id,\n+            _ => return Some(AccessLevel::Public)\n+        };\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(ty_def_id) {\n+            self.get(node_id)\n         } else {\n             Some(AccessLevel::Public)\n         }\n     }\n \n-    fn trait_level(&self, trait_ref: &hir::TraitRef) -> Option<AccessLevel> {\n-        let did = trait_ref.path.def.def_id();\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n-            self.get(node_id)\n-        } else {\n-            Some(AccessLevel::Public)\n+    fn impl_trait_level(&self, impl_def_id: DefId) -> Option<AccessLevel> {\n+        if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_def_id) {\n+            if let Some(node_id) = self.tcx.map.as_local_node_id(trait_ref.def_id) {\n+                return self.get(node_id);\n+            }\n         }\n+        Some(AccessLevel::Public)\n     }\n \n     fn get(&self, id: ast::NodeId) -> Option<AccessLevel> {\n@@ -115,8 +108,12 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn reach<'b>(&'b mut self) -> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n-        ReachEverythingInTheInterfaceVisitor { ev: self }\n+    fn reach<'b>(&'b mut self, item_id: ast::NodeId)\n+                 -> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+        ReachEverythingInTheInterfaceVisitor {\n+            item_def_id: self.tcx.map.local_def_id(item_id),\n+            ev: self,\n+        }\n     }\n }\n \n@@ -130,14 +127,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             // Impls inherit level from their types and traits\n-            hir::ItemImpl(.., None, ref ty, _) => {\n-                self.ty_level(&ty)\n-            }\n-            hir::ItemImpl(.., Some(ref trait_ref), ref ty, _) => {\n-                cmp::min(self.ty_level(&ty), self.trait_level(trait_ref))\n+            hir::ItemImpl(..) => {\n+                let def_id = self.tcx.map.local_def_id(item.id);\n+                cmp::min(self.item_ty_level(def_id), self.impl_trait_level(def_id))\n             }\n-            hir::ItemDefaultImpl(_, ref trait_ref) => {\n-                self.trait_level(trait_ref)\n+            hir::ItemDefaultImpl(..) => {\n+                let def_id = self.tcx.map.local_def_id(item.id);\n+                self.impl_trait_level(def_id)\n             }\n             // Foreign mods inherit level from parents\n             hir::ItemForeignMod(..) => {\n@@ -209,22 +205,54 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemMod(..) => {}\n             // Reexports are handled in visit_mod\n             hir::ItemUse(..) => {}\n+            // The interface is empty\n+            hir::ItemDefaultImpl(..) => {}\n             // Visit everything\n-            hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n-            hir::ItemTrait(..) | hir::ItemTy(..) | hir::ItemImpl(.., Some(..), _, _) => {\n+            hir::ItemConst(..) | hir::ItemStatic(..) |\n+            hir::ItemFn(..) | hir::ItemTy(..) => {\n                 if item_level.is_some() {\n-                    self.reach().visit_item(item);\n+                    self.reach(item.id).generics().predicates().item_type();\n                 }\n             }\n+            hir::ItemTrait(.., ref trait_items) => {\n+                if item_level.is_some() {\n+                    self.reach(item.id).generics().predicates();\n+\n+                    for trait_item in trait_items {\n+                        let mut reach = self.reach(trait_item.id);\n+                        reach.generics().predicates();\n+\n+                        if let hir::TypeTraitItem(_, None) = trait_item.node {\n+                            // No type to visit.\n+                        } else {\n+                            reach.item_type();\n+                        }\n+                    }\n+                }\n+            }\n+            // Visit everything except for private impl items\n+            hir::ItemImpl(.., ref trait_ref, _, ref impl_items) => {\n+                if item_level.is_some() {\n+                    self.reach(item.id).generics().predicates().impl_trait_ref();\n+\n+                    for impl_item in impl_items {\n+                        let id = impl_item.id.node_id;\n+                        if trait_ref.is_some() || self.get(id).is_some() {\n+                            self.reach(id).generics().predicates().item_type();\n+                        }\n+                    }\n+                }\n+            }\n+\n             // Visit everything, but enum variants have their own levels\n-            hir::ItemEnum(ref def, ref generics) => {\n+            hir::ItemEnum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach().visit_generics(generics);\n+                    self.reach(item.id).generics().predicates();\n                 }\n                 for variant in &def.variants {\n                     if self.get(variant.node.data.id()).is_some() {\n                         for field in variant.node.data.fields() {\n-                            self.reach().visit_struct_field(field);\n+                            self.reach(field.id).item_type();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n@@ -236,32 +264,18 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if self.get(foreign_item.id).is_some() {\n-                        self.reach().visit_foreign_item(foreign_item);\n+                        self.reach(foreign_item.id).generics().predicates().item_type();\n                     }\n                 }\n             }\n             // Visit everything except for private fields\n-            hir::ItemStruct(ref struct_def, ref generics) |\n-            hir::ItemUnion(ref struct_def, ref generics) => {\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach().visit_generics(generics);\n+                    self.reach(item.id).generics().predicates();\n                     for field in struct_def.fields() {\n                         if self.get(field.id).is_some() {\n-                            self.reach().visit_struct_field(field);\n-                        }\n-                    }\n-                }\n-            }\n-            // The interface is empty\n-            hir::ItemDefaultImpl(..) => {}\n-            // Visit everything except for private impl items\n-            hir::ItemImpl(.., ref generics, None, _, ref impl_item_refs) => {\n-                if item_level.is_some() {\n-                    self.reach().visit_generics(generics);\n-                    for impl_item_ref in impl_item_refs {\n-                        if self.get(impl_item_ref.id.node_id).is_some() {\n-                            let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n-                            self.reach().visit_impl_item(impl_item);\n+                            self.reach(field.id).item_type();\n                         }\n                     }\n                 }\n@@ -306,87 +320,69 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n         self.update(md.id, Some(AccessLevel::Public));\n     }\n-}\n \n-impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n-    // Make the type hidden under a type alias reachable\n-    fn reach_aliased_type(&mut self, item: &'tcx hir::Item, segment: &'tcx hir::PathSegment) {\n-        if let hir::ItemTy(ref ty, ref generics) = item.node {\n-            // See `fn is_public_type_alias` for details\n-            self.visit_ty(ty);\n-            let provided_params = segment.parameters.types().len();\n-            for ty_param in &generics.ty_params[provided_params..] {\n-                if let Some(ref default_ty) = ty_param.default {\n-                    self.visit_ty(default_ty);\n-                }\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        if let hir::TyImplTrait(..) = ty.node {\n+            if self.get(ty.id).is_some() {\n+                // Reach the (potentially private) type and the API being exposed.\n+                self.reach(ty.id).item_type().predicates();\n             }\n         }\n+\n+        intravisit::walk_ty(self, ty);\n     }\n }\n \n-impl<'b, 'a, 'tcx: 'a> Visitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n-    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n-        // when we visit an impl, its methods and items are part of its \"interface\"\n-        let impl_item = self.ev.tcx.map.impl_item(item_id);\n-        self.visit_impl_item(impl_item)\n+impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    fn generics(&mut self) -> &mut Self {\n+        self.ev.tcx.item_generics(self.item_def_id).visit_with(self);\n+        self\n     }\n \n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        let def_and_segment = match ty.node {\n-            hir::TyPath(hir::QPath::Resolved(_, ref path)) => {\n-                Some((path.def, path.segments.last().unwrap()))\n-            }\n-            hir::TyPath(hir::QPath::TypeRelative(_, ref segment)) => {\n-                Some((self.ev.tcx.tables().type_relative_path_defs[&ty.id], &**segment))\n-            }\n+    fn predicates(&mut self) -> &mut Self {\n+        self.ev.tcx.item_predicates(self.item_def_id).visit_with(self);\n+        self\n+    }\n+\n+    fn item_type(&mut self) -> &mut Self {\n+        self.ev.tcx.item_type(self.item_def_id).visit_with(self);\n+        self\n+    }\n+\n+    fn impl_trait_ref(&mut self) -> &mut Self {\n+        self.ev.tcx.impl_trait_ref(self.item_def_id).visit_with(self);\n+        self\n+    }\n+}\n+\n+impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        let ty_def_id = match ty.sty {\n+            ty::TyAdt(adt, _) => Some(adt.did),\n+            ty::TyTrait(ref obj) => Some(obj.principal.def_id()),\n+            ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n+            ty::TyFnDef(def_id, ..) |\n+            ty::TyAnon(def_id, _) => Some(def_id),\n             _ => None\n         };\n-        if let Some((def, segment)) = def_and_segment {\n-            match def {\n-                Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n-                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id) => {\n-                    if let Some(mut node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n-                        // Check the trait for associated types.\n-                        if let hir::map::NodeTraitItem(_) = self.ev.tcx.map.get(node_id) {\n-                            node_id = self.ev.tcx.map.get_parent(node_id);\n-                        }\n-\n-                        let item = self.ev.tcx.map.expect_item(node_id);\n-                        if let Def::TyAlias(..) = def {\n-                            // Type aliases are substituted. Associated type aliases are not\n-                            // substituted yet, but ideally they should be.\n-                            if self.ev.get(item.id).is_none() {\n-                                self.reach_aliased_type(item, segment);\n-                            }\n-                        } else {\n-                            self.ev.update(item.id, Some(AccessLevel::Reachable));\n-                        }\n-                    }\n-                }\n \n-                _ => {}\n+        if let Some(def_id) = ty_def_id {\n+            if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+                self.ev.update(node_id, Some(AccessLevel::Reachable));\n             }\n         }\n \n-        intravisit::walk_ty(self, ty);\n+        ty.super_visit_with(self)\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n-        let def_id = trait_ref.path.def.def_id();\n-        if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n+        if let Some(node_id) = self.ev.tcx.map.as_local_node_id(trait_ref.def_id) {\n             let item = self.ev.tcx.map.expect_item(node_id);\n             self.ev.update(item.id, Some(AccessLevel::Reachable));\n         }\n \n-        intravisit::walk_trait_ref(self, trait_ref);\n+        trait_ref.super_visit_with(self)\n     }\n-\n-    // Don't recurse into function bodies\n-    fn visit_block(&mut self, _: &hir::Block) {}\n-    // Don't recurse into expressions in array sizes or const initializers\n-    fn visit_expr(&mut self, _: &hir::Expr) {}\n-    // Don't recurse into patterns in function arguments\n-    fn visit_pat(&mut self, _: &hir::Pat) {}\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "0dcc0bcc316ce96cab2a98079156907d07ffa046", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "patch": "@@ -136,7 +136,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         if let hir::ExprClosure(..) = expr.node {\n-            convert_closure(self.ccx, expr.id);\n+            let def_id = self.ccx.tcx.map.local_def_id(expr.id);\n+            generics_of_def_id(self.ccx, def_id);\n+            type_of_def_id(self.ccx, def_id);\n         }\n         intravisit::walk_expr(self, expr);\n     }\n@@ -570,40 +572,6 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ccx.tcx.predicates.borrow_mut().insert(def_id, struct_predicates.clone());\n }\n \n-fn convert_closure<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                             node_id: ast::NodeId)\n-{\n-    let tcx = ccx.tcx;\n-    let def_id = tcx.map.local_def_id(node_id);\n-    let base_def_id = tcx.closure_base_def_id(def_id);\n-    let base_generics = generics_of_def_id(ccx, base_def_id);\n-\n-    // provide junk type parameter defs - the only place that\n-    // cares about anything but the length is instantiation,\n-    // and we don't do that for closures.\n-    let upvar_decls : Vec<_> = tcx.with_freevars(node_id, |fv| {\n-        fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n-            index: (base_generics.count() as u32) + (i as u32),\n-            name: Symbol::intern(\"<upvar>\"),\n-            def_id: def_id,\n-            default_def_id: base_def_id,\n-            default: None,\n-            object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n-            pure_wrt_drop: false,\n-        }).collect()\n-    });\n-    tcx.generics.borrow_mut().insert(def_id, tcx.alloc_generics(ty::Generics {\n-        parent: Some(base_def_id),\n-        parent_regions: base_generics.parent_regions + (base_generics.regions.len() as u32),\n-        parent_types: base_generics.parent_types + (base_generics.types.len() as u32),\n-        regions: vec![],\n-        types: upvar_decls,\n-        has_self: base_generics.has_self,\n-    }));\n-\n-    type_of_def_id(ccx, def_id);\n-}\n-\n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: AssociatedItemContainer,\n                             id: ast::NodeId,\n@@ -1320,6 +1288,9 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let parent_id = tcx.map.get_parent(node_id);\n                 Some(tcx.map.local_def_id(parent_id))\n             }\n+            NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+                Some(tcx.closure_base_def_id(def_id))\n+            }\n             NodeTy(&hir::Ty { node: hir::TyImplTrait(..), .. }) => {\n                 let mut parent_id = node_id;\n                 loop {\n@@ -1437,7 +1408,24 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let i = type_start + i as u32;\n             get_or_create_type_parameter_def(ccx, ast_generics, i, p, allow_defaults)\n         });\n-        let types: Vec<_> = opt_self.into_iter().chain(types).collect();\n+        let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n+\n+        // provide junk type parameter defs - the only place that\n+        // cares about anything but the length is instantiation,\n+        // and we don't do that for closures.\n+        if let NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) = node {\n+            tcx.with_freevars(node_id, |fv| {\n+                types.extend(fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n+                    index: type_start + i as u32,\n+                    name: Symbol::intern(\"<upvar>\"),\n+                    def_id: def_id,\n+                    default_def_id: parent_def_id.unwrap(),\n+                    default: None,\n+                    object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n+                    pure_wrt_drop: false,\n+               }));\n+            });\n+        }\n \n         // Debugging aid.\n         if tcx.has_attr(def_id, \"rustc_object_lifetime_default\") {"}, {"sha": "be353f6d563a196c7f2e6cb25e18b12bdecb2282", "filename": "src/test/run-pass/impl-trait/auxiliary/xcrate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs?ref=36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+pub fn fourway_add(a: i32) -> impl Fn(i32) -> impl Fn(i32) -> impl Fn(i32) -> i32 {\n+    move |b| move |c| move |d| a + b + c + d\n+}"}, {"sha": "fe3ed7b3465f47dee3ab9be7f82940a624192156", "filename": "src/test/run-pass/impl-trait/xcrate.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d33d6b71cb99ad9d9403295daec8d8a8f5c976/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs?ref=36d33d6b71cb99ad9d9403295daec8d8a8f5c976", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate.rs\n+\n+extern crate xcrate;\n+\n+fn main() {\n+    assert_eq!(xcrate::fourway_add(1)(2)(3)(4), 10);\n+}"}]}