{"sha": "50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZmIyYTRmMWZjZjc2NzFmNGJkYzhkNDM4YTExNjg4NjM2ZTVlY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T12:51:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T12:51:40Z"}, "message": "auto merge of #12610 : eddyb/rust/deref-now-auto, r=nikomatsakis\n\nEnables the dereference overloads introduced by #12491 to be applied wherever automatic dereferences would be used (field accesses, method calls and indexing).", "tree": {"sha": "4bc0e67ee0f558838c394135a5e25e2feac4bc42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bc0e67ee0f558838c394135a5e25e2feac4bc42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "html_url": "https://github.com/rust-lang/rust/commit/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c8bce1c768a59e2ad4a05042ff88e910fa3ae89", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c8bce1c768a59e2ad4a05042ff88e910fa3ae89", "html_url": "https://github.com/rust-lang/rust/commit/2c8bce1c768a59e2ad4a05042ff88e910fa3ae89"}, {"sha": "01a15d5870169636cec50a1f9d98bc967472a680", "url": "https://api.github.com/repos/rust-lang/rust/commits/01a15d5870169636cec50a1f9d98bc967472a680", "html_url": "https://github.com/rust-lang/rust/commit/01a15d5870169636cec50a1f9d98bc967472a680"}], "stats": {"total": 2732, "additions": 1632, "deletions": 1100}, "files": [{"sha": "15fd21e9fbc079806ae067d495b6c0836185082e", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -1687,7 +1687,7 @@ let x = Rc::new([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n let y = x.clone(); // a new owner\n let z = x; // this moves `x` into `z`, rather than creating a new owner\n \n-assert!(*z.borrow() == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+assert!(*z == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n \n // the variable is mutable, but not the contents of the box\n let mut a = Rc::new([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);"}, {"sha": "2ccb8e9c4c25034ba764dd0af0228557063ded20", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -51,11 +51,11 @@ struct Chunk {\n }\n impl Chunk {\n     fn capacity(&self) -> uint {\n-        self.data.borrow().borrow().get().capacity()\n+        self.data.deref().borrow().get().capacity()\n     }\n \n     unsafe fn as_ptr(&self) -> *u8 {\n-        self.data.borrow().borrow().get().as_ptr()\n+        self.data.deref().borrow().get().as_ptr()\n     }\n }\n "}, {"sha": "b226e773dbb880f6a9f87f44b0a948aa967a5116", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -101,7 +101,7 @@ impl<T: Clone + Float> Cmplx<T> {\n     /// Convert a polar representation into a complex number.\n     #[inline]\n     pub fn from_polar(r: &T, theta: &T) -> Cmplx<T> {\n-        Cmplx::new(r * theta.cos(), r * theta.sin())\n+        Cmplx::new(*r * theta.cos(), *r * theta.sin())\n     }\n }\n "}, {"sha": "10b209c998bc1eac94d92bbebc70429356a17282", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -1020,7 +1020,8 @@ pub fn build_session_(sopts: @session::Options,\n         lints: RefCell::new(HashMap::new()),\n         node_id: Cell::new(1),\n         crate_types: @RefCell::new(Vec::new()),\n-        features: front::feature_gate::Features::new()\n+        features: front::feature_gate::Features::new(),\n+        recursion_limit: Cell::new(64),\n     }\n }\n "}, {"sha": "b4e1516074e6f58f2e18dfdc2e860455132a87f7", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -194,7 +194,11 @@ pub struct Session_ {\n                            Vec<(lint::Lint, codemap::Span, ~str)> >>,\n     node_id: Cell<ast::NodeId>,\n     crate_types: @RefCell<Vec<CrateType> >,\n-    features: front::feature_gate::Features\n+    features: front::feature_gate::Features,\n+\n+    /// The maximum recursion limit for potentially infinitely recursive\n+    /// operations such as auto-dereference and monomorphization.\n+    recursion_limit: Cell<uint>,\n }\n \n pub type Session = @Session_;"}, {"sha": "fed35922a90c0ffbc02d73df78da0d16b094d981", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -21,7 +21,7 @@ use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter,\n                          RegionParameter};\n use metadata::tyencode;\n-use middle::typeck::{MethodCallee, MethodOrigin};\n+use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n@@ -1039,7 +1039,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    for &method in maps.method_map.borrow().get().find(&id).iter() {\n+    let method_call = MethodCall::expr(id);\n+    for &method in maps.method_map.borrow().get().find(&method_call).iter() {\n         ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n@@ -1081,7 +1082,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_from_vec(cap_vars.borrow().as_slice(),\n+                    ebml_w.emit_from_vec(cap_vars.deref().as_slice(),\n                                          |ebml_w, cap_var| {\n                         cap_var.encode(ebml_w);\n                     })\n@@ -1385,7 +1386,8 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_method_map => {\n                         let method = val_dsr.read_method_callee(xcx);\n-                        dcx.maps.method_map.borrow_mut().get().insert(id, method);\n+                        let method_call = MethodCall::expr(id);\n+                        dcx.maps.method_map.borrow_mut().get().insert(method_call, method);\n                     }\n                     c::tag_table_vtable_map => {\n                         let vtable_res ="}, {"sha": "e50d24560701ee25da81b481bba6873da5646432", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -22,6 +22,7 @@ use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::moves;\n use middle::ty;\n+use middle::typeck::MethodCall;\n use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n@@ -716,7 +717,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                                 span: Span) {\n         let capture_map = self.bccx.capture_map.borrow();\n         let cap_vars = capture_map.get().get(&closure_id);\n-        for cap_var in cap_vars.borrow().iter() {\n+        for cap_var in cap_vars.deref().iter() {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n             let var_path = @LpVar(var_id);\n             self.check_if_path_is_moved(closure_id, span,\n@@ -838,11 +839,11 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n         this.check_call(expr, None, expr.span, args.as_slice());\n       }\n       ast::ExprIndex(_, rval) | ast::ExprBinary(_, _, rval)\n-      if method_map.get().contains_key(&expr.id) => {\n+      if method_map.get().contains_key(&MethodCall::expr(expr.id)) => {\n         this.check_call(expr, None, expr.span, [rval]);\n       }\n       ast::ExprUnary(_, _) | ast::ExprIndex(_, _)\n-      if method_map.get().contains_key(&expr.id) => {\n+      if method_map.get().contains_key(&MethodCall::expr(expr.id)) => {\n         this.check_call(expr, None, expr.span, []);\n       }\n       ast::ExprInlineAsm(ref ia) => {"}, {"sha": "cfc4b3de38d8c9d1d04dc9650c6da0c5ee58016d", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -49,7 +49,7 @@ pub fn gather_captures(bccx: &BorrowckCtxt,\n                        closure_expr: &ast::Expr) {\n     let capture_map = bccx.capture_map.borrow();\n     let captured_vars = capture_map.get().get(&closure_expr.id);\n-    for captured_var in captured_vars.borrow().iter() {\n+    for captured_var in captured_vars.deref().iter() {\n         match captured_var.mode {\n             moves::CapMove => {\n                 let cmt = bccx.cat_captured_var(closure_expr.id,"}, {"sha": "f6168feb2b84696ca1b0a8c6faa456074aea45d2", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -23,6 +23,7 @@ use middle::moves;\n use middle::pat_util;\n use middle::ty::{ty_region};\n use middle::ty;\n+use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::{Repr};\n \n@@ -242,7 +243,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n \n       ast::ExprIndex(_, arg) |\n       ast::ExprBinary(_, _, arg)\n-      if method_map.get().contains_key(&ex.id) => {\n+      if method_map.get().contains_key(&MethodCall::expr(ex.id)) => {\n           // Arguments in method calls are always passed by ref.\n           //\n           // Currently these do not use adjustments, so we have to\n@@ -325,6 +326,39 @@ impl<'a> GatherLoanCtxt<'a> {\n         assert_eq!(id, popped);\n     }\n \n+    pub fn guarantee_autoderefs(&mut self,\n+                                expr: &ast::Expr,\n+                                autoderefs: uint) {\n+        let method_map = self.bccx.method_map.borrow();\n+        for i in range(0, autoderefs) {\n+            match method_map.get().find(&MethodCall::autoderef(expr.id, i as u32)) {\n+                Some(method) => {\n+                    // Treat overloaded autoderefs as if an AutoRef adjustment\n+                    // was applied on the base type, as that is always the case.\n+                    let mut mc = self.bccx.mc();\n+                    let cmt = match mc.cat_expr_autoderefd(expr, i) {\n+                        Ok(v) => v,\n+                        Err(()) => self.tcx().sess.span_bug(expr.span, \"Err from mc\")\n+                    };\n+                    let self_ty = *ty::ty_fn_args(method.ty).get(0);\n+                    let (m, r) = match ty::get(self_ty).sty {\n+                        ty::ty_rptr(r, ref m) => (m.mutbl, r),\n+                        _ => self.tcx().sess.span_bug(expr.span,\n+                                format!(\"bad overloaded deref type {}\",\n+                                    method.ty.repr(self.tcx())))\n+                    };\n+                    self.guarantee_valid(expr.id,\n+                                         expr.span,\n+                                         cmt,\n+                                         m,\n+                                         r,\n+                                         AutoRef);\n+                }\n+                None => {}\n+            }\n+        }\n+    }\n+\n     pub fn guarantee_adjustments(&mut self,\n                                  expr: &ast::Expr,\n                                  adjustment: &ty::AutoAdjustment) {\n@@ -340,15 +374,17 @@ impl<'a> GatherLoanCtxt<'a> {\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n-                    autoref: None, .. }) => {\n+                    autoref: None, autoderefs }) => {\n                 debug!(\"no autoref\");\n+                self.guarantee_autoderefs(expr, autoderefs);\n                 return;\n             }\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoref: Some(ref autoref),\n-                    autoderefs: autoderefs}) => {\n+                    autoderefs}) => {\n+                self.guarantee_autoderefs(expr, autoderefs);\n                 let mut mc = self.bccx.mc();\n                 let cmt = match mc.cat_expr_autoderefd(expr, autoderefs) {\n                     Ok(v) => v,\n@@ -406,7 +442,7 @@ impl<'a> GatherLoanCtxt<'a> {\n                           closure_expr: &ast::Expr) {\n         let capture_map = self.bccx.capture_map.borrow();\n         let captured_vars = capture_map.get().get(&closure_expr.id);\n-        for captured_var in captured_vars.borrow().iter() {\n+        for captured_var in captured_vars.deref().iter() {\n             match captured_var.mode {\n                 moves::CapCopy | moves::CapMove => { continue; }\n                 moves::CapRef => { }"}, {"sha": "44a5acc7f1b54dabdc0194f5bf0b33ab9858ed1d", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -556,7 +556,8 @@ impl BorrowckCtxt {\n             move_data::MoveExpr => {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n+                        (ty::expr_ty_adjusted(self.tcx, expr,\n+                                              self.method_map.borrow().get()), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to {:?}, not Expr\",\n                                                    move.id, r))\n@@ -582,7 +583,8 @@ impl BorrowckCtxt {\n             move_data::Captured => {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n+                        (ty::expr_ty_adjusted(self.tcx, expr,\n+                                              self.method_map.borrow().get()), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"Captured({:?}) maps to {:?}, not Expr\",\n                                                    move.id, r))\n@@ -922,8 +924,8 @@ impl mc::Typer for TcxTyper {\n         Ok(ty::node_id_to_type(self.tcx, id))\n     }\n \n-    fn node_method_ty(&mut self, id: ast::NodeId) -> Option<ty::t> {\n-        self.method_map.borrow().get().find(&id).map(|method| method.ty)\n+    fn node_method_ty(&mut self, method_call: typeck::MethodCall) -> Option<ty::t> {\n+        self.method_map.borrow().get().find(&method_call).map(|method| method.ty)\n     }\n \n     fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n@@ -932,7 +934,7 @@ impl mc::Typer for TcxTyper {\n     }\n \n     fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n-        self.method_map.borrow().get().contains_key(&id)\n+        self.method_map.borrow().get().contains_key(&typeck::MethodCall::expr(id))\n     }\n \n     fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {"}, {"sha": "0100a82a9d5aa56aad2ce3dbf0b55e239acd8619", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -523,7 +523,7 @@ impl CFGBuilder {\n     }\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {\n-        let method_map = self.method_map.borrow();\n-        method_map.get().contains_key(&expr.id)\n+        let method_call = typeck::MethodCall::expr(expr.id);\n+        self.method_map.borrow().get().contains_key(&method_call)\n     }\n }"}, {"sha": "6841e09f7f2db661e2296cda0677c918f418695a", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -117,8 +117,8 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n           }\n           ExprLit(lit) if ast_util::lit_is_str(lit) => {}\n           ExprBinary(..) | ExprUnary(..) => {\n-            let method_map = method_map.borrow();\n-            if method_map.get().contains_key(&e.id) {\n+              let method_call = typeck::MethodCall::expr(e.id);\n+            if method_map.borrow().get().contains_key(&method_call) {\n                 sess.span_err(e.span, \"user-defined operators are not \\\n                                        allowed in constant expressions\");\n             }"}, {"sha": "1f675b7bb4a688e0400b6809970e8ef7d848649c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -16,7 +16,7 @@ use middle::astencode;\n use middle::ty;\n use middle::typeck::astconv;\n use middle;\n-use util::nodemap::{DefIdMap, NodeMap};\n+use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use syntax::ast::*;\n use syntax::parse::token::InternedString;\n@@ -136,7 +136,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n         }\n         let maps = astencode::Maps {\n             root_map: @RefCell::new(HashMap::new()),\n-            method_map: @RefCell::new(NodeMap::new()),\n+            method_map: @RefCell::new(FnvHashMap::new()),\n             vtable_map: @RefCell::new(NodeMap::new()),\n             capture_map: @RefCell::new(NodeMap::new())\n         };\n@@ -186,7 +186,7 @@ pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n         }\n         let maps = astencode::Maps {\n             root_map: @RefCell::new(HashMap::new()),\n-            method_map: @RefCell::new(NodeMap::new()),\n+            method_map: @RefCell::new(FnvHashMap::new()),\n             vtable_map: @RefCell::new(NodeMap::new()),\n             capture_map: @RefCell::new(NodeMap::new())\n         };\n@@ -512,7 +512,7 @@ pub fn lit_to_const(lit: &Lit) -> const_val {\n     match lit.node {\n         LitStr(ref s, _) => const_str((*s).clone()),\n         LitBinary(ref data) => {\n-            const_binary(Rc::new(data.borrow().iter().map(|x| *x).collect()))\n+            const_binary(Rc::new(data.deref().iter().map(|x| *x).collect()))\n         }\n         LitChar(n) => const_uint(n as u64),\n         LitInt(n, _) => const_int(n),"}, {"sha": "57b5be4e96069b5742dde20c524c170cfbbf92fe", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -810,8 +810,8 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     }\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {\n-        let method_map = self.dfcx.method_map.borrow();\n-        method_map.get().contains_key(&expr.id)\n+        let method_call = typeck::MethodCall::expr(expr.id);\n+        self.dfcx.method_map.borrow().get().contains_key(&method_call)\n     }\n \n     fn reset(&mut self, bits: &mut [uint]) {"}, {"sha": "310feb88892d71e43ea6b5d02b583d2af8d8cb74", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -92,9 +92,10 @@ impl MarkSymbolVisitor {\n         }\n     }\n \n-    fn lookup_and_handle_method(&mut self, id: &ast::NodeId,\n+    fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n                                 span: codemap::Span) {\n-        match self.method_map.borrow().get().find(id) {\n+        let method_call = typeck::MethodCall::expr(id);\n+        match self.method_map.borrow().get().find(&method_call) {\n             Some(method) => {\n                 match method.origin {\n                     typeck::MethodStatic(def_id) => {\n@@ -179,7 +180,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n         match expr.node {\n             ast::ExprMethodCall(..) => {\n-                self.lookup_and_handle_method(&expr.id, expr.span);\n+                self.lookup_and_handle_method(expr.id, expr.span);\n             }\n             _ => ()\n         }"}, {"sha": "d3ec7044040ccabf513cdd09d0d034dff2c28b4d", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -12,7 +12,7 @@\n /// `unsafe`.\n \n use middle::ty;\n-use middle::typeck::MethodMap;\n+use middle::typeck::{MethodCall, MethodMap};\n use util::ppaux;\n \n use syntax::ast;\n@@ -138,7 +138,8 @@ impl Visitor<()> for EffectCheckVisitor {\n     fn visit_expr(&mut self, expr: &ast::Expr, _:()) {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n-                let base_type = self.method_map.borrow().get().get(&expr.id).ty;\n+                let method_call = MethodCall::expr(expr.id);\n+                let base_type = self.method_map.borrow().get().get(&method_call).ty;\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_str(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "7771cb0ab3c14d1b6775dcfde9cde2fca26c4fe3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -267,7 +267,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     // Handle any kind bounds on type parameters\n     {\n         let method_map = cx.method_map.borrow();\n-        let method = method_map.get().find(&e.id);\n+        let method = method_map.get().find(&typeck::MethodCall::expr(e.id));\n         let node_type_substs = cx.tcx.node_type_substs.borrow();\n         let r = match method {\n             Some(method) => Some(&method.substs.tps),\n@@ -298,7 +298,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n                 }\n               }\n             };\n-            let type_param_defs = type_param_defs.borrow();\n+            let type_param_defs = type_param_defs.deref();\n             if ts.len() != type_param_defs.len() {\n                 // Fail earlier to make debugging easier\n                 fail!(\"internal error: in kind::check_expr, length \\\n@@ -341,7 +341,8 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n             match **adjustment {\n                 ty::AutoObject(..) => {\n                     let source_ty = ty::expr_ty(cx.tcx, e);\n-                    let target_ty = ty::expr_ty_adjusted(cx.tcx, e);\n+                    let target_ty = ty::expr_ty_adjusted(cx.tcx, e,\n+                                                         cx.method_map.borrow().get());\n                     check_trait_cast(cx, source_ty, target_ty, e.span);\n                 }\n                 ty::AutoAddEnv(..) |"}, {"sha": "31d705dc6aa933e9330975d727a684165d870166", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -1491,7 +1491,8 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n             }\n         }\n         ast::ExprMethodCall(..) => {\n-            match cx.method_map.borrow().get().find(&e.id) {\n+            let method_call = typeck::MethodCall::expr(e.id);\n+            match cx.method_map.borrow().get().find(&method_call) {\n                 Some(method) => {\n                     match method.origin {\n                         typeck::MethodStatic(def_id) => {"}, {"sha": "48a6b5c92d4e8ed1ddeeec78e54e3f447216d8d4", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -505,7 +505,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n         let capture_map = this.capture_map.borrow();\n         let cvs = capture_map.get().get(&expr.id);\n         let mut call_caps = Vec::new();\n-        for cv in cvs.borrow().iter() {\n+        for cv in cvs.deref().iter() {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n                 let cv_ln = this.add_live_node(FreeVarNode(cv.span));"}, {"sha": "c07cd2570a30b3b08e4e65f234384aaddc21a06e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 47, "deletions": 50, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -63,6 +63,7 @@\n #[allow(non_camel_case_types)];\n \n use middle::ty;\n+use middle::typeck;\n use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n \n use std::vec_ng::Vec;\n@@ -268,7 +269,7 @@ pub type McResult<T> = Result<T, ()>;\n pub trait Typer {\n     fn tcx(&self) -> ty::ctxt;\n     fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t>;\n-    fn node_method_ty(&mut self, id: ast::NodeId) -> Option<ty::t>;\n+    fn node_method_ty(&mut self, method_call: typeck::MethodCall) -> Option<ty::t>;\n     fn adjustment(&mut self, node_id: ast::NodeId) -> Option<@ty::AutoAdjustment>;\n     fn is_method_call(&mut self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&mut self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n@@ -365,7 +366,8 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n     fn expr_ty_adjusted(&mut self, expr: &ast::Expr) -> McResult<ty::t> {\n         let unadjusted_ty = if_ok!(self.expr_ty(expr));\n         let adjustment = self.adjustment(expr.id);\n-        Ok(ty::adjust_ty(self.tcx(), expr.span, unadjusted_ty, adjustment))\n+        Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty, adjustment,\n+                         |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n     fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t> {\n@@ -435,21 +437,11 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         let expr_ty = if_ok!(self.expr_ty(expr));\n         match expr.node {\n           ast::ExprUnary(ast::UnDeref, e_base) => {\n-            let base_cmt = match self.typer.node_method_ty(expr.id) {\n-                Some(method_ty) => {\n-                    let ref_ty = ty::ty_fn_ret(method_ty);\n-                    self.cat_rvalue_node(expr.id(), expr.span(), ref_ty)\n-                }\n-                None => if_ok!(self.cat_expr(e_base))\n-            };\n+            let base_cmt = if_ok!(self.cat_expr(e_base));\n             Ok(self.cat_deref(expr, base_cmt, 0))\n           }\n \n           ast::ExprField(base, f_name, _) => {\n-            // Method calls are now a special syntactic form,\n-            // so `a.b` should always be a field.\n-            assert!(!self.typer.is_method_call(expr.id));\n-\n             let base_cmt = if_ok!(self.cat_expr(base));\n             Ok(self.cat_field(expr, base_cmt, f_name, expr_ty))\n           }\n@@ -725,59 +717,64 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         // `()` (the empty tuple).\n \n         let opaque_ty = ty::mk_tup(self.tcx(), Vec::new());\n-        return self.cat_deref_common(node, base_cmt, deref_cnt, opaque_ty);\n+        self.cat_deref_common(node, base_cmt, deref_cnt, opaque_ty)\n     }\n \n-    pub fn cat_deref<N:ast_node>(&mut self,\n-                                 node: &N,\n-                                 base_cmt: cmt,\n-                                 deref_cnt: uint)\n-                                 -> cmt {\n-        let mt = match ty::deref(base_cmt.ty, true) {\n-            Some(mt) => mt,\n+    fn cat_deref<N:ast_node>(&mut self,\n+                             node: &N,\n+                             base_cmt: cmt,\n+                             deref_cnt: uint)\n+                             -> cmt {\n+        let method_call = typeck::MethodCall {\n+            expr_id: node.id(),\n+            autoderef: deref_cnt as u32\n+        };\n+        let method_ty = self.typer.node_method_ty(method_call);\n+\n+        debug!(\"cat_deref: method_call={:?} method_ty={}\",\n+            method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n+\n+        let base_cmt = match method_ty {\n+            Some(method_ty) => {\n+                let ref_ty = ty::ty_fn_ret(method_ty);\n+                self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n+            }\n+            None => base_cmt\n+        };\n+        match ty::deref(base_cmt.ty, true) {\n+            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty),\n             None => {\n                 self.tcx().sess.span_bug(\n                     node.span(),\n                     format!(\"Explicit deref of non-derefable type: {}\",\n                             base_cmt.ty.repr(self.tcx())));\n             }\n-        };\n-\n-        return self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty);\n+        }\n     }\n \n-    pub fn cat_deref_common<N:ast_node>(&mut self,\n-                                        node: &N,\n-                                        base_cmt: cmt,\n-                                        deref_cnt: uint,\n-                                        deref_ty: ty::t)\n-                                        -> cmt {\n-        match deref_kind(self.tcx(), base_cmt.ty) {\n+    fn cat_deref_common<N:ast_node>(&mut self,\n+                                    node: &N,\n+                                    base_cmt: cmt,\n+                                    deref_cnt: uint,\n+                                    deref_ty: ty::t)\n+                                    -> cmt {\n+        let (m, cat) = match deref_kind(self.tcx(), base_cmt.ty) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n-                let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl,\n-                                                              ptr);\n-\n-                @cmt_ {\n-                    id:node.id(),\n-                    span:node.span(),\n-                    cat:cat_deref(base_cmt, deref_cnt, ptr),\n-                    mutbl:m,\n-                    ty:deref_ty\n-                }\n+                (MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n+                 cat_deref(base_cmt, deref_cnt, ptr))\n             }\n-\n             deref_interior(interior) => {\n-                let m = base_cmt.mutbl.inherit();\n-                @cmt_ {\n-                    id:node.id(),\n-                    span:node.span(),\n-                    cat:cat_interior(base_cmt, interior),\n-                    mutbl:m,\n-                    ty:deref_ty\n-                }\n+                (base_cmt.mutbl.inherit(), cat_interior(base_cmt, interior))\n             }\n+        };\n+        @cmt_ {\n+            id: node.id(),\n+            span: node.span(),\n+            cat: cat,\n+            mutbl: m,\n+            ty: deref_ty\n         }\n     }\n "}, {"sha": "b52ec7be631143b24e4d59a77bb1c027c1e81465", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -130,7 +130,7 @@ and so on.\n use middle::pat_util::{pat_bindings};\n use middle::freevars;\n use middle::ty;\n-use middle::typeck::MethodMap;\n+use middle::typeck::{MethodCall, MethodMap};\n use util::ppaux;\n use util::ppaux::Repr;\n use util::common::indenter;\n@@ -281,12 +281,10 @@ impl VisitContext {\n         debug!(\"consume_expr(expr={})\",\n                expr.repr(self.tcx));\n \n-        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr,\n+                                           self.method_map.borrow().get());\n         if ty::type_moves_by_default(self.tcx, expr_ty) {\n-            {\n-                let mut moves_map = self.move_maps.moves_map.borrow_mut();\n-                moves_map.get().insert(expr.id);\n-            }\n+            self.move_maps.moves_map.borrow_mut().get().insert(expr.id);\n             self.use_expr(expr, Move);\n         } else {\n             self.use_expr(expr, Read);\n@@ -608,8 +606,8 @@ impl VisitContext {\n                                    receiver_expr: @Expr,\n                                    arg_exprs: &[@Expr])\n                                    -> bool {\n-        let method_map = self.method_map.borrow();\n-        if !method_map.get().contains_key(&expr.id) {\n+        let method_call = MethodCall::expr(expr.id);\n+        if !self.method_map.borrow().get().contains_key(&method_call) {\n             return false;\n         }\n "}, {"sha": "b8a40f623d947088a56ebe9eb98b7d28e1299aba", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -19,7 +19,7 @@ use metadata::csearch;\n use middle::lint;\n use middle::resolve;\n use middle::ty;\n-use middle::typeck::{MethodMap, MethodOrigin, MethodParam};\n+use middle::typeck::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n use middle::typeck::{MethodStatic, MethodObject};\n use util::nodemap::{NodeMap, NodeSet};\n \n@@ -772,40 +772,26 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n         match expr.node {\n             ast::ExprField(base, ident, _) => {\n-                // Method calls are now a special syntactic form,\n-                // so `a.b` should always be a field.\n-                let method_map = self.method_map.borrow();\n-                assert!(!method_map.get().contains_key(&expr.id));\n-\n-                // With type_autoderef, make sure we don't\n-                // allow pointers to violate privacy\n-                let t = ty::type_autoderef(ty::expr_ty(self.tcx, base));\n-                match ty::get(t).sty {\n+                match ty::get(ty::expr_ty_adjusted(self.tcx, base,\n+                                                   self.method_map.borrow().get())).sty {\n                     ty::ty_struct(id, _) => {\n                         self.check_field(expr.span, id, ident, None);\n                     }\n                     _ => {}\n                 }\n             }\n-            ast::ExprMethodCall(ident, _, ref args) => {\n-                // see above\n-                let t = ty::type_autoderef(ty::expr_ty(self.tcx,\n-                                                       *args.get(0)));\n-                match ty::get(t).sty {\n-                    ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n-                        match self.method_map.borrow().get().find(&expr.id) {\n-                            None => {\n-                                self.tcx.sess.span_bug(expr.span,\n-                                                       \"method call not in \\\n-                                                        method map\");\n-                            }\n-                            Some(method) => {\n-                                debug!(\"(privacy checking) checking impl method\");\n-                                self.check_method(expr.span, method.origin, ident);\n-                            }\n-                        }\n+            ast::ExprMethodCall(ident, _, _) => {\n+                let method_call = MethodCall::expr(expr.id);\n+                match self.method_map.borrow().get().find(&method_call) {\n+                    None => {\n+                        self.tcx.sess.span_bug(expr.span,\n+                                                \"method call not in \\\n+                                                method map\");\n+                    }\n+                    Some(method) => {\n+                        debug!(\"(privacy checking) checking impl method\");\n+                        self.check_method(expr.span, method.origin, ident);\n                     }\n-                    _ => {}\n                 }\n             }\n             ast::ExprStruct(_, ref fields, _) => {"}, {"sha": "e9d01713e1c271942601b8cf8dc1b173cbd48db3", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -149,24 +149,17 @@ impl Visitor<()> for MarkSymbolVisitor {\n                 }\n             }\n             ast::ExprMethodCall(..) => {\n-                match self.method_map.borrow().get().get(&expr.id).origin {\n+                let method_call = typeck::MethodCall::expr(expr.id);\n+                match self.method_map.borrow().get().get(&method_call).origin {\n                     typeck::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if ReachableContext::\n                                 def_id_represents_local_inlined_item(\n                                     self.tcx,\n                                     def_id) {\n-                                {\n-                                    let mut worklist = self.worklist\n-                                                           .borrow_mut();\n-                                    worklist.get().push(def_id.node)\n-                                }\n-                            }\n-                            {\n-                                let mut reachable_symbols =\n-                                    self.reachable_symbols.borrow_mut();\n-                                reachable_symbols.get().insert(def_id.node);\n+                                self.worklist.borrow_mut().get().push(def_id.node)\n                             }\n+                            self.reachable_symbols.borrow_mut().get().insert(def_id.node);\n                         }\n                     }\n                     _ => {}"}, {"sha": "82458a69ee65aaabe277d6af152d45a2579ab7f3", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -142,7 +142,7 @@ impl<T:Subst> Subst for Rc<T> {\n     fn subst_spanned(&self, tcx: ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> Rc<T> {\n-        Rc::new(self.borrow().subst_spanned(tcx, substs, span))\n+        Rc::new(self.deref().subst_spanned(tcx, substs, span))\n     }\n }\n "}, {"sha": "1a398a7377100a7cc097e11ecd06c74414f63947", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -50,10 +50,11 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     let inputs = ia.inputs.map(|&(ref c, input)| {\n         constraints.push((*c).clone());\n \n+        let in_datum = unpack_datum!(bcx, expr::trans(bcx, input));\n         unpack_result!(bcx, {\n-            callee::trans_arg_expr(bcx,\n+            callee::trans_arg_datum(bcx,\n                                    expr_ty(bcx, input),\n-                                   input,\n+                                   in_datum,\n                                    cleanup::CustomScope(temp_scope),\n                                    callee::DontAutorefArg)\n         })"}, {"sha": "ff63b74444c614238e4c9d78dc6983b2aeaab7a8", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 84, "deletions": 68, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -44,6 +44,7 @@ use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n use middle::typeck::coherence::make_substs_for_receiver_types;\n+use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n@@ -120,7 +121,7 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         match def {\n             ast::DefFn(did, _) |\n             ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n-                fn_callee(bcx, trans_fn_ref(bcx, did, ref_expr.id, false))\n+                fn_callee(bcx, trans_fn_ref(bcx, did, ExprId(ref_expr.id)))\n             }\n             ast::DefStaticMethod(impl_did,\n                                    ast::FromTrait(trait_did),\n@@ -134,10 +135,10 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n                 assert!(ty::enum_variant_with_id(bcx.tcx(),\n                                                       tid,\n                                                       vid).args.len() > 0u);\n-                fn_callee(bcx, trans_fn_ref(bcx, vid, ref_expr.id, false))\n+                fn_callee(bcx, trans_fn_ref(bcx, vid, ExprId(ref_expr.id)))\n             }\n             ast::DefStruct(def_id) => {\n-                fn_callee(bcx, trans_fn_ref(bcx, def_id, ref_expr.id, false))\n+                fn_callee(bcx, trans_fn_ref(bcx, def_id, ExprId(ref_expr.id)))\n             }\n             ast::DefStatic(..) |\n             ast::DefArg(..) |\n@@ -160,9 +161,7 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n     }\n }\n \n-pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId,\n-                    ref_id: ast::NodeId, is_method: bool)\n-                    -> ValueRef {\n+pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) -> ValueRef {\n     /*!\n      *\n      * Translates a reference (with id `ref_id`) to the fn/method\n@@ -171,15 +170,21 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId,\n \n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n-    let type_params = node_id_type_params(bcx, ref_id, is_method);\n-    let vtables = node_vtables(bcx, ref_id);\n-    debug!(\"trans_fn_ref(def_id={}, ref_id={:?}, type_params={}, vtables={})\",\n-           def_id.repr(bcx.tcx()), ref_id, type_params.repr(bcx.tcx()),\n+    let type_params = node_id_type_params(bcx, node);\n+    let vtables = match node {\n+        ExprId(id) => node_vtables(bcx, id),\n+        MethodCall(ref method_call) => {\n+            if method_call.autoderef == 0 {\n+                node_vtables(bcx, method_call.expr_id)\n+            } else {\n+                None\n+            }\n+        }\n+    };\n+    debug!(\"trans_fn_ref(def_id={}, node={:?}, type_params={}, vtables={})\",\n+           def_id.repr(bcx.tcx()), node, type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n-    trans_fn_ref_with_vtables(bcx,\n-                              def_id,\n-                              ref_id,\n-                              is_method,\n+    trans_fn_ref_with_vtables(bcx, def_id, node,\n                               type_params.as_slice(),\n                               vtables)\n }\n@@ -191,7 +196,7 @@ fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n                                            vtables: Option<typeck::vtable_res>)\n                                            -> Callee<'a> {\n     Callee {bcx: bcx,\n-            data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ref_id, false,\n+            data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ExprId(ref_id),\n                                                type_params, vtables))}\n }\n \n@@ -241,8 +246,7 @@ fn resolve_default_method_vtables(bcx: &Block,\n pub fn trans_fn_ref_with_vtables(\n         bcx: &Block,       //\n         def_id: ast::DefId,   // def id of fn\n-        ref_id: ast::NodeId,  // node id of use of fn; may be zero if N/A\n-        is_method: bool,\n+        node: ExprOrMethodCall,  // node id of use of fn; may be zero if N/A\n         type_params: &[ty::t], // values for fn's ty params\n         vtables: Option<typeck::vtable_res>) // vtables for the call\n      -> ValueRef {\n@@ -254,7 +258,7 @@ pub fn trans_fn_ref_with_vtables(\n      *\n      * - `bcx`: the current block where the reference to the fn occurs\n      * - `def_id`: def id of the fn or method item being referenced\n-     * - `ref_id`: node id of the reference to the fn/method, if applicable.\n+     * - `node`: node id of the reference to the fn/method, if applicable.\n      *   This parameter may be zero; but, if so, the resulting value may not\n      *   have the right type, so it must be cast before being used.\n      * - `type_params`: values for each of the fn/method's type parameters\n@@ -265,11 +269,11 @@ pub fn trans_fn_ref_with_vtables(\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n-    debug!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, ref_id={:?}, \\\n+    debug!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, node={:?}, \\\n             type_params={}, vtables={})\",\n            bcx.to_str(),\n            def_id.repr(bcx.tcx()),\n-           ref_id,\n+           node,\n            type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n \n@@ -380,19 +384,25 @@ pub fn trans_fn_ref_with_vtables(\n         // Should be either intra-crate or inlined.\n         assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n+        let opt_ref_id = match node {\n+            ExprId(id) => if id != 0 { Some(id) } else { None },\n+            MethodCall(_) => None,\n+        };\n+\n         let (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, &substs,\n                                          vtables, self_vtables,\n-                                         Some(ref_id));\n+                                         opt_ref_id);\n         let mut val = val;\n-        if must_cast && ref_id != 0 {\n+        if must_cast && node != ExprId(0) {\n             // Monotype of the REFERENCE to the function (type params\n             // are subst'd)\n-            let ref_ty = if is_method {\n-                let t = bcx.ccx().maps.method_map.borrow().get().get(&ref_id).ty;\n-                monomorphize_type(bcx, t)\n-            } else {\n-                node_id_type(bcx, ref_id)\n+            let ref_ty = match node {\n+                ExprId(id) => node_id_type(bcx, id),\n+                MethodCall(method_call) => {\n+                    let t = bcx.ccx().maps.method_map.borrow().get().get(&method_call).ty;\n+                    monomorphize_type(bcx, t)\n+                }\n             };\n \n             val = PointerCast(\n@@ -472,13 +482,14 @@ pub fn trans_method_call<'a>(\n                          -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n-    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&call_ex.id).ty;\n+    let method_call = MethodCall::expr(call_ex.id);\n+    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&method_call).ty;\n     trans_call_inner(\n         bcx,\n         Some(common::expr_info(call_ex)),\n         monomorphize_type(bcx, method_ty),\n         |cx, arg_cleanup_scope| {\n-            meth::trans_method_callee(cx, call_ex.id, rcvr, arg_cleanup_scope)\n+            meth::trans_method_callee(cx, method_call, Some(rcvr), arg_cleanup_scope)\n         },\n         args,\n         Some(dest)).bcx\n@@ -717,19 +728,16 @@ pub fn trans_call_inner<'a>(\n         assert!(dest.is_some());\n \n         let mut llargs = Vec::new();\n-        bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n-                         cleanup::CustomScope(arg_cleanup_scope), false);\n-        fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n         let arg_tys = match args {\n             ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, *x)).collect(),\n             _ => fail!(\"expected arg exprs.\")\n         };\n-        bcx = foreign::trans_native_call(bcx,\n-                                         callee_ty,\n-                                         llfn,\n-                                         opt_llretslot.unwrap(),\n-                                         llargs.as_slice(),\n-                                         arg_tys);\n+        bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n+                         cleanup::CustomScope(arg_cleanup_scope), false);\n+        fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n+        bcx = foreign::trans_native_call(bcx, callee_ty,\n+                                         llfn, opt_llretslot.unwrap(),\n+                                         llargs.as_slice(), arg_tys);\n     }\n \n     // If the caller doesn't care about the result of this fn call,\n@@ -753,10 +761,19 @@ pub fn trans_call_inner<'a>(\n }\n \n pub enum CallArgs<'a> {\n+    // Supply value of arguments as a list of expressions that must be\n+    // translated. This is used in the common case of `foo(bar, qux)`.\n     ArgExprs(&'a [@ast::Expr]),\n-    // HACK used only by trans_overloaded_op.\n-    ArgAutorefSecond(&'a ast::Expr, Option<&'a ast::Expr>),\n-    ArgVals(&'a [ValueRef])\n+\n+    // Supply value of arguments as a list of LLVM value refs; frequently\n+    // used with lang items and so forth, when the argument is an internal\n+    // value.\n+    ArgVals(&'a [ValueRef]),\n+\n+    // For overloaded operators: `(lhs, Option(rhs, rhs_id))`. `lhs`\n+    // is the left-hand-side and `rhs/rhs_id` is the datum/expr-id of\n+    // the right-hand-side (if any).\n+    ArgOverloadedOp(Datum<Expr>, Option<(Datum<Expr>, ast::NodeId)>),\n }\n \n fn trans_args<'a>(cx: &'a Block<'a>,\n@@ -778,40 +795,42 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n     match args {\n         ArgExprs(arg_exprs) => {\n             let num_formal_args = arg_tys.len();\n-            for (i, arg_expr) in arg_exprs.iter().enumerate() {\n+            for (i, &arg_expr) in arg_exprs.iter().enumerate() {\n                 if i == 0 && ignore_self {\n                     continue;\n                 }\n                 let arg_ty = if i >= num_formal_args {\n                     assert!(variadic);\n-                    expr_ty_adjusted(cx, *arg_expr)\n+                    expr_ty_adjusted(cx, arg_expr)\n                 } else {\n                     *arg_tys.get(i)\n                 };\n+\n+                let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_expr));\n                 llargs.push(unpack_result!(bcx, {\n-                    trans_arg_expr(bcx, arg_ty, *arg_expr,\n-                                   arg_cleanup_scope,\n-                                   DontAutorefArg)\n+                    trans_arg_datum(bcx, arg_ty, arg_datum,\n+                                    arg_cleanup_scope,\n+                                    DontAutorefArg)\n                 }));\n             }\n         }\n-        ArgAutorefSecond(arg_expr, arg2) => {\n+        ArgOverloadedOp(lhs, rhs) => {\n             assert!(!variadic);\n \n             llargs.push(unpack_result!(bcx, {\n-                trans_arg_expr(bcx, *arg_tys.get(0), arg_expr,\n-                               arg_cleanup_scope,\n-                               DontAutorefArg)\n+                trans_arg_datum(bcx, *arg_tys.get(0), lhs,\n+                                arg_cleanup_scope,\n+                                DontAutorefArg)\n             }));\n \n-            match arg2 {\n-                Some(arg2_expr) => {\n+            match rhs {\n+                Some((rhs, rhs_id)) => {\n                     assert_eq!(arg_tys.len(), 2);\n \n                     llargs.push(unpack_result!(bcx, {\n-                        trans_arg_expr(bcx, *arg_tys.get(1), arg2_expr,\n-                                       arg_cleanup_scope,\n-                                       DoAutorefArg)\n+                        trans_arg_datum(bcx, *arg_tys.get(1), rhs,\n+                                        arg_cleanup_scope,\n+                                        DoAutorefArg(rhs_id))\n                     }));\n                 }\n                 None => assert_eq!(arg_tys.len(), 1)\n@@ -827,26 +846,23 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n \n pub enum AutorefArg {\n     DontAutorefArg,\n-    DoAutorefArg\n+    DoAutorefArg(ast::NodeId)\n }\n \n-pub fn trans_arg_expr<'a>(\n+pub fn trans_arg_datum<'a>(\n                       bcx: &'a Block<'a>,\n                       formal_arg_ty: ty::t,\n-                      arg_expr: &ast::Expr,\n+                      arg_datum: Datum<Expr>,\n                       arg_cleanup_scope: cleanup::ScopeId,\n                       autoref_arg: AutorefArg)\n                       -> Result<'a> {\n-    let _icx = push_ctxt(\"trans_arg_expr\");\n+    let _icx = push_ctxt(\"trans_arg_datum\");\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_expr(formal_arg_ty=({}), arg_expr={})\",\n-           formal_arg_ty.repr(bcx.tcx()),\n-           arg_expr.repr(bcx.tcx()));\n+    debug!(\"trans_arg_datum({})\",\n+           formal_arg_ty.repr(bcx.tcx()));\n \n-    // translate the arg expr to a datum\n-    let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_expr));\n     let arg_datum_ty = arg_datum.ty;\n \n     debug!(\"   arg datum: {}\", arg_datum.to_str(bcx.ccx()));\n@@ -864,11 +880,11 @@ pub fn trans_arg_expr<'a>(\n     } else {\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n-            DoAutorefArg => {\n+            DoAutorefArg(arg_id) => {\n                 // We will pass argument by reference\n                 // We want an lvalue, so that we can pass by reference and\n                 let arg_datum = unpack_datum!(\n-                    bcx, arg_datum.to_lvalue_datum(bcx, \"arg\", arg_expr.id));\n+                    bcx, arg_datum.to_lvalue_datum(bcx, \"arg\", arg_id));\n                 val = arg_datum.val;\n             }\n             DontAutorefArg => {\n@@ -898,6 +914,6 @@ pub fn trans_arg_expr<'a>(\n         }\n     }\n \n-    debug!(\"--- trans_arg_expr passing {}\", bcx.val_to_str(val));\n-    return rslt(bcx, val);\n+    debug!(\"--- trans_arg_datum passing {}\", bcx.val_to_str(val));\n+    rslt(bcx, val)\n }"}, {"sha": "d249bd8a894cc8be40d43a9049a3c2f4d3770d43", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -19,7 +19,7 @@ use middle::trans::base;\n use middle::trans::build;\n use middle::trans::callee;\n use middle::trans::common;\n-use middle::trans::common::{Block, FunctionContext};\n+use middle::trans::common::{Block, FunctionContext, ExprId};\n use middle::trans::glue;\n use middle::trans::type_::Type;\n use middle::ty;\n@@ -673,7 +673,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n \n         // The exception handling personality function.\n         let def_id = common::langcall(pad_bcx, None, \"\", EhPersonalityLangItem);\n-        let llpersonality = callee::trans_fn_ref(pad_bcx, def_id, 0, false);\n+        let llpersonality = callee::trans_fn_ref(pad_bcx, def_id, ExprId(0));\n \n         // The only landing pad clause will be 'cleanup'\n         let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1u);"}, {"sha": "bfc9d8d2d6d0d47c545007b0dcee80dcb9ed72c0", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -397,21 +397,13 @@ pub fn trans_expr_fn<'a>(\n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n \n-    let cap_vars = {\n-        let capture_map = ccx.maps.capture_map.borrow();\n-        capture_map.get().get_copy(&id)\n-    };\n+    let cap_vars = ccx.maps.capture_map.borrow().get().get_copy(&id);\n     let ClosureResult {llbox, cdata_ty, bcx} =\n-        build_closure(bcx, cap_vars.borrow().as_slice(), sigil);\n+        build_closure(bcx, cap_vars.deref().as_slice(), sigil);\n     trans_closure(ccx, decl, body, llfn,\n                   bcx.fcx.param_substs, id,\n                   [], ty::ty_fn_ret(fty),\n-                  |bcx| {\n-                      load_environment(bcx,\n-                                       cdata_ty,\n-                                       cap_vars.borrow().as_slice(),\n-                                       sigil)\n-                  });\n+                  |bcx| load_environment(bcx, cdata_ty, cap_vars.deref().as_slice(), sigil));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n \n     bcx"}, {"sha": "e3a996e33d392d62f3e5f5cfce730e1cb9edfcac", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -805,22 +805,33 @@ pub fn expr_ty(bcx: &Block, ex: &ast::Expr) -> ty::t {\n \n pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n     let tcx = bcx.tcx();\n-    let t = ty::expr_ty_adjusted(tcx, ex);\n+    let t = ty::expr_ty_adjusted(tcx, ex, bcx.ccx().maps.method_map.borrow().get());\n     monomorphize_type(bcx, t)\n }\n \n-pub fn node_id_type_params(bcx: &Block, id: ast::NodeId, is_method: bool) -> Vec<ty::t> {\n+// Key used to lookup values supplied for type parameters in an expr.\n+#[deriving(Eq)]\n+pub enum ExprOrMethodCall {\n+    // Type parameters for a path like `None::<int>`\n+    ExprId(ast::NodeId),\n+\n+    // Type parameters for a method call like `a.foo::<int>()`\n+    MethodCall(typeck::MethodCall)\n+}\n+\n+pub fn node_id_type_params(bcx: &Block, node: ExprOrMethodCall) -> Vec<ty::t> {\n     let tcx = bcx.tcx();\n-    let params = if is_method {\n-        bcx.ccx().maps.method_map.borrow().get().get(&id).substs.tps.clone()\n-    } else {\n-        ty::node_id_to_type_params(tcx, id)\n+    let params = match node {\n+        ExprId(id) => ty::node_id_to_type_params(tcx, id),\n+        MethodCall(method_call) => {\n+            bcx.ccx().maps.method_map.borrow().get().get(&method_call).substs.tps.clone()\n+        }\n     };\n \n     if !params.iter().all(|t| !ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n-            format!(\"type parameters for node {} include inference types: {}\",\n-                 id, params.map(|t| bcx.ty_to_str(*t)).connect(\",\")));\n+            format!(\"type parameters for node {:?} include inference types: {}\",\n+                 node, params.map(|t| bcx.ty_to_str(*t)).connect(\",\")));\n     }\n \n     match bcx.fcx.param_substs {"}, {"sha": "9d55084c7f4e7ed95db6b8a859e909a8de4c3f1e", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -76,9 +76,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n         ast::LitBool(b) => C_bool(b),\n         ast::LitNil => C_nil(),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        ast::LitBinary(ref data) => {\n-            C_binary_slice(cx, data.borrow().as_slice())\n-        }\n+        ast::LitBinary(ref data) => C_binary_slice(cx, data.deref().as_slice()),\n     }\n }\n \n@@ -192,7 +190,8 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n     let mut llconst = llconst;\n     let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx, e);\n-    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx, e);\n+    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx, e,\n+                                            cx.maps.method_map.borrow().get());\n     let adjustment = {\n         let adjustments = cx.tcx.adjustments.borrow();\n         adjustments.get().find_copy(&e.id)\n@@ -424,7 +423,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n             }, true)\n           }\n           ast::ExprField(base, field, _) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx, base);\n+              let bt = ty::expr_ty_adjusted(cx.tcx, base,\n+                                            cx.maps.method_map.borrow().get());\n               let brepr = adt::represent_type(cx, bt);\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n               expr::with_field_tys(cx.tcx, bt, None, |discr, field_tys| {\n@@ -434,7 +434,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n           }\n \n           ast::ExprIndex(base, index) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx, base);\n+              let bt = ty::expr_ty_adjusted(cx.tcx, base,\n+                                            cx.maps.method_map.borrow().get());\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n               let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n                   const_eval::const_int(i) => i as u64,"}, {"sha": "d143d6743052cb9a5722b2665263c64c1c88e8c5", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 118, "deletions": 149, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -64,6 +64,7 @@ use middle::ty::struct_fields;\n use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoObject, AutoUnsafe};\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n use middle::ty;\n+use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n@@ -211,8 +212,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n                     unpack_datum!(bcx, auto_slice_and_ref(bcx, expr, datum))\n                 }\n                 Some(AutoBorrowFn(..)) => {\n-                    let adjusted_ty = ty::adjust_ty(bcx.tcx(), expr.span,\n-                                                    datum.ty, Some(adjustment));\n+                    let adjusted_ty = ty::adjust_ty(bcx.tcx(), expr.span, expr.id, datum.ty,\n+                                                    Some(adjustment), |method_call| {\n+                        bcx.ccx().maps.method_map.borrow().get()\n+                           .find(&method_call).map(|method| method.ty)\n+                    });\n                     unpack_datum!(bcx, auto_borrow_fn(bcx, adjusted_ty, datum))\n                 }\n                 Some(AutoBorrowObj(..)) => {\n@@ -221,7 +225,8 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n             };\n         }\n         AutoObject(..) => {\n-            let adjusted_ty = ty::expr_ty_adjusted(bcx.tcx(), expr);\n+            let adjusted_ty = ty::expr_ty_adjusted(bcx.tcx(), expr,\n+                                                   bcx.ccx().maps.method_map.borrow().get());\n             let scratch = rvalue_scratch_datum(bcx, adjusted_ty, \"__adjust\");\n             bcx = meth::trans_trait_cast(\n                 bcx, datum, expr.id, SaveIn(scratch.val));\n@@ -231,30 +236,6 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n     debug!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n-    fn auto_ref<'a>(bcx: &'a Block<'a>,\n-                    datum: Datum<Expr>,\n-                    expr: &ast::Expr)\n-                    -> DatumBlock<'a, Expr> {\n-        let mut bcx = bcx;\n-\n-        // Ensure cleanup of `datum` if not already scheduled and obtain\n-        // a \"by ref\" pointer.\n-        let lv_datum = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"autoref\", expr.id));\n-\n-        // Compute final type. Note that we are loose with the region and\n-        // mutability, since those things don't matter in trans.\n-        let referent_ty = lv_datum.ty;\n-        let ptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::ReStatic, referent_ty);\n-\n-        // Get the pointer.\n-        let llref = lv_datum.to_llref();\n-\n-        // Construct the resulting datum, using what was the \"by ref\"\n-        // ValueRef of type `referent_ty` to be the \"by value\" ValueRef\n-        // of type `&referent_ty`.\n-        DatumBlock(bcx, Datum(llref, ptr_ty, RvalueExpr(Rvalue(ByValue))))\n-    }\n-\n     fn auto_borrow_fn<'a>(\n                       bcx: &'a Block<'a>,\n                       adjusted_ty: ty::t,\n@@ -462,13 +443,10 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprLit(lit) => trans_immediate_lit(bcx, expr, (*lit).clone()),\n         ast::ExprBinary(op, lhs, rhs) => {\n-            // if overloaded, would be RvalueDpsExpr\n-            assert!(!bcx.ccx().maps.method_map.borrow().get().contains_key(&expr.id));\n-\n             trans_binary(bcx, expr, op, lhs, rhs)\n         }\n         ast::ExprUnary(op, x) => {\n-            trans_unary_datum(bcx, expr, op, x)\n+            trans_unary(bcx, expr, op, x)\n         }\n         ast::ExprAddrOf(_, x) => {\n             trans_addr_of(bcx, expr, x)\n@@ -789,15 +767,23 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprBinary(_, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, lhs, Some(&*rhs), Some(dest)).bcx\n+            let lhs = unpack_datum!(bcx, trans(bcx, lhs));\n+            let rhs_datum = unpack_datum!(bcx, trans(bcx, rhs));\n+            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n+                                Some((rhs_datum, rhs.id)), Some(dest)).bcx\n         }\n         ast::ExprUnary(_, subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, subexpr, None, Some(dest)).bcx\n+            let arg = unpack_datum!(bcx, trans(bcx, subexpr));\n+            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n+                                arg, None, Some(dest)).bcx\n         }\n         ast::ExprIndex(base, idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, base, Some(&*idx), Some(dest)).bcx\n+            let base = unpack_datum!(bcx, trans(bcx, base));\n+            let idx_datum = unpack_datum!(bcx, trans(bcx, idx));\n+            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n+                                Some((idx_datum, idx.id)), Some(dest)).bcx\n         }\n         ast::ExprCast(val, _) => {\n             // DPS output mode means this is a trait cast:\n@@ -848,7 +834,7 @@ fn trans_def_dps_unadjusted<'a>(\n             let variant_info = ty::enum_variant_with_id(ccx.tcx, tid, vid);\n             if variant_info.args.len() > 0u {\n                 // N-ary variant.\n-                let llfn = callee::trans_fn_ref(bcx, vid, ref_expr.id, false);\n+                let llfn = callee::trans_fn_ref(bcx, vid, ExprId(ref_expr.id));\n                 Store(bcx, llfn, lldest);\n                 return bcx;\n             } else {\n@@ -888,7 +874,7 @@ fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::DefFn(did, _) |\n         ast::DefStruct(did) | ast::DefVariant(_, did, _) |\n         ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n-            callee::trans_fn_ref(bcx, did, ref_expr.id, false)\n+            callee::trans_fn_ref(bcx, did, ExprId(ref_expr.id))\n         }\n         ast::DefStaticMethod(impl_did, ast::FromTrait(trait_did), _) => {\n             meth::trans_static_method_callee(bcx, impl_did,\n@@ -1165,25 +1151,26 @@ fn trans_immediate_lit<'a>(bcx: &'a Block<'a>,\n     immediate_rvalue_bcx(bcx, v, ty).to_expr_datumblock()\n }\n \n-fn trans_unary_datum<'a>(\n-                     bcx: &'a Block<'a>,\n-                     un_expr: &ast::Expr,\n-                     op: ast::UnOp,\n-                     sub_expr: &ast::Expr)\n-                     -> DatumBlock<'a, Expr> {\n+fn trans_unary<'a>(bcx: &'a Block<'a>,\n+                   expr: &ast::Expr,\n+                   op: ast::UnOp,\n+                   sub_expr: &ast::Expr)\n+                   -> DatumBlock<'a, Expr> {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_unary_datum\");\n \n-    let overloaded = {\n-        let method_map = bcx.ccx().maps.method_map.borrow();\n-        method_map.get().contains_key(&un_expr.id)\n-    };\n-    // if overloaded, would be RvalueDpsExpr\n-    assert!(!overloaded || op == ast::UnDeref);\n+    let method_call = MethodCall::expr(expr.id);\n \n-    let un_ty = expr_ty(bcx, un_expr);\n+    // The only overloaded operator that is translated to a datum\n+    // is an overloaded deref, since it is always yields a `&T`.\n+    // Otherwise, we should be in the RvalueDpsExpr path.\n+    assert!(\n+        op == ast::UnDeref ||\n+        !bcx.ccx().maps.method_map.borrow().get().contains_key(&method_call));\n \n-    return match op {\n+    let un_ty = expr_ty(bcx, expr);\n+\n+    match op {\n         ast::UnNot => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n             let llresult = if ty::type_is_bool(un_ty) {\n@@ -1218,15 +1205,10 @@ fn trans_unary_datum<'a>(\n             trans_boxed_expr(bcx, un_ty, sub_expr, expr_ty(bcx, sub_expr), heap_exchange)\n         }\n         ast::UnDeref => {\n-            if overloaded {\n-                let r = trans_overloaded_op(bcx, un_expr, sub_expr, None, None);\n-                DatumBlock(r.bcx, Datum(r.val, un_ty, LvalueExpr))\n-            } else {\n-                let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n-                deref_once(bcx, un_expr, datum, 0)\n-            }\n+            let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n+            deref_once(bcx, expr, datum, 0)\n         }\n-    };\n+    }\n }\n \n fn trans_boxed_expr<'a>(bcx: &'a Block<'a>,\n@@ -1451,41 +1433,43 @@ fn trans_lazy_binop<'a>(\n     return immediate_rvalue_bcx(join, phi, binop_ty).to_expr_datumblock();\n }\n \n-fn trans_binary<'a>(\n-                bcx: &'a Block<'a>,\n-                binop_expr: &ast::Expr,\n-                op: ast::BinOp,\n-                lhs: &ast::Expr,\n-                rhs: &ast::Expr)\n-                -> DatumBlock<'a, Expr> {\n+fn trans_binary<'a>(bcx: &'a Block<'a>,\n+                    expr: &ast::Expr,\n+                    op: ast::BinOp,\n+                    lhs: &ast::Expr,\n+                    rhs: &ast::Expr)\n+                    -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_binary\");\n     let ccx = bcx.ccx();\n \n+    // if overloaded, would be RvalueDpsExpr\n+    assert!(!ccx.maps.method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)));\n+\n     match op {\n         ast::BiAnd => {\n-            trans_lazy_binop(bcx, binop_expr, lazy_and, lhs, rhs)\n+            trans_lazy_binop(bcx, expr, lazy_and, lhs, rhs)\n         }\n         ast::BiOr => {\n-            trans_lazy_binop(bcx, binop_expr, lazy_or, lhs, rhs)\n+            trans_lazy_binop(bcx, expr, lazy_or, lhs, rhs)\n         }\n         _ => {\n             let mut bcx = bcx;\n             let lhs_datum = unpack_datum!(bcx, trans(bcx, lhs));\n             let rhs_datum = unpack_datum!(bcx, trans(bcx, rhs));\n-            let binop_ty = expr_ty(bcx, binop_expr);\n+            let binop_ty = expr_ty(bcx, expr);\n \n             debug!(\"trans_binary (expr {}): lhs_datum={}\",\n-                   binop_expr.id,\n+                   expr.id,\n                    lhs_datum.to_str(ccx));\n             let lhs_ty = lhs_datum.ty;\n             let lhs = lhs_datum.to_llscalarish(bcx);\n \n             debug!(\"trans_binary (expr {}): rhs_datum={}\",\n-                   binop_expr.id,\n+                   expr.id,\n                    rhs_datum.to_str(ccx));\n             let rhs_ty = rhs_datum.ty;\n             let rhs = rhs_datum.to_llscalarish(bcx);\n-            trans_eager_binop(bcx, binop_expr, binop_ty, op,\n+            trans_eager_binop(bcx, expr, binop_ty, op,\n                               lhs_ty, lhs, rhs_ty, rhs)\n         }\n     }\n@@ -1494,21 +1478,22 @@ fn trans_binary<'a>(\n fn trans_overloaded_op<'a, 'b>(\n                        bcx: &'a Block<'a>,\n                        expr: &ast::Expr,\n-                       rcvr: &'b ast::Expr,\n-                       arg: Option<&'b ast::Expr>,\n+                       method_call: MethodCall,\n+                       lhs: Datum<Expr>,\n+                       rhs: Option<(Datum<Expr>, ast::NodeId)>,\n                        dest: Option<Dest>)\n                        -> Result<'a> {\n-    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&expr.id).ty;\n+    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&method_call).ty;\n     callee::trans_call_inner(bcx,\n                              Some(expr_info(expr)),\n                              monomorphize_type(bcx, method_ty),\n                              |bcx, arg_cleanup_scope| {\n                                 meth::trans_method_callee(bcx,\n-                                                          expr.id,\n-                                                          rcvr,\n+                                                          method_call,\n+                                                          None,\n                                                           arg_cleanup_scope)\n                              },\n-                             callee::ArgAutorefSecond(rcvr, arg),\n+                             callee::ArgOverloadedOp(lhs, rhs),\n                              dest)\n }\n \n@@ -1666,10 +1651,7 @@ fn trans_assign_op<'a>(\n     debug!(\"trans_assign_op(expr={})\", bcx.expr_to_str(expr));\n \n     // User-defined operator methods cannot be used with `+=` etc right now\n-    assert!({\n-            let method_map = bcx.ccx().maps.method_map.borrow();\n-            !method_map.get().find(&expr.id).is_some()\n-        });\n+    assert!(!bcx.ccx().maps.method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)));\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n@@ -1748,6 +1730,30 @@ fn trans_log_level<'a>(bcx: &'a Block<'a>) -> DatumBlock<'a, Expr> {\n     immediate_rvalue_bcx(bcx, Load(bcx, global), ty::mk_u32()).to_expr_datumblock()\n }\n \n+fn auto_ref<'a>(bcx: &'a Block<'a>,\n+                datum: Datum<Expr>,\n+                expr: &ast::Expr)\n+                -> DatumBlock<'a, Expr> {\n+    let mut bcx = bcx;\n+\n+    // Ensure cleanup of `datum` if not already scheduled and obtain\n+    // a \"by ref\" pointer.\n+    let lv_datum = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"autoref\", expr.id));\n+\n+    // Compute final type. Note that we are loose with the region and\n+    // mutability, since those things don't matter in trans.\n+    let referent_ty = lv_datum.ty;\n+    let ptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::ReStatic, referent_ty);\n+\n+    // Get the pointer.\n+    let llref = lv_datum.to_llref();\n+\n+    // Construct the resulting datum, using what was the \"by ref\"\n+    // ValueRef of type `referent_ty` to be the \"by value\" ValueRef\n+    // of type `&referent_ty`.\n+    DatumBlock(bcx, Datum(llref, ptr_ty, RvalueExpr(Rvalue(ByValue))))\n+}\n+\n fn deref_multiple<'a>(bcx: &'a Block<'a>,\n                       expr: &ast::Expr,\n                       datum: Datum<Expr>,\n@@ -1777,6 +1783,37 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n     let mut bcx = bcx;\n \n+    // Check for overloaded deref.\n+    let method_call = MethodCall {\n+        expr_id: expr.id,\n+        autoderef: derefs as u32\n+    };\n+    let method_ty = ccx.maps.method_map.borrow().get()\n+                       .find(&method_call).map(|method| method.ty);\n+    let datum = match method_ty {\n+        Some(method_ty) => {\n+            // Overloaded. Evaluate `trans_overloaded_op`, which will\n+            // invoke the user's deref() method, which basically\n+            // converts from the `Shaht<T>` pointer that we have into\n+            // a `&T` pointer.  We can then proceed down the normal\n+            // path (below) to dereference that `&T`.\n+            let datum = if derefs == 0 {\n+                datum\n+            } else {\n+                // Always perform an AutoPtr when applying an overloaded auto-deref.\n+                unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n+            };\n+            let val = unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n+                                                              datum, None, None));\n+            let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty));\n+            Datum(val, ref_ty, RvalueExpr(Rvalue(ByValue)))\n+        }\n+        None => {\n+            // Not overloaded. We already have a pointer we know how to deref.\n+            datum\n+        }\n+    };\n+\n     let r = match ty::get(datum.ty).sty {\n         ty::ty_uniq(content_ty) => {\n             deref_owned_pointer(bcx, expr, datum, content_ty)\n@@ -1805,55 +1842,6 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n             DatumBlock(bcx, Datum(ptr, content_ty, LvalueExpr))\n         }\n \n-        ty::ty_enum(..) |\n-        ty::ty_struct(..) => {\n-            // Subtle efficiency note: In the case where we have a\n-            // newtype struct where the struct itself does not have a\n-            // dtor, but the contents do, we could avoid forcing the\n-            // data into Lvalue and instead return an Rvalue. But it\n-            // doesn't seem worth the trouble.\n-            let datum = unpack_datum!(bcx, ensure_cleanup(bcx, expr, datum));\n-\n-            // Unlike the pointer case above, we generate an\n-            // rvalue datum if we are given an rvalue. There are\n-            // two reasons that this makes sense here:\n-            //\n-            // 1. dereferencing a struct does not actually perform a\n-            //    pointer load and hence the resulting value is not\n-            //    naturally by reference, as would be required by an\n-            //    lvalue result.\n-            //\n-            // 2. the struct always owns its contents, and hence and does not\n-            //    itself have a dtor (else it would be in lvalue mode).\n-            let repr = adt::represent_type(ccx, datum.ty);\n-            let ty = adt::deref_ty(ccx, repr);\n-            let Datum { val, kind, .. } = datum;\n-            let r = match kind {\n-                LvalueExpr => {\n-                    Datum {\n-                        val: adt::trans_field_ptr(bcx, repr, val, 0, 0),\n-                        ty: ty,\n-                        kind: LvalueExpr\n-                    }\n-                }\n-                RvalueExpr(Rvalue { mode: ByRef }) => {\n-                    Datum {\n-                        val: adt::trans_field_ptr(bcx, repr, val, 0, 0),\n-                        ty: ty,\n-                        kind: RvalueExpr(Rvalue(ByValue))\n-                    }\n-                }\n-                RvalueExpr(Rvalue { mode: ByValue }) => {\n-                    Datum {\n-                        val: ExtractValue(bcx, val, 0),\n-                        ty: ty,\n-                        kind: RvalueExpr(Rvalue(ByValue))\n-                    }\n-                }\n-            };\n-            DatumBlock(bcx, r)\n-        }\n-\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n@@ -1867,25 +1855,6 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n     return r;\n \n-    fn ensure_cleanup<'a>(mut bcx: &'a Block<'a>,\n-                          expr: &ast::Expr,\n-                          datum: Datum<Expr>)\n-                          -> DatumBlock<'a, Expr> {\n-        /*!\n-         * If the datum contains data that needs to be dropped,\n-         * convert it to an lvalue, thus ensuring that cleanup\n-         * is scheduled.\n-         */\n-\n-        if ty::type_needs_drop(bcx.tcx(), datum.ty) {\n-            let lv_datum = unpack_datum!(\n-                bcx, datum.to_lvalue_datum(bcx, \"deref\", expr.id));\n-            DatumBlock(bcx, lv_datum.to_expr_datum())\n-        } else {\n-            DatumBlock(bcx, datum)\n-        }\n-    }\n-\n     fn deref_owned_pointer<'a>(bcx: &'a Block<'a>,\n                                expr: &ast::Expr,\n                                datum: Datum<Expr>,"}, {"sha": "89f3377643142985a1e14e81a415d2f6e0c333da", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -29,6 +29,7 @@ use middle::trans::type_::Type;\n use middle::trans::type_of::*;\n use middle::ty;\n use middle::typeck;\n+use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n@@ -93,29 +94,30 @@ pub fn trans_method(ccx: @CrateContext, method: &ast::Method,\n \n pub fn trans_method_callee<'a>(\n                            bcx: &'a Block<'a>,\n-                           expr_id: ast::NodeId,\n-                           this: &ast::Expr,\n+                           method_call: MethodCall,\n+                           self_expr: Option<&ast::Expr>,\n                            arg_cleanup_scope: cleanup::ScopeId)\n                            -> Callee<'a> {\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n     let (origin, method_ty) = match bcx.ccx().maps.method_map\n-                                       .borrow().get().find(&expr_id) {\n+                                       .borrow().get().find(&method_call) {\n         Some(method) => {\n-            debug!(\"trans_method_callee(expr_id={:?}, method={})\",\n-                expr_id, method.repr(bcx.tcx()));\n+            debug!(\"trans_method_callee({:?}, method={})\",\n+                   method_call, method.repr(bcx.tcx()));\n             (method.origin, method.ty)\n         }\n         None => {\n-            bcx.tcx().sess.span_bug(this.span, \"method call expr wasn't in method map\")\n+            bcx.tcx().sess.span_bug(bcx.tcx().map.span(method_call.expr_id),\n+                                    \"method call expr wasn't in method map\")\n         }\n     };\n \n     match origin {\n         typeck::MethodStatic(did) => {\n             Callee {\n                 bcx: bcx,\n-                data: Fn(callee::trans_fn_ref(bcx, did, expr_id, true))\n+                data: Fn(callee::trans_fn_ref(bcx, did, MethodCall(method_call)))\n             }\n         }\n         typeck::MethodParam(typeck::MethodParam {\n@@ -131,7 +133,7 @@ pub fn trans_method_callee<'a>(\n                         trait_id);\n \n                     let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n-                    trans_monomorphized_callee(bcx, expr_id,\n+                    trans_monomorphized_callee(bcx, method_call,\n                                                trait_id, off, vtbl)\n                 }\n                 // how to get rid of this?\n@@ -140,10 +142,18 @@ pub fn trans_method_callee<'a>(\n         }\n \n         typeck::MethodObject(ref mt) => {\n+            let self_expr = match self_expr {\n+                Some(self_expr) => self_expr,\n+                None => {\n+                    bcx.tcx().sess.span_bug(bcx.tcx().map.span(method_call.expr_id),\n+                                            \"self expr wasn't provided for trait object \\\n+                                            callee (trying to call overloaded op?)\")\n+                }\n+            };\n             trans_trait_callee(bcx,\n                                monomorphize_type(bcx, method_ty),\n                                mt.real_index,\n-                               this,\n+                               self_expr,\n                                arg_cleanup_scope)\n         }\n     }\n@@ -209,13 +219,10 @@ pub fn trans_static_method_callee(bcx: &Block,\n             let mth_id = method_with_name(ccx, impl_did, mname);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n-                    bcx, mth_id, expr_id, false,\n+                    bcx, mth_id, ExprId(expr_id),\n                     rcvr_substs.as_slice(), rcvr_origins);\n \n-            let llfn = trans_fn_ref_with_vtables(bcx,\n-                                                 mth_id,\n-                                                 expr_id,\n-                                                 false,\n+            let llfn = trans_fn_ref_with_vtables(bcx, mth_id, ExprId(expr_id),\n                                                  callee_substs.as_slice(),\n                                                  Some(callee_origins));\n \n@@ -254,7 +261,7 @@ pub fn method_with_name(ccx: &CrateContext,\n }\n \n fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n-                                  expr_id: ast::NodeId,\n+                                  method_call: MethodCall,\n                                   trait_id: ast::DefId,\n                                   n_method: uint,\n                                   vtbl: typeck::vtable_origin)\n@@ -270,14 +277,13 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n           // those from the impl and those from the method:\n           let (callee_substs, callee_origins) =\n               combine_impl_and_methods_tps(\n-                  bcx, mth_id, expr_id, true,\n+                  bcx, mth_id,  MethodCall(method_call),\n                   rcvr_substs.as_slice(), rcvr_origins);\n \n           // translate the function\n           let llfn = trans_fn_ref_with_vtables(bcx,\n                                                mth_id,\n-                                               expr_id,\n-                                               true,\n+                                               MethodCall(method_call),\n                                                callee_substs.as_slice(),\n                                                Some(callee_origins));\n \n@@ -291,8 +297,7 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n \n fn combine_impl_and_methods_tps(bcx: &Block,\n                                 mth_did: ast::DefId,\n-                                expr_id: ast::NodeId,\n-                                is_method: bool,\n+                                node: ExprOrMethodCall,\n                                 rcvr_substs: &[ty::t],\n                                 rcvr_origins: typeck::vtable_res)\n                                 -> (Vec<ty::t> , typeck::vtable_res) {\n@@ -316,7 +321,7 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     let ccx = bcx.ccx();\n     let method = ty::method(ccx.tcx, mth_did);\n     let n_m_tps = method.generics.type_param_defs().len();\n-    let node_substs = node_id_type_params(bcx, expr_id, is_method);\n+    let node_substs = node_id_type_params(bcx, node);\n     debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs\n         = vec_ng::append(Vec::from_slice(rcvr_substs),\n@@ -328,7 +333,17 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n \n     // Now, do the same work for the vtables.  The vtables might not\n     // exist, in which case we need to make them.\n-    let r_m_origins = match node_vtables(bcx, expr_id) {\n+    let vtables = match node {\n+        ExprId(id) => node_vtables(bcx, id),\n+        MethodCall(method_call) => {\n+            if method_call.autoderef == 0 {\n+                node_vtables(bcx, method_call.expr_id)\n+            } else {\n+                None\n+            }\n+        }\n+    };\n+    let r_m_origins = match vtables {\n         Some(vt) => vt,\n         None => @Vec::from_elem(node_substs.len(), @Vec::new())\n     };\n@@ -555,7 +570,7 @@ fn emit_vtable_methods(bcx: &Block,\n                    token::get_ident(ident));\n             C_null(Type::nil().ptr_to())\n         } else {\n-            trans_fn_ref_with_vtables(bcx, m_id, 0, false, substs, Some(vtables))\n+            trans_fn_ref_with_vtables(bcx, m_id, ExprId(0), substs, Some(vtables))\n         }\n     })\n }"}, {"sha": "b39bcfb075fab5ba68c986fbb0e9ddba3a8f1d2d", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -172,11 +172,11 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         // Random cut-off -- code that needs to instantiate the same function\n         // recursively more than thirty times can probably safely be assumed\n         // to be causing an infinite expansion.\n-        if depth > 30 {\n-            ccx.sess.span_fatal(\n-                ccx.tcx.map.span(fn_id.node),\n-                \"overly deep expansion of inlined function\");\n+        if depth > ccx.sess.recursion_limit.get() {\n+            ccx.sess.span_fatal(ccx.tcx.map.span(fn_id.node),\n+                \"reached the recursion limit during monomorphization\");\n         }\n+\n         monomorphizing.get().insert(fn_id, depth + 1);\n     }\n "}, {"sha": "c0ad18d9520e3f52abecb2ae7fa85378579cc16a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 53, "deletions": 111, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -23,14 +23,15 @@ use middle::resolve_lifetime;\n use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n+use middle::typeck::{MethodCall, MethodCallee, MethodMap};\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n+use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet, FnvHashMap};\n \n use std::cast;\n use std::cell::{Cell, RefCell};\n@@ -228,7 +229,7 @@ pub struct AutoDerefRef {\n     autoref: Option<AutoRef>\n }\n \n-#[deriving(Decodable, Encodable)]\n+#[deriving(Decodable, Encodable, Eq, Show)]\n pub enum AutoRef {\n     /// Convert from T to &T\n     AutoPtr(Region, ast::Mutability),\n@@ -258,10 +259,7 @@ pub struct ctxt_ {\n     diag: @syntax::diagnostic::SpanHandler,\n     // Specifically use a speedy hash algorithm for this hash map, it's used\n     // quite often.\n-    #[cfg(stage0)]\n-    interner: RefCell<HashMap<intern_key, ~t_box_>>,\n-    #[cfg(not(stage0))]\n-    interner: RefCell<HashMap<intern_key, ~t_box_, ::util::nodemap::FnvHasher>>,\n+    interner: RefCell<FnvHashMap<intern_key, ~t_box_>>,\n     next_id: Cell<uint>,\n     cstore: @metadata::cstore::CStore,\n     sess: session::Session,\n@@ -1014,13 +1012,13 @@ pub struct Generics {\n \n impl Generics {\n     pub fn has_type_params(&self) -> bool {\n-        !self.type_param_defs.borrow().is_empty()\n+        !self.type_param_defs.deref().is_empty()\n     }\n     pub fn type_param_defs<'a>(&'a self) -> &'a [TypeParameterDef] {\n-        self.type_param_defs.borrow().as_slice()\n+        self.type_param_defs.deref().as_slice()\n     }\n     pub fn region_param_defs<'a>(&'a self) -> &'a [RegionParameterDef] {\n-        self.region_param_defs.borrow().as_slice()\n+        self.region_param_defs.deref().as_slice()\n     }\n }\n \n@@ -1091,19 +1089,11 @@ pub fn mk_ctxt(s: session::Session,\n                region_maps: middle::region::RegionMaps,\n                lang_items: @middle::lang_items::LanguageItems)\n             -> ctxt {\n-    #[cfg(stage0)]\n-    fn hasher() -> HashMap<intern_key, ~t_box_> {\n-        HashMap::new()\n-    }\n-    #[cfg(not(stage0))]\n-    fn hasher() -> HashMap<intern_key, ~t_box_, ::util::nodemap::FnvHasher> {\n-        HashMap::with_hasher(::util::nodemap::FnvHasher)\n-    }\n     @ctxt_ {\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n         diag: s.diagnostic(),\n-        interner: RefCell::new(hasher()),\n+        interner: RefCell::new(FnvHashMap::new()),\n         next_id: Cell::new(primitives::LAST_PRIMITIVE_ID),\n         cstore: s.cstore,\n         sess: s,\n@@ -2710,50 +2700,23 @@ pub fn type_param(ty: t) -> Option<uint> {\n // The parameter `explicit` indicates if this is an *explicit* dereference.\n // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n pub fn deref(t: t, explicit: bool) -> Option<mt> {\n-    deref_sty(&get(t).sty, explicit)\n-}\n-\n-pub fn deref_sty(sty: &sty, explicit: bool) -> Option<mt> {\n-    match *sty {\n-        ty_box(typ) | ty_uniq(typ) => {\n-            Some(mt {\n-                ty: typ,\n-                mutbl: ast::MutImmutable,\n-            })\n-        }\n-\n-        ty_rptr(_, mt) => {\n-            Some(mt)\n-        }\n-\n-        ty_ptr(mt) if explicit => {\n-            Some(mt)\n-        }\n-\n+    match get(t).sty {\n+        ty_box(typ) | ty_uniq(typ) => Some(mt {\n+            ty: typ,\n+            mutbl: ast::MutImmutable,\n+        }),\n+        ty_rptr(_, mt) => Some(mt),\n+        ty_ptr(mt) if explicit => Some(mt),\n         _ => None\n     }\n }\n \n-pub fn type_autoderef(t: t) -> t {\n-    let mut t = t;\n-    loop {\n-        match deref(t, false) {\n-          None => return t,\n-          Some(mt) => t = mt.ty\n-        }\n-    }\n-}\n-\n // Returns the type and mutability of t[i]\n pub fn index(t: t) -> Option<mt> {\n-    index_sty(&get(t).sty)\n-}\n-\n-pub fn index_sty(sty: &sty) -> Option<mt> {\n-    match *sty {\n-      ty_vec(mt, _) => Some(mt),\n-      ty_str(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n-      _ => None\n+    match get(t).sty {\n+        ty_vec(mt, _) => Some(mt),\n+        ty_str(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n+        _ => None\n     }\n }\n \n@@ -2964,7 +2927,10 @@ pub fn expr_ty_opt(cx: ctxt, expr: &ast::Expr) -> Option<t> {\n     return node_id_to_type_opt(cx, expr.id);\n }\n \n-pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::Expr) -> t {\n+pub fn expr_ty_adjusted(cx: ctxt,\n+                        expr: &ast::Expr,\n+                        method_map: &FnvHashMap<MethodCall, MethodCallee>)\n+                        -> t {\n     /*!\n      *\n      * Returns the type of `expr`, considering any `AutoAdjustment`\n@@ -2979,11 +2945,10 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::Expr) -> t {\n      */\n \n     let unadjusted_ty = expr_ty(cx, expr);\n-    let adjustment = {\n-        let adjustments = cx.adjustments.borrow();\n-        adjustments.get().find_copy(&expr.id)\n-    };\n-    adjust_ty(cx, expr.span, unadjusted_ty, adjustment)\n+    let adjustment = cx.adjustments.borrow().get().find_copy(&expr.id);\n+    adjust_ty(cx, expr.span, expr.id, unadjusted_ty, adjustment, |method_call| {\n+        method_map.find(&method_call).map(|method| method.ty)\n+    })\n }\n \n pub fn expr_span(cx: ctxt, id: NodeId) -> Span {\n@@ -3026,14 +2991,14 @@ pub fn local_var_name_str(cx: ctxt, id: NodeId) -> InternedString {\n \n pub fn adjust_ty(cx: ctxt,\n                  span: Span,\n+                 expr_id: ast::NodeId,\n                  unadjusted_ty: ty::t,\n-                 adjustment: Option<@AutoAdjustment>)\n+                 adjustment: Option<@AutoAdjustment>,\n+                 method_type: |MethodCall| -> Option<ty::t>)\n                  -> ty::t {\n     /*! See `expr_ty_adjusted` */\n \n     return match adjustment {\n-        None => unadjusted_ty,\n-\n         Some(adjustment) => {\n             match *adjustment {\n                 AutoAddEnv(r, s) => {\n@@ -3062,7 +3027,13 @@ pub fn adjust_ty(cx: ctxt,\n \n                     if !ty::type_is_error(adjusted_ty) {\n                         for i in range(0, adj.autoderefs) {\n-                            match ty::deref(adjusted_ty, true) {\n+                            match method_type(MethodCall::autoderef(expr_id, i as u32)) {\n+                                Some(method_ty) => {\n+                                    adjusted_ty = ty_fn_ret(method_ty);\n+                                }\n+                                None => {}\n+                            }\n+                            match deref(adjusted_ty, true) {\n                                 Some(mt) => { adjusted_ty = mt.ty; }\n                                 None => {\n                                     cx.sess.span_bug(\n@@ -3130,6 +3101,7 @@ pub fn adjust_ty(cx: ctxt,\n                 }\n             }\n         }\n+        None => unadjusted_ty\n     };\n \n     fn borrow_vec(cx: ctxt, span: Span,\n@@ -3274,7 +3246,7 @@ pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n }\n \n pub fn expr_is_lval(tcx: ctxt,\n-                    method_map: typeck::MethodMap,\n+                    method_map: MethodMap,\n                     e: &ast::Expr) -> bool {\n     match expr_kind(tcx, method_map, e) {\n         LvalueExpr => true,\n@@ -3295,20 +3267,21 @@ pub enum ExprKind {\n }\n \n pub fn expr_kind(tcx: ctxt,\n-                 method_map: typeck::MethodMap,\n+                 method_map: MethodMap,\n                  expr: &ast::Expr) -> ExprKind {\n-    {\n-        let method_map = method_map.borrow();\n-        if method_map.get().contains_key(&expr.id) {\n-            // Overloaded operations are generally calls, and hence they are\n-            // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n-            // exception, as its result is always unit.\n-            return match expr.node {\n-                ast::ExprAssignOp(..) => RvalueStmtExpr,\n-                ast::ExprUnary(ast::UnDeref, _) => LvalueExpr,\n-                _ => RvalueDpsExpr\n-            };\n-        }\n+    if method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)) {\n+        // Overloaded operations are generally calls, and hence they are\n+        // generated via DPS, but there are two exceptions:\n+        return match expr.node {\n+            // `a += b` has a unit result.\n+            ast::ExprAssignOp(..) => RvalueStmtExpr,\n+\n+            // the deref method invoked for `*a` always yields an `&T`\n+            ast::ExprUnary(ast::UnDeref, _) => LvalueExpr,\n+\n+            // in the general case, result could be any type, use DPS\n+            _ => RvalueDpsExpr\n+        };\n     }\n \n     match expr.node {\n@@ -3498,37 +3471,6 @@ pub fn param_tys_in_type(ty: t) -> Vec<param_ty> {\n     rslt\n }\n \n-pub fn occurs_check(tcx: ctxt, sp: Span, vid: TyVid, rt: t) {\n-    // Returns a vec of all the type variables occurring in `ty`. It may\n-    // contain duplicates.  (Integral type vars aren't counted.)\n-    fn vars_in_type(ty: t) -> Vec<TyVid> {\n-        let mut rslt = Vec::new();\n-        walk_ty(ty, |ty| {\n-            match get(ty).sty {\n-              ty_infer(TyVar(v)) => rslt.push(v),\n-              _ => ()\n-            }\n-        });\n-        rslt\n-    }\n-\n-    // Fast path\n-    if !type_needs_infer(rt) { return; }\n-\n-    // Occurs check!\n-    if vars_in_type(rt).contains(&vid) {\n-            // Maybe this should be span_err -- however, there's an\n-            // assertion later on that the type doesn't contain\n-            // variables, so in this case we have to be sure to die.\n-            tcx.sess.span_fatal\n-                (sp, ~\"type inference failed because I \\\n-                     could not find a type\\n that's both of the form \"\n-                 + ::util::ppaux::ty_to_str(tcx, mk_var(tcx, vid)) +\n-                 \" and of the form \" + ::util::ppaux::ty_to_str(tcx, rt) +\n-                 \" - such a type would have to be infinitely large.\");\n-    }\n-}\n-\n pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     match get(t).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |"}, {"sha": "0d37904445ff6c4482f1786028747dcc6ef760ad", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 197, "deletions": 164, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -84,9 +84,7 @@ use middle::subst::Subst;\n use middle::ty::*;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n-use middle::typeck::check::{FnCtxt, impl_self_ty};\n-use middle::typeck::check::{structurally_resolved_type};\n-use middle::typeck::check::vtable;\n+use middle::typeck::check::{FnCtxt, PreferMutLvalue, impl_self_ty};\n use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::MethodCallee;\n@@ -106,6 +104,7 @@ use syntax::ast::{DefId, SelfValue, SelfRegion};\n use syntax::ast::{SelfUniq, SelfStatic};\n use syntax::ast::{MutMutable, MutImmutable};\n use syntax::ast;\n+use syntax::codemap::Span;\n use syntax::parse::token;\n \n #[deriving(Eq)]\n@@ -120,23 +119,23 @@ pub enum AutoderefReceiverFlag {\n     DontAutoderefReceiver,\n }\n \n-pub fn lookup(\n+pub fn lookup<'a>(\n         fcx: @FnCtxt,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: &ast::Expr,                   // The expression `a.b(...)`.\n-        self_expr: &ast::Expr,              // The expression `a`.\n+        self_expr: &'a ast::Expr,           // The expression `a`.\n         m_name: ast::Name,                  // The name `b`.\n         self_ty: ty::t,                     // The type of `a`.\n-        supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n+        supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n         deref_args: check::DerefArgs,       // Whether we autopointer first.\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<MethodCallee> {\n     let lcx = LookupContext {\n         fcx: fcx,\n-        expr: expr,\n-        self_expr: self_expr,\n+        span: expr.span,\n+        self_expr: Some(self_expr),\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n         impl_dups: @RefCell::new(HashSet::new()),\n@@ -147,7 +146,6 @@ pub fn lookup(\n         autoderef_receiver: autoderef_receiver,\n     };\n \n-    let self_ty = structurally_resolved_type(fcx, self_expr.span, self_ty);\n     debug!(\"method lookup(self_ty={}, expr={}, self_expr={})\",\n            self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n@@ -162,25 +160,25 @@ pub fn lookup(\n     debug!(\"searching extension candidates\");\n     lcx.reset_candidates();\n     lcx.push_bound_candidates(self_ty, None);\n-    lcx.push_extension_candidates();\n+    lcx.push_extension_candidates(expr.id);\n     return lcx.search(self_ty);\n }\n \n-pub fn lookup_in_trait(\n+pub fn lookup_in_trait<'a>(\n         fcx: @FnCtxt,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n-        expr: &ast::Expr,                   // The expression `a.b(...)`.\n-        self_expr: &ast::Expr,              // The expression `a`.\n+        span: Span,                         // The expression `a.b(...)`'s span.\n+        self_expr: Option<&'a ast::Expr>,   // The expression `a`, if available.\n         m_name: ast::Name,                  // The name `b`.\n         trait_did: DefId,                   // The trait to limit the lookup to.\n         self_ty: ty::t,                     // The type of `a`.\n-        supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n+        supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<MethodCallee> {\n     let lcx = LookupContext {\n         fcx: fcx,\n-        expr: expr,\n+        span: span,\n         self_expr: self_expr,\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n@@ -192,20 +190,24 @@ pub fn lookup_in_trait(\n         autoderef_receiver: autoderef_receiver,\n     };\n \n-    let self_ty = structurally_resolved_type(fcx, self_expr.span, self_ty);\n-    debug!(\"method lookup_in_trait(self_ty={}, expr={}, self_expr={})\",\n-           self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n-           self_expr.repr(fcx.tcx()));\n+    debug!(\"method lookup_in_trait(self_ty={}, self_expr={})\",\n+           self_ty.repr(fcx.tcx()), self_expr.map(|e| e.repr(fcx.tcx())));\n \n     lcx.push_bound_candidates(self_ty, Some(trait_did));\n     lcx.push_extension_candidate(trait_did);\n     lcx.search(self_ty)\n }\n \n-pub struct LookupContext<'a> {\n+struct LookupContext<'a> {\n     fcx: @FnCtxt,\n-    expr: &'a ast::Expr,\n-    self_expr: &'a ast::Expr,\n+    span: Span,\n+\n+    // The receiver to the method call. Only `None` in the case of\n+    // an overloaded autoderef, where the receiver may be an intermediate\n+    // state like \"the expression `x` when it has been autoderef'd\n+    // twice already\".\n+    self_expr: Option<&'a ast::Expr>,\n+\n     m_name: ast::Name,\n     supplied_tps: &'a [ty::t],\n     impl_dups: @RefCell<HashSet<DefId>>,\n@@ -221,7 +223,7 @@ pub struct LookupContext<'a> {\n  * is of a suitable type.\n  */\n #[deriving(Clone)]\n-pub struct Candidate {\n+struct Candidate {\n     rcvr_match_condition: RcvrMatchCondition,\n     rcvr_substs: ty::substs,\n     method_ty: @ty::Method,\n@@ -244,68 +246,70 @@ pub enum RcvrMatchCondition {\n \n impl<'a> LookupContext<'a> {\n     fn search(&self, self_ty: ty::t) -> Option<MethodCallee> {\n-        let mut self_ty = self_ty;\n-        let mut autoderefs = 0;\n-        loop {\n-            debug!(\"loop: self_ty={} autoderefs={}\",\n-                   self.ty_to_str(self_ty), autoderefs);\n-\n-            match self.deref_args {\n-                check::DontDerefArgs => {\n-                    match self.search_for_autoderefd_method(self_ty,\n-                                                            autoderefs) {\n-                        Some(mme) => { return Some(mme); }\n-                        None => {}\n-                    }\n-\n-                    match self.search_for_autoptrd_method(self_ty,\n-                                                          autoderefs) {\n-                        Some(mme) => { return Some(mme); }\n-                        None => {}\n-                    }\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n+        let self_expr_id = self.self_expr.map(|e| e.id);\n+        let (self_ty, autoderefs, result) =\n+            check::autoderef(\n+                self.fcx, span, self_ty, self_expr_id, PreferMutLvalue,\n+                |self_ty, autoderefs| self.search_step(self_ty, autoderefs));\n+\n+        match result {\n+            Some(Some(result)) => Some(result),\n+            _ => {\n+                if self.is_overloaded_deref() {\n+                    // If we are searching for an overloaded deref, no\n+                    // need to try coercing a `~[T]` to an `&[T]` and\n+                    // searching for an overloaded deref on *that*.\n+                    None\n+                } else {\n+                    self.search_for_autosliced_method(self_ty, autoderefs)\n                 }\n-                check::DoDerefArgs => {\n-                    match self.search_for_autoptrd_method(self_ty,\n-                                                          autoderefs) {\n-                        Some(mme) => { return Some(mme); }\n-                        None => {}\n-                    }\n+            }\n+        }\n+    }\n \n-                    match self.search_for_autoderefd_method(self_ty,\n-                                                            autoderefs) {\n-                        Some(mme) => { return Some(mme); }\n-                        None => {}\n-                    }\n+    fn search_step(&self,\n+                   self_ty: ty::t,\n+                   autoderefs: uint)\n+                   -> Option<Option<MethodCallee>> {\n+        debug!(\"search_step: self_ty={} autoderefs={}\",\n+               self.ty_to_str(self_ty), autoderefs);\n+\n+        match self.deref_args {\n+            check::DontDerefArgs => {\n+                match self.search_for_autoderefd_method(self_ty, autoderefs) {\n+                    Some(result) => return Some(Some(result)),\n+                    None => {}\n                 }\n-            }\n \n-            // Don't autoderef if we aren't supposed to.\n-            if self.autoderef_receiver == DontAutoderefReceiver {\n-                break;\n+                match self.search_for_autoptrd_method(self_ty, autoderefs) {\n+                    Some(result) => return Some(Some(result)),\n+                    None => {}\n+                }\n             }\n+            check::DoDerefArgs => {\n+                match self.search_for_autoptrd_method(self_ty, autoderefs) {\n+                    Some(result) => return Some(Some(result)),\n+                    None => {}\n+                }\n \n-            // Otherwise, perform autoderef.\n-            match self.deref(self_ty) {\n-                None => { break; }\n-                Some(ty) => {\n-                    self_ty = ty;\n-                    autoderefs += 1;\n+                match self.search_for_autoderefd_method(self_ty, autoderefs) {\n+                    Some(result) => return Some(Some(result)),\n+                    None => {}\n                 }\n             }\n         }\n \n-        self.search_for_autosliced_method(self_ty, autoderefs)\n+        // Don't autoderef if we aren't supposed to.\n+        if self.autoderef_receiver == DontAutoderefReceiver {\n+            Some(None)\n+        } else {\n+            None\n+        }\n     }\n \n-    fn deref(&self, ty: ty::t) -> Option<ty::t> {\n-        match ty::deref(ty, false) {\n-            None => None,\n-            Some(t) => {\n-                Some(structurally_resolved_type(self.fcx,\n-                                                self.self_expr.span,\n-                                                t.ty))\n-            }\n-        }\n+    fn is_overloaded_deref(&self) -> bool {\n+        self.self_expr.is_none()\n     }\n \n     // ______________________________________________________________________\n@@ -326,8 +330,8 @@ impl<'a> LookupContext<'a> {\n          * we'll want to find the inherent impls for `C`.\n          */\n \n-        let mut self_ty = self_ty;\n-        loop {\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n+        check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n             match get(self_ty).sty {\n                 ty_trait(did, ref substs, _, _, _) => {\n                     self.push_inherent_candidates_from_object(did, substs);\n@@ -341,19 +345,18 @@ impl<'a> LookupContext<'a> {\n                 _ => { /* No inherent methods in these types */ }\n             }\n \n-            // n.b.: Generally speaking, we only loop if we hit the\n-            // fallthrough case in the match above.  The exception\n-            // would be newtype enums.\n-            self_ty = match self.deref(self_ty) {\n-                None => { return; }\n-                Some(ty) => { ty }\n+            // Don't autoderef if we aren't supposed to.\n+            if self.autoderef_receiver == DontAutoderefReceiver {\n+                Some(())\n+            } else {\n+                None\n             }\n-        }\n+        });\n     }\n \n     fn push_bound_candidates(&self, self_ty: ty::t, restrict_to: Option<DefId>) {\n-        let mut self_ty = self_ty;\n-        loop {\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n+        check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n             match get(self_ty).sty {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, restrict_to, p);\n@@ -366,11 +369,13 @@ impl<'a> LookupContext<'a> {\n                 _ => { /* No bound methods in these types */ }\n             }\n \n-            self_ty = match self.deref(self_ty) {\n-                None => { return; }\n-                Some(ty) => { ty }\n+            // Don't autoderef if we aren't supposed to.\n+            if self.autoderef_receiver == DontAutoderefReceiver {\n+                Some(())\n+            } else {\n+                None\n             }\n-        }\n+        });\n     }\n \n     fn push_extension_candidate(&self, trait_did: DefId) {\n@@ -386,11 +391,11 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn push_extension_candidates(&self) {\n+    fn push_extension_candidates(&self, expr_id: ast::NodeId) {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n-        let opt_applicable_traits = self.fcx.ccx.trait_map.find(&self.expr.id);\n+        let opt_applicable_traits = self.fcx.ccx.trait_map.find(&expr_id);\n         for applicable_traits in opt_applicable_traits.move_iter() {\n             for trait_did in applicable_traits.iter() {\n                 self.push_extension_candidate(*trait_did);\n@@ -591,8 +596,8 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn push_candidates_from_impl(&self,\n-                                     candidates: &mut Vec<Candidate> ,\n-                                     impl_info: &ty::Impl) {\n+                                 candidates: &mut Vec<Candidate>,\n+                                 impl_info: &ty::Impl) {\n         {\n             let mut impl_dups = self.impl_dups.borrow_mut();\n             if !impl_dups.get().insert(impl_info.did) {\n@@ -619,12 +624,12 @@ impl<'a> LookupContext<'a> {\n \n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n-        let location_info = &vtable::location_info_for_expr(self.self_expr);\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n         let vcx = self.fcx.vtable_context();\n         let ty::ty_param_substs_and_ty {\n             substs: impl_substs,\n             ty: impl_ty\n-        } = impl_self_ty(&vcx, location_info, impl_info.did);\n+        } = impl_self_ty(&vcx, span, impl_info.did);\n \n         candidates.push(Candidate {\n             rcvr_match_condition: RcvrMatchesIfSubtype(impl_ty),\n@@ -638,28 +643,41 @@ impl<'a> LookupContext<'a> {\n     // Candidate selection (see comment at start of file)\n \n     fn search_for_autoderefd_method(&self,\n-                                        self_ty: ty::t,\n-                                        autoderefs: uint)\n-                                        -> Option<MethodCallee> {\n-        let (self_ty, autoadjust) =\n+                                    self_ty: ty::t,\n+                                    autoderefs: uint)\n+                                    -> Option<MethodCallee> {\n+        let (self_ty, auto_deref_ref) =\n             self.consider_reborrow(self_ty, autoderefs);\n+\n+        // Hacky. For overloaded derefs, there may be an adjustment\n+        // added to the expression from the outside context, so we do not store\n+        // an explicit adjustment, but rather we hardwire the single deref\n+        // that occurs in trans and mem_categorization.\n+        let adjustment = match self.self_expr {\n+            Some(expr) => Some((expr.id, @ty::AutoDerefRef(auto_deref_ref))),\n+            None => return None\n+        };\n+\n         match self.search_for_method(self_ty) {\n             None => None,\n-            Some(mme) => {\n+            Some(method) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n-                       adjustment ({}) to {}\",\n-                       autoderefs,\n-                       self.self_expr.id);\n-                self.fcx.write_adjustment(self.self_expr.id, @autoadjust);\n-                Some(mme)\n+                       adjustment {:?}\", adjustment);\n+                match adjustment {\n+                    Some((self_expr_id, adj)) => {\n+                        self.fcx.write_adjustment(self_expr_id, adj);\n+                    }\n+                    None => {}\n+                }\n+                Some(method)\n             }\n         }\n     }\n \n     fn consider_reborrow(&self,\n-                             self_ty: ty::t,\n-                             autoderefs: uint)\n-                             -> (ty::t, ty::AutoAdjustment) {\n+                         self_ty: ty::t,\n+                         autoderefs: uint)\n+                         -> (ty::t, ty::AutoDerefRef) {\n         /*!\n          * In the event that we are invoking a method with a receiver\n          * of a borrowed type like `&T`, `&mut T`, or `&mut [T]`,\n@@ -681,44 +699,41 @@ impl<'a> LookupContext<'a> {\n         return match ty::get(self_ty).sty {\n             ty::ty_rptr(_, self_mt) if default_method_hack(self_mt) => {\n                 (self_ty,\n-                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                 ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n-                     autoref: None}))\n+                     autoref: None})\n             }\n             ty::ty_rptr(_, self_mt) => {\n                 let region =\n-                    self.infcx().next_region_var(\n-                        infer::Autoref(self.expr.span));\n+                    self.infcx().next_region_var(infer::Autoref(self.span));\n                 (ty::mk_rptr(tcx, region, self_mt),\n-                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                 ty::AutoDerefRef {\n                      autoderefs: autoderefs+1,\n-                     autoref: Some(ty::AutoPtr(region, self_mt.mutbl))}))\n+                     autoref: Some(ty::AutoPtr(region, self_mt.mutbl))})\n             }\n             ty::ty_vec(self_mt, vstore_slice(_)) => {\n                 let region =\n-                    self.infcx().next_region_var(\n-                        infer::Autoref(self.expr.span));\n+                    self.infcx().next_region_var(infer::Autoref(self.span));\n                 (ty::mk_vec(tcx, self_mt, vstore_slice(region)),\n-                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                 ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n-                     autoref: Some(ty::AutoBorrowVec(region, self_mt.mutbl))}))\n+                     autoref: Some(ty::AutoBorrowVec(region, self_mt.mutbl))})\n             }\n-            ty_trait(did, ref substs, ty::RegionTraitStore(_), mutbl, bounds) => {\n+            ty::ty_trait(did, ref substs, ty::RegionTraitStore(_), mutbl, bounds) => {\n                 let region =\n-                    self.infcx().next_region_var(\n-                        infer::Autoref(self.expr.span));\n+                    self.infcx().next_region_var(infer::Autoref(self.span));\n                 (ty::mk_trait(tcx, did, substs.clone(),\n                               ty::RegionTraitStore(region),\n                               mutbl, bounds),\n-                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                 ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n-                     autoref: Some(ty::AutoBorrowObj(region, mutbl))}))\n+                     autoref: Some(ty::AutoBorrowObj(region, mutbl))})\n             }\n             _ => {\n                 (self_ty,\n-                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                 ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n-                     autoref: None}))\n+                     autoref: None})\n             }\n         };\n \n@@ -738,9 +753,9 @@ impl<'a> LookupContext<'a> {\n                                     autoderefs: uint)\n                                     -> Option<MethodCallee> {\n         /*!\n-         *\n          * Searches for a candidate by converting things like\n-         * `~[]` to `&[]`. */\n+         * `~[]` to `&[]`.\n+         */\n \n         let tcx = self.tcx();\n         let sty = ty::get(self_ty).sty.clone();\n@@ -848,30 +863,48 @@ impl<'a> LookupContext<'a> {\n             mutbls: &[ast::Mutability],\n             mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n             -> Option<MethodCallee> {\n+        // Hacky. For overloaded derefs, there may be an adjustment\n+        // added to the expression from the outside context, so we do not store\n+        // an explicit adjustment, but rather we hardwire the single deref\n+        // that occurs in trans and mem_categorization.\n+        let self_expr_id = match self.self_expr {\n+            Some(expr) => Some(expr.id),\n+            None => {\n+                assert_eq!(autoderefs, 0);\n+                assert_eq!(kind(ty::ReEmpty, ast::MutImmutable),\n+                           ty::AutoPtr(ty::ReEmpty, ast::MutImmutable));\n+                None\n+            }\n+        };\n+\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n         let region =\n-            self.infcx().next_region_var(\n-                infer::Autoref(self.expr.span));\n+            self.infcx().next_region_var(infer::Autoref(self.span));\n         for mutbl in mutbls.iter() {\n             let autoref_ty = mk_autoref_ty(*mutbl, region);\n             match self.search_for_method(autoref_ty) {\n                 None => {}\n-                Some(mme) => {\n-                    self.fcx.write_adjustment(\n-                        self.self_expr.id,\n-                        @ty::AutoDerefRef(ty::AutoDerefRef {\n-                            autoderefs: autoderefs,\n-                            autoref: Some(kind(region, *mutbl))}));\n-                    return Some(mme);\n+                Some(method) => {\n+                    match self_expr_id {\n+                        Some(self_expr_id) => {\n+                            self.fcx.write_adjustment(\n+                                self_expr_id,\n+                                @ty::AutoDerefRef(ty::AutoDerefRef {\n+                                    autoderefs: autoderefs,\n+                                    autoref: Some(kind(region, *mutbl))\n+                                }));\n+                        }\n+                        None => {}\n+                    }\n+                    return Some(method);\n                 }\n             }\n         }\n-        return None;\n+        None\n     }\n \n-    fn search_for_method(&self, rcvr_ty: ty::t)\n-                         -> Option<MethodCallee> {\n+    fn search_for_method(&self, rcvr_ty: ty::t) -> Option<MethodCallee> {\n         debug!(\"search_for_method(rcvr_ty={})\", self.ty_to_str(rcvr_ty));\n         let _indenter = indenter();\n \n@@ -900,9 +933,8 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn consider_candidates(&self,\n-                           rcvr_ty: ty::t,\n-                           candidates: &mut Vec<Candidate> )\n+    fn consider_candidates(&self, rcvr_ty: ty::t,\n+                           candidates: &mut Vec<Candidate>)\n                            -> Option<MethodCallee> {\n         // FIXME(pcwalton): Do we need to clone here?\n         let relevant_candidates: Vec<Candidate> =\n@@ -918,7 +950,7 @@ impl<'a> LookupContext<'a> {\n \n         if relevant_candidates.len() > 1 {\n             self.tcx().sess.span_err(\n-                self.expr.span,\n+                self.span,\n                 \"multiple applicable methods in scope\");\n             for (idx, candidate) in relevant_candidates.iter().enumerate() {\n                 self.report_candidate(idx, &candidate.origin);\n@@ -986,8 +1018,7 @@ impl<'a> LookupContext<'a> {\n \n         let tcx = self.tcx();\n \n-        debug!(\"confirm_candidate(expr={}, rcvr_ty={}, candidate={})\",\n-               self.expr.repr(tcx),\n+        debug!(\"confirm_candidate(rcvr_ty={}, candidate={})\",\n                self.ty_to_str(rcvr_ty),\n                candidate.repr(self.tcx()));\n \n@@ -1007,12 +1038,12 @@ impl<'a> LookupContext<'a> {\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else if num_method_tps == 0u {\n                 tcx.sess.span_err(\n-                    self.expr.span,\n+                    self.span,\n                     \"this method does not take type parameters\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else if num_supplied_tps != num_method_tps {\n                 tcx.sess.span_err(\n-                    self.expr.span,\n+                    self.span,\n                     \"incorrect number of type \\\n                      parameters given for this method\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n@@ -1025,12 +1056,12 @@ impl<'a> LookupContext<'a> {\n         // FIXME -- permit users to manually specify lifetimes\n         let mut all_regions = match candidate.rcvr_substs.regions {\n             NonerasedRegions(ref v) => v.clone(),\n-            ErasedRegions => tcx.sess.span_bug(self.expr.span, \"ErasedRegions\")\n+            ErasedRegions => tcx.sess.span_bug(self.span, \"ErasedRegions\")\n         };\n         let m_regions =\n             self.fcx.infcx().region_vars_for_defs(\n-                self.expr.span,\n-                candidate.method_ty.generics.region_param_defs.borrow().as_slice());\n+                self.span,\n+                candidate.method_ty.generics.region_param_defs.deref().as_slice());\n         for &r in m_regions.iter() {\n             all_regions.push(r);\n         }\n@@ -1077,7 +1108,7 @@ impl<'a> LookupContext<'a> {\n         let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(\n             tcx, &fn_sig,\n             |br| self.fcx.infcx().next_region_var(\n-                infer::LateBoundRegion(self.expr.span, br)));\n+                infer::LateBoundRegion(self.span, br)));\n         let transformed_self_ty = *fn_sig.inputs.get(0);\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n@@ -1091,7 +1122,8 @@ impl<'a> LookupContext<'a> {\n         // variables to unify etc).  Since we checked beforehand, and\n         // nothing has changed in the meantime, this unification\n         // should never fail.\n-        match self.fcx.mk_subty(false, infer::Misc(self.self_expr.span),\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n+        match self.fcx.mk_subty(false, infer::Misc(span),\n                                 rcvr_ty, transformed_self_ty) {\n             result::Ok(_) => {}\n             result::Err(_) => {\n@@ -1112,8 +1144,8 @@ impl<'a> LookupContext<'a> {\n         &self,\n         trait_def_id: ast::DefId,\n         rcvr_substs: &ty::substs,\n-        method_ty: &ty::Method) -> ty::t\n-    {\n+        method_ty: &ty::Method)\n+        -> ty::t {\n         /*!\n          * This is a bit tricky. We have a match against a trait method\n          * being invoked on an object, and we want to generate the\n@@ -1140,7 +1172,7 @@ impl<'a> LookupContext<'a> {\n                                  tps: rcvr_substs.tps.clone()};\n         match method_ty.explicit_self {\n             ast::SelfStatic => {\n-                self.bug(~\"static method for object type receiver\");\n+                self.bug(\"static method for object type receiver\");\n             }\n             ast::SelfValue => {\n                 ty::mk_err() // error reported in `enforce_object_limitations()`\n@@ -1187,14 +1219,14 @@ impl<'a> LookupContext<'a> {\n         match candidate.method_ty.explicit_self {\n             ast::SelfStatic => { // reason (a) above\n                 self.tcx().sess.span_err(\n-                    self.expr.span,\n+                    self.span,\n                     \"cannot call a method without a receiver \\\n                      through an object\");\n             }\n \n             ast::SelfValue => { // reason (a) above\n                 self.tcx().sess.span_err(\n-                    self.expr.span,\n+                    self.span,\n                     \"cannot call a method with a by-value receiver \\\n                      through an object\");\n             }\n@@ -1206,7 +1238,7 @@ impl<'a> LookupContext<'a> {\n         let check_for_self_ty = |ty| {\n             if ty::type_has_self(ty) {\n                 self.tcx().sess.span_err(\n-                    self.expr.span,\n+                    self.span,\n                     \"cannot call a method whose type contains a \\\n                      self-type through an object\");\n                 true\n@@ -1228,7 +1260,7 @@ impl<'a> LookupContext<'a> {\n \n         if candidate.method_ty.generics.has_type_params() { // reason (b) above\n             self.tcx().sess.span_err(\n-                self.expr.span,\n+                self.span,\n                 \"cannot call a generic method through an object\");\n         }\n     }\n@@ -1253,7 +1285,7 @@ impl<'a> LookupContext<'a> {\n         }\n \n         if bad {\n-            self.tcx().sess.span_err(self.expr.span,\n+            self.tcx().sess.span_err(self.span,\n                                      \"explicit call to destructor\");\n         }\n     }\n@@ -1364,7 +1396,7 @@ impl<'a> LookupContext<'a> {\n         let span = if did.krate == ast::LOCAL_CRATE {\n             self.tcx().map.span(did.node)\n         } else {\n-            self.expr.span\n+            self.span\n         };\n         self.tcx().sess.span_note(\n             span,\n@@ -1375,15 +1407,15 @@ impl<'a> LookupContext<'a> {\n \n     fn report_param_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n-            self.expr.span,\n+            self.span,\n             format!(\"candidate \\\\#{} derives from the bound `{}`\",\n                  idx+1u,\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n     fn report_trait_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n-            self.expr.span,\n+            self.span,\n             format!(\"candidate \\\\#{} derives from the type of the receiver, \\\n                   which is the trait `{}`\",\n                  idx+1u,\n@@ -1406,8 +1438,9 @@ impl<'a> LookupContext<'a> {\n         ty::item_path_str(self.tcx(), did)\n     }\n \n-    fn bug(&self, s: ~str) -> ! {\n-        self.tcx().sess.span_bug(self.self_expr.span, s)\n+    fn bug(&self, s: &str) -> ! {\n+        let span = self.self_expr.map_or(self.span, |e| e.span);\n+        self.tcx().sess.span_bug(span, s)\n     }\n }\n "}, {"sha": "51efcb7d1c3879c613480ceaec1fd394522ed624", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 105, "deletions": 122, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -99,19 +99,20 @@ use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::method::{DontAutoderefReceiver};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::check::regionmanip::relate_free_regions;\n-use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n+use middle::typeck::check::vtable::VtableContext;\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n use middle::typeck::rscope::RegionScope;\n use middle::typeck::{lookup_def_ccx};\n use middle::typeck::no_params;\n-use middle::typeck::{require_same_types, MethodMap, vtable_map};\n+use middle::typeck::{require_same_types, vtable_map};\n+use middle::typeck::{MethodCall, MethodMap};\n use middle::lang_items::TypeIdLangItem;\n use util::common::{block_query, indenter, loop_query};\n use util::ppaux;\n use util::ppaux::{UserString, Repr};\n-use util::nodemap::NodeMap;\n+use util::nodemap::{FnvHashMap, NodeMap};\n \n use std::cell::{Cell, RefCell};\n use collections::HashMap;\n@@ -266,7 +267,7 @@ impl Inherited {\n             node_types: RefCell::new(NodeMap::new()),\n             node_type_substs: RefCell::new(NodeMap::new()),\n             adjustments: RefCell::new(NodeMap::new()),\n-            method_map: @RefCell::new(NodeMap::new()),\n+            method_map: @RefCell::new(FnvHashMap::new()),\n             vtable_map: @RefCell::new(NodeMap::new()),\n             upvar_borrow_map: RefCell::new(HashMap::new()),\n         }\n@@ -569,7 +570,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n                 fn_tpt.generics.type_param_defs(),\n                 [],\n                 [],\n-                fn_tpt.generics.region_param_defs.borrow().as_slice(),\n+                fn_tpt.generics.region_param_defs.deref().as_slice(),\n                 body.id);\n \n         check_bare_fn(ccx, decl, body, it.id, fn_tpt.ty, param_env);\n@@ -1108,18 +1109,6 @@ impl FnCtxt {\n         }\n     }\n \n-    pub fn method_ty(&self, id: ast::NodeId) -> ty::t {\n-        match self.inh.method_map.borrow().get().find(&id) {\n-            Some(method) => method.ty,\n-            None => {\n-                self.tcx().sess.bug(\n-                    format!(\"no method entry for node {}: {} in fcx {}\",\n-                            id, self.tcx().map.node_to_str(id),\n-                            self.tag()));\n-            }\n-        }\n-    }\n-\n     pub fn node_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n         match self.inh.node_type_substs.borrow().get().find(&id) {\n             Some(ts) => (*ts).clone(),\n@@ -1133,7 +1122,7 @@ impl FnCtxt {\n     }\n \n     pub fn method_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n-        match self.inh.method_map.borrow().get().find(&id) {\n+        match self.inh.method_map.borrow().get().find(&MethodCall::expr(id)) {\n             Some(method) => method.substs.clone(),\n             None => {\n                 self.tcx().sess.bug(\n@@ -1252,98 +1241,93 @@ pub enum LvaluePreference {\n     NoPreference\n }\n \n-pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n+pub fn autoderef<T>(fcx: @FnCtxt, sp: Span, base_ty: ty::t,\n+                    expr_id: Option<ast::NodeId>,\n+                    mut lvalue_pref: LvaluePreference,\n+                    should_stop: |ty::t, uint| -> Option<T>)\n+                    -> (ty::t, uint, Option<T>) {\n     /*!\n+     * Executes an autoderef loop for the type `t`. At each step, invokes\n+     * `should_stop` to decide whether to terminate the loop. Returns\n+     * the final type and number of derefs that it performed.\n      *\n-     * Autoderefs the type `t` as many times as possible, returning\n-     * a new type and a counter for how many times the type was\n-     * deref'd.  If the counter is non-zero, the receiver is responsible\n-     * for inserting an AutoAdjustment record into `tcx.adjustments`\n-     * so that trans/borrowck/etc know about this autoderef. */\n-\n-    let mut t1 = t;\n-    let mut enum_dids = Vec::new();\n-    let mut autoderefs = 0;\n-    loop {\n-        let sty = structure_of(fcx, sp, t1);\n-\n-        // Some extra checks to detect weird cycles and so forth:\n-        match *sty {\n-            ty::ty_box(inner) | ty::ty_uniq(inner) => {\n-                match ty::get(t1).sty {\n-                    ty::ty_infer(ty::TyVar(v1)) => {\n-                        ty::occurs_check(fcx.ccx.tcx, sp, v1,\n-                                         ty::mk_box(fcx.ccx.tcx, inner));\n-                    }\n-                    _ => ()\n-                }\n-            }\n-            ty::ty_rptr(_, inner) => {\n-                match ty::get(t1).sty {\n-                    ty::ty_infer(ty::TyVar(v1)) => {\n-                        ty::occurs_check(fcx.ccx.tcx, sp, v1,\n-                                         ty::mk_box(fcx.ccx.tcx, inner.ty));\n-                    }\n-                    _ => ()\n-                }\n-            }\n-            ty::ty_enum(ref did, _) => {\n-                // Watch out for a type like `enum t = @t`.  Such a\n-                // type would otherwise infinitely auto-deref.  Only\n-                // autoderef loops during typeck (basically, this one\n-                // and the loops in typeck::check::method) need to be\n-                // concerned with this, as an error will be reported\n-                // on the enum definition as well because the enum is\n-                // not instantiable.\n-                if enum_dids.contains(did) {\n-                    return (t1, autoderefs);\n-                }\n-                enum_dids.push(*did);\n-            }\n-            _ => { /*ok*/ }\n+     * Note: this method does not modify the adjustments table. The caller is\n+     * responsible for inserting an AutoAdjustment record into the `fcx`\n+     * using one of the suitable methods.\n+     */\n+\n+    let mut t = base_ty;\n+    for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n+        let resolved_t = structurally_resolved_type(fcx, sp, t);\n+\n+        match should_stop(resolved_t, autoderefs) {\n+            Some(x) => return (resolved_t, autoderefs, Some(x)),\n+            None => {}\n         }\n \n         // Otherwise, deref if type is derefable:\n-        match ty::deref_sty(sty, false) {\n+        let mt = match ty::deref(resolved_t, false) {\n+            Some(mt) => Some(mt),\n             None => {\n-                return (t1, autoderefs);\n+                let method_call =\n+                    expr_id.map(|id| MethodCall::autoderef(id, autoderefs as u32));\n+                try_overloaded_deref(fcx, sp, method_call, None, resolved_t, lvalue_pref)\n             }\n+        };\n+        match mt {\n             Some(mt) => {\n-                autoderefs += 1;\n-                t1 = mt.ty\n+                t = mt.ty;\n+                if mt.mutbl == ast::MutImmutable {\n+                    lvalue_pref = NoPreference;\n+                }\n             }\n+            None => return (resolved_t, autoderefs, None)\n         }\n-    };\n+    }\n+\n+    // We've reached the recursion limit, error gracefully.\n+    fcx.tcx().sess.span_err(sp,\n+        format!(\"reached the recursion limit while auto-dereferencing {}\",\n+                base_ty.repr(fcx.tcx())));\n+    (ty::mk_err(), 0, None)\n }\n \n fn try_overloaded_deref(fcx: @FnCtxt,\n-                        expr: &ast::Expr,\n-                        base_expr: &ast::Expr,\n+                        span: Span,\n+                        method_call: Option<MethodCall>,\n+                        base_expr: Option<&ast::Expr>,\n                         base_ty: ty::t,\n                         lvalue_pref: LvaluePreference)\n                         -> Option<ty::mt> {\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n         (PreferMutLvalue, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx, expr, base_expr, token::intern(\"deref_mut\"),\n-                                    trait_did, base_ty, [], DontAutoderefReceiver)\n+            method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n+                                    token::intern(\"deref_mut\"), trait_did,\n+                                    base_ty, [], DontAutoderefReceiver)\n         }\n         _ => None\n     };\n \n     // Otherwise, fall back to Deref.\n     let method = match (method, fcx.tcx().lang_items.deref_trait()) {\n         (None, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx, expr, base_expr, token::intern(\"deref\"),\n-                                    trait_did, base_ty, [], DontAutoderefReceiver)\n+            method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n+                                    token::intern(\"deref\"), trait_did,\n+                                    base_ty, [], DontAutoderefReceiver)\n         }\n         (method, _) => method\n     };\n \n     match method {\n         Some(method) => {\n             let ref_ty = ty::ty_fn_ret(method.ty);\n-            fcx.inh.method_map.borrow_mut().get().insert(expr.id, method);\n+            match method_call {\n+                Some(method_call) => {\n+                    fcx.inh.method_map.borrow_mut().get().insert(method_call, method);\n+                }\n+                None => {}\n+            }\n             ty::deref(ref_ty, true)\n         }\n         None => None\n@@ -1434,8 +1418,7 @@ fn check_expr_with_lvalue_pref(fcx: @FnCtxt, expr: &ast::Expr,\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n pub fn impl_self_ty(vcx: &VtableContext,\n-                    location_info: &LocationInfo, // (potential) receiver for\n-                                                  // this impl\n+                    span: Span, // (potential) receiver for this impl\n                     did: ast::DefId)\n                  -> ty_param_substs_and_ty {\n     let tcx = vcx.tcx();\n@@ -1446,7 +1429,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n          ity.generics.region_param_defs(),\n          ity.ty);\n \n-    let rps = vcx.infcx.region_vars_for_defs(location_info.span, rps);\n+    let rps = vcx.infcx.region_vars_for_defs(span, rps);\n     let tps = vcx.infcx.next_ty_vars(n_tps);\n \n     let substs = substs {\n@@ -1921,7 +1904,8 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                          AutoderefReceiver) {\n             Some(method) => {\n                 let method_ty = method.ty;\n-                fcx.inh.method_map.borrow_mut().get().insert(expr.id, method);\n+                let method_call = MethodCall::expr(expr.id);\n+                fcx.inh.method_map.borrow_mut().get().insert(method_call, method);\n                 method_ty\n             }\n             None => {\n@@ -2001,15 +1985,17 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                         unbound_method: ||) -> ty::t {\n         let method = match trait_did {\n             Some(trait_did) => {\n-                method::lookup_in_trait(fcx, op_ex, args[0], opname, trait_did,\n-                                        self_t, [], autoderef_receiver)\n+                method::lookup_in_trait(fcx, op_ex.span, Some(&*args[0]), opname,\n+                                        trait_did, self_t, [], autoderef_receiver)\n             }\n             None => None\n         };\n         match method {\n             Some(method) => {\n                 let method_ty = method.ty;\n-                fcx.inh.method_map.borrow_mut().get().insert(op_ex.id, method);\n+                // HACK(eddyb) Fully qualified path to work around a resolve bug.\n+                let method_call = ::middle::typeck::MethodCall::expr(op_ex.id);\n+                fcx.inh.method_map.borrow_mut().get().insert(method_call, method);\n                 check_method_argument_types(fcx, op_ex.span,\n                                             method_ty, op_ex,\n                                             args, DoDerefArgs)\n@@ -2293,32 +2279,28 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                    field: ast::Name,\n                    tys: &[ast::P<ast::Ty>]) {\n         let tcx = fcx.ccx.tcx;\n-        let bot = check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n+        check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n-        let (base_t, derefs) = do_autoderef(fcx, expr.span, expr_t);\n-\n-        match *structure_of(fcx, expr.span, base_t) {\n-            ty::ty_struct(base_id, ref substs) => {\n-                // This is just for fields -- the same code handles\n-                // methods in both classes and traits\n-\n-                // (1) verify that the class id actually has a field called\n-                // field\n-                debug!(\"class named {}\", ppaux::ty_to_str(tcx, base_t));\n-                let cls_items = ty::lookup_struct_fields(tcx, base_id);\n-                match lookup_field_ty(tcx, base_id, cls_items.as_slice(),\n-                                      field, &(*substs)) {\n-                    Some(field_ty) => {\n-                        // (2) look up what field's type is, and return it\n-                        fcx.write_ty(expr.id, field_ty);\n-                        fcx.write_autoderef_adjustment(base.id, derefs);\n-                        return bot;\n+        // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n+        let (_, autoderefs, field_ty) =\n+            autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n+                match ty::get(base_t).sty {\n+                    ty::ty_struct(base_id, ref substs) => {\n+                        debug!(\"struct named {}\", ppaux::ty_to_str(tcx, base_t));\n+                        let fields = ty::lookup_struct_fields(tcx, base_id);\n+                        lookup_field_ty(tcx, base_id, fields.as_slice(), field, &(*substs))\n                     }\n-                    None => ()\n+                    _ => None\n                 }\n+            });\n+        match field_ty {\n+            Some(field_ty) => {\n+                fcx.write_ty(expr.id, field_ty);\n+                fcx.write_autoderef_adjustment(base.id, autoderefs);\n+                return;\n             }\n-            _ => ()\n+            None => {}\n         }\n \n         let tps: Vec<ty::t> = tys.iter().map(|&ty| fcx.to_ty(ty)).collect();\n@@ -2738,8 +2720,9 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                     oprnd_t = structurally_resolved_type(fcx, expr.span, oprnd_t);\n                     oprnd_t = match ty::deref(oprnd_t, true) {\n                         Some(mt) => mt.ty,\n-                        None => match try_overloaded_deref(fcx, expr, oprnd,\n-                                                           oprnd_t, lvalue_pref) {\n+                        None => match try_overloaded_deref(fcx, expr.span,\n+                                                           Some(MethodCall::expr(expr.id)),\n+                                                           Some(&*oprnd), oprnd_t, lvalue_pref) {\n                             Some(mt) => mt.ty,\n                             None => {\n                                 let is_newtype = match ty::get(oprnd_t).sty {\n@@ -3175,19 +3158,27 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n           } else if ty::type_is_error(idx_t) || ty::type_is_bot(idx_t) {\n               fcx.write_ty(id, idx_t);\n           } else {\n-              let (base_t, derefs) = do_autoderef(fcx, expr.span, raw_base_t);\n-              let base_sty = structure_of(fcx, expr.span, base_t);\n-              match ty::index_sty(base_sty) {\n+              let (base_t, autoderefs, field_ty) =\n+                autoderef(fcx, expr.span, raw_base_t, Some(base.id),\n+                          lvalue_pref, |base_t, _| ty::index(base_t));\n+              match field_ty {\n                   Some(mt) => {\n                       require_integral(fcx, idx.span, idx_t);\n                       fcx.write_ty(id, mt.ty);\n-                      fcx.write_autoderef_adjustment(base.id, derefs);\n+                      fcx.write_autoderef_adjustment(base.id, autoderefs);\n                   }\n                   None => {\n                       let resolved = structurally_resolved_type(fcx,\n                                                                 expr.span,\n                                                                 raw_base_t);\n-                      let error_message = || {\n+                      let ret_ty = lookup_op_method(fcx,\n+                                                    expr,\n+                                                    resolved,\n+                                                    token::intern(\"index\"),\n+                                                    tcx.lang_items.index_trait(),\n+                                                    [base, idx],\n+                                                    AutoderefReceiver,\n+                                                    || {\n                         fcx.type_error_message(expr.span,\n                                                |actual| {\n                                                 format!(\"cannot index a value \\\n@@ -3196,15 +3187,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                },\n                                                base_t,\n                                                None);\n-                      };\n-                      let ret_ty = lookup_op_method(fcx,\n-                                                    expr,\n-                                                    resolved,\n-                                                    token::intern(\"index\"),\n-                                                    tcx.lang_items.index_trait(),\n-                                                    [base, idx],\n-                                                    AutoderefReceiver,\n-                                                    error_message);\n+                      });\n                       fcx.write_ty(id, ret_ty);\n                   }\n               }\n@@ -3732,7 +3715,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n                         nsupplied = num_supplied_regions));\n         }\n \n-        fcx.infcx().region_vars_for_defs(span, tpt.generics.region_param_defs.borrow().as_slice())\n+        fcx.infcx().region_vars_for_defs(span, tpt.generics.region_param_defs.deref().as_slice())\n     };\n     let regions = ty::NonerasedRegions(regions);\n "}, {"sha": "1278bfb2e168f086e526d7873b94ca421ed82faa", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 123, "deletions": 91, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -129,6 +129,7 @@ use middle::typeck::check::regionmanip::relate_nested_regions;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n+use middle::typeck::MethodCall;\n use middle::pat_util;\n use util::ppaux::{ty_to_str, region_to_str, Repr};\n \n@@ -140,6 +141,19 @@ use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+// If mem categorization results in an error, it's because the type\n+// check failed (or will fail, when the error is uncovered and\n+// reported during writeback). In this case, we just ignore this part\n+// of the code and don't try to add any more region constraints.\n+macro_rules! ignore_err(\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(v) => v,\n+            Err(()) => return\n+        }\n+    )\n+)\n+\n pub struct Rcx {\n     fcx: @FnCtxt,\n     errors_reported: uint,\n@@ -221,23 +235,27 @@ impl Rcx {\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_node_type(&mut self, id: ast::NodeId) -> ty::t {\n+    fn resolve_node_type(&mut self, id: ast::NodeId) -> ty::t {\n         let t = self.fcx.node_ty(id);\n         self.resolve_type(t)\n     }\n \n+    fn resolve_method_type(&mut self, method_call: MethodCall) -> Option<ty::t> {\n+        let method_ty = self.fcx.inh.method_map.borrow().get()\n+                            .find(&method_call).map(|method| method.ty);\n+        method_ty.map(|method_ty| self.resolve_type(method_ty))\n+    }\n+\n     /// Try to resolve the type for the given node.\n     pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> ty::t {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n         if ty::type_is_error(ty_unadjusted) || ty::type_is_bot(ty_unadjusted) {\n             ty_unadjusted\n         } else {\n             let tcx = self.fcx.tcx();\n-            let adjustment = {\n-                let adjustments = self.fcx.inh.adjustments.borrow();\n-                adjustments.get().find_copy(&expr.id)\n-            };\n-            ty::adjust_ty(tcx, expr.span, ty_unadjusted, adjustment)\n+            let adjustment = self.fcx.inh.adjustments.borrow().get().find_copy(&expr.id);\n+            ty::adjust_ty(tcx, expr.span, expr.id, ty_unadjusted, adjustment,\n+                          |method_call| self.resolve_method_type(method_call))\n         }\n     }\n }\n@@ -252,10 +270,8 @@ impl<'a> mc::Typer for &'a mut Rcx {\n         if ty::type_is_error(t) {Err(())} else {Ok(t)}\n     }\n \n-    fn node_method_ty(&mut self, id: ast::NodeId) -> Option<ty::t> {\n-        self.fcx.inh.method_map.borrow().get().find(&id).map(|method| {\n-            self.resolve_type(method.ty)\n-        })\n+    fn node_method_ty(&mut self, method_call: MethodCall) -> Option<ty::t> {\n+        self.resolve_method_type(method_call)\n     }\n \n     fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n@@ -264,7 +280,7 @@ impl<'a> mc::Typer for &'a mut Rcx {\n     }\n \n     fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n-        self.fcx.inh.method_map.borrow().get().contains_key(&id)\n+        self.fcx.inh.method_map.borrow().get().contains_key(&MethodCall::expr(id))\n     }\n \n     fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n@@ -383,53 +399,48 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     debug!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n-    let has_method_map = rcx.fcx.inh.method_map.get().contains_key(&expr.id);\n+    let method_call = MethodCall::expr(expr.id);\n+    let has_method_map = rcx.fcx.inh.method_map.get().contains_key(&method_call);\n \n     // Check any autoderefs or autorefs that appear.\n-    {\n-        let adjustments = rcx.fcx.inh.adjustments.borrow();\n-        let r = adjustments.get().find(&expr.id);\n-        for &adjustment in r.iter() {\n-            debug!(\"adjustment={:?}\", adjustment);\n-            match **adjustment {\n-                ty::AutoDerefRef(\n-                    ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n-                {\n-                    let expr_ty = rcx.resolve_node_type(expr.id);\n-                    constrain_derefs(rcx, expr, autoderefs, expr_ty);\n-                    for autoref in opt_autoref.iter() {\n-                        link_autoref(rcx, expr, autoderefs, autoref);\n-\n-                        // Require that the resulting region encompasses\n-                        // the current node.\n-                        //\n-                        // FIXME(#6268) remove to support nested method calls\n-                        constrain_regions_in_type_of_node(\n-                            rcx, expr.id, ty::ReScope(expr.id),\n-                            infer::AutoBorrow(expr.span));\n-                    }\n-                }\n-                ty::AutoObject(ast::BorrowedSigil, Some(trait_region), _, _, _, _) => {\n-                    // Determine if we are casting `expr` to an trait\n-                    // instance.  If so, we have to be sure that the type of\n-                    // the source obeys the trait's region bound.\n+    for &adjustment in rcx.fcx.inh.adjustments.borrow().get().find(&expr.id).iter() {\n+        debug!(\"adjustment={:?}\", adjustment);\n+        match **adjustment {\n+            ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: opt_autoref}) => {\n+                let expr_ty = rcx.resolve_node_type(expr.id);\n+                constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n+                for autoref in opt_autoref.iter() {\n+                    link_autoref(rcx, expr, autoderefs, autoref);\n+\n+                    // Require that the resulting region encompasses\n+                    // the current node.\n                     //\n-                    // Note: there is a subtle point here concerning type\n-                    // parameters.  It is possible that the type of `source`\n-                    // contains type parameters, which in turn may contain\n-                    // regions that are not visible to us (only the caller\n-                    // knows about them).  The kind checker is ultimately\n-                    // responsible for guaranteeing region safety in that\n-                    // particular case.  There is an extensive comment on the\n-                    // function check_cast_for_escaping_regions() in kind.rs\n-                    // explaining how it goes about doing that.\n-\n-                    let source_ty = rcx.fcx.expr_ty(expr);\n-                    constrain_regions_in_type(rcx, trait_region,\n-                                              infer::RelateObjectBound(expr.span), source_ty);\n+                    // FIXME(#6268) remove to support nested method calls\n+                    constrain_regions_in_type_of_node(\n+                        rcx, expr.id, ty::ReScope(expr.id),\n+                        infer::AutoBorrow(expr.span));\n                 }\n-                _ => {}\n             }\n+            ty::AutoObject(ast::BorrowedSigil, Some(trait_region), _, _, _, _) => {\n+                // Determine if we are casting `expr` to an trait\n+                // instance.  If so, we have to be sure that the type of\n+                // the source obeys the trait's region bound.\n+                //\n+                // Note: there is a subtle point here concerning type\n+                // parameters.  It is possible that the type of `source`\n+                // contains type parameters, which in turn may contain\n+                // regions that are not visible to us (only the caller\n+                // knows about them).  The kind checker is ultimately\n+                // responsible for guaranteeing region safety in that\n+                // particular case.  There is an extensive comment on the\n+                // function check_cast_for_escaping_regions() in kind.rs\n+                // explaining how it goes about doing that.\n+\n+                let source_ty = rcx.fcx.expr_ty(expr);\n+                constrain_regions_in_type(rcx, trait_region,\n+                                            infer::RelateObjectBound(expr.span), source_ty);\n+            }\n+            _ => {}\n         }\n     }\n \n@@ -488,14 +499,21 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n         ast::ExprUnary(ast::UnDeref, base) => {\n             // For *a, the lifetime of a must enclose the deref\n-            let base_ty = match rcx.fcx.inh.method_map.get().find(&expr.id) {\n+            let method_call = MethodCall::expr(expr.id);\n+            let base_ty = match rcx.fcx.inh.method_map.get().find(&method_call) {\n                 Some(method) => {\n                     constrain_call(rcx, None, expr, Some(base), [], true);\n                     ty::ty_fn_ret(method.ty)\n                 }\n                 None => rcx.resolve_node_type(base.id)\n             };\n-            constrain_derefs(rcx, expr, 1, base_ty);\n+            match ty::get(base_ty).sty {\n+                ty::ty_rptr(r_ptr, _) => {\n+                    mk_subregion_due_to_dereference(rcx, expr.span,\n+                                                    ty::ReScope(expr.id), r_ptr);\n+                }\n+                _ => {}\n+            }\n \n             visit::walk_expr(rcx, expr, ());\n         }\n@@ -769,7 +787,8 @@ fn constrain_call(rcx: &mut Rcx,\n             implicitly_ref_args);\n     let callee_ty = match fn_expr_id {\n         Some(id) => rcx.resolve_node_type(id),\n-        None => rcx.resolve_type(rcx.fcx.method_ty(call_expr.id))\n+        None => rcx.resolve_method_type(MethodCall::expr(call_expr.id))\n+                   .expect(\"call should have been to a method\")\n     };\n     if ty::type_is_error(callee_ty) {\n         // Bail, as function type is unknown\n@@ -819,29 +838,57 @@ fn constrain_call(rcx: &mut Rcx,\n         fn_sig.output);\n }\n \n-fn constrain_derefs(rcx: &mut Rcx,\n-                    deref_expr: &ast::Expr,\n-                    derefs: uint,\n-                    mut derefd_ty: ty::t)\n-{\n+fn constrain_autoderefs(rcx: &mut Rcx,\n+                        deref_expr: &ast::Expr,\n+                        derefs: uint,\n+                        mut derefd_ty: ty::t) {\n     /*!\n-     * Invoked on any dereference that occurs, whether explicitly\n-     * or through an auto-deref.  Checks that if this is a region\n-     * pointer being derefenced, the lifetime of the pointer includes\n-     * the deref expr.\n+     * Invoked on any auto-dereference that occurs.  Checks that if\n+     * this is a region pointer being dereferenced, the lifetime of\n+     * the pointer includes the deref expr.\n      */\n     let r_deref_expr = ty::ReScope(deref_expr.id);\n     for i in range(0u, derefs) {\n-        debug!(\"constrain_derefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n+        debug!(\"constrain_autoderefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n                rcx.fcx.infcx().ty_to_str(derefd_ty),\n                i, derefs);\n \n+        let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n+        derefd_ty = match rcx.fcx.inh.method_map.get().find(&method_call) {\n+            Some(method) => {\n+                // Treat overloaded autoderefs as if an AutoRef adjustment\n+                // was applied on the base type, as that is always the case.\n+                let fn_sig = ty::ty_fn_sig(method.ty);\n+                let self_ty = *fn_sig.inputs.get(0);\n+                let (m, r) = match ty::get(self_ty).sty {\n+                    ty::ty_rptr(r, ref m) => (m.mutbl, r),\n+                    _ => rcx.tcx().sess.span_bug(deref_expr.span,\n+                            format!(\"bad overloaded deref type {}\",\n+                                method.ty.repr(rcx.tcx())))\n+                };\n+                {\n+                    let mut mc = mc::MemCategorizationContext { typer: &mut *rcx };\n+                    let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n+                    link_region(mc.typer, deref_expr.span, r, m, self_cmt);\n+                }\n+\n+                // Specialized version of constrain_call.\n+                constrain_regions_in_type(rcx, r_deref_expr,\n+                                          infer::CallRcvr(deref_expr.span),\n+                                          self_ty);\n+                constrain_regions_in_type(rcx, r_deref_expr,\n+                                          infer::CallReturn(deref_expr.span),\n+                                          fn_sig.output);\n+                fn_sig.output\n+            }\n+            None => derefd_ty\n+        };\n+\n         match ty::get(derefd_ty).sty {\n             ty::ty_rptr(r_ptr, _) => {\n-                mk_subregion_due_to_derefence(rcx, deref_expr.span,\n-                                              r_deref_expr, r_ptr);\n+                mk_subregion_due_to_dereference(rcx, deref_expr.span,\n+                                                r_deref_expr, r_ptr);\n             }\n-\n             _ => {}\n         }\n \n@@ -854,10 +901,10 @@ fn constrain_derefs(rcx: &mut Rcx,\n     }\n }\n \n-pub fn mk_subregion_due_to_derefence(rcx: &mut Rcx,\n-                                     deref_span: Span,\n-                                     minimum_lifetime: ty::Region,\n-                                     maximum_lifetime: ty::Region) {\n+pub fn mk_subregion_due_to_dereference(rcx: &mut Rcx,\n+                                       deref_span: Span,\n+                                       minimum_lifetime: ty::Region,\n+                                       maximum_lifetime: ty::Region) {\n     rcx.fcx.mk_subr(true, infer::DerefPointer(deref_span),\n                     minimum_lifetime, maximum_lifetime)\n }\n@@ -904,11 +951,9 @@ fn constrain_regions_in_type_of_node(\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n-    let adjustment = {\n-        let adjustments = rcx.fcx.inh.adjustments.borrow();\n-        adjustments.get().find_copy(&id)\n-    };\n-    let ty = ty::adjust_ty(tcx, origin.span(), ty0, adjustment);\n+    let adjustment = rcx.fcx.inh.adjustments.borrow().get().find_copy(&id);\n+    let ty = ty::adjust_ty(tcx, origin.span(), id, ty0, adjustment,\n+                           |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?}, adjustment={:?})\",\n            ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n@@ -967,19 +1012,6 @@ fn constrain_regions_in_type(\n     return e == rcx.errors_reported;\n }\n \n-// If mem categorization results in an error, it's because the type\n-// check failed (or will fail, when the error is uncovered and\n-// reported during writeback). In this case, we just ignore this part\n-// of the code and don't try to add any more region constraints.\n-macro_rules! ignore_err(\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => { v }\n-            Err(()) => { return; }\n-        }\n-    )\n-)\n-\n fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n                mutability: ast::Mutability, base: &ast::Expr) {\n     /*!"}, {"sha": "3fee30bc4988cc93aeed1641304bf9b1a45e475f", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 52, "deletions": 99, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -21,6 +21,7 @@ use middle::typeck::infer;\n use middle::typeck::{vtable_origin, vtable_res, vtable_param_res};\n use middle::typeck::{vtable_static, vtable_param, impl_res};\n use middle::typeck::{param_numbered, param_self, param_index};\n+use middle::typeck::MethodCall;\n use middle::subst::Subst;\n use util::common::indenter;\n use util::ppaux;\n@@ -62,15 +63,6 @@ use syntax::visit::Visitor;\n // It may be better to do something more clever, like processing fully\n // resolved types first.\n \n-\n-/// Location info records the span and ID of the expression or item that is\n-/// responsible for this vtable instantiation. (This may not be an expression\n-/// if the vtable instantiation is being performed as part of \"deriving\".)\n-pub struct LocationInfo {\n-    span: Span,\n-    id: ast::NodeId\n-}\n-\n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n pub struct VtableContext<'a> {\n@@ -88,14 +80,14 @@ fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n }\n \n fn lookup_vtables(vcx: &VtableContext,\n-                  location_info: &LocationInfo,\n+                  span: Span,\n                   type_param_defs: &[ty::TypeParameterDef],\n                   substs: &ty::substs,\n                   is_early: bool) -> vtable_res {\n-    debug!(\"lookup_vtables(location_info={:?}, \\\n+    debug!(\"lookup_vtables(span={:?}, \\\n             type_param_defs={}, \\\n             substs={}\",\n-           location_info,\n+           span,\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()));\n \n@@ -105,26 +97,26 @@ fn lookup_vtables(vcx: &VtableContext,\n         substs.tps.rev_iter()\n         .zip(type_param_defs.rev_iter())\n         .map(|(ty, def)|\n-                   lookup_vtables_for_param(vcx, location_info, Some(substs),\n-                                            &*def.bounds, *ty, is_early))\n+            lookup_vtables_for_param(vcx, span, Some(substs),\n+                                     &*def.bounds, *ty, is_early))\n         .collect();\n     result.reverse();\n \n     assert_eq!(substs.tps.len(), result.len());\n     debug!(\"lookup_vtables result(\\\n-            location_info={:?}, \\\n+            span={:?}, \\\n             type_param_defs={}, \\\n             substs={}, \\\n             result={})\",\n-           location_info,\n+           span,\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()),\n            result.repr(vcx.tcx()));\n     @result\n }\n \n fn lookup_vtables_for_param(vcx: &VtableContext,\n-                            location_info: &LocationInfo,\n+                            span: Span,\n                             // None for substs means the identity\n                             substs: Option<&ty::substs>,\n                             type_param_bounds: &ty::ParamBounds,\n@@ -155,11 +147,10 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n \n         debug!(\"after subst: {}\", trait_ref.repr(tcx));\n \n-        match lookup_vtable(vcx, location_info, ty, trait_ref, is_early) {\n+        match lookup_vtable(vcx, span, ty, trait_ref, is_early) {\n             Some(vtable) => param_result.push(vtable),\n             None => {\n-                vcx.tcx().sess.span_fatal(\n-                    location_info.span,\n+                vcx.tcx().sess.span_fatal(span,\n                     format!(\"failed to find an implementation of \\\n                           trait {} for {}\",\n                          vcx.infcx.trait_ref_to_str(trait_ref),\n@@ -170,11 +161,11 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n     });\n \n     debug!(\"lookup_vtables_for_param result(\\\n-            location_info={:?}, \\\n+            span={:?}, \\\n             type_param_bounds={}, \\\n             ty={}, \\\n             result={})\",\n-           location_info,\n+           span,\n            type_param_bounds.repr(vcx.tcx()),\n            ty.repr(vcx.tcx()),\n            param_result.repr(vcx.tcx()));\n@@ -183,10 +174,9 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n }\n \n fn relate_trait_refs(vcx: &VtableContext,\n-                     location_info: &LocationInfo,\n+                     span: Span,\n                      act_trait_ref: @ty::TraitRef,\n-                     exp_trait_ref: @ty::TraitRef)\n-{\n+                     exp_trait_ref: @ty::TraitRef) {\n     /*!\n      *\n      * Checks that an implementation of `act_trait_ref` is suitable\n@@ -196,10 +186,9 @@ fn relate_trait_refs(vcx: &VtableContext,\n \n     match infer::mk_sub_trait_refs(vcx.infcx,\n                                    false,\n-                                   infer::RelateTraitRefs(location_info.span),\n+                                   infer::RelateTraitRefs(span),\n                                    act_trait_ref,\n-                                   exp_trait_ref)\n-    {\n+                                   exp_trait_ref) {\n         result::Ok(()) => {} // Ok.\n         result::Err(ref err) => {\n             // There is an error, but we need to do some work to make\n@@ -215,8 +204,7 @@ fn relate_trait_refs(vcx: &VtableContext,\n                 !ty::trait_ref_contains_error(&r_exp_trait_ref)\n             {\n                 let tcx = vcx.tcx();\n-                tcx.sess.span_err(\n-                    location_info.span,\n+                tcx.sess.span_err(span,\n                     format!(\"expected {}, but found {} ({})\",\n                          ppaux::trait_ref_to_str(tcx, &r_exp_trait_ref),\n                          ppaux::trait_ref_to_str(tcx, &r_act_trait_ref),\n@@ -228,18 +216,17 @@ fn relate_trait_refs(vcx: &VtableContext,\n \n // Look up the vtable implementing the trait `trait_ref` at type `t`\n fn lookup_vtable(vcx: &VtableContext,\n-                 location_info: &LocationInfo,\n+                 span: Span,\n                  ty: ty::t,\n                  trait_ref: @ty::TraitRef,\n                  is_early: bool)\n-    -> Option<vtable_origin>\n-{\n+                 -> Option<vtable_origin> {\n     debug!(\"lookup_vtable(ty={}, trait_ref={})\",\n            vcx.infcx.ty_to_str(ty),\n            vcx.infcx.trait_ref_to_str(trait_ref));\n     let _i = indenter();\n \n-    let ty = match fixup_ty(vcx, location_info, ty, is_early) {\n+    let ty = match fixup_ty(vcx, span, ty, is_early) {\n         Some(ty) => ty,\n         None => {\n             // fixup_ty can only fail if this is early resolution\n@@ -261,17 +248,15 @@ fn lookup_vtable(vcx: &VtableContext,\n                    .get(n)\n                    .trait_bounds\n                    .as_slice();\n-            lookup_vtable_from_bounds(vcx,\n-                                      location_info,\n+            lookup_vtable_from_bounds(vcx, span,\n                                       type_param_bounds,\n                                       param_numbered(n),\n                                       trait_ref)\n         }\n \n         ty::ty_self(_) => {\n             let self_param_bound = vcx.param_env.self_param_bound.unwrap();\n-            lookup_vtable_from_bounds(vcx,\n-                                      location_info,\n+            lookup_vtable_from_bounds(vcx, span,\n                                       [self_param_bound],\n                                       param_self,\n                                       trait_ref)\n@@ -285,14 +270,13 @@ fn lookup_vtable(vcx: &VtableContext,\n \n     // If we aren't a self type or param, or it was, but we didn't find it,\n     // do a search.\n-    return search_for_vtable(vcx, location_info,\n-                             ty, trait_ref, is_early)\n+    search_for_vtable(vcx, span, ty, trait_ref, is_early)\n }\n \n // Given a list of bounds on a type, search those bounds to see if any\n // of them are the vtable we are looking for.\n fn lookup_vtable_from_bounds(vcx: &VtableContext,\n-                             location_info: &LocationInfo,\n+                             span: Span,\n                              bounds: &[@ty::TraitRef],\n                              param: param_index,\n                              trait_ref: @ty::TraitRef)\n@@ -306,10 +290,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n                bound_trait_ref.repr(vcx.tcx()));\n \n         if bound_trait_ref.def_id == trait_ref.def_id {\n-            relate_trait_refs(vcx,\n-                              location_info,\n-                              bound_trait_ref,\n-                              trait_ref);\n+            relate_trait_refs(vcx, span, bound_trait_ref, trait_ref);\n             let vtable = vtable_param(param, n_bound);\n             debug!(\"found param vtable: {:?}\",\n                    vtable);\n@@ -324,7 +305,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n }\n \n fn search_for_vtable(vcx: &VtableContext,\n-                     location_info: &LocationInfo,\n+                     span: Span,\n                      ty: ty::t,\n                      trait_ref: @ty::TraitRef,\n                      is_early: bool)\n@@ -385,11 +366,10 @@ fn search_for_vtable(vcx: &VtableContext,\n         let ty::ty_param_substs_and_ty {\n             substs: substs,\n             ty: for_ty\n-        } = impl_self_ty(vcx, location_info, im.did);\n+        } = impl_self_ty(vcx, span, im.did);\n         match infer::mk_subty(vcx.infcx,\n                               false,\n-                              infer::RelateSelfType(\n-                                  location_info.span),\n+                              infer::RelateSelfType(span),\n                               ty,\n                               for_ty) {\n             result::Err(_) => continue,\n@@ -418,7 +398,7 @@ fn search_for_vtable(vcx: &VtableContext,\n                vcx.infcx.trait_ref_to_str(of_trait_ref));\n \n         let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n-        relate_trait_refs(vcx, location_info, of_trait_ref, trait_ref);\n+        relate_trait_refs(vcx, span, of_trait_ref, trait_ref);\n \n \n         // Recall that trait_ref -- the trait type we're casting to --\n@@ -430,15 +410,14 @@ fn search_for_vtable(vcx: &VtableContext,\n         // process of looking up bounds might constrain some of them.\n         let im_generics =\n             ty::lookup_item_type(tcx, im.did).generics;\n-        let subres = lookup_vtables(vcx, location_info,\n+        let subres = lookup_vtables(vcx, span,\n                                     im_generics.type_param_defs(), &substs,\n                                     is_early);\n \n \n         // substs might contain type variables, so we call\n         // fixup_substs to resolve them.\n-        let substs_f = match fixup_substs(vcx,\n-                                          location_info,\n+        let substs_f = match fixup_substs(vcx, span,\n                                           trait_ref.def_id,\n                                           substs,\n                                           is_early) {\n@@ -463,7 +442,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         // I am a little confused about this, since it seems to be\n         // very similar to the relate_trait_refs we already do,\n         // but problems crop up if it is removed, so... -sully\n-        connect_trait_tps(vcx, location_info, &substs_f, trait_ref, im.did);\n+        connect_trait_tps(vcx, span, &substs_f, trait_ref, im.did);\n \n         // Finally, we register that we found a matching impl, and\n         // record the def ID of the impl as well as the resolved list\n@@ -476,9 +455,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         1 => return Some(found.get(0).clone()),\n         _ => {\n             if !is_early {\n-                vcx.tcx().sess.span_err(\n-                    location_info.span,\n-                    \"multiple applicable methods in scope\");\n+                vcx.tcx().sess.span_err(span, \"multiple applicable methods in scope\");\n             }\n             return Some(found.get(0).clone());\n         }\n@@ -487,7 +464,7 @@ fn search_for_vtable(vcx: &VtableContext,\n \n \n fn fixup_substs(vcx: &VtableContext,\n-                location_info: &LocationInfo,\n+                span: Span,\n                 id: ast::DefId,\n                 substs: ty::substs,\n                 is_early: bool)\n@@ -499,7 +476,7 @@ fn fixup_substs(vcx: &VtableContext,\n                          ty::RegionTraitStore(ty::ReStatic),\n                          ast::MutImmutable,\n                          ty::EmptyBuiltinBounds());\n-    fixup_ty(vcx, location_info, t, is_early).map(|t_f| {\n+    fixup_ty(vcx, span, t, is_early).map(|t_f| {\n         match ty::get(t_f).sty {\n           ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n           _ => fail!(\"t_f should be a trait\")\n@@ -508,16 +485,15 @@ fn fixup_substs(vcx: &VtableContext,\n }\n \n fn fixup_ty(vcx: &VtableContext,\n-            location_info: &LocationInfo,\n+            span: Span,\n             ty: ty::t,\n             is_early: bool)\n             -> Option<ty::t> {\n     let tcx = vcx.tcx();\n     match resolve_type(vcx.infcx, ty, resolve_and_force_all_but_regions) {\n         Ok(new_type) => Some(new_type),\n         Err(e) if !is_early => {\n-            tcx.sess.span_fatal(\n-                location_info.span,\n+            tcx.sess.span_fatal(span,\n                 format!(\"cannot determine a type \\\n                       for this bounded type parameter: {}\",\n                      fixup_err_to_str(e)))\n@@ -529,20 +505,20 @@ fn fixup_ty(vcx: &VtableContext,\n }\n \n fn connect_trait_tps(vcx: &VtableContext,\n-                     location_info: &LocationInfo,\n+                     span: Span,\n                      impl_substs: &ty::substs,\n                      trait_ref: @ty::TraitRef,\n                      impl_did: ast::DefId) {\n     let tcx = vcx.tcx();\n \n     let impl_trait_ref = match ty::impl_trait_ref(tcx, impl_did) {\n         Some(t) => t,\n-        None => vcx.tcx().sess.span_bug(location_info.span,\n+        None => vcx.tcx().sess.span_bug(span,\n                                   \"connect_trait_tps invoked on a type impl\")\n     };\n \n     let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n-    relate_trait_refs(vcx, location_info, impl_trait_ref, trait_ref);\n+    relate_trait_refs(vcx, span, impl_trait_ref, trait_ref);\n }\n \n fn insert_vtables(fcx: &FnCtxt, expr_id: ast::NodeId, vtables: vtable_res) {\n@@ -551,19 +527,6 @@ fn insert_vtables(fcx: &FnCtxt, expr_id: ast::NodeId, vtables: vtable_res) {\n     fcx.inh.vtable_map.borrow_mut().get().insert(expr_id, vtables);\n }\n \n-pub fn location_info_for_expr(expr: &ast::Expr) -> LocationInfo {\n-    LocationInfo {\n-        span: expr.span,\n-        id: expr.id\n-    }\n-}\n-pub fn location_info_for_item(item: &ast::Item) -> LocationInfo {\n-    LocationInfo {\n-        span: item.span,\n-        id: item.id\n-    }\n-}\n-\n pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n            ex.id, is_early, expr_to_str(ex));\n@@ -608,8 +571,6 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                         _ => fail!(\"shouldn't get here\"),\n                     };\n \n-                      let location_info =\n-                          &location_info_for_expr(ex);\n                       let vcx = fcx.vtable_context();\n                       let target_trait_ref = @ty::TraitRef {\n                           def_id: target_def_id,\n@@ -626,7 +587,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                       };\n                       let vtables =\n                             lookup_vtables_for_param(&vcx,\n-                                                     location_info,\n+                                                     ex.span,\n                                                      None,\n                                                      &param_bounds,\n                                                      typ,\n@@ -687,7 +648,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                 debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n                        item_ty.generics.type_param_defs().repr(fcx.tcx()));\n                 let vcx = fcx.vtable_context();\n-                let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n+                let vtbls = lookup_vtables(&vcx, ex.span,\n                                            item_ty.generics.type_param_defs(),\n                                            substs, is_early);\n                 if !is_early {\n@@ -704,20 +665,18 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n       ast::ExprAssignOp(_, _, _) |\n       ast::ExprIndex(_, _) |\n       ast::ExprMethodCall(_, _, _) => {\n-        match fcx.inh.method_map.borrow().get().find(&ex.id) {\n+        match fcx.inh.method_map.borrow().get().find(&MethodCall::expr(ex.id)) {\n           Some(method) => {\n             debug!(\"vtable resolution on parameter bounds for method call {}\",\n                    ex.repr(fcx.tcx()));\n             let type_param_defs = ty::method_call_type_param_defs(cx.tcx, method.origin);\n-            if has_trait_bounds(type_param_defs.borrow().as_slice()) {\n+            if has_trait_bounds(type_param_defs.deref().as_slice()) {\n                 let substs = fcx.method_ty_substs(ex.id);\n                 let vcx = fcx.vtable_context();\n-                let vtbls = lookup_vtables(&vcx,\n-                                           &location_info_for_expr(ex),\n-                                           type_param_defs.borrow()\n+                let vtbls = lookup_vtables(&vcx, ex.span,\n+                                           type_param_defs.deref()\n                                                           .as_slice(),\n-                                           &substs,\n-                                           is_early);\n+                                           &substs, is_early);\n                 if !is_early {\n                     insert_vtables(fcx, ex.id, vtbls);\n                 }\n@@ -784,13 +743,11 @@ pub fn resolve_impl(tcx: ty::ctxt,\n \n     let infcx = &infer::new_infer_ctxt(tcx);\n     let vcx = VtableContext { infcx: infcx, param_env: &param_env };\n-    let loc_info = location_info_for_item(impl_item);\n \n     // First, check that the impl implements any trait bounds\n     // on the trait.\n     let trait_def = ty::lookup_trait_def(tcx, impl_trait_ref.def_id);\n-    let vtbls = lookup_vtables(&vcx,\n-                               &loc_info,\n+    let vtbls = lookup_vtables(&vcx, impl_item.span,\n                                trait_def.generics.type_param_defs(),\n                                &impl_trait_ref.substs,\n                                false);\n@@ -810,7 +767,7 @@ pub fn resolve_impl(tcx: ty::ctxt,\n     // We will need to make one so we can use this information\n     // for compiling default methods that refer to supertraits.\n     let self_vtable_res =\n-        lookup_vtables_for_param(&vcx, &loc_info, None,\n+        lookup_vtables_for_param(&vcx, impl_item.span, None,\n                                  &param_bounds, t, false);\n \n \n@@ -829,19 +786,15 @@ pub fn resolve_impl(tcx: ty::ctxt,\n pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n                             substs: &ty::substs) -> Option<vtable_res> {\n     let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n-    let type_param_defs = generics.type_param_defs.borrow();\n+    let type_param_defs = generics.type_param_defs.deref();\n     if has_trait_bounds(type_param_defs.as_slice()) {\n         let vcx = VtableContext {\n             infcx: &infer::new_infer_ctxt(tcx),\n             param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], [], id)\n         };\n-        let loc_info = LocationInfo {\n-            id: id,\n-            span: tcx.map.span(id)\n-        };\n \n         Some(lookup_vtables(&vcx,\n-                            &loc_info,\n+                            tcx.map.span(id),\n                             type_param_defs.as_slice(),\n                             substs,\n                             false))"}, {"sha": "7659842aff4119e3b4055fcf3c6cf081ed1e992f", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -20,7 +20,7 @@ use middle::typeck::check::FnCtxt;\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n-use middle::typeck::MethodCallee;\n+use middle::typeck::{MethodCall, MethodCallee};\n use middle::typeck::{vtable_res, vtable_origin};\n use middle::typeck::{vtable_static, vtable_param};\n use middle::typeck::write_substs_to_tcx;\n@@ -63,15 +63,15 @@ fn resolve_type_vars_in_types(fcx: @FnCtxt, sp: Span, tys: &[ty::t])\n     }).collect()\n }\n \n-fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n+fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, method_call: MethodCall) {\n     let fcx = wbcx.fcx;\n     let tcx = fcx.ccx.tcx;\n \n     // Resolve any method map entry\n-    match fcx.inh.method_map.borrow().get().find(&id) {\n+    match fcx.inh.method_map.borrow().get().find(&method_call) {\n         Some(method) => {\n-            debug!(\"writeback::resolve_method_map_entry(id={:?}, entry={:?})\",\n-                   id, method.repr(tcx));\n+            debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n+                   method_call, method.repr(tcx));\n             let method_ty = match resolve_type_vars_in_type(fcx, sp, method.ty) {\n                 Some(t) => t,\n                 None => {\n@@ -95,7 +95,7 @@ fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n                     self_ty: None\n                 }\n             };\n-            fcx.ccx.method_map.borrow_mut().get().insert(id, new_method);\n+            fcx.ccx.method_map.borrow_mut().get().insert(method_call, new_method);\n         }\n         None => {}\n     }\n@@ -142,10 +142,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n     let tcx = fcx.ccx.tcx;\n \n     // Resolve any borrowings for the node with id `id`\n-    let adjustment = {\n-        let adjustments = fcx.inh.adjustments.borrow();\n-        adjustments.get().find_copy(&id)\n-    };\n+    let adjustment = fcx.inh.adjustments.borrow().get().find_copy(&id);\n     match adjustment {\n         None => (),\n \n@@ -167,30 +164,29 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                             // FIXME(eddyb) #2190 Allow only statically resolved\n                             // bare functions to coerce to a closure to avoid\n                             // constructing (slower) indirect call wrappers.\n-                            {\n-                                let def_map = tcx.def_map.borrow();\n-                                match def_map.get().find(&id) {\n-                                    Some(&ast::DefFn(..)) |\n-                                    Some(&ast::DefStaticMethod(..)) |\n-                                    Some(&ast::DefVariant(..)) |\n-                                    Some(&ast::DefStruct(_)) => {}\n-                                    _ => tcx.sess.span_err(sp,\n-                                            \"cannot coerce non-statically resolved bare fn\")\n-                                }\n+                            match tcx.def_map.borrow().get().find(&id) {\n+                                Some(&ast::DefFn(..)) |\n+                                Some(&ast::DefStaticMethod(..)) |\n+                                Some(&ast::DefVariant(..)) |\n+                                Some(&ast::DefStruct(_)) => {}\n+                                _ => tcx.sess.span_err(sp,\n+                                        \"cannot coerce non-statically resolved bare fn\")\n                             }\n \n                             let resolved_adj = @ty::AutoAddEnv(r1, s);\n                             debug!(\"Adjustments for node {}: {:?}\",\n-                                   id,\n-                                   resolved_adj);\n-                            let mut adjustments = tcx.adjustments\n-                                                     .borrow_mut();\n-                            adjustments.get().insert(id, resolved_adj);\n+                                   id, resolved_adj);\n+                            tcx.adjustments.borrow_mut().get().insert(id, resolved_adj);\n                         }\n                     }\n                 }\n \n                 ty::AutoDerefRef(adj) => {\n+                    for autoderef in range(0, adj.autoderefs) {\n+                        let method_call = MethodCall::autoderef(id, autoderef as u32);\n+                        resolve_method_map_entry(wbcx, sp, method_call);\n+                    }\n+\n                     let fixup_region = |r| {\n                         match resolve_region(fcx.infcx(),\n                                              r,\n@@ -218,14 +214,12 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                         autoref: resolved_autoref,\n                     });\n                     debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n-                    let mut adjustments = tcx.adjustments.borrow_mut();\n-                    adjustments.get().insert(id, resolved_adj);\n+                    tcx.adjustments.borrow_mut().get().insert(id, resolved_adj);\n                 }\n \n                 ty::AutoObject(..) => {\n                     debug!(\"Adjustments for node {}: {:?}\", id, adjustment);\n-                    let mut adjustments = tcx.adjustments.borrow_mut();\n-                    adjustments.get().insert(id, adjustment);\n+                    tcx.adjustments.borrow_mut().get().insert(id, adjustment);\n                 }\n             }\n         }\n@@ -280,7 +274,7 @@ fn visit_expr(e: &ast::Expr, wbcx: &mut WbCtxt) {\n     }\n \n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n-    resolve_method_map_entry(wbcx, e.span, e.id);\n+    resolve_method_map_entry(wbcx, e.span, MethodCall::expr(e.id));\n     resolve_vtable_map_entry(wbcx.fcx, e.span, e.id);\n \n     match e.node {"}, {"sha": "402f06f928ccef54637f7bd02b365c7714322de6", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -342,7 +342,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let mut new_type_param_defs = Vec::new();\n         let substd_type_param_defs =\n             trait_ty_generics.type_param_defs.subst(tcx, &substs);\n-        new_type_param_defs.push_all(substd_type_param_defs.borrow()\n+        new_type_param_defs.push_all(substd_type_param_defs.deref()\n                                                            .as_slice());\n \n         // add in the \"self\" type parameter\n@@ -360,7 +360,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n \n         // add in the type parameters from the method\n         let substd_type_param_defs = m.generics.type_param_defs.subst(tcx, &substs);\n-        new_type_param_defs.push_all(substd_type_param_defs.borrow()\n+        new_type_param_defs.push_all(substd_type_param_defs.deref()\n                                                            .as_slice());\n \n         debug!(\"static method {} type_param_defs={} ty={}, substs={}\","}, {"sha": "726f89048984c9f9f8954f89a6075158407febe1", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -68,7 +68,7 @@ use middle::ty;\n use util::common::time;\n use util::ppaux::Repr;\n use util::ppaux;\n-use util::nodemap::{DefIdMap, NodeMap};\n+use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -149,9 +149,31 @@ pub struct MethodCallee {\n     substs: ty::substs\n }\n \n+#[deriving(Clone, Eq, Hash)]\n+pub struct MethodCall {\n+    expr_id: ast::NodeId,\n+    autoderef: u32\n+}\n+\n+impl MethodCall {\n+    pub fn expr(id: ast::NodeId) -> MethodCall {\n+        MethodCall {\n+            expr_id: id,\n+            autoderef: 0\n+        }\n+    }\n+\n+    pub fn autoderef(expr_id: ast::NodeId, autoderef: u32) -> MethodCall {\n+        MethodCall {\n+            expr_id: expr_id,\n+            autoderef: 1 + autoderef\n+        }\n+    }\n+}\n+\n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap = @RefCell<NodeMap<MethodCallee>>;\n+pub type MethodMap = @RefCell<FnvHashMap<MethodCall, MethodCallee>>;\n \n pub type vtable_param_res = @Vec<vtable_origin> ;\n // Resolutions for bounds of all parameters, left to right, for a given path.\n@@ -442,7 +464,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     let time_passes = tcx.sess.time_passes();\n     let ccx = @CrateCtxt {\n         trait_map: trait_map,\n-        method_map: @RefCell::new(NodeMap::new()),\n+        method_map: @RefCell::new(FnvHashMap::new()),\n         vtable_map: @RefCell::new(NodeMap::new()),\n         tcx: tcx\n     };"}, {"sha": "7507fd579ebc174e02a5a0e592cf45bb230281a9", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -16,22 +16,35 @@ use std::io;\n use syntax::ast;\n \n #[cfg(not(stage0))]\n-pub type NodeMap<T> = HashMap<ast::NodeId, T, FnvHasher>;\n-#[cfg(not(stage0))]\n-pub type DefIdMap<T> = HashMap<ast::DefId, T, FnvHasher>;\n+pub type FnvHashMap<K, V> = HashMap<K, V, FnvHasher>;\n+\n+pub type NodeMap<T> = FnvHashMap<ast::NodeId, T>;\n+pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n+\n #[cfg(not(stage0))]\n pub type NodeSet = HashSet<ast::NodeId, FnvHasher>;\n #[cfg(not(stage0))]\n pub type DefIdSet = HashSet<ast::DefId, FnvHasher>;\n \n // Hacks to get good names\n #[cfg(not(stage0))]\n-pub mod NodeMap {\n+pub mod FnvHashMap {\n+    use std::hash::Hash;\n     use collections::HashMap;\n-    pub fn new<T>() -> super::NodeMap<T> {\n+    pub fn new<K: Hash<super::FnvState> + Eq, V>() -> super::FnvHashMap<K, V> {\n         HashMap::with_hasher(super::FnvHasher)\n     }\n }\n+pub mod NodeMap {\n+    pub fn new<T>() -> super::NodeMap<T> {\n+        super::FnvHashMap::new()\n+    }\n+}\n+pub mod DefIdMap {\n+    pub fn new<T>() -> super::DefIdMap<T> {\n+        super::FnvHashMap::new()\n+    }\n+}\n #[cfg(not(stage0))]\n pub mod NodeSet {\n     use collections::HashSet;\n@@ -40,13 +53,6 @@ pub mod NodeSet {\n     }\n }\n #[cfg(not(stage0))]\n-pub mod DefIdMap {\n-    use collections::HashMap;\n-    pub fn new<T>() -> super::DefIdMap<T> {\n-        HashMap::with_hasher(super::FnvHasher)\n-    }\n-}\n-#[cfg(not(stage0))]\n pub mod DefIdSet {\n     use collections::HashSet;\n     pub fn new() -> super::DefIdSet {\n@@ -55,19 +61,19 @@ pub mod DefIdSet {\n }\n \n #[cfg(stage0)]\n-pub type NodeMap<T> = HashMap<ast::NodeId, T>;\n-#[cfg(stage0)]\n-pub type DefIdMap<T> = HashMap<ast::DefId, T>;\n+pub type FnvHashMap<K, V> = HashMap<K, V>;\n+\n #[cfg(stage0)]\n pub type NodeSet = HashSet<ast::NodeId>;\n #[cfg(stage0)]\n pub type DefIdSet = HashSet<ast::DefId>;\n \n // Hacks to get good names\n #[cfg(stage0)]\n-pub mod NodeMap {\n+pub mod FnvHashMap {\n+    use std::hash::Hash;\n     use collections::HashMap;\n-    pub fn new<T>() -> super::NodeMap<T> {\n+    pub fn new<K: Hash + Eq, V>() -> super::FnvHashMap<K, V> {\n         HashMap::new()\n     }\n }\n@@ -79,13 +85,6 @@ pub mod NodeSet {\n     }\n }\n #[cfg(stage0)]\n-pub mod DefIdMap {\n-    use collections::HashMap;\n-    pub fn new<T>() -> super::DefIdMap<T> {\n-        HashMap::new()\n-    }\n-}\n-#[cfg(stage0)]\n pub mod DefIdSet {\n     use collections::HashSet;\n     pub fn new() -> super::DefIdSet {"}, {"sha": "c27725fd5852aeccebbef9a2501565e276059489", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -1192,7 +1192,7 @@ impl ToSource for syntax::codemap::Span {\n fn lit_to_str(lit: &ast::Lit) -> ~str {\n     match lit.node {\n         ast::LitStr(ref st, _) => st.get().to_owned(),\n-        ast::LitBinary(ref data) => format!(\"{:?}\", data.borrow().as_slice()),\n+        ast::LitBinary(ref data) => format!(\"{:?}\", data.deref().as_slice()),\n         ast::LitChar(c) => ~\"'\" + std::char::from_u32(c).unwrap().to_str() + \"'\",\n         ast::LitInt(i, _t) => i.to_str(),\n         ast::LitUint(u, _t) => u.to_str(),"}, {"sha": "a6c0a7b829ae94cdb993eda966090d2fe227616e", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -113,7 +113,7 @@ mod test {\n         fn call(&mut self) {\n             let task = match *self {\n                 MyCallback(ref rc, n) => {\n-                    let mut slot = rc.borrow().borrow_mut();\n+                    let mut slot = rc.deref().borrow_mut();\n                     match *slot.get() {\n                         (ref mut task, ref mut val) => {\n                             *val = n;\n@@ -140,7 +140,7 @@ mod test {\n     fn sleep(chan: &Chan) -> uint {\n         let task: ~Task = Local::take();\n         task.deschedule(1, |task| {\n-            let mut slot = chan.borrow().borrow_mut();\n+            let mut slot = chan.deref().borrow_mut();\n             match *slot.get() {\n                 (ref mut slot, _) => {\n                     assert!(slot.is_none());\n@@ -150,7 +150,7 @@ mod test {\n             Ok(())\n         });\n \n-        let slot = chan.borrow().borrow();\n+        let slot = chan.deref().borrow();\n         match *slot.get() { (_, n) => n }\n     }\n "}, {"sha": "fd57f47e8819d546cf02d78d049bd1e1db8c8684", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -388,7 +388,7 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for Rc<T> {\n     #[inline]\n     fn encode(&self, s: &mut S) {\n-        self.borrow().encode(s)\n+        self.deref().encode(s)\n     }\n }\n "}, {"sha": "dd40f6008735f0d228c7599eb14d8a0bbcde2f71", "filename": "src/libstd/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -66,6 +66,7 @@\n use container::Container;\n use io::Writer;\n use iter::Iterator;\n+use ops::Deref;\n use option::{Option, Some, None};\n use rc::Rc;\n use str::{Str, StrSlice};\n@@ -246,7 +247,7 @@ impl<S: Writer, T: Hash<S>> Hash<S> for @T {\n impl<S: Writer, T: Hash<S>> Hash<S> for Rc<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n-        self.borrow().hash(state);\n+        self.deref().hash(state);\n     }\n }\n "}, {"sha": "31605ca961e6ac1de5b761dc2642fa688dee84cb", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -503,7 +503,7 @@ mod tests {\n         #[unsafe_destructor]\n         impl ::ops::Drop for R {\n            fn drop(&mut self) {\n-                let ii = self.i.borrow();\n+                let ii = self.i.deref();\n                 ii.set(ii.get() + 1);\n             }\n         }\n@@ -520,7 +520,7 @@ mod tests {\n             let opt = Some(x);\n             let _y = opt.unwrap();\n         }\n-        assert_eq!(i.borrow().get(), 1);\n+        assert_eq!(i.deref().get(), 1);\n     }\n \n     #[test]"}, {"sha": "5c4b19b4e4b8c8c347828edb1a7e30989bc0b9ac", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -63,12 +63,6 @@ impl<T> Rc<T> {\n }\n \n impl<T> Rc<T> {\n-    /// Borrow the value contained in the reference-counted box\n-    #[inline(always)]\n-    pub fn borrow<'a>(&'a self) -> &'a T {\n-        unsafe { &(*self.ptr).value }\n-    }\n-\n     /// Downgrade the reference-counted pointer to a weak reference\n     pub fn downgrade(&self) -> Weak<T> {\n         unsafe {\n@@ -93,7 +87,7 @@ impl<T> Drop for Rc<T> {\n             if self.ptr != 0 as *mut RcBox<T> {\n                 (*self.ptr).strong -= 1;\n                 if (*self.ptr).strong == 0 {\n-                    ptr::read(self.borrow()); // destroy the contained object\n+                    ptr::read(self.deref()); // destroy the contained object\n \n                     // remove the implicit \"strong weak\" pointer now\n                     // that we've destroyed the contents.\n@@ -120,24 +114,24 @@ impl<T> Clone for Rc<T> {\n \n impl<T: Eq> Eq for Rc<T> {\n     #[inline(always)]\n-    fn eq(&self, other: &Rc<T>) -> bool { *self.borrow() == *other.borrow() }\n+    fn eq(&self, other: &Rc<T>) -> bool { *self.deref() == *other.deref() }\n \n     #[inline(always)]\n-    fn ne(&self, other: &Rc<T>) -> bool { *self.borrow() != *other.borrow() }\n+    fn ne(&self, other: &Rc<T>) -> bool { *self.deref() != *other.deref() }\n }\n \n impl<T: Ord> Ord for Rc<T> {\n     #[inline(always)]\n-    fn lt(&self, other: &Rc<T>) -> bool { *self.borrow() < *other.borrow() }\n+    fn lt(&self, other: &Rc<T>) -> bool { *self.deref() < *other.deref() }\n \n     #[inline(always)]\n-    fn le(&self, other: &Rc<T>) -> bool { *self.borrow() <= *other.borrow() }\n+    fn le(&self, other: &Rc<T>) -> bool { *self.deref() <= *other.deref() }\n \n     #[inline(always)]\n-    fn gt(&self, other: &Rc<T>) -> bool { *self.borrow() > *other.borrow() }\n+    fn gt(&self, other: &Rc<T>) -> bool { *self.deref() > *other.deref() }\n \n     #[inline(always)]\n-    fn ge(&self, other: &Rc<T>) -> bool { *self.borrow() >= *other.borrow() }\n+    fn ge(&self, other: &Rc<T>) -> bool { *self.deref() >= *other.deref() }\n }\n \n /// Weak reference to a reference-counted box\n@@ -197,30 +191,30 @@ mod tests {\n     fn test_clone() {\n         let x = Rc::new(RefCell::new(5));\n         let y = x.clone();\n-        x.borrow().with_mut(|inner| {\n+        x.deref().with_mut(|inner| {\n             *inner = 20;\n         });\n-        assert_eq!(y.borrow().with(|v| *v), 20);\n+        assert_eq!(y.deref().with(|v| *v), 20);\n     }\n \n     #[test]\n     fn test_simple() {\n         let x = Rc::new(5);\n-        assert_eq!(*x.borrow(), 5);\n+        assert_eq!(*x.deref(), 5);\n     }\n \n     #[test]\n     fn test_simple_clone() {\n         let x = Rc::new(5);\n         let y = x.clone();\n-        assert_eq!(*x.borrow(), 5);\n-        assert_eq!(*y.borrow(), 5);\n+        assert_eq!(*x.deref(), 5);\n+        assert_eq!(*y.deref(), 5);\n     }\n \n     #[test]\n     fn test_destructor() {\n         let x = Rc::new(~5);\n-        assert_eq!(**x.borrow(), 5);\n+        assert_eq!(**x.deref(), 5);\n     }\n \n     #[test]\n@@ -243,7 +237,7 @@ mod tests {\n         // see issue #11532\n         use gc::Gc;\n         let a = Rc::new(RefCell::new(Gc::new(1)));\n-        assert!(a.borrow().try_borrow_mut().is_some());\n+        assert!(a.deref().try_borrow_mut().is_some());\n     }\n \n     #[test]\n@@ -254,7 +248,7 @@ mod tests {\n \n         let a = Rc::new(Cycle { x: RefCell::new(None) });\n         let b = a.clone().downgrade();\n-        *a.borrow().x.borrow_mut().get() = Some(b);\n+        *a.deref().x.borrow_mut().get() = Some(b);\n \n         // hopefully we don't double-free (or leak)...\n     }"}, {"sha": "7fef6da560783c3b5327e3888b9e99d5d28c4982", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -354,7 +354,7 @@ pub enum Pat_ {\n     PatVec(Vec<@Pat> , Option<@Pat>, Vec<@Pat> )\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Mutability {\n     MutMutable,\n     MutImmutable,"}, {"sha": "b7fad22a7ad94ed7a6bd2f04e4c19f7fff68c7db", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -103,7 +103,7 @@ pub fn with_sctable<T>(op: |&SCTable| -> T) -> T {\n             }\n             Some(ts) => ts.clone()\n         };\n-        op(table.borrow())\n+        op(table.deref())\n     })\n }\n \n@@ -158,7 +158,7 @@ fn with_resolve_table_mut<T>(op: |&mut ResolveTable| -> T) -> T {\n             }\n             Some(ts) => ts.clone()\n         };\n-        op(table.borrow().borrow_mut().get())\n+        op(table.deref().borrow_mut().get())\n     })\n }\n "}, {"sha": "6894d6a2b053736a764a9ee2fe38df9db4d25eef", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -2291,7 +2291,7 @@ pub fn print_literal(s: &mut State, lit: &ast::Lit) -> io::IoResult<()> {\n       ast::LitBinary(ref arr) => {\n         try!(ibox(s, indent_unit));\n         try!(word(&mut s.s, \"[\"));\n-        try!(commasep_cmnt(s, Inconsistent, arr.borrow().as_slice(),\n+        try!(commasep_cmnt(s, Inconsistent, arr.deref().as_slice(),\n                              |s, u| word(&mut s.s, format!(\"{}\", *u)),\n                              |_| lit.span));\n         try!(word(&mut s.s, \"]\"));"}, {"sha": "969c7cec87ccea623ffe595a6b93eb5eade6427f", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -106,13 +106,13 @@ impl TotalOrd for RcStr {\n impl Str for RcStr {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n-        let s: &'a str = *self.string.borrow();\n+        let s: &'a str = *self.string.deref();\n         s\n     }\n \n     #[inline]\n     fn into_owned(self) -> ~str {\n-        self.string.borrow().to_owned()\n+        self.string.deref().to_owned()\n     }\n }\n "}, {"sha": "e43ac98aa98027cab58e0ef603393af5b380510f", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-auto-deref-mut.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -0,0 +1,151 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test how overloaded deref interacts with borrows when DerefMut\n+// is implemented.\n+\n+use std::ops::{Deref, DerefMut};\n+\n+struct Own<T> {\n+    value: *mut T\n+}\n+\n+impl<T> Deref<T> for Own<T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        unsafe { &*self.value }\n+    }\n+}\n+\n+impl<T> DerefMut<T> for Own<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+        unsafe { &mut *self.value }\n+    }\n+}\n+\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+impl Point {\n+    fn get(&self) -> (int, int) {\n+        (self.x, self.y)\n+    }\n+\n+    fn set(&mut self, x: int, y: int) {\n+        self.x = x;\n+        self.y = y;\n+    }\n+\n+    fn x_ref<'a>(&'a self) -> &'a int {\n+        &self.x\n+    }\n+\n+    fn y_mut<'a>(&'a mut self) -> &'a mut int {\n+        &mut self.y\n+    }\n+}\n+\n+fn deref_imm_field(x: Own<Point>) {\n+    let _i = &x.y;\n+}\n+\n+fn deref_mut_field1(x: Own<Point>) {\n+    let _i = &mut x.y; //~ ERROR cannot borrow\n+}\n+\n+fn deref_mut_field2(mut x: Own<Point>) {\n+    let _i = &mut x.y;\n+}\n+\n+fn deref_extend_field<'a>(x: &'a Own<Point>) -> &'a int {\n+    &x.y\n+}\n+\n+fn deref_extend_mut_field1<'a>(x: &'a Own<Point>) -> &'a mut int {\n+    &mut x.y //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_mut_field2<'a>(x: &'a mut Own<Point>) -> &'a mut int {\n+    &mut x.y\n+}\n+\n+fn deref_extend_mut_field3<'a>(x: &'a mut Own<Point>) {\n+    // Hmm, this is unfortunate, because with ~ it would work,\n+    // but it's presently the expected outcome. See `deref_extend_mut_field4`\n+    // for the workaround.\n+\n+    let _x = &mut x.x;\n+    let _y = &mut x.y; //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_mut_field4<'a>(x: &'a mut Own<Point>) {\n+    let p = &mut **x;\n+    let _x = &mut p.x;\n+    let _y = &mut p.y;\n+}\n+\n+fn assign_field1<'a>(x: Own<Point>) {\n+    x.y = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign_field2<'a>(x: &'a Own<Point>) {\n+    x.y = 3; //~ ERROR cannot assign\n+}\n+\n+fn assign_field3<'a>(x: &'a mut Own<Point>) {\n+    x.y = 3;\n+}\n+\n+fn assign_field4<'a>(x: &'a mut Own<Point>) {\n+    let _p: &mut Point = &mut **x;\n+    x.y = 3; //~ ERROR cannot borrow\n+}\n+\n+// FIXME(eddyb) #12825 This shouldn't attempt to call deref_mut.\n+/*\n+fn deref_imm_method(x: Own<Point>) {\n+    let _i = x.get();\n+}\n+*/\n+\n+fn deref_mut_method1(x: Own<Point>) {\n+    x.set(0, 0); //~ ERROR cannot borrow\n+}\n+\n+fn deref_mut_method2(mut x: Own<Point>) {\n+    x.set(0, 0);\n+}\n+\n+fn deref_extend_method<'a>(x: &'a Own<Point>) -> &'a int {\n+    x.x_ref()\n+}\n+\n+fn deref_extend_mut_method1<'a>(x: &'a Own<Point>) -> &'a mut int {\n+    x.y_mut() //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_mut_method2<'a>(x: &'a mut Own<Point>) -> &'a mut int {\n+    x.y_mut()\n+}\n+\n+fn assign_method1<'a>(x: Own<Point>) {\n+    *x.y_mut() = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign_method2<'a>(x: &'a Own<Point>) {\n+    *x.y_mut() = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign_method3<'a>(x: &'a mut Own<Point>) {\n+    *x.y_mut() = 3;\n+}\n+\n+pub fn main() {}"}, {"sha": "de68dd311c6578872aefc4a354381aa70393000b", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-auto-deref.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test how overloaded deref interacts with borrows when only\n+// Deref and not DerefMut is implemented.\n+\n+use std::ops::Deref;\n+\n+struct Rc<T> {\n+    value: *T\n+}\n+\n+impl<T> Deref<T> for Rc<T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        unsafe { &*self.value }\n+    }\n+}\n+\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+impl Point {\n+    fn get(&self) -> (int, int) {\n+        (self.x, self.y)\n+    }\n+\n+    fn set(&mut self, x: int, y: int) {\n+        self.x = x;\n+        self.y = y;\n+    }\n+\n+    fn x_ref<'a>(&'a self) -> &'a int {\n+        &self.x\n+    }\n+\n+    fn y_mut<'a>(&'a mut self) -> &'a mut int {\n+        &mut self.y\n+    }\n+}\n+\n+fn deref_imm_field(x: Rc<Point>) {\n+    let _i = &x.y;\n+}\n+\n+fn deref_mut_field1(x: Rc<Point>) {\n+    let _i = &mut x.y; //~ ERROR cannot borrow\n+}\n+\n+fn deref_mut_field2(mut x: Rc<Point>) {\n+    let _i = &mut x.y; //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_field<'a>(x: &'a Rc<Point>) -> &'a int {\n+    &x.y\n+}\n+\n+fn deref_extend_mut_field1<'a>(x: &'a Rc<Point>) -> &'a mut int {\n+    &mut x.y //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_mut_field2<'a>(x: &'a mut Rc<Point>) -> &'a mut int {\n+    &mut x.y //~ ERROR cannot borrow\n+}\n+\n+fn assign_field1<'a>(x: Rc<Point>) {\n+    x.y = 3; //~ ERROR cannot assign\n+}\n+\n+fn assign_field2<'a>(x: &'a Rc<Point>) {\n+    x.y = 3; //~ ERROR cannot assign\n+}\n+\n+fn assign_field3<'a>(x: &'a mut Rc<Point>) {\n+    x.y = 3; //~ ERROR cannot assign\n+}\n+\n+fn deref_imm_method(x: Rc<Point>) {\n+    let _i = x.get();\n+}\n+\n+fn deref_mut_method1(x: Rc<Point>) {\n+    x.set(0, 0); //~ ERROR cannot borrow\n+}\n+\n+fn deref_mut_method2(mut x: Rc<Point>) {\n+    x.set(0, 0); //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_method<'a>(x: &'a Rc<Point>) -> &'a int {\n+    x.x_ref()\n+}\n+\n+fn deref_extend_mut_method1<'a>(x: &'a Rc<Point>) -> &'a mut int {\n+    x.y_mut() //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_mut_method2<'a>(x: &'a mut Rc<Point>) -> &'a mut int {\n+    x.y_mut() //~ ERROR cannot borrow\n+}\n+\n+fn assign_method1<'a>(x: Rc<Point>) {\n+    *x.y_mut() = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign_method2<'a>(x: &'a Rc<Point>) {\n+    *x.y_mut() = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign_method3<'a>(x: &'a mut Rc<Point>) {\n+    *x.y_mut() = 3; //~ ERROR cannot borrow\n+}\n+\n+pub fn main() {}"}, {"sha": "1a96e5ef4b0ccbf301b5f6b6fea4bac199cb42ad", "filename": "src/test/compile-fail/borrowck-move-out-of-overloaded-auto-deref.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+pub fn main() {\n+    let _x = Rc::new(vec!(1, 2)).move_iter();\n+    //~^ ERROR cannot move out of dereference of `&`-pointer\n+}"}, {"sha": "ddef459453ec491eba284711b98eef8858e8d3eb", "filename": "src/test/compile-fail/infinite-autoderef.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: reached the recursion limit while auto-dereferencing\n+\n+use std::ops::Deref;\n+\n+struct Foo;\n+\n+impl Deref<Foo> for Foo {\n+    fn deref<'a>(&'a self) -> &'a Foo {\n+        self\n+    }\n+}\n+\n+pub fn main() {\n+    let mut x;\n+    loop {\n+        x = ~x;\n+        x.foo;\n+        x.bar();\n+    }\n+\n+    Foo.foo;\n+    Foo.bar();\n+}"}, {"sha": "b8fa6285d99553e547c2f77bc1b8a755bbe437af", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: overly deep expansion\n+// error-pattern: reached the recursion limit during monomorphization\n // issue 2258\n \n trait to_opt {"}, {"sha": "800549b7737c63c3f676e0b87b42837b5903a23c", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -40,7 +40,7 @@ fn main()\n     //~^ ERROR cannot pack type `~B`, which does not fulfill `Send`\n     let v = Rc::new(RefCell::new(a));\n     let w = v.clone();\n-    let b = v.borrow();\n+    let b = v.deref();\n     let mut b = b.borrow_mut();\n     b.get().v.set(w.clone());\n }"}, {"sha": "fca59ed74ee8d5135a86bf77a5fb6fdd11eeedaf", "filename": "src/test/compile-fail/issue-8727.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -15,7 +15,7 @@\n struct Data(~Option<Data>);\n \n fn generic<T>( _ : ~[(Data,T)] ) {\n-    //~^ ERROR overly deep expansion of inlined function\n+    //~^ ERROR reached the recursion limit during monomorphization\n     let rec : ~[(Data,(bool,T))] = ~[];\n     generic( rec );\n }"}, {"sha": "96676257184ce1f7cc8e076a70be2f7b154c07d7", "filename": "src/test/compile-fail/recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -20,7 +20,7 @@ impl<T:Dot> Dot for Cons<T> {\n   }\n }\n fn test<T:Dot> (n:int, i:int, first:T, second:T) ->int {\n-    //~^ ERROR: overly deep expansion of inlined function\n+    //~^ ERROR: reached the recursion limit during monomorphization\n   match n {\n     0 => {first.dot(second)}\n       // Error message should be here. It should be a type error"}, {"sha": "10ee06473c80bf8fe73ede7e64aa7daa435aaed1", "filename": "src/test/run-pass/overloaded-autoderef-count.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::Cell;\n+use std::ops::{Deref, DerefMut};\n+use std::vec_ng::Vec;\n+\n+#[deriving(Eq)]\n+struct DerefCounter<T> {\n+    count_imm: Cell<uint>,\n+    count_mut: uint,\n+    value: T\n+}\n+\n+impl<T> DerefCounter<T> {\n+    fn new(value: T) -> DerefCounter<T> {\n+        DerefCounter {\n+            count_imm: Cell::new(0),\n+            count_mut: 0,\n+            value: value\n+        }\n+    }\n+\n+    fn counts(&self) -> (uint, uint) {\n+        (self.count_imm.get(), self.count_mut)\n+    }\n+}\n+\n+impl<T> Deref<T> for DerefCounter<T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        self.count_imm.set(self.count_imm.get() + 1);\n+        &self.value\n+    }\n+}\n+\n+impl<T> DerefMut<T> for DerefCounter<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+        self.count_mut += 1;\n+        &mut self.value\n+    }\n+}\n+\n+#[deriving(Eq, Show)]\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+impl Point {\n+    fn get(&self) -> (int, int) {\n+        (self.x, self.y)\n+    }\n+}\n+\n+pub fn main() {\n+    let mut p = DerefCounter::new(Point {x: 0, y: 0});\n+\n+    let _ = p.x;\n+    assert_eq!(p.counts(), (1, 0));\n+\n+    let _ = &p.x;\n+    assert_eq!(p.counts(), (2, 0));\n+\n+    let _ = &mut p.y;\n+    assert_eq!(p.counts(), (2, 1));\n+\n+    p.x += 3;\n+    assert_eq!(p.counts(), (2, 2));\n+\n+    p.get();\n+    assert_eq!(p.counts(), (2, 3));\n+\n+    // Check the final state.\n+    assert_eq!(*p, Point {x: 3, y: 0});\n+}"}, {"sha": "c8885a3090c00ea6f0699927203618a882e498f3", "filename": "src/test/run-pass/overloaded-autoderef-indexing.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct DerefArray<'a, T> {\n+    inner: &'a [T]\n+}\n+\n+impl<'a, T> Deref<&'a [T]> for DerefArray<'a, T> {\n+    fn deref<'b>(&'b self) -> &'b &'a [T] {\n+        &self.inner\n+    }\n+}\n+\n+pub fn main() {\n+    let a = &[1, 2, 3];\n+    assert_eq!(DerefArray {inner: a}[1], 2);\n+}"}, {"sha": "9deeff773642d67a0c38844062c8b65d45c2396a", "filename": "src/test/run-pass/overloaded-autoderef-order.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+struct DerefWrapper<X, Y> {\n+    x: X,\n+    y: Y\n+}\n+\n+impl<X, Y> DerefWrapper<X, Y> {\n+    fn get_x(self) -> X {\n+        self.x\n+    }\n+}\n+\n+impl<X, Y> Deref<Y> for DerefWrapper<X, Y> {\n+    fn deref<'a>(&'a self) -> &'a Y {\n+        &self.y\n+    }\n+}\n+\n+mod priv_test {\n+    pub struct DerefWrapperHideX<X, Y> {\n+        priv x: X,\n+        y: Y\n+    }\n+\n+    impl<X, Y> DerefWrapperHideX<X, Y> {\n+        pub fn new(x: X, y: Y) -> DerefWrapperHideX<X, Y> {\n+            DerefWrapperHideX {\n+                x: x,\n+                y: y\n+            }\n+        }\n+    }\n+\n+    impl<X, Y> Deref<Y> for DerefWrapperHideX<X, Y> {\n+        fn deref<'a>(&'a self) -> &'a Y {\n+            &self.y\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    let nested = DerefWrapper {x: true, y: DerefWrapper {x: 0, y: 1}};\n+\n+    // Use the first field that you can find.\n+    assert_eq!(nested.x, true);\n+    assert_eq!((*nested).x, 0);\n+\n+    // Same for methods, even though there are multiple\n+    // candidates (at different nesting levels).\n+    assert_eq!(nested.get_x(), true);\n+    assert_eq!((*nested).get_x(), 0);\n+\n+    // Also go through multiple levels of indirection.\n+    assert_eq!(Rc::new(nested).x, true);\n+\n+    let nested_priv = priv_test::DerefWrapperHideX::new(true, DerefWrapper {x: 0, y: 1});\n+    // FIXME(eddyb) #12808 should skip private fields.\n+    // assert_eq!(nested_priv.x, 0);\n+    assert_eq!((*nested_priv).x, 0);\n+}"}, {"sha": "6b347b3833e46822fdcf1e484fefdda0fa91576d", "filename": "src/test/run-pass/overloaded-autoderef.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+#[deriving(Eq, Show)]\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+pub fn main() {\n+    assert_eq!(Rc::new(5u).to_uint(), Some(5));\n+    assert_eq!((~&~&Rc::new(~~&~5u)).to_uint(), Some(5));\n+    let point = Rc::new(Point {x: 2, y: 4});\n+    assert_eq!(point.x, 2);\n+    assert_eq!(point.y, 4);\n+\n+    let i = Rc::new(RefCell::new(2));\n+    let i_value = *i.borrow();\n+    *i.borrow_mut() = 5;\n+    assert_eq!((i_value, *i.borrow()), (2, 5));\n+\n+    let s = Rc::new(~\"foo\");\n+    assert!(s.equiv(&(\"foo\")));\n+    assert_eq!(s.as_slice(), \"foo\");\n+\n+    let mut_s = Rc::new(RefCell::new(~\"foo\"));\n+    mut_s.borrow_mut().push_str(\"bar\");\n+    // HACK assert_eq! would fail here because it stores the LHS and RHS in two locals.\n+    assert!(mut_s.borrow().as_slice() == \"foobar\");\n+    assert!(mut_s.borrow_mut().as_slice() == \"foobar\");\n+\n+    let p = Rc::new(RefCell::new(Point {x: 1, y: 2}));\n+    p.borrow_mut().x = 3;\n+    p.borrow_mut().y += 3;\n+    assert_eq!(*p.borrow(), Point {x: 3, y: 5});\n+\n+    let v = Rc::new(RefCell::new(~[1, 2, 3]));\n+    v.borrow_mut()[0] = 3;\n+    v.borrow_mut()[1] += 3;\n+    assert_eq!((v.borrow()[0], v.borrow()[1], v.borrow()[2]), (3, 5, 3));\n+}"}, {"sha": "cba142680dfb93fe27083d156cef1488ec44d631", "filename": "src/test/run-pass/self-re-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Frun-pass%2Fself-re-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf/src%2Ftest%2Frun-pass%2Fself-re-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fself-re-assign.rs?ref=50fb2a4f1fcf7671f4bdc8d438a11688636e5ecf", "patch": "@@ -20,5 +20,5 @@ pub fn main() {\n \n    let mut x = Rc::new(3);\n    x = x;\n-   assert!(*x.borrow() == 3);\n+   assert!(*x.deref() == 3);\n }"}]}