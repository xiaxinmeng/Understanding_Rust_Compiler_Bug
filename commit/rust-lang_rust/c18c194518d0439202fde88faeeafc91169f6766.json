{"sha": "c18c194518d0439202fde88faeeafc91169f6766", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxOGMxOTQ1MThkMDQzOTIwMmZkZTg4ZmFlZWFmYzkxMTY5ZjY3NjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-04T13:09:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-04T13:09:06Z"}, "message": "Rollup merge of #59671 - matklad:lexer, r=eddyb\n\nMake some of lexer's API private\n\nLexer is a `pub` type, so it feels wrong that its fields are just pub (I guess it wasn't exported initially), so let's minimize visibility.\n\nContext: I am looking into extracting rust-lexer into a library, which can be shared by rust-analyzer and rustc. I hope that a simple interface like `fn next_token(src: &str) -> (TokenKind, usize)` would work, but to try this out I need to understand what is the current API of the lexer.", "tree": {"sha": "31d526c4f740451556b58a654f1c41f030565dde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31d526c4f740451556b58a654f1c41f030565dde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c18c194518d0439202fde88faeeafc91169f6766", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcpgHyCRBK7hj4Ov3rIwAAdHIIADD6lkCsL+/izYy+Tq8eoinb\nP8CQ5hZow5EJXZfAx0YqvvsXcBsUf6J7Nf2D0SB1ioE73l7+cEVvu0+nSbIALdjH\nPUMNzalR3cToHyTCDlCN54FnAiVi7QI78LH9wozEpL9U6bSPoAliHtTrxXeQQwVO\nXhouNKJDdrzTBWhUnbIiDe4XFUEZLNtWBlTa4ltkxXSiZmCuvjRGfbJFxxBc+XjW\nOH4zKwiVbn9DQNIPK8hWUE4/TfyrX6OCx6mJ195lHev/ObPYuAvkZq64lVPaY/5X\neRQkYYsZbz2+OHwTZKvi2EBKjs7ZLvnJMT5Wp6E545/ZCmWFiWxIO+1N1FT3CH0=\n=G8nh\n-----END PGP SIGNATURE-----\n", "payload": "tree 31d526c4f740451556b58a654f1c41f030565dde\nparent 05c31baf83ffe6f96ee379d00a236356ce39fd6d\nparent 1763aea7ba039235baebd8f116b91a21df39778a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1554383346 +0200\ncommitter GitHub <noreply@github.com> 1554383346 +0200\n\nRollup merge of #59671 - matklad:lexer, r=eddyb\n\nMake some of lexer's API private\n\nLexer is a `pub` type, so it feels wrong that its fields are just pub (I guess it wasn't exported initially), so let's minimize visibility.\n\nContext: I am looking into extracting rust-lexer into a library, which can be shared by rust-analyzer and rustc. I hope that a simple interface like `fn next_token(src: &str) -> (TokenKind, usize)` would work, but to try this out I need to understand what is the current API of the lexer.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c18c194518d0439202fde88faeeafc91169f6766", "html_url": "https://github.com/rust-lang/rust/commit/c18c194518d0439202fde88faeeafc91169f6766", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c18c194518d0439202fde88faeeafc91169f6766/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05c31baf83ffe6f96ee379d00a236356ce39fd6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/05c31baf83ffe6f96ee379d00a236356ce39fd6d", "html_url": "https://github.com/rust-lang/rust/commit/05c31baf83ffe6f96ee379d00a236356ce39fd6d"}, {"sha": "1763aea7ba039235baebd8f116b91a21df39778a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1763aea7ba039235baebd8f116b91a21df39778a", "html_url": "https://github.com/rust-lang/rust/commit/1763aea7ba039235baebd8f116b91a21df39778a"}], "stats": {"total": 16, "additions": 8, "deletions": 8}, "files": [{"sha": "d0162ef170482a37e922bd3d0fc39e49eb6b7805", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c18c194518d0439202fde88faeeafc91169f6766/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18c194518d0439202fde88faeeafc91169f6766/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c18c194518d0439202fde88faeeafc91169f6766", "patch": "@@ -43,16 +43,16 @@ pub struct UnmatchedBrace {\n }\n \n pub struct StringReader<'a> {\n-    pub sess: &'a ParseSess,\n+    crate sess: &'a ParseSess,\n     /// The absolute offset within the source_map of the next character to read\n-    pub next_pos: BytePos,\n+    crate next_pos: BytePos,\n     /// The absolute offset within the source_map of the current character\n-    pub pos: BytePos,\n+    crate pos: BytePos,\n     /// The current character (which has been read from self.pos)\n-    pub ch: Option<char>,\n-    pub source_file: Lrc<syntax_pos::SourceFile>,\n+    crate ch: Option<char>,\n+    crate source_file: Lrc<syntax_pos::SourceFile>,\n     /// Stop reading src at this index.\n-    pub end_src_index: usize,\n+    crate end_src_index: usize,\n     // cached:\n     peek_tok: token::Token,\n     peek_span: Span,\n@@ -126,7 +126,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Immutably extract string if found at current position with given delimiters\n-    pub fn peek_delimited(&self, from_ch: char, to_ch: char) -> Option<String> {\n+    fn peek_delimited(&self, from_ch: char, to_ch: char) -> Option<String> {\n         let mut pos = self.pos;\n         let mut idx = self.src_index(pos);\n         let mut ch = char_at(&self.src, idx);\n@@ -191,7 +191,7 @@ impl<'a> StringReader<'a> {\n         self.fatal_span(self.peek_span, m)\n     }\n \n-    pub fn emit_fatal_errors(&mut self) {\n+    crate fn emit_fatal_errors(&mut self) {\n         for err in &mut self.fatal_errs {\n             err.emit();\n         }"}]}