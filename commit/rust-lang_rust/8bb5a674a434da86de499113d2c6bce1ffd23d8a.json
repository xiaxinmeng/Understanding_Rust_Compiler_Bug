{"sha": "8bb5a674a434da86de499113d2c6bce1ffd23d8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYjVhNjc0YTQzNGRhODZkZTQ5OTExM2QyYzZiY2UxZmZkMjNkOGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-02T21:49:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-02T21:49:42Z"}, "message": "rollup merge of #16993 : dschatzberg/items-bounds", "tree": {"sha": "4155e4ac5a90d0495241084952ac6c558ff8c002", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4155e4ac5a90d0495241084952ac6c558ff8c002"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bb5a674a434da86de499113d2c6bce1ffd23d8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb5a674a434da86de499113d2c6bce1ffd23d8a", "html_url": "https://github.com/rust-lang/rust/commit/8bb5a674a434da86de499113d2c6bce1ffd23d8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bb5a674a434da86de499113d2c6bce1ffd23d8a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c8d0334ee480d54b6917e780cfa2da3747ecfc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c8d0334ee480d54b6917e780cfa2da3747ecfc1", "html_url": "https://github.com/rust-lang/rust/commit/4c8d0334ee480d54b6917e780cfa2da3747ecfc1"}, {"sha": "49e593c3d6494e210c215b4d353270616450980f", "url": "https://api.github.com/repos/rust-lang/rust/commits/49e593c3d6494e210c215b4d353270616450980f", "html_url": "https://github.com/rust-lang/rust/commit/49e593c3d6494e210c215b4d353270616450980f"}], "stats": {"total": 100, "additions": 81, "deletions": 19}, "files": [{"sha": "ab1605954337e611cbbee13a571b936edcd61c20", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb5a674a434da86de499113d2c6bce1ffd23d8a/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb5a674a434da86de499113d2c6bce1ffd23d8a/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=8bb5a674a434da86de499113d2c6bce1ffd23d8a", "patch": "@@ -46,12 +46,12 @@ struct AbsEntries<T> {\n }\n \n /// An iterator over a BTreeMap's entries.\n-pub struct Entries<'a, K, V> {\n+pub struct Entries<'a, K: 'a, V: 'a> {\n     inner: AbsEntries<Traversal<'a, K, V>>\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n-pub struct MutEntries<'a, K, V> {\n+pub struct MutEntries<'a, K: 'a, V: 'a> {\n     inner: AbsEntries<MutTraversal<'a, K, V>>\n }\n "}, {"sha": "f5d61a644a3c3842a9162023b06292720d2c8a85", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 77, "deletions": 15, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8bb5a674a434da86de499113d2c6bce1ffd23d8a/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb5a674a434da86de499113d2c6bce1ffd23d8a/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=8bb5a674a434da86de499113d2c6bce1ffd23d8a", "patch": "@@ -791,11 +791,16 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn into_iter(self) -> MoveItems<T> {\n         unsafe {\n-            let iter = mem::transmute(self.as_slice().iter());\n             let ptr = self.ptr;\n             let cap = self.cap;\n+            let begin = self.ptr as *const T;\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as uint + self.len()) as *const T\n+            } else {\n+                ptr.offset(self.len() as int) as *const T\n+            };\n             mem::forget(self);\n-            MoveItems { allocation: ptr, cap: cap, iter: iter }\n+            MoveItems { allocation: ptr, cap: cap, ptr: begin, end: end }\n         }\n     }\n \n@@ -1719,7 +1724,8 @@ impl<T> MutableSeq<T> for Vec<T> {\n pub struct MoveItems<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n     cap: uint, // the capacity of the vector\n-    iter: Items<'static, T>\n+    ptr: *const T,\n+    end: *const T\n }\n \n impl<T> MoveItems<T> {\n@@ -1728,7 +1734,7 @@ impl<T> MoveItems<T> {\n     pub fn unwrap(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self { }\n-            let MoveItems { allocation, cap, iter: _iter } = self;\n+            let MoveItems { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n             Vec { ptr: allocation, cap: cap, len: 0 }\n         }\n@@ -1739,29 +1745,55 @@ impl<T> Iterator<T> for MoveItems<T> {\n     #[inline]\n     fn next<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n-            // Unsafely transmute from Items<'static, T> to Items<'a,\n-            // T> because otherwise the type checker requires that T\n-            // be bounded by 'static.\n-            let iter: &mut Items<'a, T> = mem::transmute(&mut self.iter);\n-            iter.next().map(|x| ptr::read(x))\n+            if self.ptr == self.end {\n+                None\n+            } else {\n+                if mem::size_of::<T>() == 0 {\n+                    // purposefully don't use 'ptr.offset' because for\n+                    // vectors with 0-size elements this would return the\n+                    // same pointer.\n+                    self.ptr = mem::transmute(self.ptr as uint + 1);\n+\n+                    // Use a non-null pointer value\n+                    Some(ptr::read(mem::transmute(1u)))\n+                } else {\n+                    let old = self.ptr;\n+                    self.ptr = self.ptr.offset(1);\n+\n+                    Some(ptr::read(old))\n+                }\n+            }\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n+        let diff = (self.end as uint) - (self.ptr as uint);\n+        let size = mem::size_of::<T>();\n+        let exact = diff / (if size == 0 {1} else {size});\n+        (exact, Some(exact))\n     }\n }\n \n impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n     #[inline]\n     fn next_back<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n-            // Unsafely transmute from Items<'static, T> to Items<'a,\n-            // T> because otherwise the type checker requires that T\n-            // be bounded by 'static.\n-            let iter: &mut Items<'a, T> = mem::transmute(&mut self.iter);\n-            iter.next_back().map(|x| ptr::read(x))\n+            if self.end == self.ptr {\n+                None\n+            } else {\n+                if mem::size_of::<T>() == 0 {\n+                    // See above for why 'ptr.offset' isn't used\n+                    self.end = mem::transmute(self.end as uint - 1);\n+\n+                    // Use a non-null pointer value\n+                    Some(ptr::read(mem::transmute(1u)))\n+                } else {\n+                    self.end = self.end.offset(-1);\n+\n+                    Some(ptr::read(mem::transmute(self.end)))\n+                }\n+            }\n         }\n     }\n }\n@@ -2473,6 +2505,36 @@ mod tests {\n         assert_eq!(v.map_in_place(|_| ZeroSized).as_slice(), [ZeroSized, ZeroSized].as_slice());\n     }\n \n+    #[test]\n+    fn test_move_items() {\n+        let mut vec = vec!(1i, 2, 3);\n+        let mut vec2 : Vec<int> = vec!();\n+        for i in vec.into_iter() {\n+            vec2.push(i);\n+        }\n+        assert!(vec2 == vec!(1i, 2, 3));\n+    }\n+\n+    #[test]\n+    fn test_move_items_reverse() {\n+        let mut vec = vec!(1i, 2, 3);\n+        let mut vec2 : Vec<int> = vec!();\n+        for i in vec.into_iter().rev() {\n+            vec2.push(i);\n+        }\n+        assert!(vec2 == vec!(3i, 2, 1));\n+    }\n+\n+    #[test]\n+    fn test_move_items_zero_sized() {\n+        let mut vec = vec!((), (), ());\n+        let mut vec2 : Vec<()> = vec!();\n+        for i in vec.into_iter() {\n+            vec2.push(i);\n+        }\n+        assert!(vec2 == vec!((), (), ()));\n+    }\n+\n     #[bench]\n     fn bench_new(b: &mut Bencher) {\n         b.iter(|| {"}, {"sha": "9f925f9d371a63712c2379b46b193bc7d38fb918", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb5a674a434da86de499113d2c6bce1ffd23d8a/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb5a674a434da86de499113d2c6bce1ffd23d8a/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=8bb5a674a434da86de499113d2c6bce1ffd23d8a", "patch": "@@ -1218,7 +1218,7 @@ macro_rules! iterator {\n \n /// Immutable slice iterator\n #[experimental = \"needs review\"]\n-pub struct Items<'a, T> {\n+pub struct Items<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n     marker: marker::ContravariantLifetime<'a>\n@@ -1261,7 +1261,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n \n /// Mutable slice iterator.\n #[experimental = \"needs review\"]\n-pub struct MutItems<'a, T> {\n+pub struct MutItems<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n     marker: marker::ContravariantLifetime<'a>,"}]}