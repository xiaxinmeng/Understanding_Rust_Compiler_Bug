{"sha": "e61937a6bf5e3a612dd8e2aa92061345f73d4b30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MTkzN2E2YmY1ZTNhNjEyZGQ4ZTJhYTkyMDYxMzQ1ZjczZDRiMzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-01T04:41:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-01T04:41:56Z"}, "message": "auto merge of #11187 : alexcrichton/rust/once, r=brson\n\nRationale can be found in the first commit, but this is basically the same thing as `pthread_once`", "tree": {"sha": "8bc04190803bd71c0d5e7730dfdb3318079d844b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bc04190803bd71c0d5e7730dfdb3318079d844b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e61937a6bf5e3a612dd8e2aa92061345f73d4b30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e61937a6bf5e3a612dd8e2aa92061345f73d4b30", "html_url": "https://github.com/rust-lang/rust/commit/e61937a6bf5e3a612dd8e2aa92061345f73d4b30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02cec05c550317f88cd8e3a4574f60ed731fe666", "url": "https://api.github.com/repos/rust-lang/rust/commits/02cec05c550317f88cd8e3a4574f60ed731fe666", "html_url": "https://github.com/rust-lang/rust/commit/02cec05c550317f88cd8e3a4574f60ed731fe666"}, {"sha": "c22fed9424a907beab53f6c6cd54afeff039f1b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c22fed9424a907beab53f6c6cd54afeff039f1b3", "html_url": "https://github.com/rust-lang/rust/commit/c22fed9424a907beab53f6c6cd54afeff039f1b3"}], "stats": {"total": 232, "additions": 176, "deletions": 56}, "files": [{"sha": "6736641c85811db11823641afb769296044ce5a7", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=e61937a6bf5e3a612dd8e2aa92061345f73d4b30", "patch": "@@ -205,19 +205,14 @@ pub fn init() {\n     }\n \n     unsafe {\n-        use std::unstable::mutex::{Mutex, MUTEX_INIT};\n-        static mut LOCK: Mutex = MUTEX_INIT;\n-        static mut INITIALIZED: bool = false;\n-        if INITIALIZED { return }\n-        LOCK.lock();\n-        if !INITIALIZED {\n+        use std::unstable::mutex::{Once, ONCE_INIT};\n+        static mut INIT: Once = ONCE_INIT;\n+        INIT.doit(|| {\n             let mut data: WSADATA = intrinsics::init();\n             let ret = WSAStartup(0x202,      // version 2.2\n                                  &mut data);\n             assert_eq!(ret, 0);\n-            INITIALIZED = true;\n-        }\n-        LOCK.unlock();\n+        });\n     }\n }\n "}, {"sha": "d70af9bc1edb4961fa83959fd5338302ea045af8", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=e61937a6bf5e3a612dd8e2aa92061345f73d4b30", "patch": "@@ -309,9 +309,8 @@ pub mod write {\n     }\n \n     unsafe fn configure_llvm(sess: Session) {\n-        use std::unstable::mutex::{MUTEX_INIT, Mutex};\n-        static mut LOCK: Mutex = MUTEX_INIT;\n-        static mut CONFIGURED: bool = false;\n+        use std::unstable::mutex::{Once, ONCE_INIT};\n+        static mut INIT: Once = ONCE_INIT;\n \n         // Copy what clan does by turning on loop vectorization at O2 and\n         // slp vectorization at O3\n@@ -340,8 +339,7 @@ pub mod write {\n             add(*arg);\n         }\n \n-        LOCK.lock();\n-        if !CONFIGURED {\n+        INIT.doit(|| {\n             llvm::LLVMInitializePasses();\n \n             // Only initialize the platforms supported by Rust here, because\n@@ -368,9 +366,7 @@ pub mod write {\n \n             llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n                                          llvm_args.as_ptr());\n-            CONFIGURED = true;\n-        }\n-        LOCK.unlock();\n+        });\n     }\n \n     unsafe fn populate_llvm_passes(fpm: lib::llvm::PassManagerRef,"}, {"sha": "0639526ffdb6ee45a127dff8775f6faed746f6e8", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=e61937a6bf5e3a612dd8e2aa92061345f73d4b30", "patch": "@@ -1459,15 +1459,16 @@ pub mod llvm {\n                                                          BufferName: *c_char)\n             -> MemoryBufferRef;\n \n+        pub fn LLVMIsMultithreaded() -> Bool;\n+        pub fn LLVMStartMultithreaded() -> Bool;\n+\n         /** Returns a string describing the last error caused by an LLVMRust*\n             call. */\n         pub fn LLVMRustGetLastError() -> *c_char;\n \n         /// Print the pass timings since static dtors aren't picking them up.\n         pub fn LLVMRustPrintPassTimings();\n \n-        pub fn LLVMRustStartMultithreading() -> bool;\n-\n         pub fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char) -> TypeRef;\n \n         pub fn LLVMStructSetBody(StructTy: TypeRef,"}, {"sha": "08d2c3f0caf5fc7d83aad6ec5538afc525f8f909", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e61937a6bf5e3a612dd8e2aa92061345f73d4b30", "patch": "@@ -3189,8 +3189,21 @@ pub fn trans_crate(sess: session::Session,\n                    analysis: &CrateAnalysis,\n                    output: &Path) -> CrateTranslation {\n     // Before we touch LLVM, make sure that multithreading is enabled.\n-    if unsafe { !llvm::LLVMRustStartMultithreading() } {\n-        sess.bug(\"couldn't enable multi-threaded LLVM\");\n+    unsafe {\n+        use std::unstable::mutex::{Once, ONCE_INIT};\n+        static mut INIT: Once = ONCE_INIT;\n+        static mut POISONED: bool = false;\n+        INIT.doit(|| {\n+            if llvm::LLVMStartMultithreaded() != 1 {\n+                // use an extra bool to make sure that all future usage of LLVM\n+                // cannot proceed despite the Once not running more than once.\n+                POISONED = true;\n+            }\n+        });\n+\n+        if POISONED {\n+            sess.bug(\"couldn't enable multi-threaded LLVM\");\n+        }\n     }\n \n     let mut symbol_hasher = Sha256::new();"}, {"sha": "f13691a7bfe99542cb2b87196648762b3018f8e6", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=e61937a6bf5e3a612dd8e2aa92061345f73d4b30", "patch": "@@ -160,30 +160,20 @@ pub mod native {\n     use option::{Option, Some, None};\n     use ptr;\n     use tls = rt::thread_local_storage;\n-    use unstable::mutex::{Mutex, MUTEX_INIT};\n \n-    static mut LOCK: Mutex = MUTEX_INIT;\n-    static mut INITIALIZED: bool = false;\n     static mut RT_TLS_KEY: tls::Key = -1;\n \n     /// Initialize the TLS key. Other ops will fail if this isn't executed\n     /// first.\n     pub fn init() {\n         unsafe {\n-            LOCK.lock();\n-            if !INITIALIZED {\n-                tls::create(&mut RT_TLS_KEY);\n-                INITIALIZED = true;\n-            }\n-            LOCK.unlock();\n+            tls::create(&mut RT_TLS_KEY);\n         }\n     }\n \n     pub unsafe fn cleanup() {\n-        rtassert!(INITIALIZED);\n+        rtassert!(RT_TLS_KEY != -1);\n         tls::destroy(RT_TLS_KEY);\n-        LOCK.destroy();\n-        INITIALIZED = false;\n     }\n \n     /// Give a pointer to thread-local storage."}, {"sha": "36682b8541860e069f0f20c4e25eb1e50a3f841a", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 148, "deletions": 1, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=e61937a6bf5e3a612dd8e2aa92061345f73d4b30", "patch": "@@ -47,6 +47,7 @@\n \n #[allow(non_camel_case_types)];\n \n+use int;\n use libc::c_void;\n use sync::atomics;\n \n@@ -315,10 +316,156 @@ mod imp {\n     }\n }\n \n+/// A type which can be used to run a one-time global initialization. This type\n+/// is *unsafe* to use because it is built on top of the `Mutex` in this module.\n+/// It does not know whether the currently running task is in a green or native\n+/// context, and a blocking mutex should *not* be used under normal\n+/// circumstances on a green task.\n+///\n+/// Despite its unsafety, it is often useful to have a one-time initialization\n+/// routine run for FFI bindings or related external functionality. This type\n+/// can only be statically constructed with the `ONCE_INIT` value.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::unstable::mutex::{Once, ONCE_INIT};\n+///\n+/// static mut START: Once = ONCE_INIT;\n+/// unsafe {\n+///     START.doit(|| {\n+///         // run initialization here\n+///     });\n+/// }\n+/// ```\n+pub struct Once {\n+    priv mutex: Mutex,\n+    priv cnt: atomics::AtomicInt,\n+    priv lock_cnt: atomics::AtomicInt,\n+}\n+\n+/// Initialization value for static `Once` values.\n+pub static ONCE_INIT: Once = Once {\n+    mutex: MUTEX_INIT,\n+    cnt: atomics::INIT_ATOMIC_INT,\n+    lock_cnt: atomics::INIT_ATOMIC_INT,\n+};\n+\n+impl Once {\n+    /// Perform an initialization routine once and only once. The given closure\n+    /// will be executed if this is the first time `doit` has been called, and\n+    /// otherwise the routine will *not* be invoked.\n+    ///\n+    /// This method will block the calling *os thread* if another initialization\n+    /// routine is currently running.\n+    ///\n+    /// When this function returns, it is guaranteed that some initialization\n+    /// has run and completed (it may not be the closure specified).\n+    pub fn doit(&mut self, f: ||) {\n+        // Implementation-wise, this would seem like a fairly trivial primitive.\n+        // The stickler part is where our mutexes currently require an\n+        // allocation, and usage of a `Once` should't leak this allocation.\n+        //\n+        // This means that there must be a deterministic destroyer of the mutex\n+        // contained within (because it's not needed after the initialization\n+        // has run).\n+        //\n+        // The general scheme here is to gate all future threads once\n+        // initialization has completed with a \"very negative\" count, and to\n+        // allow through threads to lock the mutex if they see a non negative\n+        // count. For all threads grabbing the mutex, exactly one of them should\n+        // be responsible for unlocking the mutex, and this should only be done\n+        // once everyone else is done with the mutex.\n+        //\n+        // This atomicity is achieved by swapping a very negative value into the\n+        // shared count when the initialization routine has completed. This will\n+        // read the number of threads which will at some point attempt to\n+        // acquire the mutex. This count is then squirreled away in a separate\n+        // variable, and the last person on the way out of the mutex is then\n+        // responsible for destroying the mutex.\n+        //\n+        // It is crucial that the negative value is swapped in *after* the\n+        // initialization routine has completed because otherwise new threads\n+        // calling `doit` will return immediately before the initialization has\n+        // completed.\n+\n+        let prev = self.cnt.fetch_add(1, atomics::SeqCst);\n+        if prev < 0 {\n+            // Make sure we never overflow, we'll never have int::min_value\n+            // simultaneous calls to `doit` to make this value go back to 0\n+            self.cnt.store(int::min_value, atomics::SeqCst);\n+            return\n+        }\n+\n+        // If the count is negative, then someone else finished the job,\n+        // otherwise we run the job and record how many people will try to grab\n+        // this lock\n+        unsafe { self.mutex.lock() }\n+        if self.cnt.load(atomics::SeqCst) > 0 {\n+            f();\n+            let prev = self.cnt.swap(int::min_value, atomics::SeqCst);\n+            self.lock_cnt.store(prev, atomics::SeqCst);\n+        }\n+        unsafe { self.mutex.unlock() }\n+\n+        // Last one out cleans up after everyone else, no leaks!\n+        if self.lock_cnt.fetch_add(-1, atomics::SeqCst) == 1 {\n+            unsafe { self.mutex.destroy() }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n-    use super::{Mutex, MUTEX_INIT};\n+    use prelude::*;\n+\n     use rt::thread::Thread;\n+    use super::{ONCE_INIT, Once, Mutex, MUTEX_INIT};\n+    use task;\n+\n+    #[test]\n+    fn smoke_once() {\n+        static mut o: Once = ONCE_INIT;\n+        let mut a = 0;\n+        unsafe { o.doit(|| a += 1); }\n+        assert_eq!(a, 1);\n+        unsafe { o.doit(|| a += 1); }\n+        assert_eq!(a, 1);\n+    }\n+\n+    #[test]\n+    fn stampede_once() {\n+        static mut o: Once = ONCE_INIT;\n+        static mut run: bool = false;\n+\n+        let (p, c) = SharedChan::new();\n+        for _ in range(0, 10) {\n+            let c = c.clone();\n+            do spawn {\n+                for _ in range(0, 4) { task::deschedule() }\n+                unsafe {\n+                    o.doit(|| {\n+                        assert!(!run);\n+                        run = true;\n+                    });\n+                    assert!(run);\n+                }\n+                c.send(());\n+            }\n+        }\n+\n+        unsafe {\n+            o.doit(|| {\n+                assert!(!run);\n+                run = true;\n+            });\n+            assert!(run);\n+        }\n+\n+        for _ in range(0, 10) {\n+            p.recv();\n+        }\n+    }\n \n     #[test]\n     fn somke_lock() {"}, {"sha": "335c7b2c65b7fc552a6810467db7a3f2c430c375", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e61937a6bf5e3a612dd8e2aa92061345f73d4b30/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=e61937a6bf5e3a612dd8e2aa92061345f73d4b30", "patch": "@@ -149,28 +149,6 @@ extern \"C\" LLVMValueRef LLVMInlineAsm(LLVMTypeRef Ty,\n                                IsAlignStack, (InlineAsm::AsmDialect) Dialect));\n }\n \n-/**\n- * This function is intended to be a threadsafe interface into enabling a\n- * multithreaded LLVM. This is invoked at the start of the translation phase of\n- * compilation to ensure that LLVM is ready.\n- *\n- * All of trans properly isolates LLVM with the use of a different\n- * LLVMContextRef per task, thus allowing parallel compilation of different\n- * crates in the same process. At the time of this writing, the use case for\n- * this is unit tests for rusti, but there are possible other applications.\n- */\n-extern \"C\" bool LLVMRustStartMultithreading() {\n-    static Mutex lock;\n-    bool ret = true;\n-    assert(lock.acquire());\n-    if (!LLVMIsMultithreaded()) {\n-        ret = LLVMStartMultithreaded();\n-    }\n-    assert(lock.release());\n-    return ret;\n-}\n-\n-\n typedef DIBuilder* DIBuilderRef;\n \n template<typename DIT>"}]}