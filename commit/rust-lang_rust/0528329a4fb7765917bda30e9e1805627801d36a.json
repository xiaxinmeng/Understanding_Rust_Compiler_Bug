{"sha": "0528329a4fb7765917bda30e9e1805627801d36a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MjgzMjlhNGZiNzc2NTkxN2JkYTMwZTllMTgwNTYyNzgwMWQzNmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-15T20:09:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-15T20:09:15Z"}, "message": "auto merge of #4964 : luqmana/rust/demove, r=graydon\n\nAs per #4339/#3676 this pull removes all uses `move` and gets rid of parsing it in libsyntax.\r\nSo that's one more thing to cross off #4707", "tree": {"sha": "7802d09c2d554bfacb9070fb60b3b68b4bd8c9d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7802d09c2d554bfacb9070fb60b3b68b4bd8c9d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0528329a4fb7765917bda30e9e1805627801d36a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0528329a4fb7765917bda30e9e1805627801d36a", "html_url": "https://github.com/rust-lang/rust/commit/0528329a4fb7765917bda30e9e1805627801d36a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0528329a4fb7765917bda30e9e1805627801d36a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "690d038d0ba715ac45c0f416761e561fffdae3c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/690d038d0ba715ac45c0f416761e561fffdae3c9", "html_url": "https://github.com/rust-lang/rust/commit/690d038d0ba715ac45c0f416761e561fffdae3c9"}, {"sha": "3a19eef4966cf9ba7104792ebd70c38015dcecab", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a19eef4966cf9ba7104792ebd70c38015dcecab", "html_url": "https://github.com/rust-lang/rust/commit/3a19eef4966cf9ba7104792ebd70c38015dcecab"}], "stats": {"total": 2791, "additions": 1386, "deletions": 1405}, "files": [{"sha": "14efa3fcead884c040696744668021fc849554a3", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -213,7 +213,7 @@ else enum extern\n false fn for\n if impl\n let log loop\n-match mod move mut\n+match mod mut\n priv pub pure\n ref return\n self static struct super"}, {"sha": "c13b2528598c18c648956dc5bd38e73637c75216", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -431,7 +431,7 @@ fn example5c(x: @S) -> int {\n         let y = &v.g;\n         ...\n     }\n-    x.f = move v;          // Replace x.f\n+    x.f = v;          // Replace x.f\n     ...\n # return 0;\n }"}, {"sha": "a3d0ecaa4ba6552e21b33ceacc16d70ca4272527", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -161,7 +161,7 @@ use pipes::{stream, Port, Chan};\n \n let (port, chan): (Port<int>, Chan<int>) = stream();\n \n-do spawn |move chan| {\n+do spawn || {\n     let result = some_expensive_computation();\n     chan.send(result);\n }\n@@ -192,7 +192,7 @@ spawns the child task.\n # use pipes::{stream, Port, Chan};\n # fn some_expensive_computation() -> int { 42 }\n # let (port, chan) = stream();\n-do spawn |move chan| {\n+do spawn || {\n     let result = some_expensive_computation();\n     chan.send(result);\n }\n@@ -229,7 +229,7 @@ following program is ill-typed:\n # fn some_expensive_computation() -> int { 42 }\n let (port, chan) = stream();\n \n-do spawn |move chan| {\n+do spawn {\n     chan.send(some_expensive_computation());\n }\n \n@@ -248,12 +248,12 @@ Instead we can use a `SharedChan`, a type that allows a single\n use pipes::{stream, SharedChan};\n \n let (port, chan) = stream();\n-let chan = SharedChan(move chan);\n+let chan = SharedChan(chan);\n \n for uint::range(0, 3) |init_val| {\n     // Create a new channel handle to distribute to the child task\n     let child_chan = chan.clone();\n-    do spawn |move child_chan| {\n+    do spawn {\n         child_chan.send(some_expensive_computation(init_val));\n     }\n }\n@@ -283,10 +283,10 @@ might look like the example below.\n // Create a vector of ports, one for each child task\n let ports = do vec::from_fn(3) |init_val| {\n     let (port, chan) = stream();\n-    do spawn |move chan| {\n+    do spawn {\n         chan.send(some_expensive_computation(init_val));\n     }\n-    move port\n+    port\n };\n \n // Wait on each port, accumulating the results\n@@ -398,13 +398,13 @@ before returning. Hence:\n # fn sleep_forever() { loop { task::yield() } }\n # do task::try {\n let (receiver, sender): (Port<int>, Chan<int>) = stream();\n-do spawn |move receiver| {  // Bidirectionally linked\n+do spawn {  // Bidirectionally linked\n     // Wait for the supervised child task to exist.\n     let message = receiver.recv();\n     // Kill both it and the parent task.\n     assert message != 42;\n }\n-do try |move sender| {  // Unidirectionally linked\n+do try {  // Unidirectionally linked\n     sender.send(42);\n     sleep_forever();  // Will get woken up by force\n }\n@@ -505,7 +505,7 @@ Here is the code for the parent task:\n \n let (from_child, to_child) = DuplexStream();\n \n-do spawn |move to_child| {\n+do spawn {\n     stringifier(&to_child);\n };\n "}, {"sha": "9550dd927fac36c1457e3e16207c0e1c822649b8", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -1260,7 +1260,7 @@ Moving it into a mutable slot makes the elements assignable.\n let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n \n // Put the vector into a mutable slot\n-let mut mutable_crayons = move crayons;\n+let mut mutable_crayons = crayons;\n \n // Now it's mutable to the bone\n mutable_crayons[0] = Apricot;"}, {"sha": "5ad616963fa666253ad3ad0ae643a4dc97e247bc", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -177,7 +177,7 @@ pub fn make_tests(config: config) -> ~[test::TestDescAndFn] {\n             tests.push(make_test(config, file))\n         }\n     }\n-    move tests\n+    tests\n }\n \n pub fn is_test(config: config, testfile: &Path) -> bool {"}, {"sha": "432258b26a638797a38f9f15154e57cf411487ef", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -78,12 +78,12 @@ pub fn run(lib_path: ~str,\n     writeclose(pipe_in.out, input);\n     let p = pipes::PortSet();\n     let ch = p.chan();\n-    do task::spawn_sched(task::SingleThreaded) |move ch| {\n+    do task::spawn_sched(task::SingleThreaded) || {\n         let errput = readclose(pipe_err.in);\n         ch.send((2, errput));\n     }\n     let ch = p.chan();\n-    do task::spawn_sched(task::SingleThreaded) |move ch| {\n+    do task::spawn_sched(task::SingleThreaded) || {\n         let output = readclose(pipe_out.in);\n         ch.send((1, output));\n     }"}, {"sha": "98fd50909545bf64c128ea3e56be6b3f6a261e4c", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -744,7 +744,7 @@ pub fn configure(opts: Options) -> Cargo {\n              ~\" or package manager to get it to work correctly\");\n     }\n \n-    move c\n+    c\n }\n \n pub fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n@@ -1655,10 +1655,10 @@ pub fn dump_sources(c: &Cargo) {\n                     _ => ()\n                 }\n \n-                hash.insert(copy k, json::Object(move chash));\n+                hash.insert(copy k, json::Object(chash));\n             }\n \n-            json::to_writer(writer, &json::Object(move hash))\n+            json::to_writer(writer, &json::Object(hash))\n         }\n         result::Err(e) => {\n             error(fmt!(\"could not dump sources: %s\", e));"}, {"sha": "71af60314da8252b4b60aacd30bc343f69b53389", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -229,12 +229,12 @@ pub mod raw {\n         (**repr).unboxed.fill += sys::size_of::<T>();\n         let p = addr_of(&((**repr).unboxed.data));\n         let p = ptr::offset(p, fill) as *mut T;\n-        rusti::move_val_init(&mut(*p), move initval);\n+        rusti::move_val_init(&mut(*p), initval);\n     }\n \n     pub unsafe fn push_slow<T>(v: &mut @[const T], initval: T) {\n         reserve_at_least(&mut *v, v.len() + 1u);\n-        push_fast(v, move initval);\n+        push_fast(v, initval);\n     }\n \n     /**"}, {"sha": "22ed4f76943109e9ea992354e8c8adb753d718f1", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -29,15 +29,15 @@ pub unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n  * reinterpret_cast on pointer types.\n  */\n #[inline(always)]\n-pub unsafe fn forget<T>(thing: T) { rusti::forget(move thing); }\n+pub unsafe fn forget<T>(thing: T) { rusti::forget(thing); }\n \n /**\n  * Force-increment the reference count on a shared box. If used\n  * carelessly, this can leak the box. Use this in conjunction with transmute\n  * and/or reinterpret_cast when such calls would otherwise scramble a box's\n  * reference count\n  */\n-pub unsafe fn bump_box_refcount<T>(t: @T) { forget(move t); }\n+pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n \n /**\n  * Transform a value of one type into a value of another type.\n@@ -50,23 +50,23 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(move t); }\n #[inline(always)]\n pub unsafe fn transmute<L, G>(thing: L) -> G {\n     let newthing: G = reinterpret_cast(&thing);\n-    forget(move thing);\n-    move newthing\n+    forget(thing);\n+    newthing\n }\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n-pub unsafe fn transmute_mut<T>(ptr: &a/T) -> &a/mut T { transmute(move ptr) }\n+pub unsafe fn transmute_mut<T>(ptr: &a/T) -> &a/mut T { transmute(ptr) }\n \n /// Coerce a mutable reference to be immutable.\n #[inline(always)]\n pub unsafe fn transmute_immut<T>(ptr: &a/mut T) -> &a/T {\n-    transmute(move ptr)\n+    transmute(ptr)\n }\n \n /// Coerce a borrowed pointer to have an arbitrary associated region.\n #[inline(always)]\n-pub unsafe fn transmute_region<T>(ptr: &a/T) -> &b/T { transmute(move ptr) }\n+pub unsafe fn transmute_region<T>(ptr: &a/T) -> &b/T { transmute(ptr) }\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n@@ -83,7 +83,7 @@ pub unsafe fn transmute_immut_unsafe<T>(ptr: *const T) -> *T {\n /// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n #[inline(always)]\n pub unsafe fn transmute_mut_region<T>(ptr: &a/mut T) -> &b/mut T {\n-    transmute(move ptr)\n+    transmute(ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n@@ -132,9 +132,9 @@ pub mod tests {\n         use managed::raw::BoxRepr;\n         unsafe {\n             let x = @100u8;\n-            let x: *BoxRepr = transmute(move x);\n+            let x: *BoxRepr = transmute(x);\n             assert (*x).data == 100;\n-            let _x: @int = transmute(move x);\n+            let _x: @int = transmute(x);\n         }\n     }\n "}, {"sha": "09de94f1aaf7ddf1a76b5b5abd1b32124b0a0b36", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -493,7 +493,7 @@ impl<T: Copy> DList<T> {\n                 v[index] = *data;\n             }\n         }\n-        move v\n+        v\n     }\n }\n "}, {"sha": "03a921d7ea504f8d2c20673fc15b13663bccc544", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -67,18 +67,18 @@ pub pure fn DVec<A>() -> DVec<A> {\n \n /// Creates a new dvec with a single element\n pub pure fn from_elem<A>(e: A) -> DVec<A> {\n-    DVec {mut data: ~[move e]}\n+    DVec {mut data: ~[e]}\n }\n \n /// Creates a new dvec with the contents of a vector\n pub pure fn from_vec<A>(v: ~[A]) -> DVec<A> {\n-    DVec {mut data: move v}\n+    DVec {mut data: v}\n }\n \n /// Consumes the vector and returns its contents\n pub pure fn unwrap<A>(d: DVec<A>) -> ~[A] {\n-    let DVec {data: v} = move d;\n-    move v\n+    let DVec {data: v} = d;\n+    v\n }\n \n priv impl<A> DVec<A> {\n@@ -99,14 +99,14 @@ priv impl<A> DVec<A> {\n             data <-> self.data;\n             let data_ptr: *() = cast::reinterpret_cast(&data);\n             if data_ptr.is_null() { fail!(~\"Recursive use of dvec\"); }\n-            return f(move data);\n+            return f(data);\n         }\n     }\n \n     #[inline(always)]\n     fn give_back(data: ~[A]) {\n         unsafe {\n-            self.data = move data;\n+            self.data = data;\n         }\n     }\n \n@@ -130,7 +130,7 @@ impl<A> DVec<A> {\n      */\n     #[inline(always)]\n     fn swap(f: &fn(v: ~[A]) -> ~[A]) {\n-        self.check_out(|v| self.give_back(f(move v)))\n+        self.check_out(|v| self.give_back(f(v)))\n     }\n \n     /**\n@@ -141,7 +141,7 @@ impl<A> DVec<A> {\n     #[inline(always)]\n     fn swap_mut(f: &fn(v: ~[mut A]) -> ~[mut A]) {\n         do self.swap |v| {\n-            vec::cast_from_mut(f(vec::cast_to_mut(move v)))\n+            vec::cast_from_mut(f(vec::cast_to_mut(v)))\n         }\n     }\n \n@@ -156,16 +156,16 @@ impl<A> DVec<A> {\n     #[inline(always)]\n     fn set(w: ~[A]) {\n         self.check_not_borrowed();\n-        self.data = move w;\n+        self.data = w;\n     }\n \n     /// Remove and return the last element\n     fn pop() -> A {\n         do self.check_out |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             let result = v.pop();\n-            self.give_back(move v);\n-            move result\n+            self.give_back(v);\n+            result\n         }\n     }\n \n@@ -176,53 +176,53 @@ impl<A> DVec<A> {\n             data <-> self.data;\n             let data_ptr: *() = cast::reinterpret_cast(&data);\n             if data_ptr.is_null() { fail!(~\"Recursive use of dvec\"); }\n-            self.data = move ~[move t];\n-            self.data.push_all_move(move data);\n+            self.data = ~[t];\n+            self.data.push_all_move(data);\n         }\n     }\n \n     /// Append a single item to the end of the list\n     #[inline(always)]\n     fn push(t: A) {\n         self.check_not_borrowed();\n-        self.data.push(move t);\n+        self.data.push(t);\n     }\n \n     /// Remove and return the first element\n     fn shift() -> A {\n         do self.check_out |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             let result = v.shift();\n-            self.give_back(move v);\n-            move result\n+            self.give_back(v);\n+            result\n         }\n     }\n \n     /// Reverse the elements in the list, in place\n     fn reverse() {\n         do self.check_out |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             vec::reverse(v);\n-            self.give_back(move v);\n+            self.give_back(v);\n         }\n     }\n \n     /// Gives access to the vector as a slice with immutable contents\n     fn borrow<R>(op: fn(x: &[A]) -> R) -> R {\n         do self.check_out |v| {\n             let result = op(v);\n-            self.give_back(move v);\n-            move result\n+            self.give_back(v);\n+            result\n         }\n     }\n \n     /// Gives access to the vector as a slice with mutable contents\n     fn borrow_mut<R>(op: fn(x: &[mut A]) -> R) -> R {\n         do self.check_out |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             let result = op(v);\n-            self.give_back(move v);\n-            move result\n+            self.give_back(v);\n+            result\n         }\n     }\n }\n@@ -240,15 +240,15 @@ impl<A: Copy> DVec<A> {\n     /// Appends elements from `from_idx` to `to_idx` (exclusive)\n     fn push_slice(ts: &[const A], from_idx: uint, to_idx: uint) {\n         do self.swap |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             let new_len = vec::len(v) + to_idx - from_idx;\n             vec::reserve(&mut v, new_len);\n             let mut i = from_idx;\n             while i < to_idx {\n                 v.push(ts[i]);\n                 i += 1u;\n             }\n-            move v\n+            v\n         }\n     }\n \n@@ -265,7 +265,7 @@ impl<A: Copy> DVec<A> {\n              none { v }\n              Some(h) {\n                let len = v.len() + h;\n-               let mut v = move v;\n+               let mut v = v;\n                vec::reserve(v, len);\n                v\n             }\n@@ -286,8 +286,8 @@ impl<A: Copy> DVec<A> {\n         unsafe {\n             do self.check_out |v| {\n                 let w = copy v;\n-                self.give_back(move v);\n-                move w\n+                self.give_back(v);\n+                w\n             }\n         }\n     }\n@@ -312,9 +312,9 @@ impl<A: Copy> DVec<A> {\n      */\n     fn grow_set_elt(idx: uint, initval: &A, val: A) {\n         do self.swap |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             v.grow_set(idx, initval, val);\n-            move v\n+            v\n         }\n     }\n \n@@ -340,7 +340,7 @@ impl<A: Copy> DVec<A> {\n             for vec::rev_each(v) |e| {\n                 if !f(e) { break; }\n             }\n-            move v\n+            v\n         }\n     }\n \n@@ -353,7 +353,7 @@ impl<A: Copy> DVec<A> {\n             for vec::rev_eachi(v) |i, e| {\n                 if !f(i, e) { break; }\n             }\n-            move v\n+            v\n         }\n     }\n }"}, {"sha": "72aecdd82954fe18e42ab2a25849d80d119c5e89", "filename": "src/libcore/either.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -84,7 +84,7 @@ pub fn partition<T, U>(eithers: ~[Either<T, U>])\n           Right(r) => rights.push(r)\n         }\n     }\n-    return (move lefts, move rights);\n+    return (lefts, rights);\n }\n \n #[inline(always)]\n@@ -131,8 +131,8 @@ pub pure fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n     //! Retrieves the value in the left branch. Fails if the either is Right.\n \n-    match move eith {\n-        Left(move x) => move x,\n+    match eith {\n+        Left(x) => x,\n         Right(_) => fail!(~\"either::unwrap_left Right\")\n     }\n }\n@@ -141,8 +141,8 @@ pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     //! Retrieves the value in the right branch. Fails if the either is Left.\n \n-    match move eith {\n-        Right(move x) => move x,\n+    match eith {\n+        Right(x) => x,\n         Left(_) => fail!(~\"either::unwrap_right Left\")\n     }\n }"}, {"sha": "36ea67ea6954e8ace732c3a65022a9bb9807b093", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -510,7 +510,7 @@ pub mod rt {\n                 unsafe { str::unshift_char(&mut s, ' ') };\n             }\n         }\n-        return unsafe { pad(cv, move s, PadSigned) };\n+        return unsafe { pad(cv, s, PadSigned) };\n     }\n     pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n@@ -522,7 +522,7 @@ pub mod rt {\n               TyBits => uint_to_str_prec(u, 2, prec),\n               TyOctal => uint_to_str_prec(u, 8, prec)\n             };\n-        return unsafe { pad(cv, move rs, PadUnsigned) };\n+        return unsafe { pad(cv, rs, PadUnsigned) };\n     }\n     pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n@@ -532,7 +532,7 @@ pub mod rt {\n     }\n     pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n-        return unsafe { pad(cv, move s, PadNozero) };\n+        return unsafe { pad(cv, s, PadNozero) };\n     }\n     pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n@@ -545,7 +545,7 @@ pub mod rt {\n             s.to_owned()\n           }\n         };\n-        return unsafe { pad(cv, move unpadded, PadNozero) };\n+        return unsafe { pad(cv, unpadded, PadNozero) };\n     }\n     pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n@@ -560,7 +560,7 @@ pub mod rt {\n                 s = ~\" \" + s;\n             }\n         }\n-        return unsafe { pad(cv, move s, PadFloat) };\n+        return unsafe { pad(cv, s, PadFloat) };\n     }\n     pub pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n         let s = sys::log_str(v);\n@@ -589,7 +589,7 @@ pub mod rt {\n                     let diff = prec - len;\n                     let pad = str::from_chars(vec::from_elem(diff, '0'));\n                     pad + s\n-                } else { move s }\n+                } else { s }\n             };\n     }\n     pub pure fn get_int_precision(cv: Conv) -> uint {\n@@ -603,13 +603,13 @@ pub mod rt {\n     pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n     pub fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n-        let mut s = move s; // sadtimes\n+        let mut s = s; // sadtimes\n         let uwidth : uint = match cv.width {\n-          CountImplied => return (move s),\n+          CountImplied => return (s),\n           CountIs(width) => { width as uint }\n         };\n         let strlen = str::char_len(s);\n-        if uwidth <= strlen { return (move s); }\n+        if uwidth <= strlen { return (s); }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {"}, {"sha": "c47e27e75d950709fcb6c33e22c4ecf683c6dfd2", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -50,7 +50,7 @@ pub fn deflate_bytes(bytes: &[const u8]) -> ~[u8] {\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n-            move out\n+            out\n         }\n     }\n }\n@@ -68,7 +68,7 @@ pub fn inflate_bytes(bytes: &[const u8]) -> ~[u8] {\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n-            move out\n+            out\n         }\n     }\n }"}, {"sha": "40a9de0cea349405e36a290d3850450e43d4488c", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -183,7 +183,7 @@ fn SipState(key0: u64, key1: u64) -> SipState {\n         mut ntail : 0u,\n     };\n     (&state).reset();\n-    move state\n+    state\n }\n \n \n@@ -352,7 +352,7 @@ impl Streaming for &SipState {\n         for vec::each(r) |b| {\n             s += uint::to_str_radix(*b as uint, 16u);\n         }\n-        move s\n+        s\n     }\n \n     #[inline(always)]\n@@ -447,7 +447,7 @@ pub fn test_siphash() {\n         for vec::each(*r) |b| {\n             s += uint::to_str_radix(*b as uint, 16u);\n         }\n-        move s\n+        s\n     }\n \n     while t < 64 {"}, {"sha": "34a9f6a8588d30916636cd8f171fed9eb0581180", "filename": "src/libcore/io.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -178,7 +178,7 @@ impl<T: Reader> ReaderUtil for T {\n         let count = self.read(bytes, len);\n \n         unsafe { vec::raw::set_len(&mut bytes, count); }\n-        move bytes\n+        bytes\n     }\n \n     fn read_line(&self) -> ~str {\n@@ -249,7 +249,7 @@ impl<T: Reader> ReaderUtil for T {\n                 bytes = vec::slice(bytes, offset, bytes.len());\n             }\n         }\n-        move chars\n+        chars\n     }\n \n     fn read_char(&self) -> char {\n@@ -273,7 +273,7 @@ impl<T: Reader> ReaderUtil for T {\n     fn read_whole_stream(&self) -> ~[u8] {\n         let mut bytes: ~[u8] = ~[];\n         while !self.eof() { bytes.push_all(self.read_bytes(2048u)); }\n-        move bytes\n+        bytes\n     }\n \n     fn each_byte(&self, it: fn(int) -> bool) {\n@@ -999,7 +999,7 @@ pub struct BytesWriter {\n impl Writer for BytesWriter {\n     fn write(&self, v: &[const u8]) {\n         do self.bytes.swap |bytes| {\n-            let mut bytes = move bytes;\n+            let mut bytes = bytes;\n             let v_len = v.len();\n             let bytes_len = bytes.len();\n \n@@ -1014,7 +1014,7 @@ impl Writer for BytesWriter {\n \n             self.pos += v_len;\n \n-            move bytes\n+            bytes\n         }\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n@@ -1035,7 +1035,7 @@ pub pure fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n     // FIXME (#3758): This should not be needed.\n-    unsafe { wr.bytes.check_out(|bytes| move bytes) }\n+    unsafe { wr.bytes.check_out(|bytes| bytes) }\n }\n \n pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n@@ -1048,7 +1048,7 @@ pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n     }\n     assert str::is_utf8(v);\n \n-    unsafe { move ::cast::transmute(move v) }\n+    unsafe { ::cast::transmute(v) }\n }\n \n // Utility functions\n@@ -1126,7 +1126,7 @@ pub mod fsync {\n \n     pub fn Res<t: Copy>(arg: Arg<t>) -> Res<t>{\n         Res {\n-            arg: move arg\n+            arg: arg\n         }\n     }\n "}, {"sha": "9a8f01baed1ebd8ea7eb9b5b615d28addd49e09d", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -42,7 +42,7 @@ impl<A> iter::ExtendedIter<A> for IMPL_T<A> {\n     }\n     #[inline(always)]\n     pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n-        iter::foldl(self, move b0, blk)\n+        iter::foldl(self, b0, blk)\n     }\n     #[inline(always)]\n     pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {"}, {"sha": "986aa18ad4ab18274de18e2c9a3fc26f926df44c", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -25,7 +25,7 @@ mod inst {\n         unsafe {\n             do self.swap |v| {\n                 v.each(f);\n-                move v\n+                v\n             }\n         }\n     }"}, {"sha": "25cdb11456a06a3ab043879fabb197b828034ca0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -154,11 +154,11 @@ pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n                                       blk: fn(&B, &A) -> B)\n     -> B {\n-    let mut b = move b0;\n+    let mut b = b0;\n     for self.each |a| {\n         b = blk(&b, a);\n     }\n-    move b\n+    b\n }\n \n #[inline(always)]\n@@ -215,12 +215,12 @@ pub pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ < *b => {\n-             *(move a)\n+             *(a)\n           }\n           _ => Some(*b)\n         }\n     } {\n-        Some(move val) => val,\n+        Some(val) => val,\n         None => fail!(~\"min called on empty iterator\")\n     }\n }\n@@ -230,12 +230,12 @@ pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ > *b => {\n-              *(move a)\n+              *(a)\n           }\n           _ => Some(*b)\n         }\n     } {\n-        Some(move val) => val,\n+        Some(val) => val,\n         None => fail!(~\"max called on empty iterator\")\n     }\n }"}, {"sha": "1fb855520ba49d92d15b740c813fc3c4d25e8fb8", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -32,15 +32,15 @@ struct Data<T> {\n pub type Mut<T> = Data<T>;\n \n pub fn Mut<T>(t: T) -> Mut<T> {\n-    Data {value: move t, mode: ReadOnly}\n+    Data {value: t, mode: ReadOnly}\n }\n \n pub fn unwrap<T>(m: Mut<T>) -> T {\n     // Borrowck should prevent us from calling unwrap while the value\n     // is in use, as that would be a move from a borrowed value.\n     assert (m.mode as uint) == (ReadOnly as uint);\n-    let Data {value: move value, mode: _} = move m;\n-    move value\n+    let Data {value: value, mode: _} = m;\n+    value\n }\n \n impl<T> Data<T> {"}, {"sha": "a90364c7d8cedb537cee6c70eab40be5c4398317", "filename": "src/libcore/option.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -33,8 +33,8 @@ match msg {\n }\n \n // Remove the contained string, destroying the Option\n-let unwrapped_msg = match move msg {\n-    Some(move m) => m,\n+let unwrapped_msg = match msg {\n+    Some(m) => m,\n     None => ~\"default message\"\n };\n ~~~\n@@ -126,8 +126,8 @@ pub pure fn chain<T, U>(opt: Option<T>,\n      * function that returns an option.\n      */\n \n-    match move opt {\n-        Some(move t) => f(move t),\n+    match opt {\n+        Some(t) => f(t),\n         None => None\n     }\n }\n@@ -148,19 +148,19 @@ pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n     /*!\n      * Returns the leftmost Some() value, or None if both are None.\n      */\n-    match move opta {\n-        Some(move opta) => Some(move opta),\n-        _ => move optb\n+    match opta {\n+        Some(opta) => Some(opta),\n+        _ => optb\n     }\n }\n \n #[inline(always)]\n pub pure fn while_some<T>(x: Option<T>, blk: fn(v: T) -> Option<T>) {\n     //! Applies a function zero or more times until the result is none.\n \n-    let mut opt = move x;\n+    let mut opt = x;\n     while opt.is_some() {\n-        opt = blk(unwrap(move opt));\n+        opt = blk(unwrap(opt));\n     }\n }\n \n@@ -197,7 +197,7 @@ pub pure fn map_default<T, U>(opt: &r/Option<T>, def: U,\n                               f: fn(&r/T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n-    match *opt { None => move def, Some(ref t) => f(t) }\n+    match *opt { None => def, Some(ref t) => f(t) }\n }\n \n #[inline(always)]\n@@ -224,8 +224,8 @@ pub pure fn unwrap<T>(opt: Option<T>) -> T {\n     Instead, prefer to use pattern matching and handle the `None`\n     case explicitly.\n      */\n-    match move opt {\n-        Some(move x) => move x,\n+    match opt {\n+        Some(x) => x,\n         None => fail!(~\"option::unwrap none\")\n     }\n }\n@@ -247,8 +247,8 @@ pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n #[inline(always)]\n pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n-    match move opt {\n-        Some(move val) => val,\n+    match opt {\n+        Some(val) => val,\n         None => fail!(reason.to_owned()),\n     }\n }\n@@ -285,7 +285,7 @@ impl<T> Option<T> {\n     /// Applies a function to the contained value or returns a default\n     #[inline(always)]\n     pure fn map_default<U>(&self, def: U, f: fn(&self/T) -> U) -> U {\n-        map_default(self, move def, f)\n+        map_default(self, def, f)\n     }\n \n     /// As `map_default`, but consumes the option and gives `f`\n@@ -402,8 +402,8 @@ impl<T: Copy Zero> Option<T> {\n fn test_unwrap_ptr() {\n     let x = ~0;\n     let addr_x = ptr::addr_of(&(*x));\n-    let opt = Some(move x);\n-    let y = unwrap(move opt);\n+    let opt = Some(x);\n+    let y = unwrap(opt);\n     let addr_y = ptr::addr_of(&(*y));\n     assert addr_x == addr_y;\n }\n@@ -412,8 +412,8 @@ fn test_unwrap_ptr() {\n fn test_unwrap_str() {\n     let x = ~\"test\";\n     let addr_x = str::as_buf(x, |buf, _len| buf);\n-    let opt = Some(move x);\n-    let y = unwrap(move opt);\n+    let opt = Some(x);\n+    let y = unwrap(opt);\n     let addr_y = str::as_buf(y, |buf, _len| buf);\n     assert addr_x == addr_y;\n }\n@@ -434,8 +434,8 @@ fn test_unwrap_resource() {\n     let i = @mut 0;\n     {\n         let x = R(i);\n-        let opt = Some(move x);\n-        let _y = unwrap(move opt);\n+        let opt = Some(x);\n+        let _y = unwrap(opt);\n     }\n     assert *i == 1;\n }"}, {"sha": "f2401589cd81dfbc70606fad5b37d6ed55b509d6", "filename": "src/libcore/os.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -171,7 +171,7 @@ pub fn env() -> ~[(~str,~str)] {\n                 assert vec::len(vs) == 2u;\n                 pairs.push((copy vs[0], copy vs[1]));\n             }\n-            move pairs\n+            pairs\n         }\n     }\n }\n@@ -482,7 +482,7 @@ pub fn tmpdir() -> Path {\n \n     fn getenv_nonempty(v: &str) -> Option<Path> {\n         match getenv(v) {\n-            Some(move x) =>\n+            Some(x) =>\n                 if str::is_empty(x) {\n                     None\n                 } else {\n@@ -915,7 +915,7 @@ unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n     for uint::range(0, argc as uint) |i| {\n         vec::push(&mut args, str::raw::from_c_str(*argv.offset(i)));\n     }\n-    move args\n+    args\n }\n \n /**\n@@ -1137,7 +1137,7 @@ mod tests {\n         let rng: rand::Rng = rand::Rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n         assert getenv(n).is_none();\n-        move n\n+        n\n     }\n \n     #[test]\n@@ -1171,7 +1171,7 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, s);\n         log(debug, copy s);\n-        assert getenv(n) == option::Some(move s);\n+        assert getenv(n) == option::Some(s);\n     }\n \n     #[test]\n@@ -1197,7 +1197,7 @@ mod tests {\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n-            assert v2.is_none() || v2 == option::Some(move v);\n+            assert v2.is_none() || v2 == option::Some(v);\n         }\n     }\n \n@@ -1210,7 +1210,7 @@ mod tests {\n         assert !vec::contains(e, &(copy n, ~\"VALUE\"));\n \n         e = env();\n-        assert vec::contains(e, &(move n, ~\"VALUE\"));\n+        assert vec::contains(e, &(n, ~\"VALUE\"));\n     }\n \n     #[test]"}, {"sha": "531ce95d067be11232276b66d8c225975c3e0c9d", "filename": "src/libcore/path.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -245,7 +245,7 @@ impl Path {\n                 let mut st = stat::arch::default_stat();\n                 let r = libc::stat(buf, &mut st);\n \n-                if r == 0 { Some(move st) } else { None }\n+                if r == 0 { Some(st) } else { None }\n             }\n         }\n     }\n@@ -257,7 +257,7 @@ impl Path {\n                 let mut st = stat::arch::default_stat();\n                 let r = libc::lstat(buf, &mut st);\n \n-                if r == 0 { Some(move st) } else { None }\n+                if r == 0 { Some(st) } else { None }\n             }\n         }\n     }\n@@ -381,7 +381,7 @@ impl GenericPath for PosixPath {\n         let mut components = str::split_nonempty(s, |c| c == '/');\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n         return PosixPath { is_absolute: is_absolute,\n-                           components: move components }\n+                           components: components }\n     }\n \n     pure fn dirname() -> ~str {\n@@ -390,7 +390,7 @@ impl GenericPath for PosixPath {\n             if s.len() == 0 {\n                 ~\".\"\n             } else {\n-                move s\n+                s\n             }\n         }\n     }\n@@ -430,7 +430,7 @@ impl GenericPath for PosixPath {\n         let dpath = PosixPath(d);\n         match self.filename() {\n           Some(ref f) => dpath.push(*f),\n-          None => move dpath\n+          None => dpath\n         }\n     }\n \n@@ -477,7 +477,7 @@ impl GenericPath for PosixPath {\n           Some(ref f) => ~[copy *f]\n         };\n         return PosixPath { is_absolute: false,\n-                           components: move cs }\n+                           components: cs }\n     }\n \n     pure fn push_rel(other: &PosixPath) -> PosixPath {\n@@ -491,17 +491,17 @@ impl GenericPath for PosixPath {\n             let mut ss = str::split_nonempty(\n                 *e,\n                 |c| windows::is_sep(c as u8));\n-            unsafe { v.push_all_move(move ss); }\n+            unsafe { v.push_all_move(ss); }\n         }\n         PosixPath { is_absolute: self.is_absolute,\n-                    components: move v }\n+                    components: v }\n     }\n \n     pure fn push(s: &str) -> PosixPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n-        unsafe { v.push_all_move(move ss); }\n-        PosixPath { components: move v, ..copy self }\n+        unsafe { v.push_all_move(ss); }\n+        PosixPath { components: v, ..copy self }\n     }\n \n     pure fn pop() -> PosixPath {\n@@ -511,7 +511,7 @@ impl GenericPath for PosixPath {\n         }\n         return PosixPath {\n             is_absolute: self.is_absolute,\n-            components: move cs\n+            components: cs\n         }\n                           //..self }\n     }\n@@ -577,10 +577,10 @@ impl GenericPath for WindowsPath {\n         let mut components =\n             str::split_nonempty(rest, |c| windows::is_sep(c as u8));\n         let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n-        return WindowsPath { host: move host,\n-                             device: move device,\n+        return WindowsPath { host: host,\n+                             device: device,\n                              is_absolute: is_absolute,\n-                             components: move components }\n+                             components: components }\n     }\n \n     pure fn dirname() -> ~str {\n@@ -589,7 +589,7 @@ impl GenericPath for WindowsPath {\n             if s.len() == 0 {\n                 ~\".\"\n             } else {\n-                move s\n+                s\n             }\n         }\n     }\n@@ -629,7 +629,7 @@ impl GenericPath for WindowsPath {\n         let dpath = WindowsPath(d);\n         match self.filename() {\n           Some(ref f) => dpath.push(*f),\n-          None => move dpath\n+          None => dpath\n         }\n     }\n \n@@ -677,7 +677,7 @@ impl GenericPath for WindowsPath {\n         return WindowsPath { host: None,\n                              device: None,\n                              is_absolute: false,\n-                             components: move cs }\n+                             components: cs }\n     }\n \n     pure fn push_rel(other: &WindowsPath) -> WindowsPath {\n@@ -691,22 +691,22 @@ impl GenericPath for WindowsPath {\n             let mut ss = str::split_nonempty(\n                 *e,\n                 |c| windows::is_sep(c as u8));\n-            unsafe { v.push_all_move(move ss); }\n+            unsafe { v.push_all_move(ss); }\n         }\n         // tedious, but as-is, we can't use ..self\n         return WindowsPath {\n             host: copy self.host,\n             device: copy self.device,\n             is_absolute: self.is_absolute,\n-            components: move v\n+            components: v\n         }\n     }\n \n     pure fn push(s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n-        unsafe { v.push_all_move(move ss); }\n-        return WindowsPath { components: move v, ..copy self }\n+        unsafe { v.push_all_move(ss); }\n+        return WindowsPath { components: v, ..copy self }\n     }\n \n     pure fn pop() -> WindowsPath {\n@@ -718,7 +718,7 @@ impl GenericPath for WindowsPath {\n             host: copy self.host,\n             device: copy self.device,\n             is_absolute: self.is_absolute,\n-            components: move cs\n+            components: cs\n         }\n     }\n \n@@ -748,7 +748,7 @@ pub pure fn normalize(components: &[~str]) -> ~[~str] {\n             }\n         }\n     }\n-    move cs\n+    cs\n }\n \n // Various windows helpers, and tests for the impl.\n@@ -771,7 +771,7 @@ pub mod windows {\n                 if s[i] == '\\\\' as u8 {\n                     let pre = s.slice(2, i);\n                     let rest = s.slice(i, s.len());\n-                    return Some((move pre, move rest));\n+                    return Some((pre, rest));\n                 }\n                 i += 1;\n             }\n@@ -789,7 +789,7 @@ pub mod windows {\n                 } else {\n                     s.slice(2, s.len())\n                 };\n-                return Some((s.slice(0,1), move rest));\n+                return Some((s.slice(0,1), rest));\n             }\n             None\n         }"}, {"sha": "b9e07135f2c9b7579c798844a15d7c3cfdac3d48", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -101,7 +101,7 @@ use vec;\n const SPIN_COUNT: uint = 0;\n \n macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = move *ptr::addr_of(&($x)); move y } )\n+    { $x:expr } => ( unsafe { let y = *ptr::addr_of(&($x)); y } )\n )\n \n #[doc(hidden)]\n@@ -233,15 +233,15 @@ fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n     unsafe {\n         b.data.header.buffer = reinterpret_cast(&b);\n     }\n-    move b\n+    b\n }\n \n #[doc(hidden)]\n pub fn packet<T>() -> *Packet<T> {\n     let b = unibuffer();\n     let p = ptr::addr_of(&(b.data));\n     // We'll take over memory management from here.\n-    unsafe { forget(move b) }\n+    unsafe { forget(b) }\n     p\n }\n \n@@ -252,7 +252,7 @@ pub fn entangle_buffer<T: Owned, Tstart: Owned>(\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n {\n     let p = init(unsafe { reinterpret_cast(&buffer) }, &buffer.data);\n-    unsafe { forget(move buffer) }\n+    unsafe { forget(buffer) }\n     (SendPacketBuffered(p), RecvPacketBuffered(p))\n }\n \n@@ -295,7 +295,7 @@ pub fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n     // It might be worth making both acquire and release versions of\n     // this.\n     unsafe {\n-        transmute(rusti::atomic_xchg(transmute(move dst), src as int))\n+        transmute(rusti::atomic_xchg(transmute(dst), src as int))\n     }\n }\n \n@@ -335,14 +335,14 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n #[doc(hidden)]\n fn swap_state_acq(dst: &mut State, src: State) -> State {\n     unsafe {\n-        transmute(rusti::atomic_xchg_acq(transmute(move dst), src as int))\n+        transmute(rusti::atomic_xchg_acq(transmute(dst), src as int))\n     }\n }\n \n #[doc(hidden)]\n fn swap_state_rel(dst: &mut State, src: State) -> State {\n     unsafe {\n-        transmute(rusti::atomic_xchg_rel(transmute(move dst), src as int))\n+        transmute(rusti::atomic_xchg_rel(transmute(dst), src as int))\n     }\n }\n \n@@ -368,7 +368,7 @@ struct BufferResource<T> {\n                 // go go gadget drop glue\n             }\n             else {\n-                forget(move b)\n+                forget(b)\n             }\n         }\n     }\n@@ -381,7 +381,7 @@ fn BufferResource<T>(b: ~Buffer<T>) -> BufferResource<T> {\n \n     BufferResource {\n         // tjc: ????\n-        buffer: move b\n+        buffer: b\n     }\n }\n \n@@ -392,7 +392,7 @@ pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n     let p = unsafe { &*p_ };\n     assert ptr::addr_of(&(p.header)) == header;\n     assert p.payload.is_none();\n-    p.payload = move Some(move payload);\n+    p.payload = Some(payload);\n     let old_state = swap_state_rel(&mut p.header.state, Full);\n     match old_state {\n         Empty => {\n@@ -434,7 +434,7 @@ Fails if the sender closes the connection.\n */\n pub fn recv<T: Owned, Tbuffer: Owned>(\n     p: RecvPacketBuffered<T, Tbuffer>) -> T {\n-    try_recv(move p).expect(\"connection closed\")\n+    try_recv(p).expect(\"connection closed\")\n }\n \n /** Attempts to receive a message from a pipe.\n@@ -474,7 +474,7 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n         let mut payload = None;\n         payload <-> p.payload;\n         p.header.state = Empty;\n-        return Some(option::unwrap(move payload))\n+        return Some(option::unwrap(payload))\n       },\n       Terminated => return None,\n       _ => {}\n@@ -532,7 +532,7 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n                 }\n             }\n             p.header.state = Empty;\n-            return Some(option::unwrap(move payload))\n+            return Some(option::unwrap(payload))\n           }\n           Terminated => {\n             // This assert detects when we've accidentally unsafely\n@@ -723,8 +723,8 @@ pub fn select2<A: Owned, Ab: Owned, B: Owned, Bb: Owned>(\n     let i = wait_many([a.header(), b.header()]);\n \n     match i {\n-      0 => Left((try_recv(move a), move b)),\n-      1 => Right((move a, try_recv(move b))),\n+      0 => Left((try_recv(a), b)),\n+      1 => Right((a, try_recv(b))),\n       _ => fail!(~\"select2 return an invalid packet\")\n     }\n }\n@@ -761,10 +761,10 @@ pub fn select<T: Owned, Tb: Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n     -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n-    let mut remaining = move endpoints;\n+    let mut remaining = endpoints;\n     let port = remaining.swap_remove(ready);\n-    let result = try_recv(move port);\n-    (ready, move result, move remaining)\n+    let result = try_recv(port);\n+    (ready, result, remaining)\n }\n \n /** The sending end of a pipe. It can be used to send exactly one\n@@ -791,7 +791,7 @@ impl<T:Owned,Tbuffer:Owned> ::ops::Drop for SendPacketBuffered<T,Tbuffer> {\n         if self.p != None {\n             let mut p = None;\n             p <-> self.p;\n-            sender_terminate(option::unwrap(move p))\n+            sender_terminate(option::unwrap(p))\n         }\n         //unsafe { error!(\"send_drop: %?\",\n         //                if self.buffer == none {\n@@ -816,7 +816,7 @@ impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n     fn unwrap() -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n-        option::unwrap(move p)\n+        option::unwrap(p)\n     }\n \n     pure fn header() -> *PacketHeader {\n@@ -835,7 +835,7 @@ impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n         //error!(\"send reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n-        option::unwrap(move tmp)\n+        option::unwrap(tmp)\n     }\n }\n \n@@ -860,7 +860,7 @@ impl<T:Owned, Tbuffer:Owned> ::ops::Drop for RecvPacketBuffered<T,Tbuffer> {\n         if self.p != None {\n             let mut p = None;\n             p <-> self.p;\n-            receiver_terminate(option::unwrap(move p))\n+            receiver_terminate(option::unwrap(p))\n         }\n         //unsafe { error!(\"recv_drop: %?\",\n         //                if self.buffer == none {\n@@ -873,14 +873,14 @@ impl<T: Owned, Tbuffer: Owned> RecvPacketBuffered<T, Tbuffer> {\n     fn unwrap() -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n-        option::unwrap(move p)\n+        option::unwrap(p)\n     }\n \n     fn reuse_buffer() -> BufferResource<Tbuffer> {\n         //error!(\"recv reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n-        option::unwrap(move tmp)\n+        option::unwrap(tmp)\n     }\n }\n \n@@ -933,14 +933,14 @@ pub fn spawn_service<T: Owned, Tb: Owned>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut Some(move server);\n-    do task::spawn |move service, move server| {\n+    let server = ~mut Some(server);\n+    do task::spawn || {\n         let mut server_ = None;\n         server_ <-> *server;\n-        service(option::unwrap(move server_))\n+        service(option::unwrap(server_))\n     }\n \n-    move client\n+    client\n }\n \n /** Like `spawn_service_recv`, but for protocols that start in the\n@@ -957,14 +957,14 @@ pub fn spawn_service_recv<T: Owned, Tb: Owned>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut Some(move server);\n-    do task::spawn |move service, move server| {\n+    let server = ~mut Some(server);\n+    do task::spawn || {\n         let mut server_ = None;\n         server_ <-> *server;\n-        service(option::unwrap(move server_))\n+        service(option::unwrap(server_))\n     }\n \n-    move client\n+    client\n }\n \n // Streams - Make pipes a little easier in general.\n@@ -1041,7 +1041,7 @@ impl<T: Owned> GenericChan<T> for Chan<T> {\n         let mut endp = None;\n         endp <-> self.endp;\n         self.endp = Some(\n-            streamp::client::data(unwrap(move endp), move x))\n+            streamp::client::data(unwrap(endp), x))\n     }\n }\n \n@@ -1050,9 +1050,9 @@ impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n     fn try_send(x: T) -> bool {\n         let mut endp = None;\n         endp <-> self.endp;\n-        match move streamp::client::try_data(unwrap(move endp), move x) {\n-            Some(move next) => {\n-                self.endp = Some(move next);\n+        match streamp::client::try_data(unwrap(endp), x) {\n+            Some(next) => {\n+                self.endp = Some(next);\n                 true\n             }\n             None => false\n@@ -1064,18 +1064,18 @@ impl<T: Owned> GenericPort<T> for Port<T> {\n     fn recv() -> T {\n         let mut endp = None;\n         endp <-> self.endp;\n-        let streamp::data(x, endp) = pipes::recv(unwrap(move endp));\n-        self.endp = Some(move endp);\n-        move x\n+        let streamp::data(x, endp) = pipes::recv(unwrap(endp));\n+        self.endp = Some(endp);\n+        x\n     }\n \n     fn try_recv() -> Option<T> {\n         let mut endp = None;\n         endp <-> self.endp;\n-        match move pipes::try_recv(unwrap(move endp)) {\n-          Some(streamp::data(move x, move endp)) => {\n-            self.endp = Some(move endp);\n-            Some(move x)\n+        match pipes::try_recv(unwrap(endp)) {\n+          Some(streamp::data(x, endp)) => {\n+            self.endp = Some(endp);\n+            Some(x)\n           }\n           None => None\n         }\n@@ -1122,13 +1122,13 @@ pub fn PortSet<T: Owned>() -> PortSet<T>{\n impl<T: Owned> PortSet<T> {\n \n     fn add(port: pipes::Port<T>) {\n-        self.ports.push(move port)\n+        self.ports.push(port)\n     }\n \n     fn chan() -> Chan<T> {\n         let (po, ch) = stream();\n-        self.add(move po);\n-        move ch\n+        self.add(po);\n+        ch\n     }\n }\n \n@@ -1142,9 +1142,9 @@ impl<T: Owned> GenericPort<T> for PortSet<T> {\n         ports <-> self.ports;\n         while result.is_none() && ports.len() > 0 {\n             let i = wait_many(ports);\n-            match move ports[i].try_recv() {\n-                Some(move m) => {\n-                  result = Some(move m);\n+            match ports[i].try_recv() {\n+                Some(m) => {\n+                  result = Some(m);\n                 }\n                 None => {\n                     // Remove this port.\n@@ -1153,7 +1153,7 @@ impl<T: Owned> GenericPort<T> for PortSet<T> {\n             }\n         }\n         ports <-> self.ports;\n-        move result\n+        result\n     }\n \n     fn recv() -> T {\n@@ -1178,29 +1178,29 @@ pub type SharedChan<T> = private::Exclusive<Chan<T>>;\n \n impl<T: Owned> GenericChan<T> for SharedChan<T> {\n     fn send(x: T) {\n-        let mut xx = Some(move x);\n+        let mut xx = Some(x);\n         do self.with_imm |chan| {\n             let mut x = None;\n             x <-> xx;\n-            chan.send(option::unwrap(move x))\n+            chan.send(option::unwrap(x))\n         }\n     }\n }\n \n impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n     fn try_send(x: T) -> bool {\n-        let mut xx = Some(move x);\n+        let mut xx = Some(x);\n         do self.with_imm |chan| {\n             let mut x = None;\n             x <-> xx;\n-            chan.try_send(option::unwrap(move x))\n+            chan.try_send(option::unwrap(x))\n         }\n     }\n }\n \n /// Converts a `chan` into a `shared_chan`.\n pub fn SharedChan<T:Owned>(c: Chan<T>) -> SharedChan<T> {\n-    private::exclusive(move c)\n+    private::exclusive(c)\n }\n \n /// Receive a message from one of two endpoints.\n@@ -1267,24 +1267,24 @@ impl<T: Owned> ChanOne<T> {\n  * closed.\n  */\n pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n-    let oneshot::send(message) = recv(move port);\n-    move message\n+    let oneshot::send(message) = recv(port);\n+    message\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n-    let message = try_recv(move port);\n+    let message = try_recv(port);\n \n     if message.is_none() { None }\n     else {\n-        let oneshot::send(message) = option::unwrap(move message);\n-        Some(move message)\n+        let oneshot::send(message) = option::unwrap(message);\n+        Some(message)\n     }\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n-    oneshot::client::send(move chan, move data);\n+    oneshot::client::send(chan, data);\n }\n \n /**\n@@ -1293,15 +1293,15 @@ pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n  */\n pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T)\n         -> bool {\n-    oneshot::client::try_send(move chan, move data).is_some()\n+    oneshot::client::try_send(chan, data).is_some()\n }\n \n pub mod rt {\n     use option::{None, Option, Some};\n \n     // These are used to hide the option constructors from the\n     // compiler because their names are changing\n-    pub fn make_some<T>(val: T) -> Option<T> { Some(move val) }\n+    pub fn make_some<T>(val: T) -> Option<T> { Some(val) }\n     pub fn make_none<T>() -> Option<T> { None }\n }\n \n@@ -1318,7 +1318,7 @@ pub mod test {\n \n         c1.send(~\"abc\");\n \n-        match (move p1, move p2).select() {\n+        match (p1, p2).select() {\n           Right(_) => fail!(),\n           _ => ()\n         }\n@@ -1330,9 +1330,9 @@ pub mod test {\n     pub fn test_oneshot() {\n         let (c, p) = oneshot::init();\n \n-        oneshot::client::send(move c, ());\n+        oneshot::client::send(c, ());\n \n-        recv_one(move p)\n+        recv_one(p)\n     }\n \n     #[test]\n@@ -1341,7 +1341,7 @@ pub mod test {\n \n         {\n             // Destroy the channel\n-            let _chan = move chan;\n+            let _chan = chan;\n         }\n \n         assert !port.peek();"}, {"sha": "5b69c348c1591174544e3731734c7162519641a5", "filename": "src/libcore/private.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -145,19 +145,19 @@ struct ArcDestruct<T> {\n                             cast::reinterpret_cast(&data.unwrapper);\n                         let (message, response) = option::swap_unwrap(p);\n                         // Send 'ready' and wait for a response.\n-                        pipes::send_one(move message, ());\n+                        pipes::send_one(message, ());\n                         // Unkillable wait. Message guaranteed to come.\n-                        if pipes::recv_one(move response) {\n+                        if pipes::recv_one(response) {\n                             // Other task got the data.\n-                            cast::forget(move data);\n+                            cast::forget(data);\n                         } else {\n                             // Other task was killed. drop glue takes over.\n                         }\n                     } else {\n                         // drop glue takes over.\n                     }\n                 } else {\n-                    cast::forget(move data);\n+                    cast::forget(data);\n                 }\n             }\n         }\n@@ -182,13 +182,13 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n                 // tried to wake us whether they should hand-off the data to\n                 // us.\n                 if task::failing() {\n-                    pipes::send_one(move response, false);\n+                    pipes::send_one(response, false);\n                     // Either this swap_unwrap or the one below (at \"Got\n                     // here\") ought to run.\n                     cast::forget(option::swap_unwrap(&mut self.ptr));\n                 } else {\n                     assert self.ptr.is_none();\n-                    pipes::send_one(move response, true);\n+                    pipes::send_one(response, true);\n                 }\n             }\n         }\n@@ -198,8 +198,8 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&rc.data);\n         let (p1,c1) = pipes::oneshot(); // ()\n         let (p2,c2) = pipes::oneshot(); // bool\n-        let server: UnwrapProto = ~mut Some((move c1,move p2));\n-        let serverp: int = cast::transmute(move server);\n+        let server: UnwrapProto = ~mut Some((c1,p2));\n+        let serverp: int = cast::transmute(server);\n         // Try to put our server end in the unwrapper slot.\n         if compare_and_swap(&mut ptr.unwrapper, 0, serverp) {\n             // Got in. Step 0: Tell destructor not to run. We are now it.\n@@ -210,15 +210,15 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n             if new_count == 0 {\n                 // We were the last owner. Can unwrap immediately.\n                 // Also we have to free the server endpoints.\n-                let _server: UnwrapProto = cast::transmute(move serverp);\n+                let _server: UnwrapProto = cast::transmute(serverp);\n                 option::swap_unwrap(&mut ptr.data)\n                 // drop glue takes over.\n             } else {\n                 // The *next* person who sees the refcount hit 0 will wake us.\n                 let end_result =\n-                    DeathThroes { ptr: Some(move ptr),\n-                                  response: Some(move c2) };\n-                let mut p1 = Some(move p1); // argh\n+                    DeathThroes { ptr: Some(ptr),\n+                                  response: Some(c2) };\n+                let mut p1 = Some(p1); // argh\n                 do task::rekillable {\n                     pipes::recv_one(option::swap_unwrap(&mut p1));\n                 }\n@@ -230,9 +230,9 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n             }\n         } else {\n             // Somebody else was trying to unwrap. Avoid guaranteed deadlock.\n-            cast::forget(move ptr);\n+            cast::forget(ptr);\n             // Also we have to free the (rejected) server endpoints.\n-            let _server: UnwrapProto = cast::transmute(move serverp);\n+            let _server: UnwrapProto = cast::transmute(serverp);\n             fail!(~\"Another task is already unwrapping this ARC!\");\n         }\n     }\n@@ -248,9 +248,9 @@ pub type SharedMutableState<T> = ArcDestruct<T>;\n \n pub unsafe fn shared_mutable_state<T: Owned>(data: T) ->\n         SharedMutableState<T> {\n-    let data = ~ArcData { count: 1, unwrapper: 0, data: Some(move data) };\n+    let data = ~ArcData { count: 1, unwrapper: 0, data: Some(data) };\n     unsafe {\n-        let ptr = cast::transmute(move data);\n+        let ptr = cast::transmute(data);\n         ArcDestruct(ptr)\n     }\n }\n@@ -263,7 +263,7 @@ pub unsafe fn get_shared_mutable_state<T: Owned>(\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         assert ptr.count > 0;\n         let r = cast::transmute(option::get_ref(&ptr.data));\n-        cast::forget(move ptr);\n+        cast::forget(ptr);\n         return r;\n     }\n }\n@@ -275,7 +275,7 @@ pub unsafe fn get_shared_immutable_state<T: Owned>(\n         assert ptr.count > 0;\n         // Cast us back into the correct region\n         let r = cast::transmute_region(option::get_ref(&ptr.data));\n-        cast::forget(move ptr);\n+        cast::forget(ptr);\n         return r;\n     }\n }\n@@ -286,7 +286,7 @@ pub unsafe fn clone_shared_mutable_state<T: Owned>(rc: &SharedMutableState<T>)\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         let new_count = rusti::atomic_xadd(&mut ptr.count, 1) + 1;\n         assert new_count >= 2;\n-        cast::forget(move ptr);\n+        cast::forget(ptr);\n     }\n     ArcDestruct((*rc).data)\n }\n@@ -355,9 +355,9 @@ pub struct Exclusive<T> { x: SharedMutableState<ExData<T>> }\n \n pub fn exclusive<T:Owned >(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n-        lock: LittleLock(), mut failed: false, mut data: move user_data\n+        lock: LittleLock(), mut failed: false, mut data: user_data\n     };\n-    Exclusive { x: unsafe { shared_mutable_state(move data) } }\n+    Exclusive { x: unsafe { shared_mutable_state(data) } }\n }\n \n impl<T: Owned> Clone for Exclusive<T> {\n@@ -386,7 +386,7 @@ impl<T: Owned> Exclusive<T> {\n                 (*rec).failed = true;\n                 let result = f(&mut (*rec).data);\n                 (*rec).failed = false;\n-                move result\n+                result\n             }\n         }\n     }\n@@ -401,10 +401,10 @@ impl<T: Owned> Exclusive<T> {\n \n // FIXME(#3724) make this a by-move method on the exclusive\n pub fn unwrap_exclusive<T: Owned>(arc: Exclusive<T>) -> T {\n-    let Exclusive { x: x } = move arc;\n-    let inner = unsafe { unwrap_shared_mutable_state(move x) };\n-    let ExData { data: data, _ } = move inner;\n-    move data\n+    let Exclusive { x: x } = arc;\n+    let inner = unsafe { unwrap_shared_mutable_state(x) };\n+    let ExData { data: data, _ } = inner;\n+    data\n }\n \n #[cfg(test)]\n@@ -430,9 +430,9 @@ pub mod tests {\n         for uint::range(0, num_tasks) |_i| {\n             let total = total.clone();\n             let (port, chan) = pipes::stream();\n-            futures.push(move port);\n+            futures.push(port);\n \n-            do task::spawn |move total, move chan| {\n+            do task::spawn || {\n                 for uint::range(0, count) |_i| {\n                     do total.with |count| {\n                         **count += 1;\n@@ -455,7 +455,7 @@ pub mod tests {\n         // accesses will also fail.\n         let x = exclusive(1);\n         let x2 = x.clone();\n-        do task::try |move x2| {\n+        do task::try || {\n             do x2.with |one| {\n                 assert *one == 2;\n             }\n@@ -468,31 +468,31 @@ pub mod tests {\n     #[test]\n     pub fn exclusive_unwrap_basic() {\n         let x = exclusive(~~\"hello\");\n-        assert unwrap_exclusive(move x) == ~~\"hello\";\n+        assert unwrap_exclusive(x) == ~~\"hello\";\n     }\n \n     #[test]\n     pub fn exclusive_unwrap_contended() {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n-        do task::spawn |move x2| {\n+        do task::spawn || {\n             let x2 = option::swap_unwrap(x2);\n             do x2.with |_hello| { }\n             task::yield();\n         }\n-        assert unwrap_exclusive(move x) == ~~\"hello\";\n+        assert unwrap_exclusive(x) == ~~\"hello\";\n \n         // Now try the same thing, but with the child task blocking.\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(move r)).spawn\n-              |move x2| {\n+        do task::task().future_result(|+r| res = Some(r)).spawn\n+              || {\n             let x2 = option::swap_unwrap(x2);\n-            assert unwrap_exclusive(move x2) == ~~\"hello\";\n+            assert unwrap_exclusive(x2) == ~~\"hello\";\n         }\n         // Have to get rid of our reference before blocking.\n-        { let _x = move x; } // FIXME(#3161) util::ignore doesn't work here\n+        { let _x = x; } // FIXME(#3161) util::ignore doesn't work here\n         let res = option::swap_unwrap(&mut res);\n         res.recv();\n     }\n@@ -502,12 +502,12 @@ pub mod tests {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(move r)).spawn\n-           |move x2| {\n+        do task::task().future_result(|+r| res = Some(r)).spawn\n+           || {\n             let x2 = option::swap_unwrap(x2);\n-            assert unwrap_exclusive(move x2) == ~~\"hello\";\n+            assert unwrap_exclusive(x2) == ~~\"hello\";\n         }\n-        assert unwrap_exclusive(move x) == ~~\"hello\";\n+        assert unwrap_exclusive(x) == ~~\"hello\";\n         let res = option::swap_unwrap(&mut res);\n         res.recv();\n     }\n@@ -526,7 +526,7 @@ pub mod tests {\n                 for 10.times { task::yield(); } // try to let the unwrapper go\n                 fail!(); // punt it awake from its deadlock\n             }\n-            let _z = unwrap_exclusive(move x);\n+            let _z = unwrap_exclusive(x);\n             do x2.with |_hello| { }\n         };\n         assert result.is_err();"}, {"sha": "97812602ce762f9151ce78dce4a5ffff15b2d475", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -273,7 +273,7 @@ impl Rng {\n             s = s + str::from_char(self.gen_char_from(charset));\n             i += 1u;\n         }\n-        move s\n+        s\n     }\n \n     /// Return a random byte string of the specified length\n@@ -339,14 +339,14 @@ impl Rng {\n                 r.push(item.item);\n             }\n         }\n-        move r\n+        r\n     }\n \n     /// Shuffle a vec\n     fn shuffle<T:Copy>(values: &[T]) -> ~[T] {\n         let mut m = vec::from_slice(values);\n         self.shuffle_mut(m);\n-        move m\n+        m\n     }\n \n     /// Shuffle a mutable vec in place"}, {"sha": "8983c63f42a1ff2e779d2a80a556ac53b96011a4", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -42,7 +42,7 @@ pub struct MovePtrAdaptor<V> {\n     inner: V\n }\n pub fn MovePtrAdaptor<V: TyVisitor MovePtr>(v: V) -> MovePtrAdaptor<V> {\n-    MovePtrAdaptor { inner: move v }\n+    MovePtrAdaptor { inner: v }\n }\n \n impl<V: TyVisitor MovePtr> MovePtrAdaptor<V> {"}, {"sha": "7f1687b08608a20d37f5f548137310ec7bc83cfc", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -200,8 +200,8 @@ impl ReprVisitor {\n     fn visit_ptr_inner(ptr: *c_void, inner: *TyDesc) -> bool {\n         unsafe {\n             let mut u = ReprVisitor(ptr, self.writer);\n-            let v = reflect::MovePtrAdaptor(move u);\n-            visit_tydesc(inner, (move v) as @TyVisitor);\n+            let v = reflect::MovePtrAdaptor(u);\n+            visit_tydesc(inner, (v) as @TyVisitor);\n             true\n         }\n     }\n@@ -569,8 +569,8 @@ pub fn write_repr<T>(writer: @Writer, object: &T) {\n         let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n         let tydesc = intrinsic::get_tydesc::<T>();\n         let mut u = ReprVisitor(ptr, writer);\n-        let v = reflect::MovePtrAdaptor(move u);\n-        visit_tydesc(tydesc, (move v) as @TyVisitor)\n+        let v = reflect::MovePtrAdaptor(u);\n+        visit_tydesc(tydesc, (v) as @TyVisitor)\n     }\n }\n "}, {"sha": "64c62c925849fa87f98993c5414086ec3e04d1ac", "filename": "src/libcore/result.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -125,9 +125,9 @@ pub pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>)\n #[inline(always)]\n pub pure fn chain<T, U, V>(res: Result<T, V>, op: fn(T)\n     -> Result<U, V>) -> Result<U, V> {\n-    match move res {\n-        Ok(move t) => op(move t),\n-        Err(move e) => Err(move e)\n+    match res {\n+        Ok(t) => op(t),\n+        Err(e) => Err(e)\n     }\n }\n \n@@ -144,9 +144,9 @@ pub pure fn chain_err<T, U, V>(\n     res: Result<T, V>,\n     op: fn(t: V) -> Result<T, U>)\n     -> Result<T, U> {\n-    match move res {\n-      Ok(move t) => Ok(move t),\n-      Err(move v) => op(move v)\n+    match res {\n+      Ok(t) => Ok(t),\n+      Err(v) => op(v)\n     }\n }\n \n@@ -309,7 +309,7 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n           Err(copy u) => return Err(u)\n         }\n     }\n-    return Ok(move vs);\n+    return Ok(vs);\n }\n \n #[inline(always)]\n@@ -349,7 +349,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n         }\n         i += 1u;\n     }\n-    return Ok(move vs);\n+    return Ok(vs);\n }\n \n /**\n@@ -377,17 +377,17 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n /// Unwraps a result, assuming it is an `ok(T)`\n #[inline(always)]\n pub pure fn unwrap<T, U>(res: Result<T, U>) -> T {\n-    match move res {\n-      Ok(move t) => move t,\n+    match res {\n+      Ok(t) => t,\n       Err(_) => fail!(~\"unwrap called on an err result\")\n     }\n }\n \n /// Unwraps a result, assuming it is an `err(U)`\n #[inline(always)]\n pub pure fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n-    match move res {\n-      Err(move u) => move u,\n+    match res {\n+      Err(u) => u,\n       Ok(_) => fail!(~\"unwrap called on an ok result\")\n     }\n }"}, {"sha": "5103025d1205193b1b58a50030163c53a1900ba3", "filename": "src/libcore/run.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -258,7 +258,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n \n     fn ProgRes(r: ProgRepr) -> ProgRes {\n         ProgRes {\n-            r: move r\n+            r: r\n         }\n     }\n \n@@ -344,11 +344,11 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n         let ch_clone = ch.clone();\n         do task::spawn_sched(task::SingleThreaded) {\n             let errput = readclose(pipe_err.in);\n-            ch.send((2, move errput));\n+            ch.send((2, errput));\n         };\n         do task::spawn_sched(task::SingleThreaded) {\n             let output = readclose(pipe_out.in);\n-            ch_clone.send((1, move output));\n+            ch_clone.send((1, output));\n         };\n         let status = run::waitpid(pid);\n         let mut errs = ~\"\";\n@@ -358,10 +358,10 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n             let stream = p.recv();\n             match stream {\n                 (1, copy s) => {\n-                    outs = move s;\n+                    outs = s;\n                 }\n                 (2, copy s) => {\n-                    errs = move s;\n+                    errs = s;\n                 }\n                 (n, _) => {\n                     fail!(fmt!(\"program_output received an unexpected file \\\n@@ -371,8 +371,8 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n             count -= 1;\n         };\n         return ProgramOutput {status: status,\n-                              out: move outs,\n-                              err: move errs};\n+                              out: outs,\n+                              err: errs};\n     }\n }\n "}, {"sha": "afc9d7f1417e44110adfefbc3e0fff5457b045e2", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -216,7 +216,7 @@ pub mod tests {\n \n             assert f(20) == 30;\n \n-            let original_closure: Closure = cast::transmute(move f);\n+            let original_closure: Closure = cast::transmute(f);\n \n             let actual_function_pointer = original_closure.code;\n             let environment = original_closure.env;\n@@ -226,7 +226,7 @@ pub mod tests {\n                 env: environment\n             };\n \n-            let new_f: fn(int) -> int = cast::transmute(move new_closure);\n+            let new_f: fn(int) -> int = cast::transmute(new_closure);\n             assert new_f(20) == 30;\n         }\n     }"}, {"sha": "949c36545dd0341027b17fdc8c02cc0adf452fbd", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -73,7 +73,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n         cast::bump_box_refcount(map);\n         map\n     } else {\n-        let map = cast::transmute(move map_ptr);\n+        let map = cast::transmute(map_ptr);\n         cast::bump_box_refcount(map);\n         map\n     }\n@@ -119,7 +119,7 @@ unsafe fn local_get_helper<T: Durable>(\n         // overwriting the local_data_box we need to give an extra reference.\n         // We must also give an extra reference when not removing.\n         let (index, data_ptr) = *result;\n-        let data: @T = cast::transmute(move data_ptr);\n+        let data: @T = cast::transmute(data_ptr);\n         cast::bump_box_refcount(data);\n         if do_pop {\n             (*map).set_elt(index, None);\n@@ -182,6 +182,6 @@ pub unsafe fn local_modify<T: Durable>(\n     // Could be more efficient by doing the lookup work, but this is easy.\n     let newdata = modify_fn(local_pop(task, key));\n     if newdata.is_some() {\n-        local_set(task, key, option::unwrap(move newdata));\n+        local_set(task, key, option::unwrap(newdata));\n     }\n }"}, {"sha": "4b15d1f76c98a70e096734b01fef5dd3b05d2302", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -203,7 +203,7 @@ pub struct TaskBuilder {\n pub fn task() -> TaskBuilder {\n     TaskBuilder {\n         opts: default_task_opts(),\n-        gen_body: |body| move body, // Identity function\n+        gen_body: |body| body, // Identity function\n         can_not_copy: None,\n         mut consumed: false,\n     }\n@@ -315,7 +315,7 @@ impl TaskBuilder {\n         // Construct the future and give it to the caller.\n         let (notify_pipe_po, notify_pipe_ch) = stream::<TaskResult>();\n \n-        blk(move notify_pipe_po);\n+        blk(notify_pipe_po);\n \n         // Reconfigure self to use a notify channel.\n         TaskBuilder {\n@@ -336,7 +336,7 @@ impl TaskBuilder {\n             opts: TaskOpts {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n-                notify_chan: move notify_chan,\n+                notify_chan: notify_chan,\n                 sched: SchedOpts { mode: mode, foreign_stack_size: None}\n             },\n             can_not_copy: None,\n@@ -366,11 +366,7 @@ impl TaskBuilder {\n                 notify_chan: notify_chan,\n                 sched: self.opts.sched\n             },\n-            // tjc: I think this is the line that gets miscompiled\n-            // w/ last-use off, if we leave out the move prev_gen_body?\n-            // that makes no sense, though...\n-            gen_body: |move prev_gen_body,\n-                       body| { wrapper(prev_gen_body(move body)) },\n+            gen_body: |body| { wrapper(prev_gen_body(body)) },\n             can_not_copy: None,\n             .. self.consume()\n         }\n@@ -397,12 +393,12 @@ impl TaskBuilder {\n             notify_chan: notify_chan,\n             sched: x.opts.sched\n         };\n-        spawn::spawn_raw(move opts, (x.gen_body)(move f));\n+        spawn::spawn_raw(opts, (x.gen_body)(f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n     fn spawn_with<A: Owned>(arg: A, f: fn~(v: A)) {\n-        let arg = ~mut Some(move arg);\n-        do self.spawn |move arg, move f| {\n+        let arg = ~mut Some(arg);\n+        do self.spawn || {\n             f(option::swap_unwrap(arg))\n         }\n     }\n@@ -425,12 +421,12 @@ impl TaskBuilder {\n         let mut result = None;\n \n         let fr_task_builder = self.future_result(|+r| {\n-            result = Some(move r);\n+            result = Some(r);\n         });\n-        do fr_task_builder.spawn |move f, move ch| {\n+        do fr_task_builder.spawn || {\n             ch.send(f());\n         }\n-        match option::unwrap(move result).recv() {\n+        match option::unwrap(result).recv() {\n             Success => result::Ok(po.recv()),\n             Failure => result::Err(())\n         }\n@@ -471,7 +467,7 @@ pub fn spawn(f: fn~()) {\n      * This function is equivalent to `task().spawn(f)`.\n      */\n \n-    task().spawn(move f)\n+    task().spawn(f)\n }\n \n pub fn spawn_unlinked(f: fn~()) {\n@@ -480,7 +476,7 @@ pub fn spawn_unlinked(f: fn~()) {\n      * task or the child task fails, the other will not be killed.\n      */\n \n-    task().unlinked().spawn(move f)\n+    task().unlinked().spawn(f)\n }\n \n pub fn spawn_supervised(f: fn~()) {\n@@ -489,7 +485,7 @@ pub fn spawn_supervised(f: fn~()) {\n      * task or the child task fails, the other will not be killed.\n      */\n \n-    task().supervised().spawn(move f)\n+    task().supervised().spawn(f)\n }\n \n pub fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n@@ -503,7 +499,7 @@ pub fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n      * This function is equivalent to `task().spawn_with(arg, f)`.\n      */\n \n-    task().spawn_with(move arg, move f)\n+    task().spawn_with(arg, f)\n }\n \n pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n@@ -519,7 +515,7 @@ pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n      * greater than zero.\n      */\n \n-    task().sched_mode(mode).spawn(move f)\n+    task().sched_mode(mode).spawn(f)\n }\n \n pub fn try<T:Owned>(f: fn~() -> T) -> Result<T,()> {\n@@ -530,7 +526,7 @@ pub fn try<T:Owned>(f: fn~() -> T) -> Result<T,()> {\n      * This is equivalent to task().supervised().try.\n      */\n \n-    task().supervised().try(move f)\n+    task().supervised().try(f)\n }\n \n \n@@ -719,12 +715,12 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n         let mut opts = default_task_opts();\n         opts.linked = true;\n         opts.supervised = true;\n-        move opts\n+        opts\n     };\n \n     let b0 = task();\n     let b1 = TaskBuilder {\n-        opts: move opts,\n+        opts: opts,\n         can_not_copy: None,\n         .. b0\n     };\n@@ -739,12 +735,12 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n         let mut opts = default_task_opts();\n         opts.linked = true;\n         opts.supervised = true;\n-        move opts\n+        opts\n     };\n \n     let b0 = task();\n     let b1 = TaskBuilder {\n-        opts: move opts,\n+        opts: opts,\n         can_not_copy: None,\n         .. b0\n     };\n@@ -843,7 +839,7 @@ fn test_add_wrapper() {\n     let ch = Wrapper { f: Some(ch) };\n     let b1 = do b0.add_wrapper |body| {\n         let ch = Wrapper { f: Some(ch.f.swap_unwrap()) };\n-        fn~(move body) {\n+        fn~() {\n             let ch = ch.f.swap_unwrap();\n             body();\n             ch.send(());\n@@ -857,15 +853,15 @@ fn test_add_wrapper() {\n #[ignore(cfg(windows))]\n fn test_future_result() {\n     let mut result = None;\n-    do task().future_result(|+r| { result = Some(move r); }).spawn { }\n-    assert option::unwrap(move result).recv() == Success;\n+    do task().future_result(|+r| { result = Some(r); }).spawn { }\n+    assert option::unwrap(result).recv() == Success;\n \n     result = None;\n     do task().future_result(|+r|\n-        { result = Some(move r); }).unlinked().spawn {\n+        { result = Some(r); }).unlinked().spawn {\n         fail!();\n     }\n-    assert option::unwrap(move result).recv() == Failure;\n+    assert option::unwrap(result).recv() == Failure;\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -1024,7 +1020,7 @@ fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n     let x = ~1;\n     let x_in_parent = ptr::addr_of(&(*x)) as uint;\n \n-    do spawnfn |move x| {\n+    do spawnfn || {\n         let x_in_child = ptr::addr_of(&(*x)) as uint;\n         ch.send(x_in_child);\n     }\n@@ -1041,7 +1037,7 @@ fn test_avoid_copying_the_body_spawn() {\n #[test]\n fn test_avoid_copying_the_body_task_spawn() {\n     do avoid_copying_the_body |f| {\n-        do task().spawn |move f| {\n+        do task().spawn || {\n             f();\n         }\n     }\n@@ -1050,7 +1046,7 @@ fn test_avoid_copying_the_body_task_spawn() {\n #[test]\n fn test_avoid_copying_the_body_try() {\n     do avoid_copying_the_body |f| {\n-        do try |move f| {\n+        do try || {\n             f()\n         };\n     }\n@@ -1059,7 +1055,7 @@ fn test_avoid_copying_the_body_try() {\n #[test]\n fn test_avoid_copying_the_body_unlinked() {\n     do avoid_copying_the_body |f| {\n-        do spawn_unlinked |move f| {\n+        do spawn_unlinked || {\n             f();\n         }\n     }\n@@ -1096,12 +1092,12 @@ fn test_unkillable() {\n     unsafe {\n         do unkillable {\n             let p = ~0;\n-            let pp: *uint = cast::transmute(move p);\n+            let pp: *uint = cast::transmute(p);\n \n             // If we are killed here then the box will leak\n             po.recv();\n \n-            let _p: ~int = cast::transmute(move pp);\n+            let _p: ~int = cast::transmute(pp);\n         }\n     }\n \n@@ -1116,7 +1112,7 @@ fn test_unkillable_nested() {\n     let (po, ch) = pipes::stream();\n \n     // We want to do this after failing\n-    do spawn_unlinked |move ch| {\n+    do spawn_unlinked || {\n         for iter::repeat(10) { yield() }\n         ch.send(());\n     }\n@@ -1132,12 +1128,12 @@ fn test_unkillable_nested() {\n         do unkillable {\n             do unkillable {} // Here's the difference from the previous test.\n             let p = ~0;\n-            let pp: *uint = cast::transmute(move p);\n+            let pp: *uint = cast::transmute(p);\n \n             // If we are killed here then the box will leak\n             po.recv();\n \n-            let _p: ~int = cast::transmute(move pp);\n+            let _p: ~int = cast::transmute(pp);\n         }\n     }\n \n@@ -1181,7 +1177,7 @@ fn test_child_doesnt_ref_parent() {\n fn test_sched_thread_per_core() {\n     let (port, chan) = pipes::stream();\n \n-    do spawn_sched(ThreadPerCore) |move chan| {\n+    do spawn_sched(ThreadPerCore) || {\n         unsafe {\n             let cores = rt::rust_num_threads();\n             let reported_threads = rt::rust_sched_threads();\n@@ -1197,7 +1193,7 @@ fn test_sched_thread_per_core() {\n fn test_spawn_thread_on_demand() {\n     let (port, chan) = pipes::stream();\n \n-    do spawn_sched(ManualThreads(2)) |move chan| {\n+    do spawn_sched(ManualThreads(2)) || {\n         unsafe {\n             let max_threads = rt::rust_sched_threads();\n             assert(max_threads as int == 2);\n@@ -1206,7 +1202,7 @@ fn test_spawn_thread_on_demand() {\n \n             let (port2, chan2) = pipes::stream();\n \n-            do spawn_sched(CurrentScheduler) |move chan2| {\n+            do spawn_sched(CurrentScheduler) || {\n                 chan2.send(());\n             }\n "}, {"sha": "d72cacc2c4be7b71c4190c9ff788c3c565484c3f", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -93,7 +93,7 @@ use uint;\n use util;\n \n macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = move *ptr::addr_of(&($x)); move y } )\n+    { $x:expr } => ( unsafe { let y = *ptr::addr_of(&($x)); y } )\n )\n \n type TaskSet = LinearSet<*rust_task>;\n@@ -195,10 +195,10 @@ fn each_ancestor(list:        &mut AncestorList,\n         if coalesce_this.is_some() {\n             // Needed coalesce. Our next ancestor becomes our old\n             // ancestor's next ancestor. (\"next = old_next->next;\")\n-            *list = move option::unwrap(move coalesce_this);\n+            *list = option::unwrap(coalesce_this);\n         } else {\n             // No coalesce; restore from tmp. (\"next = old_next;\")\n-            *list = move tmp_list;\n+            *list = tmp_list;\n         }\n         return early_break;\n     }\n@@ -279,7 +279,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                     // Swap the list out here; the caller replaces us with it.\n                     let rest = util::replace(&mut nobe.ancestors,\n                                              AncestorList(None));\n-                    (Some(move rest), need_unwind)\n+                    (Some(rest), need_unwind)\n                 } else {\n                     (None, need_unwind)\n                 }\n@@ -292,8 +292,8 @@ fn each_ancestor(list:        &mut AncestorList,\n             // If this trips, more likely the problem is 'blk' failed inside.\n             let tmp_arc = option::swap_unwrap(&mut *parent_group);\n             let result = do access_group(&tmp_arc) |tg_opt| { blk(tg_opt) };\n-            *parent_group = move Some(move tmp_arc);\n-            move result\n+            *parent_group = Some(tmp_arc);\n+            result\n         }\n     }\n }\n@@ -337,15 +337,15 @@ struct TCB {\n fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n        is_main: bool, notifier: Option<AutoNotify>) -> TCB {\n \n-    let notifier = move notifier;\n+    let notifier = notifier;\n     notifier.iter(|x| { x.failed = false; });\n \n     TCB {\n         me: me,\n-        tasks: move tasks,\n-        ancestors: move ancestors,\n+        tasks: tasks,\n+        ancestors: ancestors,\n         is_main: is_main,\n-        notifier: move notifier\n+        notifier: notifier\n     }\n }\n \n@@ -360,7 +360,7 @@ struct AutoNotify {\n \n fn AutoNotify(chan: Chan<TaskResult>) -> AutoNotify {\n     AutoNotify {\n-        notify_chan: move chan,\n+        notify_chan: chan,\n         failed: true // Un-set above when taskgroup successfully made.\n     }\n }\n@@ -370,10 +370,10 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', the group was failing. Can't enlist.\n     if newstate.is_some() {\n-        let group = option::unwrap(move newstate);\n+        let group = option::unwrap(newstate);\n         taskset_insert(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n-        *state = Some(move group);\n+        *state = Some(group);\n         true\n     } else {\n         false\n@@ -386,10 +386,10 @@ fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n-        let group = option::unwrap(move newstate);\n+        let group = option::unwrap(newstate);\n         taskset_remove(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n-        *state = Some(move group);\n+        *state = Some(group);\n     }\n }\n \n@@ -410,7 +410,7 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n         // That's ok; only one task needs to do the dirty work. (Might also\n         // see 'None' if Somebody already failed and we got a kill signal.)\n         if newstate.is_some() {\n-            let group = option::unwrap(move newstate);\n+            let group = option::unwrap(newstate);\n             for taskset_each(&group.members) |sibling| {\n                 // Skip self - killing ourself won't do much good.\n                 if sibling != me {\n@@ -457,7 +457,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 }));\n                 // Main task/group has no ancestors, no notifier, etc.\n                 let group =\n-                    @TCB(spawner, move tasks, AncestorList(None), true, None);\n+                    @TCB(spawner, tasks, AncestorList(None), true, None);\n                 local_set(spawner, taskgroup_key!(), group);\n                 group\n             }\n@@ -472,7 +472,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             // Child's ancestors are spawner's ancestors.\n             let a = share_ancestors(&mut spawner_group.ancestors);\n             // Propagate main-ness.\n-            (move g, move a, spawner_group.is_main)\n+            (g, a, spawner_group.is_main)\n         } else {\n             // Child is in a separate group from spawner.\n             let g = private::exclusive(Some(TaskGroupData {\n@@ -504,7 +504,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 // Child has no ancestors.\n                 AncestorList(None)\n             };\n-            (move g, move a, false)\n+            (g, a, false)\n         };\n     }\n \n@@ -515,10 +515,10 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         //    None               { ancestor_list(None) }\n         let tmp = util::replace(&mut **ancestors, None);\n         if tmp.is_some() {\n-            let ancestor_arc = option::unwrap(move tmp);\n+            let ancestor_arc = option::unwrap(tmp);\n             let result = ancestor_arc.clone();\n-            **ancestors = move Some(move ancestor_arc);\n-            AncestorList(Some(move result))\n+            **ancestors = Some(ancestor_arc);\n+            AncestorList(Some(result))\n         } else {\n             AncestorList(None)\n         }\n@@ -530,7 +530,7 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n     unsafe {\n-        let child_data = ~mut Some((move child_tg, move ancestors, move f));\n+        let child_data = ~mut Some((child_tg, ancestors, f));\n         // Being killed with the unsafe task/closure pointers would leak them.\n         do unkillable {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n@@ -548,16 +548,16 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n                 Some(option::swap_unwrap(&mut opts.notify_chan))\n             };\n \n-            let child_wrapper = make_child_wrapper(new_task, move child_tg,\n-                  move ancestors, is_main, move notify_chan, move f);\n+            let child_wrapper = make_child_wrapper(new_task, child_tg,\n+                  ancestors, is_main, notify_chan, f);\n \n             let closure = cast::transmute(&child_wrapper);\n \n             // Getting killed between these two calls would free the child's\n             // closure. (Reordering them wouldn't help - then getting killed\n             // between them would leak.)\n             rt::start_task(new_task, closure);\n-            cast::forget(move child_wrapper);\n+            cast::forget(child_wrapper);\n         }\n     }\n \n@@ -571,8 +571,8 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n                           ancestors: AncestorList, is_main: bool,\n                           notify_chan: Option<Chan<TaskResult>>,\n                           f: fn~()) -> fn~() {\n-        let child_data = ~mut Some((move child_arc, move ancestors));\n-        return fn~(move notify_chan, move child_data, move f) {\n+        let child_data = ~mut Some((child_arc, ancestors));\n+        return fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let mut (child_arc, ancestors) = option::swap_unwrap(child_data);\n             // Child task runs this code.\n@@ -584,14 +584,14 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n             let notifier = match notify_chan {\n                 Some(ref notify_chan_value) => {\n                     let moved_ncv = move_it!(*notify_chan_value);\n-                    Some(AutoNotify(move moved_ncv))\n+                    Some(AutoNotify(moved_ncv))\n                 }\n                 _ => None\n             };\n \n             if enlist_many(child, &child_arc, &mut ancestors) {\n-                let group = @TCB(child, move child_arc, move ancestors,\n-                                 is_main, move notifier);\n+                let group = @TCB(child, child_arc, ancestors,\n+                                 is_main, notifier);\n                 unsafe {\n                     local_set(child, taskgroup_key!(), group);\n                 }\n@@ -694,7 +694,7 @@ fn test_spawn_raw_unsupervise() {\n         notify_chan: None,\n         .. default_task_opts()\n     };\n-    do spawn_raw(move opts) {\n+    do spawn_raw(opts) {\n         fail!();\n     }\n }\n@@ -708,7 +708,7 @@ fn test_spawn_raw_notify_success() {\n         notify_chan: Some(notify_ch),\n         .. default_task_opts()\n     };\n-    do spawn_raw(move opts) {\n+    do spawn_raw(opts) {\n     }\n     assert notify_po.recv() == Success;\n }\n@@ -724,7 +724,7 @@ fn test_spawn_raw_notify_failure() {\n         notify_chan: Some(notify_ch),\n         .. default_task_opts()\n     };\n-    do spawn_raw(move opts) {\n+    do spawn_raw(opts) {\n         fail!();\n     }\n     assert notify_po.recv() == Failure;"}, {"sha": "e545f6567ec32880f328870e4f8f4f811beae21a", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -87,7 +87,7 @@ impl<A: ToStr> ToStr for ~[A] {\n                 }\n             }\n             str::push_char(&mut acc, ']');\n-            move acc\n+            acc\n         }\n     }\n }"}, {"sha": "eea172a43ced1e1ca440897b36fdf006f3365b48", "filename": "src/libcore/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -19,7 +19,7 @@ use prelude::*;\n \n /// The identity function.\n #[inline(always)]\n-pub pure fn id<T>(x: T) -> T { move x }\n+pub pure fn id<T>(x: T) -> T { x }\n \n /// Ignores a value.\n #[inline(always)]\n@@ -37,10 +37,10 @@ pub fn with<T: Copy, R>(\n     // we wouldn't need to copy...\n \n     let old_value = *ptr;\n-    *ptr = move new_value;\n+    *ptr = new_value;\n     let result = op();\n-    *ptr = move old_value;\n-    return move result;\n+    *ptr = old_value;\n+    return result;\n }\n \n /**\n@@ -58,9 +58,9 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n  */\n #[inline(always)]\n pub fn replace<T>(dest: &mut T, src: T) -> T {\n-    let mut tmp = move src;\n+    let mut tmp = src;\n     swap(dest, &mut tmp);\n-    move tmp\n+    tmp\n }\n \n /// A non-copyable dummy type.\n@@ -109,7 +109,7 @@ mod tests {\n         let x = ~[(5, false)];\n         //FIXME #3387 assert x.eq(id(copy x));\n         let y = copy x;\n-        assert x.eq(&id(move y));\n+        assert x.eq(&id(y));\n     }\n     #[test]\n     pub fn test_swap() {"}, {"sha": "97519e88f26c810aa2b6f71e111292069e479170", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -614,7 +614,7 @@ unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n     (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n     let p = addr_of(&((**repr).unboxed.data));\n     let p = ptr::offset(p, fill) as *mut T;\n-    rusti::move_val_init(&mut(*p), move initval);\n+    rusti::move_val_init(&mut(*p), initval);\n }\n \n #[inline(never)]"}, {"sha": "894e846e11f684b002ae067ce5f9f93a61cf8930", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -156,7 +156,7 @@ pub mod jit {\n                     code: entry,\n                     env: ptr::null()\n                 };\n-                let func: fn(++argv: ~[~str]) = cast::transmute(move closure);\n+                let func: fn(++argv: ~[~str]) = cast::transmute(closure);\n \n                 func(~[/*bad*/copy sess.opts.binary]);\n             }\n@@ -559,11 +559,11 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n \n     let {name: opt_name, vers: opt_vers,\n          cmh_items: cmh_items} = provided_link_metas(sess, c);\n-    let name = crate_meta_name(sess, output, move opt_name);\n-    let vers = crate_meta_vers(sess, move opt_vers);\n+    let name = crate_meta_name(sess, output, opt_name);\n+    let vers = crate_meta_vers(sess, opt_vers);\n     let dep_hashes = cstore::get_dep_hashes(sess.cstore);\n     let extras_hash =\n-        crate_meta_extras_hash(symbol_hasher, move cmh_items,\n+        crate_meta_extras_hash(symbol_hasher, cmh_items,\n                                dep_hashes);\n \n     return {name: name, vers: vers, extras_hash: extras_hash};"}, {"sha": "08ba3515fd251bb665058071183b3abcf1417744", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -172,7 +172,7 @@ pub fn time<T>(do_it: bool, what: ~str, thunk: fn() -> T) -> T {\n     let end = std::time::precise_time_s();\n     io::stdout().write_str(fmt!(\"time: %3.3f s\\t%s\\n\",\n                                 end - start, what));\n-    move rv\n+    rv\n }\n \n pub enum compile_upto {\n@@ -257,7 +257,7 @@ pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n     let (llmod, link_meta) = {\n \n         let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n-                                region_map, rp_set, move lang_items, crate);\n+                                region_map, rp_set, lang_items, crate);\n \n         let (method_map, vtable_map) =\n             time(time_passes, ~\"typechecking\", ||"}, {"sha": "e18a7e7d1d85ab9905534852f3694ef535b47657", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -1481,7 +1481,7 @@ pub fn struct_element_types(struct_ty: TypeRef) -> ~[TypeRef] {\n             llvm::LLVMGetStructElementTypes(\n                 struct_ty, ptr::to_mut_unsafe_ptr(&mut buf[0]));\n         }\n-        return move buf;\n+        return buf;\n     }\n }\n "}, {"sha": "cc97c0060535a54c58bab6f53b6f0042206c48e2", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -752,10 +752,10 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n             def_id: did\n         };\n \n-        vec::push(&mut result, move provided_trait_method_info);\n+        vec::push(&mut result, provided_trait_method_info);\n     }\n \n-    return move result;\n+    return result;\n }\n \n /// Returns the supertraits of the given trait.\n@@ -766,7 +766,7 @@ pub fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     for reader::tagged_docs(item_doc, tag_impl_trait) |trait_doc| {\n         results.push(doc_type(trait_doc, tcx, cdata));\n     }\n-    return dvec::unwrap(move results);\n+    return dvec::unwrap(results);\n }\n \n // If the item in question is a trait, returns its set of methods and\n@@ -847,7 +847,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n         }\n     }\n \n-    return Some(dvec::unwrap(move static_impl_methods));\n+    return Some(dvec::unwrap(static_impl_methods));\n }\n \n pub fn get_item_attrs(cdata: cmd,"}, {"sha": "ad418943ec06c24874c4741bc7866010141bdb4a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -1229,7 +1229,7 @@ pub fn encode_metadata(parms: encode_parms, crate: &crate) -> ~[u8] {\n     let ecx: @encode_ctxt = @encode_ctxt({\n         diag: parms.diag,\n         tcx: parms.tcx,\n-        stats: @mut move stats,\n+        stats: @mut stats,\n         reachable: parms.reachable,\n         reexports2: parms.reexports2,\n         item_symbols: parms.item_symbols,"}, {"sha": "ad19eed6992f35f7e315c2d339ae967630b3e612", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -228,7 +228,7 @@ fn get_metadata_section(os: os,\n                            csz - vlen);\n                     do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n                         let inflated = flate::inflate_bytes(bytes);\n-                        found = move Some(@(move inflated));\n+                        found = Some(@(inflated));\n                     }\n                     if found != None {\n                         return found;"}, {"sha": "da58062f5537650cbfabee90f8647b4a966e94f3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -1140,7 +1140,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 let ids = val_dsr.read_to_vec(|| {\n                     xcx.tr_id(val_dsr.read_int())\n                 });\n-                let dvec = @dvec::from_vec(move ids);\n+                let dvec = @dvec::from_vec(ids);\n                 dcx.maps.last_use_map.insert(id, dvec);\n             } else if tag == (c::tag_table_method_map as uint) {\n                 dcx.maps.method_map.insert("}, {"sha": "507f3059f32c8f14568d7f93ab050529d84016f9", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -632,7 +632,7 @@ fn check_loans_in_fn(fk: visit::fn_kind,\n                             _ => {} // Ignore this argument.\n                         }\n                     }\n-                    *self.fn_args = @move fn_args;\n+                    *self.fn_args = @fn_args;\n                 }\n             }\n "}, {"sha": "126a7f3033308879029c0ed6730bcf47d3d06b83", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -376,8 +376,8 @@ impl GatherLoanCtxt {\n           Some(_) => {\n               match loan::loan(self.bccx, cmt, scope_r, loan_kind) {\n                   Err(ref e) => { self.bccx.report((*e)); }\n-                  Ok(move loans) => {\n-                      self.add_loans(cmt, loan_kind, scope_r, move loans);\n+                  Ok(loans) => {\n+                      self.add_loans(cmt, loan_kind, scope_r, loans);\n                   }\n               }\n           }\n@@ -540,7 +540,7 @@ impl GatherLoanCtxt {\n             }\n         };\n \n-        self.add_loans_to_scope_id(scope_id, move loans);\n+        self.add_loans_to_scope_id(scope_id, loans);\n \n         if loan_kind.is_freeze() && !cmt.mutbl.is_immutable() {\n             self.bccx.stats.loaned_paths_imm += 1;\n@@ -566,7 +566,7 @@ impl GatherLoanCtxt {\n                 req_loans.push_all(loans);\n             }\n             None => {\n-                let dvec = @dvec::from_vec(move loans);\n+                let dvec = @dvec::from_vec(loans);\n                 let req_loan_map = self.req_maps.req_loan_map;\n                 req_loan_map.insert(scope_id, dvec);\n             }"}, {"sha": "40f5a001632861516da7230d2a1ed6f4d7e7ffc3", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -420,15 +420,15 @@ pub fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T,\n     let old_save_and_restore_t = *save_and_restore_t;\n     let u = f();\n     *save_and_restore_t = old_save_and_restore_t;\n-    move u\n+    u\n }\n \n pub fn save_and_restore_managed<T:Copy,U>(save_and_restore_t: @mut T,\n                                           f: &fn() -> U) -> U {\n     let old_save_and_restore_t = *save_and_restore_t;\n     let u = f();\n     *save_and_restore_t = old_save_and_restore_t;\n-    move u\n+    u\n }\n \n impl LoanKind {"}, {"sha": "70464d0084a3535f6526155d86e8089877050a78", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -1520,7 +1520,7 @@ impl Liveness {\n         self.cont_ln.insert(loop_node_id, cont_ln);\n         let r = f();\n         self.loop_scope.pop();\n-        move r\n+        r\n     }\n }\n "}, {"sha": "44b0da626b68d1e54a6c02021910905c277b4c6c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -797,7 +797,7 @@ pub fn Resolver(session: Session,\n         intr: session.intr()\n     };\n \n-    move self\n+    self\n }\n \n /// The main resolver class.\n@@ -3255,7 +3255,7 @@ pub impl Resolver {\n         self.add_exports_for_module(&mut exports2, module_);\n         match copy module_.def_id {\n             Some(def_id) => {\n-                self.export_map2.insert(def_id.node, move exports2);\n+                self.export_map2.insert(def_id.node, exports2);\n                 debug!(\"(computing exports) writing exports for %d (some)\",\n                        def_id.node);\n             }"}, {"sha": "75c3c35039d3af21a87105ebc47608a5cff6a9f8", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -559,7 +559,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                                 Some(fp) => reordered_patterns.push(fp.pat)\n                             }\n                     }\n-                    Some(dvec::unwrap(move reordered_patterns))\n+                    Some(dvec::unwrap(reordered_patterns))\n                 } else {\n                     None\n                 }\n@@ -815,7 +815,7 @@ pub fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n             _ => {}\n         }\n     }\n-    return dvec::unwrap(move found);\n+    return dvec::unwrap(found);\n }\n \n pub fn extract_variant_args(bcx: block,\n@@ -1657,7 +1657,7 @@ pub fn trans_match_inner(scope_cx: block,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = controlflow::join_blocks(scope_cx, dvec::unwrap(move arm_cxs));\n+    bcx = controlflow::join_blocks(scope_cx, dvec::unwrap(arm_cxs));\n     return bcx;\n \n     fn mk_fail(bcx: block, sp: span, +msg: ~str,"}, {"sha": "f38e56278c52180ea4c8269396d7cad9fb543471", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -1174,7 +1174,7 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n         });\n         let bcx = mk_block(llbb,\n                            parent,\n-                           move kind,\n+                           kind,\n                            is_lpad,\n                            opt_node_info,\n                            cx);"}, {"sha": "9f717682dae09d6f9429db71f62a3c94eb5f0527", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -274,11 +274,11 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     if words > 4 {\n         all_mem(cls);\n         let cls = cls;\n-        return move cls;\n+        return cls;\n     }\n     classify(ty, cls, 0, 0);\n     fixup(ty, cls);\n-    return move cls;\n+    return cls;\n }\n \n fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {"}, {"sha": "6ecfbb5762c559b19fca0cfdd7b170575b02e179", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -593,7 +593,7 @@ pub fn block_(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n         terminated: false,\n         unreachable: false,\n         parent: parent,\n-        kind: move kind,\n+        kind: kind,\n         is_lpad: is_lpad,\n         node_info: node_info,\n         fcx: fcx\n@@ -607,7 +607,7 @@ pub enum block = @block_;\n pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n             is_lpad: bool, node_info: Option<node_info>, fcx: fn_ctxt)\n     -> block {\n-    block(@block_(llbb, parent, move kind, is_lpad, node_info, fcx))\n+    block(@block_(llbb, parent, kind, is_lpad, node_info, fcx))\n }\n \n // First two args are retptr, env"}, {"sha": "e2e5526eac08b0599a540040ccd80c6bd4fda6c7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -152,7 +152,7 @@ enum debug_metadata {\n fn cast_safely<T: Copy, U>(val: T) -> U {\n     unsafe {\n         let val2 = val;\n-        return cast::transmute(move val2);\n+        return cast::transmute(val2);\n     }\n }\n "}, {"sha": "a30e0df8452a1b40a398cedcff2065575f87cee1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -320,7 +320,7 @@ pub pure fn get(t: t) -> t_box {\n     unsafe {\n         let t2 = cast::reinterpret_cast::<t, t_box>(&t);\n         let t3 = t2;\n-        cast::forget(move t2);\n+        cast::forget(t2);\n         t3\n     }\n }\n@@ -830,7 +830,7 @@ pub fn mk_ctxt(s: session::Session,\n         inferred_modes: HashMap(),\n         adjustments: HashMap(),\n         normalized_cache: new_ty_hash(),\n-        lang_items: move lang_items,\n+        lang_items: lang_items,\n         legacy_boxed_traits: HashMap(),\n         provided_methods: HashMap(),\n         provided_method_sources: HashMap(),\n@@ -909,10 +909,10 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       }\n     }\n \n-    let t = @{sty: move st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n+    let t = @{sty: st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n \n     let key = intern_key {sty: to_unsafe_ptr(&t.sty), o_def_id: o_def_id};\n-    cx.interner.insert(move key, t);\n+    cx.interner.insert(key, t);\n \n     cx.next_id += 1u;\n     unsafe { cast::reinterpret_cast(&t) }\n@@ -1178,7 +1178,7 @@ pub fn fold_sig(sig: &FnSig, fldop: fn(t) -> t) -> FnSig {\n     };\n \n     FnSig {\n-        inputs: move args,\n+        inputs: args,\n         output: fldop(sig.output)\n     }\n }\n@@ -3110,7 +3110,7 @@ pub fn expr_kind(tcx: ctxt,\n                 ast::def_local(*) |\n                 ast::def_self(*) => LvalueExpr,\n \n-                move def => {\n+                def => {\n                     tcx.sess.span_bug(expr.span, fmt!(\n                         \"Uncategorized def for expr %?: %?\",\n                         expr.id, def));\n@@ -3617,7 +3617,7 @@ pub fn trait_supertraits(cx: ctxt,\n     }\n \n     // Unwrap and return the result.\n-    return @dvec::unwrap(move result);\n+    return @dvec::unwrap(result);\n }\n \n pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {"}, {"sha": "3524636fe2b776b17019bb4fc7edd17cc07d8a3c", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -139,7 +139,7 @@ pub fn lookup(\n     let mme = lcx.do_lookup(self_ty);\n     debug!(\"method lookup for %s yielded %?\",\n            expr_repr(fcx.tcx(), expr), mme);\n-    return move mme;\n+    return mme;\n }\n \n pub struct LookupContext {\n@@ -204,26 +204,26 @@ pub impl LookupContext {\n                 check::DontDerefArgs => {\n                     match self.search_for_autoderefd_method(self_ty,\n                                                             autoderefs) {\n-                        Some(move mme) => { return Some(mme); }\n+                        Some(mme) => { return Some(mme); }\n                         None => {}\n                     }\n \n                     match self.search_for_autoptrd_method(self_ty,\n                                                           autoderefs) {\n-                        Some(move mme) => { return Some(move mme); }\n+                        Some(mme) => { return Some(mme); }\n                         None => {}\n                     }\n                 }\n                 check::DoDerefArgs => {\n                     match self.search_for_autoptrd_method(self_ty,\n                                                           autoderefs) {\n-                        Some(move mme) => { return Some(move mme); }\n+                        Some(mme) => { return Some(mme); }\n                         None => {}\n                     }\n \n                     match self.search_for_autoderefd_method(self_ty,\n                                                             autoderefs) {\n-                        Some(move mme) => { return Some(mme); }\n+                        Some(mme) => { return Some(mme); }\n                         None => {}\n                     }\n                 }\n@@ -457,7 +457,7 @@ pub impl LookupContext {\n                     self.create_rcvr_ty_and_substs_for_method(\n                         method.self_ty,\n                         rcvr_ty,\n-                        move init_substs,\n+                        init_substs,\n                         TransformTypeNormally);\n \n                 let cand = Candidate {\n@@ -525,12 +525,12 @@ pub impl LookupContext {\n         let (rcvr_ty, rcvr_substs) =\n             self.create_rcvr_ty_and_substs_for_method(method.self_ty,\n                                                       self_ty,\n-                                                      move rcvr_substs,\n+                                                      rcvr_substs,\n                                                       TransformTypeForObject);\n \n         self.inherent_candidates.push(Candidate {\n             rcvr_ty: rcvr_ty,\n-            rcvr_substs: move rcvr_substs,\n+            rcvr_substs: rcvr_substs,\n             explicit_self: method.self_ty,\n             num_method_tps: method.tps.len(),\n             self_mode: get_mode_from_self_type(method.self_ty),\n@@ -585,7 +585,7 @@ pub impl LookupContext {\n                     self.create_rcvr_ty_and_substs_for_method(\n                         method_self_ty,\n                         self_ty,\n-                        move rcvr_substs,\n+                        rcvr_substs,\n                         TransformTypeNormally);\n                 let origin = if trait_did == did {\n                     method_self(trait_did, index)\n@@ -595,7 +595,7 @@ pub impl LookupContext {\n                 };\n                 self.inherent_candidates.push(Candidate {\n                     rcvr_ty: rcvr_ty,\n-                    rcvr_substs: move rcvr_substs,\n+                    rcvr_substs: rcvr_substs,\n                     explicit_self: method_self_ty,\n                     num_method_tps: method_num_tps,\n                     self_mode: get_mode_from_self_type(method_self_ty),\n@@ -648,12 +648,12 @@ pub impl LookupContext {\n             self.create_rcvr_ty_and_substs_for_method(\n                 method.self_type,\n                 impl_ty,\n-                move impl_substs,\n+                impl_substs,\n                 TransformTypeNormally);\n \n         candidates.push(Candidate {\n             rcvr_ty: impl_ty,\n-            rcvr_substs: move impl_substs,\n+            rcvr_substs: impl_substs,\n             explicit_self: method.self_type,\n             num_method_tps: method.n_tps,\n             self_mode: get_mode_from_self_type(method.self_type),\n@@ -693,7 +693,7 @@ pub impl LookupContext {\n \n             candidates.push(Candidate {\n                 rcvr_ty: impl_ty,\n-                rcvr_substs: move impl_substs,\n+                rcvr_substs: impl_substs,\n                 explicit_self: provided_method_info.method_info.self_type,\n                 num_method_tps: provided_method_info.method_info.n_tps,\n                 self_mode: get_mode_from_self_type(\n@@ -722,10 +722,10 @@ pub impl LookupContext {\n             match self_decl {\n                 sty_static | sty_value | sty_by_ref |\n                 sty_box(_) | sty_uniq(_) => {\n-                    move self_substs\n+                    self_substs\n                 }\n                 sty_region(_) if self_substs.self_r.is_some() => {\n-                    move self_substs\n+                    self_substs\n                 }\n                 sty_region(_) => {\n                     substs {\n@@ -761,7 +761,7 @@ pub impl LookupContext {\n             self.consider_reborrow(self_ty, autoderefs);\n         match self.search_for_method(self_ty) {\n             None => None,\n-            Some(move mme) => {\n+            Some(mme) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n                        adjustment (%u) to %d\",\n                        autoderefs,\n@@ -945,7 +945,7 @@ pub impl LookupContext {\n             let autoref_ty = mk_autoref_ty(*mutbl, region);\n             match self.search_for_method(autoref_ty) {\n                 None => {}\n-                Some(move mme) => {\n+                Some(mme) => {\n                     self.fcx.write_adjustment(\n                         self.self_expr.id,\n                         @ty::AutoAdjustment {\n@@ -977,8 +977,8 @@ pub impl LookupContext {\n         debug!(\"searching inherent candidates\");\n         match self.consider_candidates(self_ty, &self.inherent_candidates) {\n             None => {}\n-            Some(move mme) => {\n-                return Some(move mme);\n+            Some(mme) => {\n+                return Some(mme);\n             }\n         }\n \n@@ -987,8 +987,8 @@ pub impl LookupContext {\n             None => {\n                 return None;\n             }\n-            Some(move mme) => {\n-                return Some(move mme);\n+            Some(mme) => {\n+                return Some(mme);\n             }\n         }\n     }"}, {"sha": "706f6d82c879b80a55bd9c3b0004889bb11eed3b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -870,7 +870,7 @@ pub impl FnCtxt {\n         self.region_lb = lb;\n         let v = f();\n         self.region_lb = old_region_lb;\n-        move v\n+        v\n     }\n \n     fn region_var_if_parameterized(@mut self,"}, {"sha": "7594b2690a4a3e5fc433fccd3cf459e08b46c8e4", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -553,7 +553,7 @@ pub impl CoherenceChecker {\n \n         UniversalQuantificationResult {\n             monotype: monotype,\n-            type_variables: move type_parameters,\n+            type_variables: type_parameters,\n             bounds: polytype.bounds\n         }\n     }"}, {"sha": "17ed0c0a93f5be109e2612757a10d72c5dbc913d", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -320,7 +320,7 @@ pub fn ensure_supertraits(ccx: @mut CrateCtxt,\n         instantiated.push(InstantiatedTraitRef { def_id: did, tpt: tpt });\n     }\n     tcx.supertraits.insert(local_def(id),\n-                               @dvec::unwrap(move instantiated));\n+                               @dvec::unwrap(instantiated));\n }\n \n /**"}, {"sha": "89719564adaa61d8343ea5088252afd66cba355c", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -121,9 +121,9 @@ pub struct CombineFields {\n pub fn expected_found<C:Combine,T>(\n         self: &C, +a: T, +b: T) -> ty::expected_found<T> {\n     if self.a_is_expected() {\n-        ty::expected_found {expected: move a, found: move b}\n+        ty::expected_found {expected: a, found: b}\n     } else {\n-        ty::expected_found {expected: move b, found: move a}\n+        ty::expected_found {expected: b, found: a}\n     }\n }\n "}, {"sha": "e51fd14f6651195a097beb75e0df139753bf57a3", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -186,7 +186,7 @@ pub impl Glb: Combine {\n                                               new_vars, a_isr, a_vars, b_vars,\n                                               r));\n         debug!(\"sig1 = %s\", sig1.inf_str(self.infcx));\n-        return Ok(move sig1);\n+        return Ok(sig1);\n \n         fn generalize_region(self: &Glb,\n                              snapshot: uint,"}, {"sha": "fd4b2fdf32bf39886e2170706b3d38f37717a475", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -144,7 +144,7 @@ pub impl Lub: Combine {\n                 &sig0,\n                 |r, _in_fn| generalize_region(&self, snapshot, new_vars,\n                                               a_isr, r));\n-        return Ok(move sig1);\n+        return Ok(sig1);\n \n         fn generalize_region(self: &Lub,\n                              snapshot: uint,"}, {"sha": "01174d1620adab490cb41e56a23a28d8b63287d7", "filename": "src/librustc/middle/typeck/infer/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -13,8 +13,8 @@\n macro_rules! if_ok(\n     ($inp: expr) => (\n         match $inp {\n-            Ok(move v) => { move v }\n-            Err(move e) => { return Err(e); }\n+            Ok(v) => { v }\n+            Err(e) => { return Err(e); }\n         }\n     )\n );"}, {"sha": "4f7507d4c5a2b7de235fc6dfd067a5926c527048", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -599,7 +599,7 @@ impl @mut InferCtxt {\n             self.ty_var_bindings.bindings.truncate(0);\n             self.int_var_bindings.bindings.truncate(0);\n             self.region_vars.commit();\n-            move r\n+            r\n         }\n     }\n \n@@ -613,7 +613,7 @@ impl @mut InferCtxt {\n               Ok(_) => (),\n               Err(_) => self.rollback_to(&snapshot)\n             }\n-            move r\n+            r\n         }\n     }\n \n@@ -624,7 +624,7 @@ impl @mut InferCtxt {\n             let snapshot = self.start_snapshot();\n             let r = self.try(f);\n             self.rollback_to(&snapshot);\n-            move r\n+            r\n         }\n     }\n }"}, {"sha": "cc5e860715d6d791fdea806170e57d90c63d0b90", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -899,7 +899,7 @@ pub impl RegionVarBindings {\n                 // replace the NoValue entry with ErrorValue.\n                 let mut values = self.values.take();\n                 values[*rid] = ErrorValue;\n-                self.values.put_back(move values);\n+                self.values.put_back(values);\n                 re_static\n             }\n \n@@ -999,9 +999,9 @@ pub impl RegionVarBindings {\n                     None => {}\n                     Some((ref r1, ref r2)) => {\n                         result_set =\n-                            consider_adding_edge(move result_set, &r, r1, r2);\n+                            consider_adding_edge(result_set, &r, r1, r2);\n                         result_set =\n-                            consider_adding_edge(move result_set, &r, r2, r1);\n+                            consider_adding_edge(result_set, &r, r2, r1);\n                     }\n                 }\n \n@@ -1018,13 +1018,13 @@ pub impl RegionVarBindings {\n                                 r1: &Region,\n                                 r2: &Region) -> ~[Region]\n         {\n-            let mut result_set = move result_set;\n+            let mut result_set = result_set;\n             if *r == *r1 { // Clearly, this is potentially inefficient.\n                 if !result_set.contains(r2) {\n                     result_set.push(*r2);\n                 }\n             }\n-            return move result_set;\n+            return result_set;\n         }\n     }\n \n@@ -1254,8 +1254,8 @@ impl RegionVarBindings {\n         }\n \n         let mut graph = Graph {\n-            nodes: move nodes,\n-            edges: move edges\n+            nodes: nodes,\n+            edges: edges\n         };\n \n         for uint::range(0, num_edges) |edge_idx| {\n@@ -1273,7 +1273,7 @@ impl RegionVarBindings {\n             }\n         }\n \n-        return (move graph);\n+        return (graph);\n \n         fn insert_edge(+graph: &mut Graph,\n                        node_id: RegionVid,"}, {"sha": "27355da4b9aeea129eaaf6edbd22135bb17ed816", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -69,7 +69,7 @@ fn setup_env(test_name: &str, source_string: &str) -> Env {\n         cfg, parse_sess);\n \n     let tcx = ty::mk_ctxt(sess, dm, amap, freevars, region_map,\n-                          region_paramd_items, move lang_items, crate);\n+                          region_paramd_items, lang_items, crate);\n \n     let infcx = infer::new_infer_ctxt(tcx);\n \n@@ -192,7 +192,7 @@ impl Env {\n                           onceness: ast::Many,\n                           region: ty::re_static,\n                           bounds: @~[]},\n-            sig: FnSig {inputs: move inputs,\n+            sig: FnSig {inputs: inputs,\n                         output: output_ty}\n         })\n     }"}, {"sha": "52a8e5488d8df036cde76d137c104e6f876d20db", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -326,7 +326,7 @@ pub fn monitor(+f: fn~(diagnostic::Emitter)) {\n     let (p, ch) = stream();\n     let ch = SharedChan(ch);\n     let ch_capture = ch.clone();\n-    match do task::try |move f| {\n+    match do task::try || {\n         let ch = ch_capture.clone();\n         let ch_capture = ch.clone();\n         // The 'diagnostics emitter'. Every error, warning, etc. should\n@@ -375,7 +375,7 @@ pub fn monitor(+f: fn~(diagnostic::Emitter)) {\n \n pub fn main() {\n     let args = os::args();\n-    do monitor |move args, demitter| {\n+    do monitor |demitter| {\n         run_compiler(&args, demitter);\n     }\n }"}, {"sha": "7b980b9de0db61fbf3897e71708c2abdf8e14304", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -27,7 +27,7 @@ pub fn indent<R>(op: fn() -> R) -> R {\n     debug!(\">>\");\n     let r = op();\n     debug!(\"<< (Result = %?)\", r);\n-    move r\n+    r\n }\n \n pub struct _indenter {"}, {"sha": "f34a7ffbbdbcf9a3c10abfb8627947f0f572eb8f", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -91,7 +91,7 @@ fn run<T>(owner: SrvOwner<T>, source: ~str, parse: Parser) -> T {\n \n     let res = owner(srv_.clone());\n     srv_.ch.send(Exit);\n-    move res\n+    res\n }\n \n fn act(po: &Port<Msg>, source: ~str, parse: Parser) {\n@@ -120,10 +120,10 @@ pub fn exec<T:Owned>(\n     f: fn~(ctxt: Ctxt) -> T\n ) -> T {\n     let (po, ch) = stream();\n-    let msg = HandleRequest(fn~(move f, ctxt: Ctxt) {\n+    let msg = HandleRequest(fn~(ctxt: Ctxt) {\n         ch.send(f(ctxt))\n     });\n-    srv.ch.send(move msg);\n+    srv.ch.send(msg);\n     po.recv()\n }\n "}, {"sha": "85ac952d6d4813fe0563f4df0774134b405b04f8", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -115,7 +115,7 @@ fn parse_item_attrs<T:Owned>(\n     srv: astsrv::Srv,\n     id: doc::AstId,\n     parse_attrs: fn~(a: ~[ast::attribute]) -> T) -> T {\n-    do astsrv::exec(srv) |move parse_attrs, ctxt| {\n+    do astsrv::exec(srv) |ctxt| {\n         let attrs = match ctxt.ast_map.get(&id) {\n           ast_map::node_item(item, _) => copy item.attrs,\n           ast_map::node_foreign_item(item, _, _) => copy item.attrs,"}, {"sha": "ceea3d0e798d22353b0b9436a7546b202daf4c33", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -133,7 +133,7 @@ pub fn parse_config_(\n         result::Ok(matches) => {\n             if matches.free.len() == 1 {\n                 let input_crate = Path(vec::head(matches.free));\n-                config_from_opts(&input_crate, &matches, move program_output)\n+                config_from_opts(&input_crate, &matches, program_output)\n             } else if matches.free.is_empty() {\n                 result::Err(~\"no crates specified\")\n             } else {\n@@ -191,11 +191,11 @@ fn config_from_opts(\n             }\n         }\n     };\n-    let program_output = Cell(move program_output);\n+    let program_output = Cell(program_output);\n     let result = do result::chain(result) |config| {\n         let pandoc_cmd = getopts::opt_maybe_str(matches, opt_pandoc_cmd());\n         let pandoc_cmd = maybe_find_pandoc(\n-            &config, pandoc_cmd, move program_output.take());\n+            &config, pandoc_cmd, program_output.take());\n         do result::chain(pandoc_cmd) |pandoc_cmd| {\n             result::Ok(Config {\n                 pandoc_cmd: pandoc_cmd,\n@@ -268,7 +268,7 @@ fn should_find_pandoc() {\n             status: 0, out: ~\"pandoc 1.8.2.1\", err: ~\"\"\n         }\n     };\n-    let result = maybe_find_pandoc(&config, None, move mock_program_output);\n+    let result = maybe_find_pandoc(&config, None, mock_program_output);\n     assert result == result::Ok(Some(~\"pandoc\"));\n }\n \n@@ -284,7 +284,7 @@ fn should_error_with_no_pandoc() {\n             status: 1, out: ~\"\", err: ~\"\"\n         }\n     };\n-    let result = maybe_find_pandoc(&config, None, move mock_program_output);\n+    let result = maybe_find_pandoc(&config, None, mock_program_output);\n     assert result == result::Err(~\"couldn't find pandoc\");\n }\n "}, {"sha": "113cce422c474259ab4ffb5c057cb2e230a29e3d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -87,25 +87,25 @@ fn mk_fold<T>(\n     fold_struct: FoldStruct<T>\n ) -> Fold<T> {\n     Fold {\n-        ctxt: move ctxt,\n-        fold_doc: move fold_doc,\n-        fold_crate: move fold_crate,\n-        fold_item: move fold_item,\n-        fold_mod: move fold_mod,\n-        fold_nmod: move fold_nmod,\n-        fold_fn: move fold_fn,\n-        fold_const: move fold_const,\n-        fold_enum: move fold_enum,\n-        fold_trait: move fold_trait,\n-        fold_impl: move fold_impl,\n-        fold_type: move fold_type,\n-        fold_struct: move fold_struct\n+        ctxt: ctxt,\n+        fold_doc: fold_doc,\n+        fold_crate: fold_crate,\n+        fold_item: fold_item,\n+        fold_mod: fold_mod,\n+        fold_nmod: fold_nmod,\n+        fold_fn: fold_fn,\n+        fold_const: fold_const,\n+        fold_enum: fold_enum,\n+        fold_trait: fold_trait,\n+        fold_impl: fold_impl,\n+        fold_type: fold_type,\n+        fold_struct: fold_struct\n     }\n }\n \n pub fn default_any_fold<T: Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n-        move ctxt,\n+        ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n         |f, d| default_seq_fold_crate(f, d),\n         |f, d| default_seq_fold_item(f, d),\n@@ -123,7 +123,7 @@ pub fn default_any_fold<T: Clone>(ctxt: T) -> Fold<T> {\n \n pub fn default_seq_fold<T: Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n-        move ctxt,\n+        ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n         |f, d| default_seq_fold_crate(f, d),\n         |f, d| default_seq_fold_item(f, d),\n@@ -141,7 +141,7 @@ pub fn default_seq_fold<T: Clone>(ctxt: T) -> Fold<T> {\n \n pub fn default_par_fold<T: Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n-        move ctxt,\n+        ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n         |f, d| default_seq_fold_crate(f, d),\n         |f, d| default_seq_fold_item(f, d),"}, {"sha": "6a56a1c66e71a845014221ae1c9a8694109b4cb2", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -74,7 +74,7 @@ fn run(\n         ~\"mods last\", mods_last\n     ).f)(srv, copy doc);\n \n-    write_markdown(sorted_doc, move writer_factory);\n+    write_markdown(sorted_doc, writer_factory);\n \n     return doc;\n }\n@@ -148,7 +148,7 @@ fn should_request_new_writer_for_each_page() {\n     let (srv, doc) = test::create_doc_srv(~\"mod a { }\");\n     // Split the document up into pages\n     let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n-    write_markdown(doc, move writer_factory);\n+    write_markdown(doc, writer_factory);\n     // We expect two pages to have been written\n     for iter::repeat(2) {\n         po.recv();\n@@ -180,7 +180,7 @@ fn should_write_title_for_each_page() {\n     let (srv, doc) = test::create_doc_srv(\n         ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n     let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n-    write_markdown(doc, move writer_factory);\n+    write_markdown(doc, writer_factory);\n     for iter::repeat(2) {\n         let (page, markdown) = po.recv();\n         match page {\n@@ -894,7 +894,7 @@ mod test {\n         doc: doc::Doc\n     ) -> ~str {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n-        write_markdown(doc, move writer_factory);\n+        write_markdown(doc, writer_factory);\n         return po.recv().second();\n     }\n \n@@ -903,7 +903,7 @@ mod test {\n         doc: doc::Doc\n     ) -> ~str {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n-        let pass = mk_pass(move writer_factory);\n+        let pass = mk_pass(writer_factory);\n         (pass.f)(srv, doc);\n         return po.recv().second();\n     }"}, {"sha": "a6cc517079693efb49f04e8e621b848ff36ed083", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -129,12 +129,12 @@ fn pandoc_writer(\n         os::close(pipe_in.out);\n \n         let (stdout_po, stdout_ch) = pipes::stream();\n-        do task::spawn_sched(task::SingleThreaded) |move stdout_ch| {\n+        do task::spawn_sched(task::SingleThreaded) || {\n             stdout_ch.send(readclose(pipe_out.in));\n         }\n \n         let (stderr_po, stderr_ch) = pipes::stream();\n-        do task::spawn_sched(task::SingleThreaded) |move stderr_ch| {\n+        do task::spawn_sched(task::SingleThreaded) || {\n             stderr_ch.send(readclose(pipe_err.in));\n         }\n         let stdout = stdout_po.recv();\n@@ -169,7 +169,7 @@ fn readclose(fd: libc::c_int) -> ~str {\n \n fn generic_writer(process: fn~(markdown: ~str)) -> Writer {\n     let (po, ch) = stream::<WriteInstr>();\n-    do task::spawn |move process, move setup_ch| {\n+    do task::spawn || {\n         let mut markdown = ~\"\";\n         let mut keep_going = true;\n         while keep_going {\n@@ -178,7 +178,7 @@ fn generic_writer(process: fn~(markdown: ~str)) -> Writer {\n               Done => keep_going = false\n             }\n         }\n-        process(move markdown);\n+        process(markdown);\n     };\n     fn~(instr: WriteInstr) {\n         ch.send(instr);\n@@ -298,24 +298,24 @@ pub fn future_writer_factory(\n     let writer_factory = fn~(page: doc::Page) -> Writer {\n         let (writer_po, writer_ch) = pipes::stream();\n         let markdown_ch = markdown_ch.clone();\n-        do task::spawn |move writer_ch| {\n+        do task::spawn || {\n             let (writer, future) = future_writer();\n-            writer_ch.send(move writer);\n+            writer_ch.send(writer);\n             let s = future.get();\n             markdown_ch.send((copy page, s));\n         }\n         writer_po.recv()\n     };\n \n-    (move writer_factory, markdown_po)\n+    (writer_factory, markdown_po)\n }\n \n fn future_writer() -> (Writer, future::Future<~str>) {\n     let (port, chan) = pipes::stream();\n-    let writer = fn~(move chan, instr: WriteInstr) {\n+    let writer = fn~(instr: WriteInstr) {\n         chan.send(copy instr);\n     };\n-    let future = do future::from_fn |move port| {\n+    let future = do future::from_fn || {\n         let mut res = ~\"\";\n         loop {\n             match port.recv() {\n@@ -325,5 +325,5 @@ fn future_writer() -> (Writer, future::Future<~str>) {\n         }\n         res\n     };\n-    (move writer, move future)\n+    (writer, future)\n }"}, {"sha": "4971806c7ed8102059c015d3c8ac5b0279478d5d", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -71,7 +71,7 @@ fn make_doc_from_pages(page_port: &PagePort) -> doc::Doc {\n     loop {\n         let val = page_port.recv();\n         if val.is_some() {\n-            pages += ~[option::unwrap(move val)];\n+            pages += ~[option::unwrap(val)];\n         } else {\n             break;\n         }"}, {"sha": "ac50221445f7364aec453b4a5cbb13013b8f94f7", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -54,7 +54,7 @@ fn run(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n         fold_item: fold_item,\n         fold_mod: fold_mod,\n         fold_nmod: fold_nmod,\n-        .. fold::default_any_fold(move ctxt)\n+        .. fold::default_any_fold(ctxt)\n     };\n     (fold.fold_doc)(&fold, doc)\n }"}, {"sha": "7d94352cc8233ac791f20f8db55ee05452581a43", "filename": "src/librustdoc/rustdoc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rc?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -149,5 +149,5 @@ fn time<T>(what: ~str, f: fn() -> T) -> T {\n     let rv = f();\n     let end = std::time::precise_time_s();\n     info!(\"time: %3.3f s    %s\", end - start, what);\n-    move rv\n+    rv\n }"}, {"sha": "3bdb08974044d778376dbcd383908852ed51902c", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -42,7 +42,7 @@ fn run(\n ) -> doc::Doc {\n     let fold = Fold {\n         fold_mod: fold_mod,\n-        .. fold::default_any_fold(move lteq)\n+        .. fold::default_any_fold(lteq)\n     };\n     (fold.fold_doc)(&fold, doc)\n }"}, {"sha": "ab1d77a36db406334b0d9964df303e72c30070ad", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -42,14 +42,14 @@ fn run(\n     op: Op\n ) -> doc::Doc {\n     let op = NominalOp {\n-        op: move op\n+        op: op\n     };\n     let fold = Fold {\n         fold_item: fold_item,\n         fold_enum: fold_enum,\n         fold_trait: fold_trait,\n         fold_impl: fold_impl,\n-        .. fold::default_any_fold(move op)\n+        .. fold::default_any_fold(op)\n     };\n     (fold.fold_doc)(&fold, doc)\n }"}, {"sha": "66b02ae553c4e7d9eb1d0c3e301094594ba9ace5", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -81,7 +81,7 @@ struct ARC<T> { x: SharedMutableState<T> }\n \n /// Create an atomically reference counted wrapper.\n pub fn ARC<T: Const Owned>(data: T) -> ARC<T> {\n-    ARC { x: unsafe { shared_mutable_state(move data) } }\n+    ARC { x: unsafe { shared_mutable_state(data) } }\n }\n \n /**\n@@ -113,8 +113,8 @@ pub fn clone<T: Const Owned>(rc: &ARC<T>) -> ARC<T> {\n  * guaranteed to deadlock.\n  */\n pub fn unwrap<T: Const Owned>(rc: ARC<T>) -> T {\n-    let ARC { x: x } = move rc;\n-    unsafe { unwrap_shared_mutable_state(move x) }\n+    let ARC { x: x } = rc;\n+    unsafe { unwrap_shared_mutable_state(x) }\n }\n \n impl<T: Const Owned> Clone for ARC<T> {\n@@ -134,7 +134,7 @@ struct MutexARC<T> { x: SharedMutableState<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n pub fn MutexARC<T: Owned>(user_data: T) -> MutexARC<T> {\n-    mutex_arc_with_condvars(move user_data, 1)\n+    mutex_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a mutex-protected ARC with the supplied data and a specified number\n@@ -144,8 +144,8 @@ pub fn mutex_arc_with_condvars<T: Owned>(user_data: T,\n                                     num_condvars: uint) -> MutexARC<T> {\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n-                          failed: false, data: move user_data };\n-    MutexARC { x: unsafe { shared_mutable_state(move data) } }\n+                          failed: false, data: user_data };\n+    MutexARC { x: unsafe { shared_mutable_state(data) } }\n }\n \n impl<T: Owned> Clone for MutexARC<T> {\n@@ -220,13 +220,13 @@ impl<T: Owned> &MutexARC<T> {\n  */\n // FIXME(#3724) make this a by-move method on the arc\n pub fn unwrap_mutex_arc<T: Owned>(arc: MutexARC<T>) -> T {\n-    let MutexARC { x: x } = move arc;\n-    let inner = unsafe { unwrap_shared_mutable_state(move x) };\n-    let MutexARCInner { failed: failed, data: data, _ } = move inner;\n+    let MutexARC { x: x } = arc;\n+    let inner = unsafe { unwrap_shared_mutable_state(x) };\n+    let MutexARCInner { failed: failed, data: data, _ } = inner;\n     if failed {\n         fail!(~\"Can't unwrap poisoned MutexARC - another task failed inside!\")\n     }\n-    move data\n+    data\n }\n \n // Common code for {mutex.access,rwlock.write}{,_cond}.\n@@ -284,7 +284,7 @@ struct RWARC<T> {\n \n /// Create a reader/writer ARC with the supplied data.\n pub fn RWARC<T: Const Owned>(user_data: T) -> RWARC<T> {\n-    rw_arc_with_condvars(move user_data, 1)\n+    rw_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a reader/writer ARC with the supplied data and a specified number\n@@ -296,8 +296,8 @@ pub fn rw_arc_with_condvars<T: Const Owned>(\n {\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n-                     failed: false, data: move user_data };\n-    RWARC { x: unsafe { shared_mutable_state(move data) }, cant_nest: () }\n+                     failed: false, data: user_data };\n+    RWARC { x: unsafe { shared_mutable_state(data) }, cant_nest: () }\n }\n \n impl<T: Const Owned> RWARC<T> {\n@@ -386,7 +386,7 @@ impl<T: Const Owned> &RWARC<T> {\n             do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n                 check_poison(false, (*state).failed);\n                 blk(RWWriteMode((&mut (*state).data,\n-                                 move write_mode,\n+                                 write_mode,\n                                  PoisonOnFail(&mut (*state).failed))))\n             }\n         }\n@@ -396,17 +396,17 @@ impl<T: Const Owned> &RWARC<T> {\n     fn downgrade(token: RWWriteMode/&a<T>) -> RWReadMode/&a<T> {\n         // The rwlock should assert that the token belongs to us for us.\n         let state = unsafe { get_shared_immutable_state(&self.x) };\n-        let RWWriteMode((data, t, _poison)) = move token;\n+        let RWWriteMode((data, t, _poison)) = token;\n         // Let readers in\n-        let new_token = (&state.lock).downgrade(move t);\n+        let new_token = (&state.lock).downgrade(t);\n         // Whatever region the input reference had, it will be safe to use\n         // the same region for the output reference. (The only 'unsafe' part\n         // of this cast is removing the mutability.)\n         let new_data = unsafe { cast::transmute_immut(data) };\n         // Downgrade ensured the token belonged to us. Just a sanity check.\n         assert ptr::ref_eq(&state.data, new_data);\n         // Produce new token\n-        RWReadMode((new_data, move new_token))\n+        RWReadMode((new_data, new_token))\n     }\n }\n \n@@ -419,13 +419,13 @@ impl<T: Const Owned> &RWARC<T> {\n  */\n // FIXME(#3724) make this a by-move method on the arc\n pub fn unwrap_rw_arc<T: Const Owned>(arc: RWARC<T>) -> T {\n-    let RWARC { x: x, _ } = move arc;\n-    let inner = unsafe { unwrap_shared_mutable_state(move x) };\n-    let RWARCInner { failed: failed, data: data, _ } = move inner;\n+    let RWARC { x: x, _ } = arc;\n+    let inner = unsafe { unwrap_shared_mutable_state(x) };\n+    let RWARCInner { failed: failed, data: data, _ } = inner;\n     if failed {\n         fail!(~\"Can't unwrap poisoned RWARC - another task failed inside!\")\n     }\n-    move data\n+    data\n }\n \n // Borrowck rightly complains about immutably aliasing the rwlock in order to\n@@ -509,7 +509,7 @@ mod tests {\n \n         let (p, c) = pipes::stream();\n \n-        do task::spawn() |move c| {\n+        do task::spawn() || {\n             let p = pipes::PortSet();\n             c.send(p.chan());\n \n@@ -532,8 +532,8 @@ mod tests {\n         let arc = ~MutexARC(false);\n         let arc2 = ~arc.clone();\n         let (p,c) = pipes::oneshot();\n-        let (c,p) = (~mut Some(move c), ~mut Some(move p));\n-        do task::spawn |move arc2, move p| {\n+        let (c,p) = (~mut Some(c), ~mut Some(p));\n+        do task::spawn || {\n             // wait until parent gets in\n             pipes::recv_one(option::swap_unwrap(p));\n             do arc2.access_cond |state, cond| {\n@@ -555,7 +555,7 @@ mod tests {\n         let arc2 = ~arc.clone();\n         let (p, c) = pipes::stream();\n \n-        do task::spawn_unlinked |move arc2, move p| {\n+        do task::spawn_unlinked || {\n             let _ = p.recv();\n             do arc2.access_cond |one, cond| {\n                 cond.signal();\n@@ -574,7 +574,7 @@ mod tests {\n     pub fn test_mutex_arc_poison() {\n         let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.access |one| {\n                 assert *one == 2;\n             }\n@@ -588,21 +588,21 @@ mod tests {\n         let arc = MutexARC(1);\n         let arc2 = ~(&arc).clone();\n         let (p, c) = pipes::stream();\n-        do task::spawn |move c, move arc2| {\n+        do task::spawn || {\n             do arc2.access |one| {\n                 c.send(());\n                 assert *one == 2;\n             }\n         }\n         let _ = p.recv();\n-        let one = unwrap_mutex_arc(move arc);\n+        let one = unwrap_mutex_arc(arc);\n         assert one == 1;\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     pub fn test_rw_arc_poison_wr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.write |one| {\n                 assert *one == 2;\n             }\n@@ -615,7 +615,7 @@ mod tests {\n     pub fn test_rw_arc_poison_ww() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.write |one| {\n                 assert *one == 2;\n             }\n@@ -628,7 +628,7 @@ mod tests {\n     pub fn test_rw_arc_poison_dw() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.write_downgrade |write_mode| {\n                 do (&write_mode).write |one| {\n                     assert *one == 2;\n@@ -643,7 +643,7 @@ mod tests {\n     pub fn test_rw_arc_no_poison_rr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.read |one| {\n                 assert *one == 2;\n             }\n@@ -656,7 +656,7 @@ mod tests {\n     pub fn test_rw_arc_no_poison_rw() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.read |one| {\n                 assert *one == 2;\n             }\n@@ -669,9 +669,9 @@ mod tests {\n     pub fn test_rw_arc_no_poison_dr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.write_downgrade |write_mode| {\n-                let read_mode = arc2.downgrade(move write_mode);\n+                let read_mode = arc2.downgrade(write_mode);\n                 do (&read_mode).read |one| {\n                     assert *one == 2;\n                 }\n@@ -687,7 +687,7 @@ mod tests {\n         let arc2 = ~arc.clone();\n         let (p,c) = pipes::stream();\n \n-        do task::spawn |move arc2, move c| {\n+        do task::spawn || {\n             do arc2.write |num| {\n                 for 10.times {\n                     let tmp = *num;\n@@ -703,8 +703,8 @@ mod tests {\n         let mut children = ~[];\n         for 5.times {\n             let arc3 = ~arc.clone();\n-            do task::task().future_result(|+r| children.push(move r)).spawn\n-                |move arc3| {\n+            do task::task().future_result(|+r| children.push(r)).spawn\n+                || {\n                 do arc3.read |num| {\n                     assert *num >= 0;\n                 }\n@@ -732,9 +732,9 @@ mod tests {\n         let mut reader_convos = ~[];\n         for 10.times {\n             let ((rp1,rc1),(rp2,rc2)) = (pipes::stream(),pipes::stream());\n-            reader_convos.push((move rc1, move rp2));\n+            reader_convos.push((rc1, rp2));\n             let arcn = ~arc.clone();\n-            do task::spawn |move rp1, move rc2, move arcn| {\n+            do task::spawn || {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n                 do arcn.read |state| {\n                     assert *state == 31337;\n@@ -746,7 +746,7 @@ mod tests {\n         // Writer task\n         let arc2 = ~arc.clone();\n         let ((wp1,wc1),(wp2,wc2)) = (pipes::stream(),pipes::stream());\n-        do task::spawn |move arc2, move wc2, move wp1| {\n+        do task::spawn || {\n             wp1.recv();\n             do arc2.write_cond |state, cond| {\n                 assert *state == 0;\n@@ -779,7 +779,7 @@ mod tests {\n                     }\n                 }\n             }\n-            let read_mode = arc.downgrade(move write_mode);\n+            let read_mode = arc.downgrade(write_mode);\n             do (&read_mode).read |state| {\n                 // complete handshake with other readers\n                 for vec::each(reader_convos) |x| {"}, {"sha": "75b97f494bd6f3c168f16a92ee59d56d17d2e421", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -108,7 +108,7 @@ struct BigBitv {\n }\n \n fn BigBitv(storage: ~[uint]) -> BigBitv {\n-    BigBitv {storage: move storage}\n+    BigBitv {storage: storage}\n }\n \n /**\n@@ -232,9 +232,9 @@ pub fn Bitv (nbits: uint, init: bool) -> Bitv {\n                      if nbits % uint_bits == 0 {0} else {1};\n         let elem = if init {!0} else {0};\n         let s = from_elem(nelems, elem);\n-        Big(~BigBitv(move s))\n+        Big(~BigBitv(s))\n     };\n-    Bitv {rep: move rep, nbits: nbits}\n+    Bitv {rep: rep, nbits: nbits}\n }\n \n priv impl Bitv {\n@@ -519,7 +519,7 @@ impl Clone for Bitv {\n             let mut st = from_elem(self.nbits / uint_bits + 1, 0);\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n-            Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: move st})}\n+            Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: st})}\n           }\n         }\n     }\n@@ -555,7 +555,7 @@ pub fn from_fn(len: uint, f: fn(index: uint) -> bool) -> Bitv {\n     for uint::range(0, len) |i| {\n         bitv.set(i, f(i));\n     }\n-    move bitv\n+    bitv\n }\n \n const uint_bits: uint = 32u + (1u << 32u >> 27u);"}, {"sha": "c8121daddabd03e423df8226d57e83d17c698541", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -21,7 +21,7 @@ pub struct Cell<T> {\n \n /// Creates a new full cell with the given value.\n pub fn Cell<T>(value: T) -> Cell<T> {\n-    Cell { value: Some(move value) }\n+    Cell { value: Some(value) }\n }\n \n pub pure fn empty_cell<T>() -> Cell<T> {\n@@ -37,15 +37,15 @@ impl<T> Cell<T> {\n \n         let mut value = None;\n         value <-> self.value;\n-        return option::unwrap(move value);\n+        return option::unwrap(value);\n     }\n \n     /// Returns the value, failing if the cell is full.\n     fn put_back(value: T) {\n         if !self.is_empty() {\n             fail!(~\"attempt to put a value back into a full cell\");\n         }\n-        self.value = Some(move value);\n+        self.value = Some(value);\n     }\n \n     /// Returns true if the cell is empty and false if the cell is full.\n@@ -57,8 +57,8 @@ impl<T> Cell<T> {\n     fn with_ref<R>(op: fn(v: &T) -> R) -> R {\n         let v = self.take();\n         let r = op(&v);\n-        self.put_back(move v);\n-        move r\n+        self.put_back(v);\n+        r\n     }\n }\n \n@@ -69,7 +69,7 @@ fn test_basic() {\n     let value = value_cell.take();\n     assert value == ~10;\n     assert value_cell.is_empty();\n-    value_cell.put_back(move value);\n+    value_cell.put_back(value);\n     assert !value_cell.is_empty();\n }\n "}, {"sha": "c2c21002b195da3373a7c4573363a3c4437e48a1", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -27,13 +27,13 @@ pub struct DuplexStream<T, U> {\n \n impl<T: Owned, U: Owned> GenericChan<T> for DuplexStream<T, U> {\n     fn send(x: T) {\n-        self.chan.send(move x)\n+        self.chan.send(x)\n     }\n }\n \n impl<T: Owned, U: Owned> GenericSmartChan<T> for DuplexStream<T, U> {\n     fn try_send(x: T) -> bool {\n-        self.chan.try_send(move x)\n+        self.chan.try_send(x)\n     }\n }\n \n@@ -66,12 +66,12 @@ pub fn DuplexStream<T: Owned, U: Owned>()\n     let (p1, c2) = pipes::stream();\n     let (p2, c1) = pipes::stream();\n     (DuplexStream {\n-        chan: move c1,\n-        port: move p1\n+        chan: c1,\n+        port: p1\n     },\n      DuplexStream {\n-         chan: move c2,\n-         port: move p2\n+         chan: c2,\n+         port: p2\n      })\n }\n "}, {"sha": "6d01a4418435884cb08bf0621f0be9a41bb6e576", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -41,7 +41,7 @@ pub fn create<T: Copy>() -> Deque<T> {\n       */\n     fn grow<T: Copy>(nelts: uint, lo: uint, elts: ~[Cell<T>])\n       -> ~[Cell<T>] {\n-        let mut elts = move elts;\n+        let mut elts = elts;\n         assert (nelts == vec::len(elts));\n         let mut rv = ~[];\n \n@@ -54,10 +54,10 @@ pub fn create<T: Copy>() -> Deque<T> {\n             i += 1u;\n         }\n \n-        move rv\n+        rv\n     }\n     fn get<T: Copy>(elts: &DVec<Cell<T>>, i: uint) -> T {\n-        match (*elts).get_elt(i) { Some(move t) => t, _ => fail!() }\n+        match (*elts).get_elt(i) { Some(t) => t, _ => fail!() }\n     }\n \n     struct Repr<T> {\n@@ -75,7 +75,7 @@ pub fn create<T: Copy>() -> Deque<T> {\n                 self.lo = self.elts.len() - 1u;\n             } else { self.lo -= 1u; }\n             if self.lo == self.hi {\n-                self.elts.swap(|v| grow(self.nelts, oldlo, move v));\n+                self.elts.swap(|v| grow(self.nelts, oldlo, v));\n                 self.lo = self.elts.len() - 1u;\n                 self.hi = self.nelts;\n             }\n@@ -84,7 +84,7 @@ pub fn create<T: Copy>() -> Deque<T> {\n         }\n         fn add_back(t: T) {\n             if self.lo == self.hi && self.nelts != 0u {\n-                self.elts.swap(|v| grow(self.nelts, self.lo, move v));\n+                self.elts.swap(|v| grow(self.nelts, self.lo, v));\n                 self.lo = 0u;\n                 self.hi = self.nelts;\n             }"}, {"sha": "600ff3338317467d8b3a3274fceaa219c31e9145", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -259,15 +259,15 @@ pub mod reader {\n             r_doc\n         }\n \n-        fn push_doc<T>(d: Doc, f: fn() -> T) -> T{\n+        fn push_doc<T>(d: Doc, f: fn() -> T) -> T {\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n             self.parent = d;\n             self.pos = d.start;\n             let r = f();\n             self.parent = old_parent;\n             self.pos = old_pos;\n-            move r\n+            r\n         }\n \n         fn _next_uint(exp_tag: EbmlEncoderTag) -> uint {"}, {"sha": "d33ed4fd7cba952dce3a5a50a67d04db57d9283b", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 85, "deletions": 90, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -28,7 +28,7 @@ This example sends boxed integers across tasks using serialization.\n ~~~\n let (port, chan) = serial::pipe_stream();\n \n-do task::spawn |move chan| {\n+do task::spawn || {\n     for int::range(0, 10) |i| {\n         chan.send(@i)\n     }\n@@ -114,8 +114,8 @@ pub mod serial {\n         let unflat: DeserializingUnflattener<DefaultDecoder, T> =\n             DeserializingUnflattener::new(\n                 deserialize_buffer::<DefaultDecoder, T>);\n-        let byte_port = ReaderBytePort::new(move reader);\n-        FlatPort::new(move unflat, move byte_port)\n+        let byte_port = ReaderBytePort::new(reader);\n+        FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Writer`\n@@ -124,8 +124,8 @@ pub mod serial {\n         let flat: SerializingFlattener<DefaultEncoder, T> =\n             SerializingFlattener::new(\n                 serialize_value::<DefaultEncoder, T>);\n-        let byte_chan = WriterByteChan::new(move writer);\n-        FlatChan::new(move flat, move byte_chan)\n+        let byte_chan = WriterByteChan::new(writer);\n+        FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a `FlatPort` from a `Port<~[u8]>`\n@@ -135,8 +135,8 @@ pub mod serial {\n         let unflat: DeserializingUnflattener<DefaultDecoder, T> =\n             DeserializingUnflattener::new(\n                 deserialize_buffer::<DefaultDecoder, T>);\n-        let byte_port = PipeBytePort::new(move port);\n-        FlatPort::new(move unflat, move byte_port)\n+        let byte_port = PipeBytePort::new(port);\n+        FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Chan<~[u8]>`\n@@ -146,16 +146,16 @@ pub mod serial {\n         let flat: SerializingFlattener<DefaultEncoder, T> =\n             SerializingFlattener::new(\n                 serialize_value::<DefaultEncoder, T>);\n-        let byte_chan = PipeByteChan::new(move chan);\n-        FlatChan::new(move flat, move byte_chan)\n+        let byte_chan = PipeByteChan::new(chan);\n+        FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n     pub fn pipe_stream<T: Encodable<DefaultEncoder>\n                           Decodable<DefaultDecoder>>(\n                           ) -> (PipePort<T>, PipeChan<T>) {\n         let (port, chan) = pipes::stream();\n-        return (pipe_port(move port), pipe_chan(move chan));\n+        return (pipe_port(port), pipe_chan(chan));\n     }\n }\n \n@@ -193,37 +193,37 @@ pub mod pod {\n         reader: R\n     ) -> ReaderPort<T, R> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n-        let byte_port = ReaderBytePort::new(move reader);\n-        FlatPort::new(move unflat, move byte_port)\n+        let byte_port = ReaderBytePort::new(reader);\n+        FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Writer`\n     pub fn writer_chan<T: Copy Owned, W: Writer>(\n         writer: W\n     ) -> WriterChan<T, W> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n-        let byte_chan = WriterByteChan::new(move writer);\n-        FlatChan::new(move flat, move byte_chan)\n+        let byte_chan = WriterByteChan::new(writer);\n+        FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a `FlatPort` from a `Port<~[u8]>`\n     pub fn pipe_port<T: Copy Owned>(port: Port<~[u8]>) -> PipePort<T> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n-        let byte_port = PipeBytePort::new(move port);\n-        FlatPort::new(move unflat, move byte_port)\n+        let byte_port = PipeBytePort::new(port);\n+        FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Chan<~[u8]>`\n     pub fn pipe_chan<T: Copy Owned>(chan: Chan<~[u8]>) -> PipeChan<T> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n-        let byte_chan = PipeByteChan::new(move chan);\n-        FlatChan::new(move flat, move byte_chan)\n+        let byte_chan = PipeByteChan::new(chan);\n+        FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n     pub fn pipe_stream<T: Copy Owned>() -> (PipePort<T>, PipeChan<T>) {\n         let (port, chan) = pipes::stream();\n-        return (pipe_port(move port), pipe_chan(move chan));\n+        return (pipe_port(port), pipe_chan(chan));\n     }\n \n }\n@@ -261,13 +261,13 @@ const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P>: GenericPort<T> {\n     fn recv() -> T {\n         match self.try_recv() {\n-            Some(move val) => move val,\n+            Some(val) => val,\n             None => fail!(~\"port is closed\")\n         }\n     }\n     fn try_recv() -> Option<T> {\n         let command = match self.byte_port.try_recv(CONTINUE.len()) {\n-            Some(move c) => move c,\n+            Some(c) => c,\n             None => {\n                 warn!(\"flatpipe: broken pipe\");\n                 return None;\n@@ -288,8 +288,8 @@ pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P>: GenericPort<T> {\n             let msg_len = msg_len as uint;\n \n             match self.byte_port.try_recv(msg_len) {\n-                Some(move bytes) => {\n-                    Some(self.unflattener.unflatten(move bytes))\n+                Some(bytes) => {\n+                    Some(self.unflattener.unflatten(bytes))\n                 }\n                 None => {\n                     warn!(\"flatpipe: broken pipe\");\n@@ -306,29 +306,29 @@ pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P>: GenericPort<T> {\n impl<T,F:Flattener<T>,C:ByteChan> GenericChan<T> for FlatChan<T, F, C> {\n     fn send(val: T) {\n         self.byte_chan.send(CONTINUE.to_vec());\n-        let bytes = self.flattener.flatten(move val);\n+        let bytes = self.flattener.flatten(val);\n         let len = bytes.len() as u64;\n         do io::u64_to_be_bytes(len, size_of::<u64>()) |len_bytes| {\n             self.byte_chan.send(len_bytes.to_vec());\n         }\n-        self.byte_chan.send(move bytes);\n+        self.byte_chan.send(bytes);\n     }\n }\n \n pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P> {\n     static fn new(u: U, p: P) -> FlatPort<T, U, P> {\n         FlatPort {\n-            unflattener: move u,\n-            byte_port: move p\n+            unflattener: u,\n+            byte_port: p\n         }\n     }\n }\n \n pub impl<T,F:Flattener<T>,C:ByteChan> FlatChan<T, F, C> {\n     static fn new(f: F, c: C) -> FlatChan<T, F, C> {\n         FlatChan {\n-            flattener: move f,\n-            byte_chan: move c\n+            flattener: f,\n+            byte_chan: c\n         }\n     }\n }\n@@ -426,7 +426,7 @@ pub mod flatteners {\n         static fn new(deserialize_buffer: DeserializeBuffer<T>\n                      ) -> DeserializingUnflattener<D, T> {\n             DeserializingUnflattener {\n-                deserialize_buffer: move deserialize_buffer\n+                deserialize_buffer: deserialize_buffer\n             }\n         }\n     }\n@@ -437,7 +437,7 @@ pub mod flatteners {\n         static fn new(serialize_value: SerializeValue<T>\n                      ) -> SerializingFlattener<S, T> {\n             SerializingFlattener {\n-                serialize_value: move serialize_value\n+                serialize_value: serialize_value\n             }\n         }\n     }\n@@ -450,7 +450,7 @@ pub mod flatteners {\n     pub fn deserialize_buffer<D: Decoder FromReader,\n                           T: Decodable<D>>(buf: &[u8]) -> T {\n         let buf = vec::from_slice(buf);\n-        let buf_reader = @BufReader::new(move buf);\n+        let buf_reader = @BufReader::new(buf);\n         let reader = buf_reader as @Reader;\n         let deser: D = FromReader::from_reader(reader);\n         Decodable::decode(&deser)\n@@ -462,8 +462,8 @@ pub mod flatteners {\n         let writer = bytes_writer as @Writer;\n         let ser = FromWriter::from_writer(writer);\n         val.encode(&ser);\n-        let bytes = bytes_writer.bytes.check_out(|bytes| move bytes);\n-        return move bytes;\n+        let bytes = bytes_writer.bytes.check_out(|bytes| bytes);\n+        return bytes;\n     }\n \n     pub trait FromReader {\n@@ -477,8 +477,8 @@ pub mod flatteners {\n     impl FromReader for json::Decoder {\n         static fn from_reader(r: Reader) -> json::Decoder {\n             match json::from_reader(r) {\n-                Ok(move json) => {\n-                    json::Decoder(move json)\n+                Ok(json) => {\n+                    json::Decoder(json)\n                 }\n                 Err(e) => fail!(fmt!(\"flatpipe: can't parse json: %?\", e))\n             }\n@@ -487,21 +487,21 @@ pub mod flatteners {\n \n     impl FromWriter for json::Encoder {\n         static fn from_writer(w: Writer) -> json::Encoder {\n-            json::Encoder(move w)\n+            json::Encoder(w)\n         }\n     }\n \n     impl FromReader for ebml::reader::Decoder {\n         static fn from_reader(r: Reader) -> ebml::reader::Decoder {\n             let buf = @r.read_whole_stream();\n             let doc = ebml::reader::Doc(buf);\n-            ebml::reader::Decoder(move doc)\n+            ebml::reader::Decoder(doc)\n         }\n     }\n \n     impl FromWriter for ebml::writer::Encoder {\n         static fn from_writer(w: Writer) -> ebml::writer::Encoder {\n-            ebml::writer::Encoder(move w)\n+            ebml::writer::Encoder(w)\n         }\n     }\n \n@@ -537,7 +537,7 @@ pub mod bytepipes {\n             }\n \n             if left == 0 {\n-                return Some(move bytes);\n+                return Some(bytes);\n             } else {\n                 warn!(\"flatpipe: dropped %? broken bytes\", left);\n                 return None;\n@@ -554,15 +554,15 @@ pub mod bytepipes {\n     pub impl<R: Reader> ReaderBytePort<R> {\n         static fn new(r: R) -> ReaderBytePort<R> {\n             ReaderBytePort {\n-                reader: move r\n+                reader: r\n             }\n         }\n     }\n \n     pub impl<W: Writer> WriterByteChan<W> {\n         static fn new(w: W) -> WriterByteChan<W> {\n             WriterByteChan {\n-                writer: move w\n+                writer: w\n             }\n         }\n     }\n@@ -587,17 +587,17 @@ pub mod bytepipes {\n                 let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n                 assert count > bytes.len();\n                 match self.try_recv(count - bytes.len()) {\n-                    Some(move rest) => {\n+                    Some(rest) => {\n                         bytes.push_all(rest);\n-                        return Some(move bytes);\n+                        return Some(bytes);\n                     }\n                     None => return None\n                 }\n             } else if self.buf.is_empty() {\n                 match self.port.try_recv() {\n-                    Some(move buf) => {\n+                    Some(buf) => {\n                         assert !buf.is_empty();\n-                        self.buf = move buf;\n+                        self.buf = buf;\n                         return self.try_recv(count);\n                     }\n                     None => return None\n@@ -610,14 +610,14 @@ pub mod bytepipes {\n \n     pub impl PipeByteChan: ByteChan {\n         fn send(&self, val: ~[u8]) {\n-            self.chan.send(move val)\n+            self.chan.send(val)\n         }\n     }\n \n     pub impl PipeBytePort {\n         static fn new(p: Port<~[u8]>) -> PipeBytePort {\n             PipeBytePort {\n-                port: move p,\n+                port: p,\n                 buf: ~[]\n             }\n         }\n@@ -626,7 +626,7 @@ pub mod bytepipes {\n     pub impl PipeByteChan {\n         static fn new(c: Chan<~[u8]>) -> PipeByteChan {\n             PipeByteChan {\n-                chan: move c\n+                chan: c\n             }\n         }\n     }\n@@ -661,14 +661,14 @@ mod test {\n     #[test]\n     fn test_serializing_memory_stream() {\n         let writer = BytesWriter();\n-        let chan = serial::writer_chan(move writer);\n+        let chan = serial::writer_chan(writer);\n \n         chan.send(10);\n \n         let bytes = chan.byte_chan.writer.bytes.get();\n \n-        let reader = BufReader::new(move bytes);\n-        let port = serial::reader_port(move reader);\n+        let reader = BufReader::new(bytes);\n+        let port = serial::reader_port(reader);\n \n         let res: int = port.recv();\n         assert res == 10i;\n@@ -678,7 +678,7 @@ mod test {\n     fn test_serializing_pipes() {\n         let (port, chan) = serial::pipe_stream();\n \n-        do task::spawn |move chan| {\n+        do task::spawn || {\n             for int::range(0, 10) |i| {\n                 chan.send(i)\n             }\n@@ -693,7 +693,7 @@ mod test {\n     fn test_serializing_boxes() {\n         let (port, chan) = serial::pipe_stream();\n \n-        do task::spawn |move chan| {\n+        do task::spawn || {\n             for int::range(0, 10) |i| {\n                 chan.send(@i)\n             }\n@@ -707,14 +707,14 @@ mod test {\n     #[test]\n     fn test_pod_memory_stream() {\n         let writer = BytesWriter();\n-        let chan = pod::writer_chan(move writer);\n+        let chan = pod::writer_chan(writer);\n \n         chan.send(10);\n \n         let bytes = chan.byte_chan.writer.bytes.get();\n \n-        let reader = BufReader::new(move bytes);\n-        let port = pod::reader_port(move reader);\n+        let reader = BufReader::new(bytes);\n+        let port = pod::reader_port(reader);\n \n         let res: int = port.recv();\n         assert res == 10;\n@@ -724,7 +724,7 @@ mod test {\n     fn test_pod_pipes() {\n         let (port, chan) = pod::pipe_stream();\n \n-        do task::spawn |move chan| {\n+        do task::spawn || {\n             for int::range(0, 10) |i| {\n                 chan.send(i)\n             }\n@@ -741,11 +741,11 @@ mod test {\n     fn test_pod_tcp_stream() {\n         fn reader_port(buf: TcpSocketBuf\n                       ) -> pod::ReaderPort<int, TcpSocketBuf> {\n-            pod::reader_port(move buf)\n+            pod::reader_port(buf)\n         }\n         fn writer_chan(buf: TcpSocketBuf\n                       ) -> pod::WriterChan<int, TcpSocketBuf> {\n-            pod::writer_chan(move buf)\n+            pod::writer_chan(buf)\n         }\n         test_some_tcp_stream(reader_port, writer_chan, 9666);\n     }\n@@ -755,11 +755,11 @@ mod test {\n     fn test_serializing_tcp_stream() {\n         fn reader_port(buf: TcpSocketBuf\n                       ) -> serial::ReaderPort<int, TcpSocketBuf> {\n-            serial::reader_port(move buf)\n+            serial::reader_port(buf)\n         }\n         fn writer_chan(buf: TcpSocketBuf\n                       ) -> serial::WriterChan<int, TcpSocketBuf> {\n-            serial::writer_chan(move buf)\n+            serial::writer_chan(buf)\n         }\n         test_some_tcp_stream(reader_port, writer_chan, 9667);\n     }\n@@ -790,27 +790,25 @@ mod test {\n \n         let addr0 = ip::v4::parse_addr(\"127.0.0.1\");\n \n-        let begin_connect_chan = Cell(move begin_connect_chan);\n-        let accept_chan = Cell(move accept_chan);\n+        let begin_connect_chan = Cell(begin_connect_chan);\n+        let accept_chan = Cell(accept_chan);\n \n         // The server task\n         let addr = copy addr0;\n-        do task::spawn |move begin_connect_chan,\n-                        move accept_chan| {\n+        do task::spawn || {\n             let iotask = &uv::global_loop::get();\n             let begin_connect_chan = begin_connect_chan.take();\n             let accept_chan = accept_chan.take();\n             let listen_res = do tcp::listen(\n-                copy addr, port, 128, iotask,\n-                |move begin_connect_chan, _kill_ch| {\n+                copy addr, port, 128, iotask, |_kill_ch| {\n                     // Tell the sender to initiate the connection\n                     debug!(\"listening\");\n                     begin_connect_chan.send(())\n-                }) |move accept_chan, new_conn, kill_ch| {\n+                }) |new_conn, kill_ch| {\n \n                 // Incoming connection. Send it to the receiver task to accept\n                 let (res_port, res_chan) = pipes::stream();\n-                accept_chan.send((move new_conn, move res_chan));\n+                accept_chan.send((new_conn, res_chan));\n                 // Wait until the connection is accepted\n                 res_port.recv();\n \n@@ -823,8 +821,7 @@ mod test {\n \n         // Client task\n         let addr = copy addr0;\n-        do task::spawn |move begin_connect_port,\n-                        move writer_chan| {\n+        do task::spawn || {\n \n             // Wait for the server to start listening\n             begin_connect_port.recv();\n@@ -833,11 +830,11 @@ mod test {\n             let iotask = &uv::global_loop::get();\n             let connect_result = tcp::connect(copy addr, port, iotask);\n             assert connect_result.is_ok();\n-            let sock = result::unwrap(move connect_result);\n-            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(move sock);\n+            let sock = result::unwrap(connect_result);\n+            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(sock);\n \n             // TcpSocketBuf is a Writer!\n-            let chan = writer_chan(move socket_buf);\n+            let chan = writer_chan(socket_buf);\n \n             for int::range(0, 10) |i| {\n                 debug!(\"sending %?\", i);\n@@ -846,23 +843,21 @@ mod test {\n         }\n \n         // Reciever task\n-        do task::spawn |move accept_port, move finish_chan,\n-                        move reader_port| {\n-\n+        do task::spawn || {\n             // Wait for a connection\n             let (conn, res_chan) = accept_port.recv();\n \n             debug!(\"accepting connection\");\n             let accept_result = tcp::accept(conn);\n             debug!(\"accepted\");\n             assert accept_result.is_ok();\n-            let sock = result::unwrap(move accept_result);\n+            let sock = result::unwrap(accept_result);\n             res_chan.send(());\n \n-            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(move sock);\n+            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(sock);\n \n             // TcpSocketBuf is a Reader!\n-            let port = reader_port(move socket_buf);\n+            let port = reader_port(socket_buf);\n \n             for int::range(0, 10) |i| {\n                 let j = port.recv();\n@@ -897,22 +892,22 @@ mod test {\n \n         fn reader_port_loader(bytes: ~[u8]\n                              ) -> pod::ReaderPort<int, BufReader> {\n-            let reader = BufReader::new(move bytes);\n-            pod::reader_port(move reader)\n+            let reader = BufReader::new(bytes);\n+            pod::reader_port(reader)\n         }\n \n         fn pipe_port_loader(bytes: ~[u8]\n                            ) -> pod::PipePort<int> {\n             let (port, chan) = pipes::stream();\n             if !bytes.is_empty() {\n-                chan.send(move bytes);\n+                chan.send(bytes);\n             }\n-            pod::pipe_port(move port)\n+            pod::pipe_port(port)\n         }\n \n         fn test_try_recv_none1<P: BytePort>(loader: PortLoader<P>) {\n             let bytes = ~[];\n-            let port = loader(move bytes);\n+            let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n             assert res.is_none();\n         }\n@@ -929,7 +924,7 @@ mod test {\n         fn test_try_recv_none2<P: BytePort>(loader: PortLoader<P>) {\n             // The control word in the protocol is interrupted\n             let bytes = ~[0];\n-            let port = loader(move bytes);\n+            let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n             assert res.is_none();\n         }\n@@ -947,7 +942,7 @@ mod test {\n             const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n             // The control word is followed by garbage\n             let bytes = CONTINUE.to_vec() + ~[0];\n-            let port = loader(move bytes);\n+            let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n             assert res.is_none();\n         }\n@@ -962,7 +957,7 @@ mod test {\n         }\n \n         fn test_try_recv_none4<P: BytePort>(+loader: PortLoader<P>) {\n-            assert do task::try |move loader| {\n+            assert do task::try || {\n                 const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n                 // The control word is followed by a valid length,\n                 // then undeserializable garbage\n@@ -972,7 +967,7 @@ mod test {\n                 };\n                 let bytes = CONTINUE.to_vec() + len_bytes + ~[0, 0, 0, 0];\n \n-                let port = loader(move bytes);\n+                let port = loader(bytes);\n \n                 let _res: Option<int> = port.try_recv();\n             }.is_err();"}, {"sha": "8af2f350e51f7276dbe3e99ce638407602ef6415", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -55,7 +55,7 @@ pub fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n       Node(@ref kk, @copy v, left, right) => {\n         if k == *kk {\n             Some(v)\n-        } else if k < *kk { find(left, move k) } else { find(right, move k) }\n+        } else if k < *kk { find(left, k) } else { find(right, k) }\n       }\n     }\n }"}, {"sha": "e8c9a568a96e787f7e97d0ffe827b2bc6c2e20ff", "filename": "src/libstd/future.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -71,10 +71,10 @@ impl<A> Future<A> {\n \n             let mut state = Evaluating;\n             self.state <-> state;\n-            match move state {\n+            match state {\n                 Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n-                Pending(move f) => {\n-                    self.state = Forced(move f());\n+                Pending(f) => {\n+                    self.state = Forced(f());\n                     self.get_ref()\n                 }\n             }\n@@ -90,7 +90,7 @@ pub fn from_value<A>(val: A) -> Future<A> {\n      * not block.\n      */\n \n-    Future {state: Forced(move val)}\n+    Future {state: Forced(val)}\n }\n \n pub fn from_port<A:Owned>(port: PortOne<A>) ->\n@@ -102,13 +102,13 @@ pub fn from_port<A:Owned>(port: PortOne<A>) ->\n      * waiting for the result to be received on the port.\n      */\n \n-    let port = ~mut Some(move port);\n-    do from_fn |move port| {\n+    let port = ~mut Some(port);\n+    do from_fn || {\n         let mut port_ = None;\n         port_ <-> *port;\n-        let port = option::unwrap(move port_);\n-        match recv(move port) {\n-            oneshot::send(move data) => move data\n+        let port = option::unwrap(port_);\n+        match recv(port) {\n+            oneshot::send(data) => data\n         }\n     }\n }\n@@ -122,7 +122,7 @@ pub fn from_fn<A>(f: ~fn() -> A) -> Future<A> {\n      * function. It is not spawned into another task.\n      */\n \n-    Future {state: Pending(move f)}\n+    Future {state: Pending(f)}\n }\n \n pub fn spawn<A:Owned>(blk: fn~() -> A) -> Future<A> {\n@@ -135,13 +135,13 @@ pub fn spawn<A:Owned>(blk: fn~() -> A) -> Future<A> {\n \n     let (chan, port) = oneshot::init();\n \n-    let chan = ~mut Some(move chan);\n-    do task::spawn |move blk, move chan| {\n+    let chan = ~mut Some(chan);\n+    do task::spawn || {\n         let chan = option::swap_unwrap(&mut *chan);\n-        send_one(move chan, blk());\n+        send_one(chan, blk());\n     }\n \n-    return from_port(move port);\n+    return from_port(port);\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n@@ -162,8 +162,8 @@ pub mod test {\n     #[test]\n     pub fn test_from_port() {\n         let (ch, po) = oneshot::init();\n-        send_one(move ch, ~\"whale\");\n-        let f = from_port(move po);\n+        send_one(ch, ~\"whale\");\n+        let f = from_port(po);\n         assert f.get() == ~\"whale\";\n     }\n \n@@ -203,7 +203,7 @@ pub mod test {\n     pub fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n         let f = do spawn |copy expected| { copy expected };\n-        do task::spawn |move f, move expected| {\n+        do task::spawn || {\n             let actual = f.get();\n             assert actual == expected;\n         }"}, {"sha": "3726943321c353e6c24a7adaad8aec0003b9b353", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -35,7 +35,7 @@\n  *    fn do_work(in: &str, out: Option<~str>) {\n  *      io::println(in);\n  *      io::println(match out {\n- *        Some(move x) => x,\n+ *        Some(x) => x,\n  *        None => ~\"No Output\"\n  *      });\n  *    }\n@@ -339,7 +339,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n             i += 1;\n         }\n         return Ok(Matches {opts: vec::from_slice(opts),\n-                   vals: move vals,\n+                   vals: vals,\n                    free: free});\n     }\n }\n@@ -1178,7 +1178,7 @@ mod tests {\n         let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\")];\n         let matches = &match getopts(args, opts) {\n-          result::Ok(move m) => m,\n+          result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n         assert opts_present(matches, ~[~\"e\"]);\n@@ -1199,7 +1199,7 @@ mod tests {\n         let args = ~[~\"-Lfoo\", ~\"-M.\"];\n         let opts = ~[optmulti(~\"L\"), optmulti(~\"M\")];\n         let matches = &match getopts(args, opts) {\n-          result::Ok(move m) => m,\n+          result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n         assert opts_present(matches, ~[~\"L\"]);"}, {"sha": "b1c6e2d44e572fb0df7a4fb93de9fa8f60a96838", "filename": "src/libstd/io_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio_util.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -20,7 +20,7 @@ pub struct BufReader {\n pub impl BufReader {\n     static pub fn new(v: ~[u8]) -> BufReader {\n         BufReader {\n-            buf: move v,\n+            buf: v,\n             pos: 0\n         }\n     }\n@@ -38,7 +38,7 @@ pub impl BufReader {\n         // FIXME #4429: This isn't correct if f fails\n         self.pos = bytes_reader.pos;\n \n-        return move res;\n+        return res;\n     }\n }\n "}, {"sha": "5aa05e9cf75668b48ff020f82c7022e6ccc91991", "filename": "src/libstd/json.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -388,18 +388,18 @@ pub fn Parser(rdr: io::Reader) -> Parser {\n \n pub impl Parser {\n     fn parse() -> Result<Json, Error> {\n-        match move self.parse_value() {\n-          Ok(move value) => {\n+        match self.parse_value() {\n+          Ok(value) => {\n             // Skip trailing whitespaces.\n             self.parse_whitespace();\n             // Make sure there is no trailing characters.\n             if self.eof() {\n-                Ok(move value)\n+                Ok(value)\n             } else {\n                 self.error(~\"trailing characters\")\n             }\n           }\n-          Err(move e) => Err(e)\n+          Err(e) => Err(e)\n         }\n     }\n }\n@@ -438,9 +438,9 @@ priv impl Parser {\n           'f' => self.parse_ident(~\"alse\", Boolean(false)),\n           '0' .. '9' | '-' => self.parse_number(),\n           '\"' =>\n-            match move self.parse_str() {\n-              Ok(move s) => Ok(String(s)),\n-              Err(move e) => Err(e),\n+            match self.parse_str() {\n+              Ok(s) => Ok(String(s)),\n+              Err(e) => Err(e),\n             },\n           '[' => self.parse_list(),\n           '{' => self.parse_object(),\n@@ -455,7 +455,7 @@ priv impl Parser {\n     fn parse_ident(ident: &str, value: Json) -> Result<Json, Error> {\n         if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n-            Ok(move value)\n+            Ok(value)\n         } else {\n             self.error(~\"invalid syntax\")\n         }\n@@ -662,13 +662,13 @@ priv impl Parser {\n \n         if self.ch == ']' {\n             self.bump();\n-            return Ok(List(move values));\n+            return Ok(List(values));\n         }\n \n         loop {\n-            match move self.parse_value() {\n-              Ok(move v) => values.push(move v),\n-              Err(move e) => return Err(e)\n+            match self.parse_value() {\n+              Ok(v) => values.push(v),\n+              Err(e) => return Err(e)\n             }\n \n             self.parse_whitespace();\n@@ -678,7 +678,7 @@ priv impl Parser {\n \n             match self.ch {\n               ',' => self.bump(),\n-              ']' => { self.bump(); return Ok(List(move values)); }\n+              ']' => { self.bump(); return Ok(List(values)); }\n               _ => return self.error(~\"expected `,` or `]`\")\n             }\n         };\n@@ -692,7 +692,7 @@ priv impl Parser {\n \n         if self.ch == '}' {\n           self.bump();\n-          return Ok(Object(move values));\n+          return Ok(Object(values));\n         }\n \n         while !self.eof() {\n@@ -702,9 +702,9 @@ priv impl Parser {\n                 return self.error(~\"key must be a string\");\n             }\n \n-            let key = match move self.parse_str() {\n-              Ok(move key) => key,\n-              Err(move e) => return Err(e)\n+            let key = match self.parse_str() {\n+              Ok(key) => key,\n+              Err(e) => return Err(e)\n             };\n \n             self.parse_whitespace();\n@@ -715,15 +715,15 @@ priv impl Parser {\n             }\n             self.bump();\n \n-            match move self.parse_value() {\n-              Ok(move value) => { values.insert(key, move value); }\n-              Err(move e) => return Err(e)\n+            match self.parse_value() {\n+              Ok(value) => { values.insert(key, value); }\n+              Err(e) => return Err(e)\n             }\n             self.parse_whitespace();\n \n             match self.ch {\n               ',' => self.bump(),\n-              '}' => { self.bump(); return Ok(Object(move values)); }\n+              '}' => { self.bump(); return Ok(Object(values)); }\n               _ => {\n                   if self.eof() { break; }\n                   return self.error(~\"expected `,` or `}`\");\n@@ -753,7 +753,7 @@ pub struct Decoder {\n }\n \n pub fn Decoder(json: Json) -> Decoder {\n-    Decoder { json: move json, stack: ~[] }\n+    Decoder { json: json, stack: ~[] }\n }\n \n priv impl Decoder {\n@@ -868,7 +868,7 @@ pub impl Decoder: serialize::Decoder {\n         };\n         let res = f(len);\n         self.pop();\n-        move res\n+        res\n     }\n \n     fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n@@ -879,7 +879,7 @@ pub impl Decoder: serialize::Decoder {\n         };\n         let res = f(len);\n         self.pop();\n-        move res\n+        res\n     }\n \n     fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n@@ -897,14 +897,14 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_rec()\");\n         let value = f();\n         self.pop();\n-        move value\n+        value\n     }\n \n     fn read_struct<T>(&self, _name: &str, _len: uint, f: fn() -> T) -> T {\n         debug!(\"read_struct()\");\n         let value = f();\n         self.pop();\n-        move value\n+        value\n     }\n \n     fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n@@ -934,7 +934,7 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_tup(len=%u)\", len);\n         let value = f();\n         self.pop();\n-        move value\n+        value\n     }\n \n     fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n@@ -1219,11 +1219,11 @@ mod tests {\n \n         for items.each |item| {\n             match *item {\n-                (copy key, copy value) => { d.insert(key, move value); },\n+                (copy key, copy value) => { d.insert(key, value); },\n             }\n         };\n \n-        Object(move d)\n+        Object(d)\n     }\n \n     #[test]"}, {"sha": "4a185f68e17f9ee3af8c1c60a885abb5978a2e12", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -181,7 +181,7 @@ pub mod v4 {\n      */\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n-          result::Ok(move addr) => move addr,\n+          result::Ok(addr) => addr,\n           result::Err(ref err_data) => fail!(err_data.err_msg)\n         }\n     }\n@@ -276,7 +276,7 @@ pub mod v6 {\n      */\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n-          result::Ok(move addr) => move addr,\n+          result::Ok(addr) => addr,\n           result::Err(copy err_data) => fail!(err_data.err_msg)\n         }\n     }\n@@ -331,7 +331,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                             result::Err(GetAddrUnknownError));\n                         break;\n                     };\n-                    out_vec.push(move new_ip_addr);\n+                    out_vec.push(new_ip_addr);\n \n                     let next_addr = ll::get_next_addrinfo(curr_addr);\n                     if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n@@ -345,7 +345,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                 }\n                 log(debug, fmt!(\"successful process addrinfo result, len: %?\",\n                                 vec::len(out_vec)));\n-                output_ch.send(result::Ok(move out_vec));\n+                output_ch.send(result::Ok(out_vec));\n             }\n             else {\n                 log(debug, ~\"addrinfo pointer is NULL\");\n@@ -427,7 +427,7 @@ mod test {\n         }\n         // note really sure how to realiably test/assert\n         // this.. mostly just wanting to see it work, atm.\n-        let results = result::unwrap(move ga_result);\n+        let results = result::unwrap(ga_result);\n         log(debug, fmt!(\"test_get_addr: Number of results for %s: %?\",\n                         localhost_name, vec::len(results)));\n         for vec::each(results) |r| {"}, {"sha": "9f750a2bf711a7b5b0ebfd9ccd3dcbe9a49de9ae", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -177,7 +177,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n         // we can send into the interact cb to be handled in libuv..\n         debug!(\"stream_handle_ptr outside interact %?\",\n                         stream_handle_ptr);\n-        do iotask::interact(iotask) |move input_ip, loop_ptr| {\n+        do iotask::interact(iotask) |loop_ptr| {\n             unsafe {\n                 debug!(\"in interact cb for tcp client connect..\");\n                 debug!(\"stream_handle_ptr in interact %?\",\n@@ -629,10 +629,10 @@ pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n               new_connect_cb: fn~(TcpNewConnection,\n                                   SharedChan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> {\n-    do listen_common(move host_ip, port, backlog, iotask,\n-                     move on_establish_cb)\n+    do listen_common(host_ip, port, backlog, iotask,\n+                     on_establish_cb)\n         // on_connect_cb\n-        |move new_connect_cb, handle| {\n+        |handle| {\n         unsafe {\n             let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n                 as *TcpListenFcData;\n@@ -659,7 +659,7 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n             server_stream_ptr: server_stream_ptr,\n             stream_closed_ch: stream_closed_ch,\n             kill_ch: kill_ch.clone(),\n-            on_connect_cb: move on_connect_cb,\n+            on_connect_cb: on_connect_cb,\n             iotask: iotask.clone(),\n             ipv6: match &host_ip {\n                 &ip::Ipv4(_) => { false }\n@@ -678,7 +678,7 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n         // tcp::connect (because the iotask::interact cb isn't\n         // nested within a core::comm::listen block)\n         let loc_ip = copy(host_ip);\n-        do iotask::interact(iotask) |move loc_ip, loop_ptr| {\n+        do iotask::interact(iotask) |loop_ptr| {\n             unsafe {\n                 match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n                     0i32 => {\n@@ -815,7 +815,7 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n  */\n pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n     TcpSocketBuf(@TcpBufferedSocketData {\n-        sock: move sock, mut buf: ~[], buf_off: 0\n+        sock: sock, mut buf: ~[], buf_off: 0\n     })\n }\n \n@@ -851,12 +851,12 @@ impl TcpSocket {\n                 let addr = uv::ll::ip6_addr(\"\", 0);\n                 uv::ll::tcp_getpeername6(self.socket_data.stream_handle_ptr,\n                                          ptr::addr_of(&addr));\n-                ip::Ipv6(move addr)\n+                ip::Ipv6(addr)\n             } else {\n                 let addr = uv::ll::ip4_addr(\"\", 0);\n                 uv::ll::tcp_getpeername(self.socket_data.stream_handle_ptr,\n                                         ptr::addr_of(&addr));\n-                ip::Ipv4(move addr)\n+                ip::Ipv4(addr)\n             }\n         }\n     }\n@@ -1047,7 +1047,7 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n                 Some(result::get(&rs_result).recv())\n             };\n             log(debug, ~\"tcp::read after recv_timeout\");\n-            match move read_result {\n+            match read_result {\n                 None => {\n                     log(debug, ~\"tcp::read: timed out..\");\n                     let err_data = TcpErrData {\n@@ -1057,7 +1057,7 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n                     read_stop_common_impl(socket_data);\n                     result::Err(err_data)\n                 }\n-                Some(move data_result) => {\n+                Some(data_result) => {\n                     log(debug, ~\"tcp::read got data\");\n                     read_stop_common_impl(socket_data);\n                     data_result\n@@ -1091,7 +1091,7 @@ fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n             }\n         }\n         match stop_po.recv() {\n-            Some(move err_data) => Err(err_data),\n+            Some(err_data) => Err(err_data),\n             None => Ok(())\n         }\n     }\n@@ -1183,7 +1183,7 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n         // aftermath, so we don't have to sit here blocking.\n         match result_po.recv() {\n             TcpWriteSuccess => Ok(()),\n-            TcpWriteError(move err_data) => Err(err_data)\n+            TcpWriteError(err_data) => Err(err_data)\n         }\n     }\n }\n@@ -1613,10 +1613,10 @@ pub mod test {\n         debug!(\"server started, firing up client..\");\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let iotask = uv::global_loop::get();\n-        let connect_result = connect(move server_ip_addr, server_port,\n+        let connect_result = connect(server_ip_addr, server_port,\n                                      &iotask);\n \n-        let sock = result::unwrap(move connect_result);\n+        let sock = result::unwrap(connect_result);\n \n         debug!(\"testing peer address\");\n         // This is what we are actually testing!\n@@ -1784,11 +1784,11 @@ pub mod test {\n         // client\n         debug!(\"server started, firing up client..\");\n         let server_addr = ip::v4::parse_addr(server_ip);\n-        let conn_result = connect(move server_addr, server_port, hl_loop);\n+        let conn_result = connect(server_addr, server_port, hl_loop);\n         if result::is_err(&conn_result) {\n             assert false;\n         }\n-        let sock_buf = @socket_buf(result::unwrap(move conn_result));\n+        let sock_buf = @socket_buf(result::unwrap(conn_result));\n         buf_write(sock_buf, expected_req);\n \n         let buf_reader = sock_buf as Reader;\n@@ -1819,7 +1819,7 @@ pub mod test {\n         let (server_po, server_ch) = stream::<~str>();\n         let server_ch = SharedChan(server_ch);\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n-        let listen_result = listen(move server_ip_addr, server_port, 128,\n+        let listen_result = listen(server_ip_addr, server_port, 128,\n                                    iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n@@ -1849,15 +1849,15 @@ pub mod test {\n                     else {\n                         debug!(\"SERVER/WORKER: send on cont ch\");\n                         cont_ch.send(());\n-                        let sock = result::unwrap(move accept_result);\n+                        let sock = result::unwrap(accept_result);\n                         let peer_addr = sock.get_peer_addr();\n                         debug!(\"SERVER: successfully accepted \\\n                                 connection from %s:%u\",\n                                  ip::format_addr(&peer_addr),\n                                  ip::get_port(&peer_addr));\n                         let received_req_bytes = read(&sock, 0u);\n-                        match move received_req_bytes {\n-                          result::Ok(move data) => {\n+                        match received_req_bytes {\n+                          result::Ok(data) => {\n                             debug!(\"SERVER: got REQ str::from_bytes..\");\n                             debug!(\"SERVER: REQ data len: %?\",\n                                             vec::len(data));\n@@ -1868,7 +1868,7 @@ pub mod test {\n                             debug!(\"SERVER: after write.. die\");\n                             kill_ch.send(None);\n                           }\n-                          result::Err(move err_data) => {\n+                          result::Err(err_data) => {\n                             debug!(\"SERVER: error recvd: %s %s\",\n                                 err_data.err_name, err_data.err_msg);\n                             kill_ch.send(Some(err_data));\n@@ -1904,7 +1904,7 @@ pub mod test {\n     fn run_tcp_test_server_fail(server_ip: &str, server_port: uint,\n                                 iotask: &IoTask) -> TcpListenErrData {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n-        let listen_result = listen(move server_ip_addr, server_port, 128,\n+        let listen_result = listen(server_ip_addr, server_port, 128,\n                                    iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n@@ -1929,15 +1929,15 @@ pub mod test {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n         debug!(\"CLIENT: starting..\");\n-        let connect_result = connect(move server_ip_addr, server_port,\n+        let connect_result = connect(server_ip_addr, server_port,\n                                      iotask);\n         if result::is_err(&connect_result) {\n             debug!(\"CLIENT: failed to connect\");\n             let err_data = result::get_err(&connect_result);\n             Err(err_data)\n         }\n         else {\n-            let sock = result::unwrap(move connect_result);\n+            let sock = result::unwrap(connect_result);\n             let resp_bytes = str::to_bytes(resp);\n             tcp_write_single(&sock, resp_bytes);\n             let read_result = sock.read(0u);"}, {"sha": "29cb57c01be4517b0e6dbb91ab026fb7f50e3b90", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -253,7 +253,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> LinearMap<~str, ~[~str]> {\n                 '&' | ';' => {\n                     if key != ~\"\" && value != ~\"\" {\n                         let mut values = match m.pop(&key) {\n-                            Some(move values) => values,\n+                            Some(values) => values,\n                             None => ~[],\n                         };\n \n@@ -287,7 +287,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> LinearMap<~str, ~[~str]> {\n \n         if key != ~\"\" && value != ~\"\" {\n             let mut values = match m.pop(&key) {\n-                Some(move values) => values,\n+                Some(values) => values,\n                 None => ~[],\n             };\n \n@@ -671,7 +671,7 @@ pub pure fn from_str(rawurl: &str) -> Result<Url, ~str> {\n impl FromStr for Url {\n     static pure fn from_str(s: &str) -> Option<Url> {\n         match from_str(s) {\n-            Ok(move url) => Some(url),\n+            Ok(url) => Some(url),\n             Err(_) => None\n         }\n     }"}, {"sha": "701268e044ae393515b946c0c21d3b8a9a6fef0b", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -132,7 +132,7 @@ pub mod chained {\n                 entry.next = new_chains[idx];\n                 new_chains[idx] = Some(entry);\n             }\n-            self.chains = move new_chains;\n+            self.chains = new_chains;\n         }\n \n         pure fn each_entry(blk: fn(@Entry<K,V>) -> bool) {\n@@ -321,7 +321,7 @@ pub mod chained {\n             if opt_v.is_none() {\n                 fail!(fmt!(\"Key not found in table: %?\", k));\n             }\n-            option::unwrap(move opt_v)\n+            option::unwrap(opt_v)\n         }\n     }\n "}, {"sha": "c4ba465acea94f1833b54cf6f5a03296aa0e9e21", "filename": "src/libstd/oldsmallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Foldsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Foldsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldsmallintmap.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -69,7 +69,7 @@ pub pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n         error!(\"smallintmap::get(): key not present\");\n         fail!();\n       }\n-      Some(move v) => return v\n+      Some(v) => return v\n     }\n }\n "}, {"sha": "3929e8c0ea7634c7ec1535fe1e0158ff0b801759", "filename": "src/libstd/par.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -58,7 +58,7 @@ fn map_slices<A: Copy Owned, B: Copy Owned>(\n             do vec::as_imm_buf(xs) |p, _len| {\n                 let f = f();\n                 let base = base;\n-                let f = do future_spawn() |move f| {\n+                let f = do future_spawn() || {\n                     unsafe {\n                         let len = end - base;\n                         let slice = (ptr::offset(p, base),\n@@ -72,7 +72,7 @@ fn map_slices<A: Copy Owned, B: Copy Owned>(\n                         f(base, slice)\n                     }\n                 };\n-                futures.push(move f);\n+                futures.push(f);\n             };\n             base += items_per_task;\n         }"}, {"sha": "b216834a20500cd370d406a016435bd9718c9bc1", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -139,27 +139,27 @@ impl <T: Ord> PriorityQueue<T> {\n \n     priv fn siftup(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n-            let new = move *addr_of(&self.data[pos]);\n+            let new = *addr_of(&self.data[pos]);\n \n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n                 if new > self.data[parent] {\n                     let mut x = rusti::init();\n                     x <-> self.data[parent];\n-                    rusti::move_val_init(&mut self.data[pos], move x);\n+                    rusti::move_val_init(&mut self.data[pos], x);\n                     pos = parent;\n                     loop\n                 }\n                 break\n             }\n-            rusti::move_val_init(&mut self.data[pos], move new);\n+            rusti::move_val_init(&mut self.data[pos], new);\n         }\n     }\n \n     priv fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n-            let new = move *addr_of(&self.data[pos]);\n+            let new = *addr_of(&self.data[pos]);\n \n             let mut child = 2 * pos + 1;\n             while child < end {\n@@ -169,12 +169,12 @@ impl <T: Ord> PriorityQueue<T> {\n                 }\n                 let mut x = rusti::init();\n                 x <-> self.data[child];\n-                rusti::move_val_init(&mut self.data[pos], move x);\n+                rusti::move_val_init(&mut self.data[pos], x);\n                 pos = child;\n                 child = 2 * pos + 1;\n             }\n \n-            rusti::move_val_init(&mut self.data[pos], move new);\n+            rusti::move_val_init(&mut self.data[pos], new);\n             self.siftup(start, pos);\n         }\n     }"}, {"sha": "1ee67d76af571f0105ed5b7cf2cfc10f28a31be8", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -71,7 +71,7 @@ fn complete_key(_v: @CompletionCb) {}\n /// Bind to the main completion callback\n pub unsafe fn complete(cb: CompletionCb) {\n     unsafe {\n-        task::local_data::local_data_set(complete_key, @(move cb));\n+        task::local_data::local_data_set(complete_key, @(cb));\n \n         extern fn callback(line: *c_char, completions: *()) {\n             unsafe {"}, {"sha": "8e878c8fc2e312a9e75822c1a5e2a6b49876788d", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -848,11 +848,11 @@ pub mod node {\n                         offset += 1u;\n                         i      += 1u;\n                     }\n-                    cast::forget(move local_buf);\n+                    cast::forget(local_buf);\n                   }\n                 }\n             }\n-            return cast::transmute(move buf);\n+            return cast::transmute(buf);\n         }\n     }\n "}, {"sha": "242e318e8a8f0f33b031161cd2454e6800090004", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -265,7 +265,7 @@ pub fn sha1() -> Sha1 {\n          computed: false,\n          work_buf: @mut vec::from_elem(work_buf_len, 0u32)\n     };\n-    let mut sh = (move st) as Sha1;\n+    let mut sh = (st) as Sha1;\n     sh.reset();\n     return sh;\n }"}, {"sha": "e56f4cb87cd43ff3da1e9284cf70b94076d444dd", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -59,7 +59,7 @@ pub pure fn merge_sort<T: Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n         }\n         rs.push_all(vec::slice(a, a_ix, a_len));\n         rs.push_all(vec::slice(b, b_ix, b_len));\n-        move rs\n+        rs\n     }\n }\n \n@@ -241,7 +241,7 @@ fn binarysort<T: Copy Ord>(array: &mut [T], start: uint) {\n         let mut n = start-left;\n \n         copy_vec(array, left+1, array, left, n);\n-        array[left] = move pivot;\n+        array[left] = pivot;\n         start += 1;\n     }\n }\n@@ -816,7 +816,7 @@ mod test_qsort {\n \n         do quick_sort(names) |x, y| { int::le(*x, *y) };\n \n-        let immut_names = move names;\n+        let immut_names = names;\n \n         let pairs = vec::zip_slice(expected, immut_names);\n         for vec::each(pairs) |p| {\n@@ -1022,14 +1022,14 @@ mod big_tests {\n         let res = do vec::from_fn(num) |i| {\n             arr[i % size]\n         };\n-        move res\n+        res\n     }\n \n     fn makeRange(n: uint) -> ~[uint] {\n         let one = do vec::from_fn(n) |i| { i };\n         let mut two = copy one;\n         vec::reverse(two);\n-        vec::append(move two, one)\n+        vec::append(two, one)\n     }\n \n     fn tabulate_unique(lo: uint, hi: uint) {\n@@ -1048,7 +1048,7 @@ mod big_tests {\n             let arr = do vec::from_fn(n) |_i| {\n                 rng.gen_float()\n             };\n-            let mut arr = move arr;\n+            let mut arr = arr;\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1089,7 +1089,7 @@ mod big_tests {\n             let mut arr = if n > 4 {\n                 let part = vec::view(arr, 0, 4);\n                 multiplyVec(part, n)\n-            } else { move arr };\n+            } else { arr };\n             tim_sort(arr); // ~sort\n             isSorted(arr);\n \n@@ -1120,7 +1120,7 @@ mod big_tests {\n             let arr = do vec::from_fn(n) |_i| {\n                 @rng.gen_float()\n             };\n-            let mut arr = move arr;\n+            let mut arr = arr;\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1161,7 +1161,7 @@ mod big_tests {\n             let mut arr = if n > 4 {\n                 let part = vec::view(arr, 0, 4);\n                 multiplyVec(part, n)\n-            } else { move arr };\n+            } else { arr };\n             tim_sort(arr); // ~sort\n             isSorted(arr);\n "}, {"sha": "fd0b0d6be3a2dd67d236bacdf384edb006667110", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -40,7 +40,7 @@ struct Waitqueue { head: pipes::Port<SignalEnd>,\n \n fn new_waitqueue() -> Waitqueue {\n     let (block_head, block_tail) = pipes::stream();\n-    Waitqueue { head: move block_head, tail: move block_tail }\n+    Waitqueue { head: block_head, tail: block_tail }\n }\n \n // Signals one live task from the queue.\n@@ -86,7 +86,7 @@ enum Sem<Q> = Exclusive<SemInner<Q>>;\n #[doc(hidden)]\n fn new_sem<Q: Owned>(count: int, q: Q) -> Sem<Q> {\n     Sem(exclusive(SemInner {\n-        mut count: count, waiters: new_waitqueue(), blocked: move q }))\n+        mut count: count, waiters: new_waitqueue(), blocked: q }))\n }\n #[doc(hidden)]\n fn new_sem_and_signal(count: int, num_condvars: uint)\n@@ -109,17 +109,17 @@ impl<Q: Owned> &Sem<Q> {\n                     // Create waiter nobe.\n                     let (WaitEnd, SignalEnd) = pipes::oneshot();\n                     // Tell outer scope we need to block.\n-                    waiter_nobe = Some(move WaitEnd);\n+                    waiter_nobe = Some(WaitEnd);\n                     // Enqueue ourself.\n-                    state.waiters.tail.send(move SignalEnd);\n+                    state.waiters.tail.send(SignalEnd);\n                 }\n             }\n         }\n         // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n         /* for 1000.times { task::yield(); } */\n         // Need to wait outside the exclusive.\n         if waiter_nobe.is_some() {\n-            let _ = pipes::recv_one(option::unwrap(move waiter_nobe));\n+            let _ = pipes::recv_one(option::unwrap(waiter_nobe));\n         }\n     }\n     fn release() {\n@@ -215,8 +215,8 @@ impl &Condvar {\n     fn wait_on(condvar_id: uint) {\n         // Create waiter nobe.\n         let (WaitEnd, SignalEnd) = pipes::oneshot();\n-        let mut WaitEnd   = Some(move WaitEnd);\n-        let mut SignalEnd = Some(move SignalEnd);\n+        let mut WaitEnd   = Some(WaitEnd);\n+        let mut SignalEnd = Some(SignalEnd);\n         let mut reacquire = None;\n         let mut out_of_bounds = None;\n         unsafe {\n@@ -231,7 +231,7 @@ impl &Condvar {\n                         }\n                         // Enqueue ourself to be woken up by a signaller.\n                         let SignalEnd = option::swap_unwrap(&mut SignalEnd);\n-                        state.blocked[condvar_id].tail.send(move SignalEnd);\n+                        state.blocked[condvar_id].tail.send(SignalEnd);\n                     } else {\n                         out_of_bounds = Some(vec::len(state.blocked));\n                     }\n@@ -737,7 +737,7 @@ mod tests {\n     pub fn test_sem_as_mutex() {\n         let s = ~semaphore(1);\n         let s2 = ~s.clone();\n-        do task::spawn |move s2| {\n+        do task::spawn || {\n             do s2.access {\n                 for 5.times { task::yield(); }\n             }\n@@ -752,7 +752,7 @@ mod tests {\n         let (p,c) = pipes::stream();\n         let s = ~semaphore(0);\n         let s2 = ~s.clone();\n-        do task::spawn |move s2, move c| {\n+        do task::spawn || {\n             s2.acquire();\n             c.send(());\n         }\n@@ -764,7 +764,7 @@ mod tests {\n         let (p,c) = pipes::stream();\n         let s = ~semaphore(0);\n         let s2 = ~s.clone();\n-        do task::spawn |move s2, move p| {\n+        do task::spawn || {\n             for 5.times { task::yield(); }\n             s2.release();\n             let _ = p.recv();\n@@ -780,7 +780,7 @@ mod tests {\n         let s2 = ~s.clone();\n         let (p1,c1) = pipes::stream();\n         let (p2,c2) = pipes::stream();\n-        do task::spawn |move s2, move c1, move p2| {\n+        do task::spawn || {\n             do s2.access {\n                 let _ = p2.recv();\n                 c1.send(());\n@@ -799,10 +799,10 @@ mod tests {\n             let s = ~semaphore(1);\n             let s2 = ~s.clone();\n             let (p,c) = pipes::stream();\n-            let child_data = ~mut Some((move s2, move c));\n+            let child_data = ~mut Some((s2, c));\n             do s.access {\n                 let (s2,c) = option::swap_unwrap(child_data);\n-                do task::spawn |move c, move s2| {\n+                do task::spawn || {\n                     c.send(());\n                     do s2.access { }\n                     c.send(());\n@@ -825,7 +825,7 @@ mod tests {\n         let m2 = ~m.clone();\n         let mut sharedstate = ~0;\n         let ptr = ptr::addr_of(&(*sharedstate));\n-        do task::spawn |move m2, move c| {\n+        do task::spawn || {\n             let sharedstate: &mut int =\n                 unsafe { cast::reinterpret_cast(&ptr) };\n             access_shared(sharedstate, m2, 10);\n@@ -854,7 +854,7 @@ mod tests {\n         // Child wakes up parent\n         do m.lock_cond |cond| {\n             let m2 = ~m.clone();\n-            do task::spawn |move m2| {\n+            do task::spawn || {\n                 do m2.lock_cond |cond| {\n                     let woken = cond.signal();\n                     assert woken;\n@@ -865,7 +865,7 @@ mod tests {\n         // Parent wakes up child\n         let (port,chan) = pipes::stream();\n         let m3 = ~m.clone();\n-        do task::spawn |move chan, move m3| {\n+        do task::spawn || {\n             do m3.lock_cond |cond| {\n                 chan.send(());\n                 cond.wait();\n@@ -887,8 +887,8 @@ mod tests {\n         for num_waiters.times {\n             let mi = ~m.clone();\n             let (port, chan) = pipes::stream();\n-            ports.push(move port);\n-            do task::spawn |move chan, move mi| {\n+            ports.push(port);\n+            do task::spawn || {\n                 do mi.lock_cond |cond| {\n                     chan.send(());\n                     cond.wait();\n@@ -918,7 +918,7 @@ mod tests {\n     pub fn test_mutex_cond_no_waiter() {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n-        do task::try |move m| {\n+        do task::try || {\n             do m.lock_cond |_x| { }\n         };\n         do m2.lock_cond |cond| {\n@@ -931,7 +931,7 @@ mod tests {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n \n-        let result: result::Result<(),()> = do task::try |move m2| {\n+        let result: result::Result<(),()> = do task::try || {\n             do m2.lock {\n                 fail!();\n             }\n@@ -947,9 +947,9 @@ mod tests {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n \n-        let result: result::Result<(),()> = do task::try |move m2| {\n+        let result: result::Result<(),()> = do task::try || {\n             let (p,c) = pipes::stream();\n-            do task::spawn |move p| { // linked\n+            do task::spawn || { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::yield();\n                 fail!();\n@@ -972,19 +972,19 @@ mod tests {\n         let m2 = ~m.clone();\n         let (p,c) = pipes::stream();\n \n-        let result: result::Result<(),()> = do task::try |move c, move m2| {\n+        let result: result::Result<(),()> = do task::try || {\n             let mut sibling_convos = ~[];\n             for 2.times {\n                 let (p,c) = pipes::stream();\n-                let c = ~mut Some(move c);\n-                sibling_convos.push(move p);\n+                let c = ~mut Some(c);\n+                sibling_convos.push(p);\n                 let mi = ~m2.clone();\n                 // spawn sibling task\n-                do task::spawn |move mi, move c| { // linked\n+                do task::spawn || { // linked\n                     do mi.lock_cond |cond| {\n                         let c = option::swap_unwrap(c);\n                         c.send(()); // tell sibling to go ahead\n-                        let _z = SendOnFailure(move c);\n+                        let _z = SendOnFailure(c);\n                         cond.wait(); // block forever\n                     }\n                 }\n@@ -993,7 +993,7 @@ mod tests {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             do m2.lock { }\n-            c.send(move sibling_convos); // let parent wait on all children\n+            c.send(sibling_convos); // let parent wait on all children\n             fail!();\n         };\n         assert result.is_err();\n@@ -1015,7 +1015,7 @@ mod tests {\n \n         fn SendOnFailure(c: pipes::Chan<()>) -> SendOnFailure {\n             SendOnFailure {\n-                c: move c\n+                c: c\n             }\n         }\n     }\n@@ -1025,7 +1025,7 @@ mod tests {\n         let m = ~Mutex();\n         do m.lock_cond |cond| {\n             let m2 = ~m.clone();\n-            do task::spawn |move m2| {\n+            do task::spawn || {\n                 do m2.lock_cond |cond| {\n                     cond.signal_on(0);\n                 }\n@@ -1039,7 +1039,7 @@ mod tests {\n             let m = ~mutex_with_condvars(2);\n             let m2 = ~m.clone();\n             let (p,c) = pipes::stream();\n-            do task::spawn |move m2, move c| {\n+            do task::spawn || {\n                 do m2.lock_cond |cond| {\n                     c.send(());\n                     cond.wait_on(1);\n@@ -1088,7 +1088,7 @@ mod tests {\n                 },\n             DowngradeRead =>\n                 do x.write_downgrade |mode| {\n-                    let mode = x.downgrade(move mode);\n+                    let mode = x.downgrade(mode);\n                     (&mode).read(blk);\n                 },\n         }\n@@ -1103,7 +1103,7 @@ mod tests {\n         let x2 = ~x.clone();\n         let mut sharedstate = ~0;\n         let ptr = ptr::addr_of(&(*sharedstate));\n-        do task::spawn |move c, move x2| {\n+        do task::spawn || {\n             let sharedstate: &mut int =\n                 unsafe { cast::reinterpret_cast(&ptr) };\n             access_shared(sharedstate, x2, mode1, 10);\n@@ -1148,7 +1148,7 @@ mod tests {\n         let x2 = ~x.clone();\n         let (p1,c1) = pipes::stream();\n         let (p2,c2) = pipes::stream();\n-        do task::spawn |move c1, move x2, move p2| {\n+        do task::spawn || {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n             }\n@@ -1185,10 +1185,10 @@ mod tests {\n         // Tests that downgrade can unlock the lock in both modes\n         let x = ~RWlock();\n         do lock_rwlock_in_mode(x, Downgrade) { }\n-        test_rwlock_handshake(move x, Read, Read, false);\n+        test_rwlock_handshake(x, Read, Read, false);\n         let y = ~RWlock();\n         do lock_rwlock_in_mode(y, DowngradeRead) { }\n-        test_rwlock_exclusion(move y, Write, Write);\n+        test_rwlock_exclusion(y, Write, Write);\n     }\n     #[test]\n     pub fn test_rwlock_read_recursive() {\n@@ -1203,7 +1203,7 @@ mod tests {\n         // Child wakes up parent\n         do x.write_cond |cond| {\n             let x2 = ~x.clone();\n-            do task::spawn |move x2| {\n+            do task::spawn || {\n                 do x2.write_cond |cond| {\n                     let woken = cond.signal();\n                     assert woken;\n@@ -1214,7 +1214,7 @@ mod tests {\n         // Parent wakes up child\n         let (port,chan) = pipes::stream();\n         let x3 = ~x.clone();\n-        do task::spawn |move x3, move chan| {\n+        do task::spawn || {\n             do x3.write_cond |cond| {\n                 chan.send(());\n                 cond.wait();\n@@ -1250,8 +1250,8 @@ mod tests {\n         for num_waiters.times {\n             let xi = ~x.clone();\n             let (port, chan) = pipes::stream();\n-            ports.push(move port);\n-            do task::spawn |move chan, move xi| {\n+            ports.push(port);\n+            do task::spawn || {\n                 do lock_cond(xi, dg1) |cond| {\n                     chan.send(());\n                     cond.wait();\n@@ -1286,7 +1286,7 @@ mod tests {\n         let x = ~RWlock();\n         let x2 = ~x.clone();\n \n-        let result: result::Result<(),()> = do task::try |move x2| {\n+        let result: result::Result<(),()> = do task::try || {\n             do lock_rwlock_in_mode(x2, mode1) {\n                 fail!();\n             }\n@@ -1332,7 +1332,7 @@ mod tests {\n         let x = ~RWlock();\n         let y = ~RWlock();\n         do x.write_downgrade |xwrite| {\n-            let mut xopt = Some(move xwrite);\n+            let mut xopt = Some(xwrite);\n             do y.write_downgrade |_ywrite| {\n                 y.downgrade(option::swap_unwrap(&mut xopt));\n                 error!(\"oops, y.downgrade(x) should have failed!\");"}, {"sha": "6f479fbb9f7f583e06fa2f0c65ddf1ca0179f935", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -50,11 +50,11 @@ pub impl<T> TaskPool<T> {\n             let (port, chan) = pipes::stream::<Msg<T>>();\n             let init_fn = init_fn_factory();\n \n-            let task_body: ~fn() = |move port, move init_fn| {\n+            let task_body: ~fn() = || {\n                 let local_data = init_fn(i);\n                 loop {\n                     match port.recv() {\n-                        Execute(move f) => f(&local_data),\n+                        Execute(f) => f(&local_data),\n                         Quit => break\n                     }\n                 }\n@@ -64,23 +64,23 @@ pub impl<T> TaskPool<T> {\n             match opt_sched_mode {\n                 None => {\n                     // Run on this scheduler.\n-                    task::spawn(move task_body);\n+                    task::spawn(task_body);\n                 }\n                 Some(sched_mode) => {\n-                    task::task().sched_mode(sched_mode).spawn(move task_body);\n+                    task::task().sched_mode(sched_mode).spawn(task_body);\n                 }\n             }\n \n-            move chan\n+            chan\n         };\n \n-        return TaskPool { channels: move channels, next_index: 0 };\n+        return TaskPool { channels: channels, next_index: 0 };\n     }\n \n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n     fn execute(&self, f: ~fn(&T)) {\n-        self.channels[self.next_index].send(Execute(move f));\n+        self.channels[self.next_index].send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }\n     }\n@@ -90,9 +90,9 @@ pub impl<T> TaskPool<T> {\n fn test_task_pool() {\n     let f: ~fn() -> ~fn(uint) -> uint = || {\n         let g: ~fn(uint) -> uint = |i| i;\n-        move g\n+        g\n     };\n-    let pool = TaskPool::new(4, Some(SingleThreaded), move f);\n+    let pool = TaskPool::new(4, Some(SingleThreaded), f);\n     for 8.times {\n         pool.execute(|i| io::println(fmt!(\"Hello from thread %u!\", *i)));\n     }"}, {"sha": "cd03de911839014d6911076b976cd46b4ee2c32f", "filename": "src/libstd/test.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -120,8 +120,8 @@ pub struct TestDescAndFn {\n pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n     let opts =\n         match parse_opts(args) {\n-          either::Left(move o) => o,\n-          either::Right(move m) => fail!(m)\n+          either::Left(o) => o,\n+          either::Right(m) => fail!(m)\n         };\n     if !run_tests_console(&opts, tests) { fail!(~\"Some tests failed\"); }\n }\n@@ -173,8 +173,8 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n                  getopts::optopt(~\"logfile\")];\n     let matches =\n         match getopts::getopts(args_, opts) {\n-          Ok(move m) => m,\n-          Err(move f) => return either::Right(getopts::fail_str(f))\n+          Ok(m) => m,\n+          Err(f) => return either::Right(getopts::fail_str(f))\n         };\n \n     let filter =\n@@ -260,7 +260,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                 st.failed += 1;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n-                st.failures.push(move test);\n+                st.failures.push(test);\n               }\n               TrIgnored => {\n                 st.ignored += 1;\n@@ -410,7 +410,7 @@ fn should_sort_failures_before_printing_them() {\n             mut failed: 0u,\n             mut ignored: 0u,\n             mut benchmarked: 0u,\n-            mut failures: ~[move test_b, move test_a]\n+            mut failures: ~[test_b, test_a]\n         };\n \n         print_failures(st);\n@@ -486,7 +486,7 @@ fn run_tests(opts: &TestOpts,\n         callback(TeWait(copy b.desc));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n-        callback(TeResult(move test, result));\n+        callback(TeResult(test, result));\n     }\n }\n \n@@ -514,7 +514,7 @@ pub fn filter_tests(\n \n     // Remove tests that don't match the test filter\n     filtered = if opts.filter.is_none() {\n-        move filtered\n+        filtered\n     } else {\n         let filter_str =\n             match opts.filter {\n@@ -534,7 +534,7 @@ pub fn filter_tests(\n \n     // Maybe pull out the ignored test and unignore them\n     filtered = if !opts.run_ignored {\n-        move filtered\n+        filtered\n     } else {\n         fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n             if test.desc.ignore {\n@@ -556,7 +556,7 @@ pub fn filter_tests(\n     }\n     sort::quick_sort(filtered, lteq);\n \n-    move filtered\n+    filtered\n }\n \n struct TestFuture {\n@@ -582,9 +582,9 @@ pub fn run_test(force_ignore: bool,\n         do task::spawn {\n             let mut result_future = None; // task::future_result(builder);\n             task::task().unlinked().future_result(|+r| {\n-                result_future = Some(move r);\n+                result_future = Some(r);\n             }).spawn(testfn_cell.take());\n-            let task_result = option::unwrap(move result_future).recv();\n+            let task_result = option::unwrap(result_future).recv();\n             let test_result = calc_result(&desc,\n                                           task_result == task::Success);\n             monitor_ch.send((desc, test_result));\n@@ -965,9 +965,9 @@ mod tests {\n                     },\n                     testfn: DynTestFn(copy testfn),\n                 };\n-                tests.push(move test);\n+                tests.push(test);\n             }\n-            move tests\n+            tests\n         };\n         let filtered = filter_tests(&opts, tests);\n \n@@ -980,7 +980,7 @@ mod tests {\n               ~\"test::parse_ignored_flag\",\n               ~\"test::sort_tests\"];\n \n-        let pairs = vec::zip(expected, move filtered);\n+        let pairs = vec::zip(expected, filtered);\n \n         for vec::each(pairs) |p| {\n             match *p {"}, {"sha": "0b8b6c8d34d68a341d8c6f890ca81f53b40e7f5c", "filename": "src/libstd/time.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -170,7 +170,7 @@ pub fn at_utc(clock: Timespec) -> Tm {\n         let mut Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n         rustrt::rust_gmtime(sec, nsec, tm);\n-        move tm\n+        tm\n     }\n }\n \n@@ -185,7 +185,7 @@ pub fn at(clock: Timespec) -> Tm {\n         let mut Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n         rustrt::rust_localtime(sec, nsec, tm);\n-        move tm\n+        tm\n     }\n }\n \n@@ -205,7 +205,7 @@ pub pure fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n pub pure fn strftime(format: &str, tm: &Tm) -> ~str {\n     // unsafe only because do_strftime is annoying to make pure\n     // (it does IO with a str_reader)\n-    move unsafe { do_strftime(format, tm) }\n+    unsafe { do_strftime(format, tm) }\n }\n \n impl Tm {\n@@ -240,7 +240,7 @@ impl Tm {\n \n     /// Formats the time according to the format string.\n     pure fn strftime(&self, format: &str) -> ~str {\n-        move strftime(format, self)\n+        strftime(format, self)\n     }\n \n     /**\n@@ -689,7 +689,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 '%' => {\n                     match parse_type(s, pos, rdr.read_char(), &mut tm) {\n                         Ok(next) => pos = next,\n-                        Err(move e) => { result = Err(move e); break; }\n+                        Err(e) => { result = Err(e); break; }\n                     }\n                 },\n                 c => {\n@@ -714,7 +714,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm_zone: copy tm.tm_zone,\n                 tm_nsec: tm.tm_nsec,\n             })\n-        } else { move result }\n+        } else { result }\n     }\n }\n \n@@ -882,7 +882,7 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n         }\n     }\n \n-    move buf\n+    buf\n }\n \n #[cfg(test)]"}, {"sha": "872d53e93ebbe70ef03c96c4c6eee447efa9d92d", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -98,7 +98,7 @@ fn get_monitor_task_gl() -> IoTask {\n \n fn spawn_loop() -> IoTask {\n     let builder = do task().add_wrapper |task_body| {\n-        fn~(move task_body) {\n+        fn~() {\n             // The I/O loop task also needs to be weak so it doesn't keep\n             // the runtime alive\n             unsafe {\n@@ -116,7 +116,7 @@ fn spawn_loop() -> IoTask {\n         }\n     };\n     let builder = builder.unlinked();\n-    spawn_iotask(move builder)\n+    spawn_iotask(builder)\n }\n \n #[cfg(test)]"}, {"sha": "be4240237adf426bd201920b211271f6ce9ec8d0", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -78,7 +78,7 @@ pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n  */\n pub unsafe fn interact(iotask: &IoTask,\n                    cb: fn~(*c_void)) {\n-    send_msg(iotask, Interaction(move cb));\n+    send_msg(iotask, Interaction(cb));\n }\n \n /**\n@@ -150,7 +150,7 @@ struct IoTaskLoopData {\n \n fn send_msg(iotask: &IoTask,\n             msg: IoTaskMsg) {\n-    iotask.op_chan.send(move msg);\n+    iotask.op_chan.send(msg);\n     unsafe {\n         ll::async_send(iotask.async_handle);\n     }"}, {"sha": "96b285b8c0a85c710a843330e196be8f8ae90ed8", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -1252,7 +1252,6 @@ pub mod test {\n                     get_data_for_uv_handle(stream as *libc::c_void)\n                       as *request_wrapper;\n                 let buf_base = get_base_from_buf(buf);\n-                let buf_len = get_len_from_buf(buf);\n                 let bytes = vec::from_buf(buf_base, nread as uint);\n                 let read_chan = (*client_data).read_chan.clone();\n                 let msg_from_server = str::from_bytes(bytes);"}, {"sha": "cb0f7d84b4117106de56bf632a7938b890e59171", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -235,7 +235,7 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     do io::with_str_reader(s) |rdr| {\n         let j = result::unwrap(json::from_reader(rdr));\n-        Decodable::decode(&json::Decoder(move j))\n+        Decodable::decode(&json::Decoder(j))\n     }\n }\n \n@@ -323,37 +323,37 @@ impl TPrep for @Mut<Prep> {\n         Decodable<json::Decoder>>(&self,\n                                   blk: ~fn(&Exec) -> T) -> Work<T> {\n \n-        let mut bo = Some(move blk);\n+        let mut bo = Some(blk);\n \n         do self.borrow_imm |p| {\n             let cached = do p.ctxt.db.borrow_mut |db| {\n                 db.prepare(p.fn_name, &p.declared_inputs)\n             };\n \n-            match move cached {\n+            match cached {\n                 Some((ref disc_in, ref disc_out, ref res))\n                 if self.all_fresh(\"declared input\",\n                                   &p.declared_inputs) &&\n                 self.all_fresh(\"discovered input\", disc_in) &&\n                 self.all_fresh(\"discovered output\", disc_out) => {\n-                    Work::new(*self, move Left(json_decode(*res)))\n+                    Work::new(*self, Left(json_decode(*res)))\n                 }\n \n                 _ => {\n                     let (chan, port) = oneshot::init();\n                     let mut blk = None;\n                     blk <-> bo;\n                     let blk = blk.unwrap();\n-                    let chan = ~mut Some(move chan);\n-                    do task::spawn |move blk, move chan| {\n+                    let chan = ~mut Some(chan);\n+                    do task::spawn || {\n                         let exe = Exec{discovered_inputs: LinearMap::new(),\n                                        discovered_outputs: LinearMap::new()};\n                         let chan = option::swap_unwrap(&mut *chan);\n                         let v = blk(&exe);\n-                        send_one(move chan, (move exe, move v));\n+                        send_one(chan, (exe, v));\n                     }\n \n-                    Work::new(*self, move Right(move port))\n+                    Work::new(*self, Right(port))\n                 }\n             }\n         }\n@@ -365,7 +365,7 @@ impl<T:Owned\n        Decodable<json::Decoder>>\n     Work<T> {\n     static fn new(p: @Mut<Prep>, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n-        move Work { prep: p, res: Some(move e) }\n+        Work { prep: p, res: Some(e) }\n     }\n }\n \n@@ -374,18 +374,18 @@ fn unwrap<T:Owned\n             Encodable<json::Encoder>\n             Decodable<json::Decoder>>(w: Work<T>) -> T {\n \n-    let mut ww = move w;\n+    let mut ww = w;\n     let mut s = None;\n \n     ww.res <-> s;\n \n-    match move s {\n+    match s {\n         None => fail!(),\n-        Some(Left(move v)) => move v,\n-        Some(Right(move port)) => {\n+        Some(Left(v)) => v,\n+        Some(Right(port)) => {\n \n-            let (exe, v) = match recv(move port) {\n-                oneshot::send(move data) => move data\n+            let (exe, v) = match recv(port) {\n+                oneshot::send(data) => data\n             };\n \n             let s = json_encode(&v);\n@@ -399,7 +399,7 @@ fn unwrap<T:Owned\n                              s);\n                 }\n             }\n-            move v\n+            v\n         }\n     }\n }\n@@ -425,9 +425,9 @@ fn test() {\n         do prep.exec |_exe| {\n             let out = Path(\"foo.o\");\n             run::run_program(\"gcc\", [~\"foo.c\", ~\"-o\", out.to_str()]);\n-            move out.to_str()\n+            out.to_str()\n         }\n     };\n-    let s = unwrap(move w);\n+    let s = unwrap(w);\n     io::println(s);\n }"}, {"sha": "893647ca9ad82a4058bc78d11a3df26edc204412", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -270,7 +270,7 @@ pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     // This is sort of stupid here, converting to a vec of mutables and back\n     let mut v: ~[@ast::meta_item] = items;\n     std::sort::quick_sort(v, lteq);\n-    move v\n+    v\n }\n \n pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->"}, {"sha": "3c61e834af6f2a33c48108a710a4a6bc31b858ce", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -152,15 +152,15 @@ pub impl<D: Decoder> span: Decodable<D> {\n }\n \n pub pure fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n-    respan(mk_sp(lo, hi), move t)\n+    respan(mk_sp(lo, hi), t)\n }\n \n pub pure fn respan<T>(sp: span, +t: T) -> spanned<T> {\n     spanned {node: t, span: sp}\n }\n \n pub pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n-    respan(dummy_sp(), move t)\n+    respan(dummy_sp(), t)\n }\n \n /* assuming that we're not in macro expansion */"}, {"sha": "33eaaaae35b3e8f7b0652553d7191a89642e3034", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -281,7 +281,7 @@ pub fn mk_ctxt(parse_sess: parse::parse_sess,\n         mod_path: ~[],\n         trace_mac: false\n     };\n-    move ((move imp) as @ext_ctxt)\n+    ((imp) as @ext_ctxt)\n }\n \n pub fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {"}, {"sha": "963ea5bfe3329879adf68133620603bed6c82da4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -73,7 +73,7 @@ pub fn mk_raw_path_(sp: span,\n                  global: false,\n                  idents: idents,\n                  rp: None,\n-                 types: move types }\n+                 types: types }\n }\n pub fn mk_raw_path_global(sp: span, idents: ~[ast::ident]) -> @ast::path {\n     @ast::path { span: sp,\n@@ -156,7 +156,7 @@ pub fn mk_field(sp: span, f: &{ident: ast::ident, ex: @ast::expr})\n }\n pub fn mk_fields(sp: span, fields: ~[{ident: ast::ident, ex: @ast::expr}])\n               -> ~[ast::field] {\n-    move fields.map(|f| mk_field(sp, f))\n+    fields.map(|f| mk_field(sp, f))\n }\n pub fn mk_rec_e(cx: ext_ctxt,\n                 sp: span,\n@@ -288,41 +288,41 @@ pub fn mk_pat_ident_with_binding_mode(cx: ext_ctxt,\n                                       bm: ast::binding_mode) -> @ast::pat {\n     let path = mk_raw_path(span, ~[ ident ]);\n     let pat = ast::pat_ident(bm, path, None);\n-    mk_pat(cx, span, move pat)\n+    mk_pat(cx, span, pat)\n }\n pub fn mk_pat_enum(cx: ext_ctxt,\n                    span: span,\n                    path: @ast::path,\n                    +subpats: ~[@ast::pat])\n                 -> @ast::pat {\n-    let pat = ast::pat_enum(path, Some(move subpats));\n-    mk_pat(cx, span, move pat)\n+    let pat = ast::pat_enum(path, Some(subpats));\n+    mk_pat(cx, span, pat)\n }\n pub fn mk_pat_struct(cx: ext_ctxt,\n                      span: span,\n                      path: @ast::path,\n                      +field_pats: ~[ast::field_pat])\n                   -> @ast::pat {\n-    let pat = ast::pat_struct(path, move field_pats, false);\n-    mk_pat(cx, span, move pat)\n+    let pat = ast::pat_struct(path, field_pats, false);\n+    mk_pat(cx, span, pat)\n }\n pub fn mk_bool(cx: ext_ctxt, span: span, value: bool) -> @ast::expr {\n     let lit_expr = ast::expr_lit(@codemap::spanned {\n         node: ast::lit_bool(value),\n         span: span });\n-    build::mk_expr(cx, span, move lit_expr)\n+    build::mk_expr(cx, span, lit_expr)\n }\n pub fn mk_stmt(cx: ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n     let stmt_ = ast::stmt_semi(expr, cx.next_id());\n-    @codemap::spanned { node: move stmt_, span: span }\n+    @codemap::spanned { node: stmt_, span: span }\n }\n pub fn mk_ty_path(cx: ext_ctxt,\n                   span: span,\n                   idents: ~[ ast::ident ])\n                -> @ast::Ty {\n     let ty = build::mk_raw_path(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n-    let ty = @ast::Ty { id: cx.next_id(), node: move ty, span: span };\n+    let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n     ty\n }\n pub fn mk_ty_path_global(cx: ext_ctxt,\n@@ -331,7 +331,7 @@ pub fn mk_ty_path_global(cx: ext_ctxt,\n                       -> @ast::Ty {\n     let ty = build::mk_raw_path_global(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n-    let ty = @ast::Ty { id: cx.next_id(), node: move ty, span: span };\n+    let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n     ty\n }\n pub fn mk_simple_ty_path(cx: ext_ctxt,"}, {"sha": "1aa1d8ca9a07eeaedb1620075a02fb5b5f6f7bf7", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -95,27 +95,27 @@ fn expand_deriving(cx: ext_ctxt,\n                                                        span,\n                                                        struct_def,\n                                                        item.ident,\n-                                                       move ty_params));\n+                                                       ty_params));\n             }\n             item_enum(ref enum_definition, copy ty_params) => {\n                 result.push(expand_deriving_enum_def(cx,\n                                                      span,\n                                                      enum_definition,\n                                                      item.ident,\n-                                                     move ty_params));\n+                                                     ty_params));\n             }\n             _ => ()\n         }\n     }\n-    dvec::unwrap(move result)\n+    dvec::unwrap(result)\n }\n \n fn create_impl_item(cx: ext_ctxt, span: span, +item: item_) -> @item {\n     @ast::item {\n         ident: clownshoes_extensions,\n         attrs: ~[],\n         id: cx.next_id(),\n-        node: move item,\n+        node: item,\n         vis: public,\n         span: span,\n     }\n@@ -161,7 +161,7 @@ fn create_eq_method(cx: ext_ctxt,\n     };\n \n     // Create the function declaration.\n-    let fn_decl = build::mk_fn_decl(~[ move arg ], output_type);\n+    let fn_decl = build::mk_fn_decl(~[ arg ], output_type);\n \n     // Create the body block.\n     let body_block = build::mk_simple_block(cx, span, body);\n@@ -174,8 +174,8 @@ fn create_eq_method(cx: ext_ctxt,\n         tps: ~[],\n         self_ty: self_ty,\n         purity: pure_fn,\n-        decl: move fn_decl,\n-        body: move body_block,\n+        decl: fn_decl,\n+        body: body_block,\n         id: cx.next_id(),\n         span: span,\n         self_id: cx.next_id(),\n@@ -194,14 +194,14 @@ fn create_self_type_with_params(cx: ext_ctxt,\n         let self_ty_param = build::mk_simple_ty_path(cx,\n                                                      span,\n                                                      ty_param.ident);\n-        self_ty_params.push(move self_ty_param);\n+        self_ty_params.push(self_ty_param);\n     }\n-    let self_ty_params = dvec::unwrap(move self_ty_params);\n+    let self_ty_params = dvec::unwrap(self_ty_params);\n \n     // Create the type of `self`.\n     let self_type = build::mk_raw_path_(span,\n                                         ~[ type_ident ],\n-                                        move self_ty_params);\n+                                        self_ty_params);\n     let self_type = ty_path(self_type, cx.next_id());\n     @ast::Ty { id: cx.next_id(), node: self_type, span: span }\n }\n@@ -221,9 +221,9 @@ fn create_derived_impl(cx: ext_ctxt,\n                                              trait_path.map(|x| *x));\n         let bounds = @~[ TraitTyParamBound(bound) ];\n         let impl_ty_param = build::mk_ty_param(cx, ty_param.ident, bounds);\n-        impl_ty_params.push(move impl_ty_param);\n+        impl_ty_params.push(impl_ty_param);\n     }\n-    let impl_ty_params = dvec::unwrap(move impl_ty_params);\n+    let impl_ty_params = dvec::unwrap(impl_ty_params);\n \n     // Create the reference to the trait.\n     let trait_path = ast::path {\n@@ -233,12 +233,12 @@ fn create_derived_impl(cx: ext_ctxt,\n         rp: None,\n         types: ~[]\n     };\n-    let trait_path = @move trait_path;\n+    let trait_path = @trait_path;\n     let trait_ref = ast::trait_ref {\n         path: trait_path,\n         ref_id: cx.next_id()\n     };\n-    let trait_ref = @move trait_ref;\n+    let trait_ref = @trait_ref;\n \n     // Create the type of `self`.\n     let self_type = create_self_type_with_params(cx,\n@@ -247,11 +247,11 @@ fn create_derived_impl(cx: ext_ctxt,\n                                                  ty_params);\n \n     // Create the impl item.\n-    let impl_item = item_impl(move impl_ty_params,\n+    let impl_item = item_impl(impl_ty_params,\n                               Some(trait_ref),\n                               self_type,\n                               methods.map(|x| *x));\n-    return create_impl_item(cx, span, move impl_item);\n+    return create_impl_item(cx, span, impl_item);\n }\n \n fn create_derived_eq_impl(cx: ext_ctxt,\n@@ -310,11 +310,11 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n     let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n \n     // Create the function declaration.\n-    let inputs = ~[ move lsb0_arg, move f_arg ];\n-    let fn_decl = build::mk_fn_decl(move inputs, output_type);\n+    let inputs = ~[ lsb0_arg, f_arg ];\n+    let fn_decl = build::mk_fn_decl(inputs, output_type);\n \n     // Create the body block.\n-    let body_block = build::mk_block_(cx, span, move statements);\n+    let body_block = build::mk_block_(cx, span, statements);\n \n     // Create the method.\n     let self_ty = spanned { node: sty_region(m_imm), span: span };\n@@ -325,8 +325,8 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n         tps: ~[],\n         self_ty: self_ty,\n         purity: pure_fn,\n-        decl: move fn_decl,\n-        body: move body_block,\n+        decl: fn_decl,\n+        body: body_block,\n         id: cx.next_id(),\n         span: span,\n         self_id: cx.next_id(),\n@@ -348,10 +348,10 @@ fn create_subpatterns(cx: ext_ctxt,\n         // Create the subpattern.\n         let subpath = build::mk_raw_path(span, ~[ ident ]);\n         let subpat = pat_ident(bind_by_ref(m_imm), subpath, None);\n-        let subpat = build::mk_pat(cx, span, move subpat);\n+        let subpat = build::mk_pat(cx, span, subpat);\n         subpats.push(subpat);\n     }\n-    return dvec::unwrap(move subpats);\n+    return dvec::unwrap(subpats);\n }\n \n fn create_enum_variant_pattern(cx: ext_ctxt,\n@@ -373,7 +373,7 @@ fn create_enum_variant_pattern(cx: ext_ctxt,\n                                              prefix,\n                                              variant_args.len());\n \n-            return build::mk_pat_enum(cx, span, matching_path, move subpats);\n+            return build::mk_pat_enum(cx, span, matching_path, subpats);\n         }\n         struct_variant_kind(struct_def) => {\n             let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);\n@@ -508,7 +508,7 @@ fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n     return create_derived_eq_impl(cx,\n                                   span,\n                                   type_ident,\n-                                  move ty_params,\n+                                  ty_params,\n                                   eq_method,\n                                   ne_method);\n }\n@@ -541,7 +541,7 @@ fn expand_deriving_eq_enum_def(cx: ext_ctxt,\n     return create_derived_eq_impl(cx,\n                                   span,\n                                   type_ident,\n-                                  move ty_params,\n+                                  ty_params,\n                                   eq_method,\n                                   ne_method);\n }\n@@ -561,7 +561,7 @@ fn expand_deriving_iter_bytes_struct_def(cx: ext_ctxt,\n     return create_derived_iter_bytes_impl(cx,\n                                           span,\n                                           type_ident,\n-                                          move ty_params,\n+                                          ty_params,\n                                           method);\n }\n \n@@ -580,7 +580,7 @@ fn expand_deriving_iter_bytes_enum_def(cx: ext_ctxt,\n     return create_derived_iter_bytes_impl(cx,\n                                           span,\n                                           type_ident,\n-                                          move ty_params,\n+                                          ty_params,\n                                           method);\n }\n \n@@ -671,8 +671,8 @@ fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n     }\n \n     // Create the method itself.\n-    let statements = dvec::unwrap(move statements);\n-    return create_iter_bytes_method(cx, span, move statements);\n+    let statements = dvec::unwrap(statements);\n+    return create_iter_bytes_method(cx, span, statements);\n }\n \n fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n@@ -738,9 +738,9 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n         let matching_arm = ast::arm {\n             pats: ~[ matching_pat ],\n             guard: None,\n-            body: move matching_body_block\n+            body: matching_body_block\n         };\n-        other_arms.push(move matching_arm);\n+        other_arms.push(matching_arm);\n \n         // Maybe generate a non-matching case. If there is only one\n         // variant then there will always be a match.\n@@ -777,11 +777,11 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n         // Create the self pattern body.\n         let other_expr = build::mk_path(cx, span, ~[ other_ident ]);\n         let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-        let other_arms = dvec::unwrap(move other_arms);\n-        let other_match_expr = expr_match(other_expr, move other_arms);\n+        let other_arms = dvec::unwrap(other_arms);\n+        let other_match_expr = expr_match(other_expr, other_arms);\n         let other_match_expr = build::mk_expr(cx,\n                                               span,\n-                                              move other_match_expr);\n+                                              other_match_expr);\n         let other_match_body_block = build::mk_simple_block(cx,\n                                                             span,\n                                                             other_match_expr);\n@@ -792,15 +792,15 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n             guard: None,\n             body: other_match_body_block,\n         };\n-        self_arms.push(move self_arm);\n+        self_arms.push(self_arm);\n     }\n \n     // Create the method body.\n     let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n     let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_arms = dvec::unwrap(move self_arms);\n-    let self_match_expr = expr_match(self_expr, move self_arms);\n-    let self_match_expr = build::mk_expr(cx, span, move self_match_expr);\n+    let self_arms = dvec::unwrap(self_arms);\n+    let self_match_expr = expr_match(self_expr, self_arms);\n+    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n \n     // Create the method.\n     return create_eq_method(cx,\n@@ -848,8 +848,8 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n         }\n \n         // Create the pattern body.\n-        let stmts = dvec::unwrap(move stmts);\n-        let match_body_block = build::mk_block_(cx, span, move stmts);\n+        let stmts = dvec::unwrap(stmts);\n+        let match_body_block = build::mk_block_(cx, span, stmts);\n \n         // Create the arm.\n         ast::arm {"}, {"sha": "c690c89c025f2fb8b6c34c710f12ced4600b9ac5", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -53,7 +53,7 @@ pub fn analyze(proto: protocol, _cx: ext_ctxt) {\n         for state.reachable |s| {\n             bv.set(s.id, true);\n         }\n-        move bv\n+        bv\n     };\n \n     let mut i = 0;"}, {"sha": "0f596e661583dae323d60b260641dcb76ba8b8a0", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -73,10 +73,10 @@ pub impl message: gen_send {\n \n             if this.proto.is_bounded() {\n                 let (sp, rp) = match (this.dir, next.dir) {\n-                  (send, send) => (~\"move c\", ~\"move s\"),\n+                  (send, send) => (~\"c\", ~\"s\"),\n                   (send, recv) => (~\"s\", ~\"c\"),\n                   (recv, send) => (~\"s\", ~\"c\"),\n-                  (recv, recv) => (~\"move c\", ~\"move s\")\n+                  (recv, recv) => (~\"c\", ~\"s\")\n                 };\n \n                 body += ~\"let b = pipe.reuse_buffer();\\n\";\n@@ -89,28 +89,28 @@ pub impl message: gen_send {\n             }\n             else {\n                 let pat = match (this.dir, next.dir) {\n-                  (send, send) => \"(move c, move s)\",\n+                  (send, send) => \"(c, s)\",\n                   (send, recv) => \"(s, c)\",\n                   (recv, send) => \"(s, c)\",\n-                  (recv, recv) => \"(move c, move s)\"\n+                  (recv, recv) => \"(c, s)\"\n                 };\n \n                 body += fmt!(\"let %s = ::pipes::entangle();\\n\", pat);\n             }\n             body += fmt!(\"let message = %s(%s);\\n\",\n                          self.name(),\n                          str::connect(vec::append_one(\n-                           arg_names.map(|x| ~\"move \" + cx.str_of(*x)),\n-                             ~\"move s\"), ~\", \"));\n+                           arg_names.map(|x| cx.str_of(*x)),\n+                             ~\"s\"), ~\", \"));\n \n             if !try {\n-                body += fmt!(\"::pipes::send(move pipe, move message);\\n\");\n+                body += fmt!(\"::pipes::send(pipe, message);\\n\");\n                 // return the new channel\n-                body += ~\"move c }\";\n+                body += ~\"c }\";\n             }\n             else {\n-                body += fmt!(\"if ::pipes::send(move pipe, move message) {\\n \\\n-                                  ::pipes::rt::make_some(move c) \\\n+                body += fmt!(\"if ::pipes::send(pipe, message) {\\n \\\n+                                  ::pipes::rt::make_some(c) \\\n                               } else { ::pipes::rt::make_none() } }\");\n             }\n \n@@ -153,7 +153,7 @@ pub impl message: gen_send {\n                     ~\"\"\n                 }\n                 else {\n-                    ~\"(\" + str::connect(arg_names.map(|x| ~\"move \" + *x),\n+                    ~\"(\" + str::connect(arg_names.map(|x| *x),\n                                         ~\", \") + ~\")\"\n                 };\n \n@@ -164,10 +164,10 @@ pub impl message: gen_send {\n                              message_args);\n \n                 if !try {\n-                    body += fmt!(\"::pipes::send(move pipe, move message);\\n\");\n+                    body += fmt!(\"::pipes::send(pipe, message);\\n\");\n                     body += ~\" }\";\n                 } else {\n-                    body += fmt!(\"if ::pipes::send(move pipe, move message) \\\n+                    body += fmt!(\"if ::pipes::send(pipe, message) \\\n                                         { \\\n                                       ::pipes::rt::make_some(()) \\\n                                   } else { \\\n@@ -319,7 +319,7 @@ pub impl protocol: gen_init {\n               recv => {\n                 quote_expr!({\n                     let (s, c) = ::pipes::entangle();\n-                    (move c, move s)\n+                    (c, s)\n                 })\n               }\n             }\n@@ -331,7 +331,7 @@ pub impl protocol: gen_init {\n               recv => {\n                   quote_expr!({\n                       let (s, c) = $body;\n-                      (move c, move s)\n+                      (c, s)\n                   })\n               }\n             }\n@@ -375,7 +375,7 @@ pub impl protocol: gen_init {\n \n         quote_expr!({\n             let buffer = $buffer;\n-            do ::pipes::entangle_buffer(move buffer) |buffer, data| {\n+            do ::pipes::entangle_buffer(buffer) |buffer, data| {\n                 $entangle_body\n             }\n         })"}, {"sha": "1d6534aef3464703d022885e12748c60b0d3e24c", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -207,7 +207,7 @@ pub impl protocol {\n             span: self.span,\n             dir: dir,\n             ty_params: ty_params,\n-            messages: move messages,\n+            messages: messages,\n             proto: self\n         });\n "}, {"sha": "df10f15c709cb6cf2be2b8b327fa6101eb1ead4a", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -279,7 +279,7 @@ pub fn parse(sess: parse_sess,\n                         }\n \n                         new_pos.idx += 1;\n-                        cur_eis.push(move new_pos);\n+                        cur_eis.push(new_pos);\n                     }\n \n                     // can we go around again?\n@@ -288,19 +288,19 @@ pub fn parse(sess: parse_sess,\n                     match copy ei.sep {\n                       Some(ref t) if idx == len => { // we need a separator\n                         if tok == (*t) { //pass the separator\n-                            let ei_t = move ei;\n+                            let ei_t = ei;\n                             ei_t.idx += 1;\n-                            next_eis.push(move ei_t);\n+                            next_eis.push(ei_t);\n                         }\n                       }\n                       _ => { // we don't need a separator\n-                        let ei_t = move ei;\n+                        let ei_t = ei;\n                         ei_t.idx = 0;\n-                        cur_eis.push(move ei_t);\n+                        cur_eis.push(ei_t);\n                       }\n                     }\n                 } else {\n-                    eof_eis.push(move ei);\n+                    eof_eis.push(ei);\n                 }\n             } else {\n                 match copy ei.elts[idx].node {\n@@ -315,26 +315,26 @@ pub fn parse(sess: parse_sess,\n                             new_ei.matches[idx].push(@matched_seq(~[], sp));\n                         }\n \n-                        cur_eis.push(move new_ei);\n+                        cur_eis.push(new_ei);\n                     }\n \n                     let matches = vec::map(ei.matches, // fresh, same size:\n                                            |_m| DVec::<@named_match>());\n-                    let ei_t = move ei;\n+                    let ei_t = ei;\n                     cur_eis.push(~{\n                         elts: (*matchers), sep: (*sep), mut idx: 0u,\n-                        mut up: matcher_pos_up(Some(move ei_t)),\n-                        matches: move matches,\n+                        mut up: matcher_pos_up(Some(ei_t)),\n+                        matches: matches,\n                         match_lo: match_idx_lo, match_hi: match_idx_hi,\n                         sp_lo: sp.lo\n                     });\n                   }\n-                  match_nonterminal(_,_,_) => { bb_eis.push(move ei) }\n+                  match_nonterminal(_,_,_) => { bb_eis.push(ei) }\n                   match_tok(ref t) => {\n-                    let ei_t = move ei;\n+                    let ei_t = ei;\n                     if (*t) == tok {\n                         ei_t.idx += 1;\n-                        next_eis.push(move ei_t);\n+                        next_eis.push(ei_t);\n                     }\n                   }\n                 }\n@@ -388,7 +388,7 @@ pub fn parse(sess: parse_sess,\n                   }\n                   _ => fail!()\n                 }\n-                cur_eis.push(move ei);\n+                cur_eis.push(ei);\n \n                 for rust_parser.tokens_consumed.times() || {\n                     rdr.next_token();"}, {"sha": "ff9a353ee92bbe3f396af0bd7a6df968aa7effaf", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -252,7 +252,7 @@ pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n               };\n             item_trait(fold_ty_params(tps, fld),\n                        vec::map(traits, |p| fold_trait_ref(*p, fld)),\n-                       move methods)\n+                       methods)\n           }\n       item_mac(ref m) => {\n         // FIXME #2888: we might actually want to do something here."}, {"sha": "82c1697bf72b01497886fc07ced61102c19c8734", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -151,7 +151,7 @@ pub fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n         p.reader.fatal(~\"expected end-of-string\");\n     }\n     p.abort_if_errors();\n-    move r\n+    r\n }\n \n pub fn next_node_id(sess: parse_sess) -> node_id {\n@@ -177,16 +177,16 @@ pub fn new_parser_from_file(sess: parse_sess,\n                             path: &Path)\n                          -> Result<Parser, ~str> {\n     match io::read_whole_file_str(path) {\n-      result::Ok(move src) => {\n+      result::Ok(src) => {\n \n-          let filemap = sess.cm.new_filemap(path.to_str(), @move src);\n+          let filemap = sess.cm.new_filemap(path.to_str(), @src);\n           let srdr = lexer::new_string_reader(sess.span_diagnostic,\n                                               filemap,\n                                               sess.interner);\n           Ok(Parser(sess, cfg, srdr as reader))\n \n       }\n-      result::Err(move e) => Err(move e)\n+      result::Err(e) => Err(e)\n     }\n }\n \n@@ -195,8 +195,8 @@ pub fn new_parser_from_file(sess: parse_sess,\n pub fn new_crate_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n                               path: &Path) -> Parser {\n     match new_parser_from_file(sess, cfg, path) {\n-        Ok(move parser) => move parser,\n-        Err(move e) => {\n+        Ok(parser) => parser,\n+        Err(e) => {\n             sess.span_diagnostic.handler().fatal(e)\n         }\n     }\n@@ -207,8 +207,8 @@ pub fn new_crate_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n pub fn new_sub_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n                             path: &Path, sp: span) -> Parser {\n     match new_parser_from_file(sess, cfg, path) {\n-        Ok(move parser) => move parser,\n-        Err(move e) => {\n+        Ok(parser) => parser,\n+        Err(e) => {\n             sess.span_diagnostic.span_fatal(sp, e)\n         }\n     }"}, {"sha": "b4fd7a5d2e8b428683f41bf1c1aee80f9170657d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -190,8 +190,8 @@ pub fn Parser(sess: parse_sess\n     let interner = rdr.interner();\n \n     Parser {\n-        reader: move rdr,\n-        interner: move interner,\n+        reader: rdr,\n+        interner: interner,\n         sess: sess,\n         cfg: cfg,\n         token: tok0.tok,\n@@ -712,7 +712,7 @@ pub impl Parser {\n     fn parse_capture_item_or(parse_arg_fn: fn(Parser) -> arg_or_capture_item)\n         -> arg_or_capture_item\n     {\n-        if self.eat_keyword(~\"move\") || self.eat_keyword(~\"copy\") {\n+        if self.eat_keyword(~\"copy\") {\n             // XXX outdated syntax now that moves-based-on-type has gone in\n             self.parse_ident();\n             either::Right(())\n@@ -1083,9 +1083,6 @@ pub impl Parser {\n             let e = self.parse_expr();\n             ex = expr_copy(e);\n             hi = e.span.hi;\n-        } else if self.eat_keyword(~\"move\") {\n-            // XXX move keyword is no longer important, remove after snapshot\n-            return self.parse_expr();\n         } else if self.token == token::MOD_SEP ||\n             is_ident(self.token) && !self.is_keyword(~\"true\") &&\n             !self.is_keyword(~\"false\") {\n@@ -1197,7 +1194,7 @@ pub impl Parser {\n                             hi = self.span.hi;\n \n                             let nd = expr_method_call(e, i, tys, es, NoSugar);\n-                            e = self.mk_expr(lo, hi, move nd);\n+                            e = self.mk_expr(lo, hi, nd);\n                         }\n                         _ => {\n                             e = self.mk_expr(lo, hi, expr_field(e, i, tys));\n@@ -2099,10 +2096,6 @@ pub impl Parser {\n             } else if self.eat_keyword(~\"copy\") {\n                 pat = self.parse_pat_ident(refutable, bind_by_copy);\n             } else {\n-                if self.eat_keyword(~\"move\") {\n-                    /* XXX---remove move keyword */\n-                }\n-\n                 // XXX---refutable match bindings should work same as let\n                 let binding_mode =\n                     if refutable {bind_infer} else {bind_by_copy};\n@@ -2372,7 +2365,7 @@ pub impl Parser {\n             self.obsolete(copy self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(token::LBRACE);\n-        let {inner: move inner, next: move next} =\n+        let {inner: inner, next: next} =\n             maybe_parse_inner_attrs_and_next(self, parse_attrs);\n         return (inner, self.parse_block_tail_(lo, default_blk, next));\n     }\n@@ -2397,8 +2390,8 @@ pub impl Parser {\n         let mut stmts = ~[];\n         let mut expr = None;\n \n-        let {attrs_remaining: move attrs_remaining,\n-             view_items: move view_items,\n+        let {attrs_remaining: attrs_remaining,\n+             view_items: view_items,\n              items: items, _} =\n             self.parse_items_and_view_items(first_item_attrs,\n                                             IMPORTS_AND_ITEMS_ALLOWED, false);\n@@ -2570,7 +2563,7 @@ pub impl Parser {\n                 }\n             }\n         }\n-        return @move bounds;\n+        return @bounds;\n     }\n \n     fn parse_ty_param() -> ty_param {\n@@ -3083,13 +3076,13 @@ pub impl Parser {\n     fn parse_mod_items(term: token::Token,\n                        +first_item_attrs: ~[attribute]) -> _mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining: move attrs_remaining,\n-             view_items: move view_items,\n+        let {attrs_remaining: attrs_remaining,\n+             view_items: view_items,\n              items: starting_items, _} =\n             self.parse_items_and_view_items(first_item_attrs,\n                                             VIEW_ITEMS_AND_ITEMS_ALLOWED,\n                                             true);\n-        let mut items: ~[@item] = move starting_items;\n+        let mut items: ~[@item] = starting_items;\n \n         let mut first = true;\n         while self.token != term {\n@@ -3140,7 +3133,7 @@ pub impl Parser {\n             self.bump();\n             // This mod is in an external file. Let's go get it!\n             let (m, attrs) = self.eval_src_mod(id, outer_attrs, id_span);\n-            (id, m, Some(move attrs))\n+            (id, m, Some(attrs))\n         } else {\n             self.push_mod_path(id, outer_attrs);\n             self.expect(token::LBRACE);\n@@ -3300,9 +3293,9 @@ pub impl Parser {\n     fn parse_foreign_item(+attrs: ~[attribute]) -> @foreign_item {\n         let vis = self.parse_visibility();\n         if self.is_keyword(~\"const\") {\n-            self.parse_item_foreign_const(vis, move attrs)\n+            self.parse_item_foreign_const(vis, attrs)\n         } else {\n-            self.parse_item_foreign_fn( move attrs)\n+            self.parse_item_foreign_fn(attrs)\n         }\n     }\n \n@@ -3311,15 +3304,15 @@ pub impl Parser {\n                                +first_item_attrs: ~[attribute])\n                             -> foreign_mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining: move attrs_remaining,\n-             view_items: move view_items,\n+        let {attrs_remaining: attrs_remaining,\n+             view_items: view_items,\n              items: _,\n-             foreign_items: move foreign_items} =\n+             foreign_items: foreign_items} =\n             self.parse_items_and_view_items(first_item_attrs,\n                                          VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED,\n                                             true);\n \n-        let mut items: ~[@foreign_item] = move foreign_items;\n+        let mut items: ~[@foreign_item] = foreign_items;\n         let mut initial_attrs = attrs_remaining;\n         while self.token != token::RBRACE {\n             let attrs = vec::append(initial_attrs,\n@@ -3329,7 +3322,7 @@ pub impl Parser {\n         }\n         ast::foreign_mod {\n             sort: sort,\n-            abi: move abi,\n+            abi: abi,\n             view_items: view_items,\n             items: items\n         }\n@@ -3382,14 +3375,14 @@ pub impl Parser {\n         // extern mod { ... }\n         if items_allowed && self.eat(token::LBRACE) {\n             let abi;\n-            match move abi_opt {\n-                Some(move found_abi) => abi = move found_abi,\n+            match abi_opt {\n+                Some(found_abi) => abi = found_abi,\n                 None => abi = special_idents::c_abi,\n             }\n \n             let extra_attrs = self.parse_inner_attrs_and_next();\n             let m = self.parse_foreign_mod_items(sort,\n-                                                 move abi,\n+                                                 abi,\n                                                  extra_attrs.next);\n             self.expect(token::RBRACE);\n \n@@ -3513,7 +3506,7 @@ pub impl Parser {\n                 ident = self.parse_ident();\n                 self.expect(token::LBRACE);\n                 let nested_enum_def = self.parse_enum_def(ty_params);\n-                kind = enum_variant_kind(move nested_enum_def);\n+                kind = enum_variant_kind(nested_enum_def);\n                 needs_comma = false;\n             } else {\n                 ident = self.parse_value_ident();"}, {"sha": "bdd26fc00a7dc59b1bcf26c4738155c54c15eb68", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -493,7 +493,7 @@ pub fn strict_keyword_table() -> HashMap<~str, ()> {\n         ~\"false\", ~\"fn\", ~\"for\",\n         ~\"if\", ~\"impl\",\n         ~\"let\", ~\"log\", ~\"loop\",\n-        ~\"match\", ~\"mod\", ~\"move\", ~\"mut\",\n+        ~\"match\", ~\"mod\", ~\"mut\",\n         ~\"once\",\n         ~\"priv\", ~\"pub\", ~\"pure\",\n         ~\"ref\", ~\"return\","}, {"sha": "a30447d968e1de57a8cafdae450b1d5301499981", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -147,11 +147,11 @@ pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n         space: linewidth as int,\n         left: 0,\n         right: 0,\n-        token: move token,\n-        size: move size,\n+        token: token,\n+        size: size,\n         left_total: 0,\n         right_total: 0,\n-        scan_stack: move scan_stack,\n+        scan_stack: scan_stack,\n         scan_stack_empty: true,\n         top: 0,\n         bottom: 0,"}, {"sha": "0677e25a3fedf380c54f7bf297050f0bbb0c56f3", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -24,7 +24,7 @@ pub fn mk<T:Eq IterBytes Hash Const Copy>() -> Interner<T> {\n     let m = oldmap::HashMap::<T, uint>();\n     let hi: hash_interner<T> =\n         {map: m, vect: DVec()};\n-    move ((move hi) as Interner::<T>)\n+    ((hi) as Interner::<T>)\n }\n \n pub fn mk_prefill<T:Eq IterBytes Hash Const Copy>(init: &[T]) -> Interner<T> {"}, {"sha": "3ab101bc0b4e83183f08d78ca084b56dfa8a939c", "filename": "src/test/auxiliary/cci_class_6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -27,7 +27,7 @@ pub mod kitties {\n         cat {\n             meows: in_x,\n             how_hungry: in_y,\n-            info: move in_info\n+            info: in_info\n         }\n     }\n }"}, {"sha": "1dfcb31f19638853ef4d965744efbf3dc8ea8cfa", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -27,7 +27,7 @@ fn collect_dvec(num: uint) -> ~[uint] {\n     for uint::range(0u, num) |i| {\n         result.push(i);\n     }\n-    return dvec::unwrap(move result);\n+    return dvec::unwrap(result);\n }\n \n fn main() {"}, {"sha": "5910ade013e8844f595f5d31d802843dc8fe47dd", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -141,7 +141,7 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n         };\n     }\n \n-    move marks\n+    marks\n }\n \n /**\n@@ -260,7 +260,7 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         i += 1;\n         let old_len = colors.len();\n \n-        let color = arc::ARC(move colors);\n+        let color = arc::ARC(colors);\n \n         let color_vec = arc::get(&color); // FIXME #3387 requires this temp\n         colors = do par::mapi(*color_vec) {"}, {"sha": "bfbc7ecd20ac692e1efa907f4f13d160ba23185a", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -27,7 +27,7 @@ use io::WriterUtil;\n use pipes::{Port, Chan, SharedChan};\n \n macro_rules! move_out (\n-    { $x:expr } => { unsafe { let y = move *ptr::addr_of(&($x)); move y } }\n+    { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n )\n \n enum request {\n@@ -58,7 +58,7 @@ fn run(args: &[~str]) {\n     let (from_child, to_parent) = pipes::stream();\n     let (from_parent, to_child) = pipes::stream();\n \n-    let to_child = SharedChan(move to_child);\n+    let to_child = SharedChan(to_child);\n \n     let size = uint::from_str(args[1]).get();\n     let workers = uint::from_str(args[2]).get();\n@@ -68,16 +68,16 @@ fn run(args: &[~str]) {\n     for uint::range(0, workers) |_i| {\n         let to_child = to_child.clone();\n         do task::task().future_result(|+r| {\n-            worker_results.push(move r);\n-        }).spawn |move to_child| {\n+            worker_results.push(r);\n+        }).spawn || {\n             for uint::range(0, size / workers) |_i| {\n                 //error!(\"worker %?: sending %? bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n             //error!(\"worker %? exiting\", i);\n         };\n     }\n-    do task::spawn |move from_parent, move to_parent| {\n+    do task::spawn || {\n         server(from_parent, to_parent);\n     }\n "}, {"sha": "57d9bb49df25ab03bb48a5066f10c2e02a4e9af9", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -23,7 +23,7 @@ use io::WriterUtil;\n use pipes::{Port, PortSet, Chan};\n \n macro_rules! move_out (\n-    { $x:expr } => { unsafe { let y = move *ptr::addr_of(&($x)); move y } }\n+    { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n )\n \n enum request {\n@@ -54,7 +54,7 @@ fn run(args: &[~str]) {\n     let (from_child, to_parent) = pipes::stream();\n     let (from_parent_, to_child) = pipes::stream();\n     let from_parent = PortSet();\n-    from_parent.add(move from_parent_);\n+    from_parent.add(from_parent_);\n \n     let size = uint::from_str(args[1]).get();\n     let workers = uint::from_str(args[2]).get();\n@@ -63,18 +63,18 @@ fn run(args: &[~str]) {\n     let mut worker_results = ~[];\n     for uint::range(0, workers) |_i| {\n         let (from_parent_, to_child) = pipes::stream();\n-        from_parent.add(move from_parent_);\n+        from_parent.add(from_parent_);\n         do task::task().future_result(|+r| {\n-            worker_results.push(move r);\n-        }).spawn |move to_child| {\n+            worker_results.push(r);\n+        }).spawn || {\n             for uint::range(0, size / workers) |_i| {\n                 //error!(\"worker %?: sending %? bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n             //error!(\"worker %? exiting\", i);\n         };\n     }\n-    do task::spawn |move from_parent, move to_parent| {\n+    do task::spawn || {\n         server(from_parent, to_parent);\n     }\n "}, {"sha": "9b6fee5e23bc1280046f2d808d975df3324878c7", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -40,26 +40,26 @@ fn recv(p: &pipe) -> uint {\n \n fn init() -> (pipe,pipe) {\n     let m = arc::MutexARC(~[]);\n-    ((&m).clone(), move m)\n+    ((&m).clone(), m)\n }\n \n \n fn thread_ring(i: uint,\n                count: uint,\n                +num_chan: pipe,\n                +num_port: pipe) {\n-    let mut num_chan = move Some(move num_chan);\n-    let mut num_port = move Some(move num_port);\n+    let mut num_chan = Some(num_chan);\n+    let mut num_port = Some(num_port);\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n         //error!(\"task %?, iter %?\", i, j);\n         let mut num_chan2 = option::swap_unwrap(&mut num_chan);\n         let mut num_port2 = option::swap_unwrap(&mut num_port);\n         send(&num_chan2, i * j);\n-        num_chan = Some(move num_chan2);\n+        num_chan = Some(num_chan2);\n         let _n = recv(&num_port2);\n         //log(error, _n);\n-        num_port = Some(move num_port2);\n+        num_port = Some(num_port2);\n     };\n }\n \n@@ -77,7 +77,7 @@ fn main() {\n     let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = init();\n-    let mut num_chan = Some(move num_chan);\n+    let mut num_chan = Some(num_chan);\n \n     let start = time::precise_time_s();\n \n@@ -89,22 +89,22 @@ fn main() {\n         let (new_chan, num_port) = init();\n         let num_chan2 = ~mut None;\n         *num_chan2 <-> num_chan;\n-        let num_port = ~mut Some(move num_port);\n-        let new_future = future::spawn(|move num_chan2, move num_port| {\n+        let num_port = ~mut Some(num_port);\n+        let new_future = do future::spawn() || {\n             let mut num_chan = None;\n             num_chan <-> *num_chan2;\n             let mut num_port1 = None;\n             num_port1 <-> *num_port;\n             thread_ring(i, msg_per_task,\n-                        option::unwrap(move num_chan),\n-                        option::unwrap(move num_port1))\n-        });\n-        futures.push(move new_future);\n-        num_chan = Some(move new_chan);\n+                        option::unwrap(num_chan),\n+                        option::unwrap(num_port1))\n+        };\n+        futures.push(new_future);\n+        num_chan = Some(new_chan);\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, option::unwrap(move num_chan), move num_port);\n+    thread_ring(0, msg_per_task, option::unwrap(num_chan), num_port);\n \n     // synchronize\n     for futures.each |f| { f.get() };"}, {"sha": "71ca0f957657506ad3aae844712715234febfe0a", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -29,25 +29,25 @@ proto! ring (\n )\n \n macro_rules! move_out (\n-    ($x:expr) => { unsafe { let y = move *ptr::addr_of(&$x); move y } }\n+    ($x:expr) => { unsafe { let y = *ptr::addr_of(&$x); y } }\n )\n \n fn thread_ring(i: uint,\n                count: uint,\n                +num_chan: ring::client::num,\n                +num_port: ring::server::num) {\n-    let mut num_chan = move Some(move num_chan);\n-    let mut num_port = move Some(move num_port);\n+    let mut num_chan = Some(num_chan);\n+    let mut num_port = Some(num_port);\n     // Send/Receive lots of messages.\n     for uint::range(0, count) |j| {\n         //error!(\"task %?, iter %?\", i, j);\n         let mut num_chan2 = None;\n         let mut num_port2 = None;\n         num_chan2 <-> num_chan;\n         num_port2 <-> num_port;\n-        num_chan = Some(ring::client::num(option::unwrap(move num_chan2), i * j));\n-        let port = option::unwrap(move num_port2);\n-        match recv(move port) {\n+        num_chan = Some(ring::client::num(option::unwrap(num_chan2), i * j));\n+        let port = option::unwrap(num_port2);\n+        match recv(port) {\n           ring::num(_n, p) => {\n             //log(error, _n);\n             num_port = Some(move_out!(p));\n@@ -70,7 +70,7 @@ fn main() {\n     let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = ring::init();\n-    let mut num_chan = Some(move num_chan);\n+    let mut num_chan = Some(num_chan);\n \n     let start = time::precise_time_s();\n \n@@ -82,23 +82,22 @@ fn main() {\n         let (new_chan, num_port) = ring::init();\n         let num_chan2 = ~mut None;\n         *num_chan2 <-> num_chan;\n-        let num_port = ~mut Some(move num_port);\n-        let new_future = do future::spawn\n-            |move num_chan2, move num_port| {\n+        let num_port = ~mut Some(num_port);\n+        let new_future = do future::spawn || {\n             let mut num_chan = None;\n             num_chan <-> *num_chan2;\n             let mut num_port1 = None;\n             num_port1 <-> *num_port;\n             thread_ring(i, msg_per_task,\n-                        option::unwrap(move num_chan),\n-                        option::unwrap(move num_port1))\n+                        option::unwrap(num_chan),\n+                        option::unwrap(num_port1))\n         };\n-        futures.push(move new_future);\n-        num_chan = Some(move new_chan);\n+        futures.push(new_future);\n+        num_chan = Some(new_chan);\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, option::unwrap(move num_chan), move num_port);\n+    thread_ring(0, msg_per_task, option::unwrap(num_chan), num_port);\n \n     // synchronize\n     for futures.each |f| { f.get() };"}, {"sha": "eaae8370d6b8b5b2957c1005c95c8b117907cf74", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -40,26 +40,26 @@ fn recv(p: &pipe) -> uint {\n \n fn init() -> (pipe,pipe) {\n     let x = arc::RWARC(~[]);\n-    ((&x).clone(), move x)\n+    ((&x).clone(), x)\n }\n \n \n fn thread_ring(i: uint,\n                count: uint,\n                +num_chan: pipe,\n                +num_port: pipe) {\n-    let mut num_chan = move Some(move num_chan);\n-    let mut num_port = move Some(move num_port);\n+    let mut num_chan = Some(num_chan);\n+    let mut num_port = Some(num_port);\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n         //error!(\"task %?, iter %?\", i, j);\n         let mut num_chan2 = option::swap_unwrap(&mut num_chan);\n         let mut num_port2 = option::swap_unwrap(&mut num_port);\n         send(&num_chan2, i * j);\n-        num_chan = Some(move num_chan2);\n+        num_chan = Some(num_chan2);\n         let _n = recv(&num_port2);\n         //log(error, _n);\n-        num_port = Some(move num_port2);\n+        num_port = Some(num_port2);\n     };\n }\n \n@@ -77,7 +77,7 @@ fn main() {\n     let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = init();\n-    let mut num_chan = Some(move num_chan);\n+    let mut num_chan = Some(num_chan);\n \n     let start = time::precise_time_s();\n \n@@ -89,23 +89,22 @@ fn main() {\n         let (new_chan, num_port) = init();\n         let num_chan2 = ~mut None;\n         *num_chan2 <-> num_chan;\n-        let num_port = ~mut Some(move num_port);\n-        let new_future = do future::spawn\n-            |move num_chan2, move num_port| {\n+        let num_port = ~mut Some(num_port);\n+        let new_future = do future::spawn || {\n             let mut num_chan = None;\n             num_chan <-> *num_chan2;\n             let mut num_port1 = None;\n             num_port1 <-> *num_port;\n             thread_ring(i, msg_per_task,\n-                        option::unwrap(move num_chan),\n-                        option::unwrap(move num_port1))\n+                        option::unwrap(num_chan),\n+                        option::unwrap(num_port1))\n         };\n-        futures.push(move new_future);\n-        num_chan = Some(move new_chan);\n+        futures.push(new_future);\n+        num_chan = Some(new_chan);\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, option::unwrap(move num_chan), move num_port);\n+    thread_ring(0, msg_per_task, option::unwrap(num_chan), num_port);\n \n     // synchronize\n     for futures.each |f| { f.get() };"}, {"sha": "39caba9273293ba24bf7f31fdf08a1e9c24515e8", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -35,8 +35,8 @@ fn Noise2DContext() -> ~Noise2DContext {\n     r.shuffle_mut(permutations);\n \n     ~Noise2DContext{\n-        rgradients: move rgradients,\n-        permutations: move permutations,\n+        rgradients: rgradients,\n+        permutations: permutations,\n     }\n }\n "}, {"sha": "11a127b9722f407c2a624cc16e13062883ba7bb6", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -45,36 +45,36 @@ proto! pingpong_unbounded (\n \n // This stuff should go in libcore::pipes\n macro_rules! move_it (\n-    { $x:expr } => { let t = move *ptr::addr_of(&($x)); move t }\n+    { $x:expr } => { let t = *ptr::addr_of(&($x)); t }\n )\n \n macro_rules! follow (\n     {\n         $($message:path($($x: ident),+) -> $next:ident $e:expr)+\n     } => (\n-        |m| match move m {\n-            $(Some($message($($x,)* move next)) => {\n-                let $next = move next;\n-                move $e })+\n+        |m| match m {\n+            $(Some($message($($x,)* next)) => {\n+                let $next = next;\n+                $e })+\n                 _ => { fail!() }\n         }\n     );\n \n     {\n         $($message:path -> $next:ident $e:expr)+\n     } => (\n-        |m| match move m {\n-            $(Some($message(move next)) => {\n-                let $next = move next;\n-                move $e })+\n+        |m| match m {\n+            $(Some($message(next)) => {\n+                let $next = next;\n+                $e })+\n                 _ => { fail!() }\n         }\n     )\n )\n \n fn switch<T: Owned, Tb: Owned, U>(+endp: pipes::RecvPacketBuffered<T, Tb>,\n                       f: fn(+v: Option<T>) -> U) -> U {\n-    f(pipes::try_recv(move endp))\n+    f(pipes::try_recv(endp))\n }\n \n // Here's the benchmark\n@@ -84,10 +84,10 @@ fn bounded(count: uint) {\n \n     let mut ch = do spawn_service(init) |ch| {\n         let mut count = count;\n-        let mut ch = move ch;\n+        let mut ch = ch;\n         while count > 0 {\n-            ch = switch(move ch, follow! (\n-                ping -> next { server::pong(move next) }\n+            ch = switch(ch, follow! (\n+                ping -> next { server::pong(next) }\n             ));\n \n             count -= 1;\n@@ -96,10 +96,10 @@ fn bounded(count: uint) {\n \n     let mut count = count;\n     while count > 0 {\n-        let ch_ = client::ping(move ch);\n+        let ch_ = client::ping(ch);\n \n-        ch = switch(move ch_, follow! (\n-            pong -> next { move next }\n+        ch = switch(ch_, follow! (\n+            pong -> next { next }\n         ));\n \n         count -= 1;\n@@ -111,10 +111,10 @@ fn unbounded(count: uint) {\n \n     let mut ch = do spawn_service(init) |ch| {\n         let mut count = count;\n-        let mut ch = move ch;\n+        let mut ch = ch;\n         while count > 0 {\n-            ch = switch(move ch, follow! (\n-                ping -> next { server::pong(move next) }\n+            ch = switch(ch, follow! (\n+                ping -> next { server::pong(next) }\n             ));\n \n             count -= 1;\n@@ -123,10 +123,10 @@ fn unbounded(count: uint) {\n \n     let mut count = count;\n     while count > 0 {\n-        let ch_ = client::ping(move ch);\n+        let ch_ = client::ping(ch);\n \n-        ch = switch(move ch_, follow! (\n-            pong -> next { move next }\n+        ch = switch(ch_, follow! (\n+            pong -> next { next }\n         ));\n \n         count -= 1;"}, {"sha": "b42ec246ccb975f935c29fc624ac695eaf1e5272", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -156,7 +156,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n             let to_rendezvous_log = to_rendezvous_log.clone();\n             let (from_rendezvous, to_creature) = stream();\n             let from_rendezvous = Cell(from_rendezvous);\n-            do task::spawn |move ii, move col| {\n+            do task::spawn || {\n                 creature(ii, col, from_rendezvous.take(), to_rendezvous.clone(),\n                          to_rendezvous_log.clone());\n             }"}, {"sha": "b1b169752122eca367540453688e876fd3cd84ab", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -128,7 +128,7 @@ fn make_sequence_processor(sz: uint, from_parent: pipes::Port<~[u8]>,\n         _ => { ~\"\" }\n    };\n \n-    to_parent.send(move buffer);\n+    to_parent.send(buffer);\n }\n \n // given a FASTA file on stdin, process sequence THREE\n@@ -149,23 +149,23 @@ fn main() {\n    // initialize each sequence sorter\n    let sizes = ~[1,2,3,4,6,12,18];\n     let streams = vec::map(sizes, |_sz| Some(stream()));\n-    let mut streams = move streams;\n+    let mut streams = streams;\n     let mut from_child = ~[];\n     let to_child   = vec::mapi(sizes, |ii, sz| {\n         let sz = *sz;\n         let mut stream = None;\n         stream <-> streams[ii];\n-        let (from_child_, to_parent_) = option::unwrap(move stream);\n+        let (from_child_, to_parent_) = option::unwrap(stream);\n \n-        from_child.push(move from_child_);\n+        from_child.push(from_child_);\n \n         let (from_parent, to_child) = pipes::stream();\n \n-        do task::spawn_with(move from_parent) |move to_parent_, from_parent| {\n+        do task::spawn_with(from_parent) |from_parent| {\n             make_sequence_processor(sz, from_parent, to_parent_);\n         };\n \n-        move to_child\n+        to_child\n     });\n \n "}, {"sha": "5ab9b068d0b0eae8d1f8ebef742cced9f2248d6b", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -172,7 +172,7 @@ fn main() {\n     let pchan = pipes::SharedChan(pchan);\n     for uint::range(0_u, size) |j| {\n         let cchan = pchan.clone();\n-        do task::spawn |move cchan| { cchan.send(chanmb(j, size)) };\n+        do task::spawn || { cchan.send(chanmb(j, size)) };\n     };\n     writer(path, pport, size);\n }"}, {"sha": "2c9da65cc13accd2f57d41e79d7052d50362b5e1", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -43,15 +43,15 @@ fn fib(n: int) -> int {\n         } else {\n             let p = pipes::PortSet();\n             let ch = p.chan();\n-            task::spawn(|move ch| pfib(ch, n - 1) );\n+            task::spawn(|| pfib(ch, n - 1) );\n             let ch = p.chan();\n-            task::spawn(|move ch| pfib(ch, n - 2) );\n+            task::spawn(|| pfib(ch, n - 2) );\n             c.send(p.recv() + p.recv());\n         }\n     }\n \n     let (p, ch) = pipes::stream();\n-    let _t = task::spawn(|move ch| pfib(ch, n) );\n+    let _t = task::spawn(|| pfib(ch, n) );\n     p.recv()\n }\n \n@@ -86,7 +86,7 @@ fn stress(num_tasks: int) {\n     let mut results = ~[];\n     for range(0, num_tasks) |i| {\n         do task::task().future_result(|+r| {\n-            results.push(move r);\n+            results.push(r);\n         }).spawn {\n             stress_task(i);\n         }"}, {"sha": "b4b02c3aaa8d45c1b195330c21dafa0d80bda600", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -99,6 +99,6 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n           }\n         };\n \n-        recurse_or_fail(depth, Some(move st));\n+        recurse_or_fail(depth, Some(st));\n     }\n }"}, {"sha": "f2441755a7b1dab0f1f78ab72bdf21e9f64cd7b7", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -19,14 +19,14 @@ fn child_generation(gens_left: uint, -c: pipes::Chan<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n-    let c = ~mut Some(move c);\n-    do task::spawn_supervised |move c| {\n+    let c = ~mut Some(c);\n+    do task::spawn_supervised || {\n         let c = option::swap_unwrap(c);\n         if gens_left & 1 == 1 {\n             task::yield(); // shake things up a bit\n         }\n         if gens_left > 0 {\n-            child_generation(gens_left - 1, move c); // recurse\n+            child_generation(gens_left - 1, c); // recurse\n         } else {\n             c.send(())\n         }\n@@ -44,7 +44,7 @@ fn main() {\n     };\n \n     let (p,c) = pipes::stream();\n-    child_generation(uint::from_str(args[1]).get(), move c);\n+    child_generation(uint::from_str(args[1]).get(), c);\n     if p.try_recv().is_none() {\n         fail!(~\"it happened when we slumbered\");\n     }"}, {"sha": "3b6ececaef90a5d9953cc37e1e931eade0a07858", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -46,9 +46,9 @@ fn grandchild_group(num_tasks: uint) {\n \n fn spawn_supervised_blocking(myname: &str, +f: fn~()) {\n     let mut res = None;\n-    task::task().future_result(|+r| res = Some(move r)).supervised().spawn(move f);\n+    task::task().future_result(|+r| res = Some(r)).supervised().spawn(f);\n     error!(\"%s group waiting\", myname);\n-    let x = option::unwrap(move res).recv();\n+    let x = option::unwrap(res).recv();\n     assert x == task::Success;\n }\n "}, {"sha": "e9bc4a5e195d795b740f5777d86d8abd6e359baf", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -18,8 +18,8 @@ impl Drop for X {\n \n fn main() {\n     let x = Some(X { x: () });\n-    match move x {\n-        Some(ref _y @ move _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n+    match x {\n+        Some(ref _y @ _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n         None => fail!()\n     }\n }"}, {"sha": "6548adddf1956aa4651c0e8063bb93603aa3d940", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -18,8 +18,8 @@ impl Drop for X {\n \n fn main() {\n     let x = Some((X { x: () }, X { x: () }));\n-    match move x {\n-        Some((ref _y, move _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n+    match x {\n+        Some((ref _y, _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n         None => fail!()\n     }\n }"}, {"sha": "aaa9d9f920a6aa52777fc9a41e98012d90aa07b1", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -20,8 +20,8 @@ enum double_option<T,U> { some2(T,U), none2 }\n \n fn main() {\n     let x = some2(X { x: () }, X { x: () });\n-    match move x {\n-        some2(ref _y, move _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n+    match x {\n+        some2(ref _y, _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n         none2 => fail!()\n     }\n }"}, {"sha": "b5686b64c810be3391cbf916949fd62c313a2d9d", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -18,8 +18,8 @@ impl Drop for X {\n \n fn main() {\n     let x = Some((X { x: () }, X { x: () }));\n-    match move x {\n-        Some((move _y, ref _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n+    match x {\n+        Some((_y, ref _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n         None => fail!()\n     }\n }"}, {"sha": "40a444df12d368b162f370d26edb7259af85d5fb", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -12,9 +12,9 @@ fn main() {\n     let (p,c) = pipes::stream();\n     let x = Some(p);\n     c.send(false);\n-    match move x {\n-        Some(move z) if z.recv() => { fail!() }, //~ ERROR cannot bind by-move into a pattern guard\n-        Some(move z) => { assert !z.recv(); },\n+    match x {\n+        Some(z) if z.recv() => { fail!() }, //~ ERROR cannot bind by-move into a pattern guard\n+        Some(z) => { assert !z.recv(); },\n         None => fail!()\n     }\n }"}, {"sha": "c8537afa1905e59f5e46232d37087f584e6b138f", "filename": "src/test/compile-fail/bind-by-move-no-lvalues-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-1.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -21,7 +21,7 @@ impl Drop for X {\n fn main() {\n     let x = Some(X { x: () });\n     match x {\n-        Some(move _z) => { }, //~ ERROR cannot bind by-move when matching an lvalue\n+        Some(_z) => { }, //~ ERROR cannot bind by-move when matching an lvalue\n         None => fail!()\n     }\n }"}, {"sha": "26b1084c09172e13df0551c4215051803e282359", "filename": "src/test/compile-fail/bind-by-move-no-lvalues-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-2.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -23,7 +23,7 @@ struct Y { y: Option<X> }\n fn main() {\n     let x = Y { y: Some(X { x: () }) };\n     match x.y {\n-        Some(move _z) => { }, //~ ERROR cannot bind by-move when matching an lvalue\n+        Some(_z) => { }, //~ ERROR cannot bind by-move when matching an lvalue\n         None => fail!()\n     }\n }"}, {"sha": "c86158be5ea7f5a11ffcdeffdcd9a613dc2b0ca6", "filename": "src/test/compile-fail/bind-by-move-no-sub-bindings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -18,8 +18,8 @@ impl Drop for X {\n \n fn main() {\n     let x = Some(X { x: () });\n-    match move x {\n-        Some(move _y @ ref _z) => { }, //~ ERROR cannot bind by-move with sub-bindings\n+    match x {\n+        Some(_y @ ref _z) => { }, //~ ERROR cannot bind by-move with sub-bindings\n         None => fail!()\n     }\n }"}, {"sha": "7b6484fd4aadb649f2c1d11273af65310dd7e288", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -20,6 +20,6 @@ impl Add<foo, foo> for foo {\n \n fn main() {\n     let x = foo(~3);\n-    let _y = x + move x;\n+    let _y = x + x;\n     //~^ ERROR moving out of immutable local variable prohibited due to outstanding loan\n }"}, {"sha": "8f332646bbccde96b333d7c8f8ecb5c908fe40de", "filename": "src/test/compile-fail/borrowck-move-from-unsafe-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn foo(x: *~int) -> ~int {\n-    let y = move *x; //~ ERROR dereference of unsafe pointer requires unsafe function or block\n+    let y = *x; //~ ERROR dereference of unsafe pointer requires unsafe function or block\n     return y;\n }\n "}, {"sha": "cec81d8a6ef5b4c39935f9aefd3a887944e97f92", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -4,7 +4,7 @@ fn a() -> &[int] {\n         [_a, ..tail] => tail,\n         _ => fail!(~\"foo\")\n     };\n-    move tail\n+    tail\n }\n \n fn main() {"}, {"sha": "714a80def9358de21f52a8d8633c88e079919b43", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -4,7 +4,7 @@ fn a() -> &int {\n         [_a, ..tail] => &tail[0],\n         _ => fail!(~\"foo\")\n     };\n-    move tail\n+    tail\n }\n \n fn main() {"}, {"sha": "f1b31d66b3f685b20666288e06e6676a8b028966", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -23,7 +23,7 @@ fn foo(i:int) -> foo {\n }\n \n fn main() {\n-    let x = move foo(10);\n+    let x = foo(10);\n     let _y = copy x;\n     //~^ ERROR copying a value of non-copyable type `foo`\n     log(error, x);"}, {"sha": "951944e24857f6dda47b26e4c6f1d87dcbb60255", "filename": "src/test/compile-fail/issue-2548.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -34,7 +34,7 @@ fn main() {\n         let mut res = foo(x);\n \n         let mut v = ~[];\n-        v = move ~[(move res)] + v; //~ instantiating a type parameter with an incompatible type `foo`, which does not fulfill `Copy`\n+        v = ~[(res)] + v; //~ instantiating a type parameter with an incompatible type `foo`, which does not fulfill `Copy`\n         assert (v.len() == 2);\n     }\n "}, {"sha": "a71826c629b6c89e92e828da298edebe959142c4", "filename": "src/test/compile-fail/issue-3177-mutable-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fissue-3177-mutable-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fissue-3177-mutable-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3177-mutable-struct.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -17,5 +17,5 @@ struct S<T: Const> {\n \n fn main() {\n     let a1  = ~S{ s: true, cant_nest: () };\n-    let _a2 = ~S{ s: move a1, cant_nest: () };\n+    let _a2 = ~S{ s: a1, cant_nest: () };\n }"}, {"sha": "c88dae232fa0615f21711a0fd82597087e543203", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -14,5 +14,5 @@ fn main() {\n     let x = @3u;\n     let _ = fn~() { foo(x); }; //~ ERROR value has non-owned type `@uint`\n     let _ = fn~(copy x) { foo(x); }; //~ ERROR value has non-owned type `@uint`\n-    let _ = fn~(move x) { foo(x); }; //~ ERROR value has non-owned type `@uint`\n+    let _ = fn~() { foo(x); }; //~ ERROR value has non-owned type `@uint`\n }"}, {"sha": "970abf4fd94b06864561298dae9fc9e70437cd2a", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -68,5 +68,5 @@ impl Drop for r {\n \n fn main() {\n     let x = r { x: () };\n-    fn@(move x) { copy x; }; //~ ERROR copying a value of non-copyable type\n+    fn@() { copy x; }; //~ ERROR copying a value of non-copyable type\n }"}, {"sha": "42bad88633cff40315db2266bdc929c2ddb2603f", "filename": "src/test/compile-fail/noncopyable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -37,7 +37,7 @@ fn foo(i:int) -> foo {\n }\n \n fn main() {\n-    let x = move foo(10);\n+    let x = foo(10);\n     let _y = copy x; //~ ERROR copying a value of non-copyable type\n     log(error, x);\n }"}, {"sha": "12eef71f38bb3f07cbe53dc859b73da1e2bcb932", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -17,7 +17,7 @@ impl Drop for r {\n }\n \n fn main() {\n-    let i = move ~r { b: true };\n+    let i = ~r { b: true };\n     let _j = copy i; //~ ERROR copying a value of non-copyable type\n     log(debug, i);\n }"}, {"sha": "d36b53eb2ee719729b6638ef486cc724f0b01c15", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -13,5 +13,5 @@ fn f<T: Owned>(_i: T) {\n \n fn main() {\n     let i = ~@100;\n-    f(move i); //~ ERROR does not fulfill `Owned`\n+    f(i); //~ ERROR does not fulfill `Owned`\n }"}, {"sha": "4ff9dd6f9914ef0ea2d2b6a22706c0f02e3c90a3", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -24,8 +24,8 @@ fn f<T>(+_i: ~[T], +_j: ~[T]) {\n fn main() {\n     let i1 = @mut 0;\n     let i2 = @mut 1;\n-    let r1 = move ~[~r { i: i1 }];\n-    let r2 = move ~[~r { i: i2 }];\n+    let r1 = ~[~r { i: i1 }];\n+    let r2 = ~[~r { i: i2 }];\n     f(copy r1, copy r2);\n     //~^ ERROR copying a value of non-copyable type\n     //~^^ ERROR copying a value of non-copyable type"}, {"sha": "8e9ce5f97fc1da0ecc59c3c1026118c051f6f0d1", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -26,5 +26,5 @@ fn foo(i:int, j: @~str) -> foo {\n fn main() {\n   let cat = ~\"kitty\";\n     let (_, ch) = pipes::stream(); //~ ERROR does not fulfill `Owned`\n-  ch.send(foo(42, @(move cat))); //~ ERROR does not fulfill `Owned`\n+  ch.send(foo(42, @(cat))); //~ ERROR does not fulfill `Owned`\n }"}, {"sha": "b06f91d50f25cf0ba24720fa07d56b680f441dc5", "filename": "src/test/compile-fail/vec-res-add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -22,8 +22,8 @@ impl Drop for r {\n \n fn main() {\n     // This can't make sense as it would copy the classes\n-    let i = move ~[r(0)];\n-    let j = move ~[r(1)];\n+    let i = ~[r(0)];\n+    let j = ~[r(1)];\n     let k = i + j;\n     log(debug, j);\n }"}, {"sha": "9dcdaacb3c1a43c824d29532a480da3d67ddc0f2", "filename": "src/test/run-fail/out-of-stack-managed-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Fout-of-stack-managed-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Fout-of-stack-managed-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fout-of-stack-managed-box.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -15,11 +15,11 @@\n \n // error-pattern:ran out of stack\n fn main() {\n-    eat(move @0);\n+    eat(@0);\n }\n \n fn eat(\n     +a: @int\n ) {\n-    eat(move a)\n+    eat(a)\n }"}, {"sha": "d4bc70f43ef6e768ffb960729221ce5e8d95444c", "filename": "src/test/run-fail/out-of-stack-owned-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Fout-of-stack-owned-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Fout-of-stack-owned-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fout-of-stack-owned-box.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,11 +11,11 @@\n // xfail-test\n // error-pattern:ran out of stack\n fn main() {\n-    eat(move ~0);\n+    eat(~0);\n }\n \n fn eat(\n     +a: ~int\n ) {\n-    eat(move a)\n+    eat(a)\n }"}, {"sha": "ba8f2fa37cb3b86338f18bd36d201aa4c98c4bc3", "filename": "src/test/run-fail/unwind-box-res.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-res.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -36,7 +36,7 @@ fn main() {\n     unsafe {\n         let i1 = ~0;\n         let i1p = cast::reinterpret_cast(&i1);\n-        cast::forget(move i1);\n+        cast::forget(i1);\n         let x = @r(i1p);\n         failfn();\n         log(error, x);"}, {"sha": "6d52046b3e2fe8dcbb9b9edd2eb41a42782aa303", "filename": "src/test/run-fail/unwind-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Funwind-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Funwind-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-closure.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -16,6 +16,6 @@ fn f(a: @int) {\n \n fn main() {\n     let b = @0;\n-    let g : fn@() = |move b|f(b);\n+    let g : fn@() = || f(b);\n     g();\n }"}, {"sha": "b2d30688ec55db08be40bc046714288d5bf8d38c", "filename": "src/test/run-fail/unwind-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Funwind-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Funwind-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-move.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -15,5 +15,5 @@ fn f(-_a: @int) {\n \n fn main() {\n     let a = @0;\n-    f(move a);\n+    f(a);\n }"}, {"sha": "0d57e9279bc72bbc313e42efb80fab6436bfe5d1", "filename": "src/test/run-fail/unwind-resource-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Funwind-resource-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Funwind-resource-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-resource-fail.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -19,5 +19,5 @@ fn r(i: int) -> r { r { i: i } }\n \n fn main() {\n     @0;\n-    let r = move r(0);\n+    let r = r(0);\n }"}, {"sha": "0b33326abe7190bee5728d953acf3fc0a1e6773e", "filename": "src/test/run-fail/unwind-resource-fail2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Funwind-resource-fail2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-fail%2Funwind-resource-fail2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-resource-fail2.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -20,6 +20,6 @@ fn r(i: int) -> r { r { i: i } }\n \n fn main() {\n     @0;\n-    let r = move r(0);\n+    let r = r(0);\n     fail!();\n }"}, {"sha": "4474aec3d2e503be58632a711f8e4eb145080329", "filename": "src/test/run-pass/alt-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     let x = Some(private::exclusive(true));\n-    match move x {\n+    match x {\n         Some(ref z) if z.with(|b| *b) => {\n             do z.with |b| { assert *b; }\n         },"}, {"sha": "ba9266b8a30f2c4963622b4b88b176930556dc04", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -24,7 +24,7 @@ fn f2(a: int, f: fn(int)) -> int { f(1); return a; }\n \n pub fn main() {\n     let mut a = X {mut x: 1}, b = 2, c = 3;\n-    assert (f1(a, &mut b, move c) == 6);\n+    assert (f1(a, &mut b, c) == 6);\n     assert (a.x == 0);\n     assert (b == 10);\n     assert (f2(a.x, |x| a.x = 50 ) == 0);"}, {"sha": "d4171ceb70fd2a9ab69fb35e1793f71df9d399c5", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -46,7 +46,7 @@ fn test_ebml<A:\n         let ebml_w = &EBWriter::Encoder(wr);\n         a1.encode(ebml_w)\n     };\n-    let d = EBReader::Doc(@move bytes);\n+    let d = EBReader::Doc(@bytes);\n     let a2: A = Decodable::decode(&EBReader::Decoder(d));\n     assert *a1 == a2;\n }"}, {"sha": "87f70d00f8c9f24b97476be0048ab99b94412b29", "filename": "src/test/run-pass/auto-ref-sliceable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -14,7 +14,7 @@ trait Pushable<T> {\n \n impl<T> Pushable<T> for ~[T] {\n     fn push_val(&mut self, +t: T) {\n-        self.push(move t);\n+        self.push(t);\n     }\n }\n "}, {"sha": "1e836740f8e81d244de611d0ea692f07287af956", "filename": "src/test/run-pass/bind-by-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fbind-by-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fbind-by-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-by-move.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -17,8 +17,8 @@ fn dispose(+_x: arc::ARC<bool>) unsafe { }\n pub fn main() {\n     let p = arc::arc(true);\n     let x = Some(p);\n-    match move x {\n-        Some(move z) => { dispose(z); },\n+    match x {\n+        Some(z) => { dispose(z); },\n         None => fail!()\n     }\n }"}, {"sha": "2d83e9746b580951f258bc2625405315e8a3ced8", "filename": "src/test/run-pass/borrowck-move-from-unsafe-ptr-ok.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -12,7 +12,7 @@\n \n fn bar(x: *~int) -> ~int {\n     unsafe {\n-        let y = move *x;\n+        let y = *x;\n         return y;\n     }\n }"}, {"sha": "e27434400c1851d1faf2347ae5f83ad33d52b246", "filename": "src/test/run-pass/cap-clause-move.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,21 +11,21 @@\n pub fn main() {\n     let x = ~1;\n     let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_move = fn@(move x) -> uint { ptr::addr_of(&(*x)) as uint };\n+    let lam_move = fn@() -> uint { ptr::addr_of(&(*x)) as uint };\n     assert lam_move() == y;\n \n     let x = ~2;\n     let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_move: fn@() -> uint = |move x| ptr::addr_of(&(*x)) as uint;\n+    let lam_move: fn@() -> uint = || ptr::addr_of(&(*x)) as uint;\n     assert lam_move() == y;\n \n     let x = ~3;\n     let y = ptr::addr_of(&(*x)) as uint;\n-    let snd_move = fn~(move x) -> uint { ptr::addr_of(&(*x)) as uint };\n+    let snd_move = fn~() -> uint { ptr::addr_of(&(*x)) as uint };\n     assert snd_move() == y;\n \n     let x = ~4;\n     let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_move: fn~() -> uint = |move x| ptr::addr_of(&(*x)) as uint;\n+    let lam_move: fn~() -> uint = || ptr::addr_of(&(*x)) as uint;\n     assert lam_move() == y;\n }"}, {"sha": "5ef5e55b7293eac539af2a4a53e142b7943a82a8", "filename": "src/test/run-pass/class-poly-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -26,7 +26,7 @@ fn cat<U>(in_x : uint, in_y : int, -in_info: ~[U]) -> cat<U> {\n     cat {\n         meows: in_x,\n         how_hungry: in_y,\n-        info: move in_info\n+        info: in_info\n     }\n }\n "}, {"sha": "cb8b1c5f25f270675fbc61f054d9c31758bba374", "filename": "src/test/run-pass/dvec-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdvec-test.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -31,6 +31,6 @@ pub fn main() {\n         assert *e == exp[i];\n     }\n \n-    let v = dvec::unwrap(move d);\n+    let v = dvec::unwrap(d);\n     assert v == exp;\n }"}, {"sha": "c875b805ea3ca9e185e11c9b57b7c95c90aeca74", "filename": "src/test/run-pass/fn-bare-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,7 +11,7 @@\n // This is what the signature to spawn should look like with bare functions\n \n fn spawn<T: Owned>(val: T, f: extern fn(T)) {\n-    f(move val);\n+    f(val);\n }\n \n fn f(+i: int) {"}, {"sha": "6a12704d4b4b52d62017cc27ec50c5ac2a528ce9", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -39,7 +39,7 @@ mod map_reduce {\n         for inputs.each |i| {\n             let ctrl = ctrl.clone();\n             let i = copy *i;\n-            task::spawn(|move i| map_task(ctrl.clone(), copy i) );\n+            task::spawn(|| map_task(ctrl.clone(), copy i) );\n         }\n     }\n "}, {"sha": "0185b19b481771d3941b957605db1771a10395c6", "filename": "src/test/run-pass/init-res-into-things.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Finit-res-into-things.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Finit-res-into-things.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finit-res-into-things.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -32,15 +32,15 @@ fn r(i: @mut int) -> r {\n fn test_box() {\n     let i = @mut 0;\n     {\n-        let a = move @r(i);\n+        let a = @r(i);\n     }\n     assert *i == 1;\n }\n \n fn test_rec() {\n     let i = @mut 0;\n     {\n-        let a = move Box {x: r(i)};\n+        let a = Box {x: r(i)};\n     }\n     assert *i == 1;\n }\n@@ -52,31 +52,31 @@ fn test_tag() {\n \n     let i = @mut 0;\n     {\n-        let a = move t0(r(i));\n+        let a = t0(r(i));\n     }\n     assert *i == 1;\n }\n \n fn test_tup() {\n     let i = @mut 0;\n     {\n-        let a = move (r(i), 0);\n+        let a = (r(i), 0);\n     }\n     assert *i == 1;\n }\n \n fn test_unique() {\n     let i = @mut 0;\n     {\n-        let a = move ~r(i);\n+        let a = ~r(i);\n     }\n     assert *i == 1;\n }\n \n fn test_box_rec() {\n     let i = @mut 0;\n     {\n-        let a = move @Box {\n+        let a = @Box {\n             x: r(i)\n         };\n     }"}, {"sha": "9e8e9d8bc15be1998a915122b8a587df63047aae", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -18,7 +18,7 @@ pub fn main() {\n     unsafe {\n         let mut x = @1;\n         let mut y = @2;\n-        rusti::move_val(&mut y, move x);\n+        rusti::move_val(&mut y, x);\n         assert *y == 1;\n     }\n }"}, {"sha": "42c6ae38b6afbf7c22461b454cf7f279b0ceeca5", "filename": "src/test/run-pass/issue-1895.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-1895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-1895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1895.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n   let x = 1;\n-  let y = fn@(move x) -> int {\n+  let y = fn@() -> int {\n              x\n           }();\n }"}, {"sha": "f3f7f4dacbad4acc5db73f87d5b5b690de68e0ee", "filename": "src/test/run-pass/issue-2185.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2185.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -35,11 +35,11 @@ fn filter<A,IA:iterable<A>>(self: IA, prd: fn@(A) -> bool, blk: fn(A)) {\n }\n \n fn foldl<A,B,IA:iterable<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n-    let mut b = move b0;\n+    let mut b = b0;\n     do self.iter |a| {\n-        b = move blk(b, a);\n+        b = blk(b, a);\n     }\n-    move b\n+    b\n }\n \n fn range(lo: uint, hi: uint, it: fn(uint)) {"}, {"sha": "ba7cf0cc45fbca97342a7262c40f2e52ea3ab836", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -61,39 +61,39 @@ pub mod pipes {\n     // We should consider moving this to ::core::unsafe, although I\n     // suspect graydon would want us to use void pointers instead.\n     pub unsafe fn uniquify<T>(+x: *T) -> ~T {\n-        unsafe { cast::transmute(move x) }\n+        unsafe { cast::transmute(x) }\n     }\n \n     pub fn swap_state_acq(+dst: &mut state, src: state) -> state {\n         unsafe {\n-            transmute(rusti::atomic_xchg_acq(transmute(move dst), src as int))\n+            transmute(rusti::atomic_xchg_acq(transmute(dst), src as int))\n         }\n     }\n \n     pub fn swap_state_rel(+dst: &mut state, src: state) -> state {\n         unsafe {\n-            transmute(rusti::atomic_xchg_rel(transmute(move dst), src as int))\n+            transmute(rusti::atomic_xchg_rel(transmute(dst), src as int))\n         }\n     }\n \n     pub fn send<T: Owned>(-p: send_packet<T>, -payload: T) {\n         let p = p.unwrap();\n         let p = unsafe { uniquify(p) };\n         assert (*p).payload.is_none();\n-        (*p).payload = move Some(move payload);\n+        (*p).payload = Some(payload);\n         let old_state = swap_state_rel(&mut (*p).state, full);\n         match old_state {\n           empty => {\n             // Yay, fastpath.\n \n             // The receiver will eventually clean this up.\n-            unsafe { forget(move p); }\n+            unsafe { forget(p); }\n           }\n           full => { fail!(~\"duplicate send\") }\n           blocked => {\n \n             // The receiver will eventually clean this up.\n-            unsafe { forget(move p); }\n+            unsafe { forget(p); }\n           }\n           terminated => {\n             // The receiver will never receive this. Rely on drop_glue\n@@ -113,7 +113,7 @@ pub mod pipes {\n               full => {\n                 let mut payload = None;\n                 payload <-> (*p).payload;\n-                return Some(option::unwrap(move payload))\n+                return Some(option::unwrap(payload))\n               }\n               terminated => {\n                 assert old_state == terminated;\n@@ -128,7 +128,7 @@ pub mod pipes {\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty | blocked => {\n             // The receiver will eventually clean up.\n-            unsafe { forget(move p) }\n+            unsafe { forget(p) }\n           }\n           full => {\n             // This is impossible\n@@ -145,7 +145,7 @@ pub mod pipes {\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty => {\n             // the sender will clean up\n-            unsafe { forget(move p) }\n+            unsafe { forget(p) }\n           }\n           blocked => {\n             // this shouldn't happen.\n@@ -166,7 +166,7 @@ pub mod pipes {\n             if self.p != None {\n                 let mut p = None;\n                 p <-> self.p;\n-                sender_terminate(option::unwrap(move p))\n+                sender_terminate(option::unwrap(p))\n             }\n         }\n     }\n@@ -175,7 +175,7 @@ pub mod pipes {\n         fn unwrap() -> *packet<T> {\n             let mut p = None;\n             p <-> self.p;\n-            option::unwrap(move p)\n+            option::unwrap(p)\n         }\n     }\n \n@@ -194,7 +194,7 @@ pub mod pipes {\n             if self.p != None {\n                 let mut p = None;\n                 p <-> self.p;\n-                receiver_terminate(option::unwrap(move p))\n+                receiver_terminate(option::unwrap(p))\n             }\n         }\n     }\n@@ -203,7 +203,7 @@ pub mod pipes {\n         fn unwrap() -> *packet<T> {\n             let mut p = None;\n             p <-> self.p;\n-            option::unwrap(move p)\n+            option::unwrap(p)\n         }\n     }\n \n@@ -231,9 +231,9 @@ pub mod pingpong {\n             let addr : *::pipes::send_packet<pong> = match &p {\n               &ping(ref x) => { cast::transmute(ptr::addr_of(x)) }\n             };\n-            let liberated_value = move *addr;\n-            cast::forget(move p);\n-            move liberated_value\n+            let liberated_value = *addr;\n+            cast::forget(p);\n+            liberated_value\n         }\n     }\n \n@@ -242,9 +242,9 @@ pub mod pingpong {\n             let addr : *::pipes::send_packet<ping> = match &p {\n               &pong(ref x) => { cast::transmute(ptr::addr_of(x)) }\n             };\n-            let liberated_value = move *addr;\n-            cast::forget(move p);\n-            move liberated_value\n+            let liberated_value = *addr;\n+            cast::forget(p);\n+            liberated_value\n         }\n     }\n \n@@ -262,16 +262,16 @@ pub mod pingpong {\n         pub fn do_ping(-c: ping) -> pong {\n             let (sp, rp) = ::pipes::entangle();\n \n-            ::pipes::send(move c, pingpong::ping(move sp));\n-            move rp\n+            ::pipes::send(c, pingpong::ping(sp));\n+            rp\n         }\n \n         pub fn do_pong(-c: pong) -> (ping, ()) {\n-            let packet = ::pipes::recv(move c);\n+            let packet = ::pipes::recv(c);\n             if packet.is_none() {\n                 fail!(~\"sender closed the connection\")\n             }\n-            (pingpong::liberate_pong(option::unwrap(move packet)), ())\n+            (pingpong::liberate_pong(option::unwrap(packet)), ())\n         }\n     }\n \n@@ -282,32 +282,32 @@ pub mod pingpong {\n         pub type pong = ::pipes::send_packet<pingpong::pong>;\n \n         pub fn do_ping(-c: ping) -> (pong, ()) {\n-            let packet = ::pipes::recv(move c);\n+            let packet = ::pipes::recv(c);\n             if packet.is_none() {\n                 fail!(~\"sender closed the connection\")\n             }\n-            (pingpong::liberate_ping(option::unwrap(move packet)), ())\n+            (pingpong::liberate_ping(option::unwrap(packet)), ())\n         }\n \n         pub fn do_pong(-c: pong) -> ping {\n             let (sp, rp) = ::pipes::entangle();\n-            ::pipes::send(move c, pingpong::pong(move sp));\n-            move rp\n+            ::pipes::send(c, pingpong::pong(sp));\n+            rp\n         }\n     }\n }\n \n fn client(-chan: pingpong::client::ping) {\n-    let chan = pingpong::client::do_ping(move chan);\n+    let chan = pingpong::client::do_ping(chan);\n     log(error, ~\"Sent ping\");\n-    let (_chan, _data) = pingpong::client::do_pong(move chan);\n+    let (_chan, _data) = pingpong::client::do_pong(chan);\n     log(error, ~\"Received pong\");\n }\n \n fn server(-chan: pingpong::server::ping) {\n-    let (chan, _data) = pingpong::server::do_ping(move chan);\n+    let (chan, _data) = pingpong::server::do_ping(chan);\n     log(error, ~\"Received ping\");\n-    let _chan = pingpong::server::do_pong(move chan);\n+    let _chan = pingpong::server::do_pong(chan);\n     log(error, ~\"Sent pong\");\n }\n \n@@ -319,12 +319,12 @@ pub fn main() {\n     let client_ = ~mut Some(client_);\n     let server_ = ~mut Some(server_);\n \n-    task::spawn {|move client_|\n+    task::spawn {|client_|\n         let mut client__ = none;\n         *client_ <-> client__;\n         client(option::unwrap(client__));\n     };\n-    task::spawn {|move server_|\n+    task::spawn {|server_|\n         let mut server_\u02ca = none;\n         *server_ <-> server_\u02ca;\n         server(option::unwrap(server_\u02ca));"}, {"sha": "84e0f20e61b11eb40e44005c2fb4250d3e1c3576", "filename": "src/test/run-pass/issue-2834.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-2834.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-2834.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2834.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -19,7 +19,7 @@ proto! streamp (\n \n fn rendezvous() {\n     let (c, s) = streamp::init();\n-    let streams: ~[streamp::client::open<int>] = ~[move c];\n+    let streams: ~[streamp::client::open<int>] = ~[c];\n \n     error!(\"%?\", streams[0]);\n }"}, {"sha": "9a726bedbc340939326ec0b56ad03d996cf48983", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -60,7 +60,7 @@ fn square_from_char(c: char) -> square {\n }\n \n fn read_board_grid<rdr: &static io::Reader>(+in: rdr) -> ~[~[square]] {\n-    let in = (move in) as io::Reader;\n+    let in = (in) as io::Reader;\n     let mut grid = ~[];\n     for in.each_line |line| {\n         let mut row = ~[];"}, {"sha": "6d22a2ea5edcf26737ee4a0c84bd17d5508b3e0b", "filename": "src/test/run-pass/issue-2930.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2930.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -17,5 +17,5 @@ proto! stream (\n pub fn main() {\n     let (bc, _bp) = stream::init();\n \n-    stream::client::send(move bc, ~\"abc\");\n+    stream::client::send(bc, ~\"abc\");\n }"}, {"sha": "d40bf6e32cf87a7aa2f682c0f3b09c8707c8529c", "filename": "src/test/run-pass/issue-3168.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-3168.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-3168.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3168.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -12,15 +12,15 @@\n \n pub fn main() {\n     let (p,c) = pipes::stream();\n-    do task::try |move c| {\n+    do task::try || {\n         let (p2,c2) = pipes::stream();\n-        do task::spawn |move p2| {\n+        do task::spawn || {\n             p2.recv();\n             error!(\"sibling fails\");\n             fail!();\n         }   \n         let (p3,c3) = pipes::stream();\n-        c.send(move c3);\n+        c.send(c3);\n         c2.send(());\n         error!(\"child blocks\");\n         p3.recv();"}, {"sha": "fac73d07b6642188bbffd4637b49cfa526754958", "filename": "src/test/run-pass/issue-3176.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3176.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -14,19 +14,19 @@ use pipes::{Select2, Selectable};\n \n pub fn main() {\n     let (p,c) = pipes::stream();\n-    do task::try |move c| {\n+    do task::try || {\n         let (p2,c2) = pipes::stream();\n-        do task::spawn |move p2| {\n+        do task::spawn || {\n             p2.recv();\n             error!(\"sibling fails\");\n             fail!();\n         }   \n         let (p3,c3) = pipes::stream();\n-        c.send(move c3);\n+        c.send(c3);\n         c2.send(());\n         error!(\"child blocks\");\n         let (p, c) = pipes::stream();\n-        (move p, move p3).select();\n+        (p, p3).select();\n         c.send(());\n     };  \n     error!(\"parent tries\");"}, {"sha": "ef65531e5546f51ce986d3cd3915ec5374082122", "filename": "src/test/run-pass/issue-3220.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-3220.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-3220.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3220.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -23,5 +23,5 @@ impl thing { fn f(self) {} }\n \n pub fn main() {\n     let z = thing();\n-    (move z).f();\n+    (z).f();\n }"}, {"sha": "0bcc5983eb719590cc49a84064e626d819cba37a", "filename": "src/test/run-pass/issue-3447.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-3447.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-3447.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3447.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -20,7 +20,7 @@ impl<T> list<T>{\n             next: option::None\n         };\n \n-        self.next = Some(@(move newList));\n+        self.next = Some(@(newList));\n     }\n }\n "}, {"sha": "a5791e3834351bdbcdc1994f6c88802582dd8e20", "filename": "src/test/run-pass/issue-3878.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-3878.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-3878.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3878.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,5 +11,5 @@\n pub fn main()\n {\n     let y = ~1;\n-    move y;\n+    y;\n }"}, {"sha": "307d7974762f733ac9d923454507b420d931f5a2", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -20,7 +20,7 @@ trait JD : Deserializable<json::Deserializer> { }\n \n fn exec<T: JD>() {\n     let doc = result::unwrap(json::from_str(\"\"));\n-    let _v: T = deserialize(&json::Deserializer(move doc));\n+    let _v: T = deserialize(&json::Deserializer(doc));\n     fail!()\n }\n "}, {"sha": "e8083dd3f6b215339d407f6ca293ec65a0017c0f", "filename": "src/test/run-pass/last-use-in-block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -13,14 +13,14 @@\n fn lp<T>(s: ~str, f: fn(~str) -> T) -> T {\n     while false {\n         let r = f(s);\n-        return (move r);\n+        return (r);\n     }\n     fail!();\n }\n \n fn apply<T>(s: ~str, f: fn(~str) -> T) -> T {\n     fn g<T>(s: ~str, f: fn(~str) -> T) -> T {f(s)}\n-    g(s, |v| { let r = f(v); move r })\n+    g(s, |v| { let r = f(v); r })\n }\n \n pub fn main() {}"}, {"sha": "2fd2cc9d22b8125cc4df4c0b5b895e6899fddb2e", "filename": "src/test/run-pass/last-use-in-cap-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -15,7 +15,7 @@ struct A { a: ~int }\n fn foo() -> fn@() -> int {\n     let k = ~22;\n     let _u = A {a: copy k};\n-    return fn@(move k) -> int { 22 };\n+    return fn@() -> int { 22 };\n }\n \n pub fn main() {"}, {"sha": "8c4b7d57bc201df3ae8463e259ccab8c5fc3f3b9", "filename": "src/test/run-pass/liveness-move-in-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -15,7 +15,7 @@ fn the_loop() {\n     loop {\n         let x = 5;\n         if x > 3 {\n-            list += ~[take(move x)];\n+            list += ~[take(x)];\n         } else {\n             break;\n         }"}, {"sha": "152dcb3d4a7a7efc3fe2e3edc0da44ec676fcb3d", "filename": "src/test/run-pass/log-linearized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Flog-linearized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Flog-linearized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-linearized.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -21,7 +21,7 @@ struct V<T> { v: ~[option<T>] }\n \n fn mk<T>() -> @Smallintmap<T> {\n     let mut v: ~[option<T>] = ~[];\n-    return @Smallintmap {mut v: move v};\n+    return @Smallintmap {mut v: v};\n }\n \n fn f<T,U>() {"}, {"sha": "b5af07207bccd2325f36732957af163aa014f2b1", "filename": "src/test/run-pass/monomorphized-callees-with-ty-params-3314.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -25,7 +25,7 @@ struct F<A> { a: A }\n \n impl<A: Copy Serializable> Serializable for F<A> {\n     fn serialize<S: Serializer>(s: S) {\n-        self.a.serialize(move s);\n+        self.a.serialize(s);\n     }\n }\n "}, {"sha": "45ba5eb97481176fc70584ec375b46ed26229e85", "filename": "src/test/run-pass/move-1-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-1-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-1-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-1-unique.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -13,7 +13,7 @@ struct Triple { x: int, y: int, z: int }\n fn test(x: bool, foo: ~Triple) -> int {\n     let bar = foo;\n     let mut y: ~Triple;\n-    if x { y = move bar; } else { y = ~Triple{x: 4, y: 5, z: 6}; }\n+    if x { y = bar; } else { y = ~Triple{x: 4, y: 5, z: 6}; }\n     return y.y;\n }\n "}, {"sha": "35cbe6e080cc814175a3ea37d6c09dd7768e051f", "filename": "src/test/run-pass/move-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-1.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -13,7 +13,7 @@ struct Triple { x: int, y: int, z: int }\n fn test(x: bool, foo: @Triple) -> int {\n     let bar = foo;\n     let mut y: @Triple;\n-    if x { y = move bar; } else { y = @Triple{x: 4, y: 5, z: 6}; }\n+    if x { y = bar; } else { y = @Triple{x: 4, y: 5, z: 6}; }\n     return y.y;\n }\n "}, {"sha": "bc3b5405f1867a92c7239bdded37984adab189be", "filename": "src/test/run-pass/move-2-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-2-unique.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,4 +11,4 @@\n \n struct X { x: int, y: int, z: int }\n \n-pub fn main() { let x = ~X{x: 1, y: 2, z: 3}; let y = move x; assert (y.y == 2); }\n+pub fn main() { let x = ~X{x: 1, y: 2, z: 3}; let y = x; assert (y.y == 2); }"}, {"sha": "23ec3a178c15a5acd52f6048e1628b392369f879", "filename": "src/test/run-pass/move-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-2.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,4 +11,4 @@\n \n struct X { x: int, y: int, z: int }\n \n-pub fn main() { let x = @X {x: 1, y: 2, z: 3}; let y = move x; assert (y.y == 2); }\n+pub fn main() { let x = @X {x: 1, y: 2, z: 3}; let y = x; assert (y.y == 2); }"}, {"sha": "82b8d2c96092197a12c0bd73d34c69de674dc83b", "filename": "src/test/run-pass/move-3-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -15,7 +15,7 @@ struct Triple { x: int, y: int, z: int }\n fn test(x: bool, foo: ~Triple) -> int {\n     let bar = foo;\n     let mut y: ~Triple;\n-    if x { y = move bar; } else { y = ~Triple {x: 4, y: 5, z: 6}; }\n+    if x { y = bar; } else { y = ~Triple {x: 4, y: 5, z: 6}; }\n     return y.y;\n }\n "}, {"sha": "161dc55f8a34b34ae2c5d1fbcc1a8ec2458d01a7", "filename": "src/test/run-pass/move-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-3.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -15,7 +15,7 @@ struct Triple { x: int, y: int, z: int }\n fn test(x: bool, foo: @Triple) -> int {\n     let bar = foo;\n     let mut y: @Triple;\n-    if x { y = move bar; } else { y = @Triple{x: 4, y: 5, z: 6}; }\n+    if x { y = bar; } else { y = @Triple{x: 4, y: 5, z: 6}; }\n     return y.y;\n }\n "}, {"sha": "8845bdfffe146bfd09c1e87d0754de6fa95d7cbc", "filename": "src/test/run-pass/move-4-unique.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-4-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-4-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-4-unique.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -14,9 +14,9 @@ struct Triple {a: int, b: int, c: int}\n \n fn test(foo: ~Triple) -> ~Triple {\n     let foo = foo;\n-    let bar = move foo;\n-    let baz = move bar;\n-    let quux = move baz;\n+    let bar = foo;\n+    let baz = bar;\n+    let quux = baz;\n     return quux;\n }\n "}, {"sha": "1a5432620d3088a44a4065c72366190477c60eb8", "filename": "src/test/run-pass/move-4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-4.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -15,9 +15,9 @@ struct Triple { a: int, b: int, c: int }\n \n fn test(foo: @Triple) -> @Triple {\n     let foo = foo;\n-    let bar = move foo;\n-    let baz = move bar;\n-    let quux = move baz;\n+    let bar = foo;\n+    let baz = bar;\n+    let quux = baz;\n     return quux;\n }\n "}, {"sha": "21969418c3451769bf0df414be71d12dfd289c3d", "filename": "src/test/run-pass/move-arg-2-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -13,7 +13,7 @@ fn test(-foo: ~~[int]) { assert (foo[0] == 10); }\n pub fn main() {\n     let x = ~~[10];\n     // Test forgetting a local by move-in\n-    test(move x);\n+    test(x);\n \n     // Test forgetting a temporary by move-in.\n     test(~~[10]);"}, {"sha": "8c843d2da682feb2816dd1c706232096390bf12b", "filename": "src/test/run-pass/move-arg-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -13,7 +13,7 @@ fn test(-foo: @~[int]) { assert (foo[0] == 10); }\n pub fn main() {\n     let x = @~[10];\n     // Test forgetting a local by move-in\n-    test(move x);\n+    test(x);\n \n     // Test forgetting a temporary by move-in.\n     test(@~[10]);"}, {"sha": "570fa6ee39166651267720e6ec82425fad68c758", "filename": "src/test/run-pass/move-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -10,4 +10,4 @@\n \n fn test(-foo: int) { assert (foo == 10); }\n \n-pub fn main() { let x = 10; test(move x); }\n+pub fn main() { let x = 10; test(x); }"}, {"sha": "0114eeefbfb2d8da7b34bde238179534a7191351", "filename": "src/test/run-pass/move-nullary-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-nullary-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-nullary-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-nullary-fn.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -12,7 +12,7 @@\n fn f2(-thing: fn@()) { }\n \n fn f(-thing: fn@()) {\n-    f2(move thing);\n+    f2(thing);\n }\n \n pub fn main() {"}, {"sha": "a7ddc4e4cdbe2032eba4e1ad4c9a87f0cb417ba5", "filename": "src/test/run-pass/move-scalar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-scalar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-scalar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-scalar.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -12,6 +12,6 @@ pub fn main() {\n \n     let y: int = 42;\n     let mut x: int;\n-    x = move y;\n+    x = y;\n     assert (x == 42);\n }"}, {"sha": "37ce1bce9e65973858b295af5bbd4bf6fc851137", "filename": "src/test/run-pass/move-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fmove-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-self.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -4,7 +4,7 @@ struct S {\n \n impl S {\n     fn foo(self) {\n-        (move self).bar();\n+        self.bar();\n     }\n \n     fn bar(self) {"}, {"sha": "2a1f94a1d8cdf61b4f55524d666ed1d682e3e70f", "filename": "src/test/run-pass/non-legacy-modes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fnon-legacy-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fnon-legacy-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-legacy-modes.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -13,7 +13,7 @@ struct X {\n }\n \n fn apply<T>(x: T, f: fn(T)) {\n-    f(move x);\n+    f(x);\n }\n \n fn check_int(x: int) {"}, {"sha": "7616ff5007eee8d0f24f2d9b1b153a4fd30a42cc", "filename": "src/test/run-pass/option-unwrap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Foption-unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Foption-unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption-unwrap.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -21,8 +21,8 @@ impl Drop for dtor {\n }\n \n fn unwrap<T>(+o: Option<T>) -> T {\n-    match move o {\n-      Some(move v) => move v,\n+    match o {\n+      Some(v) => v,\n       None => fail!()\n     }\n }\n@@ -32,7 +32,7 @@ pub fn main() {\n \n     {\n         let b = Some(dtor { x:x });\n-        let c = unwrap(move b);\n+        let c = unwrap(b);\n     }\n \n     assert *x == 0;"}, {"sha": "bc218e71ede9b690b62f1e4a228c20562a9fb143", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -44,21 +44,21 @@ proto! bank (\n )\n \n macro_rules! move_it (\n-    { $x:expr } => { unsafe { let y = move *ptr::addr_of(&($x)); move y } }\n+    { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n )\n \n fn switch<T: Owned, U>(+endp: pipes::RecvPacket<T>,\n                       f: fn(+v: Option<T>) -> U) -> U {\n-    f(pipes::try_recv(move endp))\n+    f(pipes::try_recv(endp))\n }\n \n-fn move_it<T>(-x: T) -> T { move x }\n+fn move_it<T>(-x: T) -> T { x }\n \n macro_rules! follow (\n     {\n         $($message:path$(($($x: ident),+))||* -> $next:ident $e:expr)+\n     } => (\n-        |m| match move m {\n+        |m| match m {\n           $(Some($message($($($x,)+)* next)) => {\n             let $next = move_it!(next);\n             $e })+\n@@ -70,15 +70,15 @@ macro_rules! follow (\n fn client_follow(+bank: bank::client::login) {\n     use bank::*;\n \n-    let bank = client::login(move bank, ~\"theincredibleholk\", ~\"1234\");\n-    let bank = switch(move bank, follow! (\n-        ok -> connected { move connected }\n+    let bank = client::login(bank, ~\"theincredibleholk\", ~\"1234\");\n+    let bank = switch(bank, follow! (\n+        ok -> connected { connected }\n         invalid -> _next { fail!(~\"bank closed the connected\") }\n     ));\n \n-    let bank = client::deposit(move bank, 100.00);\n-    let bank = client::withdrawal(move bank, 50.00);\n-    switch(move bank, follow! (\n+    let bank = client::deposit(bank, 100.00);\n+    let bank = client::withdrawal(bank, 50.00);\n+    switch(bank, follow! (\n         money(m) -> _next {\n             io::println(~\"Yay! I got money!\");\n         }\n@@ -91,18 +91,18 @@ fn client_follow(+bank: bank::client::login) {\n fn bank_client(+bank: bank::client::login) {\n     use bank::*;\n \n-    let bank = client::login(move bank, ~\"theincredibleholk\", ~\"1234\");\n-    let bank = match try_recv(move bank) {\n+    let bank = client::login(bank, ~\"theincredibleholk\", ~\"1234\");\n+    let bank = match try_recv(bank) {\n       Some(ok(connected)) => {\n         move_it!(connected)\n       }\n       Some(invalid(_)) => { fail!(~\"login unsuccessful\") }\n       None => { fail!(~\"bank closed the connection\") }\n     };\n \n-    let bank = client::deposit(move bank, 100.00);\n-    let bank = client::withdrawal(move bank, 50.00);\n-    match try_recv(move bank) {\n+    let bank = client::deposit(bank, 100.00);\n+    let bank = client::withdrawal(bank, 50.00);\n+    match try_recv(bank) {\n       Some(money(*)) => {\n         io::println(~\"Yay! I got money!\");\n       }"}, {"sha": "2d765423988419035d70d81ea44f581c9dcfdc0c", "filename": "src/test/run-pass/pipe-detect-term.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -32,7 +32,7 @@ pub fn main() {\n     let iotask = &uv::global_loop::get();\n     \n     pipes::spawn_service(oneshot::init, |p| { \n-        match try_recv(move p) {\n+        match try_recv(p) {\n           Some(*) => { fail!() }\n           None => { }\n         }\n@@ -47,11 +47,11 @@ pub fn main() {\n fn failtest() {\n     let (c, p) = oneshot::init();\n \n-    do task::spawn_with(move c) |_c| { \n+    do task::spawn_with(c) |_c| { \n         fail!();\n     }\n \n-    error!(\"%?\", recv(move p));\n+    error!(\"%?\", recv(p));\n     // make sure we get killed if we missed it in the receive.\n     loop { task::yield() }\n }"}, {"sha": "baa5ba5bf00a82d7b62414511caac0b24d8938ad", "filename": "src/test/run-pass/pipe-peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-peek.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -27,7 +27,7 @@ pub fn main() {\n \n     assert !pipes::peek(&p);\n \n-    oneshot::client::signal(move c);\n+    oneshot::client::signal(c);\n \n     assert pipes::peek(&p);\n }"}, {"sha": "b13b262e8645e85fff0d33254ce6dd0f3f6e585d", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -36,7 +36,7 @@ mod pingpong {\n                 pong: mk_packet::<pong>()\n             }\n         };\n-        do pipes::entangle_buffer(move buffer) |buffer, data| {\n+        do pipes::entangle_buffer(buffer) |buffer, data| {\n             data.ping.set_buffer(buffer);\n             data.pong.set_buffer(buffer);\n             ptr::addr_of(&(data.ping))\n@@ -53,9 +53,9 @@ mod pingpong {\n                 let b = pipe.reuse_buffer();\n                 let s = SendPacketBuffered(ptr::addr_of(&(b.buffer.data.pong)));\n                 let c = RecvPacketBuffered(ptr::addr_of(&(b.buffer.data.pong)));\n-                let message = ::pingpong::ping(move s);\n-                ::pipes::send(move pipe, move message);\n-                move c\n+                let message = ::pingpong::ping(s);\n+                ::pipes::send(pipe, message);\n+                c\n             }\n         }\n         pub type ping = pipes::SendPacketBuffered<::pingpong::ping,\n@@ -74,9 +74,9 @@ mod pingpong {\n                 let b = pipe.reuse_buffer();\n                 let s = SendPacketBuffered(ptr::addr_of(&(b.buffer.data.ping)));\n                 let c = RecvPacketBuffered(ptr::addr_of(&(b.buffer.data.ping)));\n-                let message = ::pingpong::pong(move s);\n-                ::pipes::send(move pipe, move message);\n-                move c\n+                let message = ::pingpong::pong(s);\n+                ::pipes::send(pipe, message);\n+                c\n             }\n         }\n         pub type pong = pipes::SendPacketBuffered<::pingpong::pong,\n@@ -91,34 +91,34 @@ mod test {\n     pub fn client(-chan: ::pingpong::client::ping) {\n         use pingpong::client;\n \n-        let chan = client::ping(move chan); return;\n+        let chan = client::ping(chan); return;\n         log(error, \"Sent ping\");\n-        let pong(_chan) = recv(move chan);\n+        let pong(_chan) = recv(chan);\n         log(error, \"Received pong\");\n     }\n     \n     pub fn server(-chan: ::pingpong::server::ping) {\n         use pingpong::server;\n \n-        let ping(chan) = recv(move chan); return;\n+        let ping(chan) = recv(chan); return;\n         log(error, \"Received ping\");\n-        let _chan = server::pong(move chan);\n+        let _chan = server::pong(chan);\n         log(error, \"Sent pong\");\n     }\n }\n \n pub fn main() {\n     let (client_, server_) = ::pingpong::init();\n-    let client_ = ~mut Some(move client_);\n-    let server_ = ~mut Some(move server_);\n-    do task::spawn |move client_| {\n+    let client_ = ~mut Some(client_);\n+    let server_ = ~mut Some(server_);\n+    do task::spawn || {\n         let mut client__ = None;\n         *client_ <-> client__;\n-        test::client(option::unwrap(move client__));\n+        test::client(option::unwrap(client__));\n     };\n-    do task::spawn |move server_| {\n+    do task::spawn || {\n         let mut server_\u02ca = None;\n         *server_ <-> server_\u02ca;\n-        test::server(option::unwrap(move server_\u02ca));\n+        test::server(option::unwrap(server_\u02ca));\n     };\n }"}, {"sha": "0d71a2c37d162e369c034e195ef09b1b0aa22800", "filename": "src/test/run-pass/pipe-pingpong-proto.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -33,35 +33,35 @@ mod test {\n     pub fn client(-chan: ::pingpong::client::ping) {\n         use pingpong::client;\n \n-        let chan = client::ping(move chan);\n+        let chan = client::ping(chan);\n         log(error, ~\"Sent ping\");\n-        let pong(_chan) = recv(move chan);\n+        let pong(_chan) = recv(chan);\n         log(error, ~\"Received pong\");\n     }\n     \n     pub fn server(-chan: ::pingpong::server::ping) {\n         use pingpong::server;\n \n-        let ping(chan) = recv(move chan);\n+        let ping(chan) = recv(chan);\n         log(error, ~\"Received ping\");\n-        let _chan = server::pong(move chan);\n+        let _chan = server::pong(chan);\n         log(error, ~\"Sent pong\");\n     }\n }\n \n pub fn main() {\n     let (client_, server_) = pingpong::init();\n-    let client_ = ~mut Some(move client_);\n-    let server_ = ~mut Some(move server_);\n+    let client_ = ~mut Some(client_);\n+    let server_ = ~mut Some(server_);\n \n-    do task::spawn |move client_| {\n+    do task::spawn || {\n         let mut client__ = None;\n         *client_ <-> client__;\n-        test::client(option::unwrap(move client__));\n+        test::client(option::unwrap(client__));\n     };\n-    do task::spawn |move server_| {\n+    do task::spawn || {\n         let mut server_\u02ca = None;\n         *server_ <-> server_\u02ca;\n-        test::server(option::unwrap(move server_\u02ca));\n+        test::server(option::unwrap(server_\u02ca));\n     };\n }"}, {"sha": "5fd1bb276c1e85496e75eb216f167d1bbd96f353", "filename": "src/test/run-pass/pipe-presentation-examples.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -34,10 +34,10 @@ macro_rules! select_if (\n         ], )*\n     } => {\n         if $index == $count {\n-            match move pipes::try_recv(move $port) {\n-              $(Some($message($($(move $x,)+)* move next)) => {\n-                let $next = move next;\n-                move $e\n+            match pipes::try_recv($port) {\n+              $(Some($message($($($x,)+)* next)) => {\n+                let $next = next;\n+                $e\n               })+\n               _ => fail!()\n             }\n@@ -105,33 +105,33 @@ fn render(_buffer: &Buffer) {\n }\n \n fn draw_frame(+channel: double_buffer::client::acquire) {\n-    let channel = request(move channel);\n+    let channel = request(channel);\n     select! (\n         channel => {\n             give_buffer(buffer) -> channel {\n                 render(&buffer);\n-                release(move channel, move buffer)\n+                release(channel, buffer)\n             }\n         }\n     );\n }\n \n fn draw_two_frames(+channel: double_buffer::client::acquire) {\n-    let channel = request(move channel);\n+    let channel = request(channel);\n     let channel = select! (\n         channel => {\n             give_buffer(buffer) -> channel {\n                 render(&buffer);\n-                release(move channel, move buffer)\n+                release(channel, buffer)\n             }\n         }\n     );\n-    let channel = request(move channel);\n+    let channel = request(channel);\n     select! (\n         channel => {\n             give_buffer(buffer) -> channel {\n                 render(&buffer);\n-                release(move channel, move buffer)\n+                release(channel, buffer)\n             }\n         }\n     );\n@@ -152,7 +152,7 @@ fn draw_two_frames_bad1(+channel: double_buffer::client::acquire) {\n         channel => {\n             give_buffer(buffer) -> channel {\n                 render(&buffer);\n-                release(channel, move buffer)\n+                release(channel, buffer)\n             }\n         }\n     );\n@@ -165,9 +165,9 @@ fn draw_two_frames_bad2(+channel: double_buffer::client::acquire) {\n         channel => {\n             give_buffer(buffer) -> channel {\n                 render(&buffer);\n-                release(channel, move buffer);\n+                release(channel, buffer);\n                 render(&buffer);\n-                release(channel, move buffer);\n+                release(channel, buffer);\n             }\n         }\n     );"}, {"sha": "0bf739139cfe18716c1d3b288696a6008ca2ad8f", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -41,24 +41,24 @@ pub fn main() {\n     \n     let c = pipes::spawn_service(stream::init, |p| { \n         error!(\"waiting for pipes\");\n-        let stream::send(x, p) = recv(move p);\n+        let stream::send(x, p) = recv(p);\n         error!(\"got pipes\");\n         let (left, right) : (oneshot::server::waiting,\n                              oneshot::server::waiting)\n-            = move x;\n+            = x;\n         error!(\"selecting\");\n-        let (i, _, _) = select(~[move left, move right]);\n+        let (i, _, _) = select(~[left, right]);\n         error!(\"selected\");\n         assert i == 0;\n \n         error!(\"waiting for pipes\");\n-        let stream::send(x, _) = recv(move p);\n+        let stream::send(x, _) = recv(p);\n         error!(\"got pipes\");\n         let (left, right) : (oneshot::server::waiting,\n                              oneshot::server::waiting)\n-            = move x;\n+            = x;\n         error!(\"selecting\");\n-        let (i, m, _) = select(~[move left, move right]);\n+        let (i, m, _) = select(~[left, right]);\n         error!(\"selected %?\", i);\n         if m.is_some() {\n             assert i == 1;\n@@ -68,20 +68,20 @@ pub fn main() {\n     let (c1, p1) = oneshot::init();\n     let (_c2, p2) = oneshot::init();\n \n-    let c = send(move c, (move p1, move p2));\n+    let c = send(c, (p1, p2));\n     \n     sleep(iotask, 100);\n \n-    signal(move c1);\n+    signal(c1);\n \n     let (_c1, p1) = oneshot::init();\n     let (c2, p2) = oneshot::init();\n \n-    send(move c, (move p1, move p2));\n+    send(c, (p1, p2));\n \n     sleep(iotask, 100);\n \n-    signal(move c2);\n+    signal(c2);\n \n     test_select2();\n }\n@@ -90,26 +90,26 @@ fn test_select2() {\n     let (ac, ap) = stream::init();\n     let (bc, bp) = stream::init();\n \n-    stream::client::send(move ac, 42);\n+    stream::client::send(ac, 42);\n \n-    match pipes::select2(move ap, move bp) {\n+    match pipes::select2(ap, bp) {\n       either::Left(*) => { }\n       either::Right(*) => { fail!() }\n     }\n \n-    stream::client::send(move bc, ~\"abc\");\n+    stream::client::send(bc, ~\"abc\");\n \n     error!(\"done with first select2\");\n \n     let (ac, ap) = stream::init();\n     let (bc, bp) = stream::init();\n \n-    stream::client::send(move bc, ~\"abc\");\n+    stream::client::send(bc, ~\"abc\");\n \n-    match pipes::select2(move ap, move bp) {\n+    match pipes::select2(ap, bp) {\n       either::Left(*) => { fail!() }\n       either::Right(*) => { }\n     }\n \n-    stream::client::send(move ac, 42);\n+    stream::client::send(ac, 42);\n }"}, {"sha": "521c400489e95620eac83d53edfee3fc37ef5b06", "filename": "src/test/run-pass/pipe-sleep.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -26,10 +26,10 @@ proto! oneshot (\n pub fn main() {\n     use oneshot::client::*;\n \n-    let c = pipes::spawn_service(oneshot::init, |p| { recv(move p); });\n+    let c = pipes::spawn_service(oneshot::init, |p| { recv(p); });\n \n     let iotask = &uv::global_loop::get();\n     sleep(iotask, 500);\n     \n-    signal(move c);\n+    signal(c);\n }"}, {"sha": "ff3e115eda9b0caaefcc36ab3ec4eb4268f918fd", "filename": "src/test/run-pass/regions-copy-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -13,7 +13,7 @@ struct closure_box {\n }\n \n fn box_it(+x: &r/fn()) -> closure_box/&r {\n-    closure_box {cl: move x}\n+    closure_box {cl: x}\n }\n \n pub fn main() {"}, {"sha": "00f5e695475a28c9bc412f2cf46dc576286981ff", "filename": "src/test/run-pass/regions-static-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -13,7 +13,7 @@ struct closure_box {\n }\n \n fn box_it(+x: &r/fn()) -> closure_box/&r {\n-    closure_box {cl: move x}\n+    closure_box {cl: x}\n }\n \n fn call_static_closure(cl: closure_box/&static) {\n@@ -22,5 +22,5 @@ fn call_static_closure(cl: closure_box/&static) {\n \n pub fn main() {\n     let cl_box = box_it(|| debug!(\"Hello, world!\"));\n-    call_static_closure(move cl_box);\n+    call_static_closure(cl_box);\n }"}, {"sha": "af3c92db8f6a16bb4e73b001fc227dc8f61e034c", "filename": "src/test/run-pass/resource-assign-is-not-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -29,8 +29,8 @@ pub fn main() {\n     // Even though these look like copies, they are guaranteed not to be\n     {\n         let a = r(i);\n-        let b = (move a, 10);\n-        let (c, _d) = move b;\n+        let b = (a, 10);\n+        let (c, _d) = b;\n         log(debug, c);\n     }\n     assert *i == 1;"}, {"sha": "d47d56b6021b31d48116e86be7a469bf08ef4c94", "filename": "src/test/run-pass/resource-cycle.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -45,18 +45,18 @@ pub fn main() {\n     unsafe {\n         let i1 = ~0;\n         let i1p = cast::reinterpret_cast(&i1);\n-        cast::forget(move i1);\n+        cast::forget(i1);\n         let i2 = ~0;\n         let i2p = cast::reinterpret_cast(&i2);\n-        cast::forget(move i2);\n+        cast::forget(i2);\n \n         let x1 = @t(Node{\n             mut next: None,\n               r: {\n               let rs = r(i1p);\n               debug!(\"r = %x\",\n                      cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&rs)));\n-              move rs }\n+              rs }\n         });\n         \n         debug!(\"x1 = %x, x1.r = %x\",\n@@ -69,7 +69,7 @@ pub fn main() {\n               let rs = r(i2p);\n               debug!(\"r2 = %x\",\n                      cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&rs)));\n-              move rs\n+              rs\n                 }\n         });\n         "}, {"sha": "1b39093c7d05cc7e82d40afad210063c13d980e2", "filename": "src/test/run-pass/resource-cycle2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -45,10 +45,10 @@ pub fn main() {\n     unsafe {\n         let i1 = ~0xA;\n         let i1p = cast::reinterpret_cast(&i1);\n-        cast::forget(move i1);\n+        cast::forget(i1);\n         let i2 = ~0xA;\n         let i2p = cast::reinterpret_cast(&i2);\n-        cast::forget(move i2);\n+        cast::forget(i2);\n \n         let u1 = U {a: 0xB, b: 0xC, c: i1p};\n         let u2 = U {a: 0xB, b: 0xC, c: i2p};"}, {"sha": "036ca2496698c1399ff0c6313a7d3ef86c7b5c05", "filename": "src/test/run-pass/resource-cycle3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -54,10 +54,10 @@ pub fn main() {\n     unsafe {\n         let i1 = ~0xA;\n         let i1p = cast::reinterpret_cast(&i1);\n-        cast::forget(move i1);\n+        cast::forget(i1);\n         let i2 = ~0xA;\n         let i2p = cast::reinterpret_cast(&i2);\n-        cast::forget(move i2);\n+        cast::forget(i2);\n \n         let u1 = U {a: 0xB, b: 0xC, c: i1p};\n         let u2 = U {a: 0xB, b: 0xC, c: i2p};"}, {"sha": "3dc4ca7bd61dc13a7aa891564fca33d4cb479fce", "filename": "src/test/run-pass/resource-destruct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-destruct.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -30,7 +30,7 @@ fn shrinky_pointer(i: @@mut int) -> shrinky_pointer {\n \n pub fn main() {\n     let my_total = @@mut 10;\n-    { let pt = move shrinky_pointer(my_total); assert (pt.look_at() == 10); }\n+    { let pt = shrinky_pointer(my_total); assert (pt.look_at() == 10); }\n     log(error, fmt!(\"my_total = %d\", **my_total));\n     assert (**my_total == 9);\n }"}, {"sha": "eb25f20607f41544b9e554468e7f9375b82e58c4", "filename": "src/test/run-pass/resource-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-generic.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -33,6 +33,6 @@ pub fn main() {\n     let box = @mut 10;\n     fn dec_box(&&i: @mut int) { *i -= 1; }\n \n-    { let _i = move finish(Arg{val: box, fin: dec_box}); }\n+    { let _i = finish(Arg{val: box, fin: dec_box}); }\n     assert (*box == 9);\n }"}, {"sha": "cefed420546eab56909af6b1e297421e1a6eeca7", "filename": "src/test/run-pass/rt-sched-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-sched-1.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -46,7 +46,7 @@ pub fn main() {\n         };\n         let fptr = cast::reinterpret_cast(&ptr::addr_of(&f));\n         rustrt::start_task(new_task_id, fptr);\n-        cast::forget(move f);\n+        cast::forget(f);\n         po.recv();\n     }\n }"}, {"sha": "d576875be10d8575fe88fcb765be9d15dc6340d8", "filename": "src/test/run-pass/select-macro.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fselect-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fselect-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fselect-macro.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -27,18 +27,18 @@ macro_rules! select_if (\n         $count:expr,\n         $port:path => [\n             $(type_this $message:path$(($(x $x: ident),+))dont_type_this*\n-              -> $next:ident => { move $e:expr }),+\n+              -> $next:ident => { $e:expr }),+\n         ]\n         $(, $ports:path => [\n             $(type_this $messages:path$(($(x $xs: ident),+))dont_type_this*\n-              -> $nexts:ident => { move $es:expr }),+\n+              -> $nexts:ident => { $es:expr }),+\n         ] )*\n     } => {\n         if $index == $count {\n-            match move pipes::try_recv($port) {\n-              $(Some($message($($(move $x,)+)* move next)) => {\n-                let $next = move next;\n-                move $e\n+            match pipes::try_recv($port) {\n+              $(Some($message($($($x,)+)* next)) => {\n+                let $next = next;\n+                $e\n               })+\n               _ => fail!()\n             }\n@@ -48,7 +48,7 @@ macro_rules! select_if (\n                 $count + 1\n                 $(, $ports => [\n                     $(type_this $messages$(($(x $xs),+))dont_type_this*\n-                      -> $nexts => { move $es }),+\n+                      -> $nexts => { $es }),+\n                 ])*\n             )\n         }\n@@ -64,7 +64,7 @@ macro_rules! select (\n     } => {\n         let index = pipes::selecti([$(($port).header()),+]);\n         select_if!(index, 0 $(, $port => [\n-            $(type_this $message$(($(x $x),+))dont_type_this* -> $next => { move $e }),+\n+            $(type_this $message$(($(x $x),+))dont_type_this* -> $next => { $e }),+\n         ])+)\n     }\n )"}, {"sha": "fce0889e0a9b8bfbfc913799d011cc49eecdfd56", "filename": "src/test/run-pass/sendfn-spawn-with-fn-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -20,7 +20,7 @@ fn test05() {\n         log(error, *three + n); // will copy x into the closure\n         assert(*three == 3);\n     };\n-    task::spawn(fn~(move fn_to_send) {\n+    task::spawn(fn~() {\n         test05_start(fn_to_send);\n     });\n }"}, {"sha": "da79bf53fe06c9deedfc4c19c2249fb58d265b21", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -23,13 +23,13 @@ fn andand<T: bool_like Copy>(x1: T, x2: T) -> T {\n \n impl bool_like for bool {\n     static fn select<A>(&&b: bool, +x1: A, +x2: A) -> A {\n-        if b { move x1 } else { move x2 }\n+        if b { x1 } else { x2 }\n     }\n }\n \n impl bool_like for int {\n     static fn select<A>(&&b: int, +x1: A, +x2: A) -> A {\n-        if b != 0 { move x1 } else { move x2 }\n+        if b != 0 { x1 } else { x2 }\n     }\n }\n "}, {"sha": "aa8a2a9146cbc6466fcfcace5a25e4b60ecec766", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -29,7 +29,7 @@ fn test05_start(ch : Chan<int>) {\n \n fn test05() {\n     let (po, ch) = pipes::stream();\n-    task::spawn(|move ch| test05_start(ch) );\n+    task::spawn(|| test05_start(ch) );\n     let mut value = po.recv();\n     log(error, value);\n     value = po.recv();"}, {"sha": "289a728efc39a535a1ca0d1f99032905177fb340", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -15,7 +15,7 @@ extern mod std;\n \n fn start(c: pipes::Chan<pipes::Chan<~str>>) {\n     let (p, ch) = pipes::stream();\n-    c.send(move ch);\n+    c.send(ch);\n \n     let mut a;\n     let mut b;\n@@ -24,12 +24,12 @@ fn start(c: pipes::Chan<pipes::Chan<~str>>) {\n     log(error, a);\n     b = p.recv();\n     assert b == ~\"B\";\n-    log(error, move b);\n+    log(error, b);\n }\n \n pub fn main() {\n     let (p, ch) = pipes::stream();\n-    let child = task::spawn(|move ch| start(ch) );\n+    let child = task::spawn(|| start(ch) );\n \n     let c = p.recv();\n     c.send(~\"A\");"}, {"sha": "996566abcd89fd49b257a0eb673fb54ef604148e", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -15,11 +15,11 @@ extern mod std;\n \n fn start(c: pipes::Chan<pipes::Chan<int>>) {\n     let (p, ch) = pipes::stream();\n-    c.send(move ch);\n+    c.send(ch);\n }\n \n pub fn main() {\n     let (p, ch) = pipes::stream();\n-    let child = task::spawn(|move ch| start(ch) );\n+    let child = task::spawn(|| start(ch) );\n     let c = p.recv();\n }"}, {"sha": "9f23ab1c9dfa68e0c3f27721cd100d5d652d2404", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -17,7 +17,7 @@ fn start(&&task_number: int) { debug!(\"Started / Finished task.\"); }\n fn test00() {\n     let i: int = 0;\n     let mut result = None;\n-    do task::task().future_result(|+r| { result = Some(move r); }).spawn {\n+    do task::task().future_result(|+r| { result = Some(r); }).spawn {\n         start(i)\n     }\n \n@@ -29,7 +29,7 @@ fn test00() {\n     }\n \n     // Try joining tasks that have already finished.\n-    option::unwrap(move result).recv();\n+    option::unwrap(result).recv();\n \n     debug!(\"Joined task.\");\n }"}, {"sha": "4ee23ec54d6cb9c1a71409eb9dceb01f674ea502", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -22,6 +22,6 @@ fn start(c: pipes::Chan<int>, start: int, number_of_messages: int) {\n pub fn main() {\n     debug!(\"Check that we don't deadlock.\");\n     let (p, ch) = pipes::stream();\n-    task::try(|move ch| start(ch, 0, 10) );\n+    task::try(|| start(ch, 0, 10) );\n     debug!(\"Joined task\");\n }"}, {"sha": "f32fbdd04e62ead75f8ffe8da6bf9e67645b0636", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -19,8 +19,8 @@ pub fn main() {\n     while (i > 0) {\n         log(debug, i);\n         let (p, ch) = pipes::stream();\n-        po.add(move p);\n-        task::spawn({let i = i; |move ch| child(i, ch)});\n+        po.add(p);\n+        task::spawn({let i = i; || child(i, ch)});\n         i = i - 1;\n     }\n "}, {"sha": "957066005acda898cb5d558e621486412fa4ffb5", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -28,6 +28,6 @@ pub fn main() {\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n     let (p, ch) = pipes::stream();\n-    task::spawn(|move ch| start(ch, 10));\n+    task::spawn(|| start(ch, 10));\n     p.recv();\n }"}, {"sha": "648a54d190fa408b0b294f95632510943ce15558", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -100,7 +100,7 @@ fn test_tag() {\n fn test_chan() {\n     let (po, ch) = pipes::stream();\n     let (po0, ch0) = pipes::stream();\n-    ch.send(move ch0);\n+    ch.send(ch0);\n     let ch1 = po.recv();\n     // Does the transmitted channel still work?\n "}, {"sha": "372a0ea434b58b326a1fb2a0eb07b39df6f28d23", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -44,10 +44,10 @@ fn test00() {\n     while i < number_of_tasks {\n         let ch = po.chan();\n         task::task().future_result(|+r| {\n-            results.push(move r);\n+            results.push(r);\n         }).spawn({\n             let i = i;\n-            |move ch| test00_start(ch, i, number_of_messages)\n+            || test00_start(ch, i, number_of_messages)\n         });\n         i = i + 1;\n     }"}, {"sha": "481df2d1d529b4a1c94dfe1b38c6f5ef15e0bf01", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -27,19 +27,19 @@ fn test00() {\n     let number_of_messages: int = 10;\n \n     let c = p.chan();\n-    do task::spawn |move c| {\n+    do task::spawn || {\n         test00_start(c, number_of_messages * 0, number_of_messages);\n     }\n     let c = p.chan();\n-    do task::spawn |move c| {\n+    do task::spawn || {\n         test00_start(c, number_of_messages * 1, number_of_messages);\n     }\n     let c = p.chan();\n-    do task::spawn |move c| {\n+    do task::spawn || {\n         test00_start(c, number_of_messages * 2, number_of_messages);\n     }\n     let c = p.chan();\n-    do task::spawn |move c| {\n+    do task::spawn || {\n         test00_start(c, number_of_messages * 3, number_of_messages);\n     }\n "}, {"sha": "d3ed48f7575239fc67ee9cb63b648ba9a34318a4", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -28,8 +28,8 @@ fn test00() {\n     let ch = p.chan();\n \n     let mut result = None;\n-    do task::task().future_result(|+r| { result = Some(move r); }).spawn\n-          |move ch| {\n+    do task::task().future_result(|+r| { result = Some(r); }).spawn\n+          || {\n         test00_start(ch, number_of_messages);\n     }\n \n@@ -40,7 +40,7 @@ fn test00() {\n         i += 1;\n     }\n \n-    option::unwrap(move result).recv();\n+    option::unwrap(result).recv();\n \n     assert (sum == number_of_messages * (number_of_messages - 1) / 2);\n }"}, {"sha": "5468970ecf555e58d577130c0cf56bbedc85e2a7", "filename": "src/test/run-pass/trait-default-method-bound-subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,13 +11,13 @@\n // xfail-test\n \n trait A<T> {\n-    fn g<U>(x: T, y: U) -> (T, U) { (move x, move y) }\n+    fn g<U>(x: T, y: U) -> (T, U) { (x, y) }\n }\n \n impl A<int> for int { }\n \n fn f<T, U, V: A<T>>(i: V, j: T, k: U) -> (T, U) {\n-    i.g(move j, move k)\n+    i.g(j, k)\n }\n \n fn main () {"}, {"sha": "71f4165db9d64f0a893b91cba7e8c5a74070f450", "filename": "src/test/run-pass/trait-default-method-bound-subst2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst2.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,13 +11,13 @@\n // xfail-test\n \n trait A<T> {\n-    fn g(x: T) -> T { move x }\n+    fn g(x: T) -> T { x }\n }\n \n impl A<int> for int { }\n \n fn f<T, V: A<T>>(i: V, j: T) -> T {\n-    i.g(move j)\n+    i.g(j)\n }\n \n fn main () {"}, {"sha": "f27bd7c0a7bf90c6f557e0999ae0c461f6b90a69", "filename": "src/test/run-pass/trait-default-method-bound-subst3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst3.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,13 +11,13 @@\n #[allow(default_methods)];\n \n trait A {\n-    fn g<T>(x: T, y: T) -> (T, T) { (move x, move y) }\n+    fn g<T>(x: T, y: T) -> (T, T) { (x, y) }\n }\n \n impl A for int { }\n \n fn f<T, V: A>(i: V, j: T, k: T) -> (T, T) {\n-    i.g(move j, move k)\n+    i.g(j, k)\n }\n \n fn main () {"}, {"sha": "8ea5341795164404551338b26b4d1a4486f0643e", "filename": "src/test/run-pass/trait-default-method-bound-subst4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst4.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,13 +11,13 @@\n #[allow(default_methods)];\n \n trait A<T> {\n-    fn g(x: uint) -> uint { move x }\n+    fn g(x: uint) -> uint { x }\n }\n \n impl<T> A<T> for int { }\n \n fn f<T, V: A<T>>(i: V, j: uint) -> uint {\n-    i.g(move j)\n+    i.g(j)\n }\n \n fn main () {"}, {"sha": "b3ebc2ba820aabd2a9f00085b65d1afad5d8766a", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -40,7 +40,7 @@ pub fn main() {\n     assert indirect(~[10, 20]) == ~\"[10, 20]!\";\n \n     fn indirect2<T: to_str>(x: T) -> ~str {\n-        indirect(move x)\n+        indirect(x)\n     }\n     assert indirect2(~[1]) == ~\"[1]!\";\n }"}, {"sha": "96e91093d37a2eb40dc0ecf74e27c2d722b2fe1b", "filename": "src/test/run-pass/unique-decl-move-temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-decl-move-temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-decl-move-temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-decl-move-temp.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n pub fn main() {\n-    let i = move ~100;\n+    let i = ~100;\n     assert *i == 100;\n }"}, {"sha": "7723eafc035eed7db487bb80bbc1631b79de9a3e", "filename": "src/test/run-pass/unique-decl-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-decl-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-decl-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-decl-move.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -10,6 +10,6 @@\n \n pub fn main() {\n     let i = ~100;\n-    let j = move i;\n+    let j = i;\n     assert *j == 100;\n }"}, {"sha": "12e9820361d777a53790019e3d1f586616db3c7b", "filename": "src/test/run-pass/unique-fn-arg-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-fn-arg-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-fn-arg-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-fn-arg-move.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -14,5 +14,5 @@ fn f(-i: ~int) {\n \n pub fn main() {\n     let i = ~100;\n-    f(move i);\n+    f(i);\n }"}, {"sha": "5988a3e8658dce09836d80bac517009cbe358c51", "filename": "src/test/run-pass/unique-move-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-move-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-move-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-move-drop.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,6 +11,6 @@\n pub fn main() {\n     let i = ~100;\n     let j = ~200;\n-    let j = move i;\n+    let j = i;\n     assert *j == 100;\n }"}, {"sha": "08a496987c0a629801d19104352c5916baed735f", "filename": "src/test/run-pass/unique-move-temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-move-temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-move-temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-move-temp.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -10,6 +10,6 @@\n \n pub fn main() {\n     let mut i;\n-    i = move ~100;\n+    i = ~100;\n     assert *i == 100;\n }"}, {"sha": "5e778d581d340a7031c743a37d538e056572bdc2", "filename": "src/test/run-pass/unique-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funique-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-move.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,6 +11,6 @@\n pub fn main() {\n     let i = ~100;\n     let mut j;\n-    j = move i;\n+    j = i;\n     assert *j == 100;\n }"}, {"sha": "9c658fdc252760f55df4b26c62b00c1158f6cea4", "filename": "src/test/run-pass/unreachable-code-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funreachable-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funreachable-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funreachable-code-1.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -12,7 +12,7 @@\n fn id(x: bool) -> bool { x }\n \n fn call_id() {\n-    let c = move fail!();\n+    let c = fail!();\n     id(c); //~ WARNING unreachable statement\n }\n "}, {"sha": "fa93dfd0fe135a41db8764c6ef890adbd54946a0", "filename": "src/test/run-pass/unreachable-code.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funreachable-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funreachable-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funreachable-code.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -12,7 +12,7 @@\n fn id(x: bool) -> bool { x }\n \n fn call_id() {\n-    let c = move fail!();\n+    let c = fail!();\n     id(c);\n }\n "}, {"sha": "665abe23ee8935fd43fb22c58306c9b370d47be1", "filename": "src/test/run-pass/unused-move-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funused-move-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funused-move-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funused-move-capture.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -10,6 +10,6 @@\n \n pub fn main() {\n     let x = ~1;\n-    let lam_move = fn@(move x) { };\n+    let lam_move = fn@() { };\n     lam_move();\n }"}, {"sha": "69ce791c1a35aa56c8a93b08a5276b80ef2d39f0", "filename": "src/test/run-pass/unused-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funused-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funused-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funused-move.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -15,5 +15,5 @@\n pub fn main()\n {\n     let y = ~1;\n-    move y;\n+    y;\n }"}, {"sha": "93f1c7b5b45090a0f9a09d835bc88309883f5c9d", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -33,7 +33,7 @@ fn complainer(c: SharedChan<bool>) -> complainer {\n }\n \n fn f(c: SharedChan<bool>) {\n-    let _c = move complainer(c);\n+    let _c = complainer(c);\n     fail!();\n }\n "}, {"sha": "75ce797cfc842955d00ee2a89344ee86d5237c4a", "filename": "src/test/run-pass/unwind-resource2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funwind-resource2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Funwind-resource2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource2.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -26,7 +26,7 @@ fn complainer(c: @int) -> complainer {\n }\n \n fn f() {\n-    let c = move complainer(@0);\n+    let c = complainer(@0);\n     fail!();\n }\n "}, {"sha": "5b515ae5434767bd2d8db372301c31825176a7a8", "filename": "src/test/run-pass/weird-exprs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exprs.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -50,7 +50,7 @@ fn zombiejesus() {\n fn notsure() {\n     let mut _x;\n     let mut _y = (_x = 0) == (_x = 0);\n-    let mut _z = (_x = move 0) < (_x = 0);\n+    let mut _z = (_x = 0) < (_x = 0);\n     let _a = (_x += 0) == (_x = 0);\n     let _b = (_y <-> _z) == (_y <-> _z);\n }\n@@ -73,7 +73,7 @@ fn angrydome() {\n       break; }\n }\n \n-fn evil_lincoln() { let evil = move debug!(\"lincoln\"); }\n+fn evil_lincoln() { let evil = debug!(\"lincoln\"); }\n \n pub fn main() {\n     strange();"}, {"sha": "df5f5904793dad7529fbebc15b5b891c8d8c0c05", "filename": "src/test/run-pass/while-loop-constraints-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fwhile-loop-constraints-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fwhile-loop-constraints-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-loop-constraints-2.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n     let mut x: int;\n     while z < 50 {\n         z += 1;\n-        while false { x = move y; y = z; }\n+        while false { x = y; y = z; }\n         log(debug, y);\n     }\n     assert (y == 42 && z == 50);"}, {"sha": "16f43016b8e673b0220b166459c9c2190d028e9e", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,13 +11,13 @@\n \n pub fn main() {\n     let mut result = None;\n-    task::task().future_result(|+r| { result = Some(move r); }).spawn(child);\n+    task::task().future_result(|+r| { result = Some(r); }).spawn(child);\n     error!(\"1\");\n     task::yield();\n     error!(\"2\");\n     task::yield();\n     error!(\"3\");\n-    option::unwrap(move result).recv();\n+    option::unwrap(result).recv();\n }\n \n fn child() {"}, {"sha": "ae1271f64e4dc3d84ba5fc621a5e28032e1eeed9", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528329a4fb7765917bda30e9e1805627801d36a/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=0528329a4fb7765917bda30e9e1805627801d36a", "patch": "@@ -11,10 +11,10 @@\n \n pub fn main() {\n     let mut result = None;\n-    task::task().future_result(|+r| { result = Some(move r); }).spawn(child);\n+    task::task().future_result(|+r| { result = Some(r); }).spawn(child);\n     error!(\"1\");\n     task::yield();\n-    option::unwrap(move result).recv();\n+    option::unwrap(result).recv();\n }\n \n fn child() { error!(\"2\"); }"}]}