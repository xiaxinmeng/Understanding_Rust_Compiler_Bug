{"sha": "561bb979cecd786f5d311ea7bddb1e15d77a3848", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MWJiOTc5Y2VjZDc4NmY1ZDMxMWVhN2JkZGIxZTE1ZDc3YTM4NDg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-09T09:13:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-09T09:13:14Z"}, "message": "Merge #2169\n\n2169: MBE: Mapping spans for goto definition r=matklad a=edwin0cheng\n\nCurrently, go to definition gives the wrong span in MBE.  This PR implement a mapping mechanism to fix it and it could be used for future MBE hygiene implementation.\r\n\r\nThe basic idea of the mapping is:\r\n1. When expanding the macro, generated 2 `TokenMap` which maps the macro args and macro defs between tokens and input text-ranges.\r\n2. Before converting generated `TokenTree` to `SyntaxNode`, generated a `ExpandedRangeMap` which is a mapping between token and output text-ranges.\r\n3. Using these 3 mappings to construct an `ExpansionInfo`  which can map between input text ranges and output text ranges.\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "a6aaa81c3acbfc5e6add5ebbee9abbc0f8357014", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6aaa81c3acbfc5e6add5ebbee9abbc0f8357014"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/561bb979cecd786f5d311ea7bddb1e15d77a3848", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdxoMqCRBK7hj4Ov3rIwAAdHIIACft9znJ+KJ7ujLEa8Kk+07f\naswmNl87rE/1uu/VYFX6Doj+Su/l9VPc2k4N1w7JgdereoJjLjGlrXqYot/MF7Z8\nLiQ/NIeaJOjkq5Xp16/IdTJz749dO/2+jpVvM9viPaKnMNM4+kvGMsJjz5unmyV8\nGBHQeWtPUwq1wybH+st1U5DA5plblC0Zzjsh3NBC7OyJab0d1xHgHG8NP+Z3DDEv\nVCq5vXT5R4Cjb6VUv7oKYn/9FEGIfPWUMWOyvclHvs7ufJpX2YKYzgLSPshO3QOZ\nAzadmTLrIKxu0lA+4Vqwp9oB45s/5hgVk1TZo9gx4NWmXS7ssolui2jhcVbGnf8=\n=GZAb\n-----END PGP SIGNATURE-----\n", "payload": "tree a6aaa81c3acbfc5e6add5ebbee9abbc0f8357014\nparent 23939cabcc10ecc045a97361df182b9b4db32953\nparent 0a5ec69404a2556dd82e5bb00b295aebaa291f04\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573290794 +0000\ncommitter GitHub <noreply@github.com> 1573290794 +0000\n\nMerge #2169\n\n2169: MBE: Mapping spans for goto definition r=matklad a=edwin0cheng\n\nCurrently, go to definition gives the wrong span in MBE.  This PR implement a mapping mechanism to fix it and it could be used for future MBE hygiene implementation.\r\n\r\nThe basic idea of the mapping is:\r\n1. When expanding the macro, generated 2 `TokenMap` which maps the macro args and macro defs between tokens and input text-ranges.\r\n2. Before converting generated `TokenTree` to `SyntaxNode`, generated a `ExpandedRangeMap` which is a mapping between token and output text-ranges.\r\n3. Using these 3 mappings to construct an `ExpansionInfo`  which can map between input text ranges and output text ranges.\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/561bb979cecd786f5d311ea7bddb1e15d77a3848", "html_url": "https://github.com/rust-lang/rust/commit/561bb979cecd786f5d311ea7bddb1e15d77a3848", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/561bb979cecd786f5d311ea7bddb1e15d77a3848/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23939cabcc10ecc045a97361df182b9b4db32953", "url": "https://api.github.com/repos/rust-lang/rust/commits/23939cabcc10ecc045a97361df182b9b4db32953", "html_url": "https://github.com/rust-lang/rust/commit/23939cabcc10ecc045a97361df182b9b4db32953"}, {"sha": "0a5ec69404a2556dd82e5bb00b295aebaa291f04", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a5ec69404a2556dd82e5bb00b295aebaa291f04", "html_url": "https://github.com/rust-lang/rust/commit/0a5ec69404a2556dd82e5bb00b295aebaa291f04"}], "stats": {"total": 406, "additions": 305, "deletions": 101}, "files": [{"sha": "b789c6e7b3affd87dbfe60bd4f4bc7929e63b35a", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=561bb979cecd786f5d311ea7bddb1e15d77a3848", "patch": "@@ -22,9 +22,12 @@ pub trait AstDatabase: SourceDatabase {\n \n     #[salsa::interned]\n     fn intern_macro(&self, macro_call: MacroCallLoc) -> MacroCallId;\n-    fn macro_arg(&self, id: MacroCallId) -> Option<Arc<tt::Subtree>>;\n-    fn macro_def(&self, id: MacroDefId) -> Option<Arc<mbe::MacroRules>>;\n-    fn parse_macro(&self, macro_file: MacroFile) -> Option<Parse<SyntaxNode>>;\n+    fn macro_arg(&self, id: MacroCallId) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>>;\n+    fn macro_def(&self, id: MacroDefId) -> Option<Arc<(mbe::MacroRules, mbe::TokenMap)>>;\n+    fn parse_macro(\n+        &self,\n+        macro_file: MacroFile,\n+    ) -> Option<(Parse<SyntaxNode>, Arc<mbe::RevTokenMap>)>;\n     fn macro_expand(&self, macro_call: MacroCallId) -> Result<Arc<tt::Subtree>, String>;\n }\n \n@@ -34,26 +37,32 @@ pub(crate) fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdM\n     Arc::new(map)\n }\n \n-pub(crate) fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n+pub(crate) fn macro_def(\n+    db: &dyn AstDatabase,\n+    id: MacroDefId,\n+) -> Option<Arc<(mbe::MacroRules, mbe::TokenMap)>> {\n     let macro_call = id.ast_id.to_node(db);\n     let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(&arg).or_else(|| {\n+    let (tt, tmap) = mbe::ast_to_token_tree(&arg).or_else(|| {\n         log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n         None\n     })?;\n     let rules = MacroRules::parse(&tt).ok().or_else(|| {\n         log::warn!(\"fail on macro_def parse: {:#?}\", tt);\n         None\n     })?;\n-    Some(Arc::new(rules))\n+    Some(Arc::new((rules, tmap)))\n }\n \n-pub(crate) fn macro_arg(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<tt::Subtree>> {\n+pub(crate) fn macro_arg(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>> {\n     let loc = db.lookup_intern_macro(id);\n     let macro_call = loc.ast_id.to_node(db);\n     let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(&arg)?;\n-    Some(Arc::new(tt))\n+    let (tt, tmap) = mbe::ast_to_token_tree(&arg)?;\n+    Some(Arc::new((tt, tmap)))\n }\n \n pub(crate) fn macro_expand(\n@@ -64,7 +73,7 @@ pub(crate) fn macro_expand(\n     let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n \n     let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n-    let tt = macro_rules.expand(&macro_arg).map_err(|err| format!(\"{:?}\", err))?;\n+    let tt = macro_rules.0.expand(&macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     if count > 65536 {\n@@ -77,16 +86,17 @@ pub(crate) fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Optio\n     match file_id.0 {\n         HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n         HirFileIdRepr::MacroFile(macro_file) => {\n-            db.parse_macro(macro_file).map(|it| it.syntax_node())\n+            db.parse_macro(macro_file).map(|(it, _)| it.syntax_node())\n         }\n     }\n }\n \n pub(crate) fn parse_macro(\n     db: &dyn AstDatabase,\n     macro_file: MacroFile,\n-) -> Option<Parse<SyntaxNode>> {\n+) -> Option<(Parse<SyntaxNode>, Arc<mbe::RevTokenMap>)> {\n     let _p = profile(\"parse_macro_query\");\n+\n     let macro_call_id = macro_file.macro_call_id;\n     let tt = db\n         .macro_expand(macro_call_id)\n@@ -97,8 +107,13 @@ pub(crate) fn parse_macro(\n             log::warn!(\"fail on macro_parse: (reason: {})\", err,);\n         })\n         .ok()?;\n+\n     match macro_file.macro_file_kind {\n-        MacroFileKind::Items => mbe::token_tree_to_items(&tt).ok().map(Parse::to_syntax),\n-        MacroFileKind::Expr => mbe::token_tree_to_expr(&tt).ok().map(Parse::to_syntax),\n+        MacroFileKind::Items => {\n+            mbe::token_tree_to_items(&tt).ok().map(|(p, map)| (p.to_syntax(), Arc::new(map)))\n+        }\n+        MacroFileKind::Expr => {\n+            mbe::token_tree_to_expr(&tt).ok().map(|(p, map)| (p.to_syntax(), Arc::new(map)))\n+        }\n     }\n }"}, {"sha": "b219b8fbf8fb2caa3c5ca6754683f88a2f05ac5d", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=561bb979cecd786f5d311ea7bddb1e15d77a3848", "patch": "@@ -12,11 +12,12 @@ pub mod hygiene;\n pub mod diagnostics;\n \n use std::hash::{Hash, Hasher};\n+use std::sync::Arc;\n \n use ra_db::{salsa, CrateId, FileId};\n use ra_syntax::{\n     ast::{self, AstNode},\n-    SyntaxNode,\n+    SyntaxNode, TextRange, TextUnit,\n };\n \n use crate::ast_id_map::FileAstId;\n@@ -66,6 +67,30 @@ impl HirFileId {\n             }\n         }\n     }\n+\n+    /// Return expansion information if it is a macro-expansion file\n+    pub fn expansion_info(self, db: &dyn db::AstDatabase) -> Option<ExpansionInfo> {\n+        match self.0 {\n+            HirFileIdRepr::FileId(_) => None,\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n+\n+                let arg_start = loc.ast_id.to_node(db).token_tree()?.syntax().text_range().start();\n+                let def_start =\n+                    loc.def.ast_id.to_node(db).token_tree()?.syntax().text_range().start();\n+\n+                let macro_def = db.macro_def(loc.def)?;\n+                let shift = macro_def.0.shift();\n+                let exp_map = db.parse_macro(macro_file)?.1;\n+                let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n+\n+                let arg_start = (loc.ast_id.file_id, arg_start);\n+                let def_start = (loc.def.ast_id.file_id, def_start);\n+\n+                Some(ExpansionInfo { arg_start, def_start, macro_arg, macro_def, exp_map, shift })\n+            }\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -112,6 +137,36 @@ impl MacroCallId {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+/// ExpansionInfo mainly describes how to map text range between src and expanded macro\n+pub struct ExpansionInfo {\n+    pub(crate) arg_start: (HirFileId, TextUnit),\n+    pub(crate) def_start: (HirFileId, TextUnit),\n+    pub(crate) shift: u32,\n+\n+    pub(crate) macro_def: Arc<(mbe::MacroRules, mbe::TokenMap)>,\n+    pub(crate) macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n+    pub(crate) exp_map: Arc<mbe::RevTokenMap>,\n+}\n+\n+impl ExpansionInfo {\n+    pub fn find_range(&self, from: TextRange) -> Option<(HirFileId, TextRange)> {\n+        fn look_in_rev_map(exp_map: &mbe::RevTokenMap, from: TextRange) -> Option<tt::TokenId> {\n+            exp_map.ranges.iter().find(|&it| it.0.is_subrange(&from)).map(|it| it.1)\n+        }\n+\n+        let token_id = look_in_rev_map(&self.exp_map, from)?;\n+        let (token_map, file_offset, token_id) = if token_id.0 >= self.shift {\n+            (&self.macro_arg.1, self.arg_start, tt::TokenId(token_id.0 - self.shift).into())\n+        } else {\n+            (&self.macro_def.1, self.def_start, token_id)\n+        };\n+\n+        let range = token_map.relative_range_of(token_id)?;\n+        Some((file_offset.0, TextRange::offset_len(range.start() + file_offset.1, range.len())))\n+    }\n+}\n+\n /// `AstId` points to an AST node in any file.\n ///\n /// It is stable across reparses, and can be used as salsa key/value."}, {"sha": "1bf81e7d5195103716a3bd44646e0627fa41ef4e", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 88, "deletions": 32, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=561bb979cecd786f5d311ea7bddb1e15d77a3848", "patch": "@@ -29,6 +29,21 @@ pub struct NavigationTarget {\n     docs: Option<String>,\n }\n \n+fn find_range_from_node(\n+    db: &RootDatabase,\n+    src: hir::HirFileId,\n+    node: &SyntaxNode,\n+) -> (FileId, TextRange) {\n+    let text_range = node.text_range();\n+    let (file_id, text_range) = src\n+        .expansion_info(db)\n+        .and_then(|expansion_info| expansion_info.find_range(text_range))\n+        .unwrap_or((src, text_range));\n+\n+    // FIXME: handle recursive macro generated macro\n+    (file_id.original_file(db), text_range)\n+}\n+\n impl NavigationTarget {\n     /// When `focus_range` is specified, returns it. otherwise\n     /// returns `full_range`\n@@ -72,8 +87,12 @@ impl NavigationTarget {\n         self.focus_range\n     }\n \n-    pub(crate) fn from_bind_pat(file_id: FileId, pat: &ast::BindPat) -> NavigationTarget {\n-        NavigationTarget::from_named(file_id, pat, None, None)\n+    pub(crate) fn from_bind_pat(\n+        db: &RootDatabase,\n+        file_id: FileId,\n+        pat: &ast::BindPat,\n+    ) -> NavigationTarget {\n+        NavigationTarget::from_named(db, file_id.into(), pat, None, None)\n     }\n \n     pub(crate) fn from_symbol(db: &RootDatabase, symbol: FileSymbol) -> NavigationTarget {\n@@ -96,7 +115,7 @@ impl NavigationTarget {\n     ) -> NavigationTarget {\n         let parse = db.parse(file_id);\n         let pat = pat.to_node(parse.tree().syntax());\n-        NavigationTarget::from_bind_pat(file_id, &pat)\n+        NavigationTarget::from_bind_pat(db, file_id, &pat)\n     }\n \n     pub(crate) fn from_self_param(\n@@ -119,31 +138,46 @@ impl NavigationTarget {\n \n     pub(crate) fn from_module(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n         let src = module.definition_source(db);\n-        let file_id = src.file_id.original_file(db);\n         let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n         match src.ast {\n             ModuleSource::SourceFile(node) => {\n-                NavigationTarget::from_syntax(file_id, name, None, node.syntax(), None, None)\n+                let (file_id, text_range) = find_range_from_node(db, src.file_id, node.syntax());\n+\n+                NavigationTarget::from_syntax(\n+                    file_id,\n+                    name,\n+                    None,\n+                    text_range,\n+                    node.syntax(),\n+                    None,\n+                    None,\n+                )\n+            }\n+            ModuleSource::Module(node) => {\n+                let (file_id, text_range) = find_range_from_node(db, src.file_id, node.syntax());\n+\n+                NavigationTarget::from_syntax(\n+                    file_id,\n+                    name,\n+                    None,\n+                    text_range,\n+                    node.syntax(),\n+                    node.doc_comment_text(),\n+                    node.short_label(),\n+                )\n             }\n-            ModuleSource::Module(node) => NavigationTarget::from_syntax(\n-                file_id,\n-                name,\n-                None,\n-                node.syntax(),\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            ),\n         }\n     }\n \n     pub(crate) fn from_module_to_decl(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n         let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n         if let Some(src) = module.declaration_source(db) {\n-            let file_id = src.file_id.original_file(db);\n+            let (file_id, text_range) = find_range_from_node(db, src.file_id, src.ast.syntax());\n             return NavigationTarget::from_syntax(\n                 file_id,\n                 name,\n                 None,\n+                text_range,\n                 src.ast.syntax(),\n                 src.ast.doc_comment_text(),\n                 src.ast.short_label(),\n@@ -154,13 +188,25 @@ impl NavigationTarget {\n \n     pub(crate) fn from_field(db: &RootDatabase, field: hir::StructField) -> NavigationTarget {\n         let src = field.source(db);\n-        let file_id = src.file_id.original_file(db);\n         match src.ast {\n-            FieldSource::Named(it) => {\n-                NavigationTarget::from_named(file_id, &it, it.doc_comment_text(), it.short_label())\n-            }\n+            FieldSource::Named(it) => NavigationTarget::from_named(\n+                db,\n+                src.file_id,\n+                &it,\n+                it.doc_comment_text(),\n+                it.short_label(),\n+            ),\n             FieldSource::Pos(it) => {\n-                NavigationTarget::from_syntax(file_id, \"\".into(), None, it.syntax(), None, None)\n+                let (file_id, text_range) = find_range_from_node(db, src.file_id, it.syntax());\n+                NavigationTarget::from_syntax(\n+                    file_id,\n+                    \"\".into(),\n+                    None,\n+                    text_range,\n+                    it.syntax(),\n+                    None,\n+                    None,\n+                )\n             }\n         }\n     }\n@@ -172,7 +218,8 @@ impl NavigationTarget {\n     {\n         let src = def.source(db);\n         NavigationTarget::from_named(\n-            src.file_id.original_file(db),\n+            db,\n+            src.file_id,\n             &src.ast,\n             src.ast.doc_comment_text(),\n             src.ast.short_label(),\n@@ -212,10 +259,13 @@ impl NavigationTarget {\n         impl_block: hir::ImplBlock,\n     ) -> NavigationTarget {\n         let src = impl_block.source(db);\n+        let (file_id, text_range) = find_range_from_node(db, src.file_id, src.ast.syntax());\n+\n         NavigationTarget::from_syntax(\n-            src.file_id.original_file(db),\n+            file_id,\n             \"impl\".into(),\n             None,\n+            text_range,\n             src.ast.syntax(),\n             None,\n             None,\n@@ -236,12 +286,7 @@ impl NavigationTarget {\n     pub(crate) fn from_macro_def(db: &RootDatabase, macro_call: hir::MacroDef) -> NavigationTarget {\n         let src = macro_call.source(db);\n         log::debug!(\"nav target {:#?}\", src.ast.syntax());\n-        NavigationTarget::from_named(\n-            src.file_id.original_file(db),\n-            &src.ast,\n-            src.ast.doc_comment_text(),\n-            None,\n-        )\n+        NavigationTarget::from_named(db, src.file_id, &src.ast, src.ast.doc_comment_text(), None)\n     }\n \n     #[cfg(test)]\n@@ -270,21 +315,33 @@ impl NavigationTarget {\n \n     /// Allows `NavigationTarget` to be created from a `NameOwner`\n     pub(crate) fn from_named(\n-        file_id: FileId,\n+        db: &RootDatabase,\n+        file_id: hir::HirFileId,\n         node: &impl ast::NameOwner,\n         docs: Option<String>,\n         description: Option<String>,\n     ) -> NavigationTarget {\n         //FIXME: use `_` instead of empty string\n         let name = node.name().map(|it| it.text().clone()).unwrap_or_default();\n-        let focus_range = node.name().map(|it| it.syntax().text_range());\n-        NavigationTarget::from_syntax(file_id, name, focus_range, node.syntax(), docs, description)\n+        let focus_range = node.name().map(|it| find_range_from_node(db, file_id, it.syntax()).1);\n+        let (file_id, full_range) = find_range_from_node(db, file_id, node.syntax());\n+\n+        NavigationTarget::from_syntax(\n+            file_id,\n+            name,\n+            focus_range,\n+            full_range,\n+            node.syntax(),\n+            docs,\n+            description,\n+        )\n     }\n \n     fn from_syntax(\n         file_id: FileId,\n         name: SmolStr,\n         focus_range: Option<TextRange>,\n+        full_range: TextRange,\n         node: &SyntaxNode,\n         docs: Option<String>,\n         description: Option<String>,\n@@ -293,9 +350,8 @@ impl NavigationTarget {\n             file_id,\n             name,\n             kind: node.kind(),\n-            full_range: node.text_range(),\n+            full_range,\n             focus_range,\n-            // ptr: Some(LocalSyntaxPtr::new(node)),\n             container_name: None,\n             description,\n             docs,"}, {"sha": "afa59cbe3ac3a6e8f0af17d2239615ad2f3b3901", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 64, "deletions": 13, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=561bb979cecd786f5d311ea7bddb1e15d77a3848", "patch": "@@ -101,99 +101,110 @@ pub(crate) fn name_definition(\n         }\n     }\n \n-    if let Some(nav) = named_target(file_id, &parent) {\n+    if let Some(nav) = named_target(db, file_id, &parent) {\n         return Some(vec![nav]);\n     }\n \n     None\n }\n \n-fn named_target(file_id: FileId, node: &SyntaxNode) -> Option<NavigationTarget> {\n+fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option<NavigationTarget> {\n     match_ast! {\n         match node {\n             ast::StructDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::EnumDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::EnumVariant(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::FnDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::TypeAliasDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::ConstDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::StaticDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::TraitDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::RecordFieldDef(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::Module(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::MacroCall(it) => {\n                 Some(NavigationTarget::from_named(\n-                    file_id,\n+                    db,\n+                    file_id.into(),\n                     &it,\n                     it.doc_comment_text(),\n                     None,\n@@ -334,6 +345,46 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn goto_definition_works_for_macro_defined_fn_with_arg() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            macro_rules! define_fn {\n+                ($name:ident) => (fn $name() {})\n+            }\n+\n+            define_fn!(\n+                foo\n+            )\n+\n+            fn bar() {\n+               <|>foo();\n+            }\n+            \",\n+            \"foo FN_DEF FileId(1) [80; 83) [80; 83)\",\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_definition_works_for_macro_defined_fn_no_arg() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            macro_rules! define_fn {\n+                () => (fn foo() {})\n+            }\n+\n+            define_fn!();\n+\n+            fn bar() {\n+               <|>foo();\n+            }\n+            \",\n+            \"foo FN_DEF FileId(1) [39; 42) [39; 42)\",\n+        );\n+    }\n+\n     #[test]\n     fn goto_definition_works_for_methods() {\n         covers!(goto_definition_works_for_methods);"}, {"sha": "1bb27eb8512345760ce173f3ae44c3fba35833ac", "filename": "crates/ra_ide_api/src/status.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs?ref=561bb979cecd786f5d311ea7bddb1e15d77a3848", "patch": "@@ -94,10 +94,10 @@ impl FromIterator<TableEntry<FileId, Parse<ast::SourceFile>>> for SyntaxTreeStat\n     }\n }\n \n-impl FromIterator<TableEntry<MacroFile, Option<Parse<SyntaxNode>>>> for SyntaxTreeStats {\n+impl<M> FromIterator<TableEntry<MacroFile, Option<(Parse<SyntaxNode>, M)>>> for SyntaxTreeStats {\n     fn from_iter<T>(iter: T) -> SyntaxTreeStats\n     where\n-        T: IntoIterator<Item = TableEntry<MacroFile, Option<Parse<SyntaxNode>>>>,\n+        T: IntoIterator<Item = TableEntry<MacroFile, Option<(Parse<SyntaxNode>, M)>>>,\n     {\n         let mut res = SyntaxTreeStats::default();\n         for entry in iter {"}, {"sha": "70a289f099c1718694cab893a327a5d938179602", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=561bb979cecd786f5d311ea7bddb1e15d77a3848", "patch": "@@ -32,7 +32,7 @@ pub enum ExpandError {\n \n pub use crate::syntax_bridge::{\n     ast_to_token_tree, syntax_node_to_token_tree, token_tree_to_expr, token_tree_to_items,\n-    token_tree_to_macro_stmts, token_tree_to_pat, token_tree_to_ty,\n+    token_tree_to_macro_stmts, token_tree_to_pat, token_tree_to_ty, RevTokenMap, TokenMap,\n };\n \n /// This struct contains AST for a single `macro_rules` definition. What might\n@@ -118,6 +118,10 @@ impl MacroRules {\n         shift_subtree(&mut tt, self.shift);\n         mbe_expander::expand(self, &tt)\n     }\n+\n+    pub fn shift(&self) -> u32 {\n+        self.shift\n+    }\n }\n \n impl Rule {"}, {"sha": "9653f7fef784bae7b1e9c19b48e9f2cdac479deb", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 53, "deletions": 30, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=561bb979cecd786f5d311ea7bddb1e15d77a3848", "patch": "@@ -14,12 +14,18 @@ use crate::subtree_source::SubtreeTokenSource;\n use crate::ExpandError;\n \n /// Maps `tt::TokenId` to the relative range of the original token.\n-#[derive(Default)]\n+#[derive(Debug, PartialEq, Eq, Default)]\n pub struct TokenMap {\n     /// Maps `tt::TokenId` to the *relative* source range.\n     tokens: Vec<TextRange>,\n }\n \n+/// Maps relative range of the expanded syntax node to `tt::TokenId`\n+#[derive(Debug, PartialEq, Eq, Default)]\n+pub struct RevTokenMap {\n+    pub ranges: Vec<(TextRange, tt::TokenId)>,\n+}\n+\n /// Convert the syntax tree (what user has written) to a `TokenTree` (what macro\n /// will consume).\n pub fn ast_to_token_tree(ast: &ast::TokenTree) -> Option<(tt::Subtree, TokenMap)> {\n@@ -52,7 +58,7 @@ pub fn syntax_node_to_token_tree(node: &SyntaxNode) -> Option<(tt::Subtree, Toke\n fn fragment_to_syntax_node(\n     tt: &tt::Subtree,\n     fragment_kind: FragmentKind,\n-) -> Result<Parse<SyntaxNode>, ExpandError> {\n+) -> Result<(Parse<SyntaxNode>, RevTokenMap), ExpandError> {\n     let tmp;\n     let tokens = match tt {\n         tt::Subtree { delimiter: tt::Delimiter::None, token_trees } => token_trees.as_slice(),\n@@ -69,38 +75,33 @@ fn fragment_to_syntax_node(\n         return Err(ExpandError::ConversionError);\n     }\n     //FIXME: would be cool to report errors\n-    let parse = tree_sink.inner.finish();\n-    Ok(parse)\n+    let (parse, range_map) = tree_sink.finish();\n+    Ok((parse, range_map))\n }\n \n-/// Parses the token tree (result of macro expansion) to an expression\n-pub fn token_tree_to_expr(tt: &tt::Subtree) -> Result<Parse<ast::Expr>, ExpandError> {\n-    let parse = fragment_to_syntax_node(tt, Expr)?;\n-    parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n-}\n-\n-/// Parses the token tree (result of macro expansion) to a Pattern\n-pub fn token_tree_to_pat(tt: &tt::Subtree) -> Result<Parse<ast::Pat>, ExpandError> {\n-    let parse = fragment_to_syntax_node(tt, Pattern)?;\n-    parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n-}\n-\n-/// Parses the token tree (result of macro expansion) to a Type\n-pub fn token_tree_to_ty(tt: &tt::Subtree) -> Result<Parse<ast::TypeRef>, ExpandError> {\n-    let parse = fragment_to_syntax_node(tt, Type)?;\n-    parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n-}\n-\n-/// Parses the token tree (result of macro expansion) as a sequence of stmts\n-pub fn token_tree_to_macro_stmts(tt: &tt::Subtree) -> Result<Parse<ast::MacroStmts>, ExpandError> {\n-    let parse = fragment_to_syntax_node(tt, Statements)?;\n-    parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n+macro_rules! impl_token_tree_conversions {\n+    ($($(#[$attr:meta])* $name:ident => ($kind:ident, $t:ty) ),*) => {\n+        $(\n+            $(#[$attr])*\n+            pub fn $name(tt: &tt::Subtree) -> Result<(Parse<$t>, RevTokenMap), ExpandError> {\n+                let (parse, map) = fragment_to_syntax_node(tt, $kind)?;\n+                parse.cast().ok_or_else(|| crate::ExpandError::ConversionError).map(|p| (p, map))\n+            }\n+        )*\n+    }\n }\n \n-/// Parses the token tree (result of macro expansion) as a sequence of items\n-pub fn token_tree_to_items(tt: &tt::Subtree) -> Result<Parse<ast::MacroItems>, ExpandError> {\n-    let parse = fragment_to_syntax_node(tt, Items)?;\n-    parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n+impl_token_tree_conversions! {\n+    /// Parses the token tree (result of macro expansion) to an expression\n+    token_tree_to_expr => (Expr, ast::Expr),\n+    /// Parses the token tree (result of macro expansion) to a Pattern\n+    token_tree_to_pat => (Pattern, ast::Pat),\n+    /// Parses the token tree (result of macro expansion) to a Type\n+    token_tree_to_ty => (Type, ast::TypeRef),\n+    /// Parses the token tree (result of macro expansion) as a sequence of stmts\n+    token_tree_to_macro_stmts => (Statements, ast::MacroStmts),\n+    /// Parses the token tree (result of macro expansion) as a sequence of items\n+    token_tree_to_items => (Items, ast::MacroItems)\n }\n \n impl TokenMap {\n@@ -116,6 +117,12 @@ impl TokenMap {\n     }\n }\n \n+impl RevTokenMap {\n+    fn add(&mut self, relative_range: TextRange, token_id: tt::TokenId) {\n+        self.ranges.push((relative_range, token_id.clone()))\n+    }\n+}\n+\n /// Returns the textual content of a doc comment block as a quoted string\n /// That is, strips leading `///` (or `/**`, etc)\n /// and strips the ending `*/`\n@@ -262,6 +269,7 @@ struct TtTreeSink<'a> {\n     cursor: Cursor<'a>,\n     text_pos: TextUnit,\n     inner: SyntaxTreeBuilder,\n+    range_map: RevTokenMap,\n \n     // Number of roots\n     // Use for detect ill-form tree which is not single root\n@@ -276,8 +284,13 @@ impl<'a> TtTreeSink<'a> {\n             text_pos: 0.into(),\n             inner: SyntaxTreeBuilder::default(),\n             roots: smallvec::SmallVec::new(),\n+            range_map: RevTokenMap::default(),\n         }\n     }\n+\n+    fn finish(self) -> (Parse<SyntaxNode>, RevTokenMap) {\n+        (self.inner.finish(), self.range_map)\n+    }\n }\n \n fn delim_to_str(d: tt::Delimiter, closing: bool) -> SmolStr {\n@@ -307,6 +320,15 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n \n             match self.cursor.token_tree() {\n                 Some(tt::TokenTree::Leaf(leaf)) => {\n+                    // Mark the range if needed\n+                    if let tt::Leaf::Ident(ident) = leaf {\n+                        if kind == IDENT {\n+                            let range =\n+                                TextRange::offset_len(self.text_pos, TextUnit::of_str(&ident.text));\n+                            self.range_map.add(range, ident.id);\n+                        }\n+                    }\n+\n                     self.cursor = self.cursor.bump();\n                     self.buf += &format!(\"{}\", leaf);\n                 }\n@@ -337,6 +359,7 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n         {\n             if curr.spacing == tt::Spacing::Alone {\n                 self.inner.token(WHITESPACE, \" \".into());\n+                self.text_pos += TextUnit::of_char(' ');\n             }\n         }\n     }"}, {"sha": "a848ea3347ac611d00bf06c7970d5e7c1deabfa5", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561bb979cecd786f5d311ea7bddb1e15d77a3848/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=561bb979cecd786f5d311ea7bddb1e15d77a3848", "patch": "@@ -126,7 +126,7 @@ fn test_expr_order() {\n \"#,\n     );\n     let expanded = expand(&rules, \"foo! { 1 + 1}\");\n-    let tree = token_tree_to_items(&expanded).unwrap().tree();\n+    let tree = token_tree_to_items(&expanded).unwrap().0.tree();\n \n     let dump = format!(\"{:#?}\", tree.syntax());\n     assert_eq_text!(\n@@ -383,7 +383,7 @@ fn test_expand_to_item_list() {\n             \",\n     );\n     let expansion = expand(&rules, \"structs!(Foo, Bar);\");\n-    let tree = token_tree_to_items(&expansion).unwrap().tree();\n+    let tree = token_tree_to_items(&expansion).unwrap().0.tree();\n     assert_eq!(\n         format!(\"{:#?}\", tree.syntax()).trim(),\n         r#\"\n@@ -501,7 +501,7 @@ fn test_tt_to_stmts() {\n     );\n \n     let expanded = expand(&rules, \"foo!{}\");\n-    let stmts = token_tree_to_macro_stmts(&expanded).unwrap().tree();\n+    let stmts = token_tree_to_macro_stmts(&expanded).unwrap().0.tree();\n \n     assert_eq!(\n         format!(\"{:#?}\", stmts.syntax()).trim(),\n@@ -946,7 +946,7 @@ fn test_vec() {\n     );\n \n     let expansion = expand(&rules, r#\"vec![1u32,2];\"#);\n-    let tree = token_tree_to_expr(&expansion).unwrap().tree();\n+    let tree = token_tree_to_expr(&expansion).unwrap().0.tree();\n \n     assert_eq!(\n         format!(\"{:#?}\", tree.syntax()).trim(),\n@@ -1436,8 +1436,8 @@ pub(crate) fn assert_expansion(\n     };\n     let (expanded_tree, expected_tree) = match kind {\n         MacroKind::Items => {\n-            let expanded_tree = token_tree_to_items(&expanded).unwrap().tree();\n-            let expected_tree = token_tree_to_items(&expected).unwrap().tree();\n+            let expanded_tree = token_tree_to_items(&expanded).unwrap().0.tree();\n+            let expected_tree = token_tree_to_items(&expected).unwrap().0.tree();\n \n             (\n                 debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n@@ -1446,8 +1446,8 @@ pub(crate) fn assert_expansion(\n         }\n \n         MacroKind::Stmts => {\n-            let expanded_tree = token_tree_to_macro_stmts(&expanded).unwrap().tree();\n-            let expected_tree = token_tree_to_macro_stmts(&expected).unwrap().tree();\n+            let expanded_tree = token_tree_to_macro_stmts(&expanded).unwrap().0.tree();\n+            let expected_tree = token_tree_to_macro_stmts(&expected).unwrap().0.tree();\n \n             (\n                 debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),"}]}