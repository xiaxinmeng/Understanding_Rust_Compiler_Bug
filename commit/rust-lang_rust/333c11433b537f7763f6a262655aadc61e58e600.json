{"sha": "333c11433b537f7763f6a262655aadc61e58e600", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzM2MxMTQzM2I1MzdmNzc2M2Y2YTI2MjY1NWFhZGM2MWU1OGU2MDA=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-09T21:57:25Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-17T21:37:15Z"}, "message": "Derive HashStable in librustc_target.", "tree": {"sha": "30ea4ff648c5ece46f8af0d7c88900725c764268", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30ea4ff648c5ece46f8af0d7c88900725c764268"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/333c11433b537f7763f6a262655aadc61e58e600", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/333c11433b537f7763f6a262655aadc61e58e600", "html_url": "https://github.com/rust-lang/rust/commit/333c11433b537f7763f6a262655aadc61e58e600", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/333c11433b537f7763f6a262655aadc61e58e600/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ba84c6bea8ce018d81b3eb2ef923aeb996f02f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba84c6bea8ce018d81b3eb2ef923aeb996f02f0", "html_url": "https://github.com/rust-lang/rust/commit/2ba84c6bea8ce018d81b3eb2ef923aeb996f02f0"}], "stats": {"total": 219, "additions": 59, "deletions": 160}, "files": [{"sha": "1400d5fb899ab899dd9c2eb24897fcd5fde12289", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/333c11433b537f7763f6a262655aadc61e58e600/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333c11433b537f7763f6a262655aadc61e58e600/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=333c11433b537f7763f6a262655aadc61e58e600", "patch": "@@ -2327,158 +2327,6 @@ where\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        use crate::ty::layout::Variants::*;\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            Single { index } => {\n-                index.hash_stable(hcx, hasher);\n-            }\n-            Multiple {\n-                ref discr,\n-                ref discr_kind,\n-                discr_index,\n-                ref variants,\n-            } => {\n-                discr.hash_stable(hcx, hasher);\n-                discr_kind.hash_stable(hcx, hasher);\n-                discr_index.hash_stable(hcx, hasher);\n-                variants.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for DiscriminantKind {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        use crate::ty::layout::DiscriminantKind::*;\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            Tag => {}\n-            Niche {\n-                dataful_variant,\n-                ref niche_variants,\n-                niche_start,\n-            } => {\n-                dataful_variant.hash_stable(hcx, hasher);\n-                niche_variants.start().hash_stable(hcx, hasher);\n-                niche_variants.end().hash_stable(hcx, hasher);\n-                niche_start.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for FieldPlacement {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        use crate::ty::layout::FieldPlacement::*;\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            Union(count) => {\n-                count.hash_stable(hcx, hasher);\n-            }\n-            Array { count, stride } => {\n-                count.hash_stable(hcx, hasher);\n-                stride.hash_stable(hcx, hasher);\n-            }\n-            Arbitrary { ref offsets, ref memory_index } => {\n-                offsets.hash_stable(hcx, hasher);\n-                memory_index.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for VariantIdx {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.as_u32().hash_stable(hcx, hasher)\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for Abi {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        use crate::ty::layout::Abi::*;\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            Uninhabited => {}\n-            Scalar(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            ScalarPair(ref a, ref b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-            }\n-            Vector { ref element, count } => {\n-                element.hash_stable(hcx, hasher);\n-                count.hash_stable(hcx, hasher);\n-            }\n-            Aggregate { sized } => {\n-                sized.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let Scalar { value, ref valid_range } = *self;\n-        value.hash_stable(hcx, hasher);\n-        valid_range.start().hash_stable(hcx, hasher);\n-        valid_range.end().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl_stable_hash_for!(struct crate::ty::layout::Niche {\n-    offset,\n-    scalar\n-});\n-\n-impl_stable_hash_for!(struct crate::ty::layout::LayoutDetails {\n-    variants,\n-    fields,\n-    abi,\n-    largest_niche,\n-    size,\n-    align\n-});\n-\n-impl_stable_hash_for!(enum crate::ty::layout::Integer {\n-    I8,\n-    I16,\n-    I32,\n-    I64,\n-    I128\n-});\n-\n-impl_stable_hash_for!(enum crate::ty::layout::Primitive {\n-    Int(integer, signed),\n-    F32,\n-    F64,\n-    Pointer\n-});\n-\n-impl_stable_hash_for!(struct crate::ty::layout::AbiAndPrefAlign {\n-    abi,\n-    pref\n-});\n-\n-impl<'tcx> HashStable<StableHashingContext<'tcx>> for Align {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n-        self.bytes().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'tcx> HashStable<StableHashingContext<'tcx>> for Size {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n-        self.bytes().hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::LayoutError::*;"}, {"sha": "ff13218831c0cc72c59ada28cebd0d6604b2d50d", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/333c11433b537f7763f6a262655aadc61e58e600/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333c11433b537f7763f6a262655aadc61e58e600/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=333c11433b537f7763f6a262655aadc61e58e600", "patch": "@@ -6,6 +6,8 @@ use crate::spec::Target;\n use std::ops::{Add, Deref, Sub, Mul, AddAssign, Range, RangeInclusive};\n \n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_macros::HashStable_Generic;\n use syntax_pos::Span;\n \n pub mod call;\n@@ -246,6 +248,12 @@ pub struct Size {\n     raw: u64\n }\n \n+impl<CTX> HashStable<CTX> for Size {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.bytes().hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl Size {\n     pub const ZERO: Size = Self::from_bytes(0);\n \n@@ -369,6 +377,12 @@ pub struct Align {\n     pow2: u8,\n }\n \n+impl<CTX> HashStable<CTX> for Align {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.bytes().hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl Align {\n     pub fn from_bits(bits: u64) -> Result<Align, String> {\n         Align::from_bytes(Size::from_bits(bits).bytes())\n@@ -422,7 +436,8 @@ impl Align {\n }\n \n /// A pair of aligments, ABI-mandated and preferred.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug,\n+         RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub struct AbiAndPrefAlign {\n     pub abi: Align,\n     pub pref: Align,\n@@ -452,7 +467,7 @@ impl AbiAndPrefAlign {\n }\n \n /// Integers, also used for enum discriminants.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, HashStable_Generic)]\n pub enum Integer {\n     I8,\n     I16,\n@@ -533,7 +548,7 @@ impl Integer {\n }\n \n /// Fundamental unit of memory access and layout.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum Primitive {\n     /// The `bool` is the signedness of the `Integer` type.\n     ///\n@@ -608,6 +623,15 @@ pub struct Scalar {\n     pub valid_range: RangeInclusive<u128>,\n }\n \n+impl<CTX> HashStable<CTX> for Scalar {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        let Scalar { value, ref valid_range } = *self;\n+        value.hash_stable(hcx, hasher);\n+        valid_range.start().hash_stable(hcx, hasher);\n+        valid_range.end().hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl Scalar {\n     pub fn is_bool(&self) -> bool {\n         if let Int(I8, _) = self.value {\n@@ -636,7 +660,7 @@ impl Scalar {\n }\n \n /// Describes how the fields of a type are located in memory.\n-#[derive(PartialEq, Eq, Hash, Debug)]\n+#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum FieldPlacement {\n     /// All fields start at no offset. The `usize` is the field count.\n     ///\n@@ -752,7 +776,7 @@ impl FieldPlacement {\n \n /// Describes how values of the type are passed by target ABIs,\n /// in terms of categories of C types there are ABI rules for.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum Abi {\n     Uninhabited,\n     Scalar(Scalar),\n@@ -803,7 +827,13 @@ rustc_index::newtype_index! {\n     pub struct VariantIdx { .. }\n }\n \n-#[derive(PartialEq, Eq, Hash, Debug)]\n+impl<CTX> HashStable<CTX> for VariantIdx {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.as_u32().hash_stable(hcx, hasher)\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum Variants {\n     /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n     Single {\n@@ -842,7 +872,28 @@ pub enum DiscriminantKind {\n     },\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+impl<CTX> HashStable<CTX> for DiscriminantKind {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        use DiscriminantKind::*;\n+        std::mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            Tag => {}\n+            Niche {\n+                dataful_variant,\n+                ref niche_variants,\n+                niche_start,\n+            } => {\n+                dataful_variant.hash_stable(hcx, hasher);\n+                niche_variants.start().hash_stable(hcx, hasher);\n+                niche_variants.end().hash_stable(hcx, hasher);\n+                niche_start.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct Niche {\n     pub offset: Size,\n     pub scalar: Scalar,\n@@ -906,7 +957,7 @@ impl Niche {\n     }\n }\n \n-#[derive(PartialEq, Eq, Hash, Debug)]\n+#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct LayoutDetails {\n     pub variants: Variants,\n     pub fields: FieldPlacement,"}]}