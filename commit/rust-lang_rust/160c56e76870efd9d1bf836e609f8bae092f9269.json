{"sha": "160c56e76870efd9d1bf836e609f8bae092f9269", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MGM1NmU3Njg3MGVmZDlkMWJmODM2ZTYwOWY4YmFlMDkyZjkyNjk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-22T00:35:52Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-22T00:35:52Z"}, "message": "Get 'make tidy' to work rustllvm and rt again", "tree": {"sha": "74eff2bcf46a2158bf61548fb5006dd5ccb8e397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74eff2bcf46a2158bf61548fb5006dd5ccb8e397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/160c56e76870efd9d1bf836e609f8bae092f9269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/160c56e76870efd9d1bf836e609f8bae092f9269", "html_url": "https://github.com/rust-lang/rust/commit/160c56e76870efd9d1bf836e609f8bae092f9269", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/160c56e76870efd9d1bf836e609f8bae092f9269/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93d940de54cc90ea7bd5fecd3970d2466988199b", "url": "https://api.github.com/repos/rust-lang/rust/commits/93d940de54cc90ea7bd5fecd3970d2466988199b", "html_url": "https://github.com/rust-lang/rust/commit/93d940de54cc90ea7bd5fecd3970d2466988199b"}], "stats": {"total": 290, "additions": 145, "deletions": 145}, "files": [{"sha": "2cf3c28bd92bb38f8beab0eacb6b6cd058eb77d6", "filename": "mk/tests.mk", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/160c56e76870efd9d1bf836e609f8bae092f9269/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/160c56e76870efd9d1bf836e609f8bae092f9269/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=160c56e76870efd9d1bf836e609f8bae092f9269", "patch": "@@ -82,18 +82,17 @@ check-fast: tidy \\\n tidy:\n \t@$(call E, check: formatting)\n \t$(Q)echo \\\n-\t  $(filter-out $(GENERATED) $(addprefix $(S)src/, $(GENERATED)) \\\n \t    $(addprefix $(S)src/, $(RUSTLLVM_LIB_CS) $(RUSTLLVM_OBJS_CS) \\\n-\t      $(RUSTLLVM_HDR) $(PKG_3RDPARTY) \\\n+\t      $(RUSTLLVM_HDR) \\\n               $(RUNTIME_CS) $(RUNTIME_HDR) $(RUNTIME_S)) \\\n-            $(S)src/etc/%,  \\\n+            $(wildcard $(S)src/etc/*.py)  \\\n             $(COMPILER_CRATE) \\\n             $(COMPILER_INPUTS) \\\n             $(STDLIB_CRATE) \\\n             $(STDLIB_INPUTS) \\\n             $(COMPILETEST_CRATE) \\\n             $(COMPILETEST_INPUTS) \\\n-            $(ALL_TEST_INPUTS)) \\\n+            $(ALL_TEST_INPUTS) \\\n \t  | xargs -n 10 python $(S)src/etc/tidy.py\n \n "}, {"sha": "fb9df4a99007cc229f07e8687e71894cb4390479", "filename": "src/rt/arch/i386/_context.S", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/160c56e76870efd9d1bf836e609f8bae092f9269/src%2Frt%2Farch%2Fi386%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/160c56e76870efd9d1bf836e609f8bae092f9269/src%2Frt%2Farch%2Fi386%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2F_context.S?ref=160c56e76870efd9d1bf836e609f8bae092f9269", "patch": "@@ -1,76 +1,76 @@\n-\t.text\n+        .text\n \n /*\n Callee save registers:\n-\tebp, ebx, esi, edi\n+        ebp, ebx, esi, edi\n \n Caller save registers:\n-\teax, ecx, edx\n+        eax, ecx, edx\n */\n-\t\n+\n /*\n Saves a set of registers. This is used by our implementation of\n getcontext.\n \n The registers_t variable is in (%esp)\n-*/\t\n+*/\n \n // swap_registers(registers_t *oregs, registers_t *regs)\n .globl swap_registers\n swap_registers:\n     // save the old context\n     movl 4(%esp), %eax\n-\t//movl %eax, 0(%eax)\n-\tmovl %ebx, 4(%eax)\n-\tmovl %ecx, 8(%eax)\n-\tmovl %edx, 12(%eax)\n-\tmovl %ebp, 16(%eax)\n-\tmovl %esi, 20(%eax)\n-\tmovl %edi, 24(%eax)\n-\t//movl %cs, 32(%eax)\n-\t//movl %ds, 34(%eax)\n-\t//movl %ss, 36(%eax)\n-\t//movl %es, 38(%eax)\n-\t//movl %fs, 40(%eax)\n-\t//movl %gs, 42(%eax)\n+        //movl %eax, 0(%eax)\n+        movl %ebx, 4(%eax)\n+        movl %ecx, 8(%eax)\n+        movl %edx, 12(%eax)\n+        movl %ebp, 16(%eax)\n+        movl %esi, 20(%eax)\n+        movl %edi, 24(%eax)\n+        //movl %cs, 32(%eax)\n+        //movl %ds, 34(%eax)\n+        //movl %ss, 36(%eax)\n+        //movl %es, 38(%eax)\n+        //movl %fs, 40(%eax)\n+        //movl %gs, 42(%eax)\n \n-\t// save the flags\n-\tpushf\n-\tpopl %ecx\n-\tmovl %ecx, 44(%eax)\n+        // save the flags\n+        pushf\n+        popl %ecx\n+        movl %ecx, 44(%eax)\n \n-\t// save the return address as the instruction pointer\n+        // save the return address as the instruction pointer\n     // and save the stack pointer of the caller\n     popl %ecx\n     movl %esp, 28(%eax)\n-\tmovl %ecx, 48(%eax)\n+        movl %ecx, 48(%eax)\n \n     // restore the new context\n     movl 4(%esp), %eax\n \n-\tmovl 4(%eax), %ebx\n-\t// save ecx for later...\n-\tmovl 12(%eax), %edx\n-\tmovl 16(%eax), %ebp\n-\tmovl 20(%eax), %esi\n-\tmovl 24(%eax), %edi\n-\tmovl 28(%eax), %esp\n-\t// We can't actually change this...\n-\t//movl 32(%eax), %cs\n-\t//movl 34(%eax), %ds\n-\t//movl 36(%eax), %ss\n-\t//movl 38(%eax), %es\n-\t//movl 40(%eax), %fs\n-\t//movl 42(%eax), %gs\n+        movl 4(%eax), %ebx\n+        // save ecx for later...\n+        movl 12(%eax), %edx\n+        movl 16(%eax), %ebp\n+        movl 20(%eax), %esi\n+        movl 24(%eax), %edi\n+        movl 28(%eax), %esp\n+        // We can't actually change this...\n+        //movl 32(%eax), %cs\n+        //movl 34(%eax), %ds\n+        //movl 36(%eax), %ss\n+        //movl 38(%eax), %es\n+        //movl 40(%eax), %fs\n+        //movl 42(%eax), %gs\n \n-\t// restore the flags\n-\tmovl 44(%eax), %ecx\n-\tpush %ecx\n-\tpopf\n+        // restore the flags\n+        movl 44(%eax), %ecx\n+        push %ecx\n+        popf\n \n     // ok, now we can restore ecx\n     movl 8(%eax), %ecx\n-\t\n+\n     // Return!\n     jmp *48(%eax)\n "}, {"sha": "bf872700f0ecc408f3cddfdfd72dcc97ac59577d", "filename": "src/rt/rust_cc.cpp", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/160c56e76870efd9d1bf836e609f8bae092f9269/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/160c56e76870efd9d1bf836e609f8bae092f9269/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=160c56e76870efd9d1bf836e609f8bae092f9269", "patch": "@@ -95,19 +95,19 @@ class irc : public shape::data<irc,shape::ptr> {\n     }\n \n     void walk_fn() {\n-\t// Record an irc for the environment box, but don't descend\n-\t// into it since it will be walked via the box's allocation\n-\tdp += sizeof(void *); // skip code pointer\n-\tuint8_t * box_ptr = shape::bump_dp<uint8_t *>(dp);\n-\tshape::ptr ref_count_dp(box_ptr);\n-\tmaybe_record_irc(ref_count_dp);\n+        // Record an irc for the environment box, but don't descend\n+        // into it since it will be walked via the box's allocation\n+        dp += sizeof(void *); // skip code pointer\n+        uint8_t * box_ptr = shape::bump_dp<uint8_t *>(dp);\n+        shape::ptr ref_count_dp(box_ptr);\n+        maybe_record_irc(ref_count_dp);\n     }\n \n     void walk_obj() {\n-\tdp += sizeof(void *); // skip vtable\n-\tuint8_t *box_ptr = shape::bump_dp<uint8_t *>(dp);\n-\tshape::ptr ref_count_dp(box_ptr);\n-\tmaybe_record_irc(ref_count_dp);\n+        dp += sizeof(void *); // skip vtable\n+        uint8_t *box_ptr = shape::bump_dp<uint8_t *>(dp);\n+        shape::ptr ref_count_dp(box_ptr);\n+        maybe_record_irc(ref_count_dp);\n     }\n \n     void walk_res(const shape::rust_fn *dtor, unsigned n_params,\n@@ -122,7 +122,7 @@ class irc : public shape::data<irc,shape::ptr> {\n     void walk_subcontext(irc &sub) { sub.walk(); }\n \n     void walk_box_contents(irc &sub, shape::ptr &ref_count_dp) {\n-\tmaybe_record_irc(ref_count_dp);\n+        maybe_record_irc(ref_count_dp);\n \n         // Do not traverse the contents of this box; it's in the allocation\n         // somewhere, so we're guaranteed to come back to it (if we haven't\n@@ -133,19 +133,19 @@ class irc : public shape::data<irc,shape::ptr> {\n         if (!ref_count_dp)\n             return;\n \n-\t// Bump the internal reference count of the box.\n-\tif (ircs.find((void *)ref_count_dp) == ircs.end()) {\n-\t  LOG(task, gc,\n-\t      \"setting internal reference count for %p to 1\",\n-\t      (void *)ref_count_dp);\n-\t  ircs[(void *)ref_count_dp] = 1;\n-\t} else {\n-\t  uintptr_t newcount = ircs[(void *)ref_count_dp] + 1;\n-\t  LOG(task, gc,\n-\t      \"bumping internal reference count for %p to %lu\",\n-\t      (void *)ref_count_dp, newcount);\n-\t  ircs[(void *)ref_count_dp] = newcount;\n-\t}\n+        // Bump the internal reference count of the box.\n+        if (ircs.find((void *)ref_count_dp) == ircs.end()) {\n+          LOG(task, gc,\n+              \"setting internal reference count for %p to 1\",\n+              (void *)ref_count_dp);\n+          ircs[(void *)ref_count_dp] = 1;\n+        } else {\n+          uintptr_t newcount = ircs[(void *)ref_count_dp] + 1;\n+          LOG(task, gc,\n+              \"bumping internal reference count for %p to %lu\",\n+              (void *)ref_count_dp, newcount);\n+          ircs[(void *)ref_count_dp] = newcount;\n+        }\n     }\n \n     void walk_struct(const uint8_t *end_sp) {\n@@ -191,7 +191,7 @@ irc::compute_ircs(rust_task *task, irc_map &ircs) {\n         const type_desc *tydesc = begin->second;\n \n         LOG(task, gc, \"determining internal ref counts: %p, tydesc=%p\", p,\n-\t    tydesc);\n+            tydesc);\n \n         shape::arena arena;\n         shape::type_param *params =\n@@ -237,12 +237,12 @@ find_roots(rust_task *task, irc_map &ircs, std::vector<void *> &roots) {\n         if (irc < ref_count) {\n             // This allocation must be a root, because the internal reference\n             // count is smaller than the total reference count.\n-\t    LOG(task, gc,\"root found: %p, irc %lu, ref count %lu\",\n-\t\talloc, irc, ref_count);\n+            LOG(task, gc,\"root found: %p, irc %lu, ref count %lu\",\n+                alloc, irc, ref_count);\n             roots.push_back(alloc);\n         } else {\n             LOG(task, gc, \"nonroot found: %p, irc %lu, ref count %lu\",\n-\t\talloc, irc, ref_count);\n+                alloc, irc, ref_count);\n             assert(irc == ref_count && \"Internal reference count must be \"\n                    \"less than or equal to the total reference count!\");\n         }\n@@ -429,72 +429,72 @@ class sweep : public shape::data<sweep,shape::ptr> {\n     friend class shape::data<sweep,shape::ptr>;\n \n     sweep(const sweep &other, const shape::ptr &in_dp)\n-\t: shape::data<sweep,shape::ptr>(other.task, other.align,\n-\t\t\t\t\tother.sp, other.params,\n-\t\t\t\t\tother.tables, in_dp) {}\n+        : shape::data<sweep,shape::ptr>(other.task, other.align,\n+                                        other.sp, other.params,\n+                                        other.tables, in_dp) {}\n \n     sweep(const sweep &other,\n-\t  const uint8_t *in_sp,\n-\t  const shape::type_param *in_params,\n-\t  const rust_shape_tables *in_tables = NULL)\n-\t: shape::data<sweep,shape::ptr>(other.task,\n-\t\t\t\t\tother.align,\n-\t\t\t\t\tin_sp,\n-\t\t\t\t\tin_params,\n-\t\t\t\t\tin_tables ? in_tables : other.tables,\n-\t\t\t\t\tother.dp) {}\n+          const uint8_t *in_sp,\n+          const shape::type_param *in_params,\n+          const rust_shape_tables *in_tables = NULL)\n+        : shape::data<sweep,shape::ptr>(other.task,\n+                                        other.align,\n+                                        in_sp,\n+                                        in_params,\n+                                        in_tables ? in_tables : other.tables,\n+                                        other.dp) {}\n \n     sweep(const sweep &other,\n-\t  const uint8_t *in_sp,\n-\t  const shape::type_param *in_params,\n-\t  const rust_shape_tables *in_tables,\n-\t  shape::ptr in_dp)\n-\t: shape::data<sweep,shape::ptr>(other.task,\n-\t\t\t\t\tother.align,\n-\t\t\t\t\tin_sp,\n-\t\t\t\t\tin_params,\n-\t\t\t\t\tin_tables,\n-\t\t\t\t\tin_dp) {}\n+          const uint8_t *in_sp,\n+          const shape::type_param *in_params,\n+          const rust_shape_tables *in_tables,\n+          shape::ptr in_dp)\n+        : shape::data<sweep,shape::ptr>(other.task,\n+                                        other.align,\n+                                        in_sp,\n+                                        in_params,\n+                                        in_tables,\n+                                        in_dp) {}\n \n     sweep(rust_task *in_task,\n-\t  bool in_align,\n-\t  const uint8_t *in_sp,\n-\t  const shape::type_param *in_params,\n-\t  const rust_shape_tables *in_tables,\n-\t  uint8_t *in_data)\n-\t: shape::data<sweep,shape::ptr>(in_task, in_align, in_sp,\n-\t\t\t\t\tin_params, in_tables, in_data) {}\n+          bool in_align,\n+          const uint8_t *in_sp,\n+          const shape::type_param *in_params,\n+          const rust_shape_tables *in_tables,\n+          uint8_t *in_data)\n+        : shape::data<sweep,shape::ptr>(in_task, in_align, in_sp,\n+                                        in_params, in_tables, in_data) {}\n \n     void walk_vec(bool is_pod, uint16_t sp_size) {\n-\tvoid *vec = shape::get_dp<void *>(dp);\n-\twalk_vec(is_pod, get_vec_data_range(dp));\n-\ttask->kernel->free(vec);\n+        void *vec = shape::get_dp<void *>(dp);\n+        walk_vec(is_pod, get_vec_data_range(dp));\n+        task->kernel->free(vec);\n     }\n \n     void walk_vec(bool is_pod,\n-\t\t  const std::pair<shape::ptr,shape::ptr> &data_range) {\n-\tsweep sub(*this, data_range.first);\n-\tshape::ptr data_end = sub.end_dp = data_range.second;\n-\twhile (sub.dp < data_end) {\n-\t    sub.walk_reset();\n-\t    sub.align = true;\n-\t}\n+                  const std::pair<shape::ptr,shape::ptr> &data_range) {\n+        sweep sub(*this, data_range.first);\n+        shape::ptr data_end = sub.end_dp = data_range.second;\n+        while (sub.dp < data_end) {\n+            sub.walk_reset();\n+            sub.align = true;\n+        }\n     }\n \n     void walk_tag(shape::tag_info &tinfo, uint32_t tag_variant) {\n         shape::data<sweep,shape::ptr>::walk_variant(tinfo, tag_variant);\n     }\n \n     void walk_box() {\n-\tshape::data<sweep,shape::ptr>::walk_box_contents();\n+        shape::data<sweep,shape::ptr>::walk_box_contents();\n     }\n \n     void walk_fn() {\n-\treturn;\n+        return;\n     }\n \n     void walk_obj() {\n-\treturn;\n+        return;\n     }\n \n     void walk_res(const shape::rust_fn *dtor, unsigned n_params,\n@@ -509,7 +509,7 @@ class sweep : public shape::data<sweep,shape::ptr> {\n     void walk_subcontext(sweep &sub) { sub.walk(); }\n \n     void walk_box_contents(sweep &sub, shape::ptr &ref_count_dp) {\n-\treturn;\n+        return;\n     }\n \n     void walk_struct(const uint8_t *end_sp) {\n@@ -522,13 +522,13 @@ class sweep : public shape::data<sweep,shape::ptr> {\n     void walk_variant(shape::tag_info &tinfo, uint32_t variant_id,\n                       const std::pair<const uint8_t *,const uint8_t *>\n                       variant_ptr_and_end) {\n-\tsweep sub(*this, variant_ptr_and_end.first, tinfo.params);\n+        sweep sub(*this, variant_ptr_and_end.first, tinfo.params);\n \n-\tconst uint8_t *variant_end = variant_ptr_and_end.second;\n-\twhile (sub.sp < variant_end) {\n-\t    sub.walk();\n-\t    align = true;\n-\t}\n+        const uint8_t *variant_end = variant_ptr_and_end.second;\n+        while (sub.sp < variant_end) {\n+            sub.walk();\n+            align = true;\n+        }\n     }\n \n     template<typename T>\n@@ -548,16 +548,16 @@ sweep::do_sweep(rust_task *task, const std::set<void *> &marked) {\n         if (marked.find(alloc) == marked.end()) {\n             LOG(task, gc, \"object is part of a cycle: %p\", alloc);\n \n-\t    const type_desc *tydesc = begin->second;\n+            const type_desc *tydesc = begin->second;\n             uint8_t *p = reinterpret_cast<uint8_t *>(alloc);\n             shape::arena arena;\n             shape::type_param *params =\n                 shape::type_param::from_tydesc_and_data(tydesc, p, arena);\n \n-\t    sweep sweep(task, true, tydesc->shape,\n-\t\t\tparams, tydesc->shape_tables,\n-\t\t\tp + sizeof(uintptr_t));\n-\t    sweep.walk();\n+            sweep sweep(task, true, tydesc->shape,\n+                        params, tydesc->shape_tables,\n+                        p + sizeof(uintptr_t));\n+            sweep.walk();\n \n             // FIXME: Run the destructor, *if* it's a resource.\n             task->free(alloc);\n@@ -570,7 +570,7 @@ sweep::do_sweep(rust_task *task, const std::set<void *> &marked) {\n void\n do_cc(rust_task *task) {\n     LOG(task, gc, \"cc; n allocs = %lu\",\n-\t(long unsigned int)task->local_allocs.size());\n+        (long unsigned int)task->local_allocs.size());\n \n     irc_map ircs;\n     irc::compute_ircs(task, ircs);"}, {"sha": "f002b67224f55770f2080f94468ceecd7e620055", "filename": "src/rustllvm/RustGCMetadataPrinter.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/160c56e76870efd9d1bf836e609f8bae092f9269/src%2Frustllvm%2FRustGCMetadataPrinter.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/160c56e76870efd9d1bf836e609f8bae092f9269/src%2Frustllvm%2FRustGCMetadataPrinter.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustGCMetadataPrinter.cpp?ref=160c56e76870efd9d1bf836e609f8bae092f9269", "patch": "@@ -1,15 +1,15 @@\n-//===-- RustGCPrinter.cpp - Rust garbage collection map printer -----------===//\n+//===-- RustGCPrinter.cpp - Rust garbage collection map printer -----------===\n //\n //                     The LLVM Compiler Infrastructure\n //\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n //\n-//===----------------------------------------------------------------------===//\n+//===----------------------------------------------------------------------===\n //\n // This file defines the emitter for the Rust garbage collection stack maps.\n //\n-//===----------------------------------------------------------------------===//\n+//===----------------------------------------------------------------------===\n \n #include \"llvm/Constants.h\"\n #include \"llvm/DerivedTypes.h\""}, {"sha": "a6645d15a48b5c522c92958fae58e90fc720bb44", "filename": "src/rustllvm/RustGCStrategy.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/160c56e76870efd9d1bf836e609f8bae092f9269/src%2Frustllvm%2FRustGCStrategy.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/160c56e76870efd9d1bf836e609f8bae092f9269/src%2Frustllvm%2FRustGCStrategy.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustGCStrategy.cpp?ref=160c56e76870efd9d1bf836e609f8bae092f9269", "patch": "@@ -1,15 +1,15 @@\n-//===- RustGCStrategy.cpp - Rust garbage collection strategy ----*- C++ -*-===//\n+//===- RustGCStrategy.cpp - Rust garbage collection strategy ----*- C++ -*-===\n //\n //                     The LLVM Compiler Infrastructure\n //\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n //\n-//===----------------------------------------------------------------------===//\n+//===----------------------------------------------------------------------===\n //\n // This file defines the garbage collection strategy for Rust.\n //\n-//===----------------------------------------------------------------------===//\n+//===----------------------------------------------------------------------===\n \n #include \"llvm/CodeGen/GCs.h\"\n #include \"llvm/CodeGen/GCStrategy.h\""}, {"sha": "a1f68c2dd39420907d9e0c9e68cb2d014ab4fe63", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/160c56e76870efd9d1bf836e609f8bae092f9269/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/160c56e76870efd9d1bf836e609f8bae092f9269/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=160c56e76870efd9d1bf836e609f8bae092f9269", "patch": "@@ -1,16 +1,16 @@\n-//===- RustWrapper.cpp - Rust wrapper for core functions --------*- C++ -*-===//\n+//===- RustWrapper.cpp - Rust wrapper for core functions --------*- C++ -*-===\n //\n //                     The LLVM Compiler Infrastructure\n //\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n //\n-//===----------------------------------------------------------------------===//\n+//===----------------------------------------------------------------------===\n //\n // This file defines alternate interfaces to core functions that are more\n // readily callable by Rust's FFI.\n //\n-//===----------------------------------------------------------------------===//\n+//===----------------------------------------------------------------------===\n \n #include \"llvm/Linker.h\"\n #include \"llvm/PassManager.h\"\n@@ -60,12 +60,13 @@ extern \"C\" bool LLVMLinkModules(LLVMModuleRef Dest, LLVMModuleRef Src) {\n   return true;\n }\n \n-extern \"C\" void LLVMRustWriteOutputFile(LLVMPassManagerRef PMR,\n-                                        LLVMModuleRef M,\n-                                        const char *triple,\n-                                        const char *path,\n-                                        TargetMachine::CodeGenFileType FileType,\n-                                        CodeGenOpt::Level OptLevel) {\n+extern \"C\" void\n+LLVMRustWriteOutputFile(LLVMPassManagerRef PMR,\n+                        LLVMModuleRef M,\n+                        const char *triple,\n+                        const char *path,\n+                        TargetMachine::CodeGenFileType FileType,\n+                        CodeGenOpt::Level OptLevel) {\n \n   // Set compilation options.\n   llvm::NoFramePointerElim = true;"}]}