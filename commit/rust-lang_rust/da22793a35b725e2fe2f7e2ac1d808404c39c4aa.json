{"sha": "da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMjI3OTNhMzViNzI1ZTJmZTJmN2UyYWMxZDgwODQwNGMzOWM0YWE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-05-09T22:01:39Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-13T20:05:21Z"}, "message": "Create fewer basic blocks in match MIR lowering", "tree": {"sha": "c48a0a97a0308968e92ebfcc68b5e314c8d3e758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c48a0a97a0308968e92ebfcc68b5e314c8d3e758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "html_url": "https://github.com/rust-lang/rust/commit/da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32c337724dd3a1b651cb7ba9769e60262f9f52f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/32c337724dd3a1b651cb7ba9769e60262f9f52f8", "html_url": "https://github.com/rust-lang/rust/commit/32c337724dd3a1b651cb7ba9769e60262f9f52f8"}], "stats": {"total": 1338, "additions": 685, "deletions": 653}, "files": [{"sha": "521aca56108a606477f214180d24a3c1b949511c", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 111, "deletions": 118, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -206,33 +206,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             .flat_map(|(_, candidates)| candidates)\n             .collect::<Vec<_>>();\n \n+        let outer_source_info = self.source_info(span);\n+\n         // this will generate code to test scrutinee_place and\n         // branch to the appropriate arm block\n-        let otherwise = self.match_candidates(\n+        self.match_candidates(\n             scrutinee_span,\n+            &mut Some(block),\n+            None,\n             candidates,\n-            block,\n             &mut fake_borrows,\n         );\n \n-        let outer_source_info = self.source_info(span);\n-\n-        if !otherwise.is_empty() {\n-            // All matches are exhaustive. However, because some matches\n-            // only have exponentially-large exhaustive decision trees, we\n-            // sometimes generate an inexhaustive decision tree.\n-            //\n-            // In that case, the inexhaustive tips of the decision tree\n-            // can't be reached - terminate them with an `unreachable`.\n-            let mut otherwise = otherwise;\n-            otherwise.sort();\n-            otherwise.dedup(); // variant switches can introduce duplicate target blocks\n-            for block in otherwise {\n-                self.cfg\n-                    .terminate(block, outer_source_info, TerminatorKind::Unreachable);\n-            }\n-        }\n-\n         // Step 4. Determine the fake borrows that are needed from the above\n         // places. Create the required temporaries for them.\n \n@@ -247,8 +232,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let arm_source_info = self.source_info(arm.span);\n             let region_scope = (arm.scope, arm_source_info);\n             self.in_scope(region_scope, arm.lint_level, |this| {\n-                let mut arm_block = this.cfg.start_new_block();\n-\n                 let body = this.hir.mirror(arm.body.clone());\n                 let scope = this.declare_bindings(\n                     None,\n@@ -258,23 +241,27 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Some((Some(&scrutinee_place), scrutinee_span)),\n                 );\n \n+                let arm_block;\n                 if candidates.len() == 1 {\n-                    arm_block = self.bind_and_guard_matched_candidate(\n+                    arm_block = this.bind_and_guard_matched_candidate(\n                         candidates.pop().unwrap(),\n                         arm.guard.clone(),\n                         &fake_borrow_temps,\n                         scrutinee_span,\n+                        region_scope,\n                     );\n                 } else {\n-                    arm_block = self.cfg.start_new_block();\n+                    arm_block = this.cfg.start_new_block();\n                     for candidate in candidates {\n-                        let binding_end = self.bind_and_guard_matched_candidate(\n+                        this.clear_top_scope(arm.scope);\n+                        let binding_end = this.bind_and_guard_matched_candidate(\n                             candidate,\n                             arm.guard.clone(),\n                             &fake_borrow_temps,\n                             scrutinee_span,\n+                            region_scope,\n                         );\n-                        self.cfg.terminate(\n+                        this.cfg.terminate(\n                             binding_end,\n                             source_info,\n                             TerminatorKind::Goto { target: arm_block },\n@@ -286,18 +273,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     this.source_scope = source_scope;\n                 }\n \n-                for candidate in candidates {\n-                    this.clear_top_scope(arm.scope);\n-                    this.bind_and_guard_matched_candidate(\n-                        candidate,\n-                        arm.guard.clone(),\n-                        arm_block,\n-                        &fake_borrow_temps,\n-                        scrutinee_span,\n-                        region_scope,\n-                    );\n-                }\n-\n                 this.into(destination, arm_block, body)\n             })\n         }).collect();\n@@ -792,11 +767,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// the value, we will generate a branch to the appropriate\n     /// prebinding block.\n     ///\n-    /// The return value is a list of \"otherwise\" blocks. These are\n-    /// points in execution where we found that *NONE* of the\n-    /// candidates apply. In principle, this means that the input\n-    /// list was not exhaustive, though at present we sometimes are\n-    /// not smart enough to recognize all exhaustive inputs.\n+    /// If we find that *NONE* of the candidates apply, we branch to the\n+    /// `otherwise_block`. In principle, this means that the input list was not\n+    /// exhaustive, though at present we sometimes are not smart enough to\n+    /// recognize all exhaustive inputs.\n     ///\n     /// It might be surprising that the input can be inexhaustive.\n     /// Indeed, initially, it is not, because all matches are\n@@ -810,13 +784,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n+        start_block: &mut Option<BasicBlock>,\n+        otherwise_block: Option<BasicBlock>,\n         candidates: &mut [&mut Candidate<'pat, 'tcx>],\n-        mut block: BasicBlock,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n-    ) -> Vec<BasicBlock> {\n+    ) {\n         debug!(\n-            \"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n-            span, block, candidates\n+            \"matched_candidate(span={:?}, candidates={:?}, start_block={:?}, otherwise_block={:?})\",\n+            span,\n+            candidates,\n+            start_block,\n+            otherwise_block,\n         );\n \n         // Start by simplifying candidates. Once this process is complete, all\n@@ -839,52 +817,57 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         );\n         let (matched_candidates, unmatched_candidates) = candidates.split_at_mut(fully_matched);\n \n+        let block: BasicBlock;\n+\n         if !matched_candidates.is_empty() {\n-            block = if let Some(last_otherwise_block) = self.select_matched_candidates(\n+            let otherwise_block = self.select_matched_candidates(\n                 matched_candidates,\n-                block,\n+                start_block,\n                 fake_borrows,\n-            ) {\n-                last_otherwise_block\n+            );\n+\n+            if let Some(last_otherwise_block) = otherwise_block {\n+                block = last_otherwise_block\n             } else {\n                 // Any remaining candidates are unreachable.\n                 if unmatched_candidates.is_empty() {\n-                    return Vec::new();\n-                } else {\n-                    self.cfg.start_new_block()\n+                    return;\n                 }\n+                block = self.cfg.start_new_block();\n             };\n+        } else {\n+            block = *start_block.get_or_insert_with(|| self.cfg.start_new_block());\n         }\n \n         // If there are no candidates that still need testing, we're\n         // done. Since all matches are exhaustive, execution should\n         // never reach this point.\n         if unmatched_candidates.is_empty() {\n-            return vec![block];\n+            let source_info = self.source_info(span);\n+            if let Some(otherwise) = otherwise_block {\n+                self.cfg.terminate(\n+                    block,\n+                    source_info,\n+                    TerminatorKind::Goto { target: otherwise },\n+                );\n+            } else {\n+                self.cfg.terminate(\n+                    block,\n+                    source_info,\n+                    TerminatorKind::Unreachable,\n+                )\n+            }\n+            return;\n         }\n \n-        // Test candidates where possible.\n-        let (otherwise, untested_candidates) = self.test_candidates(\n+        // Test for the remaining candidates.\n+        self.test_candidates(\n             span,\n             unmatched_candidates,\n             block,\n+            otherwise_block,\n             fake_borrows,\n         );\n-\n-        // If the target candidates were exhaustive, then we are done.\n-        // But for borrowck continue build decision tree.\n-        if untested_candidates.is_empty() {\n-            return otherwise;\n-        }\n-\n-        // Otherwise, let's process those remaining candidates.\n-        let join_block = self.join_otherwise_blocks(span, otherwise);\n-        self.match_candidates(\n-            span,\n-            untested_candidates,\n-            join_block,\n-            fake_borrows,\n-        )\n     }\n \n     /// Link up matched candidates. For example, if we have something like\n@@ -908,7 +891,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn select_matched_candidates(\n         &mut self,\n         matched_candidates: &mut [&mut Candidate<'_, 'tcx>],\n-        block: BasicBlock,\n+        start_block: &mut Option<BasicBlock>,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) -> Option<BasicBlock> {\n         debug_assert!(\n@@ -956,16 +939,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             = matched_candidates.split_at_mut(fully_matched_with_guard + 1);\n \n         let first_candidate = &reachable_candidates[0];\n+        let first_prebinding_block = first_candidate.pre_binding_block;\n \n-        let candidate_source_info = self.source_info(first_candidate.span);\n-\n-        self.cfg.terminate(\n-            block,\n-            candidate_source_info,\n-            TerminatorKind::Goto {\n-                target: first_candidate.pre_binding_block,\n-            },\n-        );\n+        if let Some(start_block) = *start_block {\n+            let source_info = self.source_info(first_candidate.span);\n+            self.cfg.terminate(\n+                start_block,\n+                source_info,\n+                TerminatorKind::Goto { target: first_prebinding_block },\n+            );\n+        } else {\n+            *start_block = Some(first_prebinding_block);\n+        }\n \n         for window in reachable_candidates.windows(2) {\n             if let [first_candidate, second_candidate] = window {\n@@ -1017,25 +1002,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn join_otherwise_blocks(&mut self, span: Span, mut otherwise: Vec<BasicBlock>) -> BasicBlock {\n-        let source_info = self.source_info(span);\n-        otherwise.sort();\n-        otherwise.dedup(); // variant switches can introduce duplicate target blocks\n-        if otherwise.len() == 1 {\n-            otherwise[0]\n-        } else {\n-            let join_block = self.cfg.start_new_block();\n-            for block in otherwise {\n-                self.cfg.terminate(\n-                    block,\n-                    source_info,\n-                    TerminatorKind::Goto { target: join_block },\n-                );\n-            }\n-            join_block\n-        }\n-    }\n-\n     /// This is the most subtle part of the matching algorithm. At\n     /// this point, the input candidates have been fully simplified,\n     /// and so we know that all remaining match-pairs require some\n@@ -1153,8 +1119,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         span: Span,\n         mut candidates: &'b mut [&'c mut Candidate<'pat, 'tcx>],\n         block: BasicBlock,\n+        mut otherwise_block: Option<BasicBlock>,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n-    ) -> (Vec<BasicBlock>, &'b mut [&'c mut Candidate<'pat, 'tcx>]) {\n+    ) {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n@@ -1208,9 +1175,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             \"match_candidates: test={:?} match_pair={:?}\",\n             test, match_pair\n         );\n-        let target_blocks = self.perform_test(block, &match_place, &test);\n         let mut target_candidates: Vec<Vec<&mut Candidate<'pat, 'tcx>>> = vec![];\n-        target_candidates.resize_with(target_blocks.len(), Default::default);\n+        target_candidates.resize_with(test.targets(), Default::default);\n \n         let total_candidate_count = candidates.len();\n \n@@ -1236,20 +1202,48 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // apply. Collect a list of blocks where control flow will\n         // branch if one of the `target_candidate` sets is not\n         // exhaustive.\n-        let otherwise: Vec<_> = target_blocks\n-            .into_iter()\n-            .zip(target_candidates)\n-            .flat_map(|(target_block, mut target_candidates)| {\n+        if !candidates.is_empty() {\n+            let remainder_start = &mut None;\n+            self.match_candidates(\n+                span,\n+                remainder_start,\n+                otherwise_block,\n+                candidates,\n+                fake_borrows,\n+            );\n+            otherwise_block = Some(remainder_start.unwrap());\n+        };\n+        let target_blocks: Vec<_> = target_candidates.into_iter().map(|mut candidates| {\n+            if candidates.len() != 0 {\n+                let candidate_start = &mut None;\n                 self.match_candidates(\n                     span,\n-                    &mut *target_candidates,\n-                    target_block,\n+                    candidate_start,\n+                    otherwise_block,\n+                    &mut *candidates,\n                     fake_borrows,\n-                )\n-            })\n-            .collect();\n+                );\n+                candidate_start.unwrap()\n+            } else {\n+                *otherwise_block.get_or_insert_with(|| {\n+                    let unreachable = self.cfg.start_new_block();\n+                    let source_info = self.source_info(span);\n+                    self.cfg.terminate(\n+                        unreachable,\n+                        source_info,\n+                        TerminatorKind::Unreachable,\n+                    );\n+                    unreachable\n+                })\n+            }\n+        }).collect();\n \n-        (otherwise, candidates)\n+        self.perform_test(\n+            block,\n+            &match_place,\n+            &test,\n+            target_blocks,\n+        );\n     }\n \n     // Determine the fake borrows that are needed to ensure that the place\n@@ -1323,7 +1317,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         fake_borrows: &Vec<(&Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         region_scope: (region::Scope, SourceInfo),\n-    ) {\n     ) -> BasicBlock {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n@@ -1345,10 +1338,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block,\n                 fresh_block,\n                 candidate.next_candidate_pre_binding_block,\n-            candidate_source_info,\n-        );\n+                candidate_source_info,\n+            );\n             block = fresh_block;\n-        self.ascribe_types(block, &candidate.ascriptions);\n+            self.ascribe_types(block, &candidate.ascriptions);\n         } else {\n             return block;\n         }"}, {"sha": "bbaf92bf9f5622cd5cb0b454e375d190bc0274e3", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 280, "deletions": 198, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -16,7 +16,6 @@ use rustc::ty::util::IntTypeExt;\n use rustc::ty::layout::VariantIdx;\n use rustc::mir::*;\n use rustc::hir::{RangeEnd, Mutability};\n-use syntax_pos::Span;\n use std::cmp::Ordering;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -162,43 +161,50 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Generates the code to perform a test.\n-    pub fn perform_test(&mut self,\n-                        block: BasicBlock,\n-                        place: &Place<'tcx>,\n-                        test: &Test<'tcx>)\n-                        -> Vec<BasicBlock> {\n+    pub fn perform_test(\n+        &mut self,\n+        block: BasicBlock,\n+        place: &Place<'tcx>,\n+        test: &Test<'tcx>,\n+        target_blocks: Vec<BasicBlock>,\n+    ) {\n         debug!(\"perform_test({:?}, {:?}: {:?}, {:?})\",\n                block,\n                place,\n                place.ty(&self.local_decls, self.hir.tcx()),\n                test);\n+\n         let source_info = self.source_info(test.span);\n         match test.kind {\n             TestKind::Switch { adt_def, ref variants } => {\n                 // Variants is a BitVec of indexes into adt_def.variants.\n                 let num_enum_variants = adt_def.variants.len();\n                 let used_variants = variants.count();\n-                let mut otherwise_block = None;\n-                let mut target_blocks = Vec::with_capacity(num_enum_variants);\n+                debug_assert_eq!(target_blocks.len(), num_enum_variants + 1);\n+                let otherwise_block = *target_blocks.last().unwrap();\n                 let mut targets = Vec::with_capacity(used_variants + 1);\n                 let mut values = Vec::with_capacity(used_variants);\n                 let tcx = self.hir.tcx();\n                 for (idx, discr) in adt_def.discriminants(tcx) {\n-                    target_blocks.push(if variants.contains(idx) {\n+                    if variants.contains(idx) {\n+                        debug_assert_ne!(\n+                            target_blocks[idx.index()],\n+                            otherwise_block,\n+                            \"no canididates for tested discriminant: {:?}\",\n+                            discr,\n+                        );\n                         values.push(discr.val);\n-                        let block = self.cfg.start_new_block();\n-                        targets.push(block);\n-                        block\n+                        targets.push(target_blocks[idx.index()]);\n                     } else {\n-                        *otherwise_block\n-                            .get_or_insert_with(|| self.cfg.start_new_block())\n-                    });\n+                        debug_assert_eq!(\n+                            target_blocks[idx.index()],\n+                            otherwise_block,\n+                            \"found canididates for untested discriminant: {:?}\",\n+                            discr,\n+                        );\n+                    }\n                 }\n-                targets.push(\n-                    otherwise_block\n-                        .unwrap_or_else(|| self.unreachable_block()),\n-                );\n+                targets.push(otherwise_block);\n                 debug!(\"num_enum_variants: {}, tested variants: {:?}, variants: {:?}\",\n                        num_enum_variants, values, variants);\n                 let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n@@ -212,160 +218,61 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     values: From::from(values),\n                     targets,\n                 });\n-                target_blocks\n             }\n \n             TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n-                let (ret, terminator) = if switch_ty.sty == ty::Bool {\n+                let terminator = if switch_ty.sty == ty::Bool {\n                     assert!(options.len() > 0 && options.len() <= 2);\n-                    let (true_bb, false_bb) = (self.cfg.start_new_block(),\n-                                               self.cfg.start_new_block());\n-                    let ret = match options[0] {\n-                        1 => vec![true_bb, false_bb],\n-                        0 => vec![false_bb, true_bb],\n-                        v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n-                    };\n-                    (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Copy(place.clone()),\n-                                              true_bb, false_bb))\n+                    if let [first_bb, second_bb] = *target_blocks {\n+                        let (true_bb, false_bb) = match options[0] {\n+                            1 => (first_bb, second_bb),\n+                            0 => (second_bb, first_bb),\n+                            v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n+                        };\n+                        TerminatorKind::if_(\n+                            self.hir.tcx(),\n+                            Operand::Copy(place.clone()),\n+                            true_bb,\n+                            false_bb,\n+                        )\n+                    } else {\n+                        bug!(\"`TestKind::SwitchInt` on `bool` should have two targets\")\n+                    }\n                 } else {\n-                    // The switch may be inexhaustive so we\n-                    // add a catch all block\n-                    let otherwise = self.cfg.start_new_block();\n-                    let targets: Vec<_> =\n-                        options.iter()\n-                               .map(|_| self.cfg.start_new_block())\n-                               .chain(Some(otherwise))\n-                               .collect();\n-                    (targets.clone(), TerminatorKind::SwitchInt {\n+                    // The switch may be inexhaustive so we have a catch all block\n+                    debug_assert_eq!(options.len() + 1, target_blocks.len());\n+                    TerminatorKind::SwitchInt {\n                         discr: Operand::Copy(place.clone()),\n                         switch_ty,\n                         values: options.clone().into(),\n-                        targets,\n-                    })\n+                        targets: target_blocks,\n+                    }\n                 };\n                 self.cfg.terminate(block, source_info, terminator);\n-                ret\n             }\n \n-            TestKind::Eq { value, mut ty } => {\n-                let val = Operand::Copy(place.clone());\n-                let mut expect = self.literal_operand(test.span, ty, value);\n+            TestKind::Eq { value, ty } => {\n                 // Use `PartialEq::eq` instead of `BinOp::Eq`\n                 // (the binop can only handle primitives)\n-                let fail = self.cfg.start_new_block();\n-                if !ty.is_scalar() {\n-                    // If we're using `b\"...\"` as a pattern, we need to insert an\n-                    // unsizing coercion, as the byte string has the type `&[u8; N]`.\n-                    //\n-                    // We want to do this even when the scrutinee is a reference to an\n-                    // array, so we can call `<[u8]>::eq` rather than having to find an\n-                    // `<[u8; N]>::eq`.\n-                    let unsize = |ty: Ty<'tcx>| match ty.sty {\n-                        ty::Ref(region, rty, _) => match rty.sty {\n-                            ty::Array(inner_ty, n) => Some((region, inner_ty, n)),\n-                            _ => None,\n-                        },\n-                        _ => None,\n-                    };\n-                    let opt_ref_ty = unsize(ty);\n-                    let opt_ref_test_ty = unsize(value.ty);\n-                    let mut place = place.clone();\n-                    match (opt_ref_ty, opt_ref_test_ty) {\n-                        // nothing to do, neither is an array\n-                        (None, None) => {},\n-                        (Some((region, elem_ty, _)), _) |\n-                        (None, Some((region, elem_ty, _))) => {\n-                            let tcx = self.hir.tcx();\n-                            // make both a slice\n-                            ty = tcx.mk_imm_ref(region, tcx.mk_slice(elem_ty));\n-                            if opt_ref_ty.is_some() {\n-                                place = self.temp(ty, test.span);\n-                                self.cfg.push_assign(\n-                                    block, source_info, &place, Rvalue::Cast(\n-                                        CastKind::Pointer(PointerCast::Unsize), val, ty\n-                                    )\n-                                );\n-                            }\n-                            if opt_ref_test_ty.is_some() {\n-                                let array = self.literal_operand(\n-                                    test.span,\n-                                    value.ty,\n-                                    value,\n-                                );\n-\n-                                let slice = self.temp(ty, test.span);\n-                                self.cfg.push_assign(\n-                                    block, source_info, &slice, Rvalue::Cast(\n-                                        CastKind::Pointer(PointerCast::Unsize), array, ty\n-                                    )\n-                                );\n-                                expect = Operand::Move(slice);\n-                            }\n-                        },\n+                if let [success, fail] = *target_blocks {\n+                    if !ty.is_scalar() {\n+                        self.non_scalar_compare(\n+                            block,\n+                            success,\n+                            fail,\n+                            source_info,\n+                            value,\n+                            place,\n+                            ty,\n+                        );\n+                    } else {\n+                        let val = Operand::Copy(place.clone());\n+                        let expect = self.literal_operand(test.span, ty, value);\n+                        self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n                     }\n-                    let eq_def_id = self.hir.tcx().lang_items().eq_trait().unwrap();\n-                    let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty.into()]);\n-\n-                    let re_erased = self.hir.tcx().lifetimes.re_erased;\n-                    // take the argument by reference\n-                    let tam = ty::TypeAndMut {\n-                        ty,\n-                        mutbl: Mutability::MutImmutable,\n-                    };\n-                    let ref_ty = self.hir.tcx().mk_ref(re_erased, tam);\n-\n-                    // let lhs_ref_place = &lhs;\n-                    let ref_rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, place);\n-                    let lhs_ref_place = self.temp(ref_ty, test.span);\n-                    self.cfg.push_assign(block, source_info, &lhs_ref_place, ref_rvalue);\n-                    let val = Operand::Move(lhs_ref_place);\n-\n-                    // let rhs_place = rhs;\n-                    let rhs_place = self.temp(ty, test.span);\n-                    self.cfg.push_assign(block, source_info, &rhs_place, Rvalue::Use(expect));\n-\n-                    // let rhs_ref_place = &rhs_place;\n-                    let ref_rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, rhs_place);\n-                    let rhs_ref_place = self.temp(ref_ty, test.span);\n-                    self.cfg.push_assign(block, source_info, &rhs_ref_place, ref_rvalue);\n-                    let expect = Operand::Move(rhs_ref_place);\n-\n-                    let bool_ty = self.hir.bool_ty();\n-                    let eq_result = self.temp(bool_ty, test.span);\n-                    let eq_block = self.cfg.start_new_block();\n-                    let cleanup = self.diverge_cleanup();\n-                    self.cfg.terminate(block, source_info, TerminatorKind::Call {\n-                        func: Operand::Constant(box Constant {\n-                            span: test.span,\n-                            ty: mty,\n-\n-                            // FIXME(#54571): This constant comes from user\n-                            // input (a constant in a pattern).  Are\n-                            // there forms where users can add type\n-                            // annotations here?  For example, an\n-                            // associated constant? Need to\n-                            // experiment.\n-                            user_ty: None,\n-\n-                            literal: method,\n-                        }),\n-                        args: vec![val, expect],\n-                        destination: Some((eq_result.clone(), eq_block)),\n-                        cleanup: Some(cleanup),\n-                        from_hir_call: false,\n-                    });\n-\n-                    // check the result\n-                    let block = self.cfg.start_new_block();\n-                    self.cfg.terminate(eq_block, source_info,\n-                                       TerminatorKind::if_(self.hir.tcx(),\n-                                                           Operand::Move(eq_result),\n-                                                           block, fail));\n-                    vec![block, fail]\n                 } else {\n-                    let block = self.compare(block, fail, test.span, BinOp::Eq, expect, val);\n-                    vec![block, fail]\n-                }\n+                    bug!(\"`TestKind::Eq` should have two target blocks\")\n+                };\n             }\n \n             TestKind::Range(PatternRange { ref lo, ref hi, ty, ref end }) => {\n@@ -374,20 +281,31 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let hi = self.literal_operand(test.span, ty, hi);\n                 let val = Operand::Copy(place.clone());\n \n-                let fail = self.cfg.start_new_block();\n-                let block = self.compare(block, fail, test.span, BinOp::Le, lo, val.clone());\n-                let block = match *end {\n-                    RangeEnd::Included => self.compare(block, fail, test.span, BinOp::Le, val, hi),\n-                    RangeEnd::Excluded => self.compare(block, fail, test.span, BinOp::Lt, val, hi),\n-                };\n-\n-                vec![block, fail]\n+                if let [success, fail] = *target_blocks {\n+                    let lower_bound_success = self.cfg.start_new_block();\n+\n+                    self.compare(\n+                        block,\n+                        lower_bound_success,\n+                        fail,\n+                        source_info,\n+                        BinOp::Le,\n+                        lo,\n+                        val.clone(),\n+                    );\n+                    let op = match *end {\n+                        RangeEnd::Included => BinOp::Le,\n+                        RangeEnd::Excluded => BinOp::Lt,\n+                    };\n+                    self.compare(lower_bound_success, success, fail, source_info, op, val, hi);\n+                } else {\n+                    bug!(\"`TestKind::Range` should have two target blocks\");\n+                }\n             }\n \n             TestKind::Len { len, op } => {\n-                let (usize_ty, bool_ty) = (self.hir.usize_ty(), self.hir.bool_ty());\n-                let (actual, result) = (self.temp(usize_ty, test.span),\n-                                        self.temp(bool_ty, test.span));\n+                let usize_ty = self.hir.usize_ty();\n+                let actual = self.temp(usize_ty, test.span);\n \n                 // actual = len(place)\n                 self.cfg.push_assign(block, source_info,\n@@ -396,44 +314,188 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // expected = <N>\n                 let expected = self.push_usize(block, source_info, len);\n \n-                // result = actual == expected OR result = actual < expected\n-                self.cfg.push_assign(block, source_info, &result,\n-                                     Rvalue::BinaryOp(op,\n-                                                      Operand::Move(actual),\n-                                                      Operand::Move(expected)));\n-\n-                // branch based on result\n-                let (false_bb, true_bb) = (self.cfg.start_new_block(),\n-                                           self.cfg.start_new_block());\n-                self.cfg.terminate(block, source_info,\n-                                   TerminatorKind::if_(self.hir.tcx(), Operand::Move(result),\n-                                                       true_bb, false_bb));\n-                vec![true_bb, false_bb]\n+                if let [true_bb, false_bb] = *target_blocks {\n+                    // result = actual == expected OR result = actual < expected\n+                    // branch based on result\n+                    self.compare(\n+                        block,\n+                        true_bb,\n+                        false_bb,\n+                        source_info,\n+                        op,\n+                        Operand::Move(actual),\n+                        Operand::Move(expected),\n+                    );\n+                } else {\n+                    bug!(\"`TestKind::Len` should have two target blocks\");\n+                }\n             }\n         }\n     }\n \n-    fn compare(&mut self,\n-               block: BasicBlock,\n-               fail_block: BasicBlock,\n-               span: Span,\n-               op: BinOp,\n-               left: Operand<'tcx>,\n-               right: Operand<'tcx>) -> BasicBlock {\n+    /// Compare using the provided built-in comparison operator\n+    fn compare(\n+        &mut self,\n+        block: BasicBlock,\n+        success_block: BasicBlock,\n+        fail_block: BasicBlock,\n+        source_info: SourceInfo,\n+        op: BinOp,\n+        left: Operand<'tcx>,\n+        right: Operand<'tcx>,\n+    ) {\n         let bool_ty = self.hir.bool_ty();\n-        let result = self.temp(bool_ty, span);\n+        let result = self.temp(bool_ty, source_info.span);\n \n         // result = op(left, right)\n-        let source_info = self.source_info(span);\n-        self.cfg.push_assign(block, source_info, &result,\n-                             Rvalue::BinaryOp(op, left, right));\n+        self.cfg.push_assign(\n+            block,\n+            source_info,\n+            &result,\n+            Rvalue::BinaryOp(op, left, right),\n+        );\n \n         // branch based on result\n-        let target_block = self.cfg.start_new_block();\n-        self.cfg.terminate(block, source_info,\n-                           TerminatorKind::if_(self.hir.tcx(), Operand::Move(result),\n-                                               target_block, fail_block));\n-        target_block\n+        self.cfg.terminate(\n+            block,\n+            source_info,\n+            TerminatorKind::if_(\n+                self.hir.tcx(),\n+                Operand::Move(result),\n+                success_block,\n+                fail_block,\n+            ),\n+        );\n+    }\n+\n+    /// Compare using `std::compare::PartialEq::eq`\n+    fn non_scalar_compare(\n+        &mut self,\n+        block: BasicBlock,\n+        success_block: BasicBlock,\n+        fail_block: BasicBlock,\n+        source_info: SourceInfo,\n+        value: &'tcx ty::Const<'tcx>,\n+        place: &Place<'tcx>,\n+        mut ty: Ty<'tcx>,\n+    ) {\n+        use rustc::middle::lang_items::EqTraitLangItem;\n+\n+        let mut expect = self.literal_operand(source_info.span, ty, value);\n+        let val = Operand::Copy(place.clone());\n+\n+        // If we're using `b\"...\"` as a pattern, we need to insert an\n+        // unsizing coercion, as the byte string has the type `&[u8; N]`.\n+        //\n+        // We want to do this even when the scrutinee is a reference to an\n+        // array, so we can call `<[u8]>::eq` rather than having to find an\n+        // `<[u8; N]>::eq`.\n+        let unsize = |ty: Ty<'tcx>| match ty.sty {\n+            ty::Ref(region, rty, _) => match rty.sty {\n+                ty::Array(inner_ty, n) => Some((region, inner_ty, n)),\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        let opt_ref_ty = unsize(ty);\n+        let opt_ref_test_ty = unsize(value.ty);\n+        let mut place = place.clone();\n+        match (opt_ref_ty, opt_ref_test_ty) {\n+            // nothing to do, neither is an array\n+            (None, None) => {},\n+            (Some((region, elem_ty, _)), _) |\n+            (None, Some((region, elem_ty, _))) => {\n+                let tcx = self.hir.tcx();\n+                // make both a slice\n+                ty = tcx.mk_imm_ref(region, tcx.mk_slice(elem_ty));\n+                if opt_ref_ty.is_some() {\n+                    place = self.temp(ty, source_info.span);\n+                    self.cfg.push_assign(\n+                        block, source_info, &place, Rvalue::Cast(\n+                            CastKind::Pointer(PointerCast::Unsize), val, ty\n+                        )\n+                    );\n+                }\n+                if opt_ref_test_ty.is_some() {\n+                    let array = self.literal_operand(\n+                        source_info.span,\n+                        value.ty,\n+                        value,\n+                    );\n+\n+                    let slice = self.temp(ty, source_info.span);\n+                    self.cfg.push_assign(\n+                        block, source_info, &slice, Rvalue::Cast(\n+                            CastKind::Pointer(PointerCast::Unsize), array, ty\n+                        )\n+                    );\n+                    expect = Operand::Move(slice);\n+                }\n+            },\n+        }\n+        let eq_def_id = self.hir.tcx().require_lang_item(EqTraitLangItem);\n+        let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty.into()]);\n+\n+        let re_erased = self.hir.tcx().lifetimes.re_erased;\n+        // take the argument by reference\n+        let tam = ty::TypeAndMut {\n+            ty,\n+            mutbl: Mutability::MutImmutable,\n+        };\n+        let ref_ty = self.hir.tcx().mk_ref(re_erased, tam);\n+\n+        // let lhs_ref_place = &lhs;\n+        let ref_rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, place);\n+        let lhs_ref_place = self.temp(ref_ty, source_info.span);\n+        self.cfg.push_assign(block, source_info, &lhs_ref_place, ref_rvalue);\n+        let val = Operand::Move(lhs_ref_place);\n+\n+        // let rhs_place = rhs;\n+        let rhs_place = self.temp(ty, source_info.span);\n+        self.cfg.push_assign(block, source_info, &rhs_place, Rvalue::Use(expect));\n+\n+        // let rhs_ref_place = &rhs_place;\n+        let ref_rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, rhs_place);\n+        let rhs_ref_place = self.temp(ref_ty, source_info.span);\n+        self.cfg.push_assign(block, source_info, &rhs_ref_place, ref_rvalue);\n+        let expect = Operand::Move(rhs_ref_place);\n+\n+        let bool_ty = self.hir.bool_ty();\n+        let eq_result = self.temp(bool_ty, source_info.span);\n+        let eq_block = self.cfg.start_new_block();\n+        let cleanup = self.diverge_cleanup();\n+        self.cfg.terminate(block, source_info, TerminatorKind::Call {\n+            func: Operand::Constant(box Constant {\n+                span: source_info.span,\n+                ty: mty,\n+\n+                // FIXME(#54571): This constant comes from user\n+                // input (a constant in a pattern).  Are\n+                // there forms where users can add type\n+                // annotations here?  For example, an\n+                // associated constant? Need to\n+                // experiment.\n+                user_ty: None,\n+\n+                literal: method,\n+            }),\n+            args: vec![val, expect],\n+            destination: Some((eq_result.clone(), eq_block)),\n+            cleanup: Some(cleanup),\n+            from_hir_call: false,\n+        });\n+\n+        // check the result\n+        self.cfg.terminate(\n+            eq_block,\n+            source_info,\n+            TerminatorKind::if_(\n+                self.hir.tcx(),\n+                Operand::Move(eq_result),\n+                success_block,\n+                fail_block,\n+            ),\n+        );\n     }\n \n     /// Given that we are performing `test` against `test_place`, this job\n@@ -755,6 +817,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n }\n \n+impl Test<'_> {\n+    pub(super) fn targets(&self) -> usize {\n+        match self.kind {\n+            TestKind::Eq { .. } | TestKind::Range(_) | TestKind::Len { .. } => {\n+                2\n+            }\n+            TestKind::Switch { adt_def, .. } => {\n+                adt_def.variants.len() + 1\n+            }\n+            TestKind::SwitchInt { switch_ty, ref options, .. } => {\n+                if switch_ty.is_bool() {\n+                    2\n+                } else {\n+                    options.len() + 1\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn is_switch_ty<'tcx>(ty: Ty<'tcx>) -> bool {\n     ty.is_integral() || ty.is_char() || ty.is_bool()\n }"}, {"sha": "fdab73eb3ca7e780e8931a0920a567982f7e3506", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -952,17 +952,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n-\n-    fn unreachable_block(&mut self) -> BasicBlock {\n-        match self.cached_unreachable_block {\n-            Some(ub) => ub,\n-            None => {\n-                let ub = self.cfg.start_new_block();\n-                self.cached_unreachable_block = Some(ub);\n-                ub\n-            }\n-        }\n-    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "2fc52969a3cbc24715bb9b632791a413257b00fb", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -1448,6 +1448,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             StatementKind::Assign(..) => {\n                 self.super_statement(statement, location);\n             }\n+            StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n+                self.not_const();\n+            }\n             // FIXME(eddyb) should these really do nothing?\n             StatementKind::FakeRead(..) |\n             StatementKind::SetDiscriminant { .. } |"}, {"sha": "418a88859ac42a9ac614024a83ae1f2362ad2055", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -211,6 +211,10 @@ fn check_statement(\n             check_rvalue(tcx, body, rval, span)\n         }\n \n+        StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n+            Err((span, \"loops and conditional expressions are not stable in const fn\".into()))\n+        }\n+\n         StatementKind::FakeRead(_, place) => check_place(place, span),\n \n         // just an assignment"}, {"sha": "145d4ba6b4c5a283ee3e3a6dfa479ef61549596a", "filename": "src/test/codegen/match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fcodegen%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fcodegen%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -14,11 +14,11 @@ pub fn exhaustive_match(e: E, unit: ()) {\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[A:[a-zA-Z0-9_]+]]\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[B:[a-zA-Z0-9_]+]]\n // CHECK-NEXT: ]\n+// CHECK: [[B]]:\n+// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n // CHECK: [[OTHERWISE]]:\n // CHECK-NEXT: unreachable\n // CHECK: [[A]]:\n-// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n-// CHECK: [[B]]:\n // CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n     match e {\n         E::A => unit,"}, {"sha": "87a9cf9490d86add3aa891682a43a18cb0f31f54", "filename": "src/test/compile-fail/const-fn-error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -7,6 +7,7 @@ const fn f(x: usize) -> usize {\n     for i in 0..x {\n         //~^ ERROR E0015\n         //~| ERROR E0019\n+        //~| ERROR E0019\n         //~| ERROR E0080\n         sum += i;\n     }"}, {"sha": "0d6906086e9b1f24563b123336004502bda38846", "filename": "src/test/compile-fail/issue-52443.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -4,5 +4,6 @@ fn main() {\n     [(); {while true {break}; 0}]; //~ ERROR constant contains unimplemented expression type\n     [(); { for _ in 0usize.. {}; 0}]; //~ ERROR calls in constants are limited to constant functions\n     //~^ ERROR constant contains unimplemented expression type\n+    //~| ERROR constant contains unimplemented expression type\n     //~| ERROR evaluation of constant value failed\n }"}, {"sha": "904d303d87e313527e26e777b9c1cda4e541e700", "filename": "src/test/mir-opt/const_prop/switch_int.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -13,26 +13,26 @@ fn main() {\n //  bb0: {\n //      ...\n //      _1 = const 1i32;\n-//      switchInt(_1) -> [1i32: bb1, otherwise: bb2];\n+//      switchInt(_1) -> [1i32: bb2, otherwise: bb1];\n //  }\n // END rustc.main.ConstProp.before.mir\n // START rustc.main.ConstProp.after.mir\n //  bb0: {\n //      ...\n-//      switchInt(const 1i32) -> [1i32: bb1, otherwise: bb2];\n+//      switchInt(const 1i32) -> [1i32: bb2, otherwise: bb1];\n //  }\n // END rustc.main.ConstProp.after.mir\n // START rustc.main.SimplifyBranches-after-const-prop.before.mir\n //  bb0: {\n //      ...\n //      _1 = const 1i32;\n-//      switchInt(const 1i32) -> [1i32: bb1, otherwise: bb2];\n+//      switchInt(const 1i32) -> [1i32: bb2, otherwise: bb1];\n //  }\n // END rustc.main.SimplifyBranches-after-const-prop.before.mir\n // START rustc.main.SimplifyBranches-after-const-prop.after.mir\n //  bb0: {\n //      ...\n //      _1 = const 1i32;\n-//      goto -> bb1;\n+//      goto -> bb2;\n //  }\n // END rustc.main.SimplifyBranches-after-const-prop.after.mir"}, {"sha": "b39ad1bef8e348aa1ad1da61c7ca15c7c9d7bd55", "filename": "src/test/mir-opt/deaggregator_test_enum_2.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -21,36 +21,36 @@ fn main() {\n // END RUST SOURCE\n // START rustc.test1.Deaggregator.before.mir\n //  bb1: {\n-//      StorageLive(_4);\n-//      _4 = _2;\n-//      _0 = Foo::A(move _4,);\n-//      StorageDead(_4);\n-//      goto -> bb3;\n-//  }\n-//  bb2: {\n //      StorageLive(_5);\n //      _5 = _2;\n //      _0 = Foo::B(move _5,);\n //      StorageDead(_5);\n //      goto -> bb3;\n //  }\n-// END rustc.test1.Deaggregator.before.mir\n-// START rustc.test1.Deaggregator.after.mir\n-//  bb1: {\n+//  bb2: {\n //      StorageLive(_4);\n //      _4 = _2;\n-//      ((_0 as A).0: i32) = move _4;\n-//      discriminant(_0) = 0;\n+//      _0 = Foo::A(move _4,);\n //      StorageDead(_4);\n //      goto -> bb3;\n //  }\n-//  bb2: {\n+// END rustc.test1.Deaggregator.before.mir\n+// START rustc.test1.Deaggregator.after.mir\n+//  bb1: {\n //      StorageLive(_5);\n //      _5 = _2;\n //      ((_0 as B).0: i32) = move _5;\n //      discriminant(_0) = 1;\n //      StorageDead(_5);\n //      goto -> bb3;\n //  }\n+//  bb2: {\n+//      StorageLive(_4);\n+//      _4 = _2;\n+//      ((_0 as A).0: i32) = move _4;\n+//      discriminant(_0) = 0;\n+//      StorageDead(_4);\n+//      goto -> bb3;\n+//  }\n // END rustc.test1.Deaggregator.after.mir\n //"}, {"sha": "909f9b7b6b79ae4f64108bc566650a92aa128566", "filename": "src/test/mir-opt/issue-38669.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-38669.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -31,17 +31,17 @@ fn main() {\n //         switchInt(_4) -> [false: bb5, otherwise: bb4];\n //     }\n //     ...\n-//     bb7: {\n-//         _0 = ();\n-//         StorageDead(_4);\n-//         StorageDead(_1);\n-//         return;\n-//     }\n-//     bb8: {\n+//     bb5: {\n //         _3 = ();\n //         StorageDead(_4);\n //         _1 = const true;\n //         _2 = ();\n //         goto -> bb2;\n //     }\n+//     bb6: {\n+//         _0 = ();\n+//         StorageDead(_4);\n+//         StorageDead(_1);\n+//         return;\n+//     }\n // END rustc.main.SimplifyCfg-initial.after.mir"}, {"sha": "9dde6d821f2bc6b53e6384907721a4756a4b4ebf", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -32,76 +32,58 @@ fn main() {\n //         falseUnwind -> [real: bb3, cleanup: bb4];\n //     }\n //     bb2: {\n-//         goto -> bb20;\n+//         goto -> bb14;\n //     }\n //     bb3: {\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         _3 = const true;\n //         FakeRead(ForMatchedPlace, _3);\n-//         switchInt(_3) -> [false: bb9, otherwise: bb8];\n+//         switchInt(_3) -> [false: bb5, otherwise: bb6];\n //     }\n //     bb4 (cleanup): {\n //         resume;\n //     }\n //     bb5: {\n-//         falseEdges -> [real: bb11, imaginary: bb6];\n+//         falseEdges -> [real: bb7, imaginary: bb6];\n //     }\n //     bb6: {\n-//         falseEdges -> [real: bb13, imaginary: bb7];\n+//         _0 = ();\n+//         goto -> bb8;\n //     }\n //     bb7: {\n-//         unreachable;\n-//     }\n-//     bb8: {\n-//         goto -> bb6;\n-//     }\n-//     bb9: {\n-//         goto -> bb5;\n-//     }\n-//     bb10: {\n //         _2 = const 4i32;\n-//         goto -> bb18;\n-//     }\n-//     bb11: {\n-//         goto -> bb10;\n-//     }\n-//     bb12: {\n-//         _0 = ();\n-//         goto -> bb14;\n-//     }\n-//     bb13: {\n //         goto -> bb12;\n //     }\n-//     bb14: {\n+//     bb8: {\n //         StorageDead(_3);\n-//         goto -> bb15;\n+//         goto -> bb9;\n //     }\n-//     bb15: {\n+//     bb9: {\n //         StorageDead(_2);\n //         goto -> bb2;\n //     }\n-//     bb16: {\n+//     bb10: {\n //         _4 = ();\n //         unreachable;\n //     }\n-//     bb17: {\n-//         goto -> bb18;\n+//     bb11: {\n+//         goto -> bb12;\n //     }\n-//     bb18: {\n+//     bb12: {\n //         FakeRead(ForLet, _2);\n //         StorageDead(_3);\n //         StorageLive(_6);\n //         _6 = &_2;\n-//         _5 = const std::mem::drop::<&i32>(move _6) -> [return: bb19, unwind: bb4];\n+//         _5 = const std::mem::drop::<&i32>(move _6) -> [return: bb13, unwind: bb4];\n //     }\n-//     bb19: {\n+//     bb13: {\n //         StorageDead(_6);\n //         _1 = ();\n //         StorageDead(_2);\n //         goto -> bb1;\n //     }\n-//     bb20: {\n+//     bb14: {\n //         return;\n //     }\n // }"}, {"sha": "68ea60d92787cebb43e91783ebf5e3a59ba228e5", "filename": "src/test/mir-opt/loop_test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Floop_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Floop_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Floop_test.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -22,20 +22,21 @@ fn main() {\n //        resume;\n //    }\n //    ...\n-//    bb6: { // Entry into the loop\n+//    bb3: { // Entry into the loop\n //        _1 = ();\n //        StorageDead(_2);\n-//        goto -> bb7;\n+//        goto -> bb5;\n //    }\n-//    bb7: { // The loop_block\n-//        falseUnwind -> [real: bb8, cleanup: bb1];\n+//    ...\n+//    bb5: { // The loop_block\n+//        falseUnwind -> [real: bb6, cleanup: bb1];\n //    }\n-//    bb8: { // The loop body (body_block)\n+//    bb6: { // The loop body (body_block)\n //        StorageLive(_6);\n //        _6 = const 1i32;\n //        FakeRead(ForLet, _6);\n //        StorageDead(_6);\n-//        goto -> bb7;\n+//        goto -> bb5;\n //    }\n //    ...\n // END rustc.main.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "a2bc238c68ad9e320697e11575c21fd90f45c966", "filename": "src/test/mir-opt/match-arm-scopes.rs", "status": "modified", "additions": 66, "deletions": 84, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -42,55 +42,49 @@ fn main() {\n // let mut _0: i32;\n // let mut _3: &bool;                   // Temp for fake borrow of `items.0`\n // let mut _4: &bool;                   // Temp for fake borrow of `items.1`\n-// let _5: bool;                    // `a` in arm\n-// let _6: &bool;                   // `a` in guard\n-// let _7: std::string::String;     // `s` in arm\n-// let _8: &std::string::String;    // `s` in guard\n+// let _5: bool;                        // `a` in arm\n+// let _6: &bool;                       // `a` in guard\n+// let _7: std::string::String;         // `s` in arm\n+// let _8: &std::string::String;        // `s` in guard\n // let mut _9: bool;                    // `if cond { return 3 } else { a }`\n // let mut _10: bool;                   // `cond`\n // let mut _11: !;                      // `return 3`\n // let mut _12: bool;                   // `if cond { return 3 } else { a }`\n // let mut _13: bool;                   // `cond`\n // let mut _14: !;                      // `return 3`\n-// let _15: bool;                   // `b`\n-// let _16: std::string::String;    // `t`\n+// let _15: bool;                       // `b`\n+// let _16: std::string::String;        // `t`\n // scope 1 {\n // }\n // scope 2 {\n // }\n // bb0: {\n //     FakeRead(ForMatchedPlace, _2);\n-//     switchInt((_2.0: bool)) -> [false: bb2, otherwise: bb7];\n+//     switchInt((_2.0: bool)) -> [false: bb2, otherwise: bb5];\n // }\n // bb1 (cleanup): {\n //     resume;\n // }\n // bb2: {\n-//     falseEdges -> [real: bb10, imaginary: bb3];\n+//     falseEdges -> [real: bb8, imaginary: bb3];\n // }\n // bb3: {\n-//     falseEdges -> [real: bb21, imaginary: bb4];\n+//     falseEdges -> [real: bb17, imaginary: bb4];\n // }\n // bb4: {\n-//     falseEdges -> [real: bb31, imaginary: bb5];\n+//     falseEdges -> [real: bb25, imaginary: bb26];\n // }\n // bb5: {\n-//     falseEdges -> [real: bb32, imaginary: bb6];\n+//     switchInt((_2.1: bool)) -> [false: bb3, otherwise: bb6];\n // }\n // bb6: {\n-//     unreachable;\n+//     switchInt((_2.0: bool)) -> [false: bb26, otherwise: bb4];\n // }\n-// bb7: {\n-//     switchInt((_2.1: bool)) -> [false: bb3, otherwise: bb8];\n-// }\n-// bb8: {\n-//     switchInt((_2.0: bool)) -> [false: bb5, otherwise: bb4];\n-// }\n-// bb9: {                               // arm 1\n+// bb7: {                               // arm 1\n //     _0 = const 1i32;\n-//     drop(_7) -> [return: bb29, unwind: bb16];\n+//     drop(_7) -> [return: bb23, unwind: bb13];\n // }\n-// bb10: {                              // guard - first time\n+// bb8: {                               // guard - first time\n //     StorageLive(_6);\n //     _6 = &(_2.1: bool);\n //     StorageLive(_8);\n@@ -101,58 +95,52 @@ fn main() {\n //     StorageLive(_10);\n //     _10 = _1;\n //     FakeRead(ForMatchedPlace, _10);\n-//     switchInt(_10) -> [false: bb12, otherwise: bb11];\n+//     switchInt(_10) -> [false: bb10, otherwise: bb9];\n // }\n-// bb11: {\n-//     falseEdges -> [real: bb14, imaginary: bb12];\n+// bb9: {\n+//     falseEdges -> [real: bb11, imaginary: bb10];\n // }\n-// bb12: {\n-//     falseEdges -> [real: bb18, imaginary: bb13];\n-// }\n-// bb13: {\n-//     unreachable;\n+// bb10: {                              // `else` block - first time\n+//     _9 = (*_6);\n+//     StorageDead(_10);\n+//     FakeRead(ForMatchGuard, _3);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForGuardBinding, _6);\n+//     FakeRead(ForGuardBinding, _8);\n+//     switchInt(move _9) -> [false: bb16, otherwise: bb15];\n // }\n-// bb14: {                              // `return 3` - first time\n+// bb11: {                              // `return 3` - first time\n //     _0 = const 3i32;\n //     StorageDead(_10);\n //     StorageDead(_9);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     goto -> bb17;\n+//     goto -> bb14;\n // }\n-// bb15: {\n+// bb12: {\n //     return;\n // }\n-// bb16 (cleanup): {\n+// bb13 (cleanup): {\n //     drop(_2) -> bb1;\n // }\n-// bb17: {\n-//     drop(_2) -> [return: bb15, unwind: bb1];\n-// }\n-// bb18: {                              // `else` block - first time\n-//     _9 = (*_6);\n-//     StorageDead(_10);\n-//     FakeRead(ForMatchGuard, _3);\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForGuardBinding, _6);\n-//     FakeRead(ForGuardBinding, _8);\n-//     switchInt(move _9) -> [false: bb20, otherwise: bb19];\n+// bb14: {\n+//     drop(_2) -> [return: bb12, unwind: bb1];\n // }\n-// bb19: {\n+// bb15: {\n //     StorageDead(_9);\n //     StorageLive(_5);\n //     _5 = (_2.1: bool);\n //     StorageLive(_7);\n //     _7 = move (_2.2: std::string::String);\n-//     goto -> bb9;\n+//     goto -> bb7;\n // }\n-// bb20: {                              // guard otherwise case - first time\n+// bb16: {                              // guard otherwise case - first time\n //     StorageDead(_9);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     falseEdges -> [real: bb7, imaginary: bb3];\n+//     falseEdges -> [real: bb5, imaginary: bb3];\n // }\n-// bb21: {                              // guard - second time\n+// bb17: {                              // guard - second time\n //     StorageLive(_6);\n //     _6 = &(_2.0: bool);\n //     StorageLive(_8);\n@@ -163,80 +151,74 @@ fn main() {\n //     StorageLive(_13);\n //     _13 = _1;\n //     FakeRead(ForMatchedPlace, _13);\n-//     switchInt(_13) -> [false: bb23, otherwise: bb22];\n-// }\n-// bb22: {\n-//     falseEdges -> [real: bb25, imaginary: bb23];\n-// }\n-// bb23: {\n-//     falseEdges -> [real: bb26, imaginary: bb24];\n+//     switchInt(_13) -> [false: bb19, otherwise: bb18];\n // }\n-// bb24: {\n-//     unreachable;\n+// bb18: {\n+//     falseEdges -> [real: bb20, imaginary: bb19];\n // }\n-// bb25: {                              // `return 3` - second time\n-//     _0 = const 3i32;\n-//     StorageDead(_13);\n-//     StorageDead(_12);\n-//     StorageDead(_8);\n-//     StorageDead(_6);\n-//     goto -> bb17;\n-// }\n-// bb26: {                              // `else` block - second time\n+// bb19: {                              // `else` block - second time\n //     _12 = (*_6);\n //     StorageDead(_13);\n //     FakeRead(ForMatchGuard, _3);\n //     FakeRead(ForMatchGuard, _4);\n //     FakeRead(ForGuardBinding, _6);\n //     FakeRead(ForGuardBinding, _8);\n-//     switchInt(move _12) -> [false: bb28, otherwise: bb27];\n+//     switchInt(move _12) -> [false: bb22, otherwise: bb21];\n+// }\n+// bb20: {\n+//     _0 = const 3i32;\n+//     StorageDead(_13);\n+//     StorageDead(_12);\n+//     StorageDead(_8);\n+//     StorageDead(_6);\n+//     goto -> bb14;\n // }\n-// bb27: {                              // Guard otherwise case - second time\n+// bb21: {                              // bindings for arm 1\n //     StorageDead(_12);\n //     StorageLive(_5);\n //     _5 = (_2.0: bool);\n //     StorageLive(_7);\n //     _7 = move (_2.2: std::string::String);\n-//     goto -> bb9;\n+//     goto -> bb7;\n // }\n-// bb28: {                              // rest of arm 1\n+// bb22: {                              // Guard otherwise case - second time\n //     StorageDead(_12);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     falseEdges -> [real: bb8, imaginary: bb4];\n+//     falseEdges -> [real: bb6, imaginary: bb4];\n // }\n-// bb29: {\n+// bb23: {                              // rest of arm 1\n //     StorageDead(_7);\n //     StorageDead(_5);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     goto -> bb34;\n+//     goto -> bb28;\n // }\n-// bb30: {                              // arm 2\n+// bb24: {                              // arm 2\n //     _0 = const 2i32;\n-//     drop(_16) -> [return: bb33, unwind: bb16];\n+//     drop(_16) -> [return: bb27, unwind: bb13];\n // }\n-// bb31: {                              // bindings for arm 2 - first pattern\n+// bb25: {                              // bindings for arm 2 - first pattern\n //     StorageLive(_15);\n //     _15 = (_2.1: bool);\n //     StorageLive(_16);\n //     _16 = move (_2.2: std::string::String);\n-//     goto -> bb30;\n+//     goto -> bb24;\n // }\n-// bb32: {                              // bindings for arm 2 - first pattern\n+// bb26: {                              // bindings for arm 2 - second pattern\n //     StorageLive(_15);\n //     _15 = (_2.1: bool);\n //     StorageLive(_16);\n //     _16 = move (_2.2: std::string::String);\n-//     goto -> bb30;\n+//     goto -> bb24;\n // }\n-// bb33: {                              // rest of arm 2\n+// bb27: {                              // rest of arm 2\n //     StorageDead(_16);\n //     StorageDead(_15);\n-//     goto -> bb34;\n+//     goto -> bb28;\n // }\n-// bb34: {                              // end of match\n-//     drop(_2) -> [return: bb15, unwind: bb1];\n+// bb28: {\n+//     drop(_2) -> [return: bb12, unwind: bb1];\n // }\n // END rustc.complicated_match.SimplifyCfg-initial.after.mir\n // START rustc.complicated_match.ElaborateDrops.after.mir"}, {"sha": "a62e1b21dd162604abb49b71f6f10befc5de5637", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 58, "deletions": 76, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -45,39 +45,37 @@ fn main() {\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb6];\n+//      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb5];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb7, imaginary: bb3]; //pre_binding1\n+//      falseEdges -> [real: bb6, imaginary: bb3]; //pre_binding1\n //  }\n //  bb3: {\n-//      falseEdges -> [real: bb11, imaginary: bb4]; //pre_binding2\n+//      falseEdges -> [real: bb10, imaginary: bb4]; //pre_binding2\n //  }\n-//  bb4: {\n-//      falseEdges -> [real: bb12, imaginary: bb5]; //pre_binding3\n+//  bb4: { //pre_binding3 and arm3\n+//      _1 = (const 3i32, const 3i32);\n+//      goto -> bb11;\n //  }\n //  bb5: {\n //      unreachable;\n //  }\n-//  bb6: {\n-//      unreachable;\n-//  }\n-//  bb7: { // binding1 and guard\n+//  bb6: { // binding1 and guard\n //      StorageLive(_6);\n //      _6 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n //      _4 = &shallow _2;\n //      StorageLive(_7);\n-//      _7 = const guard() -> [return: bb8, unwind: bb1];\n+//      _7 = const guard() -> [return: bb7, unwind: bb1];\n //  }\n-//  bb8: { // end of guard\n+//  bb7: { // end of guard\n //      FakeRead(ForMatchGuard, _4);\n //      FakeRead(ForGuardBinding, _6);\n-//      switchInt(move _7) -> [false: bb10, otherwise: bb9];\n+//      switchInt(move _7) -> [false: bb9, otherwise: bb8];\n //  }\n-//  bb9: { // arm1\n+//  bb8: { // arm1\n //      StorageDead(_7);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n@@ -87,28 +85,24 @@ fn main() {\n //      StorageDead(_8);\n //      StorageDead(_5);\n //      StorageDead(_6);\n-//      goto -> bb13;\n+//      goto -> bb11;\n //  }\n-//  bb10: { // to pre_binding2\n+//  bb9: { // to pre_binding2\n //      StorageDead(_7);\n //      StorageDead(_6);\n-//      falseEdges -> [real: bb3, imaginary: bb3];\n+//      goto -> bb3;\n //  }\n-//  bb11: { // arm2\n+//  bb10: { // arm2\n //      StorageLive(_9);\n //      _9 = ((_2 as Some).0: i32);\n //      StorageLive(_10);\n //      _10 = _9;\n //      _1 = (const 2i32, move _10);\n //      StorageDead(_10);\n //      StorageDead(_9);\n-//      goto -> bb13;\n+//      goto -> bb11;\n //  }\n-//  bb12: { // arm3\n-//      _1 = (const 3i32, const 3i32);\n-//      goto -> bb13;\n-//  }\n-//  bb13: {\n+//  bb11: { // arm3\n //      StorageDead(_2);\n //      StorageDead(_1);\n //      _0 = ();\n@@ -122,39 +116,33 @@ fn main() {\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb6];\n+//      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb4];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb7, imaginary: bb3];\n+//      falseEdges -> [real: bb5, imaginary: bb3];\n //  }\n //  bb3: {\n-//      falseEdges -> [real: bb11, imaginary: bb4];\n+//      falseEdges -> [real: bb9, imaginary: bb10];\n //  }\n-//  bb4: {\n-//      falseEdges -> [real: bb12, imaginary: bb5];\n-//  }\n-//  bb5: {\n+//  bb4: { // to arm3 (can skip 2 since this is `Some`)\n //      unreachable;\n //  }\n-//  bb6: {\n-//      unreachable;\n-//  }\n-//  bb7: { // binding1 and guard\n+//  bb5: { // binding1 and guard\n //      StorageLive(_6);\n //      _6 = &((_2 as Some).0: i32);\n //      _4 = &shallow _2;\n //      StorageLive(_7);\n-//      _7 = const guard() -> [return: bb8, unwind: bb1];\n+//      _7 = const guard() -> [return: bb6, unwind: bb1];\n //  }\n-//  bb8: { // end of guard\n+//  bb6: { // end of guard\n //      FakeRead(ForMatchGuard, _4);\n //      FakeRead(ForGuardBinding, _6);\n-//      switchInt(move _7) -> [false: bb10, otherwise: bb9];\n+//      switchInt(move _7) -> [false: bb8, otherwise: bb7];\n //  }\n-//  bb9: { // arm1\n+//  bb7: {\n //      StorageDead(_7);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n@@ -164,28 +152,28 @@ fn main() {\n //      StorageDead(_8);\n //      StorageDead(_5);\n //      StorageDead(_6);\n-//      goto -> bb13;\n+//      goto -> bb11;\n //  }\n-//  bb10: { // to pre_binding3 (can skip 2 since this is `Some`)\n+//  bb8: { // to pre_binding3 (can skip 2 since this is `Some`)\n //      StorageDead(_7);\n //      StorageDead(_6);\n-//      falseEdges -> [real: bb4, imaginary: bb3];\n+//      falseEdges -> [real: bb10, imaginary: bb3];\n //  }\n-//  bb11: { // arm2\n+//  bb9: { // arm2\n //      _1 = (const 3i32, const 3i32);\n-//      goto -> bb13;\n+//      goto -> bb11;\n //  }\n-//  bb12: { // binding3 and arm3\n+//  bb10: { // binding3 and arm3\n //      StorageLive(_9);\n //      _9 = ((_2 as Some).0: i32);\n //      StorageLive(_10);\n //      _10 = _9;\n //      _1 = (const 2i32, move _10);\n //      StorageDead(_10);\n //      StorageDead(_9);\n-//      goto -> bb13;\n+//      goto -> bb11;\n //  }\n-//  bb13: {\n+//  bb11: {\n //      StorageDead(_2);\n //      StorageDead(_1);\n //      _0 = ();\n@@ -198,97 +186,91 @@ fn main() {\n //     ...\n //      _2 = std::option::Option::<i32>::Some(const 1i32,);\n //      FakeRead(ForMatchedPlace, _2);\n-//      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [1isize: bb2, otherwise: bb3];\n+//      _4 = discriminant(_2);\n+//      switchInt(move _4) -> [1isize: bb2, otherwise: bb3];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb7, imaginary: bb3];\n+//      falseEdges -> [real: bb5, imaginary: bb3];\n //  }\n //  bb3: {\n-//      falseEdges -> [real: bb11, imaginary: bb4];\n+//      falseEdges -> [real: bb9, imaginary: bb4];\n //  }\n //  bb4: {\n-//      falseEdges -> [real: bb12, imaginary: bb5];\n+//      falseEdges -> [real: bb10, imaginary: bb14];\n //  }\n //  bb5: {\n-//      falseEdges -> [real: bb16, imaginary: bb6];\n-//  }\n-//  bb6: {\n-//      unreachable;\n-//  }\n-//  bb7: { // binding1: Some(w) if guard()\n //      StorageLive(_7);\n //      _7 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n //      StorageLive(_8);\n-//      _8 = const guard() -> [return: bb8, unwind: bb1];\n+//      _8 = const guard() -> [return: bb6, unwind: bb1];\n //  }\n-//  bb8: { //end of guard1\n+//  bb6: { //end of guard1\n //      FakeRead(ForMatchGuard, _5);\n //      FakeRead(ForGuardBinding, _7);\n-//      switchInt(move _8) -> [false: bb10, otherwise: bb9];\n+//      switchInt(move _8) -> [false: bb8, otherwise: bb7];\n //  }\n-//  bb9: {\n+//  bb7: {\n //      StorageDead(_8);\n //      StorageLive(_6);\n //      _6 = ((_2 as Some).0: i32);\n //      _1 = const 1i32;\n //      StorageDead(_6);\n //      StorageDead(_7);\n-//      goto -> bb17;\n+//      goto -> bb15;\n //  }\n-//  bb10: {\n+//  bb8: {\n //      StorageDead(_8);\n //      StorageDead(_7);\n //      falseEdges -> [real: bb3, imaginary: bb3];\n //  }\n-//  bb11: { // binding2 & arm2\n+//  bb9: { // binding2 & arm2\n //      StorageLive(_9);\n //      _9 = _2;\n //      _1 = const 2i32;\n //      StorageDead(_9);\n-//      goto -> bb17;\n+//      goto -> bb15;\n //  }\n-//  bb12: { // binding3: Some(y) if guard2(y)\n+//  bb10: { // binding3: Some(y) if guard2(y)\n //      StorageLive(_11);\n //      _11 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n //      StorageLive(_12);\n //      StorageLive(_13);\n //      _13 = (*_11);\n-//      _12 = const guard2(move _13) -> [return: bb13, unwind: bb1];\n+//      _12 = const guard2(move _13) -> [return: bb11, unwind: bb1];\n //  }\n-//  bb13: { // end of guard2\n+//  bb11: { // end of guard2\n //      StorageDead(_13);\n //      FakeRead(ForMatchGuard, _5);\n //      FakeRead(ForGuardBinding, _11);\n-//      switchInt(move _12) -> [false: bb15, otherwise: bb14];\n+//      switchInt(move _12) -> [false: bb13, otherwise: bb12];\n //  }\n-//  bb14: { // binding4 & arm4\n+//  bb12: { // binding4 & arm4\n //      StorageDead(_12);\n //      StorageLive(_10);\n //      _10 = ((_2 as Some).0: i32);\n //      _1 = const 3i32;\n //      StorageDead(_10);\n //      StorageDead(_11);\n-//      goto -> bb17;\n+//      goto -> bb15;\n //  }\n-//  bb15: {\n+//  bb13: {\n //      StorageDead(_12);\n //      StorageDead(_11);\n-//      falseEdges -> [real: bb5, imaginary: bb5];\n+//      falseEdges -> [real: bb14, imaginary: bb14];\n //  }\n-//  bb16: {\n+//  bb14: {\n //      StorageLive(_14);\n //      _14 = _2;\n //      _1 = const 4i32;\n //      StorageDead(_14);\n-//      goto -> bb17;\n+//      goto -> bb15;\n //  }\n-//  bb17: {\n+//  bb15: {\n //      StorageDead(_2);\n //      StorageDead(_1);\n //      _0 = ();"}, {"sha": "ef60a04d1bdfc69683e45a877611e3f680920076", "filename": "src/test/mir-opt/match_test.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_test.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -20,67 +20,61 @@ fn main() {\n // START rustc.main.SimplifyCfg-initial.after.mir\n //    bb0: {\n //        ...\n-//        switchInt(move _4) -> [false: bb6, otherwise: bb7];\n+//        switchInt(move _6) -> [false: bb6, otherwise: bb5];\n //    }\n //    bb1: {\n-//        falseEdges -> [real: bb10, imaginary: bb2];\n+//        falseEdges -> [real: bb9, imaginary: bb2];\n //    }\n //    bb2: {\n-//        falseEdges -> [real: bb13, imaginary: bb3];\n+//        falseEdges -> [real: bb12, imaginary: bb3];\n //    }\n //    bb3: {\n-//        falseEdges -> [real: bb14, imaginary: bb4];\n+//        falseEdges -> [real: bb13, imaginary: bb4];\n //    }\n //    bb4: {\n-//        falseEdges -> [real: bb15, imaginary: bb5];\n+//        _3 = const 3i32;\n+//        goto -> bb14;\n //    }\n //    bb5: {\n-//        unreachable;\n+//        _7 = Lt(_1, const 10i32);\n+//        switchInt(move _7) -> [false: bb6, otherwise: bb1];\n //    }\n //    bb6: {\n-//        _6 = Le(const 10i32, _1);\n-//        switchInt(move _6) -> [false: bb8, otherwise: bb9];\n+//        _4 = Le(const 10i32, _1);\n+//        switchInt(move _4) -> [false: bb8, otherwise: bb7];\n //    }\n //    bb7: {\n-//        _5 = Lt(_1, const 10i32);\n-//        switchInt(move _5) -> [false: bb6, otherwise: bb1];\n+//        _5 = Le(_1, const 20i32);\n+//        switchInt(move _5) -> [false: bb8, otherwise: bb2];\n //    }\n //    bb8: {\n //        switchInt(_1) -> [-1i32: bb3, otherwise: bb4];\n //    }\n //    bb9: {\n-//        _7 = Le(_1, const 20i32);\n-//        switchInt(move _7) -> [false: bb8, otherwise: bb2];\n-//    }\n-//    bb10: {\n //        _8 = &shallow _1;\n //        StorageLive(_9);\n //        _9 = _2;\n //        FakeRead(ForMatchGuard, _8);\n-//        switchInt(move _9) -> [false: bb12, otherwise: bb11];\n+//        switchInt(move _9) -> [false: bb11, otherwise: bb10];\n //    }\n-//    bb11: {\n+//    bb10: {\n //        StorageDead(_9);\n //        _3 = const 0i32;\n-//        goto -> bb16;\n+//        goto -> bb14;\n //    }\n-//    bb12: {\n+//    bb11: {\n //        StorageDead(_9);\n //        falseEdges -> [real: bb4, imaginary: bb2];\n //    }\n-//    bb13: {\n+//    bb12: {\n //        _3 = const 1i32;\n-//        goto -> bb16;\n+//        goto -> bb14;\n //    }\n-//    bb14: {\n+//    bb13: {\n //        _3 = const 2i32;\n-//        goto -> bb16;\n+//        goto -> bb14;\n //    }\n-//    bb15: {\n-//        _3 = const 3i32;\n-//        goto -> bb16;\n-//    }\n-//    bb16: {\n+//    bb14: {\n //        _0 = ();\n //        StorageDead(_2);\n //        StorageDead(_1);"}, {"sha": "fa0dbe51c5dc3115ca3ce287f330734bf42ace37", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -22,9 +22,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#2r | U0 | {bb2[0..=8], bb3[0], bb6[0..=1]}\n-// | '_#3r | U0 | {bb2[1..=8], bb3[0], bb6[0..=1]}\n-// | '_#4r | U0 | {bb2[4..=8], bb3[0], bb6[0..=1]}\n+// | '_#2r | U0 | {bb2[0..=8], bb3[0], bb5[0..=1]}\n+// | '_#3r | U0 | {bb2[1..=8], bb3[0], bb5[0..=1]}\n+// | '_#4r | U0 | {bb2[4..=8], bb3[0], bb5[0..=1]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n // let _2: &'_#3r usize;"}, {"sha": "0f9c6f62c2bd3608555650ef415b3db014af0e6e", "filename": "src/test/mir-opt/remove_fake_borrows.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -19,21 +19,19 @@ fn main() {\n // bb0: {\n //     FakeRead(ForMatchedPlace, _1);\n //     _3 = discriminant(_1);\n-//     switchInt(move _3) -> [1isize: bb4, otherwise: bb2];\n+//     switchInt(move _3) -> [1isize: bb3, otherwise: bb2];\n // }\n // bb1: {\n-//     goto -> bb5;\n+//     goto -> bb4;\n // }\n // bb2: {\n-//     goto -> bb8;\n+//     _0 = const 1i32;\n+//     goto -> bb7;\n // }\n // bb3: {\n-//     unreachable;\n-// }\n-// bb4: {\n //     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n-// bb5: {\n+// bb4: {\n //     _4 = &shallow _1;\n //     _5 = &shallow ((_1 as Some).0: &'<empty> &'<empty> i32);\n //     _6 = &shallow (*((_1 as Some).0: &'<empty> &'<empty> i32));\n@@ -44,25 +42,21 @@ fn main() {\n //     FakeRead(ForMatchGuard, _5);\n //     FakeRead(ForMatchGuard, _6);\n //     FakeRead(ForMatchGuard, _7);\n-//     switchInt(move _8) -> [false: bb7, otherwise: bb6];\n+//     switchInt(move _8) -> [false: bb6, otherwise: bb5];\n // }\n-// bb6: {\n+// bb5: {\n //     StorageDead(_8);\n //     _0 = const 0i32;\n-//     goto -> bb9;\n+//     goto -> bb7;\n // }\n-// bb7: {\n+// bb6: {\n //     StorageDead(_8);\n //     goto -> bb2;\n // }\n-// bb8: {\n-//     _0 = const 1i32;\n-//     goto -> bb9;\n-// }\n-// bb9: {\n+// bb7: {\n //     return;\n // }\n-// bb10 (cleanup): {\n+// bb8 (cleanup): {\n //     resume;\n // }\n // END rustc.match_guard.CleanupNonCodegenStatements.before.mir\n@@ -71,21 +65,19 @@ fn main() {\n // bb0: {\n //     nop;\n //     _3 = discriminant(_1);\n-//     switchInt(move _3) -> [1isize: bb4, otherwise: bb2];\n+//     switchInt(move _3) -> [1isize: bb3, otherwise: bb2];\n // }\n // bb1: {\n-//     goto -> bb5;\n+//     goto -> bb4;\n // }\n // bb2: {\n-//     goto -> bb8;\n+//     _0 = const 1i32;\n+//     goto -> bb7;\n // }\n // bb3: {\n-//     unreachable;\n-// }\n-// bb4: {\n //     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n-// bb5: {\n+// bb4: {\n //     nop;\n //     nop;\n //     nop;\n@@ -96,25 +88,21 @@ fn main() {\n //     nop;\n //     nop;\n //     nop;\n-//     switchInt(move _8) -> [false: bb7, otherwise: bb6];\n+//     switchInt(move _8) -> [false: bb6, otherwise: bb5];\n // }\n-// bb6: {\n+// bb5: {\n //     StorageDead(_8);\n //     _0 = const 0i32;\n-//     goto -> bb9;\n+//     goto -> bb7;\n // }\n-// bb7: {\n+// bb6: {\n //     StorageDead(_8);\n //     goto -> bb2;\n // }\n-// bb8: {\n-//     _0 = const 1i32;\n-//     goto -> bb9;\n-// }\n-// bb9: {\n+// bb7: {\n //     return;\n // }\n-// bb10 (cleanup): {\n+// bb8 (cleanup): {\n //     resume;\n // }\n // END rustc.match_guard.CleanupNonCodegenStatements.after.mir"}, {"sha": "471c1df3300f0f7b2f6796e8b49854b27e90a488", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -8,12 +8,12 @@ fn main() {\n // START rustc.main.SimplifyBranches-after-const-prop.before.mir\n // bb0: {\n //     ...\n-//     switchInt(const false) -> [false: bb3, otherwise: bb1];\n+//     switchInt(const false) -> [false: bb1, otherwise: bb2];\n // }\n // END rustc.main.SimplifyBranches-after-const-prop.before.mir\n // START rustc.main.SimplifyBranches-after-const-prop.after.mir\n // bb0: {\n //     ...\n-//     goto -> bb3;\n+//     goto -> bb1;\n // }\n // END rustc.main.SimplifyBranches-after-const-prop.after.mir"}, {"sha": "8624899a0abf25f34a4fc69ab298011ec8792668", "filename": "src/test/mir-opt/simplify_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -9,14 +9,14 @@ fn main() {\n // START rustc.main.SimplifyBranches-after-copy-prop.before.mir\n // bb0: {\n //     ...\n-//     switchInt(const false) -> [false: bb3, otherwise: bb1];\n+//     switchInt(const false) -> [false: bb1, otherwise: bb2];\n // }\n // bb1: {\n // END rustc.main.SimplifyBranches-after-copy-prop.before.mir\n // START rustc.main.SimplifyBranches-after-copy-prop.after.mir\n // bb0: {\n //     ...\n-//     goto -> bb3;\n+//     goto -> bb1;\n // }\n // bb1: {\n // END rustc.main.SimplifyBranches-after-copy-prop.after.mir"}, {"sha": "ca1496a6c8d9b6781357a32ee267ec7e2a52e038", "filename": "src/test/ui/borrowck/borrowck-mut-borrow-linear-errors.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.stderr?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -2,22 +2,22 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:10:30\n    |\n LL |             1 => { addr.push(&mut x); }\n-   |                    ----      ^^^^^^ second mutable borrow occurs here\n-   |                    |\n-   |                    first borrow later used here\n+   |                              ^^^^^^ second mutable borrow occurs here\n LL |             2 => { addr.push(&mut x); }\n LL |             _ => { addr.push(&mut x); }\n-   |                              ------ first mutable borrow occurs here\n+   |                    ----      ------ first mutable borrow occurs here\n+   |                    |\n+   |                    first borrow later used here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:11:30\n    |\n-LL |             1 => { addr.push(&mut x); }\n-   |                    ---- first borrow later used here\n LL |             2 => { addr.push(&mut x); }\n    |                              ^^^^^^ second mutable borrow occurs here\n LL |             _ => { addr.push(&mut x); }\n-   |                              ------ first mutable borrow occurs here\n+   |                    ----      ------ first mutable borrow occurs here\n+   |                    |\n+   |                    first borrow later used here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:12:30"}, {"sha": "50757afaf5651422faf3c5ba7b748200f64a7db9", "filename": "src/test/ui/consts/const-eval/match-test-ptr-null.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -6,6 +6,7 @@ fn main() {\n         match &1 as *const i32 as usize {\n             //~^ ERROR casting pointers to integers in constants\n             //~| NOTE for more information, see\n+            //~| ERROR constant contains unimplemented expression type\n             0 => 42, //~ ERROR constant contains unimplemented expression type\n             //~^ NOTE \"pointer arithmetic or comparison\" needs an rfc before being allowed\n             //~| ERROR evaluation of constant value failed"}, {"sha": "167d5ad8d61fe8d277dbac7d3fb04f8a836728fd", "filename": "src/test/ui/consts/const-eval/match-test-ptr-null.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -8,18 +8,24 @@ LL |         match &1 as *const i32 as usize {\n    = help: add #![feature(const_raw_ptr_to_usize_cast)] to the crate attributes to enable\n \n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/match-test-ptr-null.rs:9:13\n+  --> $DIR/match-test-ptr-null.rs:6:15\n+   |\n+LL |         match &1 as *const i32 as usize {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/match-test-ptr-null.rs:10:13\n    |\n LL |             0 => 42,\n    |             ^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/match-test-ptr-null.rs:9:13\n+  --> $DIR/match-test-ptr-null.rs:10:13\n    |\n LL |             0 => 42,\n    |             ^ \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0019, E0080, E0658.\n For more information about an error, try `rustc --explain E0019`."}, {"sha": "6ed3ac2356243186a78b8f0f73351e9daf38aed1", "filename": "src/test/ui/consts/const-match-pattern-arm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -1,13 +1,15 @@\n #![allow(warnings)]\n \n const x: bool = match Some(true) {\n+    //~^ ERROR: constant contains unimplemented expression type [E0019]\n     Some(value) => true,\n     //~^ ERROR: constant contains unimplemented expression type [E0019]\n     _ => false\n };\n \n const y: bool = {\n     match Some(true) {\n+    //~^ ERROR: constant contains unimplemented expression type [E0019]\n         Some(value) => true,\n         //~^ ERROR: constant contains unimplemented expression type [E0019]\n         _ => false"}, {"sha": "709b66b7bf016fd1ff9ae238ab7316698acc4f70", "filename": "src/test/ui/consts/const-match-pattern-arm.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.stderr?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -1,15 +1,27 @@\n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/const-match-pattern-arm.rs:4:5\n+  --> $DIR/const-match-pattern-arm.rs:3:23\n+   |\n+LL | const x: bool = match Some(true) {\n+   |                       ^^^^^^^^^^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/const-match-pattern-arm.rs:5:5\n    |\n LL |     Some(value) => true,\n    |     ^^^^^^^^^^^\n \n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/const-match-pattern-arm.rs:11:9\n+  --> $DIR/const-match-pattern-arm.rs:11:11\n+   |\n+LL |     match Some(true) {\n+   |           ^^^^^^^^^^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/const-match-pattern-arm.rs:13:9\n    |\n LL |         Some(value) => true,\n    |         ^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0019`."}, {"sha": "75793c904838d021d8e2ec69e0625613c423c4de", "filename": "src/test/ui/consts/single_variant_match_ice.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -2,20 +2,21 @@ enum Foo {\n     Prob,\n }\n \n-const FOO: u32 = match Foo::Prob {\n-    Foo::Prob => 42, //~ ERROR unimplemented expression type\n+const FOO: u32 = match Foo::Prob { //~ ERROR unimplemented expression type\n+    Foo::Prob => 42,\n };\n \n-const BAR: u32 = match Foo::Prob {\n-    x => 42, //~ ERROR unimplemented expression type\n+const BAR: u32 = match Foo::Prob { //~ ERROR unimplemented expression type\n+    x => 42,\n };\n \n impl Foo {\n     pub const fn as_val(&self) -> u8 {\n         use self::Foo::*;\n \n         match *self {\n-            Prob => 0x1, //~ ERROR loops and conditional expressions are not stable in const fn\n+            //~^ ERROR loops and conditional expressions are not stable in const fn\n+            Prob => 0x1,\n         }\n     }\n }"}, {"sha": "851733726ac0f67131c80ff1f338f95589657ec3", "filename": "src/test/ui/consts/single_variant_match_ice.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -1,20 +1,20 @@\n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/single_variant_match_ice.rs:6:5\n+  --> $DIR/single_variant_match_ice.rs:5:24\n    |\n-LL |     Foo::Prob => 42,\n-   |     ^^^^^^^^^\n+LL | const FOO: u32 = match Foo::Prob {\n+   |                        ^^^^^^^^^\n \n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/single_variant_match_ice.rs:10:5\n+  --> $DIR/single_variant_match_ice.rs:9:24\n    |\n-LL |     x => 42,\n-   |     ^\n+LL | const BAR: u32 = match Foo::Prob {\n+   |                        ^^^^^^^^^\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n-  --> $DIR/single_variant_match_ice.rs:18:13\n+  --> $DIR/single_variant_match_ice.rs:17:15\n    |\n-LL |             Prob => 0x1,\n-   |             ^^^^\n+LL |         match *self {\n+   |               ^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable"}, {"sha": "aa252efea464ba50b6e495db277c05fe349d5925", "filename": "src/test/ui/issues/issue-46843.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fissues%2Fissue-46843.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fissues%2Fissue-46843.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46843.rs?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -4,7 +4,9 @@ fn non_const() -> Thing {\n     Thing::This\n }\n \n-pub const Q: i32 = match non_const() { //~ ERROR E0015\n+pub const Q: i32 = match non_const() {\n+    //~^ ERROR E0015\n+    //~^^ ERROR unimplemented expression type\n     Thing::This => 1, //~ ERROR unimplemented expression type\n     Thing::That => 0\n };"}, {"sha": "92ee154552c68ca0e67f5256fc1b380d61843e41", "filename": "src/test/ui/issues/issue-46843.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fissues%2Fissue-46843.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Fissues%2Fissue-46843.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46843.stderr?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -5,12 +5,18 @@ LL | pub const Q: i32 = match non_const() {\n    |                          ^^^^^^^^^^^\n \n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/issue-46843.rs:8:5\n+  --> $DIR/issue-46843.rs:7:26\n+   |\n+LL | pub const Q: i32 = match non_const() {\n+   |                          ^^^^^^^^^^^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/issue-46843.rs:10:5\n    |\n LL |     Thing::This => 1,\n    |     ^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0015, E0019.\n For more information about an error, try `rustc --explain E0015`."}, {"sha": "13b6a7bbef3213291cbe82ad79445e3b3a545770", "filename": "src/test/ui/lifetimes/lifetime-errors/liveness-assign-imm-local-notes.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da22793a35b725e2fe2f7e2ac1d808404c39c4aa/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr?ref=da22793a35b725e2fe2f7e2ac1d808404c39c4aa", "patch": "@@ -28,16 +28,16 @@ LL |     let x;\n ...\n LL |             x = 1;\n    |             ^^^^^ cannot assign twice to immutable variable\n+LL |         } else {\n+LL |             x = 2;\n+   |             ----- first assignment to `x`\n \n error[E0384]: cannot assign twice to immutable variable `x`\n   --> $DIR/liveness-assign-imm-local-notes.rs:32:13\n    |\n LL |     let x;\n    |         - help: make this binding mutable: `mut x`\n ...\n-LL |             x = 1;\n-   |             ----- first assignment to `x`\n-LL |         } else {\n LL |             x = 2;\n    |             ^^^^^ cannot assign twice to immutable variable\n "}]}