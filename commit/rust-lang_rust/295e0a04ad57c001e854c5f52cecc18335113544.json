{"sha": "295e0a04ad57c001e854c5f52cecc18335113544", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NWUwYTA0YWQ1N2MwMDFlODU0YzVmNTJjZWNjMTgzMzUxMTM1NDQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-26T03:50:22Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-08T06:28:10Z"}, "message": "native: Implement timeouts for unix networking\n\nThis commit has an implementation of the previous commit's timeout interface for\nI/O objects on unix platforms. For implementation details, see the large comment\nat the end of libnative/io/net.rs which talks about the general strategy taken.\n\nThankfully, all of these implementations can share code because they're\nperforming all the same operations.\n\nThis commit does not implement timeouts for named pipes on windows, only tcp/udp\nobjects on windows (which are quite similar to their unix equivalents).", "tree": {"sha": "b66055fe8b05649eb017ca18dfe2b49f454c41ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b66055fe8b05649eb017ca18dfe2b49f454c41ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/295e0a04ad57c001e854c5f52cecc18335113544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/295e0a04ad57c001e854c5f52cecc18335113544", "html_url": "https://github.com/rust-lang/rust/commit/295e0a04ad57c001e854c5f52cecc18335113544", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/295e0a04ad57c001e854c5f52cecc18335113544/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec", "html_url": "https://github.com/rust-lang/rust/commit/e27f27c8588f5cfa0cd9dfbbdf7609ea2d6818ec"}], "stats": {"total": 650, "additions": 493, "deletions": 157}, "files": [{"sha": "abb22476e5240f4dd0da44aa2e5664fb1acf3b63", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=295e0a04ad57c001e854c5f52cecc18335113544", "patch": "@@ -27,6 +27,13 @@ pub static FIOCLEX: libc::c_ulong = 0x20006601;\n #[cfg(target_os = \"android\")]\n pub static FIOCLEX: libc::c_ulong = 0x5451;\n \n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+pub static MSG_DONTWAIT: libc::c_int = 0x80;\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+pub static MSG_DONTWAIT: libc::c_int = 0x40;\n+\n extern {\n     pub fn gettimeofday(timeval: *mut libc::timeval,\n                         tzp: *libc::c_void) -> libc::c_int;"}, {"sha": "151111af3dfede70c89da99ece05772f6926325a", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=295e0a04ad57c001e854c5f52cecc18335113544", "patch": "@@ -18,6 +18,7 @@ pub static WSADESCRIPTION_LEN: uint = 256;\n pub static WSASYS_STATUS_LEN: uint = 128;\n pub static FIONBIO: libc::c_long = 0x8004667e;\n static FD_SETSIZE: uint = 64;\n+pub static MSG_DONTWAIT: libc::c_int = 0;\n \n pub struct WSADATA {\n     pub wVersion: libc::WORD,"}, {"sha": "87225a10e76d50cfda0ae3626cf7c47933a8b236", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=295e0a04ad57c001e854c5f52cecc18335113544", "patch": "@@ -189,6 +189,9 @@ impl rtio::RtioPipe for FileDesc {\n     fn close_write(&mut self) -> Result<(), IoError> {\n         Err(io::standard_error(io::InvalidInput))\n     }\n+    fn set_timeout(&mut self, _t: Option<u64>) {}\n+    fn set_read_timeout(&mut self, _t: Option<u64>) {}\n+    fn set_write_timeout(&mut self, _t: Option<u64>) {}\n }\n \n impl rtio::RtioTTY for FileDesc {"}, {"sha": "282f9c2e343475e2079ec6dce95b068931435090", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=295e0a04ad57c001e854c5f52cecc18335113544", "patch": "@@ -221,6 +221,9 @@ impl rtio::RtioPipe for FileDesc {\n     fn close_write(&mut self) -> IoResult<()> {\n         Err(io::standard_error(io::InvalidInput))\n     }\n+    fn set_timeout(&mut self, _t: Option<u64>) {}\n+    fn set_read_timeout(&mut self, _t: Option<u64>) {}\n+    fn set_write_timeout(&mut self, _t: Option<u64>) {}\n }\n \n impl rtio::RtioTTY for FileDesc {"}, {"sha": "06105b46244ae8fc80016023d5580722dda61f12", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 353, "deletions": 104, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=295e0a04ad57c001e854c5f52cecc18335113544", "patch": "@@ -15,6 +15,7 @@ use std::io;\n use std::mem;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n+use std::unstable::mutex;\n \n use super::{IoResult, retry, keep_going};\n use super::c;\n@@ -236,22 +237,36 @@ pub fn init() {\n \n pub struct TcpStream {\n     inner: UnsafeArc<Inner>,\n+    read_deadline: u64,\n+    write_deadline: u64,\n }\n \n struct Inner {\n     fd: sock_t,\n+    lock: mutex::NativeMutex,\n+}\n+\n+pub struct Guard<'a> {\n+    pub fd: sock_t,\n+    pub guard: mutex::LockGuard<'a>,\n+}\n+\n+impl Inner {\n+    fn new(fd: sock_t) -> Inner {\n+        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+    }\n }\n \n impl TcpStream {\n     pub fn connect(addr: ip::SocketAddr,\n                    timeout: Option<u64>) -> IoResult<TcpStream> {\n         let fd = try!(socket(addr, libc::SOCK_STREAM));\n-        let (addr, len) = addr_to_sockaddr(addr);\n-        let inner = Inner { fd: fd };\n-        let ret = TcpStream { inner: UnsafeArc::new(inner) };\n+        let ret = TcpStream::new(Inner::new(fd));\n \n-        let len = len as libc::socklen_t;\n+        let (addr, len) = addr_to_sockaddr(addr);\n         let addrp = &addr as *_ as *libc::sockaddr;\n+        let len = len as libc::socklen_t;\n+\n         match timeout {\n             Some(timeout) => {\n                 try!(util::connect_timeout(fd, addrp, len, timeout));\n@@ -266,6 +281,14 @@ impl TcpStream {\n         }\n     }\n \n+    fn new(inner: Inner) -> TcpStream {\n+        TcpStream {\n+            inner: UnsafeArc::new(inner),\n+            read_deadline: 0,\n+            write_deadline: 0,\n+        }\n+    }\n+\n     pub fn fd(&self) -> sock_t {\n         // This unsafety is fine because it's just a read-only arc\n         unsafe { (*self.inner.get()).fd }\n@@ -299,40 +322,51 @@ impl TcpStream {\n     fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {\n         Ok(())\n     }\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn lock_nonblocking(&self) {}\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n+        let ret = Guard {\n+            fd: self.fd(),\n+            guard: unsafe { (*self.inner.get()).lock.lock() },\n+        };\n+        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        ret\n+    }\n }\n \n #[cfg(windows)] type wrlen = libc::c_int;\n #[cfg(not(windows))] type wrlen = libc::size_t;\n \n impl rtio::RtioTcpStream for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let ret = retry(|| {\n-            unsafe {\n-                libc::recv(self.fd(),\n-                           buf.as_mut_ptr() as *mut libc::c_void,\n-                           buf.len() as wrlen,\n-                           0) as libc::c_int\n-            }\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n+        let fd = self.fd();\n+        let dolock = || self.lock_nonblocking();\n+        let doread = |nb| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::recv(fd,\n+                       buf.as_mut_ptr() as *mut libc::c_void,\n+                       buf.len() as wrlen,\n+                       flags) as libc::c_int\n+        };\n+        read(fd, self.read_deadline, dolock, doread)\n     }\n+\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| unsafe {\n-            libc::send(self.fd(),\n+        let fd = self.fd();\n+        let dolock = || self.lock_nonblocking();\n+        let dowrite = |nb: bool, buf: *u8, len: uint| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::send(fd,\n                        buf as *mut libc::c_void,\n                        len as wrlen,\n-                       0) as i64\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n+                       flags) as i64\n+        };\n+        match write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n+            Ok(_) => Ok(()),\n+            Err(e) => Err(e)\n         }\n     }\n     fn peer_name(&mut self) -> IoResult<ip::SocketAddr> {\n@@ -354,14 +388,29 @@ impl rtio::RtioTcpStream for TcpStream {\n     fn clone(&self) -> Box<rtio::RtioTcpStream:Send> {\n         box TcpStream {\n             inner: self.inner.clone(),\n+            read_deadline: 0,\n+            write_deadline: 0,\n         } as Box<rtio::RtioTcpStream:Send>\n     }\n+\n     fn close_write(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n     }\n     fn close_read(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n     }\n+\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+        self.read_deadline = deadline;\n+        self.write_deadline = deadline;\n+    }\n+    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n+    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n }\n \n impl rtio::RtioSocket for TcpStream {\n@@ -374,6 +423,13 @@ impl Drop for Inner {\n     fn drop(&mut self) { unsafe { close(self.fd); } }\n }\n \n+#[unsafe_destructor]\n+impl<'a> Drop for Guard<'a> {\n+    fn drop(&mut self) {\n+        assert!(util::set_nonblocking(self.fd, false).is_ok());\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // TCP listeners\n ////////////////////////////////////////////////////////////////////////////////\n@@ -384,29 +440,24 @@ pub struct TcpListener {\n \n impl TcpListener {\n     pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n-        unsafe {\n-            socket(addr, libc::SOCK_STREAM).and_then(|fd| {\n-                let (addr, len) = addr_to_sockaddr(addr);\n-                let addrp = &addr as *libc::sockaddr_storage;\n-                let inner = Inner { fd: fd };\n-                let ret = TcpListener { inner: inner };\n-                // On platforms with Berkeley-derived sockets, this allows\n-                // to quickly rebind a socket, without needing to wait for\n-                // the OS to clean up the previous one.\n-                if cfg!(unix) {\n-                    match setsockopt(fd, libc::SOL_SOCKET,\n-                                     libc::SO_REUSEADDR,\n-                                     1 as libc::c_int) {\n-                        Err(n) => { return Err(n); },\n-                        Ok(..) => { }\n-                    }\n-                }\n-                match libc::bind(fd, addrp as *libc::sockaddr,\n-                                 len as libc::socklen_t) {\n-                    -1 => Err(last_error()),\n-                    _ => Ok(ret),\n-                }\n-            })\n+        let fd = try!(socket(addr, libc::SOCK_STREAM));\n+        let ret = TcpListener { inner: Inner::new(fd) };\n+\n+        let (addr, len) = addr_to_sockaddr(addr);\n+        let addrp = &addr as *_ as *libc::sockaddr;\n+        let len = len as libc::socklen_t;\n+\n+        // On platforms with Berkeley-derived sockets, this allows\n+        // to quickly rebind a socket, without needing to wait for\n+        // the OS to clean up the previous one.\n+        if cfg!(unix) {\n+            try!(setsockopt(fd, libc::SOL_SOCKET, libc::SO_REUSEADDR,\n+                            1 as libc::c_int));\n+        }\n+\n+        match unsafe { libc::bind(fd, addrp, len) } {\n+            -1 => Err(last_error()),\n+            _ => Ok(ret),\n         }\n     }\n \n@@ -444,7 +495,7 @@ impl TcpAcceptor {\n \n     pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n         if self.deadline != 0 {\n-            try!(util::accept_deadline(self.fd(), self.deadline));\n+            try!(util::await(self.fd(), Some(self.deadline), util::Readable));\n         }\n         unsafe {\n             let mut storage: libc::sockaddr_storage = mem::init();\n@@ -457,7 +508,7 @@ impl TcpAcceptor {\n                              &mut size as *mut libc::socklen_t) as libc::c_int\n             }) as sock_t {\n                 -1 => Err(last_error()),\n-                fd => Ok(TcpStream { inner: UnsafeArc::new(Inner { fd: fd })})\n+                fd => Ok(TcpStream::new(Inner::new(fd))),\n             }\n         }\n     }\n@@ -487,22 +538,26 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n \n pub struct UdpSocket {\n     inner: UnsafeArc<Inner>,\n+    read_deadline: u64,\n+    write_deadline: u64,\n }\n \n impl UdpSocket {\n     pub fn bind(addr: ip::SocketAddr) -> IoResult<UdpSocket> {\n-        unsafe {\n-            socket(addr, libc::SOCK_DGRAM).and_then(|fd| {\n-                let (addr, len) = addr_to_sockaddr(addr);\n-                let addrp = &addr as *libc::sockaddr_storage;\n-                let inner = Inner { fd: fd };\n-                let ret = UdpSocket { inner: UnsafeArc::new(inner) };\n-                match libc::bind(fd, addrp as *libc::sockaddr,\n-                                 len as libc::socklen_t) {\n-                    -1 => Err(last_error()),\n-                    _ => Ok(ret),\n-                }\n-            })\n+        let fd = try!(socket(addr, libc::SOCK_DGRAM));\n+        let ret = UdpSocket {\n+            inner: UnsafeArc::new(Inner::new(fd)),\n+            read_deadline: 0,\n+            write_deadline: 0,\n+        };\n+\n+        let (addr, len) = addr_to_sockaddr(addr);\n+        let addrp = &addr as *_ as *libc::sockaddr;\n+        let len = len as libc::socklen_t;\n+\n+        match unsafe { libc::bind(fd, addrp, len) } {\n+            -1 => Err(last_error()),\n+            _ => Ok(ret),\n         }\n     }\n \n@@ -541,6 +596,19 @@ impl UdpSocket {\n             }\n         }\n     }\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn lock_nonblocking(&self) {}\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n+        let ret = Guard {\n+            fd: self.fd(),\n+            guard: unsafe { (*self.inner.get()).lock.lock() },\n+        };\n+        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        ret\n+    }\n }\n \n impl rtio::RtioSocket for UdpSocket {\n@@ -554,48 +622,54 @@ impl rtio::RtioSocket for UdpSocket {\n \n impl rtio::RtioUdpSocket for UdpSocket {\n     fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, ip::SocketAddr)> {\n-        unsafe {\n-            let mut storage: libc::sockaddr_storage = mem::init();\n-            let storagep = &mut storage as *mut libc::sockaddr_storage;\n-            let mut addrlen: libc::socklen_t =\n-                    mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n-            let ret = retry(|| {\n-                libc::recvfrom(self.fd(),\n-                               buf.as_ptr() as *mut libc::c_void,\n-                               buf.len() as msglen_t,\n-                               0,\n-                               storagep as *mut libc::sockaddr,\n-                               &mut addrlen) as libc::c_int\n-            });\n-            if ret < 0 { return Err(last_error()) }\n-            sockaddr_to_addr(&storage, addrlen as uint).and_then(|addr| {\n-                Ok((ret as uint, addr))\n-            })\n-        }\n+        let fd = self.fd();\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::init() };\n+        let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n+        let mut addrlen: libc::socklen_t =\n+                mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n+\n+        let dolock = || self.lock_nonblocking();\n+        let doread = |nb| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::recvfrom(fd,\n+                           buf.as_mut_ptr() as *mut libc::c_void,\n+                           buf.len() as msglen_t,\n+                           flags,\n+                           storagep,\n+                           &mut addrlen) as libc::c_int\n+        };\n+        let n = try!(read(fd, self.read_deadline, dolock, doread));\n+        sockaddr_to_addr(&storage, addrlen as uint).and_then(|addr| {\n+            Ok((n as uint, addr))\n+        })\n     }\n+\n     fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> IoResult<()> {\n-        let (dst, len) = addr_to_sockaddr(dst);\n-        let dstp = &dst as *libc::sockaddr_storage;\n-        unsafe {\n-            let ret = retry(|| {\n-                libc::sendto(self.fd(),\n-                             buf.as_ptr() as *libc::c_void,\n-                             buf.len() as msglen_t,\n-                             0,\n-                             dstp as *libc::sockaddr,\n-                             len as libc::socklen_t) as libc::c_int\n-            });\n-            match ret {\n-                -1 => Err(last_error()),\n-                n if n as uint != buf.len() => {\n-                    Err(io::IoError {\n-                        kind: io::OtherIoError,\n-                        desc: \"couldn't send entire packet at once\",\n-                        detail: None,\n-                    })\n-                }\n-                _ => Ok(())\n-            }\n+        let (dst, dstlen) = addr_to_sockaddr(dst);\n+        let dstp = &dst as *_ as *libc::sockaddr;\n+        let dstlen = dstlen as libc::socklen_t;\n+\n+        let fd = self.fd();\n+        let dolock = || self.lock_nonblocking();\n+        let dowrite = |nb, buf: *u8, len: uint| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::sendto(fd,\n+                         buf as *libc::c_void,\n+                         len as msglen_t,\n+                         flags,\n+                         dstp,\n+                         dstlen) as i64\n+        };\n+\n+        let n = try!(write(fd, self.write_deadline, buf, false, dolock, dowrite));\n+        if n != buf.len() {\n+            Err(io::IoError {\n+                kind: io::ShortWrite(n),\n+                desc: \"couldn't send entire packet at once\",\n+                detail: None,\n+            })\n+        } else {\n+            Ok(())\n         }\n     }\n \n@@ -645,6 +719,181 @@ impl rtio::RtioUdpSocket for UdpSocket {\n     fn clone(&self) -> Box<rtio::RtioUdpSocket:Send> {\n         box UdpSocket {\n             inner: self.inner.clone(),\n+            read_deadline: 0,\n+            write_deadline: 0,\n         } as Box<rtio::RtioUdpSocket:Send>\n     }\n+\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+        self.read_deadline = deadline;\n+        self.write_deadline = deadline;\n+    }\n+    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n+    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Timeout helpers\n+//\n+// The read/write functions below are the helpers for reading/writing a socket\n+// with a possible deadline specified. This is generally viewed as a timed out\n+// I/O operation.\n+//\n+// From the application's perspective, timeouts apply to the I/O object, not to\n+// the underlying file descriptor (it's one timeout per object). This means that\n+// we can't use the SO_RCVTIMEO and corresponding send timeout option.\n+//\n+// The next idea to implement timeouts would be to use nonblocking I/O. An\n+// invocation of select() would wait (with a timeout) for a socket to be ready.\n+// Once its ready, we can perform the operation. Note that the operation *must*\n+// be nonblocking, even though select() says the socket is ready. This is\n+// because some other thread could have come and stolen our data (handles can be\n+// cloned).\n+//\n+// To implement nonblocking I/O, the first option we have is to use the\n+// O_NONBLOCK flag. Remember though that this is a global setting, affecting all\n+// I/O objects, so this was initially viewed as unwise.\n+//\n+// It turns out that there's this nifty MSG_DONTWAIT flag which can be passed to\n+// send/recv, but the niftiness wears off once you realize it only works well on\n+// linux [1] [2]. This means that it's pretty easy to get a nonblocking\n+// operation on linux (no flag fidding, no affecting other objects), but not on\n+// other platforms.\n+//\n+// To work around this constraint on other platforms, we end up using the\n+// original strategy of flipping the O_NONBLOCK flag. As mentioned before, this\n+// could cause other objects' blocking operations to suddenly become\n+// nonblocking. To get around this, a \"blocking operation\" which returns EAGAIN\n+// falls back to using the same code path as nonblocking operations, but with an\n+// infinite timeout (select + send/recv). This helps emulate blocking\n+// reads/writes despite the underlying descriptor being nonblocking, as well as\n+// optimizing the fast path of just hitting one syscall in the good case.\n+//\n+// As a final caveat, this implementation uses a mutex so only one thread is\n+// doing a nonblocking operation at at time. This is the operation that comes\n+// after the select() (at which point we think the socket is ready). This is\n+// done for sanity to ensure that the state of the O_NONBLOCK flag is what we\n+// expect (wouldn't want someone turning it on when it should be off!). All\n+// operations performed in the lock are *nonblocking* to avoid holding the mutex\n+// forever.\n+//\n+// So, in summary, linux uses MSG_DONTWAIT and doesn't need mutexes, everyone\n+// else uses O_NONBLOCK and mutexes with some trickery to make sure blocking\n+// reads/writes are still blocking.\n+//\n+// Fun, fun!\n+//\n+// [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n+// [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n+\n+pub fn read<T>(fd: sock_t,\n+               deadline: u64,\n+               lock: || -> T,\n+               read: |bool| -> libc::c_int) -> IoResult<uint> {\n+    let mut ret = -1;\n+    if deadline == 0 {\n+        ret = retry(|| read(false));\n+    }\n+\n+    if deadline != 0 || (ret == -1 && util::wouldblock()) {\n+        let deadline = match deadline {\n+            0 => None,\n+            n => Some(n),\n+        };\n+        loop {\n+            // With a timeout, first we wait for the socket to become\n+            // readable using select(), specifying the relevant timeout for\n+            // our previously set deadline.\n+            try!(util::await(fd, deadline, util::Readable));\n+\n+            // At this point, we're still within the timeout, and we've\n+            // determined that the socket is readable (as returned by\n+            // select). We must still read the socket in *nonblocking* mode\n+            // because some other thread could come steal our data. If we\n+            // fail to read some data, we retry (hence the outer loop) and\n+            // wait for the socket to become readable again.\n+            let _guard = lock();\n+            match retry(|| read(deadline.is_some())) {\n+                -1 if util::wouldblock() => { assert!(deadline.is_some()); }\n+                -1 => return Err(last_error()),\n+               n => { ret = n; break }\n+            }\n+        }\n+    }\n+\n+    match ret {\n+        0 => Err(io::standard_error(io::EndOfFile)),\n+        n if n < 0 => Err(last_error()),\n+        n => Ok(n as uint)\n+    }\n+}\n+\n+pub fn write<T>(fd: sock_t,\n+                deadline: u64,\n+                buf: &[u8],\n+                write_everything: bool,\n+                lock: || -> T,\n+                write: |bool, *u8, uint| -> i64) -> IoResult<uint> {\n+    let mut ret = -1;\n+    let mut written = 0;\n+    if deadline == 0 {\n+        if write_everything {\n+            ret = keep_going(buf, |inner, len| {\n+                written = buf.len() - len;\n+                write(false, inner, len)\n+            });\n+        } else {\n+            ret = retry(|| {\n+                write(false, buf.as_ptr(), buf.len()) as libc::c_int\n+            }) as i64;\n+            if ret > 0 { written = ret as uint; }\n+        }\n+    }\n+\n+    if deadline != 0 || (ret == -1 && util::wouldblock()) {\n+        let deadline = match deadline {\n+            0 => None,\n+            n => Some(n),\n+        };\n+        while written < buf.len() && (write_everything || written == 0) {\n+            // As with read(), first wait for the socket to be ready for\n+            // the I/O operation.\n+            match util::await(fd, deadline, util::Writable) {\n+                Err(ref e) if e.kind == io::TimedOut && written > 0 => {\n+                    assert!(deadline.is_some());\n+                    return Err(io::IoError {\n+                        kind: io::ShortWrite(written),\n+                        desc: \"short write\",\n+                        detail: None,\n+                    })\n+                }\n+                Err(e) => return Err(e),\n+                Ok(()) => {}\n+            }\n+\n+            // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n+            // against unforseen circumstances.\n+            let _guard = lock();\n+            let ptr = buf.slice_from(written).as_ptr();\n+            let len = buf.len() - written;\n+            match retry(|| write(deadline.is_some(), ptr, len) as libc::c_int) {\n+                -1 if util::wouldblock() => {}\n+                -1 => return Err(last_error()),\n+                n => { written += n as uint; }\n+            }\n+        }\n+        ret = 0;\n+    }\n+    if ret < 0 {\n+        Err(last_error())\n+    } else {\n+        Ok(written)\n+>>>>>>> native: Implement timeouts for unix networking\n+>>>>>>> native: Implement timeouts for unix networking\n+    }\n }"}, {"sha": "966c711525b3c747acd687173ba6f90131273893", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 70, "deletions": 29, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=295e0a04ad57c001e854c5f52cecc18335113544", "patch": "@@ -16,9 +16,12 @@ use std::io;\n use std::mem;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n+use std::unstable::mutex;\n \n-use super::{IoResult, retry, keep_going};\n+use super::{IoResult, retry};\n+use super::net;\n use super::util;\n+use super::c;\n use super::file::fd_t;\n \n fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n@@ -55,6 +58,13 @@ fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint\n \n struct Inner {\n     fd: fd_t,\n+    lock: mutex::NativeMutex,\n+}\n+\n+impl Inner {\n+    fn new(fd: fd_t) -> Inner {\n+        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+    }\n }\n \n impl Drop for Inner {\n@@ -64,7 +74,7 @@ impl Drop for Inner {\n fn connect(addr: &CString, ty: libc::c_int,\n            timeout: Option<u64>) -> IoResult<Inner> {\n     let (addr, len) = try!(addr_to_sockaddr_un(addr));\n-    let inner = Inner { fd: try!(unix_socket(ty)) };\n+    let inner = Inner::new(try!(unix_socket(ty)));\n     let addrp = &addr as *_ as *libc::sockaddr;\n     let len = len as libc::socklen_t;\n \n@@ -84,7 +94,7 @@ fn connect(addr: &CString, ty: libc::c_int,\n \n fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n     let (addr, len) = try!(addr_to_sockaddr_un(addr));\n-    let inner = Inner { fd: try!(unix_socket(ty)) };\n+    let inner = Inner::new(try!(unix_socket(ty)));\n     let addrp = &addr as *libc::sockaddr_storage;\n     match unsafe {\n         libc::bind(inner.fd, addrp as *libc::sockaddr, len as libc::socklen_t)\n@@ -100,54 +110,74 @@ fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n \n pub struct UnixStream {\n     inner: UnsafeArc<Inner>,\n+    read_deadline: u64,\n+    write_deadline: u64,\n }\n \n impl UnixStream {\n     pub fn connect(addr: &CString,\n                    timeout: Option<u64>) -> IoResult<UnixStream> {\n         connect(addr, libc::SOCK_STREAM, timeout).map(|inner| {\n-            UnixStream { inner: UnsafeArc::new(inner) }\n+            UnixStream::new(UnsafeArc::new(inner))\n         })\n     }\n \n+    fn new(inner: UnsafeArc<Inner>) -> UnixStream {\n+        UnixStream {\n+            inner: inner,\n+            read_deadline: 0,\n+            write_deadline: 0,\n+        }\n+    }\n+\n     fn fd(&self) -> fd_t { unsafe { (*self.inner.get()).fd } }\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn lock_nonblocking(&self) {}\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn lock_nonblocking<'a>(&'a self) -> net::Guard<'a> {\n+        let ret = net::Guard {\n+            fd: self.fd(),\n+            guard: unsafe { (*self.inner.get()).lock.lock() },\n+        };\n+        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        ret\n+    }\n }\n \n impl rtio::RtioPipe for UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let ret = retry(|| unsafe {\n-            libc::recv(self.fd(),\n-                       buf.as_ptr() as *mut libc::c_void,\n+        let fd = self.fd();\n+        let dolock = || self.lock_nonblocking();\n+        let doread = |nb| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::recv(fd,\n+                       buf.as_mut_ptr() as *mut libc::c_void,\n                        buf.len() as libc::size_t,\n-                       0) as libc::c_int\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n+                       flags) as libc::c_int\n+        };\n+        net::read(fd, self.read_deadline, dolock, doread)\n     }\n \n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| unsafe {\n-            libc::send(self.fd(),\n+        let fd = self.fd();\n+        let dolock = || self.lock_nonblocking();\n+        let dowrite = |nb: bool, buf: *u8, len: uint| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::send(fd,\n                        buf as *mut libc::c_void,\n                        len as libc::size_t,\n-                       0) as i64\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n+                       flags)\n+        };\n+        match net::write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n+            Ok(_) => Ok(()),\n+            Err(e) => Err(e)\n         }\n     }\n \n     fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n-        box UnixStream {\n-            inner: self.inner.clone(),\n-        } as Box<rtio::RtioPipe:Send>\n+        box UnixStream::new(self.inner.clone()) as Box<rtio::RtioPipe:Send>\n     }\n \n     fn close_write(&mut self) -> IoResult<()> {\n@@ -156,6 +186,17 @@ impl rtio::RtioPipe for UnixStream {\n     fn close_read(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n     }\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+        self.read_deadline = deadline;\n+        self.write_deadline = deadline;\n+    }\n+    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n+    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -202,7 +243,7 @@ impl UnixAcceptor {\n \n     pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n         if self.deadline != 0 {\n-            try!(util::accept_deadline(self.fd(), self.deadline));\n+            try!(util::await(self.fd(), Some(self.deadline), util::Readable));\n         }\n         let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n         let storagep = &mut storage as *mut libc::sockaddr_storage;\n@@ -214,7 +255,7 @@ impl UnixAcceptor {\n                          &mut size as *mut libc::socklen_t) as libc::c_int\n         }) {\n             -1 => Err(super::last_error()),\n-            fd => Ok(UnixStream { inner: UnsafeArc::new(Inner { fd: fd }) })\n+            fd => Ok(UnixStream::new(UnsafeArc::new(Inner::new(fd))))\n         }\n     }\n }"}, {"sha": "0d032f9f4bcda7dd09abf9ec1712f79ad0e2371c", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 56, "deletions": 24, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/295e0a04ad57c001e854c5f52cecc18335113544/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=295e0a04ad57c001e854c5f52cecc18335113544", "patch": "@@ -12,12 +12,19 @@ use libc;\n use std::io::IoResult;\n use std::io;\n use std::mem;\n+use std::os;\n use std::ptr;\n \n use super::c;\n use super::net;\n use super::{retry, last_error};\n \n+#[deriving(Show)]\n+pub enum SocketStatus {\n+    Readable,\n+    Writable,\n+}\n+\n pub fn timeout(desc: &'static str) -> io::IoError {\n     io::IoError {\n         kind: io::TimedOut,\n@@ -33,6 +40,34 @@ pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n     }\n }\n \n+#[cfg(unix)]\n+pub fn wouldblock() -> bool {\n+    let err = os::errno();\n+    err == libc::EWOULDBLOCK as int || err == libc::EAGAIN as int\n+}\n+\n+#[cfg(windows)]\n+pub fn wouldblock() -> bool {\n+    let err = os::errno();\n+    err == libc::WSAEWOULDBLOCK as uint\n+}\n+\n+#[cfg(unix)]\n+pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n+    let set = nb as libc::c_int;\n+    super::mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n+}\n+\n+#[cfg(windows)]\n+pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n+    let mut set = nb as libc::c_ulong;\n+    if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n+        Err(last_error())\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n // See http://developerweb.net/viewtopic.php?id=3196 for where this is\n // derived from.\n pub fn connect_timeout(fd: net::sock_t,\n@@ -79,22 +114,6 @@ pub fn connect_timeout(fd: net::sock_t,\n     try!(set_nonblocking(fd, false));\n     return ret;\n \n-    #[cfg(unix)]\n-    fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n-        let set = nb as libc::c_int;\n-        super::mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n-    }\n-\n-    #[cfg(windows)]\n-    fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n-        let mut set = nb as libc::c_ulong;\n-        if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n-            Err(last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n     #[cfg(unix)]\n     fn await(fd: net::sock_t, set: &mut c::fd_set,\n              timeout: u64) -> libc::c_int {\n@@ -116,21 +135,34 @@ pub fn connect_timeout(fd: net::sock_t,\n     }\n }\n \n-pub fn accept_deadline(fd: net::sock_t, deadline: u64) -> IoResult<()> {\n+pub fn await(fd: net::sock_t, deadline: Option<u64>,\n+             status: SocketStatus) -> IoResult<()> {\n     let mut set: c::fd_set = unsafe { mem::init() };\n     c::fd_set(&mut set, fd);\n+    let (read, write) = match status {\n+        Readable => (&set as *_, ptr::null()),\n+        Writable => (ptr::null(), &set as *_),\n+    };\n+    let mut tv: libc::timeval = unsafe { mem::init() };\n \n     match retry(|| {\n-        // If we're past the deadline, then pass a 0 timeout to select() so\n-        // we can poll the status of the socket.\n         let now = ::io::timer::now();\n-        let ms = if deadline < now {0} else {deadline - now};\n-        let tv = ms_to_timeval(ms);\n+        let tvp = match deadline {\n+            None => ptr::null(),\n+            Some(deadline) => {\n+                // If we're past the deadline, then pass a 0 timeout to\n+                // select() so we can poll the status\n+                let ms = if deadline < now {0} else {deadline - now};\n+                tv = ms_to_timeval(ms);\n+                &tv as *_\n+            }\n+        };\n         let n = if cfg!(windows) {1} else {fd as libc::c_int + 1};\n-        unsafe { c::select(n, &set, ptr::null(), ptr::null(), &tv) }\n+        let r = unsafe { c::select(n, read, write, ptr::null(), tvp) };\n+        r\n     }) {\n         -1 => Err(last_error()),\n-        0 => Err(timeout(\"accept timed out\")),\n-        _ => return Ok(()),\n+        0 => Err(timeout(\"timed out\")),\n+        _ => Ok(()),\n     }\n }"}]}