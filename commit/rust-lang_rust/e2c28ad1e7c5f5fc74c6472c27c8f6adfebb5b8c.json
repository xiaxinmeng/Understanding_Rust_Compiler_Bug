{"sha": "e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c", "node_id": "C_kwDOAAsO6NoAKGUyYzI4YWQxZTdjNWY1ZmM3NGM2NDcyYzI3YzhmNmFkZmViYjViOGM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-10-15T05:44:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-15T05:44:47Z"}, "message": "Rollup merge of #89870 - tmandry:box-pin, r=estebank\n\nSuggest Box::pin when Pin::new is used instead\n\nThis fixes an incorrect diagnostic.\n\n**Based on #89390**; only the last commit is specific to this PR. \"Ignore whitespace changes\" also helps here.", "tree": {"sha": "77ed2b72260b447bcaaf197ee555fb942084f5fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77ed2b72260b447bcaaf197ee555fb942084f5fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhaRVQCRBK7hj4Ov3rIwAAd8kIAKUKwxVZZmz/wKUEhzUGuDtb\nWrVtq3KrLzbUQ7jOLHAtP4CoAcnNwM1RaIaFlHJklG3nmVVsgPd9aHxELYZv4HTB\nyaBjfi02urA+XKjA69up0UbC/iYOUHurlVQ/eWtciPlB+OTV0hn3n93JfcrUVrm5\nQd5YDH4/kyZaeZvQx8SD8506IYKIcPy0Vuhd9Vu+fGXs4XHh1NSQHhbOrv3aI+TD\n1IB0ikxRCqXbRi/tNcXsYqVdrcZzo3BcwTu3uGA3JHcHk7HcZwKOtK0OFDZGEMD+\ncOKUBT1xY1cXLVkKfqBEEIusAleDitXHJPBa6yEfszrHhYEo6N+R2V8s8uX5ANo=\n=5xjt\n-----END PGP SIGNATURE-----\n", "payload": "tree 77ed2b72260b447bcaaf197ee555fb942084f5fb\nparent 345d483e9573c2217f72e7a54e76ba1f99b4eb06\nparent d18502d6b347732a16dd45811d55111277802611\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1634276687 +0200\ncommitter GitHub <noreply@github.com> 1634276687 +0200\n\nRollup merge of #89870 - tmandry:box-pin, r=estebank\n\nSuggest Box::pin when Pin::new is used instead\n\nThis fixes an incorrect diagnostic.\n\n**Based on #89390**; only the last commit is specific to this PR. \"Ignore whitespace changes\" also helps here.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c", "html_url": "https://github.com/rust-lang/rust/commit/e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "345d483e9573c2217f72e7a54e76ba1f99b4eb06", "url": "https://api.github.com/repos/rust-lang/rust/commits/345d483e9573c2217f72e7a54e76ba1f99b4eb06", "html_url": "https://github.com/rust-lang/rust/commit/345d483e9573c2217f72e7a54e76ba1f99b4eb06"}, {"sha": "d18502d6b347732a16dd45811d55111277802611", "url": "https://api.github.com/repos/rust-lang/rust/commits/d18502d6b347732a16dd45811d55111277802611", "html_url": "https://github.com/rust-lang/rust/commit/d18502d6b347732a16dd45811d55111277802611"}], "stats": {"total": 110, "additions": 67, "deletions": 43}, "files": [{"sha": "babc06822ac529baa6b4a3b8b59d2afe1e94b2cc", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 60, "deletions": 30, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c", "patch": "@@ -8,11 +8,11 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{Expr, ExprKind, ItemKind, Node, Stmt, StmtKind};\n+use rustc_hir::{Expr, ExprKind, ItemKind, Node, Path, QPath, Stmt, StmtKind, TyKind};\n use rustc_infer::infer;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Binder, Ty};\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, sym};\n \n use std::iter;\n \n@@ -350,6 +350,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// When encountering an `impl Future` where `BoxFuture` is expected, suggest `Box::pin`.\n+    #[instrument(skip(self, err))]\n     pub(in super::super) fn suggest_calling_boxed_future_when_appropriate(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -368,41 +369,70 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if pin_did.is_none() || self.tcx.lang_items().owned_box().is_none() {\n             return false;\n         }\n-        match expected.kind() {\n-            ty::Adt(def, _) if Some(def.did) == pin_did => (),\n-            _ => return false,\n-        }\n         let box_found = self.tcx.mk_box(found);\n         let pin_box_found = self.tcx.mk_lang_item(box_found, LangItem::Pin).unwrap();\n         let pin_found = self.tcx.mk_lang_item(found, LangItem::Pin).unwrap();\n-        if self.can_coerce(pin_box_found, expected) {\n-            debug!(\"can coerce {:?} to {:?}, suggesting Box::pin\", pin_box_found, expected);\n-            match found.kind() {\n-                ty::Adt(def, _) if def.is_box() => {\n-                    err.help(\"use `Box::pin`\");\n-                }\n-                _ => {\n-                    err.multipart_suggestion(\n-                        \"you need to pin and box this expression\",\n-                        vec![\n-                            (expr.span.shrink_to_lo(), \"Box::pin(\".to_string()),\n-                            (expr.span.shrink_to_hi(), \")\".to_string()),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    );\n+        match expected.kind() {\n+            ty::Adt(def, _) if Some(def.did) == pin_did => {\n+                if self.can_coerce(pin_box_found, expected) {\n+                    debug!(\"can coerce {:?} to {:?}, suggesting Box::pin\", pin_box_found, expected);\n+                    match found.kind() {\n+                        ty::Adt(def, _) if def.is_box() => {\n+                            err.help(\"use `Box::pin`\");\n+                        }\n+                        _ => {\n+                            err.multipart_suggestion(\n+                                \"you need to pin and box this expression\",\n+                                vec![\n+                                    (expr.span.shrink_to_lo(), \"Box::pin(\".to_string()),\n+                                    (expr.span.shrink_to_hi(), \")\".to_string()),\n+                                ],\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                    true\n+                } else if self.can_coerce(pin_found, expected) {\n+                    match found.kind() {\n+                        ty::Adt(def, _) if def.is_box() => {\n+                            err.help(\"use `Box::pin`\");\n+                            true\n+                        }\n+                        _ => false,\n+                    }\n+                } else {\n+                    false\n                 }\n             }\n-            true\n-        } else if self.can_coerce(pin_found, expected) {\n-            match found.kind() {\n-                ty::Adt(def, _) if def.is_box() => {\n-                    err.help(\"use `Box::pin`\");\n-                    true\n+            ty::Adt(def, _) if def.is_box() && self.can_coerce(box_found, expected) => {\n+                // Check if the parent expression is a call to Pin::new.  If it\n+                // is and we were expecting a Box, ergo Pin<Box<expected>>, we\n+                // can suggest Box::pin.\n+                let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+                let fn_name = match self.tcx.hir().find(parent) {\n+                    Some(Node::Expr(Expr { kind: ExprKind::Call(fn_name, _), .. })) => fn_name,\n+                    _ => return false,\n+                };\n+                match fn_name.kind {\n+                    ExprKind::Path(QPath::TypeRelative(\n+                        hir::Ty {\n+                            kind: TyKind::Path(QPath::Resolved(_, Path { res: recv_ty, .. })),\n+                            ..\n+                        },\n+                        method,\n+                    )) if Some(recv_ty.def_id()) == pin_did && method.ident.name == sym::new => {\n+                        err.span_suggestion(\n+                            fn_name.span,\n+                            \"use `Box::pin` to pin and box this expression\",\n+                            \"Box::pin\".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        true\n+                    }\n+                    _ => false,\n                 }\n-                _ => false,\n             }\n-        } else {\n-            false\n+            _ => false,\n         }\n     }\n "}, {"sha": "7e9c5492d1a6bc083e119eedace934dc90768b4e", "filename": "src/test/ui/suggestions/expected-boxed-future-isnt-pinned.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.rs?ref=e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c", "patch": "@@ -15,9 +15,6 @@ fn bar<F: Future<Output=i32> + Send + 'static>(x: F) -> BoxFuture<'static, i32>\n     Box::new(x) //~ ERROR mismatched types\n }\n \n-// This case is still subpar:\n-// `Pin::new(x)`: store this in the heap by calling `Box::new`: `Box::new(x)`\n-// Should suggest changing the code from `Pin::new` to `Box::pin`.\n fn baz<F: Future<Output=i32> + Send + 'static>(x: F) -> BoxFuture<'static, i32> {\n     Pin::new(x) //~ ERROR mismatched types\n     //~^ ERROR E0277"}, {"sha": "aa3175dae2e66cca43d57f73472b30826c67ccce", "filename": "src/test/ui/suggestions/expected-boxed-future-isnt-pinned.stderr", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr?ref=e2c28ad1e7c5f5fc74c6472c27c8f6adfebb5b8c", "patch": "@@ -27,23 +27,20 @@ LL |     Box::new(x)\n    = help: use `Box::pin`\n \n error[E0308]: mismatched types\n-  --> $DIR/expected-boxed-future-isnt-pinned.rs:22:14\n+  --> $DIR/expected-boxed-future-isnt-pinned.rs:19:14\n    |\n LL | fn baz<F: Future<Output=i32> + Send + 'static>(x: F) -> BoxFuture<'static, i32> {\n    |        - this type parameter\n LL |     Pin::new(x)\n-   |              ^ expected struct `Box`, found type parameter `F`\n+   |     -------- ^ expected struct `Box`, found type parameter `F`\n+   |     |\n+   |     help: use `Box::pin` to pin and box this expression: `Box::pin`\n    |\n    = note:      expected struct `Box<dyn Future<Output = i32> + Send>`\n            found type parameter `F`\n-   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n-help: store this in the heap by calling `Box::new`\n-   |\n-LL |     Pin::new(Box::new(x))\n-   |              +++++++++ +\n \n error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n-  --> $DIR/expected-boxed-future-isnt-pinned.rs:22:5\n+  --> $DIR/expected-boxed-future-isnt-pinned.rs:19:5\n    |\n LL |     Pin::new(x)\n    |     ^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = i32> + Send`\n@@ -56,7 +53,7 @@ LL |     pub const fn new(pointer: P) -> Pin<P> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n-  --> $DIR/expected-boxed-future-isnt-pinned.rs:27:5\n+  --> $DIR/expected-boxed-future-isnt-pinned.rs:24:5\n    |\n LL |     Pin::new(Box::new(x))\n    |     ^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = i32> + Send`\n@@ -69,7 +66,7 @@ LL |     pub const fn new(pointer: P) -> Pin<P> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/expected-boxed-future-isnt-pinned.rs:31:5\n+  --> $DIR/expected-boxed-future-isnt-pinned.rs:28:5\n    |\n LL |   fn zap() -> BoxFuture<'static, i32> {\n    |               ----------------------- expected `Pin<Box<(dyn Future<Output = i32> + Send + 'static)>>` because of return type"}]}