{"sha": "c9432327c4bacaccbf7602f916f450ab27dbe49e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NDMyMzI3YzRiYWNhY2NiZjc2MDJmOTE2ZjQ1MGFiMjdkYmU0OWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-18T22:54:42Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T21:01:21Z"}, "message": "librustc: Change `@mut Block` to `@Block`.", "tree": {"sha": "b339ee2c2fa2133b39f8ea6dcbd7deed2b14a338", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b339ee2c2fa2133b39f8ea6dcbd7deed2b14a338"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9432327c4bacaccbf7602f916f450ab27dbe49e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9432327c4bacaccbf7602f916f450ab27dbe49e", "html_url": "https://github.com/rust-lang/rust/commit/c9432327c4bacaccbf7602f916f450ab27dbe49e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9432327c4bacaccbf7602f916f450ab27dbe49e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f74b8f0d3a90fd3b64afa38b9470d9a45cd04ee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f74b8f0d3a90fd3b64afa38b9470d9a45cd04ee9", "html_url": "https://github.com/rust-lang/rust/commit/f74b8f0d3a90fd3b64afa38b9470d9a45cd04ee9"}], "stats": {"total": 1194, "additions": 605, "deletions": 589}, "files": [{"sha": "6852f5ca862bea32e2ec02d2f85518926098d2ef", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -310,7 +310,7 @@ pub enum opt_result {\n     lower_bound(Result),\n     range_result(Result, Result),\n }\n-fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n+fn trans_opt(bcx: @Block, o: &Opt) -> opt_result {\n     let _icx = push_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n     let bcx = bcx;\n@@ -345,7 +345,7 @@ fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n     }\n }\n \n-fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n+fn variant_opt(bcx: @Block, pat_id: ast::NodeId)\n     -> Opt {\n     let ccx = bcx.ccx();\n     match ccx.tcx.def_map.get_copy(&pat_id) {\n@@ -396,7 +396,7 @@ type BindingsMap = HashMap<Ident, BindingInfo>;\n \n #[deriving(Clone)]\n struct ArmData<'a> {\n-    bodycx: @mut Block,\n+    bodycx: @Block,\n     arm: &'a ast::Arm,\n     bindings_map: @BindingsMap\n }\n@@ -435,7 +435,7 @@ fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-fn expand_nested_bindings<'r>(bcx: @mut Block,\n+fn expand_nested_bindings<'r>(bcx: @Block,\n                                   m: &[Match<'r>],\n                                   col: uint,\n                                   val: ValueRef)\n@@ -469,7 +469,7 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n     })\n }\n \n-fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::Pat) {\n+fn assert_is_binding_or_wild(bcx: @Block, p: @ast::Pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n@@ -480,7 +480,7 @@ fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::Pat) {\n \n type enter_pat<'a> = 'a |@ast::Pat| -> Option<~[@ast::Pat]>;\n \n-fn enter_match<'r>(bcx: @mut Block,\n+fn enter_match<'r>(bcx: @Block,\n                        dm: DefMap,\n                        m: &[Match<'r>],\n                        col: uint,\n@@ -529,7 +529,7 @@ fn enter_match<'r>(bcx: @mut Block,\n     return result;\n }\n \n-fn enter_default<'r>(bcx: @mut Block,\n+fn enter_default<'r>(bcx: @Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -599,7 +599,7 @@ fn enter_default<'r>(bcx: @mut Block,\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n-fn enter_opt<'r>(bcx: @mut Block,\n+fn enter_opt<'r>(bcx: @Block,\n                      m: &[Match<'r>],\n                      opt: &Opt,\n                      col: uint,\n@@ -735,7 +735,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_rec_or_struct<'r>(bcx: @mut Block,\n+fn enter_rec_or_struct<'r>(bcx: @Block,\n                                dm: DefMap,\n                                m: &[Match<'r>],\n                                col: uint,\n@@ -770,7 +770,7 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_tup<'r>(bcx: @mut Block,\n+fn enter_tup<'r>(bcx: @Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -796,7 +796,7 @@ fn enter_tup<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_tuple_struct<'r>(bcx: @mut Block,\n+fn enter_tuple_struct<'r>(bcx: @Block,\n                               dm: DefMap,\n                               m: &[Match<'r>],\n                               col: uint,\n@@ -822,7 +822,7 @@ fn enter_tuple_struct<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_box<'r>(bcx: @mut Block,\n+fn enter_box<'r>(bcx: @Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -849,7 +849,7 @@ fn enter_box<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_uniq<'r>(bcx: @mut Block,\n+fn enter_uniq<'r>(bcx: @Block,\n                       dm: DefMap,\n                       m: &[Match<'r>],\n                       col: uint,\n@@ -876,7 +876,7 @@ fn enter_uniq<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_region<'r>(bcx: @mut Block,\n+fn enter_region<'r>(bcx: @Block,\n                         dm: DefMap,\n                         m: &[Match<'r>],\n                         col: uint,\n@@ -906,7 +906,7 @@ fn enter_region<'r>(bcx: @mut Block,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n+fn get_options(bcx: @Block, m: &[Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n@@ -990,10 +990,10 @@ fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n \n struct ExtractedBlock {\n     vals: ~[ValueRef],\n-    bcx: @mut Block\n+    bcx: @Block\n }\n \n-fn extract_variant_args(bcx: @mut Block,\n+fn extract_variant_args(bcx: @Block,\n                             repr: &adt::Repr,\n                             disr_val: ty::Disr,\n                             val: ValueRef)\n@@ -1006,7 +1006,7 @@ fn extract_variant_args(bcx: @mut Block,\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n-fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n+fn match_datum(bcx: @Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n     //! Helper for converting from the ValueRef that we pass around in\n     //! the match code, which is always by ref, into a Datum. Eventually\n     //! we should just pass around a Datum and be done with it.\n@@ -1016,7 +1016,7 @@ fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n }\n \n \n-fn extract_vec_elems(bcx: @mut Block,\n+fn extract_vec_elems(bcx: @Block,\n                          pat_span: Span,\n                          pat_id: ast::NodeId,\n                          elem_count: uint,\n@@ -1069,7 +1069,7 @@ fn extract_vec_elems(bcx: @mut Block,\n /// Function returns None if there is no struct pattern.\n /// Function doesn't collect fields from struct-like enum variants.\n /// Function can return empty list if there is only wildcard struct pattern.\n-fn collect_record_or_struct_fields(bcx: @mut Block,\n+fn collect_record_or_struct_fields(bcx: @Block,\n                                        m: &[Match],\n                                        col: uint)\n                                     -> Option<~[ast::Ident]> {\n@@ -1105,7 +1105,7 @@ fn collect_record_or_struct_fields(bcx: @mut Block,\n     }\n }\n \n-fn pats_require_rooting(bcx: @mut Block,\n+fn pats_require_rooting(bcx: @Block,\n                             m: &[Match],\n                             col: uint)\n                          -> bool {\n@@ -1116,11 +1116,11 @@ fn pats_require_rooting(bcx: @mut Block,\n     })\n }\n \n-fn root_pats_as_necessary(mut bcx: @mut Block,\n+fn root_pats_as_necessary(mut bcx: @Block,\n                               m: &[Match],\n                               col: uint,\n                               val: ValueRef)\n-                           -> @mut Block {\n+                           -> @Block {\n     for br in m.iter() {\n         let pat_id = br.pats[col].id;\n         if pat_id != 0 {\n@@ -1163,7 +1163,7 @@ fn any_tup_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::PatTup(_))\n }\n \n-fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n+fn any_tuple_struct_pat(bcx: @Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {\n@@ -1184,7 +1184,7 @@ trait CustomFailureHandler {\n }\n \n struct DynamicFailureHandler {\n-    bcx: @mut Block,\n+    bcx: @Block,\n     sp: Span,\n     msg: @str,\n     finished: @mut Option<BasicBlockRef>,\n@@ -1271,7 +1271,7 @@ pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n // Compiles a comparison between two things.\n //\n // NB: This must produce an i1, not a Rust bool (i8).\n-fn compare_values(cx: @mut Block,\n+fn compare_values(cx: @Block,\n                       lhs: ValueRef,\n                       rhs: ValueRef,\n                       rhs_t: ty::t)\n@@ -1314,10 +1314,10 @@ fn compare_values(cx: @mut Block,\n     }\n }\n \n-fn store_non_ref_bindings(bcx: @mut Block,\n+fn store_non_ref_bindings(bcx: @Block,\n                           bindings_map: &BindingsMap,\n                           mut opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n-                          -> @mut Block\n+                          -> @Block\n {\n     /*!\n      *\n@@ -1348,9 +1348,9 @@ fn store_non_ref_bindings(bcx: @mut Block,\n     return bcx;\n }\n \n-fn insert_lllocals(bcx: @mut Block,\n+fn insert_lllocals(bcx: @Block,\n                    bindings_map: &BindingsMap,\n-                   add_cleans: bool) -> @mut Block {\n+                   add_cleans: bool) -> @Block {\n     /*!\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n      * the `fcx.lllocals` map.  If add_cleans is true, then adds cleanups for\n@@ -1391,13 +1391,13 @@ fn insert_lllocals(bcx: @mut Block,\n     return bcx;\n }\n \n-fn compile_guard(bcx: @mut Block,\n+fn compile_guard(bcx: @Block,\n                      guard_expr: &ast::Expr,\n                      data: &ArmData,\n                      m: &[Match],\n                      vals: &[ValueRef],\n                      chk: FailureHandler)\n-                  -> @mut Block {\n+                  -> @Block {\n     debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n@@ -1432,7 +1432,7 @@ fn compile_guard(bcx: @mut Block,\n         bcx\n     });\n \n-    fn drop_bindings(bcx: @mut Block, data: &ArmData) -> @mut Block {\n+    fn drop_bindings(bcx: @Block, data: &ArmData) -> @Block {\n         let mut bcx = bcx;\n         for (_, &binding_info) in data.bindings_map.iter() {\n             match binding_info.trmode {\n@@ -1447,7 +1447,7 @@ fn compile_guard(bcx: @mut Block,\n     }\n }\n \n-fn compile_submatch(bcx: @mut Block,\n+fn compile_submatch(bcx: @Block,\n                     m: &[Match],\n                     vals: &[ValueRef],\n                     chk: FailureHandler) {\n@@ -1499,7 +1499,7 @@ fn compile_submatch(bcx: @mut Block,\n     }\n }\n \n-fn compile_submatch_continue(mut bcx: @mut Block,\n+fn compile_submatch_continue(mut bcx: @Block,\n                              m: &[Match],\n                              vals: &[ValueRef],\n                              chk: FailureHandler,\n@@ -1816,18 +1816,18 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n     }\n }\n \n-pub fn trans_match(bcx: @mut Block,\n+pub fn trans_match(bcx: @Block,\n                    match_expr: &ast::Expr,\n                    discr_expr: &ast::Expr,\n                    arms: &[ast::Arm],\n-                   dest: Dest) -> @mut Block {\n+                   dest: Dest) -> @Block {\n     let _icx = push_ctxt(\"match::trans_match\");\n     with_scope(bcx, match_expr.info(), \"match\", |bcx| {\n         trans_match_inner(bcx, discr_expr, arms, dest)\n     })\n }\n \n-fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n+fn create_bindings_map(bcx: @Block, pat: @ast::Pat) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n     // Note that we use the names because each binding will have many ids\n@@ -1867,18 +1867,18 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n     return bindings_map;\n }\n \n-fn trans_match_inner(scope_cx: @mut Block,\n+fn trans_match_inner(scope_cx: @Block,\n                          discr_expr: &ast::Expr,\n                          arms: &[ast::Arm],\n-                         dest: Dest) -> @mut Block {\n+                         dest: Dest) -> @Block {\n     let _icx = push_ctxt(\"match::trans_match_inner\");\n     let mut bcx = scope_cx;\n     let tcx = bcx.tcx();\n \n     let discr_datum = unpack_datum!(bcx, {\n         expr::trans_to_datum(bcx, discr_expr)\n     });\n-    if bcx.unreachable {\n+    if bcx.unreachable.get() {\n         return bcx;\n     }\n \n@@ -1952,10 +1952,10 @@ enum IrrefutablePatternBindingMode {\n     BindArgument\n }\n \n-pub fn store_local(bcx: @mut Block,\n+pub fn store_local(bcx: @Block,\n                    pat: @ast::Pat,\n                    opt_init_expr: Option<@ast::Expr>)\n-                   -> @mut Block {\n+                   -> @Block {\n     /*!\n      * Generates code for a local variable declaration like\n      * `let <pat>;` or `let <pat> = <opt_init_expr>`.\n@@ -2006,7 +2006,7 @@ pub fn store_local(bcx: @mut Block,\n         }\n     };\n \n-    fn create_dummy_locals(mut bcx: @mut Block, pat: @ast::Pat) -> @mut Block {\n+    fn create_dummy_locals(mut bcx: @Block, pat: @ast::Pat) -> @Block {\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n@@ -2019,10 +2019,10 @@ pub fn store_local(bcx: @mut Block,\n     }\n }\n \n-pub fn store_arg(mut bcx: @mut Block,\n+pub fn store_arg(mut bcx: @Block,\n                  pat: @ast::Pat,\n                  llval: ValueRef)\n-                 -> @mut Block {\n+                 -> @Block {\n     /*!\n      * Generates code for argument patterns like `fn foo(<pat>: T)`.\n      * Creates entries in the `llargs` map for each of the bindings\n@@ -2066,12 +2066,12 @@ pub fn store_arg(mut bcx: @mut Block,\n     return bcx;\n }\n \n-fn mk_binding_alloca(mut bcx: @mut Block,\n+fn mk_binding_alloca(mut bcx: @Block,\n                      p_id: ast::NodeId,\n                      path: &ast::Path,\n                      binding_mode: IrrefutablePatternBindingMode,\n-                     populate: |@mut Block, ty::t, ValueRef| -> @mut Block)\n-                     -> @mut Block {\n+                     populate: |@Block, ty::t, ValueRef| -> @Block)\n+                     -> @Block {\n     let var_ty = node_id_type(bcx, p_id);\n     let ident = ast_util::path_to_ident(path);\n     let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));\n@@ -2085,11 +2085,11 @@ fn mk_binding_alloca(mut bcx: @mut Block,\n     return bcx;\n }\n \n-fn bind_irrefutable_pat(bcx: @mut Block,\n+fn bind_irrefutable_pat(bcx: @Block,\n                         pat: @ast::Pat,\n                         val: ValueRef,\n                         binding_mode: IrrefutablePatternBindingMode)\n-                        -> @mut Block {\n+                        -> @Block {\n     /*!\n      * A simple version of the pattern matching code that only handles\n      * irrefutable patterns. This is used in let/argument patterns,"}, {"sha": "9b18b7b1a31abffd2d63039617f748f5bee4bb21", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -111,7 +111,7 @@ pub struct Struct {\n  * these, for places in trans where the `ty::t` isn't directly\n  * available.\n  */\n-pub fn represent_node(bcx: @mut Block, node: ast::NodeId) -> @Repr {\n+pub fn represent_node(bcx: @Block, node: ast::NodeId) -> @Repr {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n@@ -458,7 +458,7 @@ fn struct_llfields(cx: &mut CrateContext, st: &Struct, sizing: bool) -> ~[Type]\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_switch(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n+pub fn trans_switch(bcx: @Block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::branch_kind, Option<ValueRef>) {\n     match *r {\n         CEnum(..) | General(..) => {\n@@ -476,7 +476,7 @@ pub fn trans_switch(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n \n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n+pub fn trans_get_discr(bcx: @Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n     -> ValueRef {\n     let signed;\n     let val;\n@@ -505,7 +505,7 @@ pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef, cast_to:\n     }\n }\n \n-fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n+fn nullable_bitdiscr(bcx: @Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n                      scrutinee: ValueRef) -> ValueRef {\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n@@ -514,7 +514,7 @@ fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: Disr, ptrfield:\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: @mut Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n+fn load_discr(bcx: @Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     -> ValueRef {\n     let llty = ll_inttype(bcx.ccx(), ity);\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n@@ -542,7 +542,7 @@ fn load_discr(bcx: @mut Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_case(bcx: @mut Block, r: &Repr, discr: Disr) -> _match::opt_result {\n+pub fn trans_case(bcx: @Block, r: &Repr, discr: Disr) -> _match::opt_result {\n     match *r {\n         CEnum(ity, _, _) => {\n             _match::single_result(rslt(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n@@ -567,7 +567,7 @@ pub fn trans_case(bcx: @mut Block, r: &Repr, discr: Disr) -> _match::opt_result\n  * representation.  The fields, if any, should then be initialized via\n  * `trans_field_ptr`.\n  */\n-pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n+pub fn trans_start_init(bcx: @Block, r: &Repr, val: ValueRef, discr: Disr) {\n     match *r {\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);\n@@ -623,7 +623,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr,\n+pub fn trans_field_ptr(bcx: @Block, r: &Repr, val: ValueRef, discr: Disr,\n                        ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n@@ -656,7 +656,7 @@ pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr,\n     }\n }\n \n-fn struct_field_ptr(bcx: @mut Block, st: &Struct, val: ValueRef, ix: uint,\n+fn struct_field_ptr(bcx: @Block, st: &Struct, val: ValueRef, ix: uint,\n               needs_cast: bool) -> ValueRef {\n     let ccx = bcx.ccx();\n \n@@ -672,7 +672,7 @@ fn struct_field_ptr(bcx: @mut Block, st: &Struct, val: ValueRef, ix: uint,\n }\n \n /// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr(bcx: @mut Block, r: &Repr, val: ValueRef) -> ValueRef {\n+pub fn trans_drop_flag_ptr(bcx: @Block, r: &Repr, val: ValueRef) -> ValueRef {\n     match *r {\n         Univariant(ref st, true) => GEPi(bcx, val, [0, st.fields.len() - 1]),\n         _ => bcx.ccx().sess.bug(\"tried to get drop flag of non-droppable type\")"}, {"sha": "5dd7c0c3b44f13ce5544eb2b04d1c29c082d8e33", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -27,7 +27,7 @@ use middle::trans::type_::Type;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n+pub fn trans_inline_asm(bcx: @Block, ia: &ast::inline_asm) -> @Block {\n \n     let mut bcx = bcx;\n     let mut constraints = ~[];"}, {"sha": "60d19f7baf2bf64484746045a142ef5d79240656", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 112, "deletions": 106, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -297,7 +297,7 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n // known.\n //\n // The runtime equivalent is box_body() in \"rust_internal.h\".\n-pub fn opaque_box_body(bcx: @mut Block,\n+pub fn opaque_box_body(bcx: @Block,\n                        body_t: ty::t,\n                        boxptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"opaque_box_body\");\n@@ -310,14 +310,14 @@ pub fn opaque_box_body(bcx: @mut Block,\n \n // malloc_raw_dyn: allocates a box to contain a given type, but with a\n // potentially dynamic size.\n-pub fn malloc_raw_dyn(bcx: @mut Block,\n+pub fn malloc_raw_dyn(bcx: @Block,\n                       t: ty::t,\n                       heap: heap,\n                       size: ValueRef) -> Result {\n     let _icx = push_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    fn require_alloc_fn(bcx: @mut Block, t: ty::t, it: LangItem) -> ast::DefId {\n+    fn require_alloc_fn(bcx: @Block, t: ty::t, it: LangItem) -> ast::DefId {\n         let li = &bcx.tcx().lang_items;\n         match li.require(it) {\n             Ok(id) => id,\n@@ -377,21 +377,21 @@ pub fn malloc_raw_dyn(bcx: @mut Block,\n // malloc_raw: expects an unboxed type and returns a pointer to\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n-pub fn malloc_raw(bcx: @mut Block, t: ty::t, heap: heap) -> Result {\n+pub fn malloc_raw(bcx: @Block, t: ty::t, heap: heap) -> Result {\n     let ty = type_of(bcx.ccx(), t);\n     let size = llsize_of(bcx.ccx(), ty);\n     malloc_raw_dyn(bcx, t, heap, size)\n }\n \n pub struct MallocResult {\n-    bcx: @mut Block,\n+    bcx: @Block,\n     smart_ptr: ValueRef,\n     body: ValueRef\n }\n \n // malloc_general_dyn: usefully wraps malloc_raw_dyn; allocates a smart\n // pointer, and pulls out the body\n-pub fn malloc_general_dyn(bcx: @mut Block, t: ty::t, heap: heap, size: ValueRef)\n+pub fn malloc_general_dyn(bcx: @Block, t: ty::t, heap: heap, size: ValueRef)\n     -> MallocResult {\n     assert!(heap != heap_exchange);\n     let _icx = push_ctxt(\"malloc_general\");\n@@ -405,21 +405,21 @@ pub fn malloc_general_dyn(bcx: @mut Block, t: ty::t, heap: heap, size: ValueRef)\n     }\n }\n \n-pub fn malloc_general(bcx: @mut Block, t: ty::t, heap: heap) -> MallocResult {\n+pub fn malloc_general(bcx: @Block, t: ty::t, heap: heap) -> MallocResult {\n     let ty = type_of(bcx.ccx(), t);\n     assert!(heap != heap_exchange);\n     malloc_general_dyn(bcx, t, heap, llsize_of(bcx.ccx(), ty))\n }\n \n-pub fn heap_for_unique(bcx: @mut Block, t: ty::t) -> heap {\n+pub fn heap_for_unique(bcx: @Block, t: ty::t) -> heap {\n     if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         heap_managed_unique\n     } else {\n         heap_exchange\n     }\n }\n \n-pub fn maybe_set_managed_unique_rc(bcx: @mut Block, bx: ValueRef, heap: heap) {\n+pub fn maybe_set_managed_unique_rc(bcx: @Block, bx: ValueRef, heap: heap) {\n     assert!(heap != heap_exchange);\n     if heap == heap_managed_unique {\n         // In cases where we are looking at a unique-typed allocation in the\n@@ -579,7 +579,7 @@ pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n // NB: This produces an i1, not a Rust bool (i8).\n-pub fn compare_scalar_types(cx: @mut Block,\n+pub fn compare_scalar_types(cx: @Block,\n                             lhs: ValueRef,\n                             rhs: ValueRef,\n                             t: ty::t,\n@@ -611,14 +611,14 @@ pub fn compare_scalar_types(cx: @mut Block,\n \n \n // A helper function to do the actual comparison of scalar values.\n-pub fn compare_scalar_values(cx: @mut Block,\n+pub fn compare_scalar_values(cx: @Block,\n                              lhs: ValueRef,\n                              rhs: ValueRef,\n                              nt: scalar_type,\n                              op: ast::BinOp)\n                           -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n-    fn die(cx: @mut Block) -> ! {\n+    fn die(cx: @Block) -> ! {\n         cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n                            comparison operator\");\n     }\n@@ -672,25 +672,25 @@ pub fn compare_scalar_values(cx: @mut Block,\n     }\n }\n \n-pub type val_and_ty_fn<'a> = 'a |@mut Block, ValueRef, ty::t|\n-                                       -> @mut Block;\n+pub type val_and_ty_fn<'a> = 'a |@Block, ValueRef, ty::t|\n+                                       -> @Block;\n \n-pub fn load_inbounds(cx: @mut Block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n+pub fn load_inbounds(cx: @Block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n     return Load(cx, GEPi(cx, p, idxs));\n }\n \n-pub fn store_inbounds(cx: @mut Block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n+pub fn store_inbounds(cx: @Block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n     Store(cx, v, GEPi(cx, p, idxs));\n }\n \n // Iterates through the elements of a structural type.\n-pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n-                          f: val_and_ty_fn) -> @mut Block {\n+pub fn iter_structural_ty(cx: @Block, av: ValueRef, t: ty::t,\n+                          f: val_and_ty_fn) -> @Block {\n     let _icx = push_ctxt(\"iter_structural_ty\");\n \n-    fn iter_variant(cx: @mut Block, repr: &adt::Repr, av: ValueRef,\n+    fn iter_variant(cx: @Block, repr: &adt::Repr, av: ValueRef,\n                     variant: @ty::VariantInfo,\n-                    tps: &[ty::t], f: val_and_ty_fn) -> @mut Block {\n+                    tps: &[ty::t], f: val_and_ty_fn) -> @Block {\n         let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n         let mut cx = cx;\n@@ -776,7 +776,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n     return cx;\n }\n \n-pub fn cast_shift_expr_rhs(cx: @mut Block, op: ast::BinOp,\n+pub fn cast_shift_expr_rhs(cx: @Block, op: ast::BinOp,\n                            lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n                    |a,b| Trunc(cx, a, b),\n@@ -818,8 +818,8 @@ pub fn cast_shift_rhs(op: ast::BinOp,\n     }\n }\n \n-pub fn fail_if_zero(cx: @mut Block, span: Span, divrem: ast::BinOp,\n-                    rhs: ValueRef, rhs_t: ty::t) -> @mut Block {\n+pub fn fail_if_zero(cx: @Block, span: Span, divrem: ast::BinOp,\n+                    rhs: ValueRef, rhs_t: ty::t) -> @Block {\n     let text = if divrem == ast::BiDiv {\n         @\"attempted to divide by zero\"\n     } else {\n@@ -875,14 +875,14 @@ pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t) ->\n     }\n }\n \n-pub fn invoke(bcx: @mut Block,\n+pub fn invoke(bcx: @Block,\n               llfn: ValueRef,\n               llargs: ~[ValueRef],\n               attributes: &[(uint, lib::llvm::Attribute)],\n               call_info: Option<NodeInfo>)\n-           -> (ValueRef, @mut Block) {\n+           -> (ValueRef, @Block) {\n     let _icx = push_ctxt(\"invoke_\");\n-    if bcx.unreachable {\n+    if bcx.unreachable.get() {\n         return (C_null(Type::i8()), bcx);\n     }\n \n@@ -934,7 +934,7 @@ pub fn invoke(bcx: @mut Block,\n     }\n }\n \n-pub fn need_invoke(bcx: @mut Block) -> bool {\n+pub fn need_invoke(bcx: @Block) -> bool {\n     if bcx.ccx().sess.no_landing_pads() {\n         return false;\n     }\n@@ -950,7 +950,7 @@ pub fn need_invoke(bcx: @mut Block) -> bool {\n \n     // Walk the scopes to look for cleanups\n     let mut cur = bcx;\n-    let mut cur_scope = cur.scope;\n+    let mut cur_scope = cur.scope.get();\n     loop {\n         cur_scope = match cur_scope {\n             Some(inf) => {\n@@ -970,13 +970,13 @@ pub fn need_invoke(bcx: @mut Block) -> bool {\n                     Some(next) => next,\n                     None => return false\n                 };\n-                cur.scope\n+                cur.scope.get()\n             }\n         }\n     }\n }\n \n-pub fn have_cached_lpad(bcx: @mut Block) -> bool {\n+pub fn have_cached_lpad(bcx: @Block) -> bool {\n     let mut res = false;\n     in_lpad_scope_cx(bcx, |inf| {\n         match inf.landing_pad {\n@@ -987,9 +987,9 @@ pub fn have_cached_lpad(bcx: @mut Block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: @mut Block, f: |si: &mut ScopeInfo|) {\n+pub fn in_lpad_scope_cx(bcx: @Block, f: |si: &mut ScopeInfo|) {\n     let mut bcx = bcx;\n-    let mut cur_scope = bcx.scope;\n+    let mut cur_scope = bcx.scope.get();\n     loop {\n         cur_scope = match cur_scope {\n             Some(inf) => {\n@@ -1001,13 +1001,13 @@ pub fn in_lpad_scope_cx(bcx: @mut Block, f: |si: &mut ScopeInfo|) {\n             }\n             None => {\n                 bcx = block_parent(bcx);\n-                bcx.scope\n+                bcx.scope.get()\n             }\n         }\n     }\n }\n \n-pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n+pub fn get_landing_pad(bcx: @Block) -> BasicBlockRef {\n     let _icx = push_ctxt(\"get_landing_pad\");\n \n     let mut cached = None;\n@@ -1053,9 +1053,9 @@ pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n     return pad_bcx.llbb;\n }\n \n-pub fn find_bcx_for_scope(bcx: @mut Block, scope_id: ast::NodeId) -> @mut Block {\n+pub fn find_bcx_for_scope(bcx: @Block, scope_id: ast::NodeId) -> @Block {\n     let mut bcx_sid = bcx;\n-    let mut cur_scope = bcx_sid.scope;\n+    let mut cur_scope = bcx_sid.scope.get();\n     loop {\n         cur_scope = match cur_scope {\n             Some(inf) => {\n@@ -1075,14 +1075,14 @@ pub fn find_bcx_for_scope(bcx: @mut Block, scope_id: ast::NodeId) -> @mut Block\n                     None => bcx.tcx().sess.bug(format!(\"no enclosing scope with id {}\", scope_id)),\n                     Some(bcx_par) => bcx_par\n                 };\n-                bcx_sid.scope\n+                bcx_sid.scope.get()\n             }\n         }\n     }\n }\n \n \n-pub fn do_spill(bcx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn do_spill(bcx: @Block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n         return C_null(Type::i8p());\n     }\n@@ -1093,31 +1093,31 @@ pub fn do_spill(bcx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n \n // Since this function does *not* root, it is the caller's responsibility to\n // ensure that the referent is pointed to by a root.\n-pub fn do_spill_noroot(cx: @mut Block, v: ValueRef) -> ValueRef {\n+pub fn do_spill_noroot(cx: @Block, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v), \"\");\n     Store(cx, v, llptr);\n     return llptr;\n }\n \n-pub fn spill_if_immediate(cx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn spill_if_immediate(cx: @Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"spill_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n-pub fn load_if_immediate(cx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_if_immediate(cx: @Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return Load(cx, v); }\n     return v;\n }\n \n-pub fn ignore_lhs(_bcx: @mut Block, local: &ast::Local) -> bool {\n+pub fn ignore_lhs(_bcx: @Block, local: &ast::Local) -> bool {\n     match local.pat.node {\n         ast::PatWild => true, _ => false\n     }\n }\n \n-pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n+pub fn init_local(bcx: @Block, local: &ast::Local) -> @Block {\n \n     debug!(\"init_local(bcx={}, local.id={:?})\",\n            bcx.to_str(), local.id);\n@@ -1138,7 +1138,7 @@ pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n     _match::store_local(bcx, local.pat, local.init)\n }\n \n-pub fn trans_stmt(cx: @mut Block, s: &ast::Stmt) -> @mut Block {\n+pub fn trans_stmt(cx: @Block, s: &ast::Stmt) -> @Block {\n     let _icx = push_ctxt(\"trans_stmt\");\n     debug!(\"trans_stmt({})\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n@@ -1172,24 +1172,24 @@ pub fn trans_stmt(cx: @mut Block, s: &ast::Stmt) -> @mut Block {\n // You probably don't want to use this one. See the\n // next three functions instead.\n pub fn new_block(cx: @mut FunctionContext,\n-                 parent: Option<@mut Block>,\n+                 parent: Option<@Block>,\n                  scope: Option<@mut ScopeInfo>,\n                  is_lpad: bool,\n                  name: &str,\n                  opt_node_info: Option<NodeInfo>)\n-              -> @mut Block {\n+              -> @Block {\n     unsafe {\n         let llbb = name.with_c_str(|buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx.ccx.llcx, cx.llfn, buf)\n         });\n-        let bcx = @mut Block::new(llbb,\n+        let bcx = @Block::new(llbb,\n                                   parent,\n                                   is_lpad,\n                                   opt_node_info,\n                                   cx);\n-        bcx.scope = scope;\n+        bcx.scope.set(scope);\n         for cx in parent.iter() {\n-            if cx.unreachable {\n+            if cx.unreachable.get() {\n                 Unreachable(bcx);\n                 break;\n             }\n@@ -1213,23 +1213,23 @@ pub fn simple_block_scope(parent: Option<@mut ScopeInfo>,\n \n // Use this when you're at the top block of a function or the like.\n pub fn top_scope_block(fcx: @mut FunctionContext, opt_node_info: Option<NodeInfo>)\n-                    -> @mut Block {\n+                    -> @Block {\n     return new_block(fcx, None, Some(simple_block_scope(None, opt_node_info)), false,\n                   \"function top level\", opt_node_info);\n }\n \n-pub fn scope_block(bcx: @mut Block,\n+pub fn scope_block(bcx: @Block,\n                    opt_node_info: Option<NodeInfo>,\n-                   n: &str) -> @mut Block {\n+                   n: &str) -> @Block {\n     return new_block(bcx.fcx, Some(bcx), Some(simple_block_scope(None, opt_node_info)), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n-pub fn loop_scope_block(bcx: @mut Block,\n-                        loop_break: @mut Block,\n+pub fn loop_scope_block(bcx: @Block,\n+                        loop_break: @Block,\n                         loop_label: Option<Name>,\n                         n: &str,\n-                        opt_node_info: Option<NodeInfo>) -> @mut Block {\n+                        opt_node_info: Option<NodeInfo>) -> @Block {\n     return new_block(bcx.fcx, Some(bcx), Some(@mut ScopeInfo {\n         parent: None,\n         loop_break: Some(loop_break),\n@@ -1242,17 +1242,17 @@ pub fn loop_scope_block(bcx: @mut Block,\n }\n \n // Use this when creating a block for the inside of a landing pad.\n-pub fn lpad_block(bcx: @mut Block, n: &str) -> @mut Block {\n+pub fn lpad_block(bcx: @Block, n: &str) -> @Block {\n     new_block(bcx.fcx, Some(bcx), None, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n-pub fn sub_block(bcx: @mut Block, n: &str) -> @mut Block {\n+pub fn sub_block(bcx: @Block, n: &str) -> @Block {\n     new_block(bcx.fcx, Some(bcx), None, bcx.is_lpad, n, None)\n }\n \n-pub fn raw_block(fcx: @mut FunctionContext, is_lpad: bool, llbb: BasicBlockRef) -> @mut Block {\n-    @mut Block::new(llbb, None, is_lpad, None, fcx)\n+pub fn raw_block(fcx: @mut FunctionContext, is_lpad: bool, llbb: BasicBlockRef) -> @Block {\n+    @Block::new(llbb, None, is_lpad, None, fcx)\n }\n \n \n@@ -1263,19 +1263,21 @@ pub fn raw_block(fcx: @mut FunctionContext, is_lpad: bool, llbb: BasicBlockRef)\n // need to make sure those variables go out of scope when the block ends.  We\n // do that by running a 'cleanup' function for each variable.\n // trans_block_cleanups runs all the cleanup functions for the block.\n-pub fn trans_block_cleanups(bcx: @mut Block, cleanups: ~[cleanup]) -> @mut Block {\n+pub fn trans_block_cleanups(bcx: @Block, cleanups: ~[cleanup]) -> @Block {\n     trans_block_cleanups_(bcx, cleanups, false)\n }\n \n-pub fn trans_block_cleanups_(bcx: @mut Block,\n+pub fn trans_block_cleanups_(bcx: @Block,\n                              cleanups: &[cleanup],\n                              /* cleanup_cx: block, */\n-                             is_lpad: bool) -> @mut Block {\n+                             is_lpad: bool) -> @Block {\n     let _icx = push_ctxt(\"trans_block_cleanups\");\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n     let no_lpads = bcx.ccx().sess.no_landing_pads();\n-    if bcx.unreachable && !no_lpads { return bcx; }\n+    if bcx.unreachable.get() && !no_lpads {\n+        return bcx\n+    }\n     let mut bcx = bcx;\n     for cu in cleanups.rev_iter() {\n         match *cu {\n@@ -1294,7 +1296,7 @@ pub fn trans_block_cleanups_(bcx: @mut Block,\n // In the last argument, Some(block) mean jump to this block, and none means\n // this is a landing pad and leaving should be accomplished with a resume\n // instruction.\n-pub fn cleanup_and_leave(bcx: @mut Block,\n+pub fn cleanup_and_leave(bcx: @Block,\n                          upto: Option<BasicBlockRef>,\n                          leave: Option<BasicBlockRef>) {\n     let _icx = push_ctxt(\"cleanup_and_leave\");\n@@ -1304,7 +1306,7 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     loop {\n         debug!(\"cleanup_and_leave: leaving {}\", cur.to_str());\n \n-        let mut cur_scope = cur.scope;\n+        let mut cur_scope = cur.scope.get();\n         loop {\n             cur_scope = match cur_scope {\n                 Some (inf) if !inf.empty_cleanups() => {\n@@ -1365,14 +1367,14 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     }\n }\n \n-pub fn cleanup_block(bcx: @mut Block, upto: Option<BasicBlockRef>) -> @mut Block{\n+pub fn cleanup_block(bcx: @Block, upto: Option<BasicBlockRef>) -> @Block{\n     let _icx = push_ctxt(\"cleanup_block\");\n     let mut cur = bcx;\n     let mut bcx = bcx;\n     loop {\n         debug!(\"cleanup_block: {}\", cur.to_str());\n \n-        let mut cur_scope = cur.scope;\n+        let mut cur_scope = cur.scope.get();\n         loop {\n             cur_scope = match cur_scope {\n                 Some (inf) => {\n@@ -1395,60 +1397,62 @@ pub fn cleanup_block(bcx: @mut Block, upto: Option<BasicBlockRef>) -> @mut Block\n     bcx\n }\n \n-pub fn cleanup_and_Br(bcx: @mut Block, upto: @mut Block, target: BasicBlockRef) {\n+pub fn cleanup_and_Br(bcx: @Block, upto: @Block, target: BasicBlockRef) {\n     let _icx = push_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, Some(upto.llbb), Some(target));\n }\n \n-pub fn leave_block(bcx: @mut Block, out_of: @mut Block) -> @mut Block {\n+pub fn leave_block(bcx: @Block, out_of: @Block) -> @Block {\n     let _icx = push_ctxt(\"leave_block\");\n     let next_cx = sub_block(block_parent(out_of), \"next\");\n-    if bcx.unreachable { Unreachable(next_cx); }\n+    if bcx.unreachable.get() {\n+        Unreachable(next_cx);\n+    }\n     cleanup_and_Br(bcx, out_of, next_cx.llbb);\n     next_cx\n }\n \n-pub fn with_scope(bcx: @mut Block,\n+pub fn with_scope(bcx: @Block,\n                   opt_node_info: Option<NodeInfo>,\n                   name: &str,\n-                  f: |@mut Block| -> @mut Block)\n-                  -> @mut Block {\n+                  f: |@Block| -> @Block)\n+                  -> @Block {\n     let _icx = push_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx={}, opt_node_info={:?}, name={})\",\n            bcx.to_str(), opt_node_info, name);\n     let _indenter = indenter();\n \n-    let scope = simple_block_scope(bcx.scope, opt_node_info);\n-    bcx.scope = Some(scope);\n+    let scope = simple_block_scope(bcx.scope.get(), opt_node_info);\n+    bcx.scope.set(Some(scope));\n     let ret = f(bcx);\n     let ret = trans_block_cleanups_(ret, (scope.cleanups).clone(), false);\n-    bcx.scope = scope.parent;\n+    bcx.scope.set(scope.parent);\n     ret\n }\n \n-pub fn with_scope_result(bcx: @mut Block,\n+pub fn with_scope_result(bcx: @Block,\n                          opt_node_info: Option<NodeInfo>,\n                          _name: &str,\n-                         f: |@mut Block| -> Result)\n+                         f: |@Block| -> Result)\n                          -> Result {\n     let _icx = push_ctxt(\"with_scope_result\");\n \n-    let scope = simple_block_scope(bcx.scope, opt_node_info);\n-    bcx.scope = Some(scope);\n+    let scope = simple_block_scope(bcx.scope.get(), opt_node_info);\n+    bcx.scope.set(Some(scope));\n     let Result { bcx: out_bcx, val } = f(bcx);\n     let out_bcx = trans_block_cleanups_(out_bcx,\n                                         (scope.cleanups).clone(),\n                                         false);\n-    bcx.scope = scope.parent;\n+    bcx.scope.set(scope.parent);\n \n     rslt(out_bcx, val)\n }\n \n-pub fn with_scope_datumblock(bcx: @mut Block,\n+pub fn with_scope_datumblock(bcx: @Block,\n                              opt_node_info: Option<NodeInfo>,\n                              name: &str,\n-                             f: |@mut Block| -> datum::DatumBlock)\n+                             f: |@Block| -> datum::DatumBlock)\n                              -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n@@ -1473,20 +1477,22 @@ pub fn block_locals(b: &ast::Block, it: |@ast::Local|) {\n     }\n }\n \n-pub fn with_cond(bcx: @mut Block,\n+pub fn with_cond(bcx: @Block,\n                  val: ValueRef,\n-                 f: |@mut Block| -> @mut Block)\n-                 -> @mut Block {\n+                 f: |@Block| -> @Block)\n+                 -> @Block {\n     let _icx = push_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, \"next\");\n     let cond_cx = base::sub_block(bcx, \"cond\");\n     CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n     let after_cx = f(cond_cx);\n-    if !after_cx.terminated { Br(after_cx, next_cx.llbb); }\n+    if !after_cx.terminated.get() {\n+        Br(after_cx, next_cx.llbb);\n+    }\n     next_cx\n }\n \n-pub fn call_memcpy(cx: @mut Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n+pub fn call_memcpy(cx: @Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess.targ_cfg.arch {\n@@ -1502,7 +1508,7 @@ pub fn call_memcpy(cx: @mut Block, dst: ValueRef, src: ValueRef, n_bytes: ValueR\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], []);\n }\n \n-pub fn memcpy_ty(bcx: @mut Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n+pub fn memcpy_ty(bcx: @Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n@@ -1515,8 +1521,8 @@ pub fn memcpy_ty(bcx: @mut Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     }\n }\n \n-pub fn zero_mem(cx: @mut Block, llptr: ValueRef, t: ty::t) {\n-    if cx.unreachable { return; }\n+pub fn zero_mem(cx: @Block, llptr: ValueRef, t: ty::t) {\n+    if cx.unreachable.get() { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n     let ccx = cx.ccx();\n@@ -1547,7 +1553,7 @@ pub fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], []);\n }\n \n-pub fn alloc_ty(bcx: @mut Block, t: ty::t, name: &str) -> ValueRef {\n+pub fn alloc_ty(bcx: @Block, t: ty::t, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n@@ -1556,13 +1562,13 @@ pub fn alloc_ty(bcx: @mut Block, t: ty::t, name: &str) -> ValueRef {\n     return val;\n }\n \n-pub fn alloca(cx: @mut Block, ty: Type, name: &str) -> ValueRef {\n+pub fn alloca(cx: @Block, ty: Type, name: &str) -> ValueRef {\n     alloca_maybe_zeroed(cx, ty, name, false)\n }\n \n-pub fn alloca_maybe_zeroed(cx: @mut Block, ty: Type, name: &str, zero: bool) -> ValueRef {\n+pub fn alloca_maybe_zeroed(cx: @Block, ty: Type, name: &str, zero: bool) -> ValueRef {\n     let _icx = push_ctxt(\"alloca\");\n-    if cx.unreachable {\n+    if cx.unreachable.get() {\n         unsafe {\n             return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n         }\n@@ -1577,9 +1583,9 @@ pub fn alloca_maybe_zeroed(cx: @mut Block, ty: Type, name: &str, zero: bool) ->\n     p\n }\n \n-pub fn arrayalloca(cx: @mut Block, ty: Type, v: ValueRef) -> ValueRef {\n+pub fn arrayalloca(cx: @Block, ty: Type, v: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"arrayalloca\");\n-    if cx.unreachable {\n+    if cx.unreachable.get() {\n         unsafe {\n             return llvm::LLVMGetUndef(ty.to_ref());\n         }\n@@ -1752,10 +1758,10 @@ pub fn create_llargs_for_fn_args(cx: @mut FunctionContext,\n }\n \n pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n-                            bcx: @mut Block,\n+                            bcx: @Block,\n                             args: &[ast::arg],\n                             raw_llargs: &[ValueRef],\n-                            arg_tys: &[ty::t]) -> @mut Block {\n+                            arg_tys: &[ty::t]) -> @Block {\n     debug!(\"copy_args_to_allocas: raw_llargs={} arg_tys={}\",\n            raw_llargs.llrepr(fcx.ccx),\n            arg_tys.repr(fcx.ccx.tcx));\n@@ -1815,12 +1821,12 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @mut Block) {\n+pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @Block) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n     let ret_cx = match fcx.llreturn {\n         Some(llreturn) => {\n-            if !last_bcx.terminated {\n+            if !last_bcx.terminated.get() {\n                 Br(last_bcx, llreturn);\n             }\n             raw_block(fcx, false, llreturn)\n@@ -1833,7 +1839,7 @@ pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @mut Block) {\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: &FunctionContext, ret_cx: @mut Block) {\n+pub fn build_return_block(fcx: &FunctionContext, ret_cx: @Block) {\n     // Return the value if this function immediate; otherwise, return void.\n     if fcx.llretptr.is_none() || fcx.caller_expects_out_pointer {\n         return RetVoid(ret_cx);\n@@ -1973,7 +1979,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                   |_fcx| { });\n }\n \n-fn insert_synthetic_type_entries(bcx: @mut Block,\n+fn insert_synthetic_type_entries(bcx: @Block,\n                                  fn_args: &[ast::arg],\n                                  arg_tys: &[ty::t])\n {\n@@ -2413,7 +2419,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n     }\n }\n \n-pub fn fill_fn_pair(bcx: @mut Block, pair: ValueRef, llfn: ValueRef,\n+pub fn fill_fn_pair(bcx: @Block, pair: ValueRef, llfn: ValueRef,\n                     llenvptr: ValueRef) {\n     let ccx = bcx.ccx();\n     let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n@@ -2705,7 +2711,7 @@ pub fn register_method(ccx: @mut CrateContext,\n     llfn\n }\n \n-pub fn vp2i(cx: @mut Block, v: ValueRef) -> ValueRef {\n+pub fn vp2i(cx: @Block, v: ValueRef) -> ValueRef {\n     let ccx = cx.ccx();\n     return PtrToInt(cx, v, ccx.int_type);\n }\n@@ -2873,7 +2879,7 @@ pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'stati\n          \"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n }\n \n-pub fn trap(bcx: @mut Block) {\n+pub fn trap(bcx: @Block) {\n     match bcx.ccx().intrinsics.find_equiv(& &\"llvm.trap\") {\n       Some(&x) => { Call(bcx, x, [], []); },\n       _ => bcx.sess().bug(\"unbound llvm.trap in trap\")"}, {"sha": "ba39c869ab0001eed1d3bb4a3c198f7cbf491085", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 112, "deletions": 110, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -23,12 +23,12 @@ use middle::trans::type_::Type;\n use std::cast;\n use std::libc::{c_uint, c_ulonglong, c_char};\n \n-pub fn terminate(cx: &mut Block, _: &str) {\n-    cx.terminated = true;\n+pub fn terminate(cx: &Block, _: &str) {\n+    cx.terminated.set(true);\n }\n \n pub fn check_not_terminated(cx: &Block) {\n-    if cx.terminated {\n+    if cx.terminated.get() {\n         fail!(\"already terminated!\");\n     }\n }\n@@ -47,45 +47,45 @@ pub fn B(cx: &Block) -> Builder {\n // for (fail/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-pub fn RetVoid(cx: &mut Block) {\n-    if cx.unreachable { return; }\n+pub fn RetVoid(cx: &Block) {\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"RetVoid\");\n     B(cx).ret_void();\n }\n \n-pub fn Ret(cx: @mut Block, V: ValueRef) {\n-    if cx.unreachable { return; }\n+pub fn Ret(cx: @Block, V: ValueRef) {\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Ret\");\n     B(cx).ret(V);\n }\n \n-pub fn AggregateRet(cx: @mut Block, RetVals: &[ValueRef]) {\n-    if cx.unreachable { return; }\n+pub fn AggregateRet(cx: @Block, RetVals: &[ValueRef]) {\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n     B(cx).aggregate_ret(RetVals);\n }\n \n-pub fn Br(cx: @mut Block, Dest: BasicBlockRef) {\n-    if cx.unreachable { return; }\n+pub fn Br(cx: @Block, Dest: BasicBlockRef) {\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Br\");\n     B(cx).br(Dest);\n }\n \n-pub fn CondBr(cx: @mut Block, If: ValueRef, Then: BasicBlockRef,\n+pub fn CondBr(cx: @Block, If: ValueRef, Then: BasicBlockRef,\n               Else: BasicBlockRef) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"CondBr\");\n     B(cx).cond_br(If, Then, Else);\n }\n \n-pub fn Switch(cx: &mut Block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n+pub fn Switch(cx: &Block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     check_not_terminated(cx);\n     terminate(cx, \"Switch\");\n     B(cx).switch(V, Else, NumCases)\n@@ -98,21 +98,21 @@ pub fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n     }\n }\n \n-pub fn IndirectBr(cx: &mut Block, Addr: ValueRef, NumDests: uint) {\n-    if cx.unreachable { return; }\n+pub fn IndirectBr(cx: &Block, Addr: ValueRef, NumDests: uint) {\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"IndirectBr\");\n     B(cx).indirect_br(Addr, NumDests);\n }\n \n-pub fn Invoke(cx: @mut Block,\n+pub fn Invoke(cx: @Block,\n               Fn: ValueRef,\n               Args: &[ValueRef],\n               Then: BasicBlockRef,\n               Catch: BasicBlockRef,\n               attributes: &[(uint, lib::llvm::Attribute)])\n            -> ValueRef {\n-    if cx.unreachable {\n+    if cx.unreachable.get() {\n         return C_null(Type::i8());\n     }\n     check_not_terminated(cx);\n@@ -123,10 +123,12 @@ pub fn Invoke(cx: @mut Block,\n     B(cx).invoke(Fn, Args, Then, Catch, attributes)\n }\n \n-pub fn Unreachable(cx: &mut Block) {\n-    if cx.unreachable { return; }\n-    cx.unreachable = true;\n-    if !cx.terminated {\n+pub fn Unreachable(cx: &Block) {\n+    if cx.unreachable.get() {\n+        return\n+    }\n+    cx.unreachable.set(true);\n+    if !cx.terminated.get() {\n         B(cx).unreachable();\n     }\n }\n@@ -139,178 +141,178 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n \n /* Arithmetic */\n pub fn Add(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).add(LHS, RHS)\n }\n \n pub fn NSWAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nswadd(LHS, RHS)\n }\n \n pub fn NUWAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nuwadd(LHS, RHS)\n }\n \n pub fn FAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).fadd(LHS, RHS)\n }\n \n pub fn Sub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).sub(LHS, RHS)\n }\n \n pub fn NSWSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nswsub(LHS, RHS)\n }\n \n pub fn NUWSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nuwsub(LHS, RHS)\n }\n \n pub fn FSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).fsub(LHS, RHS)\n }\n \n pub fn Mul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).mul(LHS, RHS)\n }\n \n pub fn NSWMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nswmul(LHS, RHS)\n }\n \n pub fn NUWMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nuwmul(LHS, RHS)\n }\n \n pub fn FMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).fmul(LHS, RHS)\n }\n \n pub fn UDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).udiv(LHS, RHS)\n }\n \n pub fn SDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).sdiv(LHS, RHS)\n }\n \n pub fn ExactSDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).exactsdiv(LHS, RHS)\n }\n \n pub fn FDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).fdiv(LHS, RHS)\n }\n \n pub fn URem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).urem(LHS, RHS)\n }\n \n pub fn SRem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).srem(LHS, RHS)\n }\n \n pub fn FRem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).frem(LHS, RHS)\n }\n \n pub fn Shl(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).shl(LHS, RHS)\n }\n \n pub fn LShr(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).lshr(LHS, RHS)\n }\n \n pub fn AShr(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).ashr(LHS, RHS)\n }\n \n pub fn And(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).and(LHS, RHS)\n }\n \n pub fn Or(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).or(LHS, RHS)\n }\n \n pub fn Xor(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).xor(LHS, RHS)\n }\n \n pub fn BinOp(cx: &Block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n           -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).binop(Op, LHS, RHS)\n }\n \n pub fn Neg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     B(cx).neg(V)\n }\n \n pub fn NSWNeg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     B(cx).nswneg(V)\n }\n \n pub fn NUWNeg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     B(cx).nuwneg(V)\n }\n pub fn FNeg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     B(cx).fneg(V)\n }\n \n pub fn Not(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     B(cx).not(V)\n }\n \n /* Memory */\n pub fn Malloc(cx: &Block, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).malloc(Ty)\n     }\n }\n \n pub fn ArrayMalloc(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).array_malloc(Ty, Val)\n     }\n }\n \n pub fn Alloca(cx: &Block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n         b.position_before(cx.fcx.alloca_insert_pt.unwrap());\n         b.alloca(Ty, name)\n@@ -319,22 +321,22 @@ pub fn Alloca(cx: &Block, Ty: Type, name: &str) -> ValueRef {\n \n pub fn ArrayAlloca(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n         b.position_before(cx.fcx.alloca_insert_pt.unwrap());\n         b.array_alloca(Ty, Val)\n     }\n }\n \n pub fn Free(cx: &Block, PointerVal: ValueRef) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     B(cx).free(PointerVal)\n }\n \n pub fn Load(cx: &Block, PointerVal: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n-        if cx.unreachable {\n+        if cx.unreachable.get() {\n             let ty = val_ty(PointerVal);\n             let eltty = if ty.kind() == lib::llvm::Array {\n                 ty.element_type()\n@@ -350,7 +352,7 @@ pub fn Load(cx: &Block, PointerVal: ValueRef) -> ValueRef {\n pub fn AtomicLoad(cx: &Block, PointerVal: ValueRef, order: AtomicOrdering) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n-        if cx.unreachable {\n+        if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(ccx.int_type.to_ref());\n         }\n         B(cx).atomic_load(PointerVal, order)\n@@ -360,7 +362,7 @@ pub fn AtomicLoad(cx: &Block, PointerVal: ValueRef, order: AtomicOrdering) -> Va\n \n pub fn LoadRangeAssert(cx: &Block, PointerVal: ValueRef, lo: c_ulonglong,\n                        hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n-    if cx.unreachable {\n+    if cx.unreachable.get() {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(PointerVal);\n         let eltty = if ty.kind() == lib::llvm::Array {\n@@ -377,18 +379,18 @@ pub fn LoadRangeAssert(cx: &Block, PointerVal: ValueRef, lo: c_ulonglong,\n }\n \n pub fn Store(cx: &Block, Val: ValueRef, Ptr: ValueRef) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     B(cx).store(Val, Ptr)\n }\n \n pub fn AtomicStore(cx: &Block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrdering) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     B(cx).atomic_store(Val, Ptr, order)\n }\n \n pub fn GEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).gep(Pointer, Indices)\n     }\n }\n@@ -398,170 +400,170 @@ pub fn GEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n #[inline]\n pub fn GEPi(cx: &Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).gepi(base, ixs)\n     }\n }\n \n pub fn InBoundsGEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).inbounds_gep(Pointer, Indices)\n     }\n }\n \n pub fn StructGEP(cx: &Block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).struct_gep(Pointer, Idx)\n     }\n }\n \n pub fn GlobalString(cx: &Block, _Str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).global_string(_Str)\n     }\n }\n \n pub fn GlobalStringPtr(cx: &Block, _Str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).global_string_ptr(_Str)\n     }\n }\n \n /* Casts */\n pub fn Trunc(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).trunc(Val, DestTy)\n     }\n }\n \n pub fn ZExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).zext(Val, DestTy)\n     }\n }\n \n pub fn SExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sext(Val, DestTy)\n     }\n }\n \n pub fn FPToUI(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptoui(Val, DestTy)\n     }\n }\n \n pub fn FPToSI(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptosi(Val, DestTy)\n     }\n }\n \n pub fn UIToFP(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).uitofp(Val, DestTy)\n     }\n }\n \n pub fn SIToFP(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sitofp(Val, DestTy)\n     }\n }\n \n pub fn FPTrunc(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptrunc(Val, DestTy)\n     }\n }\n \n pub fn FPExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fpext(Val, DestTy)\n     }\n }\n \n pub fn PtrToInt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).ptrtoint(Val, DestTy)\n     }\n }\n \n pub fn IntToPtr(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).inttoptr(Val, DestTy)\n     }\n }\n \n pub fn BitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).bitcast(Val, DestTy)\n     }\n }\n \n pub fn ZExtOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).zext_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn SExtOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sext_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn TruncOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).trunc_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn Cast(cx: &Block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).cast(Op, Val, DestTy)\n     }\n }\n \n pub fn PointerCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).pointercast(Val, DestTy)\n     }\n }\n \n pub fn IntCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).intcast(Val, DestTy)\n     }\n }\n \n pub fn FPCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fpcast(Val, DestTy)\n     }\n }\n@@ -571,30 +573,30 @@ pub fn FPCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n pub fn ICmp(cx: &Block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).icmp(Op, LHS, RHS)\n     }\n }\n \n pub fn FCmp(cx: &Block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).fcmp(Op, LHS, RHS)\n     }\n }\n \n /* Miscellaneous instructions */\n pub fn EmptyPhi(cx: &Block, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).empty_phi(Ty)\n     }\n }\n \n pub fn Phi(cx: &Block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).phi(Ty, vals, bbs)\n     }\n }\n@@ -639,116 +641,116 @@ pub fn InlineAsmCall(cx: &Block, asm: *c_char, cons: *c_char,\n \n pub fn Call(cx: &Block, Fn: ValueRef, Args: &[ValueRef],\n             attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n-    if cx.unreachable { return _UndefReturn(cx, Fn); }\n+    if cx.unreachable.get() { return _UndefReturn(cx, Fn); }\n     B(cx).call(Fn, Args, attributes)\n }\n \n pub fn CallWithConv(cx: &Block, Fn: ValueRef, Args: &[ValueRef], Conv: CallConv,\n                     attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n-    if cx.unreachable { return _UndefReturn(cx, Fn); }\n+    if cx.unreachable.get() { return _UndefReturn(cx, Fn); }\n     B(cx).call_with_conv(Fn, Args, Conv, attributes)\n }\n \n pub fn AtomicFence(cx: &Block, order: AtomicOrdering) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     B(cx).atomic_fence(order)\n }\n \n pub fn Select(cx: &Block, If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(Then); }\n+    if cx.unreachable.get() { return _Undef(Then); }\n     B(cx).select(If, Then, Else)\n }\n \n pub fn VAArg(cx: &Block, list: ValueRef, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).va_arg(list, Ty)\n     }\n }\n \n pub fn ExtractElement(cx: &Block, VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).extract_element(VecVal, Index)\n     }\n }\n \n pub fn InsertElement(cx: &Block, VecVal: ValueRef, EltVal: ValueRef,\n                      Index: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).insert_element(VecVal, EltVal, Index)\n     }\n }\n \n pub fn ShuffleVector(cx: &Block, V1: ValueRef, V2: ValueRef,\n                      Mask: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).shuffle_vector(V1, V2, Mask)\n     }\n }\n \n pub fn VectorSplat(cx: &Block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).vector_splat(NumElts, EltVal)\n     }\n }\n \n pub fn ExtractValue(cx: &Block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).extract_value(AggVal, Index)\n     }\n }\n \n pub fn InsertValue(cx: &Block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).insert_value(AggVal, EltVal, Index)\n     }\n }\n \n pub fn IsNull(cx: &Block, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).is_null(Val)\n     }\n }\n \n pub fn IsNotNull(cx: &Block, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).is_not_null(Val)\n     }\n }\n \n pub fn PtrDiff(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n-        if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n         B(cx).ptrdiff(LHS, RHS)\n     }\n }\n \n pub fn Trap(cx: &Block) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     B(cx).trap();\n }\n \n pub fn LandingPad(cx: &Block, Ty: Type, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n     check_not_terminated(cx);\n-    assert!(!cx.unreachable);\n+    assert!(!cx.unreachable.get());\n     B(cx).landing_pad(Ty, PersFn, NumClauses)\n }\n \n pub fn SetCleanup(cx: &Block, LandingPad: ValueRef) {\n     B(cx).set_cleanup(LandingPad)\n }\n \n-pub fn Resume(cx: @mut Block, Exn: ValueRef) -> ValueRef {\n+pub fn Resume(cx: @Block, Exn: ValueRef) -> ValueRef {\n     check_not_terminated(cx);\n     terminate(cx, \"Resume\");\n     B(cx).resume(Exn)"}, {"sha": "859ebbb276dbd0b45c268f4f5bf0d957f83198c0", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -71,11 +71,11 @@ pub enum CalleeData {\n }\n \n pub struct Callee {\n-    bcx: @mut Block,\n+    bcx: @Block,\n     data: CalleeData\n }\n \n-pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n+pub fn trans(bcx: @Block, expr: &ast::Expr) -> Callee {\n     let _icx = push_ctxt(\"trans_callee\");\n     debug!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n \n@@ -90,7 +90,7 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n     // any other expressions are closures:\n     return datum_callee(bcx, expr);\n \n-    fn datum_callee(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n+    fn datum_callee(bcx: @Block, expr: &ast::Expr) -> Callee {\n         let DatumBlock {bcx, datum} = expr::trans_to_datum(bcx, expr);\n         match ty::get(datum.ty).sty {\n             ty::ty_bare_fn(..) => {\n@@ -109,11 +109,11 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n         }\n     }\n \n-    fn fn_callee(bcx: @mut Block, fd: FnData) -> Callee {\n+    fn fn_callee(bcx: @Block, fd: FnData) -> Callee {\n         return Callee {bcx: bcx, data: Fn(fd)};\n     }\n \n-    fn trans_def(bcx: @mut Block, def: ast::Def, ref_expr: &ast::Expr) -> Callee {\n+    fn trans_def(bcx: @Block, def: ast::Def, ref_expr: &ast::Expr) -> Callee {\n         match def {\n             ast::DefFn(did, _) |\n             ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n@@ -158,14 +158,14 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n     }\n }\n \n-pub fn trans_fn_ref_to_callee(bcx: @mut Block,\n+pub fn trans_fn_ref_to_callee(bcx: @Block,\n                               def_id: ast::DefId,\n                               ref_id: ast::NodeId) -> Callee {\n     Callee {bcx: bcx,\n             data: Fn(trans_fn_ref(bcx, def_id, ref_id))}\n }\n \n-pub fn trans_fn_ref(bcx: @mut Block,\n+pub fn trans_fn_ref(bcx: @Block,\n                     def_id: ast::DefId,\n                     ref_id: ast::NodeId) -> FnData {\n     /*!\n@@ -185,7 +185,7 @@ pub fn trans_fn_ref(bcx: @mut Block,\n }\n \n pub fn trans_fn_ref_with_vtables_to_callee(\n-        bcx: @mut Block,\n+        bcx: @Block,\n         def_id: ast::DefId,\n         ref_id: ast::NodeId,\n         type_params: &[ty::t],\n@@ -196,7 +196,7 @@ pub fn trans_fn_ref_with_vtables_to_callee(\n                                                type_params, vtables))}\n }\n \n-fn resolve_default_method_vtables(bcx: @mut Block,\n+fn resolve_default_method_vtables(bcx: @Block,\n                                   impl_id: ast::DefId,\n                                   method: &ty::Method,\n                                   substs: &ty::substs,\n@@ -239,7 +239,7 @@ fn resolve_default_method_vtables(bcx: @mut Block,\n \n \n pub fn trans_fn_ref_with_vtables(\n-        bcx: @mut Block,       //\n+        bcx: @Block,       //\n         def_id: ast::DefId,   // def id of fn\n         ref_id: ast::NodeId,  // node id of use of fn; may be zero if N/A\n         type_params: &[ty::t], // values for fn's ty params\n@@ -444,13 +444,13 @@ pub fn trans_fn_ref_with_vtables(\n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call(in_cx: @mut Block,\n+pub fn trans_call(in_cx: @Block,\n                   call_ex: &ast::Expr,\n                   f: &ast::Expr,\n                   args: CallArgs,\n                   id: ast::NodeId,\n                   dest: expr::Dest)\n-                  -> @mut Block {\n+                  -> @Block {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      call_ex.info(),\n@@ -462,13 +462,13 @@ pub fn trans_call(in_cx: @mut Block,\n                      DontAutorefArg).bcx\n }\n \n-pub fn trans_method_call(in_cx: @mut Block,\n+pub fn trans_method_call(in_cx: @Block,\n                          call_ex: &ast::Expr,\n                          callee_id: ast::NodeId,\n                          rcvr: &ast::Expr,\n                          args: CallArgs,\n                          dest: expr::Dest)\n-                         -> @mut Block {\n+                         -> @Block {\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={}, rcvr={})\",\n            call_ex.repr(in_cx.tcx()),\n@@ -500,7 +500,7 @@ pub fn trans_method_call(in_cx: @mut Block,\n         DontAutorefArg).bcx\n }\n \n-pub fn trans_lang_call(bcx: @mut Block,\n+pub fn trans_lang_call(bcx: @Block,\n                        did: ast::DefId,\n                        args: &[ValueRef],\n                        dest: Option<expr::Dest>)\n@@ -527,12 +527,12 @@ pub fn trans_lang_call(bcx: @mut Block,\n                              DontAutorefArg)\n }\n \n-pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n+pub fn trans_lang_call_with_type_params(bcx: @Block,\n                                         did: ast::DefId,\n                                         args: &[ValueRef],\n                                         type_params: &[ty::t],\n                                         dest: expr::Dest)\n-    -> @mut Block {\n+    -> @Block {\n     let fty;\n     if did.crate == ast::LOCAL_CRATE {\n         fty = ty::node_id_to_type(bcx.tcx(), did.node);\n@@ -567,11 +567,11 @@ pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n         ArgVals(args), Some(dest), DontAutorefArg).bcx;\n }\n \n-pub fn trans_call_inner(in_cx: @mut Block,\n+pub fn trans_call_inner(in_cx: @Block,\n                         call_info: Option<NodeInfo>,\n                         callee_ty: ty::t,\n                         ret_ty: ty::t,\n-                        get_callee: |@mut Block| -> Callee,\n+                        get_callee: |@Block| -> Callee,\n                         args: CallArgs,\n                         dest: Option<expr::Dest>,\n                         autoref_arg: AutorefArg)\n@@ -755,11 +755,11 @@ pub enum CallArgs<'a> {\n     ArgVals(&'a [ValueRef])\n }\n \n-pub fn trans_args(cx: @mut Block,\n+pub fn trans_args(cx: @Block,\n                   args: CallArgs,\n                   fn_ty: ty::t,\n                   autoref_arg: AutorefArg,\n-                  llargs: &mut ~[ValueRef]) -> @mut Block\n+                  llargs: &mut ~[ValueRef]) -> @Block\n {\n     let _icx = push_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n@@ -814,7 +814,7 @@ pub enum AutorefArg {\n \n // temp_cleanups: cleanups that should run only if failure occurs before the\n // call takes place:\n-pub fn trans_arg_expr(bcx: @mut Block,\n+pub fn trans_arg_expr(bcx: @Block,\n                       formal_arg_ty: ty::t,\n                       self_mode: ty::SelfMode,\n                       arg_expr: &ast::Expr,"}, {"sha": "bceeec472cb031012ceecd2a41286a756859971c", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -155,15 +155,15 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n-fn heap_for_unique_closure(bcx: @mut Block, t: ty::t) -> heap {\n+fn heap_for_unique_closure(bcx: @Block, t: ty::t) -> heap {\n     if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         heap_managed_unique\n     } else {\n         heap_exchange_closure\n     }\n }\n \n-pub fn allocate_cbox(bcx: @mut Block, sigil: ast::Sigil, cdata_ty: ty::t)\n+pub fn allocate_cbox(bcx: @Block, sigil: ast::Sigil, cdata_ty: ty::t)\n                   -> Result {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx();\n@@ -188,14 +188,14 @@ pub fn allocate_cbox(bcx: @mut Block, sigil: ast::Sigil, cdata_ty: ty::t)\n pub struct ClosureResult {\n     llbox: ValueRef, // llvalue of ptr to closure\n     cdata_ty: ty::t, // type of the closure data\n-    bcx: @mut Block       // final bcx\n+    bcx: @Block       // final bcx\n }\n \n // Given a block context and a list of tydescs and values to bind\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n-pub fn store_environment(bcx: @mut Block,\n+pub fn store_environment(bcx: @Block,\n                          bound_values: ~[EnvValue],\n                          sigil: ast::Sigil)\n                          -> ClosureResult {\n@@ -257,7 +257,7 @@ pub fn store_environment(bcx: @mut Block,\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n-pub fn build_closure(bcx0: @mut Block,\n+pub fn build_closure(bcx0: @Block,\n                      cap_vars: &[moves::CaptureVar],\n                      sigil: ast::Sigil) -> ClosureResult {\n     let _icx = push_ctxt(\"closure::build_closure\");\n@@ -345,13 +345,13 @@ pub fn load_environment(fcx: @mut FunctionContext,\n     }\n }\n \n-pub fn trans_expr_fn(bcx: @mut Block,\n+pub fn trans_expr_fn(bcx: @Block,\n                      sigil: ast::Sigil,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n                      outer_id: ast::NodeId,\n                      user_id: ast::NodeId,\n-                     dest: expr::Dest) -> @mut Block {\n+                     dest: expr::Dest) -> @Block {\n     /*!\n      *\n      * Translates the body of a closure expression.\n@@ -422,12 +422,12 @@ pub fn trans_expr_fn(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn make_closure_glue(cx: @mut Block,\n+pub fn make_closure_glue(cx: @Block,\n                          v: ValueRef,\n                          t: ty::t,\n-                         glue_fn: |@mut Block, v: ValueRef, t: ty::t|\n-                                   -> @mut Block)\n-                         -> @mut Block {\n+                         glue_fn: |@Block, v: ValueRef, t: ty::t|\n+                                   -> @Block)\n+                         -> @Block {\n     let _icx = push_ctxt(\"closure::make_closure_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n@@ -447,10 +447,10 @@ pub fn make_closure_glue(cx: @mut Block,\n }\n \n pub fn make_opaque_cbox_drop_glue(\n-    bcx: @mut Block,\n+    bcx: @Block,\n     sigil: ast::Sigil,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n-    -> @mut Block {\n+    -> @Block {\n     let _icx = push_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n     match sigil {\n         ast::BorrowedSigil => bcx,\n@@ -465,11 +465,11 @@ pub fn make_opaque_cbox_drop_glue(\n     }\n }\n \n-pub fn make_opaque_cbox_free_glue(\n-    bcx: @mut Block,\n-    sigil: ast::Sigil,\n-    cbox: ValueRef)     // ptr to ptr to the opaque closure\n-    -> @mut Block {\n+/// `cbox` is a pointer to a pointer to an opaque closure.\n+pub fn make_opaque_cbox_free_glue(bcx: @Block,\n+                                  sigil: ast::Sigil,\n+                                  cbox: ValueRef)\n+                                  -> @Block {\n     let _icx = push_ctxt(\"closure::make_opaque_cbox_free_glue\");\n     match sigil {\n         ast::BorrowedSigil => {"}, {"sha": "81a0e15625716db9679ce848d89b4b0ea8f94131", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -35,6 +35,7 @@ use middle::trans::type_::Type;\n use std::c_str::ToCStr;\n use std::cast::transmute;\n use std::cast;\n+use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_longlong, c_ulonglong, c_char};\n use std::vec;\n@@ -213,7 +214,7 @@ pub struct FunctionContext {\n     // always be Some.\n     llretptr: Option<ValueRef>,\n \n-    entry_bcx: Option<@mut Block>,\n+    entry_bcx: Option<@Block>,\n \n     // These elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n@@ -331,7 +332,7 @@ pub enum cleantype {\n \n /// A cleanup function: a built-in destructor.\n pub trait CleanupFunction {\n-    fn clean(&self, block: @mut Block) -> @mut Block;\n+    fn clean(&self, block: @Block) -> @Block;\n }\n \n /// A cleanup function that calls the \"drop glue\" (destructor function) on\n@@ -342,7 +343,7 @@ pub struct TypeDroppingCleanupFunction {\n }\n \n impl CleanupFunction for TypeDroppingCleanupFunction {\n-    fn clean(&self, block: @mut Block) -> @mut Block {\n+    fn clean(&self, block: @Block) -> @Block {\n         glue::drop_ty(block, self.val, self.t)\n     }\n }\n@@ -355,7 +356,7 @@ pub struct ImmediateTypeDroppingCleanupFunction {\n }\n \n impl CleanupFunction for ImmediateTypeDroppingCleanupFunction {\n-    fn clean(&self, block: @mut Block) -> @mut Block {\n+    fn clean(&self, block: @Block) -> @Block {\n         glue::drop_ty_immediate(block, self.val, self.t)\n     }\n }\n@@ -371,7 +372,7 @@ pub struct WriteGuardReleasingCleanupFunction {\n }\n \n impl CleanupFunction for WriteGuardReleasingCleanupFunction {\n-    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+    fn clean(&self, bcx: @Block) -> @Block {\n         write_guard::return_to_mut(bcx,\n                                    self.root_key,\n                                    self.frozen_val_ref,\n@@ -387,7 +388,7 @@ pub struct GCHeapFreeingCleanupFunction {\n }\n \n impl CleanupFunction for GCHeapFreeingCleanupFunction {\n-    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+    fn clean(&self, bcx: @Block) -> @Block {\n         glue::trans_free(bcx, self.ptr)\n     }\n }\n@@ -398,7 +399,7 @@ pub struct ExchangeHeapFreeingCleanupFunction {\n }\n \n impl CleanupFunction for ExchangeHeapFreeingCleanupFunction {\n-    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+    fn clean(&self, bcx: @Block) -> @Block {\n         glue::trans_exchange_free(bcx, self.ptr)\n     }\n }\n@@ -445,7 +446,7 @@ pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n     }\n }\n \n-pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n+pub fn add_clean(bcx: @Block, val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) {\n         return\n     }\n@@ -463,7 +464,7 @@ pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n     })\n }\n \n-pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n+pub fn add_clean_temp_immediate(cx: @Block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n     debug!(\"add_clean_temp_immediate({}, {}, {})\",\n            cx.to_str(), cx.val_to_str(val),\n@@ -480,18 +481,18 @@ pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n     })\n }\n \n-pub fn add_clean_temp_mem(bcx: @mut Block, val: ValueRef, t: ty::t) {\n+pub fn add_clean_temp_mem(bcx: @Block, val: ValueRef, t: ty::t) {\n     add_clean_temp_mem_in_scope_(bcx, None, val, t);\n }\n \n-pub fn add_clean_temp_mem_in_scope(bcx: @mut Block,\n+pub fn add_clean_temp_mem_in_scope(bcx: @Block,\n                                    scope_id: ast::NodeId,\n                                    val: ValueRef,\n                                    t: ty::t) {\n     add_clean_temp_mem_in_scope_(bcx, Some(scope_id), val, t);\n }\n \n-pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::NodeId>,\n+pub fn add_clean_temp_mem_in_scope_(bcx: @Block, scope_id: Option<ast::NodeId>,\n                                     val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean_temp_mem({}, {}, {})\",\n@@ -508,7 +509,7 @@ pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::NodeI\n         grow_scope_clean(scope_info);\n     })\n }\n-pub fn add_clean_return_to_mut(bcx: @mut Block,\n+pub fn add_clean_return_to_mut(bcx: @Block,\n                                scope_id: ast::NodeId,\n                                root_key: root_map_key,\n                                frozen_val_ref: ValueRef,\n@@ -541,7 +542,7 @@ pub fn add_clean_return_to_mut(bcx: @mut Block,\n         grow_scope_clean(scope_info);\n     })\n }\n-pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n+pub fn add_clean_free(cx: @Block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n         heap_managed | heap_managed_unique => {\n             @GCHeapFreeingCleanupFunction {\n@@ -566,7 +567,7 @@ pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n-pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n+pub fn revoke_clean(cx: @Block, val: ValueRef) {\n     in_scope_cx(cx, None, |scope_info| {\n         let cleanup_pos = scope_info.cleanups.iter().position(\n             |cu| match *cu {\n@@ -583,16 +584,16 @@ pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n     })\n }\n \n-pub fn block_cleanups(bcx: &mut Block) -> ~[cleanup] {\n-    match bcx.scope {\n+pub fn block_cleanups(bcx: &Block) -> ~[cleanup] {\n+    match bcx.scope.get() {\n        None  => ~[],\n        Some(inf) => inf.cleanups.clone(),\n     }\n }\n \n pub struct ScopeInfo {\n     parent: Option<@mut ScopeInfo>,\n-    loop_break: Option<@mut Block>,\n+    loop_break: Option<@Block>,\n     loop_label: Option<Name>,\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n@@ -657,11 +658,11 @@ pub struct Block {\n     // instructions into that block by way of this block context.\n     // The block pointing to this one in the function's digraph.\n     llbb: BasicBlockRef,\n-    terminated: bool,\n-    unreachable: bool,\n-    parent: Option<@mut Block>,\n+    terminated: Cell<bool>,\n+    unreachable: Cell<bool>,\n+    parent: Option<@Block>,\n     // The current scope within this basic block\n-    scope: Option<@mut ScopeInfo>,\n+    scope: RefCell<Option<@mut ScopeInfo>>,\n     // Is this block part of a landing pad?\n     is_lpad: bool,\n     // info about the AST node this block originated from, if any\n@@ -674,17 +675,17 @@ pub struct Block {\n impl Block {\n \n     pub fn new(llbb: BasicBlockRef,\n-               parent: Option<@mut Block>,\n+               parent: Option<@Block>,\n                is_lpad: bool,\n                node_info: Option<NodeInfo>,\n                fcx: @mut FunctionContext)\n             -> Block {\n         Block {\n             llbb: llbb,\n-            terminated: false,\n-            unreachable: false,\n+            terminated: Cell::new(false),\n+            unreachable: Cell::new(false),\n             parent: parent,\n-            scope: None,\n+            scope: RefCell::new(None),\n             is_lpad: is_lpad,\n             node_info: node_info,\n             fcx: fcx\n@@ -748,16 +749,16 @@ impl Block {\n }\n \n pub struct Result {\n-    bcx: @mut Block,\n+    bcx: @Block,\n     val: ValueRef\n }\n \n-pub fn rslt(bcx: @mut Block, val: ValueRef) -> Result {\n+pub fn rslt(bcx: @Block, val: ValueRef) -> Result {\n     Result {bcx: bcx, val: val}\n }\n \n impl Result {\n-    pub fn unpack(&self, bcx: &mut @mut Block) -> ValueRef {\n+    pub fn unpack(&self, bcx: &mut @Block) -> ValueRef {\n         *bcx = self.bcx;\n         return self.val;\n     }\n@@ -769,11 +770,11 @@ pub fn val_ty(v: ValueRef) -> Type {\n     }\n }\n \n-pub fn in_scope_cx(cx: @mut Block,\n+pub fn in_scope_cx(cx: @Block,\n                    scope_id: Option<ast::NodeId>,\n                    f: |si: &mut ScopeInfo|) {\n     let mut cur = cx;\n-    let mut cur_scope = cur.scope;\n+    let mut cur_scope = cur.scope.get();\n     loop {\n         cur_scope = match cur_scope {\n             Some(inf) => match scope_id {\n@@ -795,13 +796,13 @@ pub fn in_scope_cx(cx: @mut Block,\n             },\n             None => {\n                 cur = block_parent(cur);\n-                cur.scope\n+                cur.scope.get()\n             }\n         }\n     }\n }\n \n-pub fn block_parent(cx: @mut Block) -> @mut Block {\n+pub fn block_parent(cx: @Block) -> @Block {\n     match cx.parent {\n       Some(b) => b,\n       None    => cx.sess().bug(format!(\"block_parent called on root block {:?}\",\n@@ -1070,17 +1071,17 @@ pub struct mono_id_ {\n \n pub type mono_id = @mono_id_;\n \n-pub fn umax(cx: @mut Block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umax(cx: @Block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, b, a);\n }\n \n-pub fn umin(cx: @mut Block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umin(cx: @Block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, a, b);\n }\n \n-pub fn align_to(cx: @mut Block, off: ValueRef, align: ValueRef) -> ValueRef {\n+pub fn align_to(cx: @Block, off: ValueRef, align: ValueRef) -> ValueRef {\n     let mask = build::Sub(cx, align, C_int(cx.ccx(), 1));\n     let bumped = build::Add(cx, off, mask);\n     return build::And(cx, bumped, build::Not(cx, mask));\n@@ -1105,7 +1106,7 @@ pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n     r\n }\n \n-pub fn monomorphize_type(bcx: &mut Block, t: ty::t) -> ty::t {\n+pub fn monomorphize_type(bcx: &Block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n@@ -1118,23 +1119,23 @@ pub fn monomorphize_type(bcx: &mut Block, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn node_id_type(bcx: &mut Block, id: ast::NodeId) -> ty::t {\n+pub fn node_id_type(bcx: &Block, id: ast::NodeId) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: &mut Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty(bcx: &Block, ex: &ast::Expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: &mut Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::expr_ty_adjusted(tcx, ex);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn node_id_type_params(bcx: &mut Block, id: ast::NodeId) -> ~[ty::t] {\n+pub fn node_id_type_params(bcx: &Block, id: ast::NodeId) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n \n@@ -1154,7 +1155,7 @@ pub fn node_id_type_params(bcx: &mut Block, id: ast::NodeId) -> ~[ty::t] {\n     }\n }\n \n-pub fn node_vtables(bcx: @mut Block, id: ast::NodeId)\n+pub fn node_vtables(bcx: @Block, id: ast::NodeId)\n                  -> Option<typeck::vtable_res> {\n     let raw_vtables = bcx.ccx().maps.vtable_map.find(&id);\n     raw_vtables.map(|vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n@@ -1254,7 +1255,7 @@ pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n     }\n }\n \n-pub fn filename_and_line_num_from_span(bcx: @mut Block,\n+pub fn filename_and_line_num_from_span(bcx: @Block,\n                                        span: Span) -> (ValueRef, ValueRef) {\n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n     let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n@@ -1264,11 +1265,11 @@ pub fn filename_and_line_num_from_span(bcx: @mut Block,\n }\n \n // Casts a Rust bool value to an i1.\n-pub fn bool_to_i1(bcx: @mut Block, llval: ValueRef) -> ValueRef {\n+pub fn bool_to_i1(bcx: @Block, llval: ValueRef) -> ValueRef {\n     build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))\n }\n \n-pub fn langcall(bcx: @mut Block, span: Option<Span>, msg: &str,\n+pub fn langcall(bcx: @Block, span: Option<Span>, msg: &str,\n                 li: LangItem) -> ast::DefId {\n     match bcx.tcx().lang_items.require(li) {\n         Ok(id) => id,"}, {"sha": "adad377b022de6a9023d7bfd8cfd54188c35c03e", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -28,7 +28,7 @@ use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit::Visitor;\n \n-pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Block {\n+pub fn trans_block(bcx: @Block, b: &ast::Block, dest: expr::Dest) -> @Block {\n     let _icx = push_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     for s in b.stmts.iter() {\n@@ -39,18 +39,18 @@ pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Bl\n             bcx = expr::trans_into(bcx, e, dest);\n         }\n         None => {\n-            assert!(dest == expr::Ignore || bcx.unreachable);\n+            assert!(dest == expr::Ignore || bcx.unreachable.get());\n         }\n     }\n     return bcx;\n }\n \n-pub fn trans_if(bcx: @mut Block,\n+pub fn trans_if(bcx: @Block,\n             cond: &ast::Expr,\n             thn: ast::P<ast::Block>,\n             els: Option<@ast::Expr>,\n             dest: expr::Dest)\n-         -> @mut Block {\n+         -> @Block {\n     debug!(\"trans_if(bcx={}, cond={}, thn={:?}, dest={})\",\n            bcx.to_str(), bcx.expr_to_str(cond), thn.id,\n            dest.to_str(bcx.ccx()));\n@@ -137,8 +137,8 @@ pub fn trans_if(bcx: @mut Block,\n     return next_bcx;\n \n     // trans `else [ if { .. } ... | { .. } ]`\n-    fn trans_if_else(else_bcx_in: @mut Block, elexpr: @ast::Expr,\n-                     dest: expr::Dest, cleanup: bool) -> @mut Block {\n+    fn trans_if_else(else_bcx_in: @Block, elexpr: @ast::Expr,\n+                     dest: expr::Dest, cleanup: bool) -> @Block {\n         let else_bcx_out = match elexpr.node {\n             ast::ExprIf(_, _, _) => {\n                 let elseif_blk = ast_util::block_from_expr(elexpr);\n@@ -159,11 +159,11 @@ pub fn trans_if(bcx: @mut Block,\n     }\n }\n \n-pub fn join_blocks(parent_bcx: @mut Block, in_cxs: &[@mut Block]) -> @mut Block {\n+pub fn join_blocks(parent_bcx: @Block, in_cxs: &[@Block]) -> @Block {\n     let out = sub_block(parent_bcx, \"join\");\n     let mut reachable = false;\n     for bcx in in_cxs.iter() {\n-        if !bcx.unreachable {\n+        if !bcx.unreachable.get() {\n             Br(*bcx, out.llbb);\n             reachable = true;\n         }\n@@ -174,7 +174,7 @@ pub fn join_blocks(parent_bcx: @mut Block, in_cxs: &[@mut Block]) -> @mut Block\n     return out;\n }\n \n-pub fn trans_while(bcx: @mut Block, cond: &ast::Expr, body: &ast::Block) -> @mut Block {\n+pub fn trans_while(bcx: @Block, cond: &ast::Expr, body: &ast::Block) -> @Block {\n     let _icx = push_ctxt(\"trans_while\");\n     let next_bcx = sub_block(bcx, \"while next\");\n \n@@ -213,10 +213,10 @@ pub fn trans_while(bcx: @mut Block, cond: &ast::Expr, body: &ast::Block) -> @mut\n     return next_bcx;\n }\n \n-pub fn trans_loop(bcx:@mut Block,\n+pub fn trans_loop(bcx:@Block,\n                   body: &ast::Block,\n                   opt_label: Option<Name>)\n-               -> @mut Block {\n+               -> @Block {\n     let _icx = push_ctxt(\"trans_loop\");\n     let next_bcx = sub_block(bcx, \"next\");\n     let body_bcx_in = loop_scope_block(bcx, next_bcx, opt_label, \"`loop`\",\n@@ -227,14 +227,14 @@ pub fn trans_loop(bcx:@mut Block,\n     return next_bcx;\n }\n \n-pub fn trans_break_cont(bcx: @mut Block,\n+pub fn trans_break_cont(bcx: @Block,\n                         opt_label: Option<Name>,\n                         to_end: bool)\n-                     -> @mut Block {\n+                     -> @Block {\n     let _icx = push_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n-    let mut cur_scope = unwind.scope;\n+    let mut cur_scope = unwind.scope.get();\n     let mut target;\n     loop {\n         cur_scope = match cur_scope {\n@@ -272,7 +272,7 @@ pub fn trans_break_cont(bcx: @mut Block,\n                             return bcx;\n                         }\n                 };\n-                unwind.scope\n+                unwind.scope.get()\n             }\n         }\n     }\n@@ -281,15 +281,15 @@ pub fn trans_break_cont(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn trans_break(bcx: @mut Block, label_opt: Option<Name>) -> @mut Block {\n+pub fn trans_break(bcx: @Block, label_opt: Option<Name>) -> @Block {\n     return trans_break_cont(bcx, label_opt, true);\n }\n \n-pub fn trans_cont(bcx: @mut Block, label_opt: Option<Name>) -> @mut Block {\n+pub fn trans_cont(bcx: @Block, label_opt: Option<Name>) -> @Block {\n     return trans_break_cont(bcx, label_opt, false);\n }\n \n-pub fn trans_ret(bcx: @mut Block, e: Option<@ast::Expr>) -> @mut Block {\n+pub fn trans_ret(bcx: @Block, e: Option<@ast::Expr>) -> @Block {\n     let _icx = push_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     let dest = match bcx.fcx.llretptr {\n@@ -307,10 +307,10 @@ pub fn trans_ret(bcx: @mut Block, e: Option<@ast::Expr>) -> @mut Block {\n     return bcx;\n }\n \n-pub fn trans_fail_expr(bcx: @mut Block,\n+pub fn trans_fail_expr(bcx: @Block,\n                        sp_opt: Option<Span>,\n                        fail_expr: Option<@ast::Expr>)\n-                    -> @mut Block {\n+                    -> @Block {\n     let _icx = push_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;\n     match fail_expr {\n@@ -323,7 +323,7 @@ pub fn trans_fail_expr(bcx: @mut Block,\n             if ty::type_is_str(arg_datum.ty) {\n                 let (lldata, _) = arg_datum.get_vec_base_and_len_no_root(bcx);\n                 return trans_fail_value(bcx, sp_opt, lldata);\n-            } else if bcx.unreachable || ty::type_is_bot(arg_datum.ty) {\n+            } else if bcx.unreachable.get() || ty::type_is_bot(arg_datum.ty) {\n                 return bcx;\n             } else {\n                 bcx.sess().span_bug(\n@@ -335,19 +335,19 @@ pub fn trans_fail_expr(bcx: @mut Block,\n     }\n }\n \n-pub fn trans_fail(bcx: @mut Block,\n+pub fn trans_fail(bcx: @Block,\n                   sp_opt: Option<Span>,\n                   fail_str: @str)\n-               -> @mut Block {\n+               -> @Block {\n     let _icx = push_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     return trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n-fn trans_fail_value(bcx: @mut Block,\n+fn trans_fail_value(bcx: @Block,\n                     sp_opt: Option<Span>,\n                     V_fail_str: ValueRef)\n-                 -> @mut Block {\n+                 -> @Block {\n     let _icx = push_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let (V_filename, V_line) = match sp_opt {\n@@ -370,8 +370,8 @@ fn trans_fail_value(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn trans_fail_bounds_check(bcx: @mut Block, sp: Span,\n-                               index: ValueRef, len: ValueRef) -> @mut Block {\n+pub fn trans_fail_bounds_check(bcx: @Block, sp: Span,\n+                               index: ValueRef, len: ValueRef) -> @Block {\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n     let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n     let args = ~[filename, line, index, len];"}, {"sha": "f606a2e2769c3e12c5621e1d90d5c0529d4bcdf7", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -128,7 +128,7 @@ pub struct Datum {\n }\n \n pub struct DatumBlock {\n-    bcx: @mut Block,\n+    bcx: @Block,\n     datum: Datum,\n }\n \n@@ -165,14 +165,14 @@ pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum {\n     return Datum {val: val, ty: ty, mode: ByValue};\n }\n \n-pub fn immediate_rvalue_bcx(bcx: @mut Block,\n+pub fn immediate_rvalue_bcx(bcx: @Block,\n                             val: ValueRef,\n                             ty: ty::t)\n                          -> DatumBlock {\n     return DatumBlock {bcx: bcx, datum: immediate_rvalue(val, ty)};\n }\n \n-pub fn scratch_datum(bcx: @mut Block, ty: ty::t, name: &str, zero: bool) -> Datum {\n+pub fn scratch_datum(bcx: @Block, ty: ty::t, name: &str, zero: bool) -> Datum {\n     /*!\n      * Allocates temporary space on the stack using alloca() and\n      * returns a by-ref Datum pointing to it.  If `zero` is true, the\n@@ -206,10 +206,10 @@ pub fn appropriate_mode(ccx: &mut CrateContext, ty: ty::t) -> DatumMode {\n \n impl Datum {\n     pub fn store_to(&self,\n-                    bcx: @mut Block,\n+                    bcx: @Block,\n                     action: CopyAction,\n                     dst: ValueRef)\n-                    -> @mut Block {\n+                    -> @Block {\n         /*!\n          *\n          * Stores this value into its final home.  This moves if\n@@ -224,9 +224,9 @@ impl Datum {\n     }\n \n     pub fn store_to_dest(&self,\n-                         bcx: @mut Block,\n+                         bcx: @Block,\n                          dest: expr::Dest)\n-                         -> @mut Block {\n+                         -> @Block {\n         match dest {\n             expr::Ignore => {\n                 return bcx;\n@@ -238,30 +238,30 @@ impl Datum {\n     }\n \n     pub fn store_to_datum(&self,\n-                          bcx: @mut Block,\n+                          bcx: @Block,\n                           action: CopyAction,\n                           datum: Datum)\n-                          -> @mut Block {\n+                          -> @Block {\n         debug!(\"store_to_datum(self={}, action={:?}, datum={})\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert!(datum.mode.is_by_ref());\n         self.store_to(bcx, action, datum.val)\n     }\n \n-    pub fn move_to_datum(&self, bcx: @mut Block, action: CopyAction, datum: Datum)\n-                         -> @mut Block {\n+    pub fn move_to_datum(&self, bcx: @Block, action: CopyAction, datum: Datum)\n+                         -> @Block {\n         assert!(datum.mode.is_by_ref());\n         self.move_to(bcx, action, datum.val)\n     }\n \n-    pub fn copy_to_datum(&self, bcx: @mut Block, action: CopyAction, datum: Datum)\n-                         -> @mut Block {\n+    pub fn copy_to_datum(&self, bcx: @Block, action: CopyAction, datum: Datum)\n+                         -> @Block {\n         assert!(datum.mode.is_by_ref());\n         self.copy_to(bcx, action, datum.val)\n     }\n \n-    pub fn copy_to(&self, bcx: @mut Block, action: CopyAction, dst: ValueRef)\n-                   -> @mut Block {\n+    pub fn copy_to(&self, bcx: @Block, action: CopyAction, dst: ValueRef)\n+                   -> @Block {\n         /*!\n          *\n          * Copies the value into `dst`, which should be a pointer to a\n@@ -304,10 +304,10 @@ impl Datum {\n     }\n \n     pub fn copy_to_no_check(&self,\n-                            bcx: @mut Block,\n+                            bcx: @Block,\n                             action: CopyAction,\n                             dst: ValueRef)\n-                            -> @mut Block {\n+                            -> @Block {\n         /*!\n          *\n          * A helper for `copy_to()` which does not check to see if we\n@@ -335,8 +335,8 @@ impl Datum {\n     // This works like copy_val, except that it deinitializes the source.\n     // Since it needs to zero out the source, src also needs to be an lval.\n     //\n-    pub fn move_to(&self, bcx: @mut Block, action: CopyAction, dst: ValueRef)\n-                   -> @mut Block {\n+    pub fn move_to(&self, bcx: @Block, action: CopyAction, dst: ValueRef)\n+                   -> @Block {\n         let _icx = push_ctxt(\"move_to\");\n         let mut bcx = bcx;\n \n@@ -365,7 +365,7 @@ impl Datum {\n         return bcx;\n     }\n \n-    pub fn add_clean(&self, bcx: @mut Block) {\n+    pub fn add_clean(&self, bcx: @Block) {\n         /*!\n          * Schedules this datum for cleanup in `bcx`.  The datum\n          * must be an rvalue.\n@@ -385,7 +385,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn cancel_clean(&self, bcx: @mut Block) {\n+    pub fn cancel_clean(&self, bcx: @Block) {\n         if ty::type_needs_drop(bcx.tcx(), self.ty) {\n             match self.mode {\n                 ByValue |\n@@ -410,7 +410,7 @@ impl Datum {\n              self.mode)\n     }\n \n-    pub fn to_value_datum(&self, bcx: @mut Block) -> Datum {\n+    pub fn to_value_datum(&self, bcx: @Block) -> Datum {\n         /*!\n          *\n          * Yields a by-value form of this datum.  This may involve\n@@ -427,7 +427,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_value_llval(&self, bcx: @mut Block) -> ValueRef {\n+    pub fn to_value_llval(&self, bcx: @Block) -> ValueRef {\n         /*!\n          *\n          * Yields the value itself. */\n@@ -448,7 +448,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_ref_datum(&self, bcx: @mut Block) -> Datum {\n+    pub fn to_ref_datum(&self, bcx: @Block) -> Datum {\n         /*!\n          * Yields a by-ref form of this datum.  This may involve\n          * creation of a temporary stack slot.  The value returned by\n@@ -465,7 +465,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_ref_llval(&self, bcx: @mut Block) -> ValueRef {\n+    pub fn to_ref_llval(&self, bcx: @Block) -> ValueRef {\n         match self.mode {\n             ByRef(_) => self.val,\n             ByValue => {\n@@ -498,7 +498,7 @@ impl Datum {\n         appropriate_mode(ccx, self.ty)\n     }\n \n-    pub fn to_appropriate_llval(&self, bcx: @mut Block) -> ValueRef {\n+    pub fn to_appropriate_llval(&self, bcx: @Block) -> ValueRef {\n         /*!\n          *\n          * Yields an llvalue with the `appropriate_mode()`. */\n@@ -509,7 +509,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_appropriate_datum(&self, bcx: @mut Block) -> Datum {\n+    pub fn to_appropriate_datum(&self, bcx: @Block) -> Datum {\n         /*!\n          *\n          * Yields a datum with the `appropriate_mode()`. */\n@@ -521,7 +521,7 @@ impl Datum {\n     }\n \n     pub fn get_element(&self,\n-                       bcx: @mut Block,\n+                       bcx: @Block,\n                        ty: ty::t,\n                        source: DatumCleanup,\n                        gep: |ValueRef| -> ValueRef)\n@@ -534,7 +534,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn drop_val(&self, bcx: @mut Block) -> @mut Block {\n+    pub fn drop_val(&self, bcx: @Block) -> @Block {\n         if !ty::type_needs_drop(bcx.tcx(), self.ty) {\n             return bcx;\n         }\n@@ -545,7 +545,7 @@ impl Datum {\n         };\n     }\n \n-    pub fn box_body(&self, bcx: @mut Block) -> Datum {\n+    pub fn box_body(&self, bcx: @Block) -> Datum {\n         /*!\n          *\n          * This datum must represent an @T or ~T box.  Returns a new\n@@ -578,7 +578,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_rptr(&self, bcx: @mut Block) -> Datum {\n+    pub fn to_rptr(&self, bcx: @Block) -> Datum {\n         //! Returns a new datum of region-pointer type containing the\n         //! the same ptr as this datum (after converting to by-ref\n         //! using `to_ref_llval()`).\n@@ -599,12 +599,12 @@ impl Datum {\n     /// derefs: Number of times deref'd already.\n     /// is_auto: If true, only deref if auto-derefable.\n     pub fn try_deref(&self,\n-                     bcx: @mut Block,\n+                     bcx: @Block,\n                      span: Span,\n                      expr_id: ast::NodeId,\n                      derefs: uint,\n                      is_auto: bool)\n-                     -> (Option<Datum>, @mut Block) {\n+                     -> (Option<Datum>, @Block) {\n         let ccx = bcx.ccx();\n \n         debug!(\"try_deref(expr_id={:?}, derefs={:?}, is_auto={}, self={:?})\",\n@@ -703,7 +703,7 @@ impl Datum {\n             }\n         }\n \n-        fn deref_ptr(bcx: @mut Block, lv: &Datum, ty: ty::t) -> Datum {\n+        fn deref_ptr(bcx: @Block, lv: &Datum, ty: ty::t) -> Datum {\n             Datum {\n                 val: lv.to_value_llval(bcx),\n                 ty: ty,\n@@ -713,7 +713,7 @@ impl Datum {\n     }\n \n     /// expr: The deref expression.\n-    pub fn deref(&self, bcx: @mut Block, expr: &ast::Expr, derefs: uint)\n+    pub fn deref(&self, bcx: @Block, expr: &ast::Expr, derefs: uint)\n                  -> DatumBlock {\n         match self.try_deref(bcx, expr.span, expr.id, derefs, false) {\n             (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },\n@@ -725,7 +725,7 @@ impl Datum {\n     }\n \n     pub fn autoderef(&self,\n-                     bcx: @mut Block,\n+                     bcx: @Block,\n                      span: Span,\n                      expr_id: ast::NodeId,\n                      max: uint)\n@@ -758,11 +758,11 @@ impl Datum {\n     }\n \n     pub fn get_vec_base_and_byte_len(&self,\n-                                     mut bcx: @mut Block,\n+                                     mut bcx: @Block,\n                                      span: Span,\n                                      expr_id: ast::NodeId,\n                                      derefs: uint)\n-                                     -> (@mut Block, ValueRef, ValueRef) {\n+                                     -> (@Block, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n         //! and write guards checks.\n \n@@ -772,7 +772,7 @@ impl Datum {\n         (bcx, base, len)\n     }\n \n-    pub fn get_vec_base_and_byte_len_no_root(&self, bcx: @mut Block)\n+    pub fn get_vec_base_and_byte_len_no_root(&self, bcx: @Block)\n                                              -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Des not root\n         //! nor perform write guard checks.\n@@ -782,11 +782,11 @@ impl Datum {\n     }\n \n     pub fn get_vec_base_and_len(&self,\n-                                     mut bcx: @mut Block,\n+                                     mut bcx: @Block,\n                                      span: Span,\n                                      expr_id: ast::NodeId,\n                                      derefs: uint)\n-                                     -> (@mut Block, ValueRef, ValueRef) {\n+                                     -> (@Block, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n         //! and write guards checks.\n \n@@ -796,7 +796,7 @@ impl Datum {\n         (bcx, base, len)\n     }\n \n-    pub fn get_vec_base_and_len_no_root(&self, bcx: @mut Block)\n+    pub fn get_vec_base_and_len_no_root(&self, bcx: @Block)\n                                              -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Des not root\n         //! nor perform write guard checks.\n@@ -806,21 +806,21 @@ impl Datum {\n     }\n \n     pub fn root_and_write_guard(&self,\n-                                bcx: @mut Block,\n+                                bcx: @Block,\n                                 span: Span,\n                                 expr_id: ast::NodeId,\n                                 derefs: uint)\n-                                -> @mut Block {\n+                                -> @Block {\n         write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs)\n     }\n \n-    pub fn to_result(&self, bcx: @mut Block) -> common::Result {\n+    pub fn to_result(&self, bcx: @Block) -> common::Result {\n         rslt(bcx, self.to_appropriate_llval(bcx))\n     }\n }\n \n impl DatumBlock {\n-    pub fn unpack(&self, bcx: &mut @mut Block) -> Datum {\n+    pub fn unpack(&self, bcx: &mut @Block) -> Datum {\n         *bcx = self.bcx;\n         return self.datum;\n     }\n@@ -830,22 +830,22 @@ impl DatumBlock {\n         *self\n     }\n \n-    pub fn drop_val(&self) -> @mut Block {\n+    pub fn drop_val(&self) -> @Block {\n         self.datum.drop_val(self.bcx)\n     }\n \n     pub fn store_to(&self,\n                     action: CopyAction,\n                     dst: ValueRef)\n-                    -> @mut Block {\n+                    -> @Block {\n         self.datum.store_to(self.bcx, action, dst)\n     }\n \n-    pub fn copy_to(&self, action: CopyAction, dst: ValueRef) -> @mut Block {\n+    pub fn copy_to(&self, action: CopyAction, dst: ValueRef) -> @Block {\n         self.datum.copy_to(self.bcx, action, dst)\n     }\n \n-    pub fn move_to(&self, action: CopyAction, dst: ValueRef) -> @mut Block {\n+    pub fn move_to(&self, action: CopyAction, dst: ValueRef) -> @Block {\n         self.datum.move_to(self.bcx, action, dst)\n     }\n "}, {"sha": "080efa059eab6f157fd07bfd4513f6d761e1cc96", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -284,7 +284,7 @@ pub fn finalize(cx: @mut CrateContext) {\n /// Creates debug information for the given local variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_local_var_metadata(bcx: @mut Block,\n+pub fn create_local_var_metadata(bcx: @Block,\n                                  local: &ast::Local) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n@@ -320,7 +320,7 @@ pub fn create_local_var_metadata(bcx: @mut Block,\n /// Creates debug information for a variable captured in a closure.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_captured_var_metadata(bcx: @mut Block,\n+pub fn create_captured_var_metadata(bcx: @Block,\n                                     node_id: ast::NodeId,\n                                     env_data_type: ty::t,\n                                     env_pointer: ValueRef,\n@@ -387,7 +387,7 @@ pub fn create_captured_var_metadata(bcx: @mut Block,\n /// Creates debug information for a local variable introduced in the head of a match-statement arm.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_match_binding_metadata(bcx: @mut Block,\n+pub fn create_match_binding_metadata(bcx: @Block,\n                                      variable_ident: ast::Ident,\n                                      node_id: ast::NodeId,\n                                      variable_type: ty::t,\n@@ -417,7 +417,7 @@ pub fn create_match_binding_metadata(bcx: @mut Block,\n /// Creates debug information for the self argument of a method.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_self_argument_metadata(bcx: @mut Block,\n+pub fn create_self_argument_metadata(bcx: @Block,\n                                      type_of_self: ty::t,\n                                      llptr: ValueRef) {\n     if fn_should_be_ignored(bcx.fcx) {\n@@ -492,7 +492,7 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_argument_metadata(bcx: @mut Block,\n+pub fn create_argument_metadata(bcx: @Block,\n                                 arg: &ast::arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n@@ -951,7 +951,7 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     });\n }\n \n-fn declare_local(bcx: @mut Block,\n+fn declare_local(bcx: @Block,\n                  variable_ident: ast::Ident,\n                  variable_type: ty::t,\n                  scope_metadata: DIScope,"}, {"sha": "08e914f5b9bee57d0c3b346c29695e654a89e70d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -175,7 +175,7 @@ impl Dest {\n     }\n }\n \n-pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n+pub fn trans_to_datum(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     debug!(\"trans_to_datum(expr={})\", bcx.expr_to_str(expr));\n \n     let mut bcx = bcx;\n@@ -229,11 +229,11 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     debug!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n-    fn auto_ref(bcx: @mut Block, datum: Datum) -> DatumBlock {\n+    fn auto_ref(bcx: @Block, datum: Datum) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: datum.to_rptr(bcx)}\n     }\n \n-    fn auto_borrow_fn(bcx: @mut Block,\n+    fn auto_borrow_fn(bcx: @Block,\n                       adjusted_ty: ty::t,\n                       datum: Datum) -> DatumBlock {\n         // Currently, all closure types are represented precisely the\n@@ -244,7 +244,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                                   mode: datum.mode}}\n     }\n \n-    fn auto_slice(bcx: @mut Block,\n+    fn auto_slice(bcx: @Block,\n                   autoderefs: uint,\n                   expr: &ast::Expr,\n                   datum: Datum) -> DatumBlock {\n@@ -273,7 +273,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn add_env(bcx: @mut Block, expr: &ast::Expr, datum: Datum) -> DatumBlock {\n+    fn add_env(bcx: @Block, expr: &ast::Expr, datum: Datum) -> DatumBlock {\n         // This is not the most efficient thing possible; since closures\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -292,15 +292,15 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn auto_slice_and_ref(bcx: @mut Block,\n+    fn auto_slice_and_ref(bcx: @Block,\n                           autoderefs: uint,\n                           expr: &ast::Expr,\n                           datum: Datum) -> DatumBlock {\n         let DatumBlock { bcx, datum } = auto_slice(bcx, autoderefs, expr, datum);\n         auto_ref(bcx, datum)\n     }\n \n-    fn auto_borrow_obj(mut bcx: @mut Block,\n+    fn auto_borrow_obj(mut bcx: @Block,\n                        autoderefs: uint,\n                        expr: &ast::Expr,\n                        source_datum: Datum) -> DatumBlock {\n@@ -414,7 +414,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     }\n }\n \n-pub fn trans_into(bcx: @mut Block, expr: &ast::Expr, dest: Dest) -> @mut Block {\n+pub fn trans_into(bcx: @Block, expr: &ast::Expr, dest: Dest) -> @Block {\n     if bcx.tcx().adjustments.contains_key(&expr.id) {\n         // use trans_to_datum, which is mildly less efficient but\n         // which will perform the adjustments:\n@@ -472,7 +472,7 @@ pub fn trans_into(bcx: @mut Block, expr: &ast::Expr, dest: Dest) -> @mut Block {\n     };\n }\n \n-fn trans_lvalue(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_lvalue(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n@@ -491,7 +491,7 @@ fn trans_lvalue(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     };\n }\n \n-fn trans_to_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_to_datum_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     /*!\n      * Translates an expression into a datum.  If this expression\n      * is an rvalue, this will result in a temporary value being\n@@ -551,13 +551,13 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         }\n     }\n \n-    fn nil(bcx: @mut Block, ty: ty::t) -> DatumBlock {\n+    fn nil(bcx: @Block, ty: ty::t) -> DatumBlock {\n         let datum = immediate_rvalue(C_nil(), ty);\n         DatumBlock {bcx: bcx, datum: datum}\n     }\n }\n \n-fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_rvalue_datum_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n     match expr.node {\n@@ -608,11 +608,11 @@ fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBloc\n     }\n }\n \n-fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> @mut Block {\n+fn trans_rvalue_stmt_unadjusted(bcx: @Block, expr: &ast::Expr) -> @Block {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rvalue_stmt\");\n \n-    if bcx.unreachable {\n+    if bcx.unreachable.get() {\n         return bcx;\n     }\n \n@@ -660,8 +660,8 @@ fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> @mut Block\n     };\n }\n \n-fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n-                               dest: Dest) -> @mut Block {\n+fn trans_rvalue_dps_unadjusted(bcx: @Block, expr: &ast::Expr,\n+                               dest: Dest) -> @Block {\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n@@ -785,8 +785,8 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n     }\n }\n \n-fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::Expr,\n-                            def: ast::Def, dest: Dest) -> @mut Block {\n+fn trans_def_dps_unadjusted(bcx: @Block, ref_expr: &ast::Expr,\n+                            def: ast::Def, dest: Dest) -> @Block {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n     let ccx = bcx.ccx();\n \n@@ -835,7 +835,7 @@ fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::Expr,\n     }\n }\n \n-fn trans_def_datum_unadjusted(bcx: @mut Block,\n+fn trans_def_datum_unadjusted(bcx: @Block,\n                               ref_expr: &ast::Expr,\n                               def: ast::Def) -> DatumBlock\n {\n@@ -870,7 +870,7 @@ fn trans_def_datum_unadjusted(bcx: @mut Block,\n     }\n }\n \n-fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_lvalue_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n@@ -907,7 +907,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         }\n     };\n \n-    fn trans_rec_field(bcx: @mut Block,\n+    fn trans_rec_field(bcx: @Block,\n                        base: &ast::Expr,\n                        field: ast::Ident) -> DatumBlock {\n         //! Translates `base.field`.\n@@ -931,7 +931,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         })\n     }\n \n-    fn trans_index(bcx: @mut Block,\n+    fn trans_index(bcx: @Block,\n                    index_expr: &ast::Expr,\n                    base: &ast::Expr,\n                    idx: &ast::Expr) -> DatumBlock {\n@@ -985,7 +985,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         };\n     }\n \n-    fn trans_def_lvalue(bcx: @mut Block,\n+    fn trans_def_lvalue(bcx: @Block,\n                         ref_expr: &ast::Expr,\n                         def: ast::Def)\n         -> DatumBlock\n@@ -1006,7 +1006,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                     }\n                 }\n \n-                fn get_val(bcx: @mut Block, did: ast::DefId, const_ty: ty::t)\n+                fn get_val(bcx: @Block, did: ast::DefId, const_ty: ty::t)\n                            -> ValueRef {\n                     // For external constants, we don't inline.\n                     if did.crate == ast::LOCAL_CRATE {\n@@ -1063,7 +1063,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     }\n }\n \n-pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n+pub fn trans_local_var(bcx: @Block, def: ast::Def) -> Datum {\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     return match def {\n@@ -1115,7 +1115,7 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n         }\n     };\n \n-    fn take_local(bcx: @mut Block,\n+    fn take_local(bcx: @Block,\n                   table: &HashMap<ast::NodeId, ValueRef>,\n                   nid: ast::NodeId) -> Datum {\n         let v = match table.find(&nid) {\n@@ -1184,12 +1184,12 @@ pub fn with_field_tys<R>(\n     }\n }\n \n-fn trans_rec_or_struct(bcx: @mut Block,\n+fn trans_rec_or_struct(bcx: @Block,\n                        fields: &[ast::Field],\n                        base: Option<@ast::Expr>,\n                        expr_span: codemap::Span,\n                        id: ast::NodeId,\n-                       dest: Dest) -> @mut Block\n+                       dest: Dest) -> @Block\n {\n     let _icx = push_ctxt(\"trans_rec\");\n     let bcx = bcx;\n@@ -1263,10 +1263,10 @@ struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: ty::Disr,\n+fn trans_adt(bcx: @Block, repr: &adt::Repr, discr: ty::Disr,\n              fields: &[(uint, @ast::Expr)],\n              optbase: Option<StructBaseInfo>,\n-             dest: Dest) -> @mut Block {\n+             dest: Dest) -> @Block {\n     let _icx = push_ctxt(\"trans_adt\");\n     let mut bcx = bcx;\n     let addr = match dest {\n@@ -1311,15 +1311,15 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: ty::Disr,\n }\n \n \n-fn trans_immediate_lit(bcx: @mut Block, expr: &ast::Expr,\n+fn trans_immediate_lit(bcx: @Block, expr: &ast::Expr,\n                        lit: ast::lit) -> DatumBlock {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n     let ty = expr_ty(bcx, expr);\n     immediate_rvalue_bcx(bcx, consts::const_lit(bcx.ccx(), expr, lit), ty)\n }\n \n-fn trans_unary_datum(bcx: @mut Block,\n+fn trans_unary_datum(bcx: @Block,\n                      un_expr: &ast::Expr,\n                      op: ast::UnOp,\n                      sub_expr: &ast::Expr) -> DatumBlock {\n@@ -1379,7 +1379,7 @@ fn trans_unary_datum(bcx: @mut Block,\n         }\n     };\n \n-    fn trans_boxed_expr(bcx: @mut Block,\n+    fn trans_boxed_expr(bcx: @Block,\n                         box_ty: ty::t,\n                         contents: &ast::Expr,\n                         contents_ty: ty::t,\n@@ -1408,7 +1408,7 @@ fn trans_unary_datum(bcx: @mut Block,\n     }\n }\n \n-fn trans_addr_of(bcx: @mut Block, expr: &ast::Expr,\n+fn trans_addr_of(bcx: @Block, expr: &ast::Expr,\n                  subexpr: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n@@ -1419,7 +1419,7 @@ fn trans_addr_of(bcx: @mut Block, expr: &ast::Expr,\n \n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n-fn trans_eager_binop(bcx: @mut Block,\n+fn trans_eager_binop(bcx: @Block,\n                      binop_expr: &ast::Expr,\n                      binop_ty: ty::t,\n                      op: ast::BinOp,\n@@ -1522,7 +1522,7 @@ fn trans_eager_binop(bcx: @mut Block,\n // refinement types would obviate the need for this\n enum lazy_binop_ty { lazy_and, lazy_or }\n \n-fn trans_lazy_binop(bcx: @mut Block,\n+fn trans_lazy_binop(bcx: @Block,\n                     binop_expr: &ast::Expr,\n                     op: lazy_binop_ty,\n                     a: &ast::Expr,\n@@ -1537,7 +1537,7 @@ fn trans_lazy_binop(bcx: @mut Block,\n         })\n     };\n \n-    if past_lhs.unreachable {\n+    if past_lhs.unreachable.get() {\n         return immediate_rvalue_bcx(past_lhs, lhs, binop_ty);\n     }\n \n@@ -1556,7 +1556,7 @@ fn trans_lazy_binop(bcx: @mut Block,\n         })\n     };\n \n-    if past_rhs.unreachable {\n+    if past_rhs.unreachable.get() {\n         return immediate_rvalue_bcx(join, lhs, binop_ty);\n     }\n \n@@ -1567,7 +1567,7 @@ fn trans_lazy_binop(bcx: @mut Block,\n     return immediate_rvalue_bcx(join, phi, binop_ty);\n }\n \n-fn trans_binary(bcx: @mut Block,\n+fn trans_binary(bcx: @Block,\n                 binop_expr: &ast::Expr,\n                 op: ast::BinOp,\n                 lhs: &ast::Expr,\n@@ -1593,14 +1593,14 @@ fn trans_binary(bcx: @mut Block,\n     }\n }\n \n-fn trans_overloaded_op(bcx: @mut Block,\n+fn trans_overloaded_op(bcx: @Block,\n                        expr: &ast::Expr,\n                        callee_id: ast::NodeId,\n                        rcvr: &ast::Expr,\n                        args: ~[@ast::Expr],\n                        ret_ty: ty::t,\n                        dest: Dest)\n-                       -> @mut Block {\n+                       -> @Block {\n     let origin = bcx.ccx().maps.method_map.get_copy(&expr.id);\n     let fty = node_id_type(bcx, callee_id);\n     callee::trans_call_inner(bcx,\n@@ -1618,7 +1618,7 @@ fn trans_overloaded_op(bcx: @mut Block,\n                              DoAutorefArg).bcx\n }\n \n-fn int_cast(bcx: @mut Block, lldsttype: Type, llsrctype: Type,\n+fn int_cast(bcx: @Block, lldsttype: Type, llsrctype: Type,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n     let _icx = push_ctxt(\"int_cast\");\n     unsafe {\n@@ -1636,7 +1636,7 @@ fn int_cast(bcx: @mut Block, lldsttype: Type, llsrctype: Type,\n     }\n }\n \n-fn float_cast(bcx: @mut Block, lldsttype: Type, llsrctype: Type,\n+fn float_cast(bcx: @Block, lldsttype: Type, llsrctype: Type,\n               llsrc: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"float_cast\");\n     let srcsz = llsrctype.float_width();\n@@ -1672,7 +1672,7 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     }\n }\n \n-fn trans_imm_cast(bcx: @mut Block, expr: &ast::Expr,\n+fn trans_imm_cast(bcx: @Block, expr: &ast::Expr,\n                   id: ast::NodeId) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_cast\");\n     let ccx = bcx.ccx();\n@@ -1747,12 +1747,12 @@ fn trans_imm_cast(bcx: @mut Block, expr: &ast::Expr,\n     return immediate_rvalue_bcx(bcx, newval, t_out);\n }\n \n-fn trans_assign_op(bcx: @mut Block,\n+fn trans_assign_op(bcx: @Block,\n                    expr: &ast::Expr,\n                    callee_id: ast::NodeId,\n                    op: ast::BinOp,\n                    dst: &ast::Expr,\n-                   src: @ast::Expr) -> @mut Block\n+                   src: @ast::Expr) -> @Block\n {\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n@@ -1788,7 +1788,7 @@ fn trans_assign_op(bcx: @mut Block,\n     return result_datum.copy_to_datum(bcx, DROP_EXISTING, dst_datum);\n }\n \n-pub fn trans_log_level(bcx: @mut Block) -> DatumBlock {\n+pub fn trans_log_level(bcx: @Block) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_log_level\");\n     let ccx = bcx.ccx();\n "}, {"sha": "e084a603c49618ae96ca9693f7e1dee0376d5889", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -153,12 +153,12 @@ pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n     return llfn;\n }\n \n-pub fn trans_native_call(bcx: @mut Block,\n+pub fn trans_native_call(bcx: @Block,\n                          callee_ty: ty::t,\n                          llfn: ValueRef,\n                          llretptr: ValueRef,\n                          llargs_rust: &[ValueRef],\n-                         passed_arg_tys: ~[ty::t]) -> @mut Block {\n+                         passed_arg_tys: ~[ty::t]) -> @Block {\n     /*!\n      * Prepares a call to a native function. This requires adapting\n      * from the Rust argument passing rules to the native rules."}, {"sha": "90dc74ef489b58a957f0df90ae5ee99be7efb11a", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -40,23 +40,23 @@ use std::c_str::ToCStr;\n use std::libc::c_uint;\n use syntax::ast;\n \n-pub fn trans_free(cx: @mut Block, v: ValueRef) -> @mut Block {\n+pub fn trans_free(cx: @Block, v: ValueRef) -> @Block {\n     let _icx = push_ctxt(\"trans_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", FreeFnLangItem),\n         [PointerCast(cx, v, Type::i8p())],\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn trans_exchange_free(cx: @mut Block, v: ValueRef) -> @mut Block {\n+pub fn trans_exchange_free(cx: @Block, v: ValueRef) -> @Block {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n         [PointerCast(cx, v, Type::i8p())],\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn take_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn take_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -65,7 +65,7 @@ pub fn take_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     return cx;\n }\n \n-pub fn drop_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn drop_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -74,14 +74,14 @@ pub fn drop_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     return cx;\n }\n \n-pub fn drop_ty_immediate(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn drop_ty_immediate(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     Store(bcx, v, vp);\n     drop_ty(bcx, vp, t)\n }\n \n-pub fn free_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn free_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -90,7 +90,7 @@ pub fn free_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     return cx;\n }\n \n-pub fn free_ty_immediate(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn free_ty_immediate(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     let _icx = push_ctxt(\"free_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_uniq(_) |\n@@ -264,7 +264,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue_full(bcx: @mut Block,\n+pub fn call_tydesc_glue_full(bcx: @Block,\n                              v: ValueRef,\n                              tydesc: ValueRef,\n                              field: uint,\n@@ -273,7 +273,7 @@ pub fn call_tydesc_glue_full(bcx: @mut Block,\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n-    if bcx.unreachable && !ccx.sess.no_landing_pads() { return; }\n+    if bcx.unreachable.get() && !ccx.sess.no_landing_pads() { return; }\n \n     let static_glue_fn = match static_ti {\n       None => None,\n@@ -323,15 +323,15 @@ pub fn call_tydesc_glue_full(bcx: @mut Block,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue(cx: @mut Block, v: ValueRef, t: ty::t, field: uint)\n-    -> @mut Block {\n+pub fn call_tydesc_glue(cx: @Block, v: ValueRef, t: ty::t, field: uint)\n+    -> @Block {\n     let _icx = push_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n     return cx;\n }\n \n-pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn make_visit_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     let _icx = push_ctxt(\"make_visit_glue\");\n     with_scope(bcx, None, \"visitor cleanup\", |bcx| {\n         let mut bcx = bcx;\n@@ -350,7 +350,7 @@ pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     })\n }\n \n-pub fn make_free_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn make_free_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_free_glue\");\n     match ty::get(t).sty {\n@@ -387,17 +387,17 @@ pub fn make_free_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     }\n }\n \n-pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n-                              class_did: ast::DefId, substs: &ty::substs) -> @mut Block {\n+pub fn trans_struct_drop_flag(bcx: @Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n+                              class_did: ast::DefId, substs: &ty::substs) -> @Block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n     with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag)), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n }\n \n-pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n-                         class_did: ast::DefId, substs: &ty::substs) -> @mut Block {\n+pub fn trans_struct_drop(bcx: @Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n+                         class_did: ast::DefId, substs: &ty::substs) -> @Block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n     // Find and call the actual destructor\n@@ -434,7 +434,7 @@ pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast:\n     })\n }\n \n-pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {\n+pub fn make_drop_glue(bcx: @Block, v0: ValueRef, t: ty::t) -> @Block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n@@ -505,10 +505,10 @@ pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {\n }\n \n // box_ptr_ptr is optional, it is constructed if not supplied.\n-pub fn decr_refcnt_maybe_free(bcx: @mut Block, box_ptr: ValueRef,\n+pub fn decr_refcnt_maybe_free(bcx: @Block, box_ptr: ValueRef,\n                               box_ptr_ptr: Option<ValueRef>,\n                               t: ty::t)\n-                           -> @mut Block {\n+                           -> @Block {\n     let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n \n@@ -534,7 +534,7 @@ pub fn decr_refcnt_maybe_free(bcx: @mut Block, box_ptr: ValueRef,\n }\n \n \n-pub fn make_take_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn make_take_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     let _icx = push_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     match ty::get(t).sty {\n@@ -575,7 +575,7 @@ pub fn make_take_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     }\n }\n \n-pub fn incr_refcnt_of_boxed(cx: @mut Block, box_ptr: ValueRef) {\n+pub fn incr_refcnt_of_boxed(cx: @Block, box_ptr: ValueRef) {\n     let _icx = push_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n@@ -639,8 +639,8 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     return inf;\n }\n \n-pub type glue_helper<'a> = 'a |@mut Block, ValueRef, ty::t|\n-                                     -> @mut Block;\n+pub type glue_helper<'a> = 'a |@Block, ValueRef, ty::t|\n+                                     -> @Block;\n \n pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n                             name: &str) -> ValueRef {"}, {"sha": "3aa976dba9aaf89a2a21b203a75d026af72eaef5", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -38,7 +38,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        ref_id: Option<ast::NodeId>) {\n     debug!(\"trans_intrinsic(item.ident={})\", ccx.sess.str_of(item.ident));\n \n-    fn simple_llvm_intrinsic(bcx: @mut Block, name: &'static str, num_args: uint) {\n+    fn simple_llvm_intrinsic(bcx: @Block, name: &'static str, num_args: uint) {\n         assert!(num_args <= 4);\n         let mut args = [0 as ValueRef, ..4];\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n@@ -50,7 +50,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         Ret(bcx, llcall);\n     }\n \n-    fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str, t: ty::t) {\n+    fn with_overflow_instrinsic(bcx: @Block, name: &'static str, t: ty::t) {\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n         let a = get_param(bcx.fcx.llfn, first_real_arg);\n         let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n@@ -73,7 +73,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         }\n     }\n \n-    fn copy_intrinsic(bcx: @mut Block, allow_overlap: bool, tp_ty: ty::t) {\n+    fn copy_intrinsic(bcx: @Block, allow_overlap: bool, tp_ty: ty::t) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n         let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -104,7 +104,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         RetVoid(bcx);\n     }\n \n-    fn memset_intrinsic(bcx: @mut Block, tp_ty: ty::t) {\n+    fn memset_intrinsic(bcx: @Block, tp_ty: ty::t) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n         let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -126,7 +126,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         RetVoid(bcx);\n     }\n \n-    fn count_zeros_intrinsic(bcx: @mut Block, name: &'static str) {\n+    fn count_zeros_intrinsic(bcx: @Block, name: &'static str) {\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n         let y = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);"}, {"sha": "8117d8e0bd567766886ed7a71eed6f1ba5ca3def", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -138,7 +138,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n              []);\n }\n \n-pub fn trans_self_arg(bcx: @mut Block,\n+pub fn trans_self_arg(bcx: @Block,\n                       base: &ast::Expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       mentry: typeck::method_map_entry) -> Result {\n@@ -154,7 +154,7 @@ pub fn trans_self_arg(bcx: @mut Block,\n                    DontAutorefArg)\n }\n \n-pub fn trans_method_callee(bcx: @mut Block,\n+pub fn trans_method_callee(bcx: @Block,\n                            callee_id: ast::NodeId,\n                            this: &ast::Expr,\n                            mentry: typeck::method_map_entry)\n@@ -212,7 +212,7 @@ pub fn trans_method_callee(bcx: @mut Block,\n     }\n }\n \n-pub fn trans_static_method_callee(bcx: @mut Block,\n+pub fn trans_static_method_callee(bcx: @Block,\n                                   method_id: ast::DefId,\n                                   trait_id: ast::DefId,\n                                   callee_id: ast::NodeId)\n@@ -311,7 +311,7 @@ pub fn method_with_name(ccx: &mut CrateContext,\n     meth.def_id\n }\n \n-pub fn trans_monomorphized_callee(bcx: @mut Block,\n+pub fn trans_monomorphized_callee(bcx: @Block,\n                                   callee_id: ast::NodeId,\n                                   base: &ast::Expr,\n                                   mentry: typeck::method_map_entry,\n@@ -368,7 +368,7 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n \n }\n \n-pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n+pub fn combine_impl_and_methods_tps(bcx: @Block,\n                                     mth_did: ast::DefId,\n                                     callee_id: ast::NodeId,\n                                     rcvr_substs: &[ty::t],\n@@ -417,7 +417,7 @@ pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n     return (ty_substs, vtables);\n }\n \n-pub fn trans_trait_callee(bcx: @mut Block,\n+pub fn trans_trait_callee(bcx: @Block,\n                           callee_id: ast::NodeId,\n                           n_method: uint,\n                           self_expr: &ast::Expr)\n@@ -459,7 +459,7 @@ pub fn trans_trait_callee(bcx: @mut Block,\n                                   Some(self_scratch.val))\n }\n \n-pub fn trans_trait_callee_from_llval(bcx: @mut Block,\n+pub fn trans_trait_callee_from_llval(bcx: @Block,\n                                      callee_ty: ty::t,\n                                      n_method: uint,\n                                      llpair: ValueRef,\n@@ -530,7 +530,7 @@ pub fn vtable_id(ccx: @mut CrateContext,\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-pub fn get_vtable(bcx: @mut Block,\n+pub fn get_vtable(bcx: @Block,\n                   self_ty: ty::t,\n                   origins: typeck::vtable_param_res)\n                   -> ValueRef {\n@@ -588,7 +588,7 @@ pub fn make_vtable(ccx: &mut CrateContext,\n     }\n }\n \n-fn emit_vtable_methods(bcx: @mut Block,\n+fn emit_vtable_methods(bcx: @Block,\n                        impl_id: ast::DefId,\n                        substs: &[ty::t],\n                        vtables: typeck::vtable_res)\n@@ -629,12 +629,12 @@ fn emit_vtable_methods(bcx: @mut Block,\n     })\n }\n \n-pub fn trans_trait_cast(bcx: @mut Block,\n+pub fn trans_trait_cast(bcx: @Block,\n                         val: &ast::Expr,\n                         id: ast::NodeId,\n                         dest: expr::Dest,\n                         _store: ty::TraitStore)\n-                     -> @mut Block {\n+                     -> @Block {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"impl::trans_cast\");\n "}, {"sha": "867a4fa87d23239ef2c2d88863219e6944ad4b81", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -37,9 +37,9 @@ use middle::trans::type_::Type;\n pub struct Reflector {\n     visitor_val: ValueRef,\n     visitor_methods: @~[@ty::Method],\n-    final_bcx: @mut Block,\n+    final_bcx: @Block,\n     tydesc_ty: Type,\n-    bcx: @mut Block\n+    bcx: @Block\n }\n \n impl Reflector {\n@@ -382,11 +382,11 @@ impl Reflector {\n }\n \n // Emit a sequence of calls to visit_ty::visit_foo\n-pub fn emit_calls_to_trait_visit_ty(bcx: @mut Block,\n+pub fn emit_calls_to_trait_visit_ty(bcx: @Block,\n                                     t: ty::t,\n                                     visitor_val: ValueRef,\n                                     visitor_trait_id: DefId)\n-                                 -> @mut Block {\n+                                 -> @Block {\n     let final = sub_block(bcx, \"final\");\n     let tydesc_ty = ty::get_tydesc_ty(bcx.ccx().tcx).unwrap();\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);"}, {"sha": "17423c1dd020297b06c33254ee2d1e735fd55d86", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -53,38 +53,38 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn get_fill(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n+pub fn get_fill(bcx: @Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n }\n-pub fn set_fill(bcx: @mut Block, vptr: ValueRef, fill: ValueRef) {\n+pub fn set_fill(bcx: @Block, vptr: ValueRef, fill: ValueRef) {\n     Store(bcx, fill, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]));\n }\n-pub fn get_alloc(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n+pub fn get_alloc(bcx: @Block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n \n-pub fn get_bodyptr(bcx: @mut Block, vptr: ValueRef, t: ty::t) -> ValueRef {\n+pub fn get_bodyptr(bcx: @Block, vptr: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         GEPi(bcx, vptr, [0u, abi::box_field_body])\n     } else {\n         vptr\n     }\n }\n \n-pub fn get_dataptr(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n+pub fn get_dataptr(bcx: @Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n-pub fn pointer_add_byte(bcx: @mut Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n+pub fn pointer_add_byte(bcx: @Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::pointer_add_byte\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, Type::i8p());\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-pub fn alloc_raw(bcx: @mut Block, unit_ty: ty::t,\n+pub fn alloc_raw(bcx: @Block, unit_ty: ty::t,\n                  fill: ValueRef, alloc: ValueRef, heap: heap) -> Result {\n     let _icx = push_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n@@ -107,12 +107,12 @@ pub fn alloc_raw(bcx: @mut Block, unit_ty: ty::t,\n     }\n }\n \n-pub fn alloc_uniq_raw(bcx: @mut Block, unit_ty: ty::t,\n+pub fn alloc_uniq_raw(bcx: @Block, unit_ty: ty::t,\n                       fill: ValueRef, alloc: ValueRef) -> Result {\n     alloc_raw(bcx, unit_ty, fill, alloc, base::heap_for_unique(bcx, unit_ty))\n }\n \n-pub fn alloc_vec(bcx: @mut Block,\n+pub fn alloc_vec(bcx: @Block,\n                  unit_ty: ty::t,\n                  elts: uint,\n                  heap: heap)\n@@ -130,8 +130,8 @@ pub fn alloc_vec(bcx: @mut Block,\n     return rslt(bcx, vptr);\n }\n \n-pub fn make_drop_glue_unboxed(bcx: @mut Block, vptr: ValueRef, vec_ty: ty::t) ->\n-   @mut Block {\n+pub fn make_drop_glue_unboxed(bcx: @Block, vptr: ValueRef, vec_ty: ty::t) ->\n+   @Block {\n     let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx();\n     let unit_ty = ty::sequence_element_type(tcx, vec_ty);\n@@ -160,11 +160,11 @@ impl VecTypes {\n     }\n }\n \n-pub fn trans_fixed_vstore(bcx: @mut Block,\n+pub fn trans_fixed_vstore(bcx: @Block,\n                           vstore_expr: &ast::Expr,\n                           content_expr: &ast::Expr,\n                           dest: expr::Dest)\n-                       -> @mut Block {\n+                       -> @Block {\n     //!\n     //\n     // [...] allocates a fixed-size array and moves it around \"by value\".\n@@ -189,11 +189,11 @@ pub fn trans_fixed_vstore(bcx: @mut Block,\n     };\n }\n \n-pub fn trans_slice_vstore(bcx: @mut Block,\n+pub fn trans_slice_vstore(bcx: @Block,\n                           vstore_expr: &ast::Expr,\n                           content_expr: &ast::Expr,\n                           dest: expr::Dest)\n-                       -> @mut Block {\n+                       -> @Block {\n     //!\n     //\n     // &[...] allocates memory on the stack and writes the values into it,\n@@ -247,11 +247,11 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn trans_lit_str(bcx: @mut Block,\n+pub fn trans_lit_str(bcx: @Block,\n                      lit_expr: &ast::Expr,\n                      str_lit: @str,\n                      dest: Dest)\n-                  -> @mut Block {\n+                  -> @Block {\n     //!\n     //\n     // Literal strings translate to slices into static memory.  This is\n@@ -282,7 +282,7 @@ pub fn trans_lit_str(bcx: @mut Block,\n }\n \n \n-pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &ast::Expr,\n+pub fn trans_uniq_or_managed_vstore(bcx: @Block, heap: heap, vstore_expr: &ast::Expr,\n                                     content_expr: &ast::Expr) -> DatumBlock {\n     //!\n     //\n@@ -343,12 +343,12 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &a\n     return immediate_rvalue_bcx(bcx, val, vt.vec_ty);\n }\n \n-pub fn write_content(bcx: @mut Block,\n+pub fn write_content(bcx: @Block,\n                      vt: &VecTypes,\n                      vstore_expr: &ast::Expr,\n                      content_expr: &ast::Expr,\n                      dest: Dest)\n-                  -> @mut Block {\n+                  -> @Block {\n     let _icx = push_ctxt(\"tvec::write_content\");\n     let mut bcx = bcx;\n \n@@ -433,12 +433,12 @@ pub fn write_content(bcx: @mut Block,\n     }\n }\n \n-pub fn vec_types_from_expr(bcx: @mut Block, vec_expr: &ast::Expr) -> VecTypes {\n+pub fn vec_types_from_expr(bcx: @Block, vec_expr: &ast::Expr) -> VecTypes {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, vec_ty)\n }\n \n-pub fn vec_types(bcx: @mut Block, vec_ty: ty::t) -> VecTypes {\n+pub fn vec_types(bcx: @Block, vec_ty: ty::t) -> VecTypes {\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n@@ -452,7 +452,7 @@ pub fn vec_types(bcx: @mut Block, vec_ty: ty::t) -> VecTypes {\n               llunit_alloc_size: llunit_alloc_size}\n }\n \n-pub fn elements_required(bcx: @mut Block, content_expr: &ast::Expr) -> uint {\n+pub fn elements_required(bcx: @Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n@@ -468,7 +468,7 @@ pub fn elements_required(bcx: @mut Block, content_expr: &ast::Expr) -> uint {\n     }\n }\n \n-pub fn get_base_and_byte_len(bcx: @mut Block, llval: ValueRef,\n+pub fn get_base_and_byte_len(bcx: @Block, llval: ValueRef,\n                         vec_ty: ty::t) -> (ValueRef, ValueRef) {\n     //!\n     //\n@@ -505,7 +505,7 @@ pub fn get_base_and_byte_len(bcx: @mut Block, llval: ValueRef,\n     }\n }\n \n-pub fn get_base_and_len(bcx: @mut Block, llval: ValueRef, vec_ty: ty::t) -> (ValueRef, ValueRef) {\n+pub fn get_base_and_len(bcx: @Block, llval: ValueRef, vec_ty: ty::t) -> (ValueRef, ValueRef) {\n     //!\n     //\n     // Converts a vector into the slice pair.  The vector should be stored in\n@@ -539,15 +539,15 @@ pub fn get_base_and_len(bcx: @mut Block, llval: ValueRef, vec_ty: ty::t) -> (Val\n     }\n }\n \n-pub type iter_vec_block<'a> = 'a |@mut Block, ValueRef, ty::t|\n-                                        -> @mut Block;\n+pub type iter_vec_block<'a> = 'a |@Block, ValueRef, ty::t|\n+                                        -> @Block;\n \n-pub fn iter_vec_loop(bcx: @mut Block,\n+pub fn iter_vec_loop(bcx: @Block,\n                      data_ptr: ValueRef,\n                      vt: &VecTypes,\n                      count: ValueRef,\n                      f: iter_vec_block\n-                     ) -> @mut Block {\n+                     ) -> @Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_loop\");\n \n     let next_bcx = sub_block(bcx, \"iter_vec_loop: while next\");\n@@ -597,8 +597,8 @@ pub fn iter_vec_loop(bcx: @mut Block,\n     next_bcx\n }\n \n-pub fn iter_vec_raw(bcx: @mut Block, data_ptr: ValueRef, vec_ty: ty::t,\n-                    fill: ValueRef, f: iter_vec_block) -> @mut Block {\n+pub fn iter_vec_raw(bcx: @Block, data_ptr: ValueRef, vec_ty: ty::t,\n+                    fill: ValueRef, f: iter_vec_block) -> @Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n \n     let vt = vec_types(bcx, vec_ty);\n@@ -632,15 +632,15 @@ pub fn iter_vec_raw(bcx: @mut Block, data_ptr: ValueRef, vec_ty: ty::t,\n     }\n }\n \n-pub fn iter_vec_uniq(bcx: @mut Block, vptr: ValueRef, vec_ty: ty::t,\n-                     fill: ValueRef, f: iter_vec_block) -> @mut Block {\n+pub fn iter_vec_uniq(bcx: @Block, vptr: ValueRef, vec_ty: ty::t,\n+                     fill: ValueRef, f: iter_vec_block) -> @Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_uniq\");\n     let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr, vec_ty));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n-pub fn iter_vec_unboxed(bcx: @mut Block, body_ptr: ValueRef, vec_ty: ty::t,\n-                        f: iter_vec_block) -> @mut Block {\n+pub fn iter_vec_unboxed(bcx: @Block, body_ptr: ValueRef, vec_ty: ty::t,\n+                        f: iter_vec_block) -> @Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_unboxed\");\n     let fill = get_fill(bcx, body_ptr);\n     let dataptr = get_dataptr(bcx, body_ptr);"}, {"sha": "a184ecda20db45b65b9fbf8cb80e7f7bb2e60c4d", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -17,8 +17,8 @@ use middle::trans::datum::immediate_rvalue;\n use middle::trans::glue;\n use middle::ty;\n \n-pub fn make_free_glue(bcx: @mut Block, vptrptr: ValueRef, box_ty: ty::t)\n-    -> @mut Block {\n+pub fn make_free_glue(bcx: @Block, vptrptr: ValueRef, box_ty: ty::t)\n+    -> @Block {\n     let _icx = push_ctxt(\"uniq::make_free_glue\");\n     let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n "}, {"sha": "14045f8ab744e4c12f10e2f6b378751ec68cf77f", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -49,7 +49,7 @@ impl Value {\n     /// This only performs a search for a trivially dominating store. The store\n     /// must be the only user of this value, and there must not be any conditional\n     /// branches between the store and the given block.\n-    pub fn get_dominating_store(self, bcx: &mut Block) -> Option<Value> {\n+    pub fn get_dominating_store(self, bcx: &Block) -> Option<Value> {\n         match self.get_single_user().and_then(|user| user.as_store_inst()) {\n             Some(store) => {\n                 store.get_parent().and_then(|store_bb| {"}, {"sha": "5c88985ce6f8ba0f263d086c946e55597a6bba97", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9432327c4bacaccbf7602f916f450ab27dbe49e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=c9432327c4bacaccbf7602f916f450ab27dbe49e", "patch": "@@ -34,10 +34,10 @@ use syntax::ast;\n use middle::trans::type_::Type;\n \n pub fn root_and_write_guard(datum: &Datum,\n-                            mut bcx: @mut Block,\n+                            mut bcx: @Block,\n                             span: Span,\n                             expr_id: ast::NodeId,\n-                            derefs: uint) -> @mut Block {\n+                            derefs: uint) -> @Block {\n     let key = root_map_key { id: expr_id, derefs: derefs };\n     debug!(\"write_guard::root_and_write_guard(key={:?})\", key);\n \n@@ -60,12 +60,12 @@ pub fn root_and_write_guard(datum: &Datum,\n     }\n }\n \n-pub fn return_to_mut(mut bcx: @mut Block,\n+pub fn return_to_mut(mut bcx: @Block,\n                      root_key: root_map_key,\n                      frozen_val_ref: ValueRef,\n                      bits_val_ref: ValueRef,\n                      filename_val: ValueRef,\n-                     line_val: ValueRef) -> @mut Block {\n+                     line_val: ValueRef) -> @Block {\n     debug!(\"write_guard::return_to_mut(root_key={:?}, {}, {}, {})\",\n            root_key,\n            bcx.to_str(),\n@@ -102,10 +102,10 @@ pub fn return_to_mut(mut bcx: @mut Block,\n }\n \n fn root(datum: &Datum,\n-        mut bcx: @mut Block,\n+        mut bcx: @Block,\n         span: Span,\n         root_key: root_map_key,\n-        root_info: RootInfo) -> @mut Block {\n+        root_info: RootInfo) -> @Block {\n     //! In some cases, borrowck will decide that an @T/@[]/@str\n     //! value must be rooted for the program to be safe.  In that\n     //! case, we will call this function, which will stash a copy\n@@ -120,7 +120,10 @@ fn root(datum: &Datum,\n     let scratch = scratch_datum(bcx, datum.ty, \"__write_guard\", true);\n     datum.copy_to_datum(bcx, INIT, scratch);\n     let cleanup_bcx = find_bcx_for_scope(bcx, root_info.scope);\n-    add_clean_temp_mem_in_scope(cleanup_bcx, root_info.scope, scratch.val, scratch.ty);\n+    add_clean_temp_mem_in_scope(cleanup_bcx,\n+                                root_info.scope,\n+                                scratch.val,\n+                                scratch.ty);\n \n     // Now, consider also freezing it.\n     match root_info.freeze {\n@@ -165,18 +168,22 @@ fn root(datum: &Datum,\n                     Some(expr::Ignore)).bcx;\n             }\n \n-            add_clean_return_to_mut(\n-                cleanup_bcx, root_info.scope, root_key, scratch.val, scratch_bits.val,\n-                filename, line);\n+            add_clean_return_to_mut(cleanup_bcx,\n+                                    root_info.scope,\n+                                    root_key,\n+                                    scratch.val,\n+                                    scratch_bits.val,\n+                                    filename,\n+                                    line);\n         }\n     }\n \n     bcx\n }\n \n fn perform_write_guard(datum: &Datum,\n-                       bcx: @mut Block,\n-                       span: Span) -> @mut Block {\n+                       bcx: @Block,\n+                       span: Span) -> @Block {\n     debug!(\"perform_write_guard\");\n \n     let llval = datum.to_value_llval(bcx);"}]}