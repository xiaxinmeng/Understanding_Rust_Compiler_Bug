{"sha": "caf018714189db0b15f9f803adfcb4572ab7a988", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZjAxODcxNDE4OWRiMGIxNWY5ZjgwM2FkZmNiNDU3MmFiN2E5ODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-07T00:10:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-07T00:10:52Z"}, "message": "Auto merge of #65750 - nnethercote:cheaper-doc-comments, r=petrochenkov\n\nCheaper doc comments\n\nThis PR implements the idea from #60935: represent doc comments more cheaply, rather than converting them into `#[doc=\"...\"]` attribute form. Unlike #60936 (which is about coalescing doc comments to reduce their number), this approach does not have any backwards compatibility concerns, and it eliminates about 80-90% of the current cost of doc comments (as estimated using the numbers in #60930, which eliminated the cost of doc comments entirely by treating them as normal comments).\n\nr? @petrochenkov", "tree": {"sha": "afeb3f84214024f4ee487367e35c64f7f2ce4771", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afeb3f84214024f4ee487367e35c64f7f2ce4771"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caf018714189db0b15f9f803adfcb4572ab7a988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caf018714189db0b15f9f803adfcb4572ab7a988", "html_url": "https://github.com/rust-lang/rust/commit/caf018714189db0b15f9f803adfcb4572ab7a988", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caf018714189db0b15f9f803adfcb4572ab7a988/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38048763e885a3ee139abf39d59a530b16484150", "url": "https://api.github.com/repos/rust-lang/rust/commits/38048763e885a3ee139abf39d59a530b16484150", "html_url": "https://github.com/rust-lang/rust/commit/38048763e885a3ee139abf39d59a530b16484150"}, {"sha": "eea6f23a0ed67fd8c6b8e1b02cda3628fee56b2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/eea6f23a0ed67fd8c6b8e1b02cda3628fee56b2f", "html_url": "https://github.com/rust-lang/rust/commit/eea6f23a0ed67fd8c6b8e1b02cda3628fee56b2f"}], "stats": {"total": 385, "additions": 234, "deletions": 151}, "files": [{"sha": "230fbb16b87bc2e31a6ee3e10bd6a6e6a71774ed", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -997,14 +997,20 @@ impl<'a> LoweringContext<'a> {\n         // Note that we explicitly do not walk the path. Since we don't really\n         // lower attributes (we use the AST version) there is nowhere to keep\n         // the `HirId`s. We don't actually need HIR version of attributes anyway.\n+        let kind = match attr.kind {\n+            AttrKind::Normal(ref item) => {\n+                AttrKind::Normal(AttrItem {\n+                    path: item.path.clone(),\n+                    tokens: self.lower_token_stream(item.tokens.clone()),\n+                })\n+            }\n+            AttrKind::DocComment(comment) => AttrKind::DocComment(comment)\n+        };\n+\n         Attribute {\n-            item: AttrItem {\n-                path: attr.path.clone(),\n-                tokens: self.lower_token_stream(attr.tokens.clone()),\n-            },\n+            kind,\n             id: attr.id,\n             style: attr.style,\n-            is_sugared_doc: attr.is_sugared_doc,\n             span: attr.span,\n         }\n     }"}, {"sha": "aa147462e3d3bff99bcd4bce38096cce76a00e2e", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -177,7 +177,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n         let filtered: SmallVec<[&ast::Attribute; 8]> = self\n             .iter()\n             .filter(|attr| {\n-                !attr.is_sugared_doc &&\n+                !attr.is_doc_comment() &&\n                 !attr.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name))\n             })\n             .collect();\n@@ -207,19 +207,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         // Make sure that these have been filtered out.\n         debug_assert!(!self.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name)));\n-        debug_assert!(!self.is_sugared_doc);\n-\n-        let ast::Attribute {\n-            ref item,\n-            id: _,\n-            style,\n-            is_sugared_doc: _,\n-            span,\n-        } = *self;\n-\n-        item.hash_stable(hcx, hasher);\n-        style.hash_stable(hcx, hasher);\n-        span.hash_stable(hcx, hasher);\n+        debug_assert!(!self.is_doc_comment());\n+\n+        let ast::Attribute { kind, id: _, style, span } = self;\n+        if let ast::AttrKind::Normal(item) = kind {\n+            item.hash_stable(hcx, hasher);\n+            style.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        } else {\n+            unreachable!();\n+        }\n     }\n }\n "}, {"sha": "d40af615eb181d855ba0267bffba4c91a6a30486", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -706,7 +706,7 @@ impl EarlyLintPass for DeprecatedAttr {\n             }\n         }\n         if attr.check_name(sym::no_start) || attr.check_name(sym::crate_id) {\n-            let path_str = pprust::path_to_string(&attr.path);\n+            let path_str = pprust::path_to_string(&attr.get_normal_item().path);\n             let msg = format!(\"use of deprecated attribute `{}`: no longer used.\", path_str);\n             lint_deprecated_attr(cx, attr, &msg, None);\n         }\n@@ -736,7 +736,7 @@ impl UnusedDocComment {\n         let mut sugared_span: Option<Span> = None;\n \n         while let Some(attr) = attrs.next() {\n-            if attr.is_sugared_doc {\n+            if attr.is_doc_comment() {\n                 sugared_span = Some(\n                     sugared_span.map_or_else(\n                         || attr.span,\n@@ -745,7 +745,7 @@ impl UnusedDocComment {\n                 );\n             }\n \n-            if attrs.peek().map(|next_attr| next_attr.is_sugared_doc).unwrap_or_default() {\n+            if attrs.peek().map(|next_attr| next_attr.is_doc_comment()).unwrap_or_default() {\n                 continue;\n             }\n "}, {"sha": "b40d58a681976c8cbfa5fb888840c3aef07c05a9", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -11,7 +11,7 @@ crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n     for attr in tcx.hir().krate().attrs.iter() {\n-        if attr.path == sym::link_args {\n+        if attr.has_name(sym::link_args) {\n             if let Some(linkarg) = attr.value_str() {\n                 collector.add_link_args(&linkarg.as_str());\n             }"}, {"sha": "d1a801b3006d78b8b70ad3b82ad26622bab435e9", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -328,7 +328,7 @@ impl<'a> AstValidator<'a> {\n                 let arr = [sym::allow, sym::cfg, sym::cfg_attr, sym::deny, sym::forbid, sym::warn];\n                 !arr.contains(&attr.name_or_empty()) && is_builtin_attr(attr)\n             })\n-            .for_each(|attr| if attr.is_sugared_doc {\n+            .for_each(|attr| if attr.is_doc_comment() {\n                 let mut err = self.err_handler().struct_span_err(\n                     attr.span,\n                     \"documentation comments cannot be applied to function parameters\""}, {"sha": "55f054d0be323a2bf30d0dedd7cdd45a525583d2", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -1229,8 +1229,10 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_attribute(&mut self, attr: &'b ast::Attribute) {\n-        if !attr.is_sugared_doc && is_builtin_attr(attr) {\n-            self.r.builtin_attrs.push((attr.path.segments[0].ident, self.parent_scope));\n+        if !attr.is_doc_comment() && is_builtin_attr(attr) {\n+            self.r.builtin_attrs.push(\n+                (attr.get_normal_item().path.segments[0].ident, self.parent_scope)\n+            );\n         }\n         visit::walk_attribute(self, attr);\n     }"}, {"sha": "3d5a7f26eda55f163fd7365cb5a6b5c4728d0acf", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -179,7 +179,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         let (path, kind, derives, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n-                (&attr.path, MacroKind::Attr, self.arenas.alloc_ast_paths(derives), after_derive),\n+                (&attr.get_normal_item().path,\n+                 MacroKind::Attr,\n+                 self.arenas.alloc_ast_paths(derives),\n+                 after_derive),\n             InvocationKind::Bang { ref mac, .. } =>\n                 (&mac.path, MacroKind::Bang, &[][..], false),\n             InvocationKind::Derive { ref path, .. } =>"}, {"sha": "9408bbe557a21a1093b2e7bbf4b236cd6cf1f922", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -885,7 +885,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         for attr in attrs {\n             if attr.check_name(sym::doc) {\n                 if let Some(val) = attr.value_str() {\n-                    if attr.is_sugared_doc {\n+                    if attr.is_doc_comment() {\n                         result.push_str(&strip_doc_comment_decoration(&val.as_str()));\n                     } else {\n                         result.push_str(&val.as_str());\n@@ -1195,7 +1195,7 @@ fn null_id() -> rls_data::Id {\n fn lower_attributes(attrs: Vec<Attribute>, scx: &SaveContext<'_, '_>) -> Vec<rls_data::Attribute> {\n     attrs.into_iter()\n     // Only retain real attributes. Doc comments are lowered separately.\n-    .filter(|attr| attr.path != sym::doc)\n+    .filter(|attr| !attr.has_name(sym::doc))\n     .map(|mut attr| {\n         // Remove the surrounding '#[..]' or '#![..]' of the pretty printed\n         // attribute. First normalize all inner attribute (#![..]) to outer"}, {"sha": "71a7b52a27ba9d912885c868a24bcecf785ea1e2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -2706,7 +2706,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     }\n \n     codegen_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        if attr.path != sym::inline {\n+        if !attr.has_name(sym::inline) {\n             return ia;\n         }\n         match attr.meta().map(|i| i.kind) {\n@@ -2746,7 +2746,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     });\n \n     codegen_fn_attrs.optimize = attrs.iter().fold(OptimizeAttr::None, |ia, attr| {\n-        if attr.path != sym::optimize {\n+        if !attr.has_name(sym::optimize) {\n             return ia;\n         }\n         let err = |sp, s| span_err!(tcx.sess.diagnostic(), sp, E0722, \"{}\", s);"}, {"sha": "32c8ca234a0c3817e0fa9aaa8b17cec6f3e32019", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -26,7 +26,7 @@ use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n use rustc::ty::layout::VariantIdx;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use syntax::ast::{self, Attribute, AttrStyle, AttrItem, Ident};\n+use syntax::ast::{self, Attribute, AttrStyle, AttrKind, Ident};\n use syntax::attr;\n use syntax::parse::lexer::comments;\n use syntax::source_map::DUMMY_SP;\n@@ -859,31 +859,32 @@ impl Attributes {\n         let mut cfg = Cfg::True;\n         let mut doc_line = 0;\n \n-        /// Converts `attr` to a normal `#[doc=\"foo\"]` comment, if it is a\n-        /// comment like `///` or `/** */`. (Returns `attr` unchanged for\n-        /// non-sugared doc attributes.)\n-        pub fn with_desugared_doc<T>(attr: &Attribute, f: impl FnOnce(&Attribute) -> T) -> T {\n-            if attr.is_sugared_doc {\n-                let comment = attr.value_str().unwrap();\n-                let meta = attr::mk_name_value_item_str(\n-                    Ident::with_dummy_span(sym::doc),\n-                    Symbol::intern(&comments::strip_doc_comment_decoration(&comment.as_str())),\n-                    DUMMY_SP,\n-                );\n-                f(&Attribute {\n-                    item: AttrItem { path: meta.path, tokens: meta.kind.tokens(meta.span) },\n-                    id: attr.id,\n-                    style: attr.style,\n-                    is_sugared_doc: true,\n-                    span: attr.span,\n-                })\n-            } else {\n-                f(attr)\n+        /// If `attr` is a doc comment, strips the leading and (if present)\n+        /// trailing comments symbols, e.g. `///`, `/**`, and `*/`. Otherwise,\n+        /// returns `attr` unchanged.\n+        pub fn with_doc_comment_markers_stripped<T>(\n+            attr: &Attribute,\n+            f: impl FnOnce(&Attribute) -> T\n+        ) -> T {\n+            match attr.kind {\n+                AttrKind::Normal(_) => {\n+                    f(attr)\n+                }\n+                AttrKind::DocComment(comment) => {\n+                    let comment =\n+                        Symbol::intern(&comments::strip_doc_comment_decoration(&comment.as_str()));\n+                    f(&Attribute {\n+                        kind: AttrKind::DocComment(comment),\n+                        id: attr.id,\n+                        style: attr.style,\n+                        span: attr.span,\n+                    })\n+                }\n             }\n         }\n \n         let other_attrs = attrs.iter().filter_map(|attr| {\n-            with_desugared_doc(attr, |attr| {\n+            with_doc_comment_markers_stripped(attr, |attr| {\n                 if attr.check_name(sym::doc) {\n                     if let Some(mi) = attr.meta() {\n                         if let Some(value) = mi.value_str() {\n@@ -892,7 +893,7 @@ impl Attributes {\n                             let line = doc_line;\n                             doc_line += value.lines().count();\n \n-                            if attr.is_sugared_doc {\n+                            if attr.is_doc_comment() {\n                                 doc_strings.push(DocFragment::SugaredDoc(line, attr.span, value));\n                             } else {\n                                 doc_strings.push(DocFragment::RawDoc(line, attr.span, value));"}, {"sha": "2392b809150d419b3ad293885d8f3ecf8e370562", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -2190,22 +2190,29 @@ pub struct AttrItem {\n }\n \n /// Metadata associated with an item.\n-/// Doc-comments are promoted to attributes that have `is_sugared_doc = true`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Attribute {\n-    pub item: AttrItem,\n+    pub kind: AttrKind,\n     pub id: AttrId,\n     /// Denotes if the attribute decorates the following construct (outer)\n     /// or the construct this attribute is contained within (inner).\n     pub style: AttrStyle,\n-    pub is_sugared_doc: bool,\n     pub span: Span,\n }\n \n-// Compatibility impl to avoid churn, consider removing.\n-impl std::ops::Deref for Attribute {\n-    type Target = AttrItem;\n-    fn deref(&self) -> &Self::Target { &self.item }\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum AttrKind {\n+    /// A normal attribute.\n+    Normal(AttrItem),\n+\n+    /// A doc comment (e.g. `/// ...`, `//! ...`, `/** ... */`, `/*! ... */`).\n+    /// Doc attributes (e.g. `#[doc=\"...\"]`) are represented with the `Normal`\n+    /// variant (which is much less compact and thus more expensive).\n+    ///\n+    /// Note: `self.has_name(sym::doc)` and `self.check_name(sym::doc)` succeed\n+    /// for this variant, but this may change in the future.\n+    /// ```\n+    DocComment(Symbol),\n }\n \n /// `TraitRef`s appear in impls."}, {"sha": "787d69f5e9964feb097be41de183e0354d7e6d60", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -228,18 +228,18 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n             sym::stable,\n             sym::rustc_promotable,\n             sym::rustc_allow_const_fn_ptr,\n-        ].iter().any(|&s| attr.path == s) {\n+        ].iter().any(|&s| attr.has_name(s)) {\n             continue // not a stability level\n         }\n \n         mark_used(attr);\n \n         let meta = attr.meta();\n \n-        if attr.path == sym::rustc_promotable {\n+        if attr.has_name(sym::rustc_promotable) {\n             promotable = true;\n         }\n-        if attr.path == sym::rustc_allow_const_fn_ptr {\n+        if attr.has_name(sym::rustc_allow_const_fn_ptr) {\n             allow_const_fn_ptr = true;\n         }\n         // attributes with data\n@@ -778,7 +778,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n \n     let mut acc = Vec::new();\n     let diagnostic = &sess.span_diagnostic;\n-    if attr.path == sym::repr {\n+    if attr.has_name(sym::repr) {\n         if let Some(items) = attr.meta_item_list() {\n             mark_used(attr);\n             for item in items {"}, {"sha": "c663995eb8fcbc218019dea09dd3efaf2d6984f0", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 79, "deletions": 31, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -9,7 +9,7 @@ pub use StabilityLevel::*;\n pub use crate::ast::Attribute;\n \n use crate::ast;\n-use crate::ast::{AttrItem, AttrId, AttrStyle, Name, Ident, Path, PathSegment};\n+use crate::ast::{AttrItem, AttrId, AttrKind, AttrStyle, Name, Ident, Path, PathSegment};\n use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n@@ -145,12 +145,17 @@ impl NestedMetaItem {\n }\n \n impl Attribute {\n+    pub fn has_name(&self, name: Symbol) -> bool {\n+        match self.kind {\n+            AttrKind::Normal(ref item) => item.path == name,\n+            AttrKind::DocComment(_) => name == sym::doc,\n+        }\n+    }\n+\n     /// Returns `true` if the attribute's path matches the argument. If it matches, then the\n     /// attribute is marked as used.\n-    ///\n-    /// To check the attribute name without marking it used, use the `path` field directly.\n     pub fn check_name(&self, name: Symbol) -> bool {\n-        let matches = self.path == name;\n+        let matches = self.has_name(name);\n         if matches {\n             mark_used(self);\n         }\n@@ -159,29 +164,48 @@ impl Attribute {\n \n     /// For a single-segment attribute, returns its name; otherwise, returns `None`.\n     pub fn ident(&self) -> Option<Ident> {\n-        if self.path.segments.len() == 1 {\n-            Some(self.path.segments[0].ident)\n-        } else {\n-            None\n+        match self.kind {\n+            AttrKind::Normal(ref item) => {\n+                if item.path.segments.len() == 1 {\n+                    Some(item.path.segments[0].ident)\n+                } else {\n+                    None\n+                }\n+            }\n+            AttrKind::DocComment(_) => Some(Ident::new(sym::doc, self.span)),\n         }\n     }\n     pub fn name_or_empty(&self) -> Symbol {\n         self.ident().unwrap_or(Ident::invalid()).name\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n-        self.meta().and_then(|meta| meta.value_str())\n+        match self.kind {\n+            AttrKind::Normal(ref item) => {\n+                item.meta(self.span).and_then(|meta| meta.value_str())\n+            }\n+            AttrKind::DocComment(comment) => Some(comment),\n+        }\n     }\n \n     pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n-        match self.meta() {\n-            Some(MetaItem { kind: MetaItemKind::List(list), .. }) => Some(list),\n-            _ => None\n+        match self.kind {\n+            AttrKind::Normal(ref item) => {\n+                match item.meta(self.span) {\n+                    Some(MetaItem { kind: MetaItemKind::List(list), .. }) => Some(list),\n+                    _ => None\n+                }\n+            }\n+            AttrKind::DocComment(_) => None,\n         }\n     }\n \n     pub fn is_word(&self) -> bool {\n-        self.tokens.is_empty()\n+        if let AttrKind::Normal(item) = &self.kind {\n+            item.tokens.is_empty()\n+        } else {\n+            false\n+        }\n     }\n \n     pub fn is_meta_item_list(&self) -> bool {\n@@ -275,17 +299,49 @@ impl AttrItem {\n }\n \n impl Attribute {\n+    pub fn is_doc_comment(&self) -> bool {\n+        match self.kind {\n+            AttrKind::Normal(_) => false,\n+            AttrKind::DocComment(_) => true,\n+        }\n+    }\n+\n+    pub fn get_normal_item(&self) -> &AttrItem {\n+        match self.kind {\n+            AttrKind::Normal(ref item) => item,\n+            AttrKind::DocComment(_) => panic!(\"unexpected sugared doc\"),\n+        }\n+    }\n+\n+    pub fn unwrap_normal_item(self) -> AttrItem {\n+        match self.kind {\n+            AttrKind::Normal(item) => item,\n+            AttrKind::DocComment(_) => panic!(\"unexpected sugared doc\"),\n+        }\n+    }\n+\n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n-        self.item.meta(self.span)\n+        match self.kind {\n+            AttrKind::Normal(ref item) => item.meta(self.span),\n+            AttrKind::DocComment(comment) =>\n+                Some(mk_name_value_item_str(Ident::new(sym::doc, self.span), comment, self.span)),\n+        }\n     }\n \n     pub fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> {\n-        Ok(MetaItem {\n-            path: self.path.clone(),\n-            kind: parse::parse_in_attr(sess, self, |p| p.parse_meta_item_kind())?,\n-            span: self.span,\n-        })\n+        match self.kind {\n+            AttrKind::Normal(ref item) => {\n+                Ok(MetaItem {\n+                    path: item.path.clone(),\n+                    kind: parse::parse_in_attr(sess, self, |parser| parser.parse_meta_item_kind())?,\n+                    span: self.span,\n+                })\n+            }\n+            AttrKind::DocComment(comment) => {\n+                Ok(mk_name_value_item_str(Ident::new(sym::doc, self.span), comment, self.span))\n+            }\n+        }\n     }\n }\n \n@@ -327,10 +383,9 @@ crate fn mk_attr_id() -> AttrId {\n \n pub fn mk_attr(style: AttrStyle, path: Path, tokens: TokenStream, span: Span) -> Attribute {\n     Attribute {\n-        item: AttrItem { path, tokens },\n+        kind: AttrKind::Normal(AttrItem { path, tokens }),\n         id: mk_attr_id(),\n         style,\n-        is_sugared_doc: false,\n         span,\n     }\n }\n@@ -345,18 +400,11 @@ pub fn mk_attr_outer(item: MetaItem) -> Attribute {\n     mk_attr(AttrStyle::Outer, item.path, item.kind.tokens(item.span), item.span)\n }\n \n-pub fn mk_sugared_doc_attr(text: Symbol, span: Span) -> Attribute {\n-    let style = doc_comment_style(&text.as_str());\n-    let lit_kind = LitKind::Str(text, ast::StrStyle::Cooked);\n-    let lit = Lit::from_lit_kind(lit_kind, span);\n+pub fn mk_doc_comment(comment: Symbol, span: Span) -> Attribute {\n     Attribute {\n-        item: AttrItem {\n-            path: Path::from_ident(Ident::with_dummy_span(sym::doc).with_span_pos(span)),\n-            tokens: MetaItemKind::NameValue(lit).tokens(span),\n-        },\n+        kind: AttrKind::DocComment(comment),\n         id: mk_attr_id(),\n-        style,\n-        is_sugared_doc: true,\n+        style: doc_comment_style(&comment.as_str()),\n         span,\n     }\n }"}, {"sha": "5f89ed36e2a7d1def6719aab664ba6298b6eb55e", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -93,10 +93,10 @@ impl<'a> StripUnconfigured<'a> {\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n     fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Vec<ast::Attribute> {\n-        if attr.path != sym::cfg_attr {\n+        if !attr.has_name(sym::cfg_attr) {\n             return vec![attr];\n         }\n-        if attr.tokens.is_empty() {\n+        if attr.get_normal_item().tokens.is_empty() {\n             self.sess.span_diagnostic\n                 .struct_span_err(\n                     attr.span,\n@@ -136,10 +136,9 @@ impl<'a> StripUnconfigured<'a> {\n             //  `#[cfg_attr(false, cfg_attr(true, some_attr))]`.\n             expanded_attrs.into_iter()\n             .flat_map(|(item, span)| self.process_cfg_attr(ast::Attribute {\n-                item,\n+                kind: ast::AttrKind::Normal(item),\n                 id: attr::mk_attr_id(),\n                 style: attr.style,\n-                is_sugared_doc: false,\n                 span,\n             }))\n             .collect()\n@@ -212,7 +211,7 @@ impl<'a> StripUnconfigured<'a> {\n                                       GateIssue::Language,\n                                       EXPLAIN_STMT_ATTR_SYNTAX);\n \n-            if attr.is_sugared_doc {\n+            if attr.is_doc_comment() {\n                 err.help(\"`///` is for documentation comments. For a plain comment, use `//`.\");\n             }\n "}, {"sha": "b7e75ff3a7e38d376a45980e34016a59f359e8a8", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -329,7 +329,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n             Some((name, _, template, _)) if name != sym::rustc_dummy =>\n                 check_builtin_attribute(self.parse_sess, attr, name, template),\n-            _ => if let Some(TokenTree::Token(token)) = attr.tokens.trees().next() {\n+            _ => if let Some(TokenTree::Token(token)) =\n+                    attr.get_normal_item().tokens.trees().next() {\n                 if token == token::Eq {\n                     // All key-value attributes are restricted to meta-item syntax.\n                     attr.parse_meta(self.parse_sess).map_err(|mut err| err.emit()).ok();"}, {"sha": "7261601e1449137639ec1f777ee5cd0ea025e14a", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -550,10 +550,14 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n-    let Attribute { item: AttrItem { path, tokens }, id: _, style: _, is_sugared_doc: _, span }\n-        = attr;\n-    vis.visit_path(path);\n-    vis.visit_tts(tokens);\n+    let Attribute { kind, id: _, style: _, span } = attr;\n+    match kind {\n+        AttrKind::Normal(AttrItem { path, tokens }) => {\n+            vis.visit_path(path);\n+            vis.visit_tts(tokens);\n+        }\n+        AttrKind::DocComment(_) => {}\n+    }\n     vis.visit_span(span);\n }\n "}, {"sha": "b688dce87c13859e9acfe0340b635c5f51b6e9cd", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -287,7 +287,7 @@ pub fn parse_in_attr<'a, T>(\n ) -> PResult<'a, T> {\n     let mut parser = Parser::new(\n         sess,\n-        attr.tokens.clone(),\n+        attr.get_normal_item().tokens.clone(),\n         None,\n         false,\n         false,\n@@ -393,18 +393,22 @@ fn prepend_attrs(\n \n         let source = pprust::attribute_to_string(attr);\n         let macro_filename = FileName::macro_expansion_source_code(&source);\n-        if attr.is_sugared_doc {\n-            let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));\n-            builder.push(stream);\n-            continue\n-        }\n+\n+        let item = match attr.kind {\n+            ast::AttrKind::Normal(ref item) => item,\n+            ast::AttrKind::DocComment(_) => {\n+                let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));\n+                builder.push(stream);\n+                continue\n+            }\n+        };\n \n         // synthesize # [ $path $tokens ] manually here\n         let mut brackets = tokenstream::TokenStreamBuilder::new();\n \n         // For simple paths, push the identifier directly\n-        if attr.path.segments.len() == 1 && attr.path.segments[0].args.is_none() {\n-            let ident = attr.path.segments[0].ident;\n+        if item.path.segments.len() == 1 && item.path.segments[0].args.is_none() {\n+            let ident = item.path.segments[0].ident;\n             let token = token::Ident(ident.name, ident.as_str().starts_with(\"r#\"));\n             brackets.push(tokenstream::TokenTree::token(token, ident.span));\n \n@@ -415,7 +419,7 @@ fn prepend_attrs(\n             brackets.push(stream);\n         }\n \n-        brackets.push(attr.tokens.clone());\n+        brackets.push(item.tokens.clone());\n \n         // The span we list here for `#` and for `[ ... ]` are both wrong in\n         // that it encompasses more than each token, but it hopefully is \"good"}, {"sha": "1c292661f24401faca9b21f7e2cc48242c27077c", "filename": "src/libsyntax/parse/parser/attr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fparse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fparse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fattr.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -43,7 +43,7 @@ impl<'a> Parser<'a> {\n                     just_parsed_doc_comment = false;\n                 }\n                 token::DocComment(s) => {\n-                    let attr = attr::mk_sugared_doc_attr(s, self.token.span);\n+                    let attr = attr::mk_doc_comment(s, self.token.span);\n                     if attr.style != ast::AttrStyle::Outer {\n                         let mut err = self.fatal(\"expected outer doc comment\");\n                         err.note(\"inner doc comments like this (starting with \\\n@@ -150,10 +150,9 @@ impl<'a> Parser<'a> {\n         };\n \n         Ok(ast::Attribute {\n-            item,\n+            kind: ast::AttrKind::Normal(item),\n             id: attr::mk_attr_id(),\n             style,\n-            is_sugared_doc: false,\n             span,\n         })\n     }\n@@ -229,7 +228,7 @@ impl<'a> Parser<'a> {\n                 }\n                 token::DocComment(s) => {\n                     // We need to get the position of this token before we bump.\n-                    let attr = attr::mk_sugared_doc_attr(s, self.token.span);\n+                    let attr = attr::mk_doc_comment(s, self.token.span);\n                     if attr.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n                         self.bump();"}, {"sha": "cc6235c6fc77242d4e60718c93b75a93daa4f03c", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -3,8 +3,8 @@ use super::diagnostics::{Error, dummy_arg, ConsumeClosingDelim};\n \n use crate::maybe_whole;\n use crate::ptr::P;\n-use crate::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrStyle, AnonConst, Item, ItemKind};\n-use crate::ast::{ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n+use crate::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n+use crate::ast::{ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n use crate::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness};\n use crate::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n use crate::ast::{Ty, TyKind, Generics, GenericBounds, TraitRef, EnumDef, VariantData, StructField};\n@@ -483,12 +483,14 @@ impl<'a> Parser<'a> {\n     /// Emits an expected-item-after-attributes error.\n     fn expected_item_err(&mut self, attrs: &[Attribute]) -> PResult<'a,  ()> {\n         let message = match attrs.last() {\n-            Some(&Attribute { is_sugared_doc: true, .. }) => \"expected item after doc comment\",\n-            _ => \"expected item after attributes\",\n+            Some(&Attribute { kind: AttrKind::DocComment(_), .. }) =>\n+                \"expected item after doc comment\",\n+            _ =>\n+                \"expected item after attributes\",\n         };\n \n         let mut err = self.diagnostic().struct_span_err(self.prev_span, message);\n-        if attrs.last().unwrap().is_sugared_doc {\n+        if attrs.last().unwrap().is_doc_comment() {\n             err.span_label(self.prev_span, \"this doc comment doesn't document anything\");\n         }\n         Err(err)"}, {"sha": "169eb954efadf600f12356b9d9aab5ed553030d2", "filename": "src/libsyntax/parse/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftests.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -246,7 +246,7 @@ let mut fflags: c_int = wb();\n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name_2, source, &sess)\n             .unwrap().unwrap();\n-        let docs = item.attrs.iter().filter(|a| a.path == sym::doc)\n+        let docs = item.attrs.iter().filter(|a| a.has_name(sym::doc))\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[..], b);"}, {"sha": "c8afe8a1ff459d6c6877ce26e5694e2afd2b5c6a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -622,16 +622,19 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             self.hardbreak_if_not_bol();\n         }\n         self.maybe_print_comment(attr.span.lo());\n-        if attr.is_sugared_doc {\n-            self.word(attr.value_str().unwrap().to_string());\n-            self.hardbreak()\n-        } else {\n-            match attr.style {\n-                ast::AttrStyle::Inner => self.word(\"#![\"),\n-                ast::AttrStyle::Outer => self.word(\"#[\"),\n+        match attr.kind {\n+            ast::AttrKind::Normal(ref item) => {\n+                match attr.style {\n+                    ast::AttrStyle::Inner => self.word(\"#![\"),\n+                    ast::AttrStyle::Outer => self.word(\"#[\"),\n+                }\n+                self.print_attr_item(&item, attr.span);\n+                self.word(\"]\");\n+            }\n+            ast::AttrKind::DocComment(comment) => {\n+                self.word(comment.to_string());\n+                self.hardbreak()\n             }\n-            self.print_attr_item(&attr.item, attr.span);\n-            self.word(\"]\");\n         }\n     }\n "}, {"sha": "117787d08c7503e3cef3de043345d727d0c10d14", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -846,7 +846,10 @@ pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n }\n \n pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n-    visitor.visit_tts(attr.tokens.clone());\n+    match attr.kind {\n+        AttrKind::Normal(ref item) => visitor.visit_tts(item.tokens.clone()),\n+        AttrKind::DocComment(_) => {}\n+    }\n }\n \n pub fn walk_tt<'a, V: Visitor<'a>>(visitor: &mut V, tt: TokenTree) {"}, {"sha": "7dbc7787010061592a7dc7ad344c4ce7306716e5", "filename": "src/libsyntax_expand/expand.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fexpand.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -419,7 +419,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     }\n \n                     let mut item = self.fully_configure(item);\n-                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n+                    item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n                     let mut helper_attrs = Vec::new();\n                     let mut has_copy = false;\n                     for ext in exts {\n@@ -634,9 +634,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         | Annotatable::Variant(..)\n                             => panic!(\"unexpected annotatable\"),\n                     })), DUMMY_SP).into();\n-                    let input = self.extract_proc_macro_attr_input(attr.item.tokens, span);\n+                    let item = attr.unwrap_normal_item();\n+                    let input = self.extract_proc_macro_attr_input(item.tokens, span);\n                     let tok_result = expander.expand(self.cx, span, input, item_tok);\n-                    self.parse_ast_fragment(tok_result, fragment_kind, &attr.item.path, span)\n+                    self.parse_ast_fragment(tok_result, fragment_kind, &item.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n                     match attr.parse_meta(self.cx.parse_sess) {\n@@ -974,15 +975,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                        -> Option<ast::Attribute> {\n         let attr = attrs.iter()\n                         .position(|a| {\n-                            if a.path == sym::derive {\n+                            if a.has_name(sym::derive) {\n                                 *after_derive = true;\n                             }\n                             !attr::is_known(a) && !is_builtin_attr(a)\n                         })\n                         .map(|i| attrs.remove(i));\n         if let Some(attr) = &attr {\n             if !self.cx.ecfg.custom_inner_attributes() &&\n-               attr.style == ast::AttrStyle::Inner && attr.path != sym::test {\n+               attr.style == ast::AttrStyle::Inner && !attr.has_name(sym::test) {\n                 emit_feature_err(&self.cx.parse_sess, sym::custom_inner_attributes,\n                                  attr.span, GateIssue::Language,\n                                  \"non-builtin inner attributes are unstable\");\n@@ -1032,7 +1033,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             feature_gate::check_attribute(attr, self.cx.parse_sess, features);\n \n             // macros are expanded before any lint passes so this warning has to be hardcoded\n-            if attr.path == sym::derive {\n+            if attr.has_name(sym::derive) {\n                 self.cx.struct_span_warn(attr.span, \"`#[derive]` does nothing on macro invocations\")\n                     .note(\"this may become a hard error in a future release\")\n                     .emit();\n@@ -1547,11 +1548,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n \n             let meta = attr::mk_list_item(Ident::with_dummy_span(sym::doc), items);\n             *at = attr::Attribute {\n-                item: AttrItem { path: meta.path, tokens: meta.kind.tokens(meta.span) },\n+                kind: ast::AttrKind::Normal(\n+                    AttrItem { path: meta.path, tokens: meta.kind.tokens(meta.span) },\n+                ),\n                 span: at.span,\n                 id: at.id,\n                 style: at.style,\n-                is_sugared_doc: false,\n             };\n         } else {\n             noop_visit_attribute(at, self)"}, {"sha": "1f4c481e3ea04d9157c144cbf1833c2f197b8239", "filename": "src/libsyntax_expand/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fproc_macro.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -181,7 +181,7 @@ impl<'a> Visitor<'a> for MarkAttrs<'a> {\n crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n     let mut result = Vec::new();\n     attrs.retain(|attr| {\n-        if attr.path != sym::derive {\n+        if !attr.has_name(sym::derive) {\n             return true;\n         }\n         if !attr.is_meta_item_list() {\n@@ -196,7 +196,7 @@ crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>)\n         }\n \n         let parse_derive_paths = |attr: &ast::Attribute| {\n-            if attr.tokens.is_empty() {\n+            if attr.get_normal_item().tokens.is_empty() {\n                 return Ok(Vec::new());\n             }\n             parse::parse_in_attr(cx.parse_sess, attr, |p| p.parse_derive_paths())"}, {"sha": "792c97d8508fe4a8418e68c73b72bb368d4cba12", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -249,9 +249,11 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         for attr in &item.attrs {\n             if is_proc_macro_attr(&attr) {\n                 if let Some(prev_attr) = found_attr {\n-                    let path_str = pprust::path_to_string(&attr.path);\n-                    let msg = if attr.path.segments[0].ident.name ==\n-                                 prev_attr.path.segments[0].ident.name {\n+                    let prev_item = prev_attr.get_normal_item();\n+                    let item = attr.get_normal_item();\n+                    let path_str = pprust::path_to_string(&item.path);\n+                    let msg = if item.path.segments[0].ident.name ==\n+                                 prev_item.path.segments[0].ident.name {\n                         format!(\n                             \"only one `#[{}]` attribute is allowed on any given function\",\n                             path_str,\n@@ -261,7 +263,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n                             \"`#[{}]` and `#[{}]` attributes cannot both be applied\n                             to the same function\",\n                             path_str,\n-                            pprust::path_to_string(&prev_attr.path),\n+                            pprust::path_to_string(&prev_item.path),\n                         )\n                     };\n \n@@ -290,7 +292,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         if !is_fn {\n             let msg = format!(\n                 \"the `#[{}]` attribute may only be used on bare functions\",\n-                pprust::path_to_string(&attr.path),\n+                pprust::path_to_string(&attr.get_normal_item().path),\n             );\n \n             self.handler.span_err(attr.span, &msg);\n@@ -304,7 +306,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         if !self.is_proc_macro_crate {\n             let msg = format!(\n                 \"the `#[{}]` attribute is only usable with crates of the `proc-macro` crate type\",\n-                pprust::path_to_string(&attr.path),\n+                pprust::path_to_string(&attr.get_normal_item().path),\n             );\n \n             self.handler.span_err(attr.span, &msg);"}]}