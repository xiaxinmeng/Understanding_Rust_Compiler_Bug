{"sha": "c2d4c1116f96463b8af222365d61d05bc42a78ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZDRjMTExNmY5NjQ2M2I4YWYyMjIzNjVkNjFkMDViYzQyYTc4YWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-06-30T02:53:24Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-06-30T02:56:04Z"}, "message": "Teach the typechecker about the auto-dereference and auto-promote-to-mutable semantics we're going with", "tree": {"sha": "0074e7565500bd7d84607249b44f83faf1bab1fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0074e7565500bd7d84607249b44f83faf1bab1fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2d4c1116f96463b8af222365d61d05bc42a78ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d4c1116f96463b8af222365d61d05bc42a78ac", "html_url": "https://github.com/rust-lang/rust/commit/c2d4c1116f96463b8af222365d61d05bc42a78ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2d4c1116f96463b8af222365d61d05bc42a78ac/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f05fc6b9d7dd6bb3de2c873d80b22d0e4ac65df4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f05fc6b9d7dd6bb3de2c873d80b22d0e4ac65df4", "html_url": "https://github.com/rust-lang/rust/commit/f05fc6b9d7dd6bb3de2c873d80b22d0e4ac65df4"}], "stats": {"total": 437, "additions": 213, "deletions": 224}, "files": [{"sha": "1903ecbd6a3bd4471153a43d7adf53a8493c33d0", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2d4c1116f96463b8af222365d61d05bc42a78ac/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c2d4c1116f96463b8af222365d61d05bc42a78ac/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=c2d4c1116f96463b8af222365d61d05bc42a78ac", "patch": "@@ -3131,7 +3131,6 @@ let trans_visitor\n       (src:Il.cell) (src_ty:Ast.ty)\n       : unit =\n     let dst_ty = slot_ty dst_slot in\n-    assert (src_ty = dst_ty);\n     match (dst_slot.Ast.slot_mode, clone) with\n         (Ast.MODE_alias, CLONE_none) ->\n           mov dst (Il.Cell (alias (Il.Mem (need_mem_cell src))))"}, {"sha": "e852965dc2ce8927aca1ef4d56ae0982a97ec231", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 213, "deletions": 223, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/c2d4c1116f96463b8af222365d61d05bc42a78ac/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c2d4c1116f96463b8af222365d61d05bc42a78ac/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=c2d4c1116f96463b8af222365d61d05bc42a78ac", "patch": "@@ -2,27 +2,23 @@ open Common;;\n open Semant;;\n \n type tyspec =\n-    TYSPEC_equiv of (simpl * tyvar)\n+    TYSPEC_equiv of tyvar\n   | TYSPEC_all\n   | TYSPEC_resolved of (Ast.ty_param array) * Ast.ty\n-  | TYSPEC_callable of (tyvar * tyvar array)   (* out, ins *)\n-  | TYSPEC_collection of tyvar                 (* vec or str *)\n-  | TYSPEC_comparable                          (* comparable with = and != *)\n-  | TYSPEC_plusable                            (* nums, vecs, and strings *)\n+  | TYSPEC_callable of (tyvar * tyvar array)  (* out, ins *)\n+  | TYSPEC_collection of tyvar                (* vec or str *)\n+  | TYSPEC_comparable                         (* comparable with = and != *)\n+  | TYSPEC_plusable                           (* nums, vecs, and strings *)\n   | TYSPEC_dictionary of dict\n-  | TYSPEC_integral                            (* int-like *)\n+  | TYSPEC_integral                           (* int-like *)\n   | TYSPEC_loggable\n-  | TYSPEC_numeric                             (* int-like or float-like *)\n-  | TYSPEC_ordered                             (* comparable with < etc. *)\n+  | TYSPEC_numeric                            (* int-like or float-like *)\n+  | TYSPEC_ordered                            (* comparable with < etc. *)\n   | TYSPEC_record of dict\n-  | TYSPEC_tuple of tyvar array                (* heterogeneous tuple *)\n+  | TYSPEC_tuple of tyvar array               (* heterogeneous tuple *)\n   | TYSPEC_vector of tyvar\n   | TYSPEC_app of (tyvar * Ast.ty array)\n \n-and simpl = SIMPL_none\n-            | SIMPL_exterior\n-            | SIMPL_mutable\n-\n and dict = (Ast.ident, tyvar) Hashtbl.t\n \n and tyvar = tyspec ref;;\n@@ -37,6 +33,7 @@ type binopsig =\n   | BINOPSIG_plus_plus_plus     (* plusable a * plusable a -> plusable a *)\n ;;\n \n+\n let rec tyspec_to_str (ts:tyspec) : string =\n \n   let fmt = Format.fprintf in\n@@ -105,15 +102,7 @@ let rec tyspec_to_str (ts:tyspec) : string =\n           else\n             Ast.fmt_ty ff ty\n \n-      | TYSPEC_equiv (SIMPL_none, tv) ->\n-          fmt_tyspec ff (!tv)\n-\n-      | TYSPEC_equiv (SIMPL_exterior, tv) ->\n-          fmt ff \"@\";\n-          fmt_tyspec ff (!tv)\n-\n-      | TYSPEC_equiv (SIMPL_mutable, tv) ->\n-          fmt ff \"mutable \";\n+      | TYSPEC_equiv tv ->\n           fmt_tyspec ff (!tv)\n \n       | TYSPEC_callable (out, ins) ->\n@@ -168,7 +157,7 @@ let iflog cx thunk =\n \n let rec resolve_tyvar (tv:tyvar) : tyvar =\n   match !tv with\n-      TYSPEC_equiv (_, subtv) -> resolve_tyvar subtv\n+      TYSPEC_equiv subtv -> resolve_tyvar subtv\n     | _ -> tv\n ;;\n \n@@ -209,73 +198,40 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n   let visitor (cx:ctxt) (inner:Walk.visitor) : Walk.visitor =\n \n     let rec unify_slot\n-        (simplify:bool)\n         (slot:Ast.slot)\n         (id_opt:node_id option)\n         (tv:tyvar) : unit =\n       match id_opt with\n-          Some id -> unify_tyvars simplify (Hashtbl.find bindings id) tv\n+          Some id -> unify_tyvars (Hashtbl.find bindings id) tv\n         | None ->\n             match slot.Ast.slot_ty with\n                 None -> bug () \"untyped unidentified slot\"\n-              | Some ty -> unify_ty simplify ty tv\n+              | Some ty -> unify_ty ty tv\n \n     and check_sane_tyvar tv =\n       match !tv with\n           TYSPEC_resolved (_, (Ast.TY_named _)) ->\n             bug () \"named-type in type checker\"\n         | _ -> ()\n \n-    and unify_tyvars (simplify:bool) (av:tyvar) (bv:tyvar) : unit =\n-      let sstr = if simplify then \"w/ simplification\" else \"\" in\n-        iflog cx (fun _ ->\n-                    log cx \"unifying types%s:\" sstr;\n-                    log cx \"input tyvar A: %s\" (tyspec_to_str !av);\n-                    log cx \"input tyvar B: %s\" (tyspec_to_str !bv));\n-        check_sane_tyvar av;\n-        check_sane_tyvar bv;\n-\n-        unify_tyvars' simplify av bv;\n-\n-        iflog cx (fun _ ->\n-                    log cx \"unified types%s:\" sstr;\n-                    log cx \"output tyvar A: %s\" (tyspec_to_str !av);\n-                    log cx \"output tyvar B: %s\" (tyspec_to_str !bv));\n-        check_sane_tyvar av;\n-        check_sane_tyvar bv;\n-\n-\n-    (* In some instances we will strip off a layer of mutability or\n-     * exterior-ness, as trans is willing to transplant and/or overlook\n-     * mutability / exterior differences wrt. many operators.\n-     * \n-     * Note: there is a secondary mutability-checking pass in effect.ml to\n-     * ensure you're not actually mutating the insides of an immutable. That's\n-     * not the typechecker's job.\n-     *)\n-    and unify_tyvars' (simplify:bool) (av:tyvar) (bv:tyvar) : unit =\n-      let (a, b) = ((resolve_tyvar av), (resolve_tyvar bv)) in\n-      let wrap tv =\n-        match !tv with\n-            TYSPEC_resolved (params, Ast.TY_mutable ty) ->\n-              tv := TYSPEC_equiv (SIMPL_mutable,\n-                                  (ref (TYSPEC_resolved (params, ty))));\n-              true\n-          | TYSPEC_resolved (params, Ast.TY_exterior ty) ->\n-              tv := TYSPEC_equiv (SIMPL_exterior,\n-                                  (ref (TYSPEC_resolved (params, ty))));\n-              true\n-          | _ -> false\n-      in\n-        if simplify\n-        then\n-          if (wrap a) || (wrap b)\n-          then unify_tyvars' simplify a b\n-          else unify_tyvars'' a b\n-        else\n-          unify_tyvars'' av bv\n-\n-    and unify_tyvars'' (av:tyvar) (bv:tyvar) : unit =\n+    and unify_tyvars  (av:tyvar) (bv:tyvar) : unit =\n+      iflog cx (fun _ ->\n+                  log cx \"unifying types:\";\n+                  log cx \"input tyvar A: %s\" (tyspec_to_str !av);\n+                  log cx \"input tyvar B: %s\" (tyspec_to_str !bv));\n+      check_sane_tyvar av;\n+      check_sane_tyvar bv;\n+\n+      unify_tyvars' av bv;\n+\n+      iflog cx (fun _ ->\n+                  log cx \"unified types:\";\n+                  log cx \"output tyvar A: %s\" (tyspec_to_str !av);\n+                  log cx \"output tyvar B: %s\" (tyspec_to_str !bv));\n+      check_sane_tyvar av;\n+      check_sane_tyvar bv;\n+\n+    and unify_tyvars' (av:tyvar) (bv:tyvar) : unit =\n       let (a, b) = ((resolve_tyvar av), (resolve_tyvar bv)) in\n       let fail () =\n         err None \"mismatched types: %s vs. %s\" (tyspec_to_str !av)\n@@ -286,7 +242,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n         let c = Hashtbl.create ((Hashtbl.length a) + (Hashtbl.length b)) in\n         let merge ident tv_a =\n           if Hashtbl.mem c ident\n-          then unify_tyvars false (Hashtbl.find c ident) tv_a\n+          then unify_tyvars (Hashtbl.find c ident) tv_a\n           else Hashtbl.add c ident tv_a\n         in\n           Hashtbl.iter (Hashtbl.add c) b;\n@@ -305,7 +261,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n         in\n \n         let check_entry ident tv =\n-          unify_ty false (find_ty ident) tv\n+          unify_ty (find_ty ident) tv\n         in\n           Hashtbl.iter check_entry dct\n       in\n@@ -316,11 +272,24 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n         let check_entry (query:Ast.ident) tv : unit =\n           match htab_search fns query with\n               None -> fail ()\n-            | Some fn -> unify_ty false (Ast.TY_fn fn) tv\n+            | Some fn -> unify_ty (Ast.TY_fn fn) tv\n         in\n           Hashtbl.iter check_entry dct\n       in\n \n+      let rec unify_resolved_types\n+          (ty_a:Ast.ty)\n+          (ty_b:Ast.ty)\n+          : Ast.ty =\n+        match ty_a, ty_b with\n+            a, b when a = b -> a\n+          | Ast.TY_exterior a, b | b, Ast.TY_exterior a ->\n+              Ast.TY_exterior (unify_resolved_types a b)\n+          | Ast.TY_mutable a, b | b, Ast.TY_mutable a ->\n+              Ast.TY_mutable (unify_resolved_types a b)\n+          | _ -> fail()\n+      in\n+\n       let rec is_comparable_or_ordered (comparable:bool) (ty:Ast.ty) : bool =\n         match ty with\n             Ast.TY_mach _ | Ast.TY_int | Ast.TY_uint\n@@ -338,38 +307,41 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n               is_comparable_or_ordered comparable ty\n       in\n \n-      let floating (ty:Ast.ty) : bool =\n+      let rec floating (ty:Ast.ty) : bool =\n         match ty with\n             Ast.TY_mach TY_f32 | Ast.TY_mach TY_f64 -> true\n+          | Ast.TY_exterior ty | Ast.TY_mutable ty -> floating ty\n           | _ -> false\n       in\n \n-      let integral (ty:Ast.ty) : bool =\n+      let rec integral (ty:Ast.ty) : bool =\n         match ty with\n             Ast.TY_int | Ast.TY_uint | Ast.TY_mach TY_u8 | Ast.TY_mach TY_u16\n           | Ast.TY_mach TY_u32 | Ast.TY_mach TY_u64 | Ast.TY_mach TY_i8\n           | Ast.TY_mach TY_i16 | Ast.TY_mach TY_i32\n           | Ast.TY_mach TY_i64 ->\n               true\n+          | Ast.TY_exterior ty | Ast.TY_mutable ty -> integral ty\n           | _ -> false\n       in\n \n       let numeric (ty:Ast.ty) : bool = (integral ty) || (floating ty) in\n \n-      let plusable (ty:Ast.ty) : bool =\n+      let rec plusable (ty:Ast.ty) : bool =\n         match ty with\n             Ast.TY_str -> true\n           | Ast.TY_vec _ -> true\n+          | Ast.TY_exterior ty | Ast.TY_mutable ty -> plusable ty\n           | _ -> numeric ty\n       in\n \n-      let loggable (ty:Ast.ty) : bool =\n+      let rec loggable (ty:Ast.ty) : bool =\n         match ty with\n-            Ast.TY_str | Ast.TY_bool | Ast.TY_int | Ast.TY_uint\n-          | Ast.TY_char\n+            Ast.TY_str | Ast.TY_bool | Ast.TY_int | Ast.TY_uint | Ast.TY_char\n           | Ast.TY_mach TY_u8 | Ast.TY_mach TY_u16 | Ast.TY_mach TY_u32\n           | Ast.TY_mach TY_i8 | Ast.TY_mach TY_i16 | Ast.TY_mach TY_i32\n               -> true\n+          | Ast.TY_exterior ty | Ast.TY_mutable ty -> loggable ty\n           | _ -> false\n       in\n \n@@ -384,40 +356,46 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n \n           | (TYSPEC_resolved (params_a, ty_a),\n              TYSPEC_resolved (params_b, ty_b)) ->\n-              if params_a <> params_b || ty_a <> ty_b\n-              then fail()\n-              else TYSPEC_resolved (params_a, ty_a)\n+              if params_a <> params_b then fail()\n+              else TYSPEC_resolved (params_a, (unify_resolved_types ty_a ty_b))\n \n           | (TYSPEC_resolved (params, ty),\n              TYSPEC_callable (out_tv, in_tvs))\n           | (TYSPEC_callable (out_tv, in_tvs),\n              TYSPEC_resolved (params, ty)) ->\n               let unify_in_slot i in_slot =\n-                unify_slot true in_slot None in_tvs.(i)\n+                unify_slot in_slot None in_tvs.(i)\n               in\n-                begin\n+                let rec unify ty =\n                   match ty with\n                       Ast.TY_fn ({\n                                    Ast.sig_input_slots = in_slots;\n                                    Ast.sig_output_slot = out_slot\n                                  }, _) ->\n                         if Array.length in_slots != Array.length in_tvs\n-                        then fail ();\n-                        unify_slot true out_slot None out_tv;\n-                        Array.iteri unify_in_slot in_slots\n+                        then\n+                          fail ()\n+                        else\n+                          unify_slot out_slot None out_tv;\n+                          Array.iteri unify_in_slot in_slots;\n+                          ty\n+                    | Ast.TY_exterior ty -> Ast.TY_exterior (unify ty)\n+                    | Ast.TY_mutable ty -> Ast.TY_mutable (unify ty)\n                     | _ -> fail ()\n-                end;\n-                TYSPEC_resolved (params, ty)\n+                in\n+                TYSPEC_resolved (params, unify ty)\n \n           | (TYSPEC_resolved (params, ty), TYSPEC_collection tv)\n           | (TYSPEC_collection tv, TYSPEC_resolved (params, ty)) ->\n-              begin\n+              let rec unify ty =\n                 match ty with\n-                    Ast.TY_vec ty -> unify_ty false ty tv\n-                  | Ast.TY_str -> unify_ty false (Ast.TY_mach TY_u8) tv\n+                    Ast.TY_vec ty -> unify_ty ty tv; ty\n+                  | Ast.TY_str -> unify_ty (Ast.TY_mach TY_u8) tv; ty\n+                  | Ast.TY_exterior ty -> Ast.TY_exterior (unify ty)\n+                  | Ast.TY_mutable ty -> Ast.TY_mutable (unify ty)\n                   | _ -> fail ()\n-              end;\n-              TYSPEC_resolved (params, ty)\n+              in\n+              TYSPEC_resolved (params, unify ty)\n \n           | (TYSPEC_resolved (params, ty), TYSPEC_comparable)\n           | (TYSPEC_comparable, TYSPEC_resolved (params, ty)) ->\n@@ -431,15 +409,19 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n \n           | (TYSPEC_resolved (params, ty), TYSPEC_dictionary dct)\n           | (TYSPEC_dictionary dct, TYSPEC_resolved (params, ty)) ->\n-              begin\n+              let rec unify ty =\n                 match ty with\n                     Ast.TY_rec fields ->\n-                      unify_dict_with_record_fields dct fields\n+                      unify_dict_with_record_fields dct fields;\n+                      ty\n                   | Ast.TY_obj (_, fns) ->\n-                      unify_dict_with_obj_fns dct fns\n+                      unify_dict_with_obj_fns dct fns;\n+                      ty\n+                  | Ast.TY_exterior ty -> Ast.TY_exterior (unify ty)\n+                  | Ast.TY_mutable ty -> Ast.TY_mutable (unify ty)\n                   | _ -> fail ()\n-              end;\n-              TYSPEC_resolved (params, ty)\n+              in\n+              TYSPEC_resolved (params, unify ty)\n \n           | (TYSPEC_resolved (params, ty), TYSPEC_integral)\n           | (TYSPEC_integral, TYSPEC_resolved (params, ty)) ->\n@@ -466,55 +448,61 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | (TYSPEC_resolved (params, ty), TYSPEC_app (tv, args))\n           | (TYSPEC_app (tv, args), TYSPEC_resolved (params, ty)) ->\n               let ty = rebuild_ty_under_params ty params args false in\n-                unify_ty false ty tv;\n+                unify_ty ty tv;\n                 TYSPEC_resolved ([| |], ty)\n \n           | (TYSPEC_resolved (params, ty), TYSPEC_record dct)\n           | (TYSPEC_record dct, TYSPEC_resolved (params, ty)) ->\n-              begin\n+              let rec unify ty =\n                 match ty with\n                     Ast.TY_rec fields ->\n-                      unify_dict_with_record_fields dct fields\n+                      unify_dict_with_record_fields dct fields;\n+                      ty\n+                  | Ast.TY_exterior ty -> Ast.TY_exterior (unify ty)\n+                  | Ast.TY_mutable ty -> Ast.TY_mutable (unify ty)\n                   | _ -> fail ()\n-              end;\n-              TYSPEC_resolved (params, ty)\n+              in\n+              TYSPEC_resolved (params, unify ty)\n \n           | (TYSPEC_resolved (params, ty), TYSPEC_tuple tvs)\n           | (TYSPEC_tuple tvs, TYSPEC_resolved (params, ty)) ->\n-              begin\n+              let rec unify ty =\n                 match ty with\n                     Ast.TY_tup (elem_tys:Ast.ty array) ->\n                       if (Array.length elem_tys) <> (Array.length tvs)\n                       then fail ()\n                       else\n                         let check_elem i tv =\n-                          unify_ty false (elem_tys.(i)) tv\n+                          unify_ty (elem_tys.(i)) tv\n                         in\n-                          Array.iteri check_elem tvs\n+                          Array.iteri check_elem tvs;\n+                          ty\n+                  | Ast.TY_exterior ty -> Ast.TY_exterior ty\n+                  | Ast.TY_mutable ty -> Ast.TY_mutable ty\n                   | _ -> fail ()\n-              end;\n-              TYSPEC_resolved (params, ty)\n+              in\n+              TYSPEC_resolved (params, unify ty)\n \n           | (TYSPEC_resolved (params, ty), TYSPEC_vector tv)\n           | (TYSPEC_vector tv, TYSPEC_resolved (params, ty)) ->\n-              begin\n+              let rec unify ty =\n                 match ty with\n-                    Ast.TY_vec ty ->\n-                      unify_ty false ty tv;\n-                      TYSPEC_resolved (params, Ast.TY_vec ty)\n+                    Ast.TY_vec ty -> unify_ty ty tv; ty\n+                  | Ast.TY_exterior ty -> Ast.TY_exterior ty\n+                  | Ast.TY_mutable ty -> Ast.TY_mutable ty\n                   | _ -> fail ()\n-              end\n+              in\n+              TYSPEC_resolved (params, unify ty)\n \n           (* callable *)\n \n           | (TYSPEC_callable (a_out_tv, a_in_tvs),\n              TYSPEC_callable (b_out_tv, b_in_tvs)) ->\n-              unify_tyvars true a_out_tv b_out_tv;\n+              unify_tyvars a_out_tv b_out_tv;\n               let check_in_tv i a_in_tv =\n-                unify_tyvars true a_in_tv b_in_tvs.(i)\n+                unify_tyvars a_in_tv b_in_tvs.(i)\n               in\n                 Array.iteri check_in_tv a_in_tvs;\n-                unify_tyvars true a_out_tv b_out_tv;\n                 TYSPEC_callable (a_out_tv, a_in_tvs)\n \n           | (TYSPEC_callable _, TYSPEC_collection _)\n@@ -545,7 +533,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           (* collection *)\n \n           | (TYSPEC_collection av, TYSPEC_collection bv) ->\n-              unify_tyvars false av bv;\n+              unify_tyvars av bv;\n               TYSPEC_collection av\n \n           | (TYSPEC_collection av, TYSPEC_comparable)\n@@ -574,7 +562,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n \n           | (TYSPEC_collection av, TYSPEC_vector bv)\n           | (TYSPEC_vector bv, TYSPEC_collection av) ->\n-              unify_tyvars false av bv;\n+              unify_tyvars av bv;\n               TYSPEC_vector av\n \n           (* comparable *)\n@@ -743,7 +731,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n               then fail()\n               else\n                 begin\n-                  unify_tyvars false tv_a tv_b;\n+                  unify_tyvars tv_a tv_b;\n                   TYSPEC_app (tv_a, args_a)\n                 end\n \n@@ -776,7 +764,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                 else if i >= len_b\n                 then tvs_a.(i)\n                 else begin\n-                  unify_tyvars false tvs_a.(i) tvs_b.(i);\n+                  unify_tyvars tvs_a.(i) tvs_b.(i);\n                   tvs_a.(i)\n                 end\n               in\n@@ -788,27 +776,26 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           (* vector *)\n \n           | (TYSPEC_vector av, TYSPEC_vector bv) ->\n-              unify_tyvars false av bv;\n+              unify_tyvars av bv;\n               TYSPEC_vector av\n       in\n       let c = ref result in\n-        a := TYSPEC_equiv (SIMPL_none, c);\n-        b := TYSPEC_equiv (SIMPL_none, c)\n+        a := TYSPEC_equiv c;\n+        b := TYSPEC_equiv c\n \n     and unify_ty_parametric\n-        (simplify:bool)\n         (ty:Ast.ty)\n         (tps:Ast.ty_param array)\n         (tv:tyvar)\n         : unit =\n-      unify_tyvars simplify (ref (TYSPEC_resolved (tps, ty))) tv\n+      unify_tyvars (ref (TYSPEC_resolved (tps, ty))) tv\n \n-    and unify_ty (simplify:bool) (ty:Ast.ty) (tv:tyvar) : unit =\n-      unify_ty_parametric simplify ty [||] tv\n+    and unify_ty (ty:Ast.ty) (tv:tyvar) : unit =\n+      unify_ty_parametric ty [||] tv\n \n     in\n \n-    let rec unify_lit (simplify:bool) (lit:Ast.lit) (tv:tyvar) : unit =\n+    let rec unify_lit (lit:Ast.lit) (tv:tyvar) : unit =\n       let ty =\n         match lit with\n             Ast.LIT_nil -> Ast.TY_nil\n@@ -818,14 +805,14 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | Ast.LIT_uint (_, _) -> Ast.TY_uint\n           | Ast.LIT_char _ -> Ast.TY_char\n       in\n-        unify_ty simplify ty tv\n+        unify_ty ty tv\n \n-    and unify_atom (simplify:bool) (atom:Ast.atom) (tv:tyvar) : unit =\n+    and unify_atom (atom:Ast.atom) (tv:tyvar) : unit =\n       match atom with\n           Ast.ATOM_literal { node = literal; id = _ } ->\n-            unify_lit simplify literal tv\n+            unify_lit literal tv\n         | Ast.ATOM_lval lval ->\n-            unify_lval simplify lval tv\n+            unify_lval lval tv\n \n     and unify_expr (expr:Ast.expr) (tv:tyvar) : unit =\n       match expr with\n@@ -858,64 +845,64 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n               begin\n                 match binop_sig with\n                     BINOPSIG_bool_bool_bool ->\n-                      unify_atom true lhs\n+                      unify_atom lhs\n                         (ref (TYSPEC_resolved ([||], Ast.TY_bool)));\n-                      unify_atom true rhs\n+                      unify_atom rhs\n                         (ref (TYSPEC_resolved ([||], Ast.TY_bool)));\n-                      unify_ty true Ast.TY_bool tv\n+                      unify_ty Ast.TY_bool tv\n                   | BINOPSIG_comp_comp_bool ->\n                       let tv_a = ref TYSPEC_comparable in\n-                        unify_atom true lhs tv_a;\n-                        unify_atom true rhs tv_a;\n-                        unify_ty true Ast.TY_bool tv\n+                        unify_atom lhs tv_a;\n+                        unify_atom rhs tv_a;\n+                        unify_ty Ast.TY_bool tv\n                   | BINOPSIG_ord_ord_bool ->\n                       let tv_a = ref TYSPEC_ordered in\n-                        unify_atom true lhs tv_a;\n-                        unify_atom true rhs tv_a;\n-                        unify_ty true Ast.TY_bool tv\n+                        unify_atom lhs tv_a;\n+                        unify_atom rhs tv_a;\n+                        unify_ty Ast.TY_bool tv\n                   | BINOPSIG_integ_integ_integ ->\n                       let tv_a = ref TYSPEC_integral in\n-                        unify_atom true lhs tv_a;\n-                        unify_atom true rhs tv_a;\n-                        unify_tyvars true tv tv_a\n+                        unify_atom lhs tv_a;\n+                        unify_atom rhs tv_a;\n+                        unify_tyvars tv tv_a\n                   | BINOPSIG_num_num_num ->\n                       let tv_a = ref TYSPEC_numeric in\n-                        unify_atom true lhs tv_a;\n-                        unify_atom true rhs tv_a;\n-                        unify_tyvars true tv tv_a\n+                        unify_atom lhs tv_a;\n+                        unify_atom rhs tv_a;\n+                        unify_tyvars tv tv_a\n                   | BINOPSIG_plus_plus_plus ->\n                       let tv_a = ref TYSPEC_plusable in\n-                        unify_atom true lhs tv_a;\n-                        unify_atom true rhs tv_a;\n-                        unify_tyvars true tv tv_a\n+                        unify_atom lhs tv_a;\n+                        unify_atom rhs tv_a;\n+                        unify_tyvars tv tv_a\n               end\n         | Ast.EXPR_unary (unop, atom) ->\n             begin\n               match unop with\n                   Ast.UNOP_not ->\n-                    unify_atom true atom\n+                    unify_atom atom\n                       (ref (TYSPEC_resolved ([||], Ast.TY_bool)));\n-                    unify_ty true Ast.TY_bool tv\n+                    unify_ty Ast.TY_bool tv\n                 | Ast.UNOP_bitnot ->\n                     let tv_a = ref TYSPEC_integral in\n-                      unify_atom true atom tv_a;\n-                      unify_tyvars true tv tv_a\n+                      unify_atom atom tv_a;\n+                      unify_tyvars tv tv_a\n                 | Ast.UNOP_neg ->\n                     let tv_a = ref TYSPEC_numeric in\n-                      unify_atom true atom tv_a;\n-                      unify_tyvars true tv tv_a\n+                      unify_atom atom tv_a;\n+                      unify_tyvars tv tv_a\n                 | Ast.UNOP_cast t ->\n                     (* FIXME (issue #84): check cast-validity in\n                      * post-typecheck pass.  Only some casts make sense.\n                      *)\n                     let tv_a = ref TYSPEC_all in\n                     let t = Hashtbl.find cx.ctxt_all_cast_types t.id in\n-                      unify_atom true atom tv_a;\n-                      unify_ty true t tv\n+                      unify_atom atom tv_a;\n+                      unify_ty t tv\n             end\n-        | Ast.EXPR_atom atom -> unify_atom true atom tv\n+        | Ast.EXPR_atom atom -> unify_atom atom tv\n \n-    and unify_lval' (simplify:bool) (lval:Ast.lval) (tv:tyvar) : unit =\n+    and unify_lval' (lval:Ast.lval) (tv:tyvar) : unit =\n       let note_args args =\n         iflog cx (fun _ -> log cx \"noting lval '%a' type arguments: %a\"\n                     Ast.sprintf_lval lval Ast.sprintf_app_args args);\n@@ -937,7 +924,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                                 log cx \"lval-base slot tyspec for %a = %s\"\n                                   Ast.sprintf_lval lval (tyspec_to_str (!tv));\n                           end;\n-                        unify_slot simplify slot (Some referent) tv\n+                        unify_slot slot (Some referent) tv\n \n                     | _ ->\n                         let spec = (!(Hashtbl.find bindings referent)) in\n@@ -959,7 +946,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                                 ref (TYSPEC_app (tv, args))\n                             | _ -> err None \"bad lval / tyspec combination\"\n                         in\n-                          unify_tyvars simplify (ref spec) tv\n+                          unify_tyvars (ref spec) tv\n                 end\n           | Ast.LVAL_ext (base, comp) ->\n               let base_ts = match comp with\n@@ -980,33 +967,33 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                       TYSPEC_tuple (Array.init (i + 1) init)\n \n                 | Ast.COMP_atom atom ->\n-                    unify_atom simplify atom\n+                    unify_atom atom\n                       (ref (TYSPEC_resolved ([||], Ast.TY_int)));\n                     TYSPEC_collection tv\n               in\n               let base_tv = ref base_ts in\n-                unify_lval' simplify base base_tv;\n+                unify_lval' base base_tv;\n                 match !(resolve_tyvar base_tv) with\n                     TYSPEC_resolved (_, ty) ->\n-                      unify_ty simplify (project_type ty comp) tv\n+                      unify_ty (project_type ty comp) tv\n                   | _ ->\n                       ()\n \n-    and unify_lval (simplify:bool) (lval:Ast.lval) (tv:tyvar) : unit =\n+    and unify_lval (lval:Ast.lval) (tv:tyvar) : unit =\n       let id = lval_base_id lval in\n         (* Fetch lval with type components resolved. *)\n         let lval = Hashtbl.find cx.ctxt_all_lvals id in\n         iflog cx (fun _ -> log cx\n                     \"fetched resolved version of lval #%d = %a\"\n                     (int_of_node id) Ast.sprintf_lval lval);\n           Hashtbl.add lval_tyvars id tv;\n-          unify_lval' simplify lval tv\n+          unify_lval' lval tv\n \n     in\n     let gen_atom_tvs atoms =\n       let gen_atom_tv atom =\n         let tv = ref TYSPEC_all in\n-          unify_atom true atom tv;\n+          unify_atom atom tv;\n           tv\n       in\n         Array.map gen_atom_tv atoms\n@@ -1016,72 +1003,72 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n       let check_callable out_tv callee args =\n         let in_tvs = gen_atom_tvs args in\n         let callee_tv = ref (TYSPEC_callable (out_tv, in_tvs)) in\n-          unify_lval true callee callee_tv;\n+          unify_lval callee callee_tv;\n       in\n       match stmt.node with\n           Ast.STMT_spawn (out, _, callee, args) ->\n             let out_tv = ref (TYSPEC_resolved ([||], Ast.TY_nil)) in\n-              unify_lval true out (ref (TYSPEC_resolved ([||], Ast.TY_task)));\n+              unify_lval out (ref (TYSPEC_resolved ([||], Ast.TY_task)));\n               check_callable out_tv callee args\n \n         | Ast.STMT_init_rec (lval, fields, Some base) ->\n             let dct = Hashtbl.create 10 in\n             let tvrec = ref (TYSPEC_record dct) in\n             let add_field (ident, atom) =\n               let tv = ref TYSPEC_all in\n-                unify_atom true atom tv;\n+                unify_atom atom tv;\n                 Hashtbl.add dct ident tv\n             in\n               Array.iter add_field fields;\n               let tvbase = ref TYSPEC_all in\n-                unify_lval true base tvbase;\n-                unify_tyvars true tvrec tvbase;\n-                unify_lval true lval tvrec\n+                unify_lval base tvbase;\n+                unify_tyvars tvrec tvbase;\n+                unify_lval lval tvrec\n \n         | Ast.STMT_init_rec (lval, fields, None) ->\n             let dct = Hashtbl.create 10 in\n             let add_field (ident, atom) =\n               let tv = ref TYSPEC_all in\n-                unify_atom true atom tv;\n+                unify_atom atom tv;\n                 Hashtbl.add dct ident tv\n             in\n               Array.iter add_field fields;\n-              unify_lval true lval (ref (TYSPEC_record dct))\n+              unify_lval lval (ref (TYSPEC_record dct))\n \n         | Ast.STMT_init_tup (lval, members) ->\n             let member_to_tv atom =\n               let tv = ref TYSPEC_all in\n-                unify_atom true atom tv;\n+                unify_atom atom tv;\n                 tv\n             in\n             let member_tvs = Array.map member_to_tv members in\n-              unify_lval true lval (ref (TYSPEC_tuple member_tvs))\n+              unify_lval lval (ref (TYSPEC_tuple member_tvs))\n \n         | Ast.STMT_init_vec (lval, atoms) ->\n             let tv = ref TYSPEC_all in\n-            let unify_with_tv atom = unify_atom true atom tv in\n+            let unify_with_tv atom = unify_atom atom tv in\n               Array.iter unify_with_tv atoms;\n-              unify_lval true lval (ref (TYSPEC_vector tv))\n+              unify_lval lval (ref (TYSPEC_vector tv))\n \n         | Ast.STMT_init_str (lval, _) ->\n-            unify_lval true lval (ref (TYSPEC_resolved ([||], Ast.TY_str)))\n+            unify_lval lval (ref (TYSPEC_resolved ([||], Ast.TY_str)))\n \n         | Ast.STMT_copy (lval, expr) ->\n             let tv = ref TYSPEC_all in\n               unify_expr expr tv;\n-              unify_lval true lval tv\n+              unify_lval lval tv\n \n         | Ast.STMT_copy_binop (lval, binop, at) ->\n             let tv = ref TYSPEC_all in\n               unify_expr (Ast.EXPR_binary (binop, Ast.ATOM_lval lval, at)) tv;\n-              unify_lval true lval tv;\n+              unify_lval lval tv;\n \n         | Ast.STMT_call (out, callee, args) ->\n             let out_tv = ref TYSPEC_all in\n-              unify_lval true out out_tv;\n+              unify_lval out out_tv;\n               check_callable out_tv callee args\n \n-        | Ast.STMT_log atom -> unify_atom true atom (ref TYSPEC_loggable)\n+        | Ast.STMT_log atom -> unify_atom atom (ref TYSPEC_loggable)\n \n         | Ast.STMT_check_expr expr ->\n             unify_expr expr (ref (TYSPEC_resolved ([||], Ast.TY_bool)))\n@@ -1105,8 +1092,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n         | Ast.STMT_put atom_opt ->\n             begin\n               match atom_opt with\n-                  None -> unify_ty true Ast.TY_nil (retval_tv())\n-                | Some atom -> unify_atom true atom (retval_tv())\n+                  None -> unify_ty Ast.TY_nil (retval_tv())\n+                | Some atom -> unify_atom atom (retval_tv())\n             end\n \n         | Ast.STMT_be (callee, args) ->\n@@ -1124,7 +1111,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                   begin\n                     match atom_opt with\n                         None -> residue := tv :: (!residue);\n-                      | Some atom -> unify_atom true atom tv\n+                      | Some atom -> unify_atom atom tv\n                   end;\n                   tv\n               in\n@@ -1135,28 +1122,28 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n             let arg_residue_tvs = Array.of_list (List.rev (!residue)) in\n             let callee_tv = ref (TYSPEC_callable (out_tv, in_tvs)) in\n             let bound_tv = ref (TYSPEC_callable (out_tv, arg_residue_tvs)) in\n-              unify_lval true callee callee_tv;\n-              unify_lval true bound bound_tv\n+              unify_lval callee callee_tv;\n+              unify_lval bound bound_tv\n \n         | Ast.STMT_for_each fe ->\n             let out_tv = ref TYSPEC_all in\n             let (si, _) = fe.Ast.for_each_slot in\n             let (callee, args) = fe.Ast.for_each_call in\n-              unify_slot true si.node (Some si.id) out_tv;\n+              unify_slot si.node (Some si.id) out_tv;\n               check_callable out_tv callee args\n \n         | Ast.STMT_for fo ->\n             let mem_tv = ref TYSPEC_all in\n             let seq_tv = ref (TYSPEC_collection mem_tv) in\n             let (si, _) = fo.Ast.for_slot in\n             let (_, seq) = fo.Ast.for_seq in\n-              unify_lval true seq seq_tv;\n-              unify_slot true si.node (Some si.id) mem_tv\n+              unify_lval seq seq_tv;\n+              unify_slot si.node (Some si.id) mem_tv\n \n         | Ast.STMT_alt_tag\n             { Ast.alt_tag_lval = lval; Ast.alt_tag_arms = arms } ->\n             let lval_tv = ref TYSPEC_all in\n-              unify_lval true lval lval_tv;\n+              unify_lval lval lval_tv;\n               Array.iter (fun _ -> push_pat_tv lval_tv) arms\n \n         (* FIXME (issue #52): plenty more to handle here. *)\n@@ -1183,7 +1170,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n     let enter_fn fn retspec =\n       let out = fn.Ast.fn_output_slot in\n         push_retval_tv (ref retspec);\n-        unify_slot true out.node (Some out.id) (retval_tv())\n+        unify_slot out.node (Some out.id) (retval_tv())\n     in\n \n     let visit_obj_fn_pre obj ident fn =\n@@ -1250,12 +1237,12 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n     let visit_pat_pre (pat:Ast.pat) : unit =\n       let expected = pat_tv() in\n         match pat with\n-            Ast.PAT_lit lit -> unify_lit true lit expected\n+            Ast.PAT_lit lit -> unify_lit lit expected\n \n           | Ast.PAT_tag (lval, _) ->\n               let expect ty =\n                 let tv = ref TYSPEC_all in\n-                  unify_ty true ty tv;\n+                  unify_ty ty tv;\n                   push_pat_tv tv;\n               in\n \n@@ -1267,7 +1254,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                * exactly to that function type, rebuilt under any latent type\n                * parameters applied in the lval. *)\n               let lval_tv = ref TYSPEC_all in\n-                unify_lval true lval lval_tv;\n+                unify_lval lval lval_tv;\n                 let tag_ctor_ty =\n                   match !(resolve_tyvar lval_tv) with\n                       TYSPEC_resolved (_, ty) -> ty\n@@ -1279,13 +1266,13 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                 let tag_ty_tup = tag_or_iso_ty_tup_by_name tag_ty lval_nm in\n \n                 let tag_tv = ref TYSPEC_all in\n-                  unify_ty true tag_ty tag_tv;\n-                  unify_tyvars true expected tag_tv;\n+                  unify_ty tag_ty tag_tv;\n+                  unify_tyvars expected tag_tv;\n                   List.iter expect\n                     (List.rev (Array.to_list tag_ty_tup));\n \n           | Ast.PAT_slot (sloti, _) ->\n-              unify_slot true sloti.node (Some sloti.id) expected\n+              unify_slot sloti.node (Some sloti.id) expected\n \n           | Ast.PAT_wild -> ()\n     in\n@@ -1386,21 +1373,24 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n               | _ -> bug () \"check_auto_tyvar: no slot defn\"\n         in\n \n-        let rec get_resolved_ty tv id =\n-          match !tv with\n-              TYSPEC_resolved ([||], ty) -> ty\n-            | TYSPEC_vector tv ->\n-                Ast.TY_vec (get_resolved_ty tv id)\n-            | TYSPEC_equiv (SIMPL_none, tv) ->\n-                get_resolved_ty tv id\n-            | TYSPEC_equiv (SIMPL_mutable, tv) ->\n-                Ast.TY_mutable (get_resolved_ty tv id)\n-            | TYSPEC_equiv (SIMPL_exterior, tv) ->\n-                Ast.TY_exterior (get_resolved_ty tv id)\n-            | _ -> err (Some id)\n-                \"unresolved type %s (%d)\"\n-                  (tyspec_to_str !tv)\n-                  (int_of_node id)\n+        let get_resolved_ty tv id =\n+          let ts = !(resolve_tyvar tv) in\n+            match ts with\n+                TYSPEC_resolved ([||], ty) -> ty\n+              | TYSPEC_vector (tv) ->\n+                  begin\n+                    match !(resolve_tyvar tv) with\n+                        TYSPEC_resolved ([||], ty) ->\n+                          (Ast.TY_vec ty)\n+                      | _ ->\n+                          err (Some id)\n+                            \"unresolved vector-element type in %s (%d)\"\n+                            (tyspec_to_str ts) (int_of_node id)\n+                  end\n+              | _ -> err (Some id)\n+                  \"unresolved type %s (%d)\"\n+                    (tyspec_to_str ts)\n+                    (int_of_node id)\n         in\n \n         let check_auto_tyvar id ="}]}