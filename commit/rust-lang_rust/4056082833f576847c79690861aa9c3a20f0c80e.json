{"sha": "4056082833f576847c79690861aa9c3a20f0c80e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNTYwODI4MzNmNTc2ODQ3Yzc5NjkwODYxYWE5YzNhMjBmMGM4MGU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-02T02:13:22Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-02T02:13:22Z"}, "message": "rustdoc: Extract markdown header logic. Needed for indexing", "tree": {"sha": "bf2ca4f9654bd176443e2fb6c1f0412c0c67bb38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf2ca4f9654bd176443e2fb6c1f0412c0c67bb38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4056082833f576847c79690861aa9c3a20f0c80e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4056082833f576847c79690861aa9c3a20f0c80e", "html_url": "https://github.com/rust-lang/rust/commit/4056082833f576847c79690861aa9c3a20f0c80e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4056082833f576847c79690861aa9c3a20f0c80e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4991943f4efde32c2be16ab849d3f77432ee7906", "url": "https://api.github.com/repos/rust-lang/rust/commits/4991943f4efde32c2be16ab849d3f77432ee7906", "html_url": "https://github.com/rust-lang/rust/commit/4991943f4efde32c2be16ab849d3f77432ee7906"}], "stats": {"total": 108, "additions": 78, "deletions": 30}, "files": [{"sha": "b6a962e4d2a51160cc21bab49af5168cd1350bf2", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 78, "deletions": 30, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4056082833f576847c79690861aa9c3a20f0c80e/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4056082833f576847c79690861aa9c3a20f0c80e/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=4056082833f576847c79690861aa9c3a20f0c80e", "patch": "@@ -105,17 +105,79 @@ enum hlvl {\n     h3 = 3\n }\n \n-fn write_header(ctxt: ctxt, lvl: hlvl, title: str) {\n+fn write_header(ctxt: ctxt, lvl: hlvl, doc: doc::itemtag) {\n+    let text = header_text(doc);\n+    write_header_(ctxt, lvl, text);\n+}\n+\n+fn write_header_(ctxt: ctxt, lvl: hlvl, title: str) {\n     let hashes = str::from_chars(vec::init_elt(lvl as uint, '#'));\n     ctxt.w.write_line(#fmt(\"%s %s\", hashes, title));\n     ctxt.w.write_line(\"\");\n }\n \n+fn header_text(doc: doc::itemtag) -> str {\n+    let fullpath = str::connect(doc.path() + [doc.name()], \"::\");\n+    alt doc {\n+      doc::modtag(_) {\n+        if doc.id() == rustc::syntax::ast::crate_node_id {\n+            header_text_(\"Crate\", doc.name())\n+        } else {\n+            header_text_(\"Module\", fullpath)\n+        }\n+      }\n+      doc::nmodtag(_) {\n+        header_text_(\"Native module\", fullpath)\n+      }\n+      doc::fntag(_) {\n+        header_text_(\"Function\", doc.name())\n+      }\n+      doc::consttag(_) {\n+        header_text_(\"Const\", doc.name())\n+      }\n+      doc::enumtag(_) {\n+        header_text_(\"Enum\", doc.name())\n+      }\n+      doc::restag(_) {\n+        header_text_(\"Resource\", doc.name())\n+      }\n+      doc::ifacetag(_) {\n+        header_text_(\"Interface\", doc.name())\n+      }\n+      doc::impltag(doc) {\n+        assert option::is_some(doc.self_ty);\n+        let self_ty = option::get(doc.self_ty);\n+        alt doc.iface_ty {\n+          some(iface_ty) {\n+            header_text_(\n+                \"Implementation\",\n+                #fmt(\"%s of %s for %s\",\n+                     doc.name(), iface_ty, self_ty)\n+            )\n+          }\n+          none {\n+            header_text_(\n+                \"Implementation\",\n+                #fmt(\"%s for %s\", doc.name(), self_ty)\n+            )\n+          }\n+        }\n+      }\n+      doc::tytag(_) {\n+        header_text_(\"Type\", doc.name())\n+      }\n+    }\n+}\n+\n+fn header_text_(kind: str, name: str) -> str {\n+    #fmt(\"%s `%s`\", kind, name)\n+}\n+\n fn write_crate(\n     ctxt: ctxt,\n     doc: doc::cratedoc\n ) {\n-    write_header(ctxt, h1, #fmt(\"Crate %s\", doc.topmod.name()));\n+    write_header(ctxt, h1, doc::modtag(doc.topmod));\n     write_top_module(ctxt, doc.topmod);\n }\n \n@@ -130,8 +192,7 @@ fn write_mod(\n     ctxt: ctxt,\n     moddoc: doc::moddoc\n ) {\n-    let fullpath = str::connect(moddoc.path() + [moddoc.name()], \"::\");\n-    write_header(ctxt, h1, #fmt(\"Module `%s`\", fullpath));\n+    write_header(ctxt, h1, doc::modtag(moddoc));\n     write_mod_contents(ctxt, moddoc);\n }\n \n@@ -176,8 +237,7 @@ fn should_write_crate_description() {\n }\n \n fn write_nmod(ctxt: ctxt, doc: doc::nmoddoc) {\n-    let fullpath = str::connect(doc.path() + [doc.name()], \"::\");\n-    write_header(ctxt, h1, #fmt(\"Native module `%s`\", fullpath));\n+    write_header(ctxt, h1, doc::nmodtag(doc));\n \n     write_brief(ctxt, doc.brief());\n     write_desc(ctxt, doc.desc());\n@@ -205,7 +265,7 @@ fn write_fn(\n     ctxt: ctxt,\n     doc: doc::fndoc\n ) {\n-    write_header(ctxt, h2, #fmt(\"Function `%s`\", doc.name()));\n+    write_header(ctxt, h2, doc::fntag(doc));\n     write_fnlike(\n         ctxt,\n         doc.sig,\n@@ -469,7 +529,7 @@ fn write_const(\n     ctxt: ctxt,\n     doc: doc::constdoc\n ) {\n-    write_header(ctxt, h2, #fmt(\"Const `%s`\", doc.name()));\n+    write_header(ctxt, h2, doc::consttag(doc));\n     write_sig(ctxt, doc.ty);\n     write_brief(ctxt, doc.brief());\n     write_desc(ctxt, doc.desc());\n@@ -493,7 +553,7 @@ fn write_enum(\n     ctxt: ctxt,\n     doc: doc::enumdoc\n ) {\n-    write_header(ctxt, h2, #fmt(\"Enum `%s`\", doc.name()));\n+    write_header(ctxt, h2, doc::enumtag(doc));\n     write_brief(ctxt, doc.brief());\n     write_desc(ctxt, doc.desc());\n     write_variants(ctxt, doc.variants);\n@@ -575,7 +635,7 @@ fn should_write_variant_list_with_signatures() {\n }\n \n fn write_res(ctxt: ctxt, doc: doc::resdoc) {\n-    write_header(ctxt, h2, #fmt(\"Resource `%s`\", doc.name()));\n+    write_header(ctxt, h2, doc::restag(doc));\n     write_sig(ctxt, doc.sig);\n     write_brief(ctxt, doc.brief());\n     write_desc(ctxt, doc.desc());\n@@ -602,7 +662,7 @@ fn should_write_resource_args() {\n }\n \n fn write_iface(ctxt: ctxt, doc: doc::ifacedoc) {\n-    write_header(ctxt, h2, #fmt(\"Interface `%s`\", doc.name()));\n+    write_header(ctxt, h2, doc::ifacetag(doc));\n     write_brief(ctxt, doc.brief());\n     write_desc(ctxt, doc.desc());\n     write_methods(ctxt, doc.methods);\n@@ -613,7 +673,7 @@ fn write_methods(ctxt: ctxt, docs: [doc::methoddoc]) {\n }\n \n fn write_method(ctxt: ctxt, doc: doc::methoddoc) {\n-    write_header(ctxt, h3, #fmt(\"Method `%s`\", doc.name));\n+    write_header_(ctxt, h3, header_text_(\"Method\", doc.name));\n     write_fnlike(\n         ctxt,\n         doc.sig,\n@@ -695,20 +755,7 @@ fn should_write_iface_method_failure_conditions() {\n }\n \n fn write_impl(ctxt: ctxt, doc: doc::impldoc) {\n-    assert option::is_some(doc.self_ty);\n-    let self_ty = option::get(doc.self_ty);\n-    alt doc.iface_ty {\n-      some(iface_ty) {\n-        write_header(ctxt, h2,\n-                     #fmt(\"Implementation `%s` of `%s` for `%s`\",\n-                          doc.name(), iface_ty, self_ty));\n-      }\n-      none {\n-        write_header(ctxt, h2,\n-                     #fmt(\"Implementation `%s` for `%s`\",\n-                          doc.name(), self_ty));\n-      }\n-    }\n+    write_header(ctxt, h2, doc::impltag(doc));\n     write_brief(ctxt, doc.brief());\n     write_desc(ctxt, doc.desc());\n     write_methods(ctxt, doc.methods);\n@@ -717,13 +764,14 @@ fn write_impl(ctxt: ctxt, doc: doc::impldoc) {\n #[test]\n fn should_write_impl_header() {\n     let markdown = test::render(\"impl i for int { fn a() { } }\");\n-    assert str::contains(markdown, \"## Implementation `i` for `int`\");\n+    log(error, markdown);\n+    assert str::contains(markdown, \"## Implementation `i for int`\");\n }\n \n #[test]\n fn should_write_impl_header_with_iface() {\n     let markdown = test::render(\"impl i of j for int { fn a() { } }\");\n-    assert str::contains(markdown, \"## Implementation `i` of `j` for `int`\");\n+    assert str::contains(markdown, \"## Implementation `i of j for int`\");\n }\n \n #[test]\n@@ -793,7 +841,7 @@ fn write_type(\n     ctxt: ctxt,\n     doc: doc::tydoc\n ) {\n-    write_header(ctxt, h2, #fmt(\"Type `%s`\", doc.name()));\n+    write_header(ctxt, h2, doc::tytag(doc));\n     write_sig(ctxt, doc.sig);\n     write_brief(ctxt, doc.brief());\n     write_desc(ctxt, doc.desc());\n@@ -881,7 +929,7 @@ mod test {\n             let doc = extract::from_srv(srv, \"belch\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n             let markdown = write_markdown_str(doc);\n-            assert str::contains(markdown, \"# Crate belch\");\n+            assert str::contains(markdown, \"# Crate `belch`\");\n         }\n     }\n "}]}