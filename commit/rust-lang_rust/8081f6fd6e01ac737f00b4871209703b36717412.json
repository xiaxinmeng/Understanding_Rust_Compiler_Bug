{"sha": "8081f6fd6e01ac737f00b4871209703b36717412", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwODFmNmZkNmUwMWFjNzM3ZjAwYjQ4NzEyMDk3MDNiMzY3MTc0MTI=", "commit": {"author": {"name": "HMPerson1", "email": "hmperson1@gmail.com", "date": "2018-01-18T22:02:18Z"}, "committer": {"name": "HMPerson1", "email": "hmperson1@gmail.com", "date": "2018-01-18T22:04:26Z"}, "message": "Replace `is_unit_expr`", "tree": {"sha": "335d16705224ee3324256a7c54a94914949ddb7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/335d16705224ee3324256a7c54a94914949ddb7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8081f6fd6e01ac737f00b4871209703b36717412", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFIBAABCAAyFiEE30PRORiHa0gkBHJnH7R33dJ4Ic4FAlphGeoUHGhtcGVyc29u\nMUBnbWFpbC5jb20ACgkQH7R33dJ4Ic6CuAgAviXvjzRgxax+9P8apUqx5xYYgkEg\nH1F3UrFyfeXuJtTJ0pamlAJmejScZW63Sc+78NgsdfY1YsvxezCqOWQoxkXZFISX\nzQMGi3apZWQsgf277n12JOVT/j/hSdnQHC7ZsqISkFUWaEymAq6PsDQV2fB9KqLo\nlaDPdbNKij9wtk4colT084tOCBY+Gm8MN4KSgvWg1PB435mmfUv/LQ/VBWj2wJVp\nQRysOog5gatTvxQs+vhZb7So9wP85v8ZgW435FK/fBxB79YBwK4wh+PY+vn1YfEA\nmvtBxMd7qmyTCD1on5YecimsGog64AFbqE/4RnIUIwSJ4x+blDWL8cuXlw==\n=uUv5\n-----END PGP SIGNATURE-----", "payload": "tree 335d16705224ee3324256a7c54a94914949ddb7a\nparent 10c96e50c3d2ef2977e0338cf3fae6384c77a331\nauthor HMPerson1 <hmperson1@gmail.com> 1516312938 -0500\ncommitter HMPerson1 <hmperson1@gmail.com> 1516313066 -0500\n\nReplace `is_unit_expr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8081f6fd6e01ac737f00b4871209703b36717412", "html_url": "https://github.com/rust-lang/rust/commit/8081f6fd6e01ac737f00b4871209703b36717412", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8081f6fd6e01ac737f00b4871209703b36717412/comments", "author": {"login": "HMPerson1", "id": 2219904, "node_id": "MDQ6VXNlcjIyMTk5MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2219904?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HMPerson1", "html_url": "https://github.com/HMPerson1", "followers_url": "https://api.github.com/users/HMPerson1/followers", "following_url": "https://api.github.com/users/HMPerson1/following{/other_user}", "gists_url": "https://api.github.com/users/HMPerson1/gists{/gist_id}", "starred_url": "https://api.github.com/users/HMPerson1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HMPerson1/subscriptions", "organizations_url": "https://api.github.com/users/HMPerson1/orgs", "repos_url": "https://api.github.com/users/HMPerson1/repos", "events_url": "https://api.github.com/users/HMPerson1/events{/privacy}", "received_events_url": "https://api.github.com/users/HMPerson1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HMPerson1", "id": 2219904, "node_id": "MDQ6VXNlcjIyMTk5MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2219904?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HMPerson1", "html_url": "https://github.com/HMPerson1", "followers_url": "https://api.github.com/users/HMPerson1/followers", "following_url": "https://api.github.com/users/HMPerson1/following{/other_user}", "gists_url": "https://api.github.com/users/HMPerson1/gists{/gist_id}", "starred_url": "https://api.github.com/users/HMPerson1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HMPerson1/subscriptions", "organizations_url": "https://api.github.com/users/HMPerson1/orgs", "repos_url": "https://api.github.com/users/HMPerson1/repos", "events_url": "https://api.github.com/users/HMPerson1/events{/privacy}", "received_events_url": "https://api.github.com/users/HMPerson1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10c96e50c3d2ef2977e0338cf3fae6384c77a331", "url": "https://api.github.com/repos/rust-lang/rust/commits/10c96e50c3d2ef2977e0338cf3fae6384c77a331", "html_url": "https://github.com/rust-lang/rust/commit/10c96e50c3d2ef2977e0338cf3fae6384c77a331"}], "stats": {"total": 582, "additions": 248, "deletions": 334}, "files": [{"sha": "90e2ef760f752171f5e38cb6dfb505463dd3a066", "filename": "clippy_lints/src/is_unit_expr.rs", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/10c96e50c3d2ef2977e0338cf3fae6384c77a331/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c96e50c3d2ef2977e0338cf3fae6384c77a331/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fis_unit_expr.rs?ref=10c96e50c3d2ef2977e0338cf3fae6384c77a331", "patch": "@@ -1,140 +0,0 @@\n-use rustc::lint::*;\n-use syntax::ast::*;\n-use syntax::ext::quote::rt::Span;\n-use utils::{span_lint, span_note_and_lint};\n-\n-/// **What it does:** Checks for\n-///  - () being assigned to a variable\n-///  - () being passed to a function\n-///\n-/// **Why is this bad?** It is extremely unlikely that a user intended to\n-/// assign '()' to valiable. Instead,\n-/// Unit is what a block evaluates to when it returns nothing. This is\n-/// typically caused by a trailing\n-///   unintended semicolon.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// * `let x = {\"foo\" ;}` when the user almost certainly intended `let x\n-/// ={\"foo\"}`\n-declare_lint! {\n-    pub UNIT_EXPR,\n-    Warn,\n-    \"unintended assignment or use of a unit typed value\"\n-}\n-\n-#[derive(Copy, Clone)]\n-enum UnitCause {\n-    SemiColon,\n-    EmptyBlock,\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnitExpr;\n-\n-impl LintPass for UnitExpr {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNIT_EXPR)\n-    }\n-}\n-\n-impl EarlyLintPass for UnitExpr {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n-        if let ExprKind::Assign(ref _left, ref right) = expr.node {\n-            check_for_unit(cx, right);\n-        }\n-        if let ExprKind::MethodCall(ref _left, ref args) = expr.node {\n-            for arg in args {\n-                check_for_unit(cx, arg);\n-            }\n-        }\n-        if let ExprKind::Call(_, ref args) = expr.node {\n-            for arg in args {\n-                check_for_unit(cx, arg);\n-            }\n-        }\n-    }\n-\n-    fn check_stmt(&mut self, cx: &EarlyContext, stmt: &Stmt) {\n-        if let StmtKind::Local(ref local) = stmt.node {\n-            if local.pat.node == PatKind::Wild {\n-                return;\n-            }\n-            if let Some(ref expr) = local.init {\n-                check_for_unit(cx, expr);\n-            }\n-        }\n-    }\n-}\n-\n-fn check_for_unit(cx: &EarlyContext, expr: &Expr) {\n-    match is_unit_expr(expr) {\n-        Some((span, UnitCause::SemiColon)) => span_note_and_lint(\n-            cx,\n-            UNIT_EXPR,\n-            expr.span,\n-            \"This expression evaluates to the Unit type ()\",\n-            span,\n-            \"Consider removing the trailing semicolon\",\n-        ),\n-        Some((_span, UnitCause::EmptyBlock)) => span_lint(\n-            cx,\n-            UNIT_EXPR,\n-            expr.span,\n-            \"This expression evaluates to the Unit type ()\",\n-        ),\n-        None => (),\n-    }\n-}\n-\n-fn is_unit_expr(expr: &Expr) -> Option<(Span, UnitCause)> {\n-    match expr.node {\n-        ExprKind::Block(ref block) => match check_last_stmt_in_block(block) {\n-            Some(UnitCause::SemiColon) =>\n-                Some((block.stmts[block.stmts.len() - 1].span, UnitCause::SemiColon)),\n-            Some(UnitCause::EmptyBlock) =>\n-                Some((block.span, UnitCause::EmptyBlock)),\n-            None => None\n-        }\n-        ExprKind::If(_, ref then, ref else_) => {\n-            let check_then = check_last_stmt_in_block(then);\n-            if let Some(ref else_) = *else_ {\n-                let check_else = is_unit_expr(else_);\n-                if let Some(ref expr_else) = check_else {\n-                    return Some(*expr_else);\n-                }\n-            }\n-            match check_then {\n-                Some(c) => Some((expr.span, c)),\n-                None => None,\n-            }\n-        },\n-        ExprKind::Match(ref _pattern, ref arms) => {\n-            for arm in arms {\n-                if let Some(r) = is_unit_expr(&arm.body) {\n-                    return Some(r);\n-                }\n-            }\n-            None\n-        },\n-        _ => None,\n-    }\n-}\n-\n-fn check_last_stmt_in_block(block: &Block) -> Option<UnitCause> {\n-    if block.stmts.is_empty() { return Some(UnitCause::EmptyBlock); }\n-    let final_stmt = &block.stmts[block.stmts.len() - 1];\n-\n-\n-    // Made a choice here to risk false positives on divergent macro invocations\n-    // like `panic!()`\n-    match final_stmt.node {\n-        StmtKind::Expr(_) => None,\n-        StmtKind::Semi(ref expr) => match expr.node {\n-            ExprKind::Break(_, _) | ExprKind::Continue(_) | ExprKind::Ret(_) => None,\n-            _ => Some(UnitCause::SemiColon),\n-        },\n-        _ => Some(UnitCause::SemiColon), // not sure what's happening here\n-    }\n-}"}, {"sha": "c14724840784b748902642b24172f7206b62a9a2", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8081f6fd6e01ac737f00b4871209703b36717412/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081f6fd6e01ac737f00b4871209703b36717412/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8081f6fd6e01ac737f00b4871209703b36717412", "patch": "@@ -111,7 +111,6 @@ pub mod if_not_else;\n pub mod infinite_iter;\n pub mod int_plus_one;\n pub mod invalid_ref;\n-pub mod is_unit_expr;\n pub mod items_after_statements;\n pub mod large_enum_variant;\n pub mod len_zero;\n@@ -268,7 +267,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box approx_const::Pass);\n     reg.register_late_lint_pass(box misc::Pass);\n     reg.register_early_lint_pass(box precedence::Precedence);\n-    reg.register_early_lint_pass(box is_unit_expr::UnitExpr);\n     reg.register_early_lint_pass(box needless_continue::NeedlessContinue);\n     reg.register_late_lint_pass(box eta_reduction::EtaPass);\n     reg.register_late_lint_pass(box identity_op::IdentityOp);\n@@ -365,6 +363,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_early_lint_pass(box const_static_lifetime::StaticConst);\n     reg.register_late_lint_pass(box fallible_impl_from::FallibleImplFrom);\n     reg.register_late_lint_pass(box replace_consts::ReplaceConsts);\n+    reg.register_late_lint_pass(box types::UnitArg);\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -478,7 +477,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         if_let_redundant_pattern_matching::IF_LET_REDUNDANT_PATTERN_MATCHING,\n         infinite_iter::INFINITE_ITER,\n         invalid_ref::INVALID_REF,\n-        is_unit_expr::UNIT_EXPR,\n         large_enum_variant::LARGE_ENUM_VARIANT,\n         len_zero::LEN_WITHOUT_IS_EMPTY,\n         len_zero::LEN_ZERO,\n@@ -607,6 +605,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         types::LINKEDLIST,\n         types::TYPE_COMPLEXITY,\n         types::UNIT_CMP,\n+        types::UNIT_ARG,\n         types::UNNECESSARY_CAST,\n         unicode::ZERO_WIDTH_SPACE,\n         unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,"}, {"sha": "8d88217b924a467f35c1fa525ea80934c848317c", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 123, "deletions": 39, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/8081f6fd6e01ac737f00b4871209703b36717412/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081f6fd6e01ac737f00b4871209703b36717412/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=8081f6fd6e01ac737f00b4871209703b36717412", "patch": "@@ -322,25 +322,22 @@ declare_lint! {\n \n fn check_let_unit(cx: &LateContext, decl: &Decl) {\n     if let DeclLocal(ref local) = decl.node {\n-        match cx.tables.pat_ty(&local.pat).sty {\n-            ty::TyTuple(slice, _) if slice.is_empty() => {\n-                if in_external_macro(cx, decl.span) || in_macro(local.pat.span) {\n-                    return;\n-                }\n-                if higher::is_from_for_desugar(decl) {\n-                    return;\n-                }\n-                span_lint(\n-                    cx,\n-                    LET_UNIT_VALUE,\n-                    decl.span,\n-                    &format!(\n-                        \"this let-binding has unit value. Consider omitting `let {} =`\",\n-                        snippet(cx, local.pat.span, \"..\")\n-                    ),\n-                );\n-            },\n-            _ => (),\n+        if is_unit(cx.tables.pat_ty(&local.pat)) {\n+            if in_external_macro(cx, decl.span) || in_macro(local.pat.span) {\n+                return;\n+            }\n+            if higher::is_from_for_desugar(decl) {\n+                return;\n+            }\n+            span_lint(\n+                cx,\n+                LET_UNIT_VALUE,\n+                decl.span,\n+                &format!(\n+                    \"this let-binding has unit value. Consider omitting `let {} =`\",\n+                    snippet(cx, local.pat.span, \"..\")\n+                ),\n+            );\n         }\n     }\n }\n@@ -395,31 +392,118 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n         }\n         if let ExprBinary(ref cmp, ref left, _) = expr.node {\n             let op = cmp.node;\n-            if op.is_comparison() {\n-                match cx.tables.expr_ty(left).sty {\n-                    ty::TyTuple(slice, _) if slice.is_empty() => {\n-                        let result = match op {\n-                            BiEq | BiLe | BiGe => \"true\",\n-                            _ => \"false\",\n-                        };\n-                        span_lint(\n-                            cx,\n-                            UNIT_CMP,\n-                            expr.span,\n-                            &format!(\n-                                \"{}-comparison of unit values detected. This will always be {}\",\n-                                op.as_str(),\n-                                result\n-                            ),\n-                        );\n-                    },\n-                    _ => (),\n-                }\n+            if op.is_comparison() && is_unit(cx.tables.expr_ty(left)) {\n+                let result = match op {\n+                    BiEq | BiLe | BiGe => \"true\",\n+                    _ => \"false\",\n+                };\n+                span_lint(\n+                    cx,\n+                    UNIT_CMP,\n+                    expr.span,\n+                    &format!(\n+                        \"{}-comparison of unit values detected. This will always be {}\",\n+                        op.as_str(),\n+                        result\n+                    ),\n+                );\n             }\n         }\n     }\n }\n \n+/// **What it does:** Checks for passing a unit value as an argument to a function without using a unit literal (`()`).\n+///\n+/// **Why is this bad?** This is likely the result of an accidental semicolon.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// foo({\n+///   let a = bar();\n+///   baz(a);\n+/// })\n+/// ```\n+declare_lint! {\n+    pub UNIT_ARG,\n+    Warn,\n+    \"passing unit to a function\"\n+}\n+\n+pub struct UnitArg;\n+\n+impl LintPass for UnitArg {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNIT_ARG)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        if in_macro(expr.span) {\n+            return;\n+        }\n+        match expr.node {\n+            ExprCall(_, ref args) | ExprMethodCall(_, _, ref args) => {\n+                for arg in args {\n+                    if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n+                        let map = &cx.tcx.hir;\n+                        // apparently stuff in the desugaring of `?` can trigger this\n+                        // so check for that here\n+                        // only the calls to `Try::from_error` is marked as desugared,\n+                        // so we need to check both the current Expr and its parent.\n+                        if !is_questionmark_desugar_marked_call(expr) {\n+                            if_chain!{\n+                                let opt_parent_node = map.find(map.get_parent_node(expr.id));\n+                                if let Some(hir::map::NodeExpr(parent_expr)) = opt_parent_node;\n+                                if is_questionmark_desugar_marked_call(parent_expr);\n+                                then {}\n+                                else {\n+                                    // `expr` and `parent_expr` where _both_ not from\n+                                    // desugaring `?`, so lint\n+                                    span_lint_and_sugg(\n+                                        cx,\n+                                        UNIT_ARG,\n+                                        arg.span,\n+                                        \"passing a unit value to a function\",\n+                                        \"if you intended to pass a unit value, use a unit literal instead\",\n+                                        \"()\".to_string(),\n+                                    );\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+}\n+\n+fn is_questionmark_desugar_marked_call(expr: &Expr) -> bool {\n+    use syntax_pos::hygiene::CompilerDesugaringKind;\n+    if let ExprCall(ref callee, _) = expr.node {\n+        callee.span.is_compiler_desugaring(CompilerDesugaringKind::QuestionMark)\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_unit(ty: Ty) -> bool {\n+    match ty.sty {\n+        ty::TyTuple(slice, _) if slice.is_empty() => true,\n+        _ => false,\n+    }\n+}\n+\n+fn is_unit_literal(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprTup(ref slice) if slice.is_empty() => true,\n+        _ => false,\n+    }\n+}\n+\n pub struct CastPass;\n \n /// **What it does:** Checks for casts from any numerical to a float type where"}, {"sha": "6c8f108d9f6e4089db623854e38a7c4515ca6115", "filename": "tests/ui/is_unit_expr.rs", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/10c96e50c3d2ef2977e0338cf3fae6384c77a331/tests%2Fui%2Fis_unit_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c96e50c3d2ef2977e0338cf3fae6384c77a331/tests%2Fui%2Fis_unit_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fis_unit_expr.rs?ref=10c96e50c3d2ef2977e0338cf3fae6384c77a331", "patch": "@@ -1,79 +0,0 @@\n-\n-\n-#![warn(unit_expr)]\n-#[allow(unused_variables)]\n-\n-fn main() {\n-    // lint should note removing the semicolon from \"baz\"\n-    let x = {\n-        \"foo\";\n-        \"baz\";\n-    };\n-\n-\n-    // lint should ignore false positive.\n-    let y = if true {\n-        \"foo\"\n-    } else {\n-        return;\n-    };\n-\n-    // lint should note removing semicolon from \"bar\"\n-    let z = if true {\n-        \"foo\";\n-    } else {\n-        \"bar\";\n-    };\n-\n-\n-    let a1 = Some(5);\n-\n-    // lint should ignore false positive\n-    let a2 = match a1 {\n-        Some(x) => x,\n-        _ => {\n-            return;\n-        },\n-    };\n-\n-    // lint should note removing the semicolon after `x;`\n-    let a3 = match a1 {\n-        Some(x) => {\n-            x;\n-        },\n-        _ => {\n-            0;\n-        },\n-    };\n-    \n-    loop {\n-        let a2 = match a1 {\n-            Some(x) => x,\n-            _ => {\n-                break;\n-            },\n-        };\n-        let a2 = match a1 {\n-            Some(x) => x,\n-            _ => {\n-                continue;\n-            },\n-        };\n-    }\n-}\n-\n-pub fn foo() -> i32 {\n-    let a2 = match None {\n-        Some(x) => x,\n-        _ => {\n-            return 42;\n-        },\n-    };\n-    55\n-}\n-\n-pub fn issue_2160() {\n-    let x1 = {};\n-    let x2 = if true {} else {};\n-    let x3 = match None { Some(_) => {}, None => {}, };\n-}"}, {"sha": "7a16fe971f3e57463972da8b03bb196d34f78521", "filename": "tests/ui/is_unit_expr.stderr", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/10c96e50c3d2ef2977e0338cf3fae6384c77a331/tests%2Fui%2Fis_unit_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10c96e50c3d2ef2977e0338cf3fae6384c77a331/tests%2Fui%2Fis_unit_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fis_unit_expr.stderr?ref=10c96e50c3d2ef2977e0338cf3fae6384c77a331", "patch": "@@ -1,73 +0,0 @@\n-error: This expression evaluates to the Unit type ()\n-  --> $DIR/is_unit_expr.rs:8:13\n-   |\n-8  |       let x = {\n-   |  _____________^\n-9  | |         \"foo\";\n-10 | |         \"baz\";\n-11 | |     };\n-   | |_____^\n-   |\n-   = note: `-D unit-expr` implied by `-D warnings`\n-note: Consider removing the trailing semicolon\n-  --> $DIR/is_unit_expr.rs:10:9\n-   |\n-10 |         \"baz\";\n-   |         ^^^^^^\n-\n-error: This expression evaluates to the Unit type ()\n-  --> $DIR/is_unit_expr.rs:22:13\n-   |\n-22 |       let z = if true {\n-   |  _____________^\n-23 | |         \"foo\";\n-24 | |     } else {\n-25 | |         \"bar\";\n-26 | |     };\n-   | |_____^\n-   |\n-note: Consider removing the trailing semicolon\n-  --> $DIR/is_unit_expr.rs:25:9\n-   |\n-25 |         \"bar\";\n-   |         ^^^^^^\n-\n-error: This expression evaluates to the Unit type ()\n-  --> $DIR/is_unit_expr.rs:40:14\n-   |\n-40 |       let a3 = match a1 {\n-   |  ______________^\n-41 | |         Some(x) => {\n-42 | |             x;\n-43 | |         },\n-...  |\n-46 | |         },\n-47 | |     };\n-   | |_____^\n-   |\n-note: Consider removing the trailing semicolon\n-  --> $DIR/is_unit_expr.rs:42:13\n-   |\n-42 |             x;\n-   |             ^^\n-\n-error: This expression evaluates to the Unit type ()\n-  --> $DIR/is_unit_expr.rs:76:14\n-   |\n-76 |     let x1 = {};\n-   |              ^^\n-\n-error: This expression evaluates to the Unit type ()\n-  --> $DIR/is_unit_expr.rs:77:14\n-   |\n-77 |     let x2 = if true {} else {};\n-   |              ^^^^^^^^^^^^^^^^^^\n-\n-error: This expression evaluates to the Unit type ()\n-  --> $DIR/is_unit_expr.rs:78:14\n-   |\n-78 |     let x3 = match None { Some(_) => {}, None => {}, };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 6 previous errors\n-"}, {"sha": "8f290446b5e42a990fec717fbc0ed1e3a0861773", "filename": "tests/ui/unit_arg.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8081f6fd6e01ac737f00b4871209703b36717412/tests%2Fui%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8081f6fd6e01ac737f00b4871209703b36717412/tests%2Fui%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.rs?ref=8081f6fd6e01ac737f00b4871209703b36717412", "patch": "@@ -0,0 +1,55 @@\n+#![warn(unit_arg)]\n+#![allow(no_effect)]\n+\n+use std::fmt::Debug;\n+\n+fn foo<T: Debug>(t: T) {\n+    println!(\"{:?}\", t);\n+}\n+\n+fn foo3<T1: Debug, T2: Debug, T3: Debug>(t1: T1, t2: T2, t3: T3) {\n+    println!(\"{:?}, {:?}, {:?}\", t1, t2, t3);\n+}\n+\n+struct Bar;\n+\n+impl Bar {\n+    fn bar<T: Debug>(&self, t: T) {\n+        println!(\"{:?}\", t);\n+    }\n+}\n+\n+fn bad() {\n+    foo({});\n+    foo({ 1; });\n+    foo(foo(1));\n+    foo({\n+        foo(1);\n+        foo(2);\n+    });\n+    foo3({}, 2, 2);\n+    let b = Bar;\n+    b.bar({ 1; });\n+}\n+\n+fn ok() {\n+    foo(());\n+    foo(1);\n+    foo({ 1 });\n+    foo3(\"a\", 3, vec![3]);\n+    let b = Bar;\n+    b.bar({ 1 });\n+    b.bar(());\n+    question_mark();\n+}\n+\n+fn question_mark() -> Result<(), ()> {\n+    Ok(Ok(())?)?;\n+    Ok(Ok(()))??;\n+    Ok(())\n+}\n+\n+fn main() {\n+    bad();\n+    ok();\n+}"}, {"sha": "ca48f39263bf5539b33f02441c1e80cb15561893", "filename": "tests/ui/unit_arg.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8081f6fd6e01ac737f00b4871209703b36717412/tests%2Fui%2Funit_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8081f6fd6e01ac737f00b4871209703b36717412/tests%2Fui%2Funit_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.stderr?ref=8081f6fd6e01ac737f00b4871209703b36717412", "patch": "@@ -0,0 +1,68 @@\n+error: passing a unit value to a function\n+  --> $DIR/unit_arg.rs:23:9\n+   |\n+23 |     foo({});\n+   |         ^^\n+   |\n+   = note: `-D unit-arg` implied by `-D warnings`\n+help: if you intended to pass a unit value, use a unit literal instead\n+   |\n+23 |     foo(());\n+   |         ^^\n+\n+error: passing a unit value to a function\n+  --> $DIR/unit_arg.rs:24:9\n+   |\n+24 |     foo({ 1; });\n+   |         ^^^^^^\n+help: if you intended to pass a unit value, use a unit literal instead\n+   |\n+24 |     foo(());\n+   |         ^^\n+\n+error: passing a unit value to a function\n+  --> $DIR/unit_arg.rs:25:9\n+   |\n+25 |     foo(foo(1));\n+   |         ^^^^^^\n+help: if you intended to pass a unit value, use a unit literal instead\n+   |\n+25 |     foo(());\n+   |         ^^\n+\n+error: passing a unit value to a function\n+  --> $DIR/unit_arg.rs:26:9\n+   |\n+26 |       foo({\n+   |  _________^\n+27 | |         foo(1);\n+28 | |         foo(2);\n+29 | |     });\n+   | |_____^\n+help: if you intended to pass a unit value, use a unit literal instead\n+   |\n+26 |     foo(());\n+   |         ^^\n+\n+error: passing a unit value to a function\n+  --> $DIR/unit_arg.rs:30:10\n+   |\n+30 |     foo3({}, 2, 2);\n+   |          ^^\n+help: if you intended to pass a unit value, use a unit literal instead\n+   |\n+30 |     foo3((), 2, 2);\n+   |          ^^\n+\n+error: passing a unit value to a function\n+  --> $DIR/unit_arg.rs:32:11\n+   |\n+32 |     b.bar({ 1; });\n+   |           ^^^^^^\n+help: if you intended to pass a unit value, use a unit literal instead\n+   |\n+32 |     b.bar(());\n+   |           ^^\n+\n+error: aborting due to 6 previous errors\n+"}]}