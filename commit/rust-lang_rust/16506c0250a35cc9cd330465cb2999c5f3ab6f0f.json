{"sha": "16506c0250a35cc9cd330465cb2999c5f3ab6f0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NTA2YzAyNTBhMzVjYzljZDMzMDQ2NWNiMjk5OWM1ZjNhYjZmMGY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-06T02:27:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-06T02:28:34Z"}, "message": "librustc: Make a context including the method map in check_alt, in preparation for moving check_legality_of_move_bindings there. rs=refactoring", "tree": {"sha": "b8aa53568f584ad40fcbdf6de4942d80d8faa6ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8aa53568f584ad40fcbdf6de4942d80d8faa6ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16506c0250a35cc9cd330465cb2999c5f3ab6f0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16506c0250a35cc9cd330465cb2999c5f3ab6f0f", "html_url": "https://github.com/rust-lang/rust/commit/16506c0250a35cc9cd330465cb2999c5f3ab6f0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16506c0250a35cc9cd330465cb2999c5f3ab6f0f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fc802233b8b8a722fa9bbd5e1cccd0a0fd417f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fc802233b8b8a722fa9bbd5e1cccd0a0fd417f3", "html_url": "https://github.com/rust-lang/rust/commit/1fc802233b8b8a722fa9bbd5e1cccd0a0fd417f3"}], "stats": {"total": 190, "additions": 103, "deletions": 87}, "files": [{"sha": "8f0ff571f032b99e84583e009ab27f3ffc82478a", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16506c0250a35cc9cd330465cb2999c5f3ab6f0f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16506c0250a35cc9cd330465cb2999c5f3ab6f0f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=16506c0250a35cc9cd330465cb2999c5f3ab6f0f", "patch": "@@ -249,7 +249,7 @@ fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n              middle::check_loop::check_crate(ty_cx, crate));\n \n         time(time_passes, ~\"alt checking\", ||\n-             middle::check_alt::check_crate(ty_cx, crate));\n+             middle::check_alt::check_crate(ty_cx, method_map, crate));\n \n         time(time_passes, ~\"mode computation\", ||\n              middle::mode::compute_modes(ty_cx, method_map, crate));"}, {"sha": "840107227f0d813092cd8b5e936e47186a20e71c", "filename": "src/librustc/middle/check_alt.rs", "status": "modified", "additions": 101, "deletions": 85, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/16506c0250a35cc9cd330465cb2999c5f3ab6f0f/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16506c0250a35cc9cd330465cb2999c5f3ab6f0f/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs?ref=16506c0250a35cc9cd330465cb2999c5f3ab6f0f", "patch": "@@ -19,62 +19,71 @@ use pat_util::*;\n use syntax::visit;\n use middle::ty;\n use middle::ty::*;\n+use middle::typeck::method_map;\n use std::map::HashMap;\n \n-fn check_crate(tcx: ty::ctxt, crate: @crate) {\n+struct AltCheckCtxt {\n+    tcx: ty::ctxt,\n+    method_map: method_map,\n+}\n+\n+fn check_crate(tcx: ty::ctxt, method_map: method_map, crate: @crate) {\n+    let cx = @AltCheckCtxt { tcx: tcx, method_map: method_map };\n     visit::visit_crate(*crate, (), visit::mk_vt(@{\n-        visit_expr: |a,b,c| check_expr(tcx, a, b, c),\n-        visit_local: |a,b,c| check_local(tcx, a, b, c),\n+        visit_expr: |a,b,c| check_expr(cx, a, b, c),\n+        visit_local: |a,b,c| check_local(cx, a, b, c),\n         visit_fn: |kind, decl, body, sp, id, e, v|\n-            check_fn(tcx, kind, decl, body, sp, id, e, v),\n+            check_fn(cx, kind, decl, body, sp, id, e, v),\n         .. *visit::default_visitor::<()>()\n     }));\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n+fn check_expr(cx: @AltCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n-        check_arms(tcx, (*arms));\n+        check_arms(cx, (*arms));\n         /* Check for exhaustiveness */\n          // Check for empty enum, because is_useful only works on inhabited\n          // types.\n-       let pat_ty = node_id_to_type(tcx, scrut.id);\n+       let pat_ty = node_id_to_type(cx.tcx, scrut.id);\n        if (*arms).is_empty() {\n-           if !type_is_empty(tcx, pat_ty) {\n+           if !type_is_empty(cx.tcx, pat_ty) {\n                // We know the type is inhabited, so this must be wrong\n-               tcx.sess.span_err(ex.span, fmt!(\"non-exhaustive patterns: \\\n-                             type %s is non-empty\", ty_to_str(tcx, pat_ty)));\n+               cx.tcx.sess.span_err(ex.span, fmt!(\"non-exhaustive patterns: \\\n+                            type %s is non-empty\",\n+                            ty_to_str(cx.tcx, pat_ty)));\n            }\n            // If the type *is* empty, it's vacuously exhaustive\n            return;\n        }\n        match ty::get(pat_ty).sty {\n           ty_enum(did, _) => {\n-              if (*enum_variants(tcx, did)).is_empty() && (*arms).is_empty() {\n+              if (*enum_variants(cx.tcx, did)).is_empty() &&\n+                    (*arms).is_empty() {\n \n                return;\n             }\n           }\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n        let arms = vec::concat(vec::filter_map((*arms), unguarded_pat));\n-       check_exhaustive(tcx, ex.span, arms);\n+       check_exhaustive(cx, ex.span, arms);\n      }\n      _ => ()\n     }\n }\n \n // Check for unreachable patterns\n-fn check_arms(tcx: ty::ctxt, arms: ~[arm]) {\n+fn check_arms(cx: @AltCheckCtxt, arms: ~[arm]) {\n     let mut seen = ~[];\n     for arms.each |arm| {\n         for arm.pats.each |pat| {\n             let v = ~[*pat];\n-            match is_useful(tcx, seen, v) {\n+            match is_useful(cx, seen, v) {\n               not_useful => {\n-                tcx.sess.span_err(pat.span, ~\"unreachable pattern\");\n+                cx.tcx.sess.span_err(pat.span, ~\"unreachable pattern\");\n               }\n               _ => ()\n             }\n@@ -90,9 +99,9 @@ fn raw_pat(p: @pat) -> @pat {\n     }\n }\n \n-fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n+fn check_exhaustive(cx: @AltCheckCtxt, sp: span, pats: ~[@pat]) {\n     assert(pats.is_not_empty());\n-    let ext = match is_useful(tcx, vec::map(pats, |p| ~[*p]), ~[wild()]) {\n+    let ext = match is_useful(cx, vec::map(pats, |p| ~[*p]), ~[wild()]) {\n       not_useful => return, // This is good, wildcard pattern isn't reachable\n       useful_ => None,\n       useful(ty, ref ctor) => {\n@@ -107,9 +116,9 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n           ty::ty_enum(id, _) => {\n               let vid = match (*ctor) { variant(id) => id,\n               _ => fail ~\"check_exhaustive: non-variant ctor\" };\n-            match vec::find(*ty::enum_variants(tcx, id),\n+            match vec::find(*ty::enum_variants(cx.tcx, id),\n                                 |v| v.id == vid) {\n-                Some(v) => Some(tcx.sess.str_of(v.name)),\n+                Some(v) => Some(cx.tcx.sess.str_of(v.name)),\n               None => fail ~\"check_exhaustive: bad variant in ctor\"\n             }\n           }\n@@ -121,7 +130,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n       Some(ref s) => ~\": \" + (*s) + ~\" not covered\",\n       None => ~\"\"\n     };\n-    tcx.sess.span_err(sp, msg);\n+    cx.tcx.sess.span_err(sp, msg);\n }\n \n type matrix = ~[~[@pat]];\n@@ -167,93 +176,95 @@ impl ctor : cmp::Eq {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n+fn is_useful(cx: @AltCheckCtxt, m: matrix, v: ~[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n     let real_pat = match vec::find(m, |r| r[0].id != 0) {\n       Some(r) => r[0], None => v[0]\n     };\n-    let left_ty = if real_pat.id == 0 { ty::mk_nil(tcx) }\n-                  else { ty::node_id_to_type(tcx, real_pat.id) };\n+    let left_ty = if real_pat.id == 0 { ty::mk_nil(cx.tcx) }\n+                  else { ty::node_id_to_type(cx.tcx, real_pat.id) };\n \n-    match pat_ctor_id(tcx, v[0]) {\n+    match pat_ctor_id(cx, v[0]) {\n       None => {\n-        match missing_ctor(tcx, m, left_ty) {\n+        match missing_ctor(cx, m, left_ty) {\n           None => {\n             match ty::get(left_ty).sty {\n               ty::ty_bool => {\n-                match is_useful_specialized(tcx, m, v, val(const_bool(true)),\n-                                          0u, left_ty){\n+                match is_useful_specialized(cx, m, v,\n+                                            val(const_bool(true)),\n+                                            0u, left_ty){\n                   not_useful => {\n-                    is_useful_specialized(tcx, m, v, val(const_bool(false)),\n+                    is_useful_specialized(cx, m, v,\n+                                          val(const_bool(false)),\n                                           0u, left_ty)\n                   }\n                   ref u => (*u)\n                 }\n               }\n               ty::ty_enum(eid, _) => {\n-                for (*ty::enum_variants(tcx, eid)).each |va| {\n-                    match is_useful_specialized(tcx, m, v, variant(va.id),\n-                                              va.args.len(), left_ty) {\n+                for (*ty::enum_variants(cx.tcx, eid)).each |va| {\n+                    match is_useful_specialized(cx, m, v, variant(va.id),\n+                                                va.args.len(), left_ty) {\n                       not_useful => (),\n                       ref u => return (*u)\n                     }\n                 }\n                 not_useful\n               }\n               _ => {\n-                let arity = ctor_arity(tcx, single, left_ty);\n-                is_useful_specialized(tcx, m, v, single, arity, left_ty)\n+                let arity = ctor_arity(cx, single, left_ty);\n+                is_useful_specialized(cx, m, v, single, arity, left_ty)\n               }\n             }\n           }\n           Some(ref ctor) => {\n-            match is_useful(tcx, vec::filter_map(m, |r| default(tcx, *r) ),\n-                          vec::tail(v)) {\n+            match is_useful(cx, vec::filter_map(m, |r| default(cx, *r)),\n+                            vec::tail(v)) {\n               useful_ => useful(left_ty, (*ctor)),\n               ref u => (*u)\n             }\n           }\n         }\n       }\n       Some(ref v0_ctor) => {\n-        let arity = ctor_arity(tcx, (*v0_ctor), left_ty);\n-        is_useful_specialized(tcx, m, v, (*v0_ctor), arity, left_ty)\n+        let arity = ctor_arity(cx, (*v0_ctor), left_ty);\n+        is_useful_specialized(cx, m, v, (*v0_ctor), arity, left_ty)\n       }\n     }\n }\n \n-fn is_useful_specialized(tcx: ty::ctxt, m: matrix, v: ~[@pat], ctor: ctor,\n+fn is_useful_specialized(cx: @AltCheckCtxt, m: matrix, v: ~[@pat], ctor: ctor,\n                           arity: uint, lty: ty::t) -> useful {\n-    let ms = vec::filter_map(m, |r| specialize(tcx, *r, ctor, arity, lty) );\n+    let ms = vec::filter_map(m, |r| specialize(cx, *r, ctor, arity, lty));\n     let could_be_useful = is_useful(\n-        tcx, ms, specialize(tcx, v, ctor, arity, lty).get());\n+        cx, ms, specialize(cx, v, ctor, arity, lty).get());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n       ref u => (*u)\n     }\n }\n \n-fn pat_ctor_id(tcx: ty::ctxt, p: @pat) -> Option<ctor> {\n+fn pat_ctor_id(cx: @AltCheckCtxt, p: @pat) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match pat.node {\n       pat_wild => { None }\n       pat_ident(_, _, _) | pat_enum(_, _) => {\n-        match tcx.def_map.find(pat.id) {\n+        match cx.tcx.def_map.find(pat.id) {\n           Some(def_variant(_, id)) => Some(variant(id)),\n           Some(def_const(did)) => {\n-            let const_expr = lookup_const_by_id(tcx, did).get();\n-            Some(val(eval_const_expr(tcx, const_expr)))\n+            let const_expr = lookup_const_by_id(cx.tcx, did).get();\n+            Some(val(eval_const_expr(cx.tcx, const_expr)))\n           }\n           _ => None\n         }\n       }\n-      pat_lit(expr) => { Some(val(eval_const_expr(tcx, expr))) }\n+      pat_lit(expr) => { Some(val(eval_const_expr(cx.tcx, expr))) }\n       pat_range(lo, hi) => {\n-        Some(range(eval_const_expr(tcx, lo), eval_const_expr(tcx, hi)))\n+        Some(range(eval_const_expr(cx.tcx, lo), eval_const_expr(cx.tcx, hi)))\n       }\n       pat_struct(*) => {\n-        match tcx.def_map.find(pat.id) {\n+        match cx.tcx.def_map.find(pat.id) {\n           Some(def_variant(_, id)) => Some(variant(id)),\n           _ => Some(single)\n         }\n@@ -265,12 +276,12 @@ fn pat_ctor_id(tcx: ty::ctxt, p: @pat) -> Option<ctor> {\n     }\n }\n \n-fn is_wild(tcx: ty::ctxt, p: @pat) -> bool {\n+fn is_wild(cx: @AltCheckCtxt, p: @pat) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n       pat_wild => { true }\n       pat_ident(_, _, _) => {\n-        match tcx.def_map.find(pat.id) {\n+        match cx.tcx.def_map.find(pat.id) {\n           Some(def_variant(_, _)) | Some(def_const(*)) => { false }\n           _ => { true }\n         }\n@@ -279,25 +290,28 @@ fn is_wild(tcx: ty::ctxt, p: @pat) -> bool {\n     }\n }\n \n-fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> Option<ctor> {\n+fn missing_ctor(cx: @AltCheckCtxt,\n+                m: matrix,\n+                left_ty: ty::t)\n+             -> Option<ctor> {\n     match ty::get(left_ty).sty {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) | ty::ty_tup(_) |\n       ty::ty_rec(_) | ty::ty_class(*) => {\n         for m.each |r| {\n-            if !is_wild(tcx, r[0]) { return None; }\n+            if !is_wild(cx, r[0]) { return None; }\n         }\n         return Some(single);\n       }\n       ty::ty_enum(eid, _) => {\n         let mut found = ~[];\n         for m.each |r| {\n-            do option::iter(&pat_ctor_id(tcx, r[0])) |id| {\n+            do option::iter(&pat_ctor_id(cx, r[0])) |id| {\n                 if !vec::contains(found, id) {\n                     found.push(*id);\n                 }\n             }\n         }\n-        let variants = ty::enum_variants(tcx, eid);\n+        let variants = ty::enum_variants(cx.tcx, eid);\n         if found.len() != (*variants).len() {\n             for vec::each(*variants) |v| {\n                 if !found.contains(&(variant(v.id))) {\n@@ -311,7 +325,7 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> Option<ctor> {\n       ty::ty_bool => {\n         let mut true_found = false, false_found = false;\n         for m.each |r| {\n-            match pat_ctor_id(tcx, r[0]) {\n+            match pat_ctor_id(cx, r[0]) {\n               None => (),\n               Some(val(const_bool(true))) => true_found = true,\n               Some(val(const_bool(false))) => false_found = true,\n@@ -326,20 +340,20 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> Option<ctor> {\n     }\n }\n \n-fn ctor_arity(tcx: ty::ctxt, ctor: ctor, ty: ty::t) -> uint {\n+fn ctor_arity(cx: @AltCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n     match ty::get(ty).sty {\n       ty::ty_tup(fs) => fs.len(),\n       ty::ty_rec(fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n       ty::ty_enum(eid, _) => {\n           let id = match ctor { variant(id) => id,\n           _ => fail ~\"impossible case\" };\n-        match vec::find(*ty::enum_variants(tcx, eid), |v| v.id == id ) {\n+        match vec::find(*ty::enum_variants(cx.tcx, eid), |v| v.id == id ) {\n             Some(v) => v.args.len(),\n             None => fail ~\"impossible case\"\n         }\n       }\n-      ty::ty_class(cid, _) => ty::lookup_class_fields(tcx, cid).len(),\n+      ty::ty_class(cid, _) => ty::lookup_class_fields(cx.tcx, cid).len(),\n       _ => 0u\n     }\n }\n@@ -348,21 +362,21 @@ fn wild() -> @pat {\n     @{id: 0, node: pat_wild, span: syntax::ast_util::dummy_sp()}\n }\n \n-fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n+fn specialize(cx: @AltCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n               left_ty: ty::t) -> Option<~[@pat]> {\n     let r0 = raw_pat(r[0]);\n     match r0.node {\n       pat_wild => Some(vec::append(vec::from_elem(arity, wild()),\n                                    vec::tail(r))),\n       pat_ident(_, _, _) => {\n-        match tcx.def_map.find(r0.id) {\n+        match cx.tcx.def_map.find(r0.id) {\n           Some(def_variant(_, id)) => {\n             if variant(id) == ctor_id { Some(vec::tail(r)) }\n             else { None }\n           }\n           Some(def_const(did)) => {\n-            let const_expr = lookup_const_by_id(tcx, did).get();\n-            let e_v = eval_const_expr(tcx, const_expr);\n+            let const_expr = lookup_const_by_id(cx.tcx, did).get();\n+            let e_v = eval_const_expr(cx.tcx, const_expr);\n             let match_ = match ctor_id {\n                 val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n                 range(ref c_lo, ref c_hi) => {\n@@ -378,7 +392,7 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         }\n       }\n       pat_enum(_, args) => {\n-        match tcx.def_map.get(r0.id) {\n+        match cx.tcx.def_map.get(r0.id) {\n           def_variant(_, id) if variant(id) == ctor_id => {\n             let args = match args {\n               Some(args) => args,\n@@ -414,7 +428,7 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n       }\n       pat_struct(_, flds, _) => {\n         // Is this a struct or an enum variant?\n-        match tcx.def_map.get(r0.id) {\n+        match cx.tcx.def_map.get(r0.id) {\n             def_variant(_, variant_id) => {\n                 if variant(variant_id) == ctor_id {\n                     // XXX: Is this right? --pcw\n@@ -435,11 +449,13 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n                 match ty::get(left_ty).sty {\n                     ty::ty_class(cid, _) => {\n                         class_id = cid;\n-                        class_fields = ty::lookup_class_fields(tcx, class_id);\n+                        class_fields = ty::lookup_class_fields(cx.tcx,\n+                                                               class_id);\n                     }\n                     _ => {\n-                        tcx.sess.span_bug(r0.span, ~\"struct pattern didn't \\\n-                                                     resolve to a struct\");\n+                        cx.tcx.sess.span_bug(r0.span, ~\"struct pattern \\\n+                                                        didn't resolve to a \\\n+                                                        struct\");\n                     }\n                 }\n                 let args = vec::map(class_fields, |class_field| {\n@@ -456,7 +472,7 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n       pat_box(a) | pat_uniq(a) | pat_region(a) =>\n           Some(vec::append(~[a], vec::tail(r))),\n       pat_lit(expr) => {\n-        let e_v = eval_const_expr(tcx, expr);\n+        let e_v = eval_const_expr(cx.tcx, expr);\n         let match_ = match ctor_id {\n           val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n           range(ref c_lo, ref c_hi) => {\n@@ -475,29 +491,29 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n           single => return Some(vec::tail(r)),\n           _ => fail ~\"type error\"\n         };\n-        let v_lo = eval_const_expr(tcx, lo),\n-            v_hi = eval_const_expr(tcx, hi);\n+        let v_lo = eval_const_expr(cx.tcx, lo),\n+            v_hi = eval_const_expr(cx.tcx, hi);\n         let match_ = compare_const_vals(c_lo, v_lo) >= 0 &&\n                     compare_const_vals(c_hi, v_hi) <= 0;\n         if match_ { Some(vec::tail(r)) } else { None }\n       }\n     }\n }\n \n-fn default(tcx: ty::ctxt, r: ~[@pat]) -> Option<~[@pat]> {\n-    if is_wild(tcx, r[0]) { Some(vec::tail(r)) }\n+fn default(cx: @AltCheckCtxt, r: ~[@pat]) -> Option<~[@pat]> {\n+    if is_wild(cx, r[0]) { Some(vec::tail(r)) }\n     else { None }\n }\n \n-fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n+fn check_local(cx: @AltCheckCtxt, loc: @local, &&s: (), v: visit::vt<()>) {\n     visit::visit_local(loc, s, v);\n-    if is_refutable(tcx, loc.node.pat) {\n-        tcx.sess.span_err(loc.node.pat.span,\n+    if is_refutable(cx, loc.node.pat) {\n+        cx.tcx.sess.span_err(loc.node.pat.span,\n                           ~\"refutable pattern in local binding\");\n     }\n }\n \n-fn check_fn(tcx: ty::ctxt,\n+fn check_fn(cx: @AltCheckCtxt,\n             kind: visit::fn_kind,\n             decl: fn_decl,\n             body: blk,\n@@ -507,17 +523,17 @@ fn check_fn(tcx: ty::ctxt,\n             v: visit::vt<()>) {\n     visit::visit_fn(kind, decl, body, sp, id, s, v);\n     for decl.inputs.each |input| {\n-        if is_refutable(tcx, input.pat) {\n-            tcx.sess.span_err(input.pat.span,\n+        if is_refutable(cx, input.pat) {\n+            cx.tcx.sess.span_err(input.pat.span,\n                               ~\"refutable pattern in function argument\");\n         }\n     }\n }\n \n-fn is_refutable(tcx: ty::ctxt, pat: &pat) -> bool {\n-    match tcx.def_map.find(pat.id) {\n+fn is_refutable(cx: @AltCheckCtxt, pat: &pat) -> bool {\n+    match cx.tcx.def_map.find(pat.id) {\n       Some(def_variant(enum_id, _)) => {\n-        if vec::len(*ty::enum_variants(tcx, enum_id)) != 1u {\n+        if vec::len(*ty::enum_variants(cx.tcx, enum_id)) != 1u {\n             return true;\n         }\n       }\n@@ -528,22 +544,22 @@ fn is_refutable(tcx: ty::ctxt, pat: &pat) -> bool {\n     match pat.node {\n       pat_box(sub) | pat_uniq(sub) | pat_region(sub) |\n       pat_ident(_, _, Some(sub)) => {\n-        is_refutable(tcx, sub)\n+        is_refutable(cx, sub)\n       }\n       pat_wild | pat_ident(_, _, None) => { false }\n       pat_lit(@{node: expr_lit(@{node: lit_nil, _}), _}) => { false } // \"()\"\n       pat_lit(_) | pat_range(_, _) => { true }\n       pat_rec(fields, _) => {\n-        fields.any(|f| is_refutable(tcx, f.pat))\n+        fields.any(|f| is_refutable(cx, f.pat))\n       }\n       pat_struct(_, fields, _) => {\n-        fields.any(|f| is_refutable(tcx, f.pat))\n+        fields.any(|f| is_refutable(cx, f.pat))\n       }\n       pat_tup(elts) => {\n-        elts.any(|elt| is_refutable(tcx, *elt))\n+        elts.any(|elt| is_refutable(cx, *elt))\n       }\n       pat_enum(_, Some(args)) => {\n-        args.any(|a| is_refutable(tcx, *a))\n+        args.any(|a| is_refutable(cx, *a))\n       }\n       pat_enum(_,_) => { false }\n     }"}, {"sha": "d4a0df172e9b089241031d8b742cced92e933670", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16506c0250a35cc9cd330465cb2999c5f3ab6f0f/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/16506c0250a35cc9cd330465cb2999c5f3ab6f0f/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=16506c0250a35cc9cd330465cb2999c5f3ab6f0f", "patch": "@@ -246,7 +246,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n     middle::check_loop::check_crate(ty_cx, crate);\n \n     debug!(\"alt checking\");\n-    middle::check_alt::check_crate(ty_cx, crate);\n+    middle::check_alt::check_crate(ty_cx, method_map, crate);\n \n     debug!(\"liveness checking\");\n     let last_use_map = middle::liveness::check_crate(ty_cx,"}]}