{"sha": "dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjOGFjMjY3OWFhMWM1MmQ1ODYwYTJlNjUxNGNmN2VkODliN2Q0NDU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-09T18:51:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-09T18:51:15Z"}, "message": "Rollup merge of #37229 - nnethercote:FxHasher, r=nikomatsakis\n\nReplace FNV with a faster hash function.\n\nHash table lookups are very hot in rustc profiles and the time taken within `FnvHash` itself is a big part of that. Although FNV is a simple hash, it processes its input one byte at a time. In contrast, Firefox has a homespun hash function that is also simple but works on multiple bytes at a time. So I tried it out and the results are compelling:\n\n```\nfutures-rs-test  4.326s vs  4.212s --> 1.027x faster (variance: 1.001x, 1.007x)\nhelloworld       0.233s vs  0.232s --> 1.004x faster (variance: 1.037x, 1.016x)\nhtml5ever-2016-  5.397s vs  5.210s --> 1.036x faster (variance: 1.009x, 1.006x)\nhyper.0.5.0      5.018s vs  4.905s --> 1.023x faster (variance: 1.007x, 1.006x)\ninflate-0.1.0    4.889s vs  4.872s --> 1.004x faster (variance: 1.012x, 1.007x)\nissue-32062-equ  0.347s vs  0.335s --> 1.035x faster (variance: 1.033x, 1.019x)\nissue-32278-big  1.717s vs  1.622s --> 1.059x faster (variance: 1.027x, 1.028x)\njld-day15-parse  1.537s vs  1.459s --> 1.054x faster (variance: 1.005x, 1.003x)\npiston-image-0. 11.863s vs 11.482s --> 1.033x faster (variance: 1.060x, 1.002x)\nregex.0.1.30     2.517s vs  2.453s --> 1.026x faster (variance: 1.011x, 1.013x)\nrust-encoding-0  2.080s vs  2.047s --> 1.016x faster (variance: 1.005x, 1.005x)\nsyntex-0.42.2   32.268s vs 31.275s --> 1.032x faster (variance: 1.014x, 1.022x)\nsyntex-0.42.2-i 17.629s vs 16.559s --> 1.065x faster (variance: 1.013x, 1.021x)\n```\n\n(That's a stage1 compiler doing debug builds. Results for a stage2 compiler are similar.)\n\nThe attached commit is not in a state suitable for landing because I changed the implementation of FnvHasher without changing its name (because that would have required touching many lines in the compiler). Nonetheless, it is a good place to start discussions.\n\nProfiles show very clearly that this new hash function is a lot faster to compute than FNV. The quality of the new hash function is less clear -- it seems to do better in some cases and worse in others (judging by the number of instructions executed in `Hash{Map,Set}::get`).\n\nCC @brson, @arthurprs", "tree": {"sha": "b2ac410427544892ea9179110d1bc66b0bd1cf24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2ac410427544892ea9179110d1bc66b0bd1cf24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "html_url": "https://github.com/rust-lang/rust/commit/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2321d11b8c8b10ac7727826bdfbe6a326d46cc34", "url": "https://api.github.com/repos/rust-lang/rust/commits/2321d11b8c8b10ac7727826bdfbe6a326d46cc34", "html_url": "https://github.com/rust-lang/rust/commit/2321d11b8c8b10ac7727826bdfbe6a326d46cc34"}, {"sha": "00e48affde2d349e3b3bfbd3d0f6afb5d76282a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/00e48affde2d349e3b3bfbd3d0f6afb5d76282a7", "html_url": "https://github.com/rust-lang/rust/commit/00e48affde2d349e3b3bfbd3d0f6afb5d76282a7"}], "stats": {"total": 1291, "additions": 703, "deletions": 588}, "files": [{"sha": "50a478fcc2fd91d8da5b6e6bd6ecdbbe01de571f", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n use std::ops::Index;\n use std::hash::Hash;\n@@ -24,7 +24,7 @@ use super::{DepNode, DepGraph};\n pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n     phantom: PhantomData<M>,\n     graph: DepGraph,\n-    map: FnvHashMap<M::Key, M::Value>,\n+    map: FxHashMap<M::Key, M::Value>,\n }\n \n pub trait DepTrackingMapConfig {\n@@ -38,7 +38,7 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n         DepTrackingMap {\n             phantom: PhantomData,\n             graph: graph,\n-            map: FnvHashMap()\n+            map: FxHashMap()\n         }\n     }\n "}, {"sha": "8657a3e5a587899f80ebb536847bcb8f8a9a9f0c", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::fmt::Debug;\n use std::hash::Hash;\n use super::{DepGraphQuery, DepNode};\n \n pub struct DepGraphEdges<D: Clone + Debug + Eq + Hash> {\n     nodes: Vec<DepNode<D>>,\n-    indices: FnvHashMap<DepNode<D>, IdIndex>,\n-    edges: FnvHashSet<(IdIndex, IdIndex)>,\n+    indices: FxHashMap<DepNode<D>, IdIndex>,\n+    edges: FxHashSet<(IdIndex, IdIndex)>,\n     open_nodes: Vec<OpenNode>,\n }\n \n@@ -46,8 +46,8 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n     pub fn new() -> DepGraphEdges<D> {\n         DepGraphEdges {\n             nodes: vec![],\n-            indices: FnvHashMap(),\n-            edges: FnvHashSet(),\n+            indices: FxHashMap(),\n+            edges: FxHashSet(),\n             open_nodes: Vec::new()\n         }\n     }"}, {"sha": "2637d34c5c56e569d91a3e1bcff2ad47310efa50", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n@@ -34,19 +34,19 @@ struct DepGraphData {\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n     /// this map. We can later look for and extract that data.\n-    previous_work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n+    previous_work_products: RefCell<FxHashMap<Arc<WorkProductId>, WorkProduct>>,\n \n     /// Work-products that we generate in this run.\n-    work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n+    work_products: RefCell<FxHashMap<Arc<WorkProductId>, WorkProduct>>,\n }\n \n impl DepGraph {\n     pub fn new(enabled: bool) -> DepGraph {\n         DepGraph {\n             data: Rc::new(DepGraphData {\n                 thread: DepGraphThreadData::new(enabled),\n-                previous_work_products: RefCell::new(FnvHashMap()),\n-                work_products: RefCell::new(FnvHashMap()),\n+                previous_work_products: RefCell::new(FxHashMap()),\n+                work_products: RefCell::new(FxHashMap()),\n             })\n         }\n     }\n@@ -117,7 +117,7 @@ impl DepGraph {\n \n     /// Access the map of work-products created during this run. Only\n     /// used during saving of the dep-graph.\n-    pub fn work_products(&self) -> Ref<FnvHashMap<Arc<WorkProductId>, WorkProduct>> {\n+    pub fn work_products(&self) -> Ref<FxHashMap<Arc<WorkProductId>, WorkProduct>> {\n         self.data.work_products.borrow()\n     }\n }"}, {"sha": "4c791f9655342e8fae1ad00a057766e67037f6f4", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{Direction, INCOMING, Graph, NodeIndex, OUTGOING};\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -17,15 +17,15 @@ use super::DepNode;\n \n pub struct DepGraphQuery<D: Clone + Debug + Hash + Eq> {\n     pub graph: Graph<DepNode<D>, ()>,\n-    pub indices: FnvHashMap<DepNode<D>, NodeIndex>,\n+    pub indices: FxHashMap<DepNode<D>, NodeIndex>,\n }\n \n impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n     pub fn new(nodes: &[DepNode<D>],\n                edges: &[(DepNode<D>, DepNode<D>)])\n                -> DepGraphQuery<D> {\n         let mut graph = Graph::new();\n-        let mut indices = FnvHashMap();\n+        let mut indices = FxHashMap();\n         for node in nodes {\n             indices.insert(node.clone(), graph.next_node_index());\n             graph.add_node(node.clone());"}, {"sha": "38157c7e565646c45b21a5dc985ad32606c56998", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n@@ -22,7 +22,7 @@ use util::nodemap::NodeMap;\n #[derive(Clone)]\n pub struct Definitions {\n     data: Vec<DefData>,\n-    key_map: FnvHashMap<DefKey, DefIndex>,\n+    key_map: FxHashMap<DefKey, DefIndex>,\n     node_map: NodeMap<DefIndex>,\n }\n \n@@ -219,7 +219,7 @@ impl Definitions {\n     pub fn new() -> Definitions {\n         Definitions {\n             data: vec![],\n-            key_map: FnvHashMap(),\n+            key_map: FxHashMap(),\n             node_map: NodeMap(),\n         }\n     }"}, {"sha": "cbd3e39f8703aa9735fc433a13870fcc1785af61", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -33,7 +33,7 @@ pub use self::PathParameters::*;\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use util::nodemap::{NodeMap, FnvHashSet};\n+use util::nodemap::{NodeMap, FxHashSet};\n \n use syntax_pos::{mk_sp, Span, ExpnId, DUMMY_SP};\n use syntax::codemap::{self, respan, Spanned};\n@@ -1605,4 +1605,4 @@ pub type TraitMap = NodeMap<Vec<TraitCandidate>>;\n \n // Map from the NodeId of a glob import to a list of items which are actually\n // imported.\n-pub type GlobMap = NodeMap<FnvHashSet<Name>>;\n+pub type GlobMap = NodeMap<FxHashSet<Name>>;"}, {"sha": "30e18a4c569b2fa7093c9b53b66aeb7c8cea8e81", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -32,7 +32,7 @@\n \n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeFolder;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use std::collections::hash_map::Entry;\n \n use super::InferCtxt;\n@@ -41,7 +41,7 @@ use super::unify_key::ToType;\n pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     freshen_count: u32,\n-    freshen_map: FnvHashMap<ty::InferTy, Ty<'tcx>>,\n+    freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -50,7 +50,7 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n         TypeFreshener {\n             infcx: infcx,\n             freshen_count: 0,\n-            freshen_map: FnvHashMap(),\n+            freshen_map: FxHashMap(),\n         }\n     }\n "}, {"sha": "737ce8bdf681daf25cd0b3dc30e3888b9d1b3623", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -24,7 +24,7 @@ use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n use syntax_pos::Span;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n pub struct HrMatchResult<U> {\n     pub value: U,\n@@ -135,7 +135,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // Map each skolemized region to a vector of other regions that it\n             // must be equated with. (Note that this vector may include other\n             // skolemized regions from `skol_map`.)\n-            let skol_resolution_map: FnvHashMap<_, _> =\n+            let skol_resolution_map: FxHashMap<_, _> =\n                 skol_map\n                 .iter()\n                 .map(|(&br, &skol)| {\n@@ -158,7 +158,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // `skol_map`. There should always be a representative if things\n             // are properly well-formed.\n             let mut unconstrained_regions = vec![];\n-            let skol_representatives: FnvHashMap<_, _> =\n+            let skol_representatives: FxHashMap<_, _> =\n                 skol_resolution_map\n                 .iter()\n                 .map(|(&skol, &(br, ref regions))| {\n@@ -268,7 +268,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                             a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n                                              r0: &'tcx ty::Region)\n                                              -> &'tcx ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n@@ -364,8 +364,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FnvHashMap<ty::BoundRegion,\n-                                                                &'tcx ty::Region>,\n+                                             a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n                                              a_vars: &[ty::RegionVid],\n                                              b_vars: &[ty::RegionVid],\n                                              r0: &'tcx ty::Region)\n@@ -434,7 +433,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                       span: Span,\n-                                      a_map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                      a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n                                       r: &'tcx ty::Region) -> &'tcx ty::Region\n         {\n             for (a_br, a_r) in a_map {\n@@ -457,7 +456,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n }\n \n fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+                           map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n                            -> Vec<ty::RegionVid> {\n     map.iter()\n        .map(|(_, &r)| match *r {\n@@ -504,7 +503,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        snapshot: &CombinedSnapshot,\n                        r: &'tcx ty::Region,\n                        directions: TaintDirections)\n-                       -> FnvHashSet<&'tcx ty::Region> {\n+                       -> FxHashSet<&'tcx ty::Region> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r, directions)\n     }\n \n@@ -568,7 +567,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let escaping_types =\n             self.type_variables.borrow_mut().types_escaping_snapshot(&snapshot.type_snapshot);\n \n-        let mut escaping_region_vars = FnvHashSet();\n+        let mut escaping_region_vars = FxHashSet();\n         for ty in &escaping_types {\n             self.tcx.collect_regions(ty, &mut escaping_region_vars);\n         }\n@@ -764,7 +763,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // region back to the `ty::BoundRegion` that it originally\n         // represented. Because `leak_check` passed, we know that\n         // these taint sets are mutually disjoint.\n-        let inv_skol_map: FnvHashMap<&'tcx ty::Region, ty::BoundRegion> =\n+        let inv_skol_map: FxHashMap<&'tcx ty::Region, ty::BoundRegion> =\n             skol_map\n             .iter()\n             .flat_map(|(&skol_br, &skol)| {\n@@ -837,7 +836,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                           snapshot: &CombinedSnapshot)\n     {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n-        let skol_regions: FnvHashSet<_> = skol_map.values().cloned().collect();\n+        let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n         self.region_vars.pop_skolemized(&skol_regions, &snapshot.region_vars_snapshot);\n         if !skol_map.is_empty() {\n             self.projection_cache.borrow_mut().rollback_skolemized("}, {"sha": "ebafd206e26e293e1dff442946ecd5efcaaa2d0e", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -39,7 +39,7 @@ use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n-use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n+use util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n \n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n@@ -134,7 +134,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     // the set of predicates on which errors have been reported, to\n     // avoid reporting the same error twice.\n-    pub reported_trait_errors: RefCell<FnvHashSet<traits::TraitErrorKey<'tcx>>>,\n+    pub reported_trait_errors: RefCell<FxHashSet<traits::TraitErrorKey<'tcx>>>,\n \n     // Sadly, the behavior of projection varies a bit depending on the\n     // stage of compilation. The specifics are given in the\n@@ -170,7 +170,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap<'tcx> = FnvHashMap<ty::BoundRegion, &'tcx ty::Region>;\n+pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, &'tcx ty::Region>;\n \n /// Why did we require that the two types be related?\n ///\n@@ -492,7 +492,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n-            reported_trait_errors: RefCell::new(FnvHashSet()),\n+            reported_trait_errors: RefCell::new(FxHashSet()),\n             projection_mode: Reveal::NotSpecializable,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n@@ -531,7 +531,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             parameter_environment: param_env,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            reported_trait_errors: RefCell::new(FnvHashSet()),\n+            reported_trait_errors: RefCell::new(FxHashSet()),\n             projection_mode: projection_mode,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n@@ -1530,7 +1530,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n-        -> (T, FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+        -> (T, FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n         where T : TypeFoldable<'tcx>\n     {\n         self.tcx.replace_late_bound_regions("}, {"sha": "95ce8d39ff488b0c7fc099d60528988f94b4ed37", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -23,7 +23,7 @@ use middle::region::CodeExtent;\n use super::Constraint;\n use infer::SubregionOrigin;\n use infer::region_inference::RegionVarBindings;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry::Vacant;\n@@ -122,8 +122,8 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     graph_name: String,\n-    map: &'a FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n-    node_ids: FnvHashMap<Node, usize>,\n+    map: &'a FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n+    node_ids: FxHashMap<Node, usize>,\n }\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]\n@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n            map: &'a ConstraintMap<'tcx>)\n            -> ConstraintGraph<'a, 'gcx, 'tcx> {\n         let mut i = 0;\n-        let mut node_ids = FnvHashMap();\n+        let mut node_ids = FxHashMap();\n         {\n             let mut add_node = |node| {\n                 if let Vacant(e) = node_ids.entry(node) {\n@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     type Node = Node;\n     type Edge = Edge<'tcx>;\n     fn nodes(&self) -> dot::Nodes<Node> {\n-        let mut set = FnvHashSet();\n+        let mut set = FxHashSet();\n         for node in self.node_ids.keys() {\n             set.insert(*node);\n         }\n@@ -261,7 +261,7 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub type ConstraintMap<'tcx> = FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n+pub type ConstraintMap<'tcx> = FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n \n fn dump_region_constraints_to<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                               map: &ConstraintMap<'tcx>,"}, {"sha": "af6f2c50e72fc2b0ebfbeefb59f76c99811ec4b3", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -19,7 +19,7 @@ pub use self::VarValue::*;\n use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n use super::unify_key;\n \n-use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n@@ -213,7 +213,7 @@ impl SameRegions {\n     }\n }\n \n-pub type CombineMap<'tcx> = FnvHashMap<TwoRegions<'tcx>, RegionVid>;\n+pub type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -222,7 +222,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // Constraints of the form `A <= B` introduced by the region\n     // checker.  Here at least one of `A` and `B` must be a region\n     // variable.\n-    constraints: RefCell<FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n+    constraints: RefCell<FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n \n     // A \"verify\" is something that we need to verify after inference is\n     // done, but which does not directly affect inference in any way.\n@@ -248,7 +248,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // record the fact that `'a <= 'b` is implied by the fn signature,\n     // and then ignore the constraint when solving equations. This is\n     // a bit of a hack but seems to work.\n-    givens: RefCell<FnvHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n+    givens: RefCell<FxHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap<'tcx>>,\n     glbs: RefCell<CombineMap<'tcx>>,\n@@ -305,14 +305,14 @@ impl TaintDirections {\n \n struct TaintSet<'tcx> {\n     directions: TaintDirections,\n-    regions: FnvHashSet<&'tcx ty::Region>\n+    regions: FxHashSet<&'tcx ty::Region>\n }\n \n impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n     fn new(directions: TaintDirections,\n            initial_region: &'tcx ty::Region)\n            -> Self {\n-        let mut regions = FnvHashSet();\n+        let mut regions = FxHashSet();\n         regions.insert(initial_region);\n         TaintSet { directions: directions, regions: regions }\n     }\n@@ -362,7 +362,7 @@ impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n         }\n     }\n \n-    fn into_set(self) -> FnvHashSet<&'tcx ty::Region> {\n+    fn into_set(self) -> FxHashSet<&'tcx ty::Region> {\n         self.regions\n     }\n \n@@ -393,11 +393,11 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             tcx: tcx,\n             var_origins: RefCell::new(Vec::new()),\n             values: RefCell::new(None),\n-            constraints: RefCell::new(FnvHashMap()),\n+            constraints: RefCell::new(FxHashMap()),\n             verifys: RefCell::new(Vec::new()),\n-            givens: RefCell::new(FnvHashSet()),\n-            lubs: RefCell::new(FnvHashMap()),\n-            glbs: RefCell::new(FnvHashMap()),\n+            givens: RefCell::new(FxHashSet()),\n+            lubs: RefCell::new(FxHashMap()),\n+            glbs: RefCell::new(FxHashMap()),\n             skolemization_count: Cell::new(0),\n             bound_count: Cell::new(0),\n             undo_log: RefCell::new(Vec::new()),\n@@ -547,7 +547,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// completes to remove all trace of the skolemized regions\n     /// created in that time.\n     pub fn pop_skolemized(&self,\n-                          skols: &FnvHashSet<&'tcx ty::Region>,\n+                          skols: &FxHashSet<&'tcx ty::Region>,\n                           snapshot: &RegionSnapshot) {\n         debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n \n@@ -601,7 +601,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         self.skolemization_count.set(snapshot.skolemization_count);\n         return;\n \n-        fn kill_constraint<'tcx>(skols: &FnvHashSet<&'tcx ty::Region>,\n+        fn kill_constraint<'tcx>(skols: &FxHashSet<&'tcx ty::Region>,\n                                  undo_entry: &UndoLogEntry<'tcx>)\n                                  -> bool {\n             match undo_entry {\n@@ -905,7 +905,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                    mark: &RegionSnapshot,\n                    r0: &'tcx Region,\n                    directions: TaintDirections)\n-                   -> FnvHashSet<&'tcx ty::Region> {\n+                   -> FxHashSet<&'tcx ty::Region> {\n         debug!(\"tainted(mark={:?}, r0={:?}, directions={:?})\",\n                mark, r0, directions);\n \n@@ -1414,13 +1414,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                                 dup_vec: &mut [u32])\n                                 -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n         struct WalkState<'tcx> {\n-            set: FnvHashSet<RegionVid>,\n+            set: FxHashSet<RegionVid>,\n             stack: Vec<RegionVid>,\n             result: Vec<RegionAndOrigin<'tcx>>,\n             dup_found: bool,\n         }\n         let mut state = WalkState {\n-            set: FnvHashSet(),\n+            set: FxHashSet(),\n             stack: vec![orig_node_idx],\n             result: Vec::new(),\n             dup_found: false,"}, {"sha": "9cc2337e3dd1ede9f0d16879f0d978a35ad00fe4", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -33,7 +33,7 @@ use lint::{Level, LevelSource, Lint, LintId, LintPass, LintSource};\n use lint::{EarlyLintPassObject, LateLintPassObject};\n use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n use lint::builtin;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use std::cmp;\n use std::default::Default as StdDefault;\n@@ -64,18 +64,18 @@ pub struct LintStore {\n     late_passes: Option<Vec<LateLintPassObject>>,\n \n     /// Lints indexed by name.\n-    by_name: FnvHashMap<String, TargetLint>,\n+    by_name: FxHashMap<String, TargetLint>,\n \n     /// Current levels of each lint, and where they were set.\n-    levels: FnvHashMap<LintId, LevelSource>,\n+    levels: FxHashMap<LintId, LevelSource>,\n \n     /// Map of registered lint groups to what lints they expand to. The bool\n     /// is true if the lint group was added by a plugin.\n-    lint_groups: FnvHashMap<&'static str, (Vec<LintId>, bool)>,\n+    lint_groups: FxHashMap<&'static str, (Vec<LintId>, bool)>,\n \n     /// Extra info for future incompatibility lints, descibing the\n     /// issue or RFC that caused the incompatibility.\n-    future_incompatible: FnvHashMap<LintId, FutureIncompatibleInfo>,\n+    future_incompatible: FxHashMap<LintId, FutureIncompatibleInfo>,\n \n     /// Maximum level a lint can be\n     lint_cap: Option<Level>,\n@@ -171,10 +171,10 @@ impl LintStore {\n             lints: vec![],\n             early_passes: Some(vec![]),\n             late_passes: Some(vec![]),\n-            by_name: FnvHashMap(),\n-            levels: FnvHashMap(),\n-            future_incompatible: FnvHashMap(),\n-            lint_groups: FnvHashMap(),\n+            by_name: FxHashMap(),\n+            levels: FxHashMap(),\n+            future_incompatible: FxHashMap(),\n+            lint_groups: FxHashMap(),\n             lint_cap: None,\n         }\n     }\n@@ -304,8 +304,8 @@ impl LintStore {\n                 Err(FindLintError::Removed) => { }\n                 Err(_) => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n-                                                 .collect::<FnvHashMap<&'static str,\n-                                                                       Vec<LintId>>>()\n+                                                 .collect::<FxHashMap<&'static str,\n+                                                                      Vec<LintId>>>()\n                                                  .get(&lint_name[..]) {\n                         Some(v) => {\n                             v.iter()"}, {"sha": "7fc698fdbebf5150da582891e22fd75920686862", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -22,7 +22,7 @@ use ty::{self, TyCtxt};\n use hir::def::Def;\n use hir::def_id::{DefId};\n use lint;\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n \n use syntax::{ast, codemap};\n use syntax::attr;\n@@ -48,7 +48,7 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: Box<FnvHashSet<ast::NodeId>>,\n+    live_symbols: Box<FxHashSet<ast::NodeId>>,\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n     inherited_pub_visibility: bool,\n@@ -61,7 +61,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             tcx: tcx,\n-            live_symbols: box FnvHashSet(),\n+            live_symbols: box FxHashSet(),\n             struct_has_extern_repr: false,\n             ignore_non_const_paths: false,\n             inherited_pub_visibility: false,\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn mark_live_symbols(&mut self) {\n-        let mut scanned = FnvHashSet();\n+        let mut scanned = FxHashSet();\n         while !self.worklist.is_empty() {\n             let id = self.worklist.pop().unwrap();\n             if scanned.contains(&id) {\n@@ -396,7 +396,7 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n-                       -> Box<FnvHashSet<ast::NodeId>> {\n+                       -> Box<FxHashSet<ast::NodeId>> {\n     let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n     symbol_visitor.mark_live_symbols();\n@@ -414,7 +414,7 @@ fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n \n struct DeadVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: Box<FnvHashSet<ast::NodeId>>,\n+    live_symbols: Box<FxHashSet<ast::NodeId>>,\n }\n \n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {"}, {"sha": "c658f47ec1be0dbbfa58913ec02427b23d754d1b", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -66,7 +66,7 @@ use hir::def_id::CrateNum;\n use session;\n use session::config;\n use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use rustc_back::PanicStrategy;\n \n /// A list of dependencies for a certain crate type.\n@@ -80,7 +80,7 @@ pub type DependencyList = Vec<Linkage>;\n /// A mapping of all required dependencies for a particular flavor of output.\n ///\n /// This is local to the tcx, and is generally relevant to one session.\n-pub type Dependencies = FnvHashMap<config::CrateType, DependencyList>;\n+pub type Dependencies = FxHashMap<config::CrateType, DependencyList>;\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum Linkage {\n@@ -149,7 +149,7 @@ fn calculate_type(sess: &session::Session,\n         config::CrateTypeProcMacro => {},\n     }\n \n-    let mut formats = FnvHashMap();\n+    let mut formats = FxHashMap();\n \n     // Sweep all crates for found dylibs. Add all dylibs, as well as their\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n@@ -240,7 +240,7 @@ fn calculate_type(sess: &session::Session,\n fn add_library(sess: &session::Session,\n                cnum: CrateNum,\n                link: LinkagePreference,\n-               m: &mut FnvHashMap<CrateNum, LinkagePreference>) {\n+               m: &mut FxHashMap<CrateNum, LinkagePreference>) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library"}, {"sha": "3e7de79246b667b59b41ac7a0f3fdbd9d573757f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -27,7 +27,7 @@ use session::Session;\n use hir::def_id::DefId;\n use ty;\n use middle::weak_lang_items;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -146,7 +146,7 @@ struct LanguageItemCollector<'a, 'tcx: 'a> {\n \n     session: &'a Session,\n \n-    item_refs: FnvHashMap<&'static str, usize>,\n+    item_refs: FxHashMap<&'static str, usize>,\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n@@ -169,7 +169,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     pub fn new(session: &'a Session, ast_map: &'a hir_map::Map<'tcx>)\n                -> LanguageItemCollector<'a, 'tcx> {\n-        let mut item_refs = FnvHashMap();\n+        let mut item_refs = FxHashMap();\n \n         $( item_refs.insert($name, $variant as usize); )*\n "}, {"sha": "1376886968f74a4b9535569bbe8133f774a32e5d", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -12,7 +12,7 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n-use util::nodemap::{DefIdSet, FnvHashMap};\n+use util::nodemap::{DefIdSet, FxHashMap};\n \n use std::hash::Hash;\n use std::fmt;\n@@ -35,7 +35,7 @@ pub enum AccessLevel {\n // Accessibility levels for reachable HIR nodes\n #[derive(Clone)]\n pub struct AccessLevels<Id = NodeId> {\n-    pub map: FnvHashMap<Id, AccessLevel>\n+    pub map: FxHashMap<Id, AccessLevel>\n }\n \n impl<Id: Hash + Eq> AccessLevels<Id> {"}, {"sha": "9898ec7597d90ca9d493a1a4876e7072278d6283", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -22,7 +22,7 @@ use hir::def_id::DefId;\n use ty::{self, TyCtxt};\n use middle::privacy;\n use session::config;\n-use util::nodemap::{NodeSet, FnvHashSet};\n+use util::nodemap::{NodeSet, FxHashSet};\n \n use syntax::abi::Abi;\n use syntax::ast;\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     fn propagate(&mut self) {\n-        let mut scanned = FnvHashSet();\n+        let mut scanned = FxHashSet();\n         loop {\n             let search_item = match self.worklist.pop() {\n                 Some(item) => item,"}, {"sha": "8d51fda0cf2b1fa27dbcd1fba91764a9a6f8e86e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -19,7 +19,7 @@\n use dep_graph::DepNode;\n use hir::map as ast_map;\n use session::Session;\n-use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n+use util::nodemap::{FxHashMap, NodeMap, NodeSet};\n use ty;\n \n use std::cell::RefCell;\n@@ -251,7 +251,7 @@ impl CodeExtent {\n /// The region maps encode information about region relationships.\n pub struct RegionMaps {\n     code_extents: RefCell<Vec<CodeExtentData>>,\n-    code_extent_interner: RefCell<FnvHashMap<CodeExtentData, CodeExtent>>,\n+    code_extent_interner: RefCell<FxHashMap<CodeExtentData, CodeExtent>>,\n     /// `scope_map` maps from a scope id to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n@@ -1217,7 +1217,7 @@ pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n \n     let maps = RegionMaps {\n         code_extents: RefCell::new(vec![]),\n-        code_extent_interner: RefCell::new(FnvHashMap()),\n+        code_extent_interner: RefCell::new(FxHashMap()),\n         scope_map: RefCell::new(vec![]),\n         var_map: RefCell::new(NodeMap()),\n         rvalue_scopes: RefCell::new(NodeMap()),"}, {"sha": "e6d960735299c069aac21a156bac913b4dc2ce0b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -31,7 +31,7 @@ use syntax::parse::token::keywords;\n use syntax_pos::Span;\n use util::nodemap::NodeMap;\n \n-use rustc_data_structures::fnv::FnvHashSet;\n+use rustc_data_structures::fx::FxHashSet;\n use hir;\n use hir::print::lifetime_to_string;\n use hir::intravisit::{self, Visitor, FnKind};\n@@ -847,13 +847,13 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n                                generics: &hir::Generics) {\n     debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n \n-    let mut constrained_by_input = ConstrainedCollector { regions: FnvHashSet() };\n+    let mut constrained_by_input = ConstrainedCollector { regions: FxHashSet() };\n     for arg in &decl.inputs {\n         constrained_by_input.visit_ty(&arg.ty);\n     }\n \n     let mut appears_in_output = AllCollector {\n-        regions: FnvHashSet(),\n+        regions: FxHashSet(),\n         impl_trait: false\n     };\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n@@ -866,7 +866,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     // Subtle point: because we disallow nested bindings, we can just\n     // ignore binders here and scrape up all names we see.\n     let mut appears_in_where_clause = AllCollector {\n-        regions: FnvHashSet(),\n+        regions: FxHashSet(),\n         impl_trait: false\n     };\n     for ty_param in generics.ty_params.iter() {\n@@ -926,7 +926,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     return;\n \n     struct ConstrainedCollector {\n-        regions: FnvHashSet<ast::Name>,\n+        regions: FxHashSet<ast::Name>,\n     }\n \n     impl<'v> Visitor<'v> for ConstrainedCollector {\n@@ -961,7 +961,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     }\n \n     struct AllCollector {\n-        regions: FnvHashSet<ast::Name>,\n+        regions: FxHashSet<ast::Name>,\n         impl_trait: bool\n     }\n "}, {"sha": "f1755c82b8cbd3f59b7fa2851556b613ac758ef6", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -27,7 +27,7 @@ use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err, find_lang_feature_accepted_version};\n use syntax::attr::{self, Stability, Deprecation};\n-use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n+use util::nodemap::{DefIdMap, FxHashSet, FxHashMap};\n \n use hir;\n use hir::{Item, Generics, StructField, Variant, PatKind};\n@@ -102,7 +102,7 @@ pub struct Index<'tcx> {\n     depr_map: DefIdMap<Option<DeprecationEntry>>,\n \n     /// Maps for each crate whether it is part of the staged API.\n-    staged_api: FnvHashMap<CrateNum, bool>\n+    staged_api: FxHashMap<CrateNum, bool>\n }\n \n // A private tree-walker for producing an Index.\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> Index<'tcx> {\n             }\n         }\n \n-        let mut staged_api = FnvHashMap();\n+        let mut staged_api = FxHashMap();\n         staged_api.insert(LOCAL_CRATE, is_staged_api);\n         Index {\n             staged_api: staged_api,\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> Index<'tcx> {\n /// features and possibly prints errors. Returns a list of all\n /// features used.\n pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                          -> FnvHashMap<InternedString, attr::StabilityLevel> {\n+                                          -> FxHashMap<InternedString, attr::StabilityLevel> {\n     let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n     let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n@@ -367,7 +367,7 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     let mut checker = Checker {\n         tcx: tcx,\n         active_features: active_features,\n-        used_features: FnvHashMap(),\n+        used_features: FxHashMap(),\n         in_skip_block: 0,\n     };\n     intravisit::walk_crate(&mut checker, tcx.map.krate());\n@@ -377,8 +377,8 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n struct Checker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    active_features: FnvHashSet<InternedString>,\n-    used_features: FnvHashMap<InternedString, attr::StabilityLevel>,\n+    active_features: FxHashSet<InternedString>,\n+    used_features: FxHashMap<InternedString, attr::StabilityLevel>,\n     // Within a block where feature gate checking can be skipped.\n     in_skip_block: u32,\n }\n@@ -746,10 +746,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n pub fn check_unused_or_stable_features(sess: &Session,\n-                                       lib_features_used: &FnvHashMap<InternedString,\n-                                                                      attr::StabilityLevel>) {\n+                                       lib_features_used: &FxHashMap<InternedString,\n+                                                                     attr::StabilityLevel>) {\n     let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n-    let mut remaining_lib_features: FnvHashMap<InternedString, Span>\n+    let mut remaining_lib_features: FxHashMap<InternedString, Span>\n         = declared_lib_features.clone().into_iter().collect();\n \n     fn format_stable_since_msg(version: &str) -> String {"}, {"sha": "724b32d2cd7150e5aa377555921f04dc034fccd7", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -17,7 +17,7 @@ use middle::dependency_format;\n use session::search_paths::PathKind;\n use session::config::DebugInfoLevel;\n use ty::tls;\n-use util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n use util::common::duration_to_secs_str;\n use mir::transform as mir_pass;\n \n@@ -78,7 +78,7 @@ pub struct Session {\n     /// Set of (LintId, span, message) tuples tracking lint (sub)diagnostics\n     /// that have been set once, but should not be set again, in order to avoid\n     /// redundantly verbose output (Issue #24690).\n-    pub one_time_diagnostics: RefCell<FnvHashSet<(lint::LintId, Span, String)>>,\n+    pub one_time_diagnostics: RefCell<FxHashSet<(lint::LintId, Span, String)>>,\n     pub plugin_llvm_passes: RefCell<Vec<String>>,\n     pub mir_passes: RefCell<mir_pass::Passes>,\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n@@ -603,12 +603,12 @@ pub fn build_session_(sopts: config::Options,\n         working_dir: env::current_dir().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap()),\n-        one_time_diagnostics: RefCell::new(FnvHashSet()),\n+        one_time_diagnostics: RefCell::new(FxHashSet()),\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n         mir_passes: RefCell::new(mir_pass::Passes::new()),\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n-        dependency_formats: RefCell::new(FnvHashMap()),\n+        dependency_formats: RefCell::new(FxHashMap()),\n         crate_disambiguator: RefCell::new(token::intern(\"\").as_str()),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),"}, {"sha": "3522c738c160c524e562cc1d1466ee21a655265a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -33,7 +33,7 @@ use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::Subst;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n use std::cmp;\n use std::fmt;\n@@ -252,7 +252,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     let generic_map = def.generics.types.iter().map(|param| {\n                         (param.name.as_str().to_string(),\n                          trait_ref.substs.type_for_def(param).to_string())\n-                    }).collect::<FnvHashMap<String, String>>();\n+                    }).collect::<FxHashMap<String, String>>();\n                     let parser = Parser::new(&istring);\n                     let mut errored = false;\n                     let err: String = parser.filter_map(|p| {\n@@ -647,7 +647,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             \"the trait `{}` cannot be made into an object\", trait_str\n         ));\n \n-        let mut reported_violations = FnvHashSet();\n+        let mut reported_violations = FxHashSet();\n         for violation in violations {\n             if !reported_violations.insert(violation.clone()) {\n                 continue;\n@@ -786,7 +786,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-            var_map: FnvHashMap<Ty<'tcx>, Ty<'tcx>>\n+            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n         }\n \n         impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ParamToVarFolder<'a, 'gcx, 'tcx> {\n@@ -807,7 +807,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n                 infcx: self,\n-                var_map: FnvHashMap()\n+                var_map: FxHashMap()\n             });\n \n             let cleaned_pred = super::project::normalize("}, {"sha": "6de93adce3f8302ee80a23f9e6dcb424b11ca520", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -18,7 +18,7 @@ use std::marker::PhantomData;\n use std::mem;\n use syntax::ast;\n use util::common::ErrorReported;\n-use util::nodemap::{FnvHashSet, NodeMap};\n+use util::nodemap::{FxHashSet, NodeMap};\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n@@ -37,7 +37,7 @@ impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n }\n \n pub struct GlobalFulfilledPredicates<'tcx> {\n-    set: FnvHashSet<ty::PolyTraitPredicate<'tcx>>,\n+    set: FxHashSet<ty::PolyTraitPredicate<'tcx>>,\n     dep_graph: DepGraph,\n }\n \n@@ -673,7 +673,7 @@ fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n     pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'gcx> {\n         GlobalFulfilledPredicates {\n-            set: FnvHashSet(),\n+            set: FxHashSet(),\n             dep_graph: dep_graph,\n         }\n     }"}, {"sha": "5e3f78b1208d51d096d1c360065787b9743ed091", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -51,7 +51,7 @@ use std::mem;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n struct InferredObligationsSnapshotVecDelegate<'tcx> {\n     phantom: PhantomData<&'tcx i32>,\n@@ -104,8 +104,8 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n \n #[derive(Clone)]\n pub struct SelectionCache<'tcx> {\n-    hashmap: RefCell<FnvHashMap<ty::TraitRef<'tcx>,\n-                                SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n+    hashmap: RefCell<FxHashMap<ty::TraitRef<'tcx>,\n+                               SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n }\n \n pub enum MethodMatchResult {\n@@ -306,7 +306,7 @@ enum EvaluationResult {\n \n #[derive(Clone)]\n pub struct EvaluationCache<'tcx> {\n-    hashmap: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n+    hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n }\n \n impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n@@ -2937,15 +2937,15 @@ impl<'tcx> TraitObligation<'tcx> {\n impl<'tcx> SelectionCache<'tcx> {\n     pub fn new() -> SelectionCache<'tcx> {\n         SelectionCache {\n-            hashmap: RefCell::new(FnvHashMap())\n+            hashmap: RefCell::new(FxHashMap())\n         }\n     }\n }\n \n impl<'tcx> EvaluationCache<'tcx> {\n     pub fn new() -> EvaluationCache<'tcx> {\n         EvaluationCache {\n-            hashmap: RefCell::new(FnvHashMap())\n+            hashmap: RefCell::new(FxHashMap())\n         }\n     }\n }"}, {"sha": "4eef6944974c0a6962b41f12b96ee8baa050fe32", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -20,7 +20,7 @@\n use super::{SelectionContext, FulfillmentContext};\n use super::util::impl_trait_ref_and_oblig;\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk, TypeOrigin};\n use middle::region;\n@@ -270,13 +270,13 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n pub struct SpecializesCache {\n-    map: FnvHashMap<(DefId, DefId), bool>\n+    map: FxHashMap<(DefId, DefId), bool>\n }\n \n impl SpecializesCache {\n     pub fn new() -> Self {\n         SpecializesCache {\n-            map: FnvHashMap()\n+            map: FxHashMap()\n         }\n     }\n "}, {"sha": "c746145474c758fa497aeace12e1efe9bd31c8a3", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -17,7 +17,7 @@ use traits::{self, Reveal};\n use ty::{self, TyCtxt, ImplOrTraitItem, TraitDef, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use syntax::ast::Name;\n-use util::nodemap::{DefIdMap, FnvHashMap};\n+use util::nodemap::{DefIdMap, FxHashMap};\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n /// graph forms a tree rooted with the trait itself, with all other nodes\n@@ -57,7 +57,7 @@ struct Children {\n     // the specialization graph.\n \n     /// Impls of the trait.\n-    nonblanket_impls: FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n+    nonblanket_impls: FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n \n     /// Blanket impls associated with the trait.\n     blanket_impls: Vec<DefId>,\n@@ -78,7 +78,7 @@ enum Inserted {\n impl<'a, 'gcx, 'tcx> Children {\n     fn new() -> Children {\n         Children {\n-            nonblanket_impls: FnvHashMap(),\n+            nonblanket_impls: FxHashMap(),\n             blanket_impls: vec![],\n         }\n     }"}, {"sha": "52830164d1d91d3ad77b137c3d664065b0bee367", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -13,7 +13,7 @@ use ty::subst::{Subst, Substs};\n use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n use ty::outlives::Component;\n use util::common::ErrorReported;\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n@@ -50,12 +50,12 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n struct PredicateSet<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    set: FnvHashSet<ty::Predicate<'tcx>>,\n+    set: FxHashSet<ty::Predicate<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PredicateSet<'a, 'gcx, 'tcx> {\n-        PredicateSet { tcx: tcx, set: FnvHashSet() }\n+        PredicateSet { tcx: tcx, set: FxHashSet() }\n     }\n \n     fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n@@ -272,7 +272,7 @@ pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n pub struct SupertraitDefIds<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     stack: Vec<DefId>,\n-    visited: FnvHashSet<DefId>,\n+    visited: FxHashSet<DefId>,\n }\n \n pub fn supertrait_def_ids<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,"}, {"sha": "7ed4de38be97eef26ceedafc418491b0e27a2859", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -11,7 +11,7 @@\n use hir::def_id::{DefId};\n use ty::{self, Ty, TyCtxt};\n use util::common::MemoizationMap;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use std::fmt;\n use std::ops;\n@@ -141,11 +141,11 @@ impl fmt::Debug for TypeContents {\n \n impl<'a, 'tcx> ty::TyS<'tcx> {\n     pub fn type_contents(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeContents {\n-        return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FnvHashMap()));\n+        return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FxHashMap()));\n \n         fn tc_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            ty: Ty<'tcx>,\n-                           cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n+                           cache: &mut FxHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n         {\n             // Subtle: Note that we are *not* using tcx.tc_cache here but rather a\n             // private cache for this walk.  This is needed in the case of cyclic"}, {"sha": "b19f935123519be1fd0893d29e8e1e700dd5a6ca", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -36,7 +36,7 @@ use ty::layout::{Layout, TargetDataLayout};\n use ty::maps;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n use arena::TypedArena;\n@@ -96,26 +96,26 @@ pub struct CtxtInterners<'tcx> {\n \n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n-    type_: RefCell<FnvHashSet<Interned<'tcx, TyS<'tcx>>>>,\n-    type_list: RefCell<FnvHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n-    substs: RefCell<FnvHashSet<Interned<'tcx, Substs<'tcx>>>>,\n-    bare_fn: RefCell<FnvHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n-    region: RefCell<FnvHashSet<Interned<'tcx, Region>>>,\n-    stability: RefCell<FnvHashSet<&'tcx attr::Stability>>,\n-    layout: RefCell<FnvHashSet<&'tcx Layout>>,\n+    type_: RefCell<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n+    type_list: RefCell<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n+    substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n+    bare_fn: RefCell<FxHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n+    region: RefCell<FxHashSet<Interned<'tcx, Region>>>,\n+    stability: RefCell<FxHashSet<&'tcx attr::Stability>>,\n+    layout: RefCell<FxHashSet<&'tcx Layout>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n     fn new(arenas: &'tcx CtxtArenas<'tcx>) -> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arenas: arenas,\n-            type_: RefCell::new(FnvHashSet()),\n-            type_list: RefCell::new(FnvHashSet()),\n-            substs: RefCell::new(FnvHashSet()),\n-            bare_fn: RefCell::new(FnvHashSet()),\n-            region: RefCell::new(FnvHashSet()),\n-            stability: RefCell::new(FnvHashSet()),\n-            layout: RefCell::new(FnvHashSet())\n+            type_: RefCell::new(FxHashSet()),\n+            type_list: RefCell::new(FxHashSet()),\n+            substs: RefCell::new(FxHashSet()),\n+            bare_fn: RefCell::new(FxHashSet()),\n+            region: RefCell::new(FxHashSet()),\n+            stability: RefCell::new(FxHashSet()),\n+            layout: RefCell::new(FxHashSet())\n         }\n     }\n \n@@ -244,11 +244,11 @@ pub struct Tables<'tcx> {\n impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n     pub fn empty() -> Tables<'tcx> {\n         Tables {\n-            node_types: FnvHashMap(),\n+            node_types: FxHashMap(),\n             item_substs: NodeMap(),\n             adjustments: NodeMap(),\n-            method_map: FnvHashMap(),\n-            upvar_capture_map: FnvHashMap(),\n+            method_map: FxHashMap(),\n+            upvar_capture_map: FxHashMap(),\n             closure_tys: DefIdMap(),\n             closure_kinds: DefIdMap(),\n             liberated_fn_sigs: NodeMap(),\n@@ -451,16 +451,16 @@ pub struct GlobalCtxt<'tcx> {\n     pub tcache: RefCell<DepTrackingMap<maps::Tcache<'tcx>>>,\n \n     // Internal cache for metadata decoding. No need to track deps on this.\n-    pub rcache: RefCell<FnvHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+    pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n     // Cache for the type-contents routine. FIXME -- track deps?\n-    pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n+    pub tc_cache: RefCell<FxHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n \n     // FIXME no dep tracking, but we should be able to remove this\n     pub ty_param_defs: RefCell<NodeMap<ty::TypeParameterDef<'tcx>>>,\n \n     // FIXME dep tracking -- should be harmless enough\n-    pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n+    pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n     pub lang_items: middle::lang_items::LanguageItems,\n \n@@ -571,7 +571,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub data_layout: TargetDataLayout,\n \n     /// Cache for layouts computed from types.\n-    pub layout_cache: RefCell<FnvHashMap<Ty<'tcx>, &'tcx Layout>>,\n+    pub layout_cache: RefCell<FxHashMap<Ty<'tcx>, &'tcx Layout>>,\n \n     /// Used to prevent layout from recursing too deeply.\n     pub layout_depth: Cell<usize>,\n@@ -801,7 +801,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             types: common_types,\n             named_region_map: named_region_map,\n             region_maps: region_maps,\n-            free_region_maps: RefCell::new(FnvHashMap()),\n+            free_region_maps: RefCell::new(FxHashMap()),\n             item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n@@ -820,13 +820,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             freevars: RefCell::new(freevars),\n             maybe_unused_trait_imports: maybe_unused_trait_imports,\n             tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            rcache: RefCell::new(FnvHashMap()),\n-            tc_cache: RefCell::new(FnvHashMap()),\n+            rcache: RefCell::new(FxHashMap()),\n+            tc_cache: RefCell::new(FxHashMap()),\n             impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             impl_or_trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_items_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n-            normalized_cache: RefCell::new(FnvHashMap()),\n+            normalized_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,\n             inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n@@ -846,7 +846,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: token::intern_and_get_ident(crate_name),\n             data_layout: data_layout,\n-            layout_cache: RefCell::new(FnvHashMap()),\n+            layout_cache: RefCell::new(FxHashMap()),\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n        }, f)"}, {"sha": "354658ec4397f3cd284e1a4a580f6db642616b87", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -45,7 +45,7 @@ use ty::adjustment;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n use std::fmt;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n@@ -225,7 +225,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n         value: &T,\n-        region_set: &mut FnvHashSet<&'tcx ty::Region>)\n+        region_set: &mut FxHashSet<&'tcx ty::Region>)\n         -> bool\n         where T : TypeFoldable<'tcx>\n     {\n@@ -319,14 +319,14 @@ struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::BoundRegion) -> &'tcx ty::Region + 'a),\n-    map: FnvHashMap<ty::BoundRegion, &'tcx ty::Region>\n+    map: FxHashMap<ty::BoundRegion, &'tcx ty::Region>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n-        -> (T, FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+        -> (T, FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n         where F : FnMut(ty::BoundRegion) -> &'tcx ty::Region,\n               T : TypeFoldable<'tcx>,\n     {\n@@ -390,22 +390,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// variables and equate `value` with something else, those\n     /// variables will also be equated.\n     pub fn collect_constrained_late_bound_regions<T>(&self, value: &Binder<T>)\n-                                                     -> FnvHashSet<ty::BoundRegion>\n+                                                     -> FxHashSet<ty::BoundRegion>\n         where T : TypeFoldable<'tcx>\n     {\n         self.collect_late_bound_regions(value, true)\n     }\n \n     /// Returns a set of all late-bound regions that appear in `value` anywhere.\n     pub fn collect_referenced_late_bound_regions<T>(&self, value: &Binder<T>)\n-                                                    -> FnvHashSet<ty::BoundRegion>\n+                                                    -> FxHashSet<ty::BoundRegion>\n         where T : TypeFoldable<'tcx>\n     {\n         self.collect_late_bound_regions(value, false)\n     }\n \n     fn collect_late_bound_regions<T>(&self, value: &Binder<T>, just_constraint: bool)\n-                                     -> FnvHashSet<ty::BoundRegion>\n+                                     -> FxHashSet<ty::BoundRegion>\n         where T : TypeFoldable<'tcx>\n     {\n         let mut collector = LateBoundRegionsCollector::new(just_constraint);\n@@ -450,7 +450,7 @@ impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n             tcx: tcx,\n             current_depth: 1,\n             fld_r: fld_r,\n-            map: FnvHashMap()\n+            map: FxHashMap()\n         }\n     }\n }\n@@ -650,15 +650,15 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n /// Collects all the late-bound regions it finds into a hash set.\n struct LateBoundRegionsCollector {\n     current_depth: u32,\n-    regions: FnvHashSet<ty::BoundRegion>,\n+    regions: FxHashSet<ty::BoundRegion>,\n     just_constrained: bool,\n }\n \n impl LateBoundRegionsCollector {\n     fn new(just_constrained: bool) -> Self {\n         LateBoundRegionsCollector {\n             current_depth: 1,\n-            regions: FnvHashSet(),\n+            regions: FxHashSet(),\n             just_constrained: just_constrained,\n         }\n     }"}, {"sha": "fcf9b5ff2730cbd5b4bd5285e179685b52696318", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -31,7 +31,7 @@ use ty::subst::{Subst, Substs};\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n use util::nodemap::NodeSet;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -418,7 +418,7 @@ impl MethodCall {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap<'tcx> = FnvHashMap<MethodCall, MethodCallee<'tcx>>;\n+pub type MethodMap<'tcx> = FxHashMap<MethodCall, MethodCallee<'tcx>>;\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n@@ -650,7 +650,7 @@ pub struct UpvarBorrow<'tcx> {\n     pub region: &'tcx ty::Region,\n }\n \n-pub type UpvarCaptureMap<'tcx> = FnvHashMap<UpvarId, UpvarCapture<'tcx>>;\n+pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n #[derive(Copy, Clone)]\n pub struct ClosureUpvar<'tcx> {\n@@ -1251,10 +1251,10 @@ pub struct ParameterEnvironment<'tcx> {\n     pub free_id_outlive: CodeExtent,\n \n     /// A cache for `moves_by_default`.\n-    pub is_copy_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n+    pub is_copy_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n \n     /// A cache for `type_is_sized`\n-    pub is_sized_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n+    pub is_sized_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n }\n \n impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n@@ -1267,8 +1267,8 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             implicit_region_bound: self.implicit_region_bound,\n             caller_bounds: caller_bounds,\n             free_id_outlive: self.free_id_outlive,\n-            is_copy_cache: RefCell::new(FnvHashMap()),\n-            is_sized_cache: RefCell::new(FnvHashMap()),\n+            is_copy_cache: RefCell::new(FxHashMap()),\n+            is_sized_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -2752,8 +2752,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             caller_bounds: Vec::new(),\n             implicit_region_bound: self.mk_region(ty::ReEmpty),\n             free_id_outlive: free_id_outlive,\n-            is_copy_cache: RefCell::new(FnvHashMap()),\n-            is_sized_cache: RefCell::new(FnvHashMap()),\n+            is_copy_cache: RefCell::new(FxHashMap()),\n+            is_sized_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -2824,8 +2824,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             implicit_region_bound: tcx.mk_region(ty::ReScope(free_id_outlive)),\n             caller_bounds: predicates,\n             free_id_outlive: free_id_outlive,\n-            is_copy_cache: RefCell::new(FnvHashMap()),\n-            is_sized_cache: RefCell::new(FnvHashMap()),\n+            is_copy_cache: RefCell::new(FxHashMap()),\n+            is_sized_cache: RefCell::new(FxHashMap()),\n         };\n \n         let cause = traits::ObligationCause::misc(span, free_id_outlive.node_id(&self.region_maps));"}, {"sha": "fc32029948388d3046d37672b55e440e12d3a225", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -16,7 +16,7 @@ use ty::fast_reject;\n use ty::{Ty, TyCtxt, TraitRef};\n use std::cell::{Cell, RefCell};\n use hir;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n /// As `TypeScheme` but for a trait ref.\n pub struct TraitDef<'tcx> {\n@@ -55,7 +55,7 @@ pub struct TraitDef<'tcx> {\n \n     /// Impls of the trait.\n     nonblanket_impls: RefCell<\n-        FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n+        FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n     >,\n \n     /// Blanket impls associated with the trait.\n@@ -84,7 +84,7 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n             unsafety: unsafety,\n             generics: generics,\n             trait_ref: trait_ref,\n-            nonblanket_impls: RefCell::new(FnvHashMap()),\n+            nonblanket_impls: RefCell::new(FxHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n             specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),"}, {"sha": "b1aeaeb48d144c771aca644a7780a699754d01c8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -20,7 +20,7 @@ use ty::{Disr, ParameterEnvironment};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n \n@@ -594,7 +594,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     fn impls_bound(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    param_env: &ParameterEnvironment<'tcx>,\n                    bound: ty::BuiltinBound,\n-                   cache: &RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n+                   cache: &RefCell<FxHashMap<Ty<'tcx>, bool>>,\n                    span: Span) -> bool\n     {\n         if self.has_param_types() || self.has_self_ty() {"}, {"sha": "b03011fcb216dbc4e783f695fde007bc384936b5", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -15,17 +15,17 @@\n use hir::def_id::DefId;\n use syntax::ast;\n \n-pub use rustc_data_structures::fnv::FnvHashMap;\n-pub use rustc_data_structures::fnv::FnvHashSet;\n+pub use rustc_data_structures::fx::FxHashMap;\n+pub use rustc_data_structures::fx::FxHashSet;\n \n-pub type NodeMap<T> = FnvHashMap<ast::NodeId, T>;\n-pub type DefIdMap<T> = FnvHashMap<DefId, T>;\n+pub type NodeMap<T> = FxHashMap<ast::NodeId, T>;\n+pub type DefIdMap<T> = FxHashMap<DefId, T>;\n \n-pub type NodeSet = FnvHashSet<ast::NodeId>;\n-pub type DefIdSet = FnvHashSet<DefId>;\n+pub type NodeSet = FxHashSet<ast::NodeId>;\n+pub type DefIdSet = FxHashSet<DefId>;\n \n-pub fn NodeMap<T>() -> NodeMap<T> { FnvHashMap() }\n-pub fn DefIdMap<T>() -> DefIdMap<T> { FnvHashMap() }\n-pub fn NodeSet() -> NodeSet { FnvHashSet() }\n-pub fn DefIdSet() -> DefIdSet { FnvHashSet() }\n+pub fn NodeMap<T>() -> NodeMap<T> { FxHashMap() }\n+pub fn DefIdMap<T>() -> DefIdMap<T> { FxHashMap() }\n+pub fn NodeSet() -> NodeSet { FxHashSet() }\n+pub fn DefIdSet() -> DefIdSet { FxHashSet() }\n "}, {"sha": "be85069db3135d7b1e2ce6218fc6cd0d5a2b1467", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -21,7 +21,7 @@ use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n@@ -63,7 +63,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n                 env: &env,\n                 flow_inits: flow_inits,\n                 flow_uninits: flow_uninits,\n-                drop_flags: FnvHashMap(),\n+                drop_flags: FxHashMap(),\n                 patch: MirPatch::new(mir),\n             }.elaborate()\n         };\n@@ -118,7 +118,7 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     env: &'a MoveDataParamEnv<'tcx>,\n     flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n     flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>,\n-    drop_flags: FnvHashMap<MovePathIndex, Local>,\n+    drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }\n "}, {"sha": "02064b52cb1fb2c24b264f621bc879294d29e021", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -11,7 +11,7 @@\n \n use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n use rustc::mir::*;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n \n use syntax::codemap::DUMMY_SP;\n@@ -181,7 +181,7 @@ pub struct MovePathLookup<'tcx> {\n     /// subsequent search so that it is solely relative to that\n     /// base-lvalue). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n-    projections: FnvHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n+    projections: FxHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n }\n \n struct MoveDataBuilder<'a, 'tcx: 'a> {\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                     locals: mir.local_decls.indices().map(Lvalue::Local).map(|v| {\n                         Self::new_move_path(&mut move_paths, &mut path_map, None, v)\n                     }).collect(),\n-                    projections: FnvHashMap(),\n+                    projections: FxHashMap(),\n                 },\n                 move_paths: move_paths,\n                 path_map: path_map,"}, {"sha": "afc4ccef0cc0fe11278a9a35fc97f78d6ac7c304", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -23,7 +23,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n use rustc::middle::mem_categorization as mc;\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::{FnvHashMap, NodeSet};\n+use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -41,7 +41,7 @@ pub struct MoveData<'tcx> {\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n \n     /// Cache of loan path to move path index, for easy lookup.\n-    pub path_map: RefCell<FnvHashMap<Rc<LoanPath<'tcx>>, MovePathIndex>>,\n+    pub path_map: RefCell<FxHashMap<Rc<LoanPath<'tcx>>, MovePathIndex>>,\n \n     /// Each move or uninitialized variable gets an entry here.\n     pub moves: RefCell<Vec<Move>>,\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     pub fn new() -> MoveData<'tcx> {\n         MoveData {\n             paths: RefCell::new(Vec::new()),\n-            path_map: RefCell::new(FnvHashMap()),\n+            path_map: RefCell::new(FxHashMap()),\n             moves: RefCell::new(Vec::new()),\n             path_assignments: RefCell::new(Vec::new()),\n             var_assignments: RefCell::new(Vec::new()),"}, {"sha": "831d21b831042cd6d5f2a386e70183749c2453b6", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -17,7 +17,7 @@ use eval::{compare_const_vals};\n \n use rustc_const_math::ConstInt;\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n use pattern::{FieldPattern, Pattern, PatternKind};\n@@ -160,7 +160,7 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     /// associated types to get field types.\n     pub wild_pattern: &'a Pattern<'tcx>,\n     pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n-    pub byte_array_map: FnvHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n+    pub byte_array_map: FxHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             tcx: tcx,\n             wild_pattern: &wild_pattern,\n             pattern_arena: &pattern_arena,\n-            byte_array_map: FnvHashMap(),\n+            byte_array_map: FxHashMap(),\n         })\n     }\n "}, {"sha": "1fb7673521d880029037f94d529df6025b8fccf3", "filename": "src/librustc_data_structures/fx.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_data_structures%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_data_structures%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffx.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::{HashMap, HashSet};\n+use std::default::Default;\n+use std::hash::{Hasher, Hash, BuildHasherDefault};\n+use std::ops::BitXor;\n+\n+pub type FxHashMap<K, V> = HashMap<K, V, BuildHasherDefault<FxHasher>>;\n+pub type FxHashSet<V> = HashSet<V, BuildHasherDefault<FxHasher>>;\n+\n+#[allow(non_snake_case)]\n+pub fn FxHashMap<K: Hash + Eq, V>() -> FxHashMap<K, V> {\n+    HashMap::default()\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn FxHashSet<V: Hash + Eq>() -> FxHashSet<V> {\n+    HashSet::default()\n+}\n+\n+/// A speedy hash algorithm for use within rustc. The hashmap in libcollections\n+/// by default uses SipHash which isn't quite as speedy as we want. In the\n+/// compiler we're not really worried about DOS attempts, so we use a fast\n+/// non-cryptographic hash.\n+///\n+/// This is the same as the algorithm used by Firefox -- which is a homespun\n+/// one not based on any widely-known algorithm -- though modified to produce\n+/// 64-bit hash values instead of 32-bit hash values. It consistently\n+/// out-performs an FNV-based hash within rustc itself -- the collision rate is\n+/// similar or slightly worse than FNV, but the speed of the hash function\n+/// itself is much higher because it works on up to 8 bytes at a time.\n+pub struct FxHasher {\n+    hash: usize\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+const K: usize = 0x9e3779b9;\n+#[cfg(target_pointer_width = \"64\")]\n+const K: usize = 0x517cc1b727220a95;\n+\n+impl Default for FxHasher {\n+    #[inline]\n+    fn default() -> FxHasher {\n+        FxHasher { hash: 0 }\n+    }\n+}\n+\n+impl FxHasher {\n+    #[inline]\n+    fn add_to_hash(&mut self, i: usize) {\n+        self.hash = self.hash.rotate_left(5).bitxor(i).wrapping_mul(K);\n+    }\n+}\n+\n+impl Hasher for FxHasher {\n+    #[inline]\n+    fn write(&mut self, bytes: &[u8]) {\n+        for byte in bytes {\n+            let i = *byte;\n+            self.add_to_hash(i as usize);\n+        }\n+    }\n+\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+        self.add_to_hash((i >> 32) as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.add_to_hash(i);\n+    }\n+\n+    #[inline]\n+    fn finish(&self) -> u64 {\n+        self.hash as u64\n+    }\n+}\n+\n+pub fn hash<T: Hash>(v: &T) -> u64 {\n+    let mut state = FxHasher::default();\n+    v.hash(&mut state);\n+    state.finish()\n+}"}, {"sha": "fdcbec6bac11a97f3867f70ce14eababca389755", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -60,6 +60,7 @@ pub mod snapshot_vec;\n pub mod transitive_relation;\n pub mod unify;\n pub mod fnv;\n+pub mod fx;\n pub mod tuple_slice;\n pub mod veccell;\n pub mod control_flow_graph;"}, {"sha": "a46238309bb46a87e16b16ee72ee1505cbb65b65", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -15,7 +15,7 @@\n //! in the first place). See README.md for a general overview of how\n //! to use this class.\n \n-use fnv::{FnvHashMap, FnvHashSet};\n+use fx::{FxHashMap, FxHashSet};\n \n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n@@ -68,9 +68,9 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n     /// A cache of predicates that have been successfully completed.\n-    done_cache: FnvHashSet<O::Predicate>,\n+    done_cache: FxHashSet<O::Predicate>,\n     /// An cache of the nodes in `nodes`, indexed by predicate.\n-    waiting_cache: FnvHashMap<O::Predicate, NodeIndex>,\n+    waiting_cache: FxHashMap<O::Predicate, NodeIndex>,\n     /// A list of the obligations added in snapshots, to allow\n     /// for their removal.\n     cache_list: Vec<O::Predicate>,\n@@ -158,8 +158,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n             snapshots: vec![],\n-            done_cache: FnvHashSet(),\n-            waiting_cache: FnvHashMap(),\n+            done_cache: FxHashSet(),\n+            waiting_cache: FxHashMap(),\n             cache_list: vec![],\n             scratch: Some(vec![]),\n         }"}, {"sha": "cd7143ad3ce8470d05826d005c44c9ff3efeae3a", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use fnv::FnvHashMap;\n+use fx::FxHashMap;\n use std::hash::Hash;\n use std::ops;\n use std::mem;\n@@ -19,7 +19,7 @@ mod test;\n pub struct SnapshotMap<K, V>\n     where K: Hash + Clone + Eq\n {\n-    map: FnvHashMap<K, V>,\n+    map: FxHashMap<K, V>,\n     undo_log: Vec<UndoLog<K, V>>,\n }\n \n@@ -40,7 +40,7 @@ impl<K, V> SnapshotMap<K, V>\n {\n     pub fn new() -> Self {\n         SnapshotMap {\n-            map: FnvHashMap(),\n+            map: FxHashMap(),\n             undo_log: vec![],\n         }\n     }"}, {"sha": "37477da755c9fb24226b42936c91aa27fdaba7fe", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -48,7 +48,7 @@ use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashSet;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc::hir;\n use rustc::hir::intravisit::Visitor;\n@@ -244,7 +244,7 @@ fn dump_graph(tcx: TyCtxt) {\n     }\n }\n \n-pub struct GraphvizDepGraph<'q>(FnvHashSet<&'q DepNode<DefId>>,\n+pub struct GraphvizDepGraph<'q>(FxHashSet<&'q DepNode<DefId>>,\n                                 Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>);\n \n impl<'a, 'tcx, 'q> dot::GraphWalk<'a> for GraphvizDepGraph<'q> {\n@@ -288,7 +288,7 @@ impl<'a, 'tcx, 'q> dot::Labeller<'a> for GraphvizDepGraph<'q> {\n // filter) or the set of nodes whose labels contain all of those\n // substrings.\n fn node_set<'q>(query: &'q DepGraphQuery<DefId>, filter: &DepNodeFilter)\n-                -> Option<FnvHashSet<&'q DepNode<DefId>>>\n+                -> Option<FxHashSet<&'q DepNode<DefId>>>\n {\n     debug!(\"node_set(filter={:?})\", filter);\n \n@@ -300,9 +300,9 @@ fn node_set<'q>(query: &'q DepGraphQuery<DefId>, filter: &DepNodeFilter)\n }\n \n fn filter_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n-                    sources: &Option<FnvHashSet<&'q DepNode<DefId>>>,\n-                    targets: &Option<FnvHashSet<&'q DepNode<DefId>>>)\n-                    -> FnvHashSet<&'q DepNode<DefId>>\n+                    sources: &Option<FxHashSet<&'q DepNode<DefId>>>,\n+                    targets: &Option<FxHashSet<&'q DepNode<DefId>>>)\n+                    -> FxHashSet<&'q DepNode<DefId>>\n {\n     if let &Some(ref sources) = sources {\n         if let &Some(ref targets) = targets {\n@@ -318,11 +318,11 @@ fn filter_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n }\n \n fn walk_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n-                  starts: &FnvHashSet<&'q DepNode<DefId>>,\n+                  starts: &FxHashSet<&'q DepNode<DefId>>,\n                   direction: Direction)\n-                  -> FnvHashSet<&'q DepNode<DefId>>\n+                  -> FxHashSet<&'q DepNode<DefId>>\n {\n-    let mut set = FnvHashSet();\n+    let mut set = FxHashSet();\n     for &start in starts {\n         debug!(\"walk_nodes: start={:?} outgoing?={:?}\", start, direction == OUTGOING);\n         if set.insert(start) {\n@@ -342,9 +342,9 @@ fn walk_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n }\n \n fn walk_between<'q>(query: &'q DepGraphQuery<DefId>,\n-                    sources: &FnvHashSet<&'q DepNode<DefId>>,\n-                    targets: &FnvHashSet<&'q DepNode<DefId>>)\n-                    -> FnvHashSet<&'q DepNode<DefId>>\n+                    sources: &FxHashSet<&'q DepNode<DefId>>,\n+                    targets: &FxHashSet<&'q DepNode<DefId>>)\n+                    -> FxHashSet<&'q DepNode<DefId>>\n {\n     // This is a bit tricky. We want to include a node only if it is:\n     // (a) reachable from a source and (b) will reach a target. And we\n@@ -410,7 +410,7 @@ fn walk_between<'q>(query: &'q DepGraphQuery<DefId>,\n }\n \n fn filter_edges<'q>(query: &'q DepGraphQuery<DefId>,\n-                    nodes: &FnvHashSet<&'q DepNode<DefId>>)\n+                    nodes: &FxHashSet<&'q DepNode<DefId>>)\n                     -> Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>\n {\n     query.edges()"}, {"sha": "58a21529974106bb65c538acda91c9fa7e185a13", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -35,7 +35,7 @@ use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n \n@@ -51,21 +51,21 @@ mod caching_codemap_view;\n pub mod hasher;\n \n pub struct IncrementalHashesMap {\n-    hashes: FnvHashMap<DepNode<DefId>, Fingerprint>,\n+    hashes: FxHashMap<DepNode<DefId>, Fingerprint>,\n \n     // These are the metadata hashes for the current crate as they were stored\n     // during the last compilation session. They are only loaded if\n     // -Z query-dep-graph was specified and are needed for auto-tests using\n     // the #[rustc_metadata_dirty] and #[rustc_metadata_clean] attributes to\n     // check whether some metadata hash has changed in between two revisions.\n-    pub prev_metadata_hashes: RefCell<FnvHashMap<DefId, Fingerprint>>,\n+    pub prev_metadata_hashes: RefCell<FxHashMap<DefId, Fingerprint>>,\n }\n \n impl IncrementalHashesMap {\n     pub fn new() -> IncrementalHashesMap {\n         IncrementalHashesMap {\n-            hashes: FnvHashMap(),\n-            prev_metadata_hashes: RefCell::new(FnvHashMap()),\n+            hashes: FxHashMap(),\n+            prev_metadata_hashes: RefCell::new(FxHashMap()),\n         }\n     }\n "}, {"sha": "f0e4f4f99ef08e2977bbf069262e598db9d8bb8a", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -13,7 +13,7 @@\n use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n use std::sync::Arc;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use ich::Fingerprint;\n \n use super::directory::DefPathIndex;\n@@ -106,7 +106,7 @@ pub struct SerializedMetadataHashes {\n     /// is only populated if -Z query-dep-graph is specified. It will be\n     /// empty otherwise. Importing crates are perfectly happy with just having\n     /// the DefIndex.\n-    pub index_map: FnvHashMap<DefIndex, DefPathIndex>\n+    pub index_map: FxHashMap<DefIndex, DefPathIndex>\n }\n \n /// The hash for some metadata that (when saving) will be exported"}, {"sha": "69b9be12de46c2de35a2438896546a3b81f80db8", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -47,7 +47,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::Visitor;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n-use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n@@ -67,7 +67,7 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    let dirty_inputs: FnvHashSet<DepNode<DefId>> =\n+    let dirty_inputs: FxHashSet<DepNode<DefId>> =\n         dirty_inputs.iter()\n                    .filter_map(|d| retraced.map(d))\n                    .collect();\n@@ -84,7 +84,7 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     query: &'a DepGraphQuery<DefId>,\n-    dirty_inputs: FnvHashSet<DepNode<DefId>>,\n+    dirty_inputs: FxHashSet<DepNode<DefId>>,\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n@@ -187,8 +187,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n }\n \n pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  prev_metadata_hashes: &FnvHashMap<DefId, Fingerprint>,\n-                                  current_metadata_hashes: &FnvHashMap<DefId, Fingerprint>) {\n+                                  prev_metadata_hashes: &FxHashMap<DefId, Fingerprint>,\n+                                  current_metadata_hashes: &FxHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return;\n     }\n@@ -205,8 +205,8 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    prev_metadata_hashes: &'m FnvHashMap<DefId, Fingerprint>,\n-    current_metadata_hashes: &'m FnvHashMap<DefId, Fingerprint>,\n+    prev_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n+    current_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n }\n \n impl<'a, 'tcx, 'm> Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {"}, {"sha": "ca9c119202322038911521a217625f81e2fc56c6", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -120,7 +120,7 @@ use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::util::fs as fs_util;\n use rustc_data_structures::flock;\n-use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use std::ffi::OsString;\n use std::fs as std_fs;\n@@ -195,7 +195,7 @@ pub fn prepare_session_directory(tcx: TyCtxt) -> Result<bool, ()> {\n     debug!(\"crate-dir: {}\", crate_dir.display());\n     try!(create_dir(tcx.sess, &crate_dir, \"crate\"));\n \n-    let mut source_directories_already_tried = FnvHashSet();\n+    let mut source_directories_already_tried = FxHashSet();\n \n     loop {\n         // Generate a session directory of the form:\n@@ -490,7 +490,7 @@ fn delete_session_dir_lock_file(sess: &Session,\n /// Find the most recent published session directory that is not in the\n /// ignore-list.\n fn find_source_directory(crate_dir: &Path,\n-                         source_directories_already_tried: &FnvHashSet<PathBuf>)\n+                         source_directories_already_tried: &FxHashSet<PathBuf>)\n                          -> Option<PathBuf> {\n     let iter = crate_dir.read_dir()\n                         .unwrap() // FIXME\n@@ -500,7 +500,7 @@ fn find_source_directory(crate_dir: &Path,\n }\n \n fn find_source_directory_in_iter<I>(iter: I,\n-                                    source_directories_already_tried: &FnvHashSet<PathBuf>)\n+                                    source_directories_already_tried: &FxHashSet<PathBuf>)\n                                     -> Option<PathBuf>\n     where I: Iterator<Item=PathBuf>\n {\n@@ -704,8 +704,8 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n \n     // First do a pass over the crate directory, collecting lock files and\n     // session directories\n-    let mut session_directories = FnvHashSet();\n-    let mut lock_files = FnvHashSet();\n+    let mut session_directories = FxHashSet();\n+    let mut lock_files = FxHashSet();\n \n     for dir_entry in try!(crate_directory.read_dir()) {\n         let dir_entry = match dir_entry {\n@@ -731,7 +731,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     }\n \n     // Now map from lock files to session directories\n-    let lock_file_to_session_dir: FnvHashMap<String, Option<String>> =\n+    let lock_file_to_session_dir: FxHashMap<String, Option<String>> =\n         lock_files.into_iter()\n                   .map(|lock_file_name| {\n                         assert!(lock_file_name.ends_with(LOCK_FILE_EXT));\n@@ -774,7 +774,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     }\n \n     // Filter out `None` directories\n-    let lock_file_to_session_dir: FnvHashMap<String, String> =\n+    let lock_file_to_session_dir: FxHashMap<String, String> =\n         lock_file_to_session_dir.into_iter()\n                                 .filter_map(|(lock_file_name, directory_name)| {\n                                     directory_name.map(|n| (lock_file_name, n))\n@@ -898,7 +898,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n }\n \n fn all_except_most_recent(deletion_candidates: Vec<(SystemTime, PathBuf, Option<flock::Lock>)>)\n-                          -> FnvHashMap<PathBuf, Option<flock::Lock>> {\n+                          -> FxHashMap<PathBuf, Option<flock::Lock>> {\n     let most_recent = deletion_candidates.iter()\n                                          .map(|&(timestamp, ..)| timestamp)\n                                          .max();\n@@ -909,7 +909,7 @@ fn all_except_most_recent(deletion_candidates: Vec<(SystemTime, PathBuf, Option<\n                            .map(|(_, path, lock)| (path, lock))\n                            .collect()\n     } else {\n-        FnvHashMap()\n+        FxHashMap()\n     }\n }\n \n@@ -946,19 +946,19 @@ fn test_all_except_most_recent() {\n             (UNIX_EPOCH + Duration::new(5, 0), PathBuf::from(\"5\"), None),\n             (UNIX_EPOCH + Duration::new(3, 0), PathBuf::from(\"3\"), None),\n             (UNIX_EPOCH + Duration::new(2, 0), PathBuf::from(\"2\"), None),\n-        ]).keys().cloned().collect::<FnvHashSet<PathBuf>>(),\n+        ]).keys().cloned().collect::<FxHashSet<PathBuf>>(),\n         vec![\n             PathBuf::from(\"1\"),\n             PathBuf::from(\"2\"),\n             PathBuf::from(\"3\"),\n             PathBuf::from(\"4\"),\n-        ].into_iter().collect::<FnvHashSet<PathBuf>>()\n+        ].into_iter().collect::<FxHashSet<PathBuf>>()\n     );\n \n     assert_eq!(all_except_most_recent(\n         vec![\n-        ]).keys().cloned().collect::<FnvHashSet<PathBuf>>(),\n-        FnvHashSet()\n+        ]).keys().cloned().collect::<FxHashSet<PathBuf>>(),\n+        FxHashSet()\n     );\n }\n \n@@ -973,7 +973,7 @@ fn test_timestamp_serialization() {\n \n #[test]\n fn test_find_source_directory_in_iter() {\n-    let already_visited = FnvHashSet();\n+    let already_visited = FxHashSet();\n \n     // Find newest\n     assert_eq!(find_source_directory_in_iter("}, {"sha": "73311ee96c5308712fae79aa667076efcbb20d63", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -12,7 +12,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::svh::Svh;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::flock;\n use rustc_serialize::Decodable;\n use rustc_serialize::opaque::Decoder;\n@@ -26,8 +26,8 @@ use super::file_format;\n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     incremental_hashes_map: &'a IncrementalHashesMap,\n-    item_metadata_hashes: FnvHashMap<DefId, Fingerprint>,\n-    crate_hashes: FnvHashMap<CrateNum, Svh>,\n+    item_metadata_hashes: FxHashMap<DefId, Fingerprint>,\n+    crate_hashes: FxHashMap<CrateNum, Svh>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n@@ -37,8 +37,8 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         HashContext {\n             tcx: tcx,\n             incremental_hashes_map: incremental_hashes_map,\n-            item_metadata_hashes: FnvHashMap(),\n-            crate_hashes: FnvHashMap(),\n+            item_metadata_hashes: FxHashMap(),\n+            crate_hashes: FxHashMap(),\n         }\n     }\n "}, {"sha": "12bf74c95116d508b197daf711a824071bcd511a", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -15,7 +15,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::fs;\n@@ -30,7 +30,7 @@ use super::hash::*;\n use super::fs::*;\n use super::file_format;\n \n-pub type DirtyNodes = FnvHashSet<DepNode<DefPathIndex>>;\n+pub type DirtyNodes = FxHashSet<DepNode<DefPathIndex>>;\n \n /// If we are in incremental mode, and a previous dep-graph exists,\n /// then load up those nodes/edges that are still valid into the\n@@ -183,7 +183,7 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Compute which work-products have an input that has changed or\n     // been removed. Put the dirty ones into a set.\n-    let mut dirty_target_nodes = FnvHashSet();\n+    let mut dirty_target_nodes = FxHashSet();\n     for &(raw_source_node, ref target_node) in &retraced_edges {\n         if dirty_raw_source_nodes.contains(raw_source_node) {\n             if !dirty_target_nodes.contains(target_node) {\n@@ -239,7 +239,7 @@ fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          retraced: &RetracedDefIdDirectory)\n                          -> DirtyNodes {\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n-    let mut dirty_nodes = FnvHashSet();\n+    let mut dirty_nodes = FxHashSet();\n \n     for hash in serialized_hashes {\n         if let Some(dep_node) = retraced.map(&hash.dep_node) {\n@@ -270,7 +270,7 @@ fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// otherwise no longer applicable.\n fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      work_products: Vec<SerializedWorkProduct>,\n-                                     dirty_target_nodes: &FnvHashSet<DepNode<DefId>>) {\n+                                     dirty_target_nodes: &FxHashSet<DepNode<DefId>>) {\n     debug!(\"reconcile_work_products({:?})\", work_products);\n     for swp in work_products {\n         if dirty_target_nodes.contains(&DepNode::WorkProduct(swp.id.clone())) {\n@@ -314,7 +314,7 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n \n fn load_prev_metadata_hashes(tcx: TyCtxt,\n                              retraced: &RetracedDefIdDirectory,\n-                             output: &mut FnvHashMap<DefId, Fingerprint>) {\n+                             output: &mut FxHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return\n     }"}, {"sha": "e1968ce8d7b6ad541234ed9ff990b36022941633", "filename": "src/librustc_incremental/persist/preds.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir::def_id::DefId;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{DepthFirstTraversal, INCOMING, NodeIndex};\n \n use super::hash::*;\n@@ -23,11 +23,11 @@ pub struct Predecessors<'query> {\n     //   nodes.\n     // - Values: transitive predecessors of the key that are hashable\n     //   (e.g., HIR nodes, input meta-data nodes)\n-    pub inputs: FnvHashMap<&'query DepNode<DefId>, Vec<&'query DepNode<DefId>>>,\n+    pub inputs: FxHashMap<&'query DepNode<DefId>, Vec<&'query DepNode<DefId>>>,\n \n     // - Keys: some hashable node\n     // - Values: the hash thereof\n-    pub hashes: FnvHashMap<&'query DepNode<DefId>, Fingerprint>,\n+    pub hashes: FxHashMap<&'query DepNode<DefId>, Fingerprint>,\n }\n \n impl<'q> Predecessors<'q> {\n@@ -37,7 +37,7 @@ impl<'q> Predecessors<'q> {\n         let all_nodes = query.graph.all_nodes();\n         let tcx = hcx.tcx;\n \n-        let inputs: FnvHashMap<_, _> = all_nodes.iter()\n+        let inputs: FxHashMap<_, _> = all_nodes.iter()\n             .enumerate()\n             .filter(|&(_, node)| match node.data {\n                 DepNode::WorkProduct(_) => true,\n@@ -60,7 +60,7 @@ impl<'q> Predecessors<'q> {\n             })\n             .collect();\n \n-        let mut hashes = FnvHashMap();\n+        let mut hashes = FxHashMap();\n         for input in inputs.values().flat_map(|v| v.iter().cloned()) {\n             hashes.entry(input)\n                   .or_insert_with(|| hcx.hash(input).unwrap());"}, {"sha": "289eebb2162083a1ee44de841288d95e5b45b918", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n use std::hash::Hash;\n@@ -46,7 +46,7 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let query = tcx.dep_graph.query();\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let preds = Predecessors::new(&query, &mut hcx);\n-    let mut current_metadata_hashes = FnvHashMap();\n+    let mut current_metadata_hashes = FxHashMap();\n \n     // IMPORTANT: We are saving the metadata hashes *before* the dep-graph,\n     //            since metadata-encoding might add new entries to the\n@@ -186,7 +186,7 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n                               svh: Svh,\n                               preds: &Predecessors,\n                               builder: &mut DefIdDirectoryBuilder,\n-                              current_metadata_hashes: &mut FnvHashMap<DefId, Fingerprint>,\n+                              current_metadata_hashes: &mut FxHashMap<DefId, Fingerprint>,\n                               encoder: &mut Encoder)\n                               -> io::Result<()> {\n     // For each `MetaData(X)` node where `X` is local, accumulate a\n@@ -198,10 +198,10 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n     // (I initially wrote this with an iterator, but it seemed harder to read.)\n     let mut serialized_hashes = SerializedMetadataHashes {\n         hashes: vec![],\n-        index_map: FnvHashMap()\n+        index_map: FxHashMap()\n     };\n \n-    let mut def_id_hashes = FnvHashMap();\n+    let mut def_id_hashes = FxHashMap();\n \n     for (&target, sources) in &preds.inputs {\n         let def_id = match *target {"}, {"sha": "48471282672adf8563ba7d0de76ad0ca99fa21ab", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -18,7 +18,7 @@ use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n \n@@ -428,7 +428,7 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n-    fn check_type_for_ffi(&self, cache: &mut FnvHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult {\n+    fn check_type_for_ffi(&self, cache: &mut FxHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult {\n         use self::FfiResult::*;\n         let cx = self.cx.tcx;\n \n@@ -639,7 +639,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         // any generic types right now:\n         let ty = self.cx.tcx.normalize_associated_type(&ty);\n \n-        match self.check_type_for_ffi(&mut FnvHashSet(), ty) {\n+        match self.check_type_for_ffi(&mut FxHashSet(), ty) {\n             FfiResult::FfiSafe => {}\n             FfiResult::FfiUnsafe(s) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp, s);"}, {"sha": "a5339f7326a63e6a8a40b132319315a7f3b52ac7", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -11,7 +11,7 @@\n use rustc::hir::pat_util;\n use rustc::ty;\n use rustc::ty::adjustment;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use lint::{LateContext, EarlyContext, LintContext, LintArray};\n use lint::{LintPass, EarlyLintPass, LateLintPass};\n \n@@ -42,7 +42,7 @@ impl UnusedMut {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n         // avoid false warnings in match arms with multiple patterns\n \n-        let mut mutables = FnvHashMap();\n+        let mut mutables = FxHashMap();\n         for p in pats {\n             pat_util::pat_bindings(p, |mode, id, _, path1| {\n                 let name = path1.node;"}, {"sha": "43c97cbe004b376bbc8e518f47557a80835655fd", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -22,7 +22,7 @@ use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc::hir::map::Definitions;\n \n use std::cell::{RefCell, Cell};\n@@ -50,7 +50,7 @@ pub struct CrateLoader<'a> {\n     pub sess: &'a Session,\n     cstore: &'a CStore,\n     next_crate_num: CrateNum,\n-    foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n+    foreign_item_map: FxHashMap<String, Vec<ast::NodeId>>,\n     local_crate_name: String,\n }\n \n@@ -148,7 +148,7 @@ impl<'a> CrateLoader<'a> {\n             sess: sess,\n             cstore: cstore,\n             next_crate_num: cstore.next_crate_num(),\n-            foreign_item_map: FnvHashMap(),\n+            foreign_item_map: FxHashMap(),\n             local_crate_name: local_crate_name.to_owned(),\n         }\n     }\n@@ -401,7 +401,7 @@ impl<'a> CrateLoader<'a> {\n     fn update_extern_crate(&mut self,\n                            cnum: CrateNum,\n                            mut extern_crate: ExternCrate,\n-                           visited: &mut FnvHashSet<(CrateNum, bool)>)\n+                           visited: &mut FxHashSet<(CrateNum, bool)>)\n     {\n         if !visited.insert((cnum, extern_crate.direct)) { return }\n \n@@ -442,7 +442,7 @@ impl<'a> CrateLoader<'a> {\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n         let deps = crate_root.crate_deps.decode(metadata);\n-        let map: FnvHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n+        let map: FxHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, ..) = self.resolve_crate(root,\n                                                         &dep.name.as_str(),\n@@ -1021,7 +1021,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n \n         let extern_crate =\n             ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n-        self.update_extern_crate(cnum, extern_crate, &mut FnvHashSet());\n+        self.update_extern_crate(cnum, extern_crate, &mut FxHashSet());\n         self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n \n         loaded_macros"}, {"sha": "f452cc23b7330433d25fd4af3c7a47359a4f5691", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::svh::Svh;\n use rustc::middle::cstore::ExternCrate;\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n+use rustc::util::nodemap::{FxHashMap, NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n@@ -76,7 +76,7 @@ pub struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping.  This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    pub key_map: FnvHashMap<DefKey, DefIndex>,\n+    pub key_map: FxHashMap<DefKey, DefIndex>,\n \n     /// Flag if this crate is required by an rlib version of this crate, or in\n     /// other words whether it was explicitly linked to. An example of a crate\n@@ -94,7 +94,7 @@ pub struct CachedInlinedItem {\n \n pub struct CStore {\n     pub dep_graph: DepGraph,\n-    metas: RefCell<FnvHashMap<CrateNum, Rc<CrateMetadata>>>,\n+    metas: RefCell<FxHashMap<CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n@@ -110,15 +110,15 @@ impl CStore {\n     pub fn new(dep_graph: &DepGraph) -> CStore {\n         CStore {\n             dep_graph: dep_graph.clone(),\n-            metas: RefCell::new(FnvHashMap()),\n-            extern_mod_crate_map: RefCell::new(FnvHashMap()),\n+            metas: RefCell::new(FxHashMap()),\n+            extern_mod_crate_map: RefCell::new(FxHashMap()),\n             used_crate_sources: RefCell::new(Vec::new()),\n             used_libraries: RefCell::new(Vec::new()),\n             used_link_args: RefCell::new(Vec::new()),\n             statically_included_foreign_items: RefCell::new(NodeSet()),\n-            visible_parent_map: RefCell::new(FnvHashMap()),\n-            inlined_item_cache: RefCell::new(FnvHashMap()),\n-            defid_for_inlined_node: RefCell::new(FnvHashMap()),\n+            visible_parent_map: RefCell::new(FxHashMap()),\n+            inlined_item_cache: RefCell::new(FxHashMap()),\n+            defid_for_inlined_node: RefCell::new(FxHashMap()),\n         }\n     }\n "}, {"sha": "630b07744249b425652d02e60116d09acd98d47b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -17,7 +17,7 @@ use schema::*;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::{DefKey, DefPathData};\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n@@ -432,7 +432,7 @@ impl<'a, 'tcx> MetadataBlob {\n \n     /// Go through each item in the metadata and create a map from that\n     /// item's def-key to the item's DefIndex.\n-    pub fn load_key_map(&self, index: LazySeq<Index>) -> FnvHashMap<DefKey, DefIndex> {\n+    pub fn load_key_map(&self, index: LazySeq<Index>) -> FxHashMap<DefKey, DefIndex> {\n         index.iter_enumerated(self.raw_bytes())\n             .map(|(index, item)| (item.decode(self).def_key.decode(self), index))\n             .collect()"}, {"sha": "fb4fb507296287d8d8dc84b87bf87dbc0ac37cc2", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -23,7 +23,7 @@ use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n \n use rustc::session::config::{self, CrateTypeProcMacro};\n-use rustc::util::nodemap::{FnvHashMap, NodeSet};\n+use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n use std::hash::Hash;\n@@ -52,8 +52,8 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     reachable: &'a NodeSet,\n \n     lazy_state: LazyState,\n-    type_shorthands: FnvHashMap<Ty<'tcx>, usize>,\n-    predicate_shorthands: FnvHashMap<ty::Predicate<'tcx>, usize>,\n+    type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n+    predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n }\n \n macro_rules! encoder_methods {\n@@ -200,7 +200,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                                       variant: &U,\n                                       map: M)\n                                       -> Result<(), <Self as Encoder>::Error>\n-        where M: for<'b> Fn(&'b mut Self) -> &'b mut FnvHashMap<T, usize>,\n+        where M: for<'b> Fn(&'b mut Self) -> &'b mut FxHashMap<T, usize>,\n               T: Clone + Eq + Hash,\n               U: Encodable\n     {\n@@ -1143,7 +1143,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n struct ImplVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    impls: FnvHashMap<DefId, Vec<DefIndex>>,\n+    impls: FxHashMap<DefId, Vec<DefIndex>>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n@@ -1165,7 +1165,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n         let mut visitor = ImplVisitor {\n             tcx: self.tcx,\n-            impls: FnvHashMap(),\n+            impls: FxHashMap(),\n         };\n         self.tcx.map.krate().visit_all_items(&mut visitor);\n "}, {"sha": "c31b209768c38518441099b4fd164beeaad9a06d", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -221,7 +221,7 @@ use rustc::session::Session;\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n use rustc::util::common;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n \n use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n@@ -430,7 +430,7 @@ impl<'a> Context<'a> {\n         let rlib_prefix = format!(\"lib{}\", self.crate_name);\n         let staticlib_prefix = format!(\"{}{}\", staticpair.0, self.crate_name);\n \n-        let mut candidates = FnvHashMap();\n+        let mut candidates = FxHashMap();\n         let mut staticlibs = vec![];\n \n         // First, find all possible candidate rlibs and dylibs purely based on\n@@ -469,7 +469,7 @@ impl<'a> Context<'a> {\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str)\n-                .or_insert_with(|| (FnvHashMap(), FnvHashMap()));\n+                .or_insert_with(|| (FxHashMap(), FxHashMap()));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             fs::canonicalize(path)\n                 .map(|p| {\n@@ -492,7 +492,7 @@ impl<'a> Context<'a> {\n         // A Library candidate is created if the metadata for the set of\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n-        let mut libraries = FnvHashMap();\n+        let mut libraries = FxHashMap();\n         for (_hash, (rlibs, dylibs)) in candidates {\n             let mut slot = None;\n             let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n@@ -544,7 +544,7 @@ impl<'a> Context<'a> {\n     // be read, it is assumed that the file isn't a valid rust library (no\n     // errors are emitted).\n     fn extract_one(&mut self,\n-                   m: FnvHashMap<PathBuf, PathKind>,\n+                   m: FxHashMap<PathBuf, PathKind>,\n                    flavor: CrateFlavor,\n                    slot: &mut Option<(Svh, MetadataBlob)>)\n                    -> Option<(PathBuf, PathKind)> {\n@@ -690,8 +690,8 @@ impl<'a> Context<'a> {\n         // rlibs/dylibs.\n         let sess = self.sess;\n         let dylibname = self.dylibname();\n-        let mut rlibs = FnvHashMap();\n-        let mut dylibs = FnvHashMap();\n+        let mut rlibs = FxHashMap();\n+        let mut dylibs = FxHashMap();\n         {\n             let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n                 if !loc.exists() {"}, {"sha": "b75e52fd4b10d99ce80988d1178da245847d443c", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -13,7 +13,7 @@\n use std;\n \n use rustc_const_math::{ConstMathErr, Op};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n@@ -190,7 +190,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 // first process the set of fields that were provided\n                 // (evaluating them in order given by user)\n-                let fields_map: FnvHashMap<_, _> =\n+                let fields_map: FxHashMap<_, _> =\n                     fields.into_iter()\n                           .map(|f| (f.name, unpack!(block = this.as_operand(block, f.expr))))\n                           .collect();"}, {"sha": "786299c370d82f964243d1790413dd3822f39f0d", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -14,7 +14,7 @@\n //! details.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{AdtDef, Ty};\n@@ -309,7 +309,7 @@ enum TestKind<'tcx> {\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n         options: Vec<ConstVal>,\n-        indices: FnvHashMap<ConstVal, usize>,\n+        indices: FxHashMap<ConstVal, usize>,\n     },\n \n     // test for equality"}, {"sha": "948ba7338cddb9800335e76aac567e686e05a741", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -18,7 +18,7 @@\n use build::Builder;\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         // these maps are empty to start; cases are\n                         // added below in add_cases_to_switch\n                         options: vec![],\n-                        indices: FnvHashMap(),\n+                        indices: FxHashMap(),\n                     }\n                 }\n             }\n@@ -110,7 +110,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n                                      options: &mut Vec<ConstVal>,\n-                                     indices: &mut FnvHashMap<ConstVal, usize>)\n+                                     indices: &mut FxHashMap<ConstVal, usize>)\n                                      -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {"}, {"sha": "b5343975a9cdf39f1826fdba24bf4c6fa15048ab", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -94,7 +94,7 @@ use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::*;\n use syntax_pos::Span;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n \n pub struct Scope<'tcx> {\n     /// the scope-id within the scope_auxiliary\n@@ -140,7 +140,7 @@ pub struct Scope<'tcx> {\n     free: Option<FreeData<'tcx>>,\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n-    cached_exits: FnvHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n+    cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n }\n \n struct DropData<'tcx> {\n@@ -298,7 +298,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             needs_cleanup: false,\n             drops: vec![],\n             free: None,\n-            cached_exits: FnvHashMap()\n+            cached_exits: FxHashMap()\n         });\n         self.scope_auxiliary.push(ScopeAuxiliary {\n             extent: extent,"}, {"sha": "d6f514cfb913616b15d8176a584376529bdef3f7", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx};\n use std::fmt::Display;\n use std::fs;\n@@ -122,10 +122,10 @@ enum Annotation {\n }\n \n fn scope_entry_exit_annotations(auxiliary: Option<&ScopeAuxiliaryVec>)\n-                                -> FnvHashMap<Location, Vec<Annotation>>\n+                                -> FxHashMap<Location, Vec<Annotation>>\n {\n     // compute scope/entry exit annotations\n-    let mut annotations = FnvHashMap();\n+    let mut annotations = FxHashMap();\n     if let Some(auxiliary) = auxiliary {\n         for (scope_id, auxiliary) in auxiliary.iter_enumerated() {\n             annotations.entry(auxiliary.dom)\n@@ -166,7 +166,7 @@ fn write_basic_block(tcx: TyCtxt,\n                      block: BasicBlock,\n                      mir: &Mir,\n                      w: &mut Write,\n-                     annotations: &FnvHashMap<Location, Vec<Annotation>>)\n+                     annotations: &FxHashMap<Location, Vec<Annotation>>)\n                      -> io::Result<()> {\n     let data = &mir[block];\n \n@@ -217,7 +217,7 @@ fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n /// Returns the total number of variables printed.\n fn write_scope_tree(tcx: TyCtxt,\n                     mir: &Mir,\n-                    scope_tree: &FnvHashMap<VisibilityScope, Vec<VisibilityScope>>,\n+                    scope_tree: &FxHashMap<VisibilityScope, Vec<VisibilityScope>>,\n                     w: &mut Write,\n                     parent: VisibilityScope,\n                     depth: usize)\n@@ -283,7 +283,7 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     writeln!(w, \" {{\")?;\n \n     // construct a scope tree and write it out\n-    let mut scope_tree: FnvHashMap<VisibilityScope, Vec<VisibilityScope>> = FnvHashMap();\n+    let mut scope_tree: FxHashMap<VisibilityScope, Vec<VisibilityScope>> = FxHashMap();\n     for (index, scope_data) in mir.visibility_scopes.iter().enumerate() {\n         if let Some(parent) = scope_data.parent_scope {\n             scope_tree.entry(parent)"}, {"sha": "c4a8d34bda008c8fa6f4ef2494e793ff519a4c98", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -14,7 +14,7 @@ use rustc::mir::{Location, Lvalue, Mir, Operand, ProjectionElem, Rvalue, Local};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::TyCtxt;\n-use rustc::util::nodemap::FnvHashSet;\n+use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use std::mem;\n \n@@ -107,5 +107,5 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n \n #[derive(Default)]\n struct OptimizationList {\n-    and_stars: FnvHashSet<Location>,\n+    and_stars: FxHashSet<Location>,\n }"}, {"sha": "84cf85e2fc4e6d46ccc21a8336ce068220504ad0", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -15,7 +15,7 @@\n use rustc::hir;\n use rustc::hir::intravisit as hir_visit;\n use rustc::util::common::to_readable_str;\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use syntax::ast::{self, NodeId, AttrId};\n use syntax::visit as ast_visit;\n use syntax_pos::Span;\n@@ -34,15 +34,15 @@ struct NodeData {\n \n struct StatCollector<'k> {\n     krate: Option<&'k hir::Crate>,\n-    data: FnvHashMap<&'static str, NodeData>,\n-    seen: FnvHashSet<Id>,\n+    data: FxHashMap<&'static str, NodeData>,\n+    seen: FxHashSet<Id>,\n }\n \n pub fn print_hir_stats(krate: &hir::Crate) {\n     let mut collector = StatCollector {\n         krate: Some(krate),\n-        data: FnvHashMap(),\n-        seen: FnvHashSet(),\n+        data: FxHashMap(),\n+        seen: FxHashSet(),\n     };\n     hir_visit::walk_crate(&mut collector, krate);\n     collector.print(\"HIR STATS\");\n@@ -51,8 +51,8 @@ pub fn print_hir_stats(krate: &hir::Crate) {\n pub fn print_ast_stats(krate: &ast::Crate, title: &str) {\n     let mut collector = StatCollector {\n         krate: None,\n-        data: FnvHashMap(),\n-        seen: FnvHashSet(),\n+        data: FxHashMap(),\n+        seen: FxHashSet(),\n     };\n     ast_visit::walk_crate(&mut collector, krate);\n     collector.print(title);"}, {"sha": "1e998a2a4d5b0e8d9532fa4a0ac0f9634dad97d9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -25,7 +25,7 @@ use rustc::middle::cstore::LoadedMacros;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n \n use std::cell::Cell;\n use std::rc::Rc;\n@@ -539,7 +539,7 @@ impl<'b> Resolver<'b> {\n                     self.invocations.insert(mark, invocation);\n                 }\n \n-                let mut macros: FnvHashMap<_, _> = macros.into_iter().map(|mut def| {\n+                let mut macros: FxHashMap<_, _> = macros.into_iter().map(|mut def| {\n                     def.body = mark_tts(&def.body, mark);\n                     let ext = macro_rules::compile(&self.session.parse_sess, &def);\n                     (def.ident.name, (def, Rc::new(ext)))"}, {"sha": "df4c05fcf5dfb42cbae442264f43d45d2739ec48", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -51,7 +51,7 @@ use rustc::hir::def::*;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n-use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet};\n \n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, FloatTy};\n@@ -498,7 +498,7 @@ struct BindingInfo {\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = FnvHashMap<Ident, BindingInfo>;\n+type BindingMap = FxHashMap<Ident, BindingInfo>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n@@ -703,14 +703,14 @@ enum ModulePrefixResult<'a> {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: FnvHashMap<Ident, Def>,\n+    bindings: FxHashMap<Ident, Def>,\n     kind: RibKind<'a>,\n }\n \n impl<'a> Rib<'a> {\n     fn new(kind: RibKind<'a>) -> Rib<'a> {\n         Rib {\n-            bindings: FnvHashMap(),\n+            bindings: FxHashMap(),\n             kind: kind,\n         }\n     }\n@@ -769,7 +769,7 @@ pub struct ModuleS<'a> {\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n     extern_crate_id: Option<NodeId>,\n \n-    resolutions: RefCell<FnvHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n \n     no_implicit_prelude: bool,\n \n@@ -794,7 +794,7 @@ impl<'a> ModuleS<'a> {\n             kind: kind,\n             normal_ancestor_id: None,\n             extern_crate_id: None,\n-            resolutions: RefCell::new(FnvHashMap()),\n+            resolutions: RefCell::new(FxHashMap()),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n@@ -950,12 +950,12 @@ impl<'a> NameBinding<'a> {\n \n /// Interns the names of the primitive types.\n struct PrimitiveTypeTable {\n-    primitive_types: FnvHashMap<Name, PrimTy>,\n+    primitive_types: FxHashMap<Name, PrimTy>,\n }\n \n impl PrimitiveTypeTable {\n     fn new() -> PrimitiveTypeTable {\n-        let mut table = PrimitiveTypeTable { primitive_types: FnvHashMap() };\n+        let mut table = PrimitiveTypeTable { primitive_types: FxHashMap() };\n \n         table.intern(\"bool\", TyBool);\n         table.intern(\"char\", TyChar);\n@@ -989,17 +989,17 @@ pub struct Resolver<'a> {\n \n     // Maps the node id of a statement to the expansions of the `macro_rules!`s\n     // immediately above the statement (if appropriate).\n-    macros_at_scope: FnvHashMap<NodeId, Vec<Mark>>,\n+    macros_at_scope: FxHashMap<NodeId, Vec<Mark>>,\n \n     graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n \n-    trait_item_map: FnvHashMap<(Name, DefId), bool /* is static method? */>,\n+    trait_item_map: FxHashMap<(Name, DefId), bool /* is static method? */>,\n \n     // Names of fields of an item `DefId` accessible with dot syntax.\n     // Used for hints during error reporting.\n-    field_names: FnvHashMap<DefId, Vec<Name>>,\n+    field_names: FxHashMap<DefId, Vec<Name>>,\n \n     // All imports known to succeed or fail.\n     determined_imports: Vec<&'a ImportDirective<'a>>,\n@@ -1061,8 +1061,8 @@ pub struct Resolver<'a> {\n     // all imports, but only glob imports are actually interesting).\n     pub glob_map: GlobMap,\n \n-    used_imports: FnvHashSet<(NodeId, Namespace)>,\n-    used_crates: FnvHashSet<CrateNum>,\n+    used_imports: FxHashSet<(NodeId, Namespace)>,\n+    used_crates: FxHashSet<CrateNum>,\n     pub maybe_unused_trait_imports: NodeSet,\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n@@ -1075,12 +1075,12 @@ pub struct Resolver<'a> {\n \n     pub exported_macros: Vec<ast::MacroDef>,\n     crate_loader: &'a mut CrateLoader,\n-    macro_names: FnvHashSet<Name>,\n-    builtin_macros: FnvHashMap<Name, Rc<SyntaxExtension>>,\n+    macro_names: FxHashSet<Name>,\n+    builtin_macros: FxHashMap<Name, Rc<SyntaxExtension>>,\n     lexical_macro_resolutions: Vec<(Name, LegacyScope<'a>)>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n-    invocations: FnvHashMap<Mark, &'a InvocationData<'a>>,\n+    invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1206,23 +1206,23 @@ impl<'a> Resolver<'a> {\n         let mut definitions = Definitions::new();\n         DefCollector::new(&mut definitions).collect_root();\n \n-        let mut invocations = FnvHashMap();\n+        let mut invocations = FxHashMap();\n         invocations.insert(Mark::root(),\n                            arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n         Resolver {\n             session: session,\n \n             definitions: definitions,\n-            macros_at_scope: FnvHashMap(),\n+            macros_at_scope: FxHashMap(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n             graph_root: graph_root,\n             prelude: None,\n \n-            trait_item_map: FnvHashMap(),\n-            field_names: FnvHashMap(),\n+            trait_item_map: FxHashMap(),\n+            field_names: FxHashMap(),\n \n             determined_imports: Vec::new(),\n             indeterminate_imports: Vec::new(),\n@@ -1248,8 +1248,8 @@ impl<'a> Resolver<'a> {\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n \n-            used_imports: FnvHashSet(),\n-            used_crates: FnvHashSet(),\n+            used_imports: FxHashSet(),\n+            used_crates: FxHashSet(),\n             maybe_unused_trait_imports: NodeSet(),\n \n             privacy_errors: Vec::new(),\n@@ -1266,8 +1266,8 @@ impl<'a> Resolver<'a> {\n \n             exported_macros: Vec::new(),\n             crate_loader: crate_loader,\n-            macro_names: FnvHashSet(),\n-            builtin_macros: FnvHashMap(),\n+            macro_names: FxHashSet(),\n+            builtin_macros: FxHashMap(),\n             lexical_macro_resolutions: Vec::new(),\n             invocations: invocations,\n         }\n@@ -1340,7 +1340,7 @@ impl<'a> Resolver<'a> {\n \n     fn add_to_glob_map(&mut self, id: NodeId, name: Name) {\n         if self.make_glob_map {\n-            self.glob_map.entry(id).or_insert_with(FnvHashSet).insert(name);\n+            self.glob_map.entry(id).or_insert_with(FxHashSet).insert(name);\n         }\n     }\n \n@@ -1803,7 +1803,7 @@ impl<'a> Resolver<'a> {\n         match type_parameters {\n             HasTypeParameters(generics, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n-                let mut seen_bindings = FnvHashMap();\n+                let mut seen_bindings = FxHashMap();\n                 for type_parameter in &generics.ty_params {\n                     let name = type_parameter.ident.name;\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n@@ -1867,7 +1867,7 @@ impl<'a> Resolver<'a> {\n         self.label_ribs.push(Rib::new(rib_kind));\n \n         // Add each argument to the rib.\n-        let mut bindings_list = FnvHashMap();\n+        let mut bindings_list = FxHashMap();\n         for argument in &declaration.inputs {\n             self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n \n@@ -2069,15 +2069,15 @@ impl<'a> Resolver<'a> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FnvHashMap());\n+        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FxHashMap());\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n     // this is done hygienically. This could arise for a macro\n     // that expands into an or-pattern where one 'x' was from the\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n-        let mut binding_map = FnvHashMap();\n+        let mut binding_map = FxHashMap();\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n@@ -2137,7 +2137,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_arm(&mut self, arm: &Arm) {\n         self.value_ribs.push(Rib::new(NormalRibKind));\n \n-        let mut bindings_list = FnvHashMap();\n+        let mut bindings_list = FxHashMap();\n         for pattern in &arm.pats {\n             self.resolve_pattern(&pattern, PatternSource::Match, &mut bindings_list);\n         }\n@@ -2278,7 +2278,7 @@ impl<'a> Resolver<'a> {\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n-                     bindings: &mut FnvHashMap<Ident, NodeId>)\n+                     bindings: &mut FxHashMap<Ident, NodeId>)\n                      -> PathResolution {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n@@ -2391,7 +2391,7 @@ impl<'a> Resolver<'a> {\n                        pat_src: PatternSource,\n                        // Maps idents to the node ID for the\n                        // outermost pattern that binds them.\n-                       bindings: &mut FnvHashMap<Ident, NodeId>) {\n+                       bindings: &mut FxHashMap<Ident, NodeId>) {\n         // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n@@ -3048,7 +3048,7 @@ impl<'a> Resolver<'a> {\n                 self.visit_expr(subexpression);\n \n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::IfLet, &mut FnvHashMap());\n+                self.resolve_pattern(pattern, PatternSource::IfLet, &mut FxHashMap());\n                 self.visit_block(if_block);\n                 self.value_ribs.pop();\n \n@@ -3065,7 +3065,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FnvHashMap());\n+                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n@@ -3075,7 +3075,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::For, &mut FnvHashMap());\n+                self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n@@ -3337,7 +3337,7 @@ impl<'a> Resolver<'a> {\n \n     fn report_errors(&mut self) {\n         self.report_shadowing_errors();\n-        let mut reported_spans = FnvHashSet();\n+        let mut reported_spans = FxHashSet();\n \n         for &AmbiguityError { span, name, b1, b2 } in &self.ambiguity_errors {\n             if !reported_spans.insert(span) { continue }\n@@ -3369,7 +3369,7 @@ impl<'a> Resolver<'a> {\n             self.resolve_macro_name(scope, name);\n         }\n \n-        let mut reported_errors = FnvHashSet();\n+        let mut reported_errors = FxHashSet();\n         for binding in replace(&mut self.disallowed_shadowing, Vec::new()) {\n             if self.resolve_macro_name(binding.parent, binding.name).is_some() &&\n                reported_errors.insert((binding.name, binding.span)) {"}, {"sha": "d50669272f726bf0be560f5839cd2975d54b7097", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -79,7 +79,7 @@ use type_::Type;\n use type_of;\n use value::Value;\n use Disr;\n-use util::nodemap::{NodeSet, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n \n use arena::TypedArena;\n use libc::c_uint;\n@@ -1318,7 +1318,7 @@ fn write_metadata(cx: &SharedCrateContext,\n fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                                  ccxs: &CrateContextList<'a, 'tcx>,\n                                  symbol_map: &SymbolMap<'tcx>,\n-                                 reachable: &FnvHashSet<&str>) {\n+                                 reachable: &FxHashSet<&str>) {\n     let scx = ccxs.shared();\n     let tcx = scx.tcx();\n \n@@ -1332,7 +1332,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n     // 'unsafe' because we are holding on to CStr's from the LLVM module within\n     // this block.\n     unsafe {\n-        let mut referenced_somewhere = FnvHashSet();\n+        let mut referenced_somewhere = FxHashSet();\n \n         // Collect all symbols that need to stay externally visible because they\n         // are referenced via a declaration in some other codegen unit.\n@@ -1353,7 +1353,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n \n         // Also collect all symbols for which we cannot adjust linkage, because\n         // it is fixed by some directive in the source code (e.g. #[no_mangle]).\n-        let linkage_fixed_explicitly: FnvHashSet<_> = scx\n+        let linkage_fixed_explicitly: FxHashSet<_> = scx\n             .translation_items()\n             .borrow()\n             .iter()\n@@ -1862,7 +1862,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n     }\n \n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n-        let mut item_to_cgus = FnvHashMap();\n+        let mut item_to_cgus = FxHashMap();\n \n         for cgu in &codegen_units {\n             for (&trans_item, &linkage) in cgu.items() {"}, {"sha": "0480bb82a998e902396d78f98b282d1f0ec00875", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -19,7 +19,7 @@ use common::*;\n use machine::llalign_of_pref;\n use type_::Type;\n use value::Value;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use libc::{c_uint, c_char};\n \n use std::borrow::Cow;\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Build version of path with cycles removed.\n \n                 // Pass 1: scan table mapping str -> rightmost pos.\n-                let mut mm = FnvHashMap();\n+                let mut mm = FxHashMap();\n                 let len = v.len();\n                 let mut i = 0;\n                 while i < len {"}, {"sha": "548554af9727f933b3fb2b8242be3bf99c73ab33", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -211,7 +211,7 @@ use context::SharedCrateContext;\n use common::{fulfill_obligation, type_is_sized};\n use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n-use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n+use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n use trans_item::{TransItem, type_to_string, def_id_to_string};\n \n@@ -228,15 +228,15 @@ pub struct InliningMap<'tcx> {\n     // that are potentially inlined by LLVM into the source.\n     // The two numbers in the tuple are the start (inclusive) and\n     // end index (exclusive) within the `targets` vecs.\n-    index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n+    index: FxHashMap<TransItem<'tcx>, (usize, usize)>,\n     targets: Vec<TransItem<'tcx>>,\n }\n \n impl<'tcx> InliningMap<'tcx> {\n \n     fn new() -> InliningMap<'tcx> {\n         InliningMap {\n-            index: FnvHashMap(),\n+            index: FxHashMap(),\n             targets: Vec::new(),\n         }\n     }\n@@ -269,15 +269,15 @@ impl<'tcx> InliningMap<'tcx> {\n \n pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n-                                                 -> (FnvHashSet<TransItem<'tcx>>,\n+                                                 -> (FxHashSet<TransItem<'tcx>>,\n                                                      InliningMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n     scx.tcx().dep_graph.with_ignore(|| {\n         let roots = collect_roots(scx, mode);\n \n         debug!(\"Building translation item graph, beginning at roots\");\n-        let mut visited = FnvHashSet();\n+        let mut visited = FxHashSet();\n         let mut recursion_depths = DefIdMap();\n         let mut inlining_map = InliningMap::new();\n \n@@ -318,7 +318,7 @@ fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n // Collect all monomorphized translation items reachable from `starting_point`\n fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n-                                   visited: &mut FnvHashSet<TransItem<'tcx>>,\n+                                   visited: &mut FxHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n                                    inlining_map: &mut InliningMap<'tcx>) {\n     if !visited.insert(starting_point.clone()) {\n@@ -1179,9 +1179,9 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let callee_substs = tcx.erase_regions(&trait_ref.substs);\n-                let overridden_methods: FnvHashSet<_> = items.iter()\n-                                                             .map(|item| item.name)\n-                                                             .collect();\n+                let overridden_methods: FxHashSet<_> = items.iter()\n+                                                            .map(|item| item.name)\n+                                                            .collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n                     if overridden_methods.contains(&method.name) {\n                         continue;"}, {"sha": "264d4940c17f91d4a4ff3c7c3b5e9b09773587ab", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -32,7 +32,7 @@ use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n use symbol_map::SymbolMap;\n-use util::nodemap::{NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -52,7 +52,7 @@ pub struct Stats {\n     pub n_inlines: Cell<usize>,\n     pub n_closures: Cell<usize>,\n     pub n_llvm_insns: Cell<usize>,\n-    pub llvm_insns: RefCell<FnvHashMap<String, usize>>,\n+    pub llvm_insns: RefCell<FxHashMap<String, usize>>,\n     // (ident, llvm-instructions)\n     pub fn_stats: RefCell<Vec<(String, usize)> >,\n }\n@@ -74,7 +74,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n \n     use_dll_storage_attrs: bool,\n \n-    translation_items: RefCell<FnvHashSet<TransItem<'tcx>>>,\n+    translation_items: RefCell<FxHashSet<TransItem<'tcx>>>,\n     trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n     project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n }\n@@ -89,15 +89,15 @@ pub struct LocalCrateContext<'tcx> {\n     previous_work_product: Option<WorkProduct>,\n     tn: TypeNames, // FIXME: This seems to be largely unused.\n     codegen_unit: CodegenUnit<'tcx>,\n-    needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n-    fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n-    drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n+    needs_unwind_cleanup_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n+    fn_pointer_shims: RefCell<FxHashMap<Ty<'tcx>, ValueRef>>,\n+    drop_glues: RefCell<FxHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n     /// Cache instances of monomorphic and polymorphic items\n-    instances: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n+    instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n+    vtables: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n     /// Cache of constant strings,\n-    const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n+    const_cstr_cache: RefCell<FxHashMap<InternedString, ValueRef>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n     /// Key is a ValueRef holding a *T,\n@@ -107,48 +107,48 @@ pub struct LocalCrateContext<'tcx> {\n     /// when we ptrcast, and we have to ptrcast during translation\n     /// of a [T] const because we form a slice, a (*T,usize) pair, not\n     /// a pointer to an LLVM array type. Similar for trait objects.\n-    const_unsized: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n+    const_unsized: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// Cache of emitted const globals (value -> global)\n-    const_globals: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n+    const_globals: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// Cache of emitted const values\n-    const_values: RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n+    const_values: RefCell<FxHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n \n     /// Cache of external const values\n     extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n     /// Mapping from static definitions to their DefId's.\n-    statics: RefCell<FnvHashMap<ValueRef, DefId>>,\n+    statics: RefCell<FxHashMap<ValueRef, DefId>>,\n \n-    impl_method_cache: RefCell<FnvHashMap<(DefId, ast::Name), DefId>>,\n+    impl_method_cache: RefCell<FxHashMap<(DefId, ast::Name), DefId>>,\n \n     /// Cache of closure wrappers for bare fn's.\n-    closure_bare_wrapper_cache: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n+    closure_bare_wrapper_cache: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// List of globals for static variables which need to be passed to the\n     /// LLVM function ReplaceAllUsesWith (RAUW) when translation is complete.\n     /// (We have to make sure we don't invalidate any ValueRefs referring\n     /// to constants.)\n     statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n \n-    lltypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n-    llsizingtypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n-    type_hashcodes: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n+    lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    llsizingtypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    type_hashcodes: RefCell<FxHashMap<Ty<'tcx>, String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    closure_vals: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n+    closure_vals: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n     eh_personality: Cell<Option<ValueRef>>,\n     eh_unwind_resume: Cell<Option<ValueRef>>,\n     rust_try_fn: Cell<Option<ValueRef>>,\n \n-    intrinsics: RefCell<FnvHashMap<&'static str, ValueRef>>,\n+    intrinsics: RefCell<FxHashMap<&'static str, ValueRef>>,\n \n     /// Number of LLVM instructions translated into this `LocalCrateContext`.\n     /// This is used to perform some basic load-balancing to keep all LLVM\n@@ -502,12 +502,12 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n                 n_inlines: Cell::new(0),\n                 n_closures: Cell::new(0),\n                 n_llvm_insns: Cell::new(0),\n-                llvm_insns: RefCell::new(FnvHashMap()),\n+                llvm_insns: RefCell::new(FxHashMap()),\n                 fn_stats: RefCell::new(Vec::new()),\n             },\n             check_overflow: check_overflow,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n-            translation_items: RefCell::new(FnvHashSet()),\n+            translation_items: RefCell::new(FxHashSet()),\n             trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n             project_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n         }\n@@ -557,7 +557,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         self.use_dll_storage_attrs\n     }\n \n-    pub fn translation_items(&self) -> &RefCell<FnvHashSet<TransItem<'tcx>>> {\n+    pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n         &self.translation_items\n     }\n \n@@ -612,32 +612,32 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 previous_work_product: previous_work_product,\n                 codegen_unit: codegen_unit,\n                 tn: TypeNames::new(),\n-                needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n-                fn_pointer_shims: RefCell::new(FnvHashMap()),\n-                drop_glues: RefCell::new(FnvHashMap()),\n-                instances: RefCell::new(FnvHashMap()),\n-                vtables: RefCell::new(FnvHashMap()),\n-                const_cstr_cache: RefCell::new(FnvHashMap()),\n-                const_unsized: RefCell::new(FnvHashMap()),\n-                const_globals: RefCell::new(FnvHashMap()),\n-                const_values: RefCell::new(FnvHashMap()),\n+                needs_unwind_cleanup_cache: RefCell::new(FxHashMap()),\n+                fn_pointer_shims: RefCell::new(FxHashMap()),\n+                drop_glues: RefCell::new(FxHashMap()),\n+                instances: RefCell::new(FxHashMap()),\n+                vtables: RefCell::new(FxHashMap()),\n+                const_cstr_cache: RefCell::new(FxHashMap()),\n+                const_unsized: RefCell::new(FxHashMap()),\n+                const_globals: RefCell::new(FxHashMap()),\n+                const_values: RefCell::new(FxHashMap()),\n                 extern_const_values: RefCell::new(DefIdMap()),\n-                statics: RefCell::new(FnvHashMap()),\n-                impl_method_cache: RefCell::new(FnvHashMap()),\n-                closure_bare_wrapper_cache: RefCell::new(FnvHashMap()),\n+                statics: RefCell::new(FxHashMap()),\n+                impl_method_cache: RefCell::new(FxHashMap()),\n+                closure_bare_wrapper_cache: RefCell::new(FxHashMap()),\n                 statics_to_rauw: RefCell::new(Vec::new()),\n-                lltypes: RefCell::new(FnvHashMap()),\n-                llsizingtypes: RefCell::new(FnvHashMap()),\n-                type_hashcodes: RefCell::new(FnvHashMap()),\n+                lltypes: RefCell::new(FxHashMap()),\n+                llsizingtypes: RefCell::new(FxHashMap()),\n+                type_hashcodes: RefCell::new(FxHashMap()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                closure_vals: RefCell::new(FnvHashMap()),\n+                closure_vals: RefCell::new(FxHashMap()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: Cell::new(None),\n                 eh_unwind_resume: Cell::new(None),\n                 rust_try_fn: Cell::new(None),\n-                intrinsics: RefCell::new(FnvHashMap()),\n+                intrinsics: RefCell::new(FxHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n                 symbol_map: symbol_map,\n@@ -794,16 +794,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.link_meta\n     }\n \n-    pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, bool>> {\n+    pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FxHashMap<Ty<'tcx>, bool>> {\n         &self.local().needs_unwind_cleanup_cache\n     }\n \n-    pub fn fn_pointer_shims(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n+    pub fn fn_pointer_shims(&self) -> &RefCell<FxHashMap<Ty<'tcx>, ValueRef>> {\n         &self.local().fn_pointer_shims\n     }\n \n     pub fn drop_glues<'a>(&'a self)\n-                          -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>> {\n+                          -> &'a RefCell<FxHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>> {\n         &self.local().drop_glues\n     }\n \n@@ -815,61 +815,61 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.sess().cstore.defid_for_inlined_node(node_id)\n     }\n \n-    pub fn instances<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n+    pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().instances\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n         &self.local().vtables\n     }\n \n-    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<InternedString, ValueRef>> {\n+    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FxHashMap<InternedString, ValueRef>> {\n         &self.local().const_cstr_cache\n     }\n \n-    pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n+    pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n         &self.local().const_unsized\n     }\n \n-    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n+    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n         &self.local().const_globals\n     }\n \n-    pub fn const_values<'a>(&'a self) -> &'a RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n-                                                                ValueRef>> {\n+    pub fn const_values<'a>(&'a self) -> &'a RefCell<FxHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n+                                                               ValueRef>> {\n         &self.local().const_values\n     }\n \n     pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n         &self.local().extern_const_values\n     }\n \n-    pub fn statics<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, DefId>> {\n+    pub fn statics<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, DefId>> {\n         &self.local().statics\n     }\n \n     pub fn impl_method_cache<'a>(&'a self)\n-            -> &'a RefCell<FnvHashMap<(DefId, ast::Name), DefId>> {\n+            -> &'a RefCell<FxHashMap<(DefId, ast::Name), DefId>> {\n         &self.local().impl_method_cache\n     }\n \n-    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n+    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n         &self.local().closure_bare_wrapper_cache\n     }\n \n     pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n         &self.local().statics_to_rauw\n     }\n \n-    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n+    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n         &self.local().lltypes\n     }\n \n-    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n+    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n         &self.local().llsizingtypes\n     }\n \n-    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n+    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, String>> {\n         &self.local().type_hashcodes\n     }\n \n@@ -885,7 +885,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().opaque_vec_type\n     }\n \n-    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n+    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().closure_vals\n     }\n \n@@ -905,7 +905,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().rust_try_fn\n     }\n \n-    fn intrinsics<'a>(&'a self) -> &'a RefCell<FnvHashMap<&'static str, ValueRef>> {\n+    fn intrinsics<'a>(&'a self) -> &'a RefCell<FxHashMap<&'static str, ValueRef>> {\n         &self.local().intrinsics\n     }\n \n@@ -958,7 +958,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &*self.local().symbol_map\n     }\n \n-    pub fn translation_items(&self) -> &RefCell<FnvHashSet<TransItem<'tcx>>> {\n+    pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n         &self.shared.translation_items\n     }\n "}, {"sha": "e81461b662172ecf4eaadac326b09fc59bc0b0b7", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -36,7 +36,7 @@ use common::CrateContext;\n use type_::Type;\n use rustc::ty::{self, AdtKind, Ty, layout};\n use session::config;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n@@ -84,20 +84,20 @@ pub struct TypeMap<'tcx> {\n     // The UniqueTypeIds created so far\n     unique_id_interner: Interner,\n     // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n-    unique_id_to_metadata: FnvHashMap<UniqueTypeId, DIType>,\n+    unique_id_to_metadata: FxHashMap<UniqueTypeId, DIType>,\n     // A map from types to debuginfo metadata. This is a N:1 mapping.\n-    type_to_metadata: FnvHashMap<Ty<'tcx>, DIType>,\n+    type_to_metadata: FxHashMap<Ty<'tcx>, DIType>,\n     // A map from types to UniqueTypeId. This is a N:1 mapping.\n-    type_to_unique_id: FnvHashMap<Ty<'tcx>, UniqueTypeId>\n+    type_to_unique_id: FxHashMap<Ty<'tcx>, UniqueTypeId>\n }\n \n impl<'tcx> TypeMap<'tcx> {\n     pub fn new() -> TypeMap<'tcx> {\n         TypeMap {\n             unique_id_interner: Interner::new(),\n-            type_to_metadata: FnvHashMap(),\n-            unique_id_to_metadata: FnvHashMap(),\n-            type_to_unique_id: FnvHashMap(),\n+            type_to_metadata: FxHashMap(),\n+            unique_id_to_metadata: FxHashMap(),\n+            type_to_unique_id: FxHashMap(),\n         }\n     }\n "}, {"sha": "62fb40cc389c24393ed41146e515824e188e4813", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -34,7 +34,7 @@ use monomorphize::{self, Instance};\n use rustc::ty::{self, Ty};\n use rustc::mir;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use util::nodemap::{DefIdMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n@@ -68,15 +68,15 @@ pub struct CrateDebugContext<'tcx> {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n     current_debug_location: Cell<InternalDebugLocation>,\n-    created_files: RefCell<FnvHashMap<String, DIFile>>,\n-    created_enum_disr_types: RefCell<FnvHashMap<(DefId, layout::Integer), DIType>>,\n+    created_files: RefCell<FxHashMap<String, DIFile>>,\n+    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Integer), DIType>>,\n \n     type_map: RefCell<TypeMap<'tcx>>,\n     namespace_map: RefCell<DefIdMap<DIScope>>,\n \n     // This collection is used to assert that composite types (structs, enums,\n     // ...) have their members only set once:\n-    composite_types_completed: RefCell<FnvHashSet<DIType>>,\n+    composite_types_completed: RefCell<FxHashSet<DIType>>,\n }\n \n impl<'tcx> CrateDebugContext<'tcx> {\n@@ -89,11 +89,11 @@ impl<'tcx> CrateDebugContext<'tcx> {\n             llcontext: llcontext,\n             builder: builder,\n             current_debug_location: Cell::new(InternalDebugLocation::UnknownLocation),\n-            created_files: RefCell::new(FnvHashMap()),\n-            created_enum_disr_types: RefCell::new(FnvHashMap()),\n+            created_files: RefCell::new(FxHashMap()),\n+            created_enum_disr_types: RefCell::new(FxHashMap()),\n             type_map: RefCell::new(TypeMap::new()),\n             namespace_map: RefCell::new(DefIdMap()),\n-            composite_types_completed: RefCell::new(FnvHashSet()),\n+            composite_types_completed: RefCell::new(FxHashSet()),\n         };\n     }\n }"}, {"sha": "b22bcf9825a2aa4239b23fbe49a9b11a4e0d9e40", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -29,7 +29,7 @@ use type_of;\n use glue;\n use type_::Type;\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use syntax::parse::token;\n \n use super::{MirContext, LocalRef};\n@@ -144,7 +144,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     adt::trans_get_discr(bcx, ty, discr_lvalue.llval, None, true)\n                 );\n \n-                let mut bb_hist = FnvHashMap();\n+                let mut bb_hist = FxHashMap();\n                 for target in targets {\n                     *bb_hist.entry(target).or_insert(0) += 1;\n                 }"}, {"sha": "c9c12fb6d4534deb2f2dbea251e38ca64fe09faa", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -134,7 +134,7 @@ use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n use syntax::parse::token::{self, InternedString};\n use trans_item::TransItem;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n pub enum PartitioningStrategy {\n     /// Generate one codegen unit per source-level module.\n@@ -151,12 +151,12 @@ pub struct CodegenUnit<'tcx> {\n     /// as well as the crate name and disambiguator.\n     name: InternedString,\n \n-    items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n+    items: FxHashMap<TransItem<'tcx>, llvm::Linkage>,\n }\n \n impl<'tcx> CodegenUnit<'tcx> {\n     pub fn new(name: InternedString,\n-               items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>)\n+               items: FxHashMap<TransItem<'tcx>, llvm::Linkage>)\n                -> Self {\n         CodegenUnit {\n             name: name,\n@@ -165,7 +165,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn empty(name: InternedString) -> Self {\n-        Self::new(name, FnvHashMap())\n+        Self::new(name, FxHashMap())\n     }\n \n     pub fn contains_item(&self, item: &TransItem<'tcx>) -> bool {\n@@ -176,7 +176,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         &self.name\n     }\n \n-    pub fn items(&self) -> &FnvHashMap<TransItem<'tcx>, llvm::Linkage> {\n+    pub fn items(&self) -> &FxHashMap<TransItem<'tcx>, llvm::Linkage> {\n         &self.items\n     }\n \n@@ -297,7 +297,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n \n struct PreInliningPartitioning<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n-    roots: FnvHashSet<TransItem<'tcx>>,\n+    roots: FxHashSet<TransItem<'tcx>>,\n }\n \n struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n@@ -308,8 +308,8 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     let tcx = scx.tcx();\n-    let mut roots = FnvHashSet();\n-    let mut codegen_units = FnvHashMap();\n+    let mut roots = FxHashSet();\n+    let mut codegen_units = FxHashMap();\n \n     for trans_item in trans_items {\n         let is_root = !trans_item.is_instantiated_only_on_demand(tcx);\n@@ -419,7 +419,7 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n \n     for codegen_unit in &initial_partitioning.codegen_units[..] {\n         // Collect all items that need to be available in this codegen unit\n-        let mut reachable = FnvHashSet();\n+        let mut reachable = FxHashSet();\n         for root in codegen_unit.items.keys() {\n             follow_inlining(*root, inlining_map, &mut reachable);\n         }\n@@ -465,7 +465,7 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n \n     fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n                              inlining_map: &InliningMap<'tcx>,\n-                             visited: &mut FnvHashSet<TransItem<'tcx>>) {\n+                             visited: &mut FxHashSet<TransItem<'tcx>>) {\n         if !visited.insert(trans_item) {\n             return;\n         }"}, {"sha": "c3e0ac1fee51578d33b238f3ebb4d3e4aba06265", "filename": "src/librustc_trans/symbol_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -14,15 +14,15 @@ use rustc::ty::TyCtxt;\n use std::borrow::Cow;\n use syntax::codemap::Span;\n use trans_item::TransItem;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n // In the SymbolMap we collect the symbol names of all translation items of\n // the current crate. This map exists as a performance optimization. Symbol\n // names of translation items are deterministic and fully defined by the item.\n // Thus they could also always be recomputed if needed.\n \n pub struct SymbolMap<'tcx> {\n-    index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n+    index: FxHashMap<TransItem<'tcx>, (usize, usize)>,\n     arena: String,\n }\n \n@@ -78,7 +78,7 @@ impl<'tcx> SymbolMap<'tcx> {\n         }\n \n         let mut symbol_map = SymbolMap {\n-            index: FnvHashMap(),\n+            index: FxHashMap(),\n             arena: String::with_capacity(1024),\n         };\n "}, {"sha": "2a6f79d3ed57ae4fb5d3ceeb3a9ba5b314fcb58b", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -15,7 +15,7 @@ use llvm::{TypeRef, Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use context::CrateContext;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use syntax::ast;\n use rustc::ty::layout;\n@@ -325,13 +325,13 @@ impl Type {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    named_types: RefCell<FnvHashMap<String, TypeRef>>,\n+    named_types: RefCell<FxHashMap<String, TypeRef>>,\n }\n \n impl TypeNames {\n     pub fn new() -> TypeNames {\n         TypeNames {\n-            named_types: RefCell::new(FnvHashMap())\n+            named_types: RefCell::new(FxHashMap())\n         }\n     }\n "}, {"sha": "57936f8a4b3be67922429629260cecd50134fc77", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -66,7 +66,7 @@ use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ElisionFailureInfo, ElidedLifetime};\n use rscope::{AnonTypeScope, MaybeWithAnonTypes};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n-use util::nodemap::{NodeMap, FnvHashSet};\n+use util::nodemap::{NodeMap, FxHashSet};\n \n use std::cell::RefCell;\n use syntax::{abi, ast};\n@@ -569,7 +569,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let mut possible_implied_output_region = None;\n \n         for input_type in input_tys.iter() {\n-            let mut regions = FnvHashSet();\n+            let mut regions = FxHashSet();\n             let have_bound_regions = tcx.collect_regions(input_type, &mut regions);\n \n             debug!(\"find_implied_output_regions: collected {:?} from {:?} \\\n@@ -1142,7 +1142,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        let mut associated_types = FnvHashSet::default();\n+        let mut associated_types = FxHashSet::default();\n         for tr in traits::supertraits(tcx, principal) {\n             if let Some(trait_id) = tcx.map.as_local_node_id(tr.def_id()) {\n                 use collect::trait_associated_type_names;"}, {"sha": "15b29573ac4e8cc080259316ebe7709bf0a1dc73", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation};\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n@@ -633,10 +633,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let field_map = variant.fields\n             .iter()\n             .map(|field| (field.name, field))\n-            .collect::<FnvHashMap<_, _>>();\n+            .collect::<FxHashMap<_, _>>();\n \n         // Keep track of which fields have already appeared in the pattern.\n-        let mut used_fields = FnvHashMap();\n+        let mut used_fields = FxHashMap();\n \n         // Typecheck each field.\n         for &Spanned { node: ref field, span } in fields {"}, {"sha": "d28eb85ebb49d925780d711766bbef66240bf177", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -18,7 +18,7 @@ use middle::region;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::traits::{self, Reveal};\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n \n use syntax::ast;\n use syntax_pos::{self, Span};\n@@ -289,7 +289,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n             rcx: rcx,\n             span: span,\n             parent_scope: parent_scope,\n-            breadcrumbs: FnvHashSet()\n+            breadcrumbs: FxHashSet()\n         },\n         TypeContext::Root,\n         typ,\n@@ -347,7 +347,7 @@ enum TypeContext {\n struct DropckContext<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n     rcx: &'a mut RegionCtxt<'b, 'gcx, 'tcx>,\n     /// types that have already been traversed\n-    breadcrumbs: FnvHashSet<Ty<'tcx>>,\n+    breadcrumbs: FxHashSet<Ty<'tcx>>,\n     /// span for error reporting\n     span: Span,\n     /// the scope reachable dtorck types must outlive"}, {"sha": "95d2b2211f5b418bb2bc3c0adf86a0c6a50d482d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::TypeOrigin;\n use rustc::ty::subst::Substs;\n use rustc::ty::FnSig;\n use rustc::ty::{self, Ty};\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use {CrateCtxt, require_same_types};\n \n use syntax::abi::Abi;\n@@ -372,7 +372,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                         return\n                     }\n \n-                    let mut structural_to_nomimal = FnvHashMap();\n+                    let mut structural_to_nomimal = FxHashMap();\n \n                     let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n                     if intr.inputs.len() != sig.inputs.len() {\n@@ -412,7 +412,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n         ccx: &CrateCtxt<'a, 'tcx>,\n         position: &str,\n         span: Span,\n-        structural_to_nominal: &mut FnvHashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n+        structural_to_nominal: &mut FxHashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n         expected: &'a intrinsics::Type, t: ty::Ty<'tcx>)\n {\n     use intrinsics::Type::*;"}, {"sha": "54b1b6c6807dbe887e172525542253cf773ed833", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::subst::{Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::{InferOk, TypeOrigin};\n-use rustc::util::nodemap::FnvHashSet;\n+use rustc::util::nodemap::FxHashSet;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir;\n@@ -40,7 +40,7 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n-    impl_dups: FnvHashSet<DefId>,\n+    impl_dups: FxHashSet<DefId>,\n     import_id: Option<ast::NodeId>,\n \n     /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             item_name: item_name,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n-            impl_dups: FnvHashSet(),\n+            impl_dups: FxHashSet(),\n             import_id: None,\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n@@ -568,7 +568,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn assemble_extension_candidates_for_traits_in_scope(&mut self,\n                                                          expr_id: ast::NodeId)\n                                                          -> Result<(), MethodError<'tcx>> {\n-        let mut duplicates = FnvHashSet();\n+        let mut duplicates = FxHashSet();\n         let opt_applicable_traits = self.tcx.trait_map.get(&expr_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for trait_candidate in applicable_traits {\n@@ -585,7 +585,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(), MethodError<'tcx>> {\n-        let mut duplicates = FnvHashSet();\n+        let mut duplicates = FxHashSet();\n         for trait_info in suggest::all_traits(self.ccx) {\n             if duplicates.insert(trait_info.def_id) {\n                 self.assemble_extension_candidates_for_trait(trait_info.def_id)?;"}, {"sha": "98d3957db70599376575876a60da162e422e8cf9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -20,7 +20,7 @@ use hir::def::Def;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::lang_items::FnOnceTraitLangItem;\n use rustc::traits::{Obligation, SelectionContext};\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n \n use syntax::ast;\n use errors::DiagnosticBuilder;\n@@ -470,10 +470,10 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n         });\n \n         // Cross-crate:\n-        let mut external_mods = FnvHashSet();\n+        let mut external_mods = FxHashSet();\n         fn handle_external_def(ccx: &CrateCtxt,\n                                traits: &mut AllTraitsVec,\n-                               external_mods: &mut FnvHashSet<DefId>,\n+                               external_mods: &mut FxHashSet<DefId>,\n                                def: Def) {\n             let def_id = def.def_id();\n             match def {"}, {"sha": "45f0672f1c0b4e80fc1f5ce6f66c7bbdb1807660", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -103,7 +103,7 @@ use CrateCtxt;\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, ErrorReported, indenter, loop_query};\n-use util::nodemap::{DefIdMap, FnvHashMap, FnvHashSet, NodeMap};\n+use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n use std::mem::replace;\n@@ -1975,13 +1975,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // We must collect the defaults *before* we do any unification. Because we have\n             // directly attached defaults to the type variables any unification that occurs\n             // will erase defaults causing conflicting defaults to be completely ignored.\n-            let default_map: FnvHashMap<_, _> =\n+            let default_map: FxHashMap<_, _> =\n                 unsolved_variables\n                     .iter()\n                     .filter_map(|t| self.default(t).map(|d| (t, d)))\n                     .collect();\n \n-            let mut unbound_tyvars = FnvHashSet();\n+            let mut unbound_tyvars = FxHashSet();\n \n             debug!(\"select_all_obligations_and_apply_defaults: defaults={:?}\", default_map);\n \n@@ -2129,8 +2129,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // table then apply defaults until we find a conflict. That default must be the one\n     // that caused conflict earlier.\n     fn find_conflicting_default(&self,\n-                                unbound_vars: &FnvHashSet<Ty<'tcx>>,\n-                                default_map: &FnvHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n+                                unbound_vars: &FxHashSet<Ty<'tcx>>,\n+                                default_map: &FxHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n                                 conflict: Ty<'tcx>)\n                                 -> Option<type_variable::Default<'tcx>> {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n@@ -3123,12 +3123,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n \n-        let mut remaining_fields = FnvHashMap();\n+        let mut remaining_fields = FxHashMap();\n         for field in &variant.fields {\n             remaining_fields.insert(field.name, field);\n         }\n \n-        let mut seen_fields = FnvHashMap();\n+        let mut seen_fields = FxHashMap();\n \n         let mut error_happened = false;\n "}, {"sha": "741f327ac99e1a7f8b69d48ee1ca614af1119511", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -16,7 +16,7 @@ use middle::region::{CodeExtent};\n use rustc::infer::TypeOrigin;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::nodemap::{FnvHashSet, FnvHashMap};\n+use rustc::util::nodemap::{FxHashSet, FxHashMap};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -529,7 +529,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         assert_eq!(ty_predicates.parent, None);\n         let variances = self.tcx().item_variances(item_def_id);\n \n-        let mut constrained_parameters: FnvHashSet<_> =\n+        let mut constrained_parameters: FxHashSet<_> =\n             variances.iter().enumerate()\n                      .filter(|&(_, &variance)| variance != ty::Bivariant)\n                      .map(|(index, _)| Parameter(index as u32))\n@@ -580,10 +580,10 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, generics: &ty::Generics) {\n     let parent = tcx.lookup_generics(generics.parent.unwrap());\n-    let impl_params: FnvHashMap<_, _> = parent.types\n-                                        .iter()\n-                                        .map(|tp| (tp.name, tp.def_id))\n-                                        .collect();\n+    let impl_params: FxHashMap<_, _> = parent.types\n+                                       .iter()\n+                                       .map(|tp| (tp.name, tp.def_id))\n+                                       .collect();\n \n     for method_param in &generics.types {\n         if impl_params.contains_key(&method_param.name) {"}, {"sha": "5c51877ae743ee09b9d6678003726e662c8e1606", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -72,7 +72,7 @@ use rustc::ty::util::IntTypeExt;\n use rscope::*;\n use rustc::dep_graph::DepNode;\n use util::common::{ErrorReported, MemoizationMap};\n-use util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n use {CrateCtxt, write_ty_to_tcx};\n \n use rustc_const_math::ConstInt;\n@@ -786,8 +786,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             // Convert all the associated consts.\n             // Also, check if there are any duplicate associated items\n-            let mut seen_type_items = FnvHashMap();\n-            let mut seen_value_items = FnvHashMap();\n+            let mut seen_type_items = FxHashMap();\n+            let mut seen_value_items = FxHashMap();\n \n             for impl_item in impl_items {\n                 let seen_items = match impl_item.node {\n@@ -1038,7 +1038,7 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     disr_val: ty::Disr,\n                                     def: &hir::VariantData)\n                                     -> ty::VariantDefData<'tcx, 'tcx> {\n-    let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n+    let mut seen_fields: FxHashMap<ast::Name, Span> = FxHashMap();\n     let node_id = ccx.tcx.map.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n         let fid = ccx.tcx.map.local_def_id(f.id);\n@@ -1952,9 +1952,9 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n {\n     let inline_bounds = from_bounds(ccx, param_bounds);\n     let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n-    let all_bounds: FnvHashSet<_> = inline_bounds.into_iter()\n-                                                 .chain(where_bounds)\n-                                                 .collect();\n+    let all_bounds: FxHashSet<_> = inline_bounds.into_iter()\n+                                                .chain(where_bounds)\n+                                                .collect();\n     return if all_bounds.len() > 1 {\n         ty::ObjectLifetimeDefault::Ambiguous\n     } else if all_bounds.len() == 0 {\n@@ -2171,7 +2171,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n-    let mut input_parameters: FnvHashSet<_> =\n+    let mut input_parameters: FxHashSet<_> =\n         ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n@@ -2200,15 +2200,15 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let impl_predicates = ccx.tcx.lookup_predicates(impl_def_id);\n     let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n-    let mut input_parameters: FnvHashSet<_> =\n+    let mut input_parameters: FxHashSet<_> =\n         ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n     ctp::identify_constrained_type_params(\n         &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n-    let lifetimes_in_associated_types: FnvHashSet<_> = impl_items.iter()\n+    let lifetimes_in_associated_types: FxHashSet<_> = impl_items.iter()\n         .map(|item| ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(item.id)))\n         .filter_map(|item| match item {\n             ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,"}, {"sha": "7918537a6c08f7ec4173a51fe68814c8ff3aeb42", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::{self, Ty};\n use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n-use rustc::util::nodemap::FnvHashSet;\n+use rustc::util::nodemap::FxHashSet;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Parameter(pub u32);\n@@ -76,7 +76,7 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n \n pub fn identify_constrained_type_params<'tcx>(predicates: &[ty::Predicate<'tcx>],\n                                               impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                              input_parameters: &mut FnvHashSet<Parameter>)\n+                                              input_parameters: &mut FxHashSet<Parameter>)\n {\n     let mut predicates = predicates.to_owned();\n     setup_constraining_predicates(&mut predicates, impl_trait_ref, input_parameters);\n@@ -125,7 +125,7 @@ pub fn identify_constrained_type_params<'tcx>(predicates: &[ty::Predicate<'tcx>]\n /// think of any.\n pub fn setup_constraining_predicates<'tcx>(predicates: &mut [ty::Predicate<'tcx>],\n                                            impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                           input_parameters: &mut FnvHashSet<Parameter>)\n+                                           input_parameters: &mut FxHashSet<Parameter>)\n {\n     // The canonical way of doing the needed topological sort\n     // would be a DFS, but getting the graph and its ownership"}, {"sha": "1885b4276cc4168021dcec56770e5ce19d19271b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::FnvHashSet;\n+use rustc::util::nodemap::FxHashSet;\n \n use rustc_const_eval::lookup_const_by_id;\n \n@@ -460,7 +460,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                 .into_iter()\n                 .map(|meth| meth.name.to_string())\n                 .collect()\n-    }).unwrap_or(FnvHashSet());\n+    }).unwrap_or(FxHashSet());\n \n     ret.push(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n@@ -496,7 +496,7 @@ fn build_module<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // If we're reexporting a reexport it may actually reexport something in\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n-        let mut visited = FnvHashSet();\n+        let mut visited = FxHashSet();\n         for item in tcx.sess.cstore.item_children(did) {\n             let def_id = item.def.def_id();\n             if tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {"}, {"sha": "df13e384d9615a4b926319a59284fb26da3e950e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -38,7 +38,7 @@ use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind};\n use rustc::middle::stability;\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use rustc::hir;\n \n@@ -116,7 +116,7 @@ pub struct Crate {\n     pub access_levels: Arc<AccessLevels<DefId>>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n-    pub external_traits: FnvHashMap<DefId, Trait>,\n+    pub external_traits: FxHashMap<DefId, Trait>,\n }\n \n struct CrateNum(def_id::CrateNum);\n@@ -993,7 +993,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n         // Note that associated types also have a sized bound by default, but we\n         // don't actually know the set of associated types right here so that's\n         // handled in cleaning associated types\n-        let mut sized_params = FnvHashSet();\n+        let mut sized_params = FxHashSet();\n         where_predicates.retain(|pred| {\n             match *pred {\n                 WP::BoundPredicate { ty: Generic(ref g), ref bounds } => {\n@@ -1693,8 +1693,8 @@ impl Clean<Type> for hir::Ty {\n                 });\n                 if let Some((tcx, &hir::ItemTy(ref ty, ref generics))) = tcx_and_alias {\n                     let provided_params = &path.segments.last().unwrap().parameters;\n-                    let mut ty_substs = FnvHashMap();\n-                    let mut lt_substs = FnvHashMap();\n+                    let mut ty_substs = FxHashMap();\n+                    let mut lt_substs = FxHashMap();\n                     for (i, ty_param) in generics.ty_params.iter().enumerate() {\n                         let ty_param_def = tcx.expect_def(ty_param.id);\n                         if let Some(ty) = provided_params.types().get(i).cloned()\n@@ -2368,7 +2368,7 @@ impl Clean<ImplPolarity> for hir::ImplPolarity {\n pub struct Impl {\n     pub unsafety: hir::Unsafety,\n     pub generics: Generics,\n-    pub provided_trait_methods: FnvHashSet<String>,\n+    pub provided_trait_methods: FxHashSet<String>,\n     pub trait_: Option<Type>,\n     pub for_: Type,\n     pub items: Vec<Item>,\n@@ -2394,7 +2394,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n                    .map(|meth| meth.name.to_string())\n                    .collect()\n             })\n-        }).unwrap_or(FnvHashSet());\n+        }).unwrap_or(FxHashSet());\n \n         ret.push(Item {\n             name: None,"}, {"sha": "810bea4c5b0983d06981154ae60d49f9d646f0f0", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -19,7 +19,7 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n@@ -48,7 +48,7 @@ pub enum MaybeTyped<'a, 'tcx: 'a> {\n     NotTyped(&'a session::Session)\n }\n \n-pub type ExternalPaths = FnvHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n+pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n     pub map: &'a hir_map::Map<'tcx>,\n@@ -65,15 +65,15 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     /// Later on moved into `html::render::CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n-    pub external_traits: RefCell<FnvHashMap<DefId, clean::Trait>>,\n+    pub external_traits: RefCell<FxHashMap<DefId, clean::Trait>>,\n \n     // The current set of type and lifetime substitutions,\n     // for expanding type aliases at the HIR level:\n \n     /// Table type parameter definition -> substituted type\n-    pub ty_substs: RefCell<FnvHashMap<Def, clean::Type>>,\n+    pub ty_substs: RefCell<FxHashMap<Def, clean::Type>>,\n     /// Table node id of lifetime parameter definition -> substituted lifetime\n-    pub lt_substs: RefCell<FnvHashMap<ast::NodeId, clean::Lifetime>>,\n+    pub lt_substs: RefCell<FxHashMap<ast::NodeId, clean::Lifetime>>,\n }\n \n impl<'b, 'tcx> DocContext<'b, 'tcx> {\n@@ -99,8 +99,8 @@ impl<'b, 'tcx> DocContext<'b, 'tcx> {\n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n     pub fn enter_alias<F, R>(&self,\n-                             ty_substs: FnvHashMap<Def, clean::Type>,\n-                             lt_substs: FnvHashMap<ast::NodeId, clean::Lifetime>,\n+                             ty_substs: FxHashMap<Def, clean::Type>,\n+                             lt_substs: FxHashMap<ast::NodeId, clean::Lifetime>,\n                              f: F) -> R\n     where F: FnOnce() -> R {\n         let (old_tys, old_lts) ="}, {"sha": "aeb952fbaad87fd73a3d88f9b29d324da5c9c38d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -59,7 +59,7 @@ use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::hir;\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::flock;\n \n use clean::{self, Attributes, GetDefId, SelfTy, Mutability};\n@@ -111,9 +111,9 @@ pub struct SharedContext {\n     /// `true`.\n     pub include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n-    pub local_sources: FnvHashMap<PathBuf, String>,\n+    pub local_sources: FxHashMap<PathBuf, String>,\n     /// All the passes that were run on this crate.\n-    pub passes: FnvHashSet<String>,\n+    pub passes: FxHashSet<String>,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n     /// an issue number.\n     pub issue_tracker_base_url: Option<String>,\n@@ -208,43 +208,43 @@ pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n     /// when pretty-printing a type (so pretty printing doesn't have to\n     /// painfully maintain a context like this)\n-    pub typarams: FnvHashMap<DefId, String>,\n+    pub typarams: FxHashMap<DefId, String>,\n \n     /// Maps a type id to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: FnvHashMap<DefId, Vec<Impl>>,\n+    pub impls: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    pub paths: FnvHashMap<DefId, (Vec<String>, ItemType)>,\n+    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    pub external_paths: FnvHashMap<DefId, (Vec<String>, ItemType)>,\n+    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n     /// should show up in documentation about trait implementations.\n-    pub traits: FnvHashMap<DefId, clean::Trait>,\n+    pub traits: FxHashMap<DefId, clean::Trait>,\n \n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    pub implementors: FnvHashMap<DefId, Vec<Implementor>>,\n+    pub implementors: FxHashMap<DefId, Vec<Implementor>>,\n \n     /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FnvHashMap<CrateNum, (String, ExternalLocation)>,\n+    pub extern_locations: FxHashMap<CrateNum, (String, ExternalLocation)>,\n \n     /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FnvHashMap<clean::PrimitiveType, CrateNum>,\n+    pub primitive_locations: FxHashMap<clean::PrimitiveType, CrateNum>,\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n@@ -257,7 +257,7 @@ pub struct Cache {\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n-    seen_modules: FnvHashSet<DefId>,\n+    seen_modules: FxHashSet<DefId>,\n     seen_mod: bool,\n     stripped_mod: bool,\n     deref_trait_did: Option<DefId>,\n@@ -275,9 +275,9 @@ pub struct Cache {\n /// Later on moved into `CACHE_KEY`.\n #[derive(Default)]\n pub struct RenderInfo {\n-    pub inlined: FnvHashSet<DefId>,\n+    pub inlined: FxHashSet<DefId>,\n     pub external_paths: ::core::ExternalPaths,\n-    pub external_typarams: FnvHashMap<DefId, String>,\n+    pub external_typarams: FxHashMap<DefId, String>,\n     pub deref_trait_did: Option<DefId>,\n     pub deref_mut_trait_did: Option<DefId>,\n }\n@@ -376,10 +376,10 @@ impl ToJson for IndexItemFunctionType {\n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> =\n                     RefCell::new(Vec::new()));\n-thread_local!(static USED_ID_MAP: RefCell<FnvHashMap<String, usize>> =\n+thread_local!(static USED_ID_MAP: RefCell<FxHashMap<String, usize>> =\n                     RefCell::new(init_ids()));\n \n-fn init_ids() -> FnvHashMap<String, usize> {\n+fn init_ids() -> FxHashMap<String, usize> {\n     [\n      \"main\",\n      \"search\",\n@@ -406,7 +406,7 @@ pub fn reset_ids(embedded: bool) {\n         *s.borrow_mut() = if embedded {\n             init_ids()\n         } else {\n-            FnvHashMap()\n+            FxHashMap()\n         };\n     });\n }\n@@ -431,7 +431,7 @@ pub fn derive_id(candidate: String) -> String {\n pub fn run(mut krate: clean::Crate,\n            external_html: &ExternalHtml,\n            dst: PathBuf,\n-           passes: FnvHashSet<String>,\n+           passes: FxHashSet<String>,\n            css_file_extension: Option<PathBuf>,\n            renderinfo: RenderInfo) -> Result<(), Error> {\n     let src_root = match krate.src.parent() {\n@@ -442,7 +442,7 @@ pub fn run(mut krate: clean::Crate,\n         src_root: src_root,\n         passes: passes,\n         include_sources: true,\n-        local_sources: FnvHashMap(),\n+        local_sources: FxHashMap(),\n         issue_tracker_base_url: None,\n         layout: layout::Layout {\n             logo: \"\".to_string(),\n@@ -510,22 +510,22 @@ pub fn run(mut krate: clean::Crate,\n         .collect();\n \n     let mut cache = Cache {\n-        impls: FnvHashMap(),\n+        impls: FxHashMap(),\n         external_paths: external_paths,\n-        paths: FnvHashMap(),\n-        implementors: FnvHashMap(),\n+        paths: FxHashMap(),\n+        implementors: FxHashMap(),\n         stack: Vec::new(),\n         parent_stack: Vec::new(),\n         search_index: Vec::new(),\n         parent_is_trait_impl: false,\n-        extern_locations: FnvHashMap(),\n-        primitive_locations: FnvHashMap(),\n-        seen_modules: FnvHashSet(),\n+        extern_locations: FxHashMap(),\n+        primitive_locations: FxHashMap(),\n+        seen_modules: FxHashSet(),\n         seen_mod: false,\n         stripped_mod: false,\n         access_levels: krate.access_levels.clone(),\n         orphan_impl_items: Vec::new(),\n-        traits: mem::replace(&mut krate.external_traits, FnvHashMap()),\n+        traits: mem::replace(&mut krate.external_traits, FxHashMap()),\n         deref_trait_did: deref_trait_did,\n         deref_mut_trait_did: deref_mut_trait_did,\n         typarams: external_typarams,\n@@ -572,7 +572,7 @@ pub fn run(mut krate: clean::Crate,\n \n /// Build the search index from the collected metadata\n fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n-    let mut nodeid_to_pathid = FnvHashMap();\n+    let mut nodeid_to_pathid = FxHashMap();\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = Vec::<Json>::new();\n \n@@ -2655,7 +2655,7 @@ fn render_union(w: &mut fmt::Formatter, it: &clean::Item,\n #[derive(Copy, Clone)]\n enum AssocItemLink<'a> {\n     Anchor(Option<&'a str>),\n-    GotoSource(DefId, &'a FnvHashSet<String>),\n+    GotoSource(DefId, &'a FxHashSet<String>),\n }\n \n impl<'a> AssocItemLink<'a> {"}, {"sha": "6e47c037ad3dbb2f1a900c78052a4ee94c710080", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=dc8ac2679aa1c52d5860a2e6514cf7ed89b7d445", "patch": "@@ -22,7 +22,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::privacy::AccessLevel;\n-use rustc::util::nodemap::FnvHashSet;\n+use rustc::util::nodemap::FxHashSet;\n \n use rustc::hir;\n \n@@ -42,14 +42,14 @@ pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx>,\n-    view_item_stack: FnvHashSet<ast::NodeId>,\n+    view_item_stack: FxHashSet<ast::NodeId>,\n     inlining_from_glob: bool,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub fn new(cx: &'a core::DocContext<'a, 'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is reexported, terminate all recursion.\n-        let mut stack = FnvHashSet();\n+        let mut stack = FxHashSet();\n         stack.insert(ast::CRATE_NODE_ID);\n         RustdocVisitor {\n             module: Module::new(None),"}]}