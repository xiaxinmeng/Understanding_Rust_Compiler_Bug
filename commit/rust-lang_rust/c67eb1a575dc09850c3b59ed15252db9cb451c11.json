{"sha": "c67eb1a575dc09850c3b59ed15252db9cb451c11", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2N2ViMWE1NzVkYzA5ODUwYzNiNTllZDE1MjUyZGI5Y2I0NTFjMTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-30T00:01:27Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-30T00:01:27Z"}, "message": "rustc: Partially resolve external module imports", "tree": {"sha": "7e0b534ff2f22bfe0e089f07d76a6aa906ddebd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e0b534ff2f22bfe0e089f07d76a6aa906ddebd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c67eb1a575dc09850c3b59ed15252db9cb451c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c67eb1a575dc09850c3b59ed15252db9cb451c11", "html_url": "https://github.com/rust-lang/rust/commit/c67eb1a575dc09850c3b59ed15252db9cb451c11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c67eb1a575dc09850c3b59ed15252db9cb451c11/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a5feffd6cb8bb04cf61d1c265254233bb093831", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a5feffd6cb8bb04cf61d1c265254233bb093831", "html_url": "https://github.com/rust-lang/rust/commit/6a5feffd6cb8bb04cf61d1c265254233bb093831"}], "stats": {"total": 124, "additions": 104, "deletions": 20}, "files": [{"sha": "35d10422a45e40f2efd26d1e6a12e9f690527816", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c67eb1a575dc09850c3b59ed15252db9cb451c11/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67eb1a575dc09850c3b59ed15252db9cb451c11/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=c67eb1a575dc09850c3b59ed15252db9cb451c11", "patch": "@@ -540,18 +540,15 @@ fn read_crates(session.session sess,\n \n // Crate metadata queries\n \n-fn lookup_def(session.session sess, &span sp, int cnum, vec[ast.ident] path)\n-        -> ast.def {\n+fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n+        -> option.t[ast.def] {\n     auto data = sess.get_external_crate(cnum);\n \n     auto did;\n     alt (resolve_path(path, data)) {\n         case (rr_ok(?di)) { did = di; }\n         case (rr_not_found(?prev, ?name)) {\n-            sess.span_err(sp,\n-                #fmt(\"unbound name '%s' (no item named '%s' found in '%s')\",\n-                     _str.connect(path, \".\"), name, _str.connect(prev, \".\")));\n-            fail;\n+            ret none[ast.def];\n         }\n     }\n \n@@ -561,21 +558,24 @@ fn lookup_def(session.session sess, &span sp, int cnum, vec[ast.ident] path)\n     did = tup(cnum, did._1);\n \n     // FIXME: It'd be great if we had u8 char literals.\n-    if (kind_ch == ('c' as u8))      { ret ast.def_const(did);      }\n-    else if (kind_ch == ('f' as u8)) { ret ast.def_fn(did);         }\n-    else if (kind_ch == ('y' as u8)) { ret ast.def_ty(did);         }\n-    else if (kind_ch == ('o' as u8)) { ret ast.def_obj(did);        }\n-    else if (kind_ch == ('t' as u8)) { ret ast.def_ty(did);         }\n-    else if (kind_ch == ('m' as u8)) { ret ast.def_mod(did);        }\n-    else if (kind_ch == ('n' as u8)) { ret ast.def_native_mod(did); }\n+    auto def;\n+    if (kind_ch == ('c' as u8))      { def = ast.def_const(did);        }\n+    else if (kind_ch == ('f' as u8)) { def = ast.def_fn(did);           }\n+    else if (kind_ch == ('y' as u8)) { def = ast.def_ty(did);           }\n+    else if (kind_ch == ('o' as u8)) { def = ast.def_obj(did);          }\n+    else if (kind_ch == ('t' as u8)) { def = ast.def_ty(did);           }\n+    else if (kind_ch == ('m' as u8)) { def = ast.def_mod(did);          }\n+    else if (kind_ch == ('n' as u8)) { def = ast.def_native_mod(did);   }\n     else if (kind_ch == ('v' as u8)) {\n         auto tid = get_variant_tag_id(ebml_r);\n         tid = tup(cnum, tid._1);\n-        ret ast.def_variant(tid, did);\n+        def = ast.def_variant(tid, did);\n+    } else {\n+        log #fmt(\"lookup_def(): unknown kind char: %d\", kind_ch as int);\n+        fail;\n     }\n \n-    log #fmt(\"lookup_def(): unknown kind char: %d\", kind_ch as int);\n-    fail;\n+    ret some[ast.def](def);\n }\n \n fn get_type(session.session sess, ast.def_id def) -> ty.ty_params_and_ty {"}, {"sha": "e171a6006b5f684184b0fa40ee39866c6e825dae", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c67eb1a575dc09850c3b59ed15252db9cb451c11/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67eb1a575dc09850c3b59ed15252db9cb451c11/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=c67eb1a575dc09850c3b59ed15252db9cb451c11", "patch": "@@ -20,6 +20,7 @@ tag scope {\n     scope_crate(@ast.crate);\n     scope_item(@ast.item);\n     scope_native_item(@ast.native_item);\n+    scope_external_mod(ast.def_id, vec[ast.ident]);\n     scope_loop(@ast.decl); // there's only 1 decl per loop.\n     scope_block(ast.block);\n     scope_arm(ast.arm);\n@@ -37,6 +38,8 @@ tag def_wrap {\n     def_wrap_import(@ast.view_item);\n     def_wrap_mod(@ast.item);\n     def_wrap_native_mod(@ast.item);\n+    def_wrap_external_mod(ast.def_id);\n+    def_wrap_external_native_mod(ast.def_id);\n     def_wrap_other(def);\n     def_wrap_expr_field(uint, def);\n     def_wrap_resolving;\n@@ -79,6 +82,12 @@ fn unwrap_def(def_wrap d) -> def {\n                 }\n             }\n         }\n+        case (def_wrap_external_mod(?mod_id)) {\n+            ret ast.def_mod(mod_id);\n+        }\n+        case (def_wrap_external_native_mod(?mod_id)) {\n+            ret ast.def_native_mod(mod_id);\n+        }\n         case (def_wrap_other(?d)) {\n             ret d;\n         }\n@@ -100,6 +109,30 @@ fn lookup_name(&env e, ast.ident i) -> option.t[def] {\n     }\n }\n \n+fn lookup_external_def(session.session sess, int cnum, vec[ident] idents)\n+        -> option.t[def_wrap] {\n+    alt (creader.lookup_def(sess, cnum, idents)) {\n+        case (none[ast.def]) {\n+            ret none[def_wrap];\n+        }\n+        case (some[ast.def](?def)) {\n+            auto dw;\n+            alt (def) {\n+                case (ast.def_mod(?mod_id)) {\n+                    dw = def_wrap_external_mod(mod_id);\n+                }\n+                case (ast.def_native_mod(?mod_id)) {\n+                    dw = def_wrap_external_native_mod(mod_id);\n+                }\n+                case (_) {\n+                    dw = def_wrap_other(def);\n+                }\n+            }\n+            ret some[def_wrap](dw);\n+        }\n+    }\n+}\n+\n // Follow the path of an import and return what it ultimately points to.\n \n // If used after imports are resolved, import_id is none.\n@@ -136,12 +169,43 @@ fn find_final_def(&env e, import_map index,\n             }\n         }\n \n+        // TODO: Refactor with above.\n+        fn found_external_mod(&env e, &import_map index, &span sp,\n+                              vec[ident] idents, ast.def_id mod_id)\n+                -> def_wrap {\n+            auto len = _vec.len[ident](idents);\n+            auto rest_idents = _vec.slice[ident](idents, 1u, len);\n+            auto empty_e = rec(scopes = nil[scope], sess = e.sess);\n+            auto tmp_e = update_env_for_external_mod(empty_e, mod_id, idents);\n+            auto next_i = rest_idents.(0);\n+            auto next_ = lookup_name_wrapped(tmp_e, next_i);\n+            alt (next_) {\n+                case (none[tup(@env, def_wrap)]) {\n+                    e.sess.span_err(sp, \"unresolved name: \" + next_i);\n+                    fail;\n+                }\n+                case (some[tup(@env, def_wrap)](?next)) {\n+                    auto combined_e = update_env_for_external_mod(e,\n+                                                                  mod_id,\n+                                                                  idents);\n+                    ret found_something(combined_e, index, sp,\n+                                        rest_idents, next._1);\n+                }\n+            }\n+        }\n+\n         fn found_crate(&env e, &import_map index, &span sp,\n                        vec[ident] idents, int cnum) -> def_wrap {\n             auto len = _vec.len[ident](idents);\n             auto rest_idents = _vec.slice[ident](idents, 1u, len);\n-            auto def = creader.lookup_def(e.sess, sp, cnum, rest_idents);\n-            ret def_wrap_other(def);\n+            alt (lookup_external_def(e.sess, cnum, rest_idents)) {\n+                case (none[def_wrap]) {\n+                    e.sess.span_err(sp, #fmt(\"unbound name '%s'\",\n+                                             _str.connect(idents, \".\")));\n+                    fail;\n+                }\n+                case (some[def_wrap](?dw)) { ret dw; }\n+            }\n         }\n \n         alt (d) {\n@@ -168,6 +232,12 @@ fn find_final_def(&env e, import_map index,\n             case (def_wrap_native_mod(?i)) {\n                 ret found_mod(e, index, sp, idents, i);\n             }\n+            case (def_wrap_external_mod(?mod_id)) {\n+                ret found_external_mod(e, index, sp, idents, mod_id);\n+            }\n+            case (def_wrap_external_native_mod(?mod_id)) {\n+                ret found_external_mod(e, index, sp, idents, mod_id);\n+            }\n             case (def_wrap_use(?vi)) {\n                 alt (vi.node) {\n                     case (ast.view_item_use(_, _, _, ?cnum_opt)) {\n@@ -390,7 +460,8 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n         }\n     }\n \n-    fn in_scope(ast.ident i, &scope s) -> option.t[def_wrap] {\n+    fn in_scope(&session.session sess, ast.ident i, &scope s)\n+            -> option.t[def_wrap] {\n         alt (s) {\n \n             case (scope_crate(?c)) {\n@@ -450,6 +521,10 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n                 }\n             }\n \n+            case (scope_external_mod(?mod_id, ?path)) {\n+                ret lookup_external_def(sess, mod_id._0, path);\n+            }\n+\n             case (scope_loop(?d)) {\n                 alt (d.node) {\n                     case (ast.decl_local(?local)) {\n@@ -483,7 +558,7 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n             ret none[tup(@env, def_wrap)];\n         }\n         case (cons[scope](?hd, ?tl)) {\n-            auto x = in_scope(i, hd);\n+            auto x = in_scope(e.sess, i, hd);\n             alt (x) {\n                 case (some[def_wrap](?x)) {\n                     ret some(tup(@e, x));\n@@ -613,6 +688,15 @@ fn update_env_for_native_item(&env e, @ast.native_item i) -> env {\n     ret rec(scopes = cons[scope](scope_native_item(i), @e.scopes) with e);\n }\n \n+// Not actually called by fold, but here since this is analogous to\n+// update_env_for_item() above and is called by find_final_def().\n+fn update_env_for_external_mod(&env e, ast.def_id mod_id,\n+                               vec[ast.ident] idents) -> env {\n+    ret rec(scopes = cons[scope](scope_external_mod(mod_id, idents),\n+                                 @e.scopes)\n+            with e);\n+}\n+\n fn update_env_for_block(&env e, &ast.block b) -> env {\n     ret rec(scopes = cons[scope](scope_block(b), @e.scopes) with e);\n }"}]}