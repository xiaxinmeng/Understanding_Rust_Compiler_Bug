{"sha": "26c37d7b168781d8be0236fdcdcb502b6c2b8ee2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YzM3ZDdiMTY4NzgxZDhiZTAyMzZmZGNkY2I1MDJiNmMyYjhlZTI=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-05-15T01:33:04Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-05-15T01:33:13Z"}, "message": "Revert \"Remove separation between generator_drop and unwind paths\"\n\nThis reverts commit 26a7228f0fd5929f2134ac36180eb1e8ff5e16e3.", "tree": {"sha": "a5499d4d78215450575b2843b84186514adcb516", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5499d4d78215450575b2843b84186514adcb516"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26c37d7b168781d8be0236fdcdcb502b6c2b8ee2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26c37d7b168781d8be0236fdcdcb502b6c2b8ee2", "html_url": "https://github.com/rust-lang/rust/commit/26c37d7b168781d8be0236fdcdcb502b6c2b8ee2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26c37d7b168781d8be0236fdcdcb502b6c2b8ee2/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2cde9119bf59a15973065a9b594c860be1520a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2cde9119bf59a15973065a9b594c860be1520a5", "html_url": "https://github.com/rust-lang/rust/commit/e2cde9119bf59a15973065a9b594c860be1520a5"}], "stats": {"total": 81, "additions": 53, "deletions": 28}, "files": [{"sha": "3b11e335fb87f6019d901d259a0d22e15395db50", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 53, "deletions": 28, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/26c37d7b168781d8be0236fdcdcb502b6c2b8ee2/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26c37d7b168781d8be0236fdcdcb502b6c2b8ee2/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=26c37d7b168781d8be0236fdcdcb502b6c2b8ee2", "patch": "@@ -124,10 +124,7 @@ pub struct Scope<'tcx> {\n     /// The cache for drop chain on \"generator drop\" exit.\n     cached_generator_drop: Option<BasicBlock>,\n \n-    /// The cache for drop chain on \"unwind\" exit. This block\n-    /// contains code to run the current drop and all the preceding\n-    /// drops (i.e., those having lower index in Drop\u2019s Scope drop\n-    /// array)\n+    /// The cache for drop chain on \"unwind\" exit.\n     cached_unwind: CachedBlock,\n }\n \n@@ -144,7 +141,21 @@ struct DropData<'tcx> {\n }\n \n #[derive(Debug, Default, Clone, Copy)]\n-pub(crate) struct CachedBlock(Option<BasicBlock>);\n+pub(crate) struct CachedBlock {\n+    /// The cached block for the cleanups-on-diverge path. This block\n+    /// contains code to run the current drop and all the preceding\n+    /// drops (i.e., those having lower index in Drop\u2019s Scope drop\n+    /// array)\n+    unwind: Option<BasicBlock>,\n+\n+    /// The cached block for unwinds during cleanups-on-generator-drop path\n+    ///\n+    /// This is split from the standard unwind path here to prevent drop\n+    /// elaboration from creating drop flags that would have to be captured\n+    /// by the generator. I'm not sure how important this optimization is,\n+    /// but it is here.\n+    generator_drop: Option<BasicBlock>,\n+}\n \n #[derive(Debug)]\n pub(crate) enum DropKind {\n@@ -170,15 +181,24 @@ pub struct BreakableScope<'tcx> {\n \n impl CachedBlock {\n     fn invalidate(&mut self) {\n-        self.0 = None;\n+        self.generator_drop = None;\n+        self.unwind = None;\n     }\n \n-    fn get(&self) -> Option<BasicBlock> {\n-        self.0\n+    fn get(&self, generator_drop: bool) -> Option<BasicBlock> {\n+        if generator_drop {\n+            self.generator_drop\n+        } else {\n+            self.unwind\n+        }\n     }\n \n-    fn ref_mut(&mut self) -> &mut Option<BasicBlock> {\n-        &mut self.0\n+    fn ref_mut(&mut self, generator_drop: bool) -> &mut Option<BasicBlock> {\n+        if generator_drop {\n+            &mut self.generator_drop\n+        } else {\n+            &mut self.unwind\n+        }\n     }\n }\n \n@@ -358,7 +378,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         assert_eq!(scope.region_scope, region_scope.0);\n \n         let unwind_to = self.scopes.last().and_then(|next_scope| {\n-            next_scope.cached_unwind.get()\n+            next_scope.cached_unwind.get(false)\n         }).unwrap_or_else(|| self.resume_block());\n \n         unpack!(block = build_scope_drops(\n@@ -367,6 +387,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             block,\n             unwind_to,\n             self.arg_count,\n+            false,\n         ));\n \n         block.unit()\n@@ -421,7 +442,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            let unwind_to = next_scope.cached_unwind.get().unwrap_or_else(|| {\n+            let unwind_to = next_scope.cached_unwind.get(false).unwrap_or_else(|| {\n                 debug_assert!(!may_panic, \"cached block not present?\");\n                 START_BLOCK\n             });\n@@ -432,6 +453,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block,\n                 unwind_to,\n                 self.arg_count,\n+                false,\n             ));\n \n             scope = next_scope;\n@@ -448,7 +470,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// None indicates there\u2019s no cleanup to do at this point.\n     pub fn generator_drop_cleanup(&mut self) -> Option<BasicBlock> {\n         // Fill in the cache for unwinds\n-        self.diverge_cleanup_gen();\n+        self.diverge_cleanup_gen(true);\n \n         let src_info = self.scopes[0].source_info(self.fn_span);\n         let resume_block = self.resume_block();\n@@ -474,7 +496,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             };\n \n             let unwind_to = scopes.peek().as_ref().map(|scope| {\n-                scope.cached_unwind.get().unwrap_or_else(|| {\n+                scope.cached_unwind.get(true).unwrap_or_else(|| {\n                     span_bug!(src_info.span, \"cached block not present?\")\n                 })\n             }).unwrap_or(resume_block);\n@@ -485,6 +507,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block,\n                 unwind_to,\n                 self.arg_count,\n+                true,\n             ));\n         }\n \n@@ -737,7 +760,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// This path terminates in Resume. Returns the start of the path.\n     /// See module comment for more details.\n     pub fn diverge_cleanup(&mut self) -> BasicBlock {\n-        self.diverge_cleanup_gen()\n+        self.diverge_cleanup_gen(false)\n     }\n \n     fn resume_block(&mut self) -> BasicBlock {\n@@ -756,7 +779,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn diverge_cleanup_gen(&mut self) -> BasicBlock {\n+    fn diverge_cleanup_gen(&mut self, generator_drop: bool) -> BasicBlock {\n         // Build up the drops in **reverse** order. The end result will\n         // look like:\n         //\n@@ -770,15 +793,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Find the last cached block\n         let (mut target, first_uncached) = if let Some(cached_index) = self.scopes.iter()\n-            .rposition(|scope| scope.cached_unwind.get().is_some()) {\n-            (self.scopes[cached_index].cached_unwind.get().unwrap(), cached_index + 1)\n+            .rposition(|scope| scope.cached_unwind.get(generator_drop).is_some()) {\n+            (self.scopes[cached_index].cached_unwind.get(generator_drop).unwrap(), cached_index + 1)\n         } else {\n             (self.resume_block(), 0)\n         };\n \n         for scope in self.scopes[first_uncached..].iter_mut() {\n             target = build_diverge_scope(&mut self.cfg, scope.region_scope_span,\n-                                         scope, target, self.is_generator);\n+                                         scope, target, generator_drop, self.is_generator);\n         }\n \n         target\n@@ -858,6 +881,7 @@ fn build_scope_drops<'tcx>(\n     mut block: BasicBlock,\n     last_unwind_to: BasicBlock,\n     arg_count: usize,\n+    generator_drop: bool,\n ) -> BlockAnd<()> {\n     debug!(\"build_scope_drops({:?} -> {:?}\", block, scope);\n \n@@ -878,7 +902,7 @@ fn build_scope_drops<'tcx>(\n \n     let mut unwind_blocks = scope.drops.iter().rev().filter_map(|drop_data| {\n         if let DropKind::Value { cached_block } = drop_data.kind {\n-            Some(cached_block.get().unwrap_or_else(|| {\n+            Some(cached_block.get(generator_drop).unwrap_or_else(|| {\n                 span_bug!(drop_data.span, \"cached block not present?\")\n             }))\n         } else {\n@@ -922,12 +946,13 @@ fn build_scope_drops<'tcx>(\n     block.unit()\n }\n \n-fn build_diverge_scope(cfg: &mut CFG<'tcx>,\n-                       span: Span,\n-                       scope: &mut Scope<'tcx>,\n-                       mut target: BasicBlock,\n-                       is_generator: bool)\n-                       -> BasicBlock\n+fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n+                             span: Span,\n+                             scope: &mut Scope<'tcx>,\n+                             mut target: BasicBlock,\n+                             generator_drop: bool,\n+                             is_generator: bool)\n+                             -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n     // look like:\n@@ -979,7 +1004,7 @@ fn build_diverge_scope(cfg: &mut CFG<'tcx>,\n             }\n             DropKind::Storage => {}\n             DropKind::Value { ref mut cached_block } => {\n-                let cached_block = cached_block.ref_mut();\n+                let cached_block = cached_block.ref_mut(generator_drop);\n                 target = if let Some(cached_block) = *cached_block {\n                     storage_deads.clear();\n                     target_built_by_us = false;\n@@ -1002,7 +1027,7 @@ fn build_diverge_scope(cfg: &mut CFG<'tcx>,\n         };\n     }\n     push_storage_deads(cfg, &mut target, &mut storage_deads, target_built_by_us, source_scope);\n-    *scope.cached_unwind.ref_mut() = Some(target);\n+    *scope.cached_unwind.ref_mut(generator_drop) = Some(target);\n \n     assert!(storage_deads.is_empty());\n     debug!(\"build_diverge_scope({:?}, {:?}) = {:?}\", scope, span, target);"}]}