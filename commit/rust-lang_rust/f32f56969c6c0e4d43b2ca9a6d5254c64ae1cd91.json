{"sha": "f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMmY1Njk2OWM2YzBlNGQ0M2IyY2E5YTZkNTI1NGM2NGFlMWNkOTE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-12-02T08:34:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-02T08:34:10Z"}, "message": "Rollup merge of #66654 - ecstatic-morse:check-consts-ref, r=eddyb,matthewjasper\n\nHandle const-checks for `&mut` outside of `HasMutInterior`\n\nAddresses [this comment](https://github.com/rust-lang/rust/pull/64470#discussion_r328200508).\n\nConst-checking relied on `HasMutInterior` to forbid `&mut` in a const context. This was strange because all we needed to do was look for an `Rvalue::Ref` with a certain `BorrowKind`, whereas the `Qualif` traits are specifically meant to get the qualifs for a *value*. This PR removes that logic from `HasMutInterior` and moves it into `check_consts::Validator`.\n\nAs a result, we can now properly handle qualifications for `static`s, which had to be ignored previously since you can e.g. borrow a static `Cell` from another `static`. We also remove the `derived_from_illegal_borrow` logic, since it is no longer necessary; we give good errors for subsequent reborrows/borrows of illegal borrows.", "tree": {"sha": "765362e41b1528b687e4e87efd72f2a761e67a7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/765362e41b1528b687e4e87efd72f2a761e67a7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd5MyDCRBK7hj4Ov3rIwAAdHIIADlPJHmY8aG7Nxokgq95KD5W\nxC+NqjduyvlOK4rO+xfBuiwFB9Xiqwbo08phdY/mrOtrOF2v8E5RBKzGnwuHta8I\nhbuMqJwuKDlPyXRAAji7SSLcEgOBJL6Tg+MlCxICtryV/umeKPs49MSlMMfZc78e\nndQp6zZbUcYmdDGlQWVOspibGAeAu2R/g2le9o5QLCQCiTanaaf1NEgIV42EpKgR\nGKzAGxtp7p6UsO3Gw13Zbkg8C2po+fm/YXi6lrHYlqpnu2N6T2A56kJy0Brt/utm\nSnmmHukvnwOUG5bIbVDgAL1AjtrqMpU5uYmE9tpb19BBi2dV8z/6NoFmxbihg0k=\n=MtAW\n-----END PGP SIGNATURE-----\n", "payload": "tree 765362e41b1528b687e4e87efd72f2a761e67a7c\nparent 8438770e1fc647bc06745cfafc4da32dcc5b85b2\nparent ccb4eed3529eaf610f476dd6d78ecd159a897b64\nauthor Ralf Jung <post@ralfj.de> 1575275650 +0100\ncommitter GitHub <noreply@github.com> 1575275650 +0100\n\nRollup merge of #66654 - ecstatic-morse:check-consts-ref, r=eddyb,matthewjasper\n\nHandle const-checks for `&mut` outside of `HasMutInterior`\n\nAddresses [this comment](https://github.com/rust-lang/rust/pull/64470#discussion_r328200508).\n\nConst-checking relied on `HasMutInterior` to forbid `&mut` in a const context. This was strange because all we needed to do was look for an `Rvalue::Ref` with a certain `BorrowKind`, whereas the `Qualif` traits are specifically meant to get the qualifs for a *value*. This PR removes that logic from `HasMutInterior` and moves it into `check_consts::Validator`.\n\nAs a result, we can now properly handle qualifications for `static`s, which had to be ignored previously since you can e.g. borrow a static `Cell` from another `static`. We also remove the `derived_from_illegal_borrow` logic, since it is no longer necessary; we give good errors for subsequent reborrows/borrows of illegal borrows.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91", "html_url": "https://github.com/rust-lang/rust/commit/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8438770e1fc647bc06745cfafc4da32dcc5b85b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8438770e1fc647bc06745cfafc4da32dcc5b85b2", "html_url": "https://github.com/rust-lang/rust/commit/8438770e1fc647bc06745cfafc4da32dcc5b85b2"}, {"sha": "ccb4eed3529eaf610f476dd6d78ecd159a897b64", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccb4eed3529eaf610f476dd6d78ecd159a897b64", "html_url": "https://github.com/rust-lang/rust/commit/ccb4eed3529eaf610f476dd6d78ecd159a897b64"}], "stats": {"total": 326, "additions": 145, "deletions": 181}, "files": [{"sha": "f4fb9a5e4f2a2ad20a2438ca5d9835fcd272f0ad", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91", "patch": "@@ -29,6 +29,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(stmt_expr_attributes)]\n #![feature(bool_to_option)]\n #![feature(trait_alias)]\n+#![feature(matches_macro)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "2d5a0a2afcd016e0e263f0feb2ced56c7099ed07", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91", "patch": "@@ -5,7 +5,7 @@ use rustc::ty::{self, Ty};\n use rustc::hir::def_id::DefId;\n use syntax_pos::DUMMY_SP;\n \n-use super::{ConstKind, Item as ConstCx};\n+use super::Item as ConstCx;\n \n pub fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> ConstQualifs {\n     ConstQualifs {\n@@ -33,9 +33,10 @@ pub trait Qualif {\n     /// of the type.\n     fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> bool;\n \n-    fn in_static(_cx: &ConstCx<'_, 'tcx>, _def_id: DefId) -> bool {\n-        // FIXME(eddyb) should we do anything here for value properties?\n-        false\n+    fn in_static(cx: &ConstCx<'_, 'tcx>, def_id: DefId) -> bool {\n+        // `mir_const_qualif` does return the qualifs in the final value of a `static`, so we could\n+        // use value-based qualification here, but we shouldn't do this without a good reason.\n+        Self::in_any_value_of_ty(cx, cx.tcx.type_of(def_id))\n     }\n \n     fn in_projection_structurally(\n@@ -217,34 +218,6 @@ impl Qualif for HasMutInterior {\n         rvalue: &Rvalue<'tcx>,\n     ) -> bool {\n         match *rvalue {\n-            // Returning `true` for `Rvalue::Ref` indicates the borrow isn't\n-            // allowed in constants (and the `Checker` will error), and/or it\n-            // won't be promoted, due to `&mut ...` or interior mutability.\n-            Rvalue::Ref(_, kind, ref place) => {\n-                let ty = place.ty(cx.body, cx.tcx).ty;\n-\n-                if let BorrowKind::Mut { .. } = kind {\n-                    // In theory, any zero-sized value could be borrowed\n-                    // mutably without consequences.\n-                    match ty.kind {\n-                        // Inside a `static mut`, &mut [...] is also allowed.\n-                        | ty::Array(..)\n-                        | ty::Slice(_)\n-                        if cx.const_kind == Some(ConstKind::StaticMut)\n-                        => {},\n-\n-                        // FIXME(eddyb): We only return false for `&mut []` outside a const\n-                        // context which seems unnecessary given that this is merely a ZST.\n-                        | ty::Array(_, len)\n-                        if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n-                            && cx.const_kind == None\n-                        => {},\n-\n-                        _ => return true,\n-                    }\n-                }\n-            }\n-\n             Rvalue::Aggregate(ref kind, _) => {\n                 if let AggregateKind::Adt(def, ..) = **kind {\n                     if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {"}, {"sha": "783c64ece73715a61e620981d07f4861b494e2c2", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 95, "deletions": 97, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91", "patch": "@@ -23,13 +23,6 @@ use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{ConstKind, Item, Qualif, is_lang_panic_fn};\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum CheckOpResult {\n-    Forbidden,\n-    Unleashed,\n-    Allowed,\n-}\n-\n pub type IndirectlyMutableResults<'mir, 'tcx> =\n     old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n \n@@ -149,17 +142,6 @@ pub struct Validator<'a, 'mir, 'tcx> {\n \n     /// The span of the current statement.\n     span: Span,\n-\n-    /// True if the local was assigned the result of an illegal borrow (`ops::MutBorrow`).\n-    ///\n-    /// This is used to hide errors from {re,}borrowing the newly-assigned local, instead pointing\n-    /// the user to the place where the illegal borrow occurred. This set is only populated once an\n-    /// error has been emitted, so it will never cause an erroneous `mir::Body` to pass validation.\n-    ///\n-    /// FIXME(ecstaticmorse): assert at the end of checking that if `tcx.has_errors() == false`,\n-    /// this set is empty. Note that if we start removing locals from\n-    /// `derived_from_illegal_borrow`, just checking at the end won't be enough.\n-    derived_from_illegal_borrow: BitSet<Local>,\n }\n \n impl Deref for Validator<'_, 'mir, 'tcx> {\n@@ -213,7 +195,6 @@ impl Validator<'a, 'mir, 'tcx> {\n             span: item.body.span,\n             item,\n             qualifs,\n-            derived_from_illegal_borrow: BitSet::new_empty(item.body.local_decls.len()),\n         }\n     }\n \n@@ -258,15 +239,15 @@ impl Validator<'a, 'mir, 'tcx> {\n     }\n \n     /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n-    /// context. Returns `Forbidden` if an error was emitted.\n-    pub fn check_op_spanned<O>(&mut self, op: O, span: Span) -> CheckOpResult\n+    /// context.\n+    pub fn check_op_spanned<O>(&mut self, op: O, span: Span)\n     where\n         O: NonConstOp\n     {\n         trace!(\"check_op: op={:?}\", op);\n \n         if op.is_allowed_in_item(self) {\n-            return CheckOpResult::Allowed;\n+            return;\n         }\n \n         // If an operation is supported in miri (and is not already controlled by a feature gate) it\n@@ -276,20 +257,19 @@ impl Validator<'a, 'mir, 'tcx> {\n \n         if is_unleashable && self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n             self.tcx.sess.span_warn(span, \"skipping const checks\");\n-            return CheckOpResult::Unleashed;\n+            return;\n         }\n \n         op.emit_error(self, span);\n-        CheckOpResult::Forbidden\n     }\n \n     /// Emits an error if an expression cannot be evaluated in the current context.\n-    pub fn check_op(&mut self, op: impl NonConstOp) -> CheckOpResult {\n+    pub fn check_op(&mut self, op: impl NonConstOp) {\n         let span = self.span;\n         self.check_op_spanned(op, span)\n     }\n \n-    fn check_static(&mut self, def_id: DefId, span: Span) -> CheckOpResult {\n+    fn check_static(&mut self, def_id: DefId, span: Span) {\n         let is_thread_local = self.tcx.has_attr(def_id, sym::thread_local);\n         if is_thread_local {\n             self.check_op_spanned(ops::ThreadLocalAccess, span)\n@@ -322,20 +302,9 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         trace!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n \n-        // Check nested operands and places.\n+        // Special-case reborrows to be more like a copy of a reference.\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            // Special-case reborrows to be more like a copy of a reference.\n-            let mut reborrow_place = None;\n-            if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n-                if elem == ProjectionElem::Deref {\n-                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n-                    if let ty::Ref(..) = base_ty.kind {\n-                        reborrow_place = Some(proj_base);\n-                    }\n-                }\n-            }\n-\n-            if let Some(proj) = reborrow_place {\n+            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, self.body, place) {\n                 let ctx = match kind {\n                     BorrowKind::Shared => PlaceContext::NonMutatingUse(\n                         NonMutatingUseContext::SharedBorrow,\n@@ -351,14 +320,13 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                     ),\n                 };\n                 self.visit_place_base(&place.base, ctx, location);\n-                self.visit_projection(&place.base, proj, ctx, location);\n-            } else {\n-                self.super_rvalue(rvalue, location);\n+                self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n+                return;\n             }\n-        } else {\n-            self.super_rvalue(rvalue, location);\n         }\n \n+        self.super_rvalue(rvalue, location);\n+\n         match *rvalue {\n             Rvalue::Use(_) |\n             Rvalue::Repeat(..) |\n@@ -369,9 +337,58 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             Rvalue::Cast(CastKind::Pointer(_), ..) |\n             Rvalue::Discriminant(..) |\n             Rvalue::Len(_) |\n-            Rvalue::Ref(..) |\n             Rvalue::Aggregate(..) => {}\n \n+            | Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n+            | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place)\n+            => {\n+                let ty = place.ty(self.body, self.tcx).ty;\n+                let is_allowed = match ty.kind {\n+                    // Inside a `static mut`, `&mut [...]` is allowed.\n+                    ty::Array(..) | ty::Slice(_) if self.const_kind() == ConstKind::StaticMut\n+                        => true,\n+\n+                    // FIXME(ecstaticmorse): We could allow `&mut []` inside a const context given\n+                    // that this is merely a ZST and it is already eligible for promotion.\n+                    // This may require an RFC?\n+                    /*\n+                    ty::Array(_, len) if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n+                        => true,\n+                    */\n+\n+                    _ => false,\n+                };\n+\n+                if !is_allowed {\n+                    self.check_op(ops::MutBorrow(kind));\n+                }\n+            }\n+\n+            // At the moment, `PlaceBase::Static` is only used for promoted MIR.\n+            | Rvalue::Ref(_, BorrowKind::Shared, ref place)\n+            | Rvalue::Ref(_, BorrowKind::Shallow, ref place)\n+            if matches!(place.base, PlaceBase::Static(_))\n+            => bug!(\"Saw a promoted during const-checking, which must run before promotion\"),\n+\n+            | Rvalue::Ref(_, kind @ BorrowKind::Shared, ref place)\n+            | Rvalue::Ref(_, kind @ BorrowKind::Shallow, ref place)\n+            => {\n+                // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually\n+                // seek the cursors beforehand.\n+                self.qualifs.has_mut_interior.cursor.seek_before(location);\n+                self.qualifs.indirectly_mutable.seek(location);\n+\n+                let borrowed_place_has_mut_interior = HasMutInterior::in_place(\n+                    &self.item,\n+                    &|local| self.qualifs.has_mut_interior_eager_seek(local),\n+                    place.as_ref(),\n+                );\n+\n+                if borrowed_place_has_mut_interior {\n+                    self.check_op(ops::MutBorrow(kind));\n+                }\n+            }\n+\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n                 let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n@@ -436,58 +453,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n \n-    fn visit_assign(&mut self, dest: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n-        trace!(\"visit_assign: dest={:?} rvalue={:?} location={:?}\", dest, rvalue, location);\n-\n-        // Error on mutable borrows or shared borrows of values with interior mutability.\n-        //\n-        // This replicates the logic at the start of `assign` in the old const checker.  Note that\n-        // it depends on `HasMutInterior` being set for mutable borrows as well as values with\n-        // interior mutability.\n-        if let Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n-            // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually seek\n-            // the cursors beforehand.\n-            self.qualifs.has_mut_interior.cursor.seek_before(location);\n-            self.qualifs.indirectly_mutable.seek(location);\n-\n-            let rvalue_has_mut_interior = HasMutInterior::in_rvalue(\n-                &self.item,\n-                &|local| self.qualifs.has_mut_interior_eager_seek(local),\n-                rvalue,\n-            );\n-\n-            if rvalue_has_mut_interior {\n-                let is_derived_from_illegal_borrow = match borrowed_place.as_local() {\n-                    // If an unprojected local was borrowed and its value was the result of an\n-                    // illegal borrow, suppress this error and mark the result of this borrow as\n-                    // illegal as well.\n-                    Some(borrowed_local)\n-                        if self.derived_from_illegal_borrow.contains(borrowed_local) =>\n-                    {\n-                        true\n-                    }\n-\n-                    // Otherwise proceed normally: check the legality of a mutable borrow in this\n-                    // context.\n-                    _ => self.check_op(ops::MutBorrow(kind)) == CheckOpResult::Forbidden,\n-                };\n-\n-                // When the target of the assignment is a local with no projections, mark it as\n-                // derived from an illegal borrow if necessary.\n-                //\n-                // FIXME: should we also clear `derived_from_illegal_borrow` when a local is\n-                // assigned a new value?\n-                if is_derived_from_illegal_borrow {\n-                    if let Some(dest) = dest.as_local() {\n-                        self.derived_from_illegal_borrow.insert(dest);\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.super_assign(dest, rvalue, location);\n-    }\n-\n     fn visit_projection_elem(\n         &mut self,\n         place_base: &PlaceBase<'tcx>,\n@@ -724,3 +689,36 @@ fn check_return_ty_is_sync(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, hir_id: HirId)\n         }\n     });\n }\n+\n+fn place_as_reborrow(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    place: &'a Place<'tcx>,\n+) -> Option<&'a [PlaceElem<'tcx>]> {\n+    place\n+        .projection\n+        .split_last()\n+        .and_then(|(outermost, inner)| {\n+            if outermost != &ProjectionElem::Deref {\n+                return None;\n+            }\n+\n+            // A borrow of a `static` also looks like `&(*_1)` in the MIR, but `_1` is a `const`\n+            // that points to the allocation for the static. Don't treat these as reborrows.\n+            if let PlaceBase::Local(local) = place.base {\n+                if body.local_decls[local].is_ref_to_static() {\n+                    return None;\n+                }\n+            }\n+\n+            // Ensure the type being derefed is a reference and not a raw pointer.\n+            //\n+            // This is sufficient to prevent an access to a `static mut` from being marked as a\n+            // reborrow, even if the check above were to disappear.\n+            let inner_ty = Place::ty_from(&place.base, inner, body, tcx).ty;\n+            match inner_ty.kind {\n+                ty::Ref(..) => Some(inner),\n+                _ => None,\n+            }\n+        })\n+}"}, {"sha": "5e2be0d4f3f02ee73be0731b934390bdbc4de1d2", "filename": "src/test/ui/consts/const-multi-ref.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs?ref=f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91", "patch": "@@ -1,11 +1,24 @@\n-const _X: i32 = {\n+// Ensure that we point the user to the erroneous borrow but not to any subsequent borrows of that\n+// initial one.\n+\n+const _: i32 = {\n     let mut a = 5;\n-    let p = &mut a;      //~ ERROR references in constants may only refer to immutable values\n+    let p = &mut a; //~ ERROR references in constants may only refer to immutable values\n \n-    let reborrow = {p};  //~ ERROR references in constants may only refer to immutable values\n+    let reborrow = {p};\n     let pp = &reborrow;\n     let ppp = &pp;\n     ***ppp\n };\n \n+const _: std::cell::Cell<i32> = {\n+    let mut a = std::cell::Cell::new(5);\n+    let p = &a; //~ ERROR cannot borrow a constant which may contain interior mutability\n+\n+    let reborrow = {p};\n+    let pp = &reborrow;\n+    let ppp = &pp;\n+    a\n+};\n+\n fn main() {}"}, {"sha": "ed3837e9c9ee589be2aea3a8298887e2ac8dfb93", "filename": "src/test/ui/consts/const-multi-ref.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr?ref=f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91", "patch": "@@ -1,15 +1,16 @@\n error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/const-multi-ref.rs:3:13\n+  --> $DIR/const-multi-ref.rs:6:13\n    |\n LL |     let p = &mut a;\n    |             ^^^^^^ constants require immutable values\n \n-error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/const-multi-ref.rs:5:21\n+error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+  --> $DIR/const-multi-ref.rs:16:13\n    |\n-LL |     let reborrow = {p};\n-   |                     ^ constants require immutable values\n+LL |     let p = &a;\n+   |             ^^\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0017`.\n+Some errors have detailed explanations: E0017, E0492.\n+For more information about an error, try `rustc --explain E0017`."}, {"sha": "3bc518c2c2b719c8ef983aecbea807d58e9b68e4", "filename": "src/test/ui/error-codes/E0017.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs?ref=f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91", "patch": "@@ -1,8 +1,11 @@\n static X: i32 = 1;\n const C: i32 = 2;\n+static mut M: i32 = 3;\n \n const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n+                                              //~| ERROR E0019\n                                               //~| ERROR cannot borrow\n static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n+static STATIC_MUT_REF: &'static mut i32 = unsafe { &mut M }; //~ ERROR E0017\n fn main() {}"}, {"sha": "8c8660adceb7a6d1ccdec30ef256aaf07b998871", "filename": "src/test/ui/error-codes/E0017.stderr", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr?ref=f32f56969c6c0e4d43b2ca9a6d5254c64ae1cd91", "patch": "@@ -1,28 +1,40 @@\n error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/E0017.rs:4:30\n+  --> $DIR/E0017.rs:5:30\n    |\n LL | const CR: &'static mut i32 = &mut C;\n    |                              ^^^^^^ constants require immutable values\n \n+error[E0019]: static contains unimplemented expression type\n+  --> $DIR/E0017.rs:6:39\n+   |\n+LL | static STATIC_REF: &'static mut i32 = &mut X;\n+   |                                       ^^^^^^\n+\n error[E0017]: references in statics may only refer to immutable values\n-  --> $DIR/E0017.rs:5:39\n+  --> $DIR/E0017.rs:6:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X;\n    |                                       ^^^^^^ statics require immutable values\n \n error[E0596]: cannot borrow immutable static item `X` as mutable\n-  --> $DIR/E0017.rs:5:39\n+  --> $DIR/E0017.rs:6:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X;\n    |                                       ^^^^^^ cannot borrow as mutable\n \n error[E0017]: references in statics may only refer to immutable values\n-  --> $DIR/E0017.rs:7:38\n+  --> $DIR/E0017.rs:9:38\n    |\n LL | static CONST_REF: &'static mut i32 = &mut C;\n    |                                      ^^^^^^ statics require immutable values\n \n-error: aborting due to 4 previous errors\n+error[E0017]: references in statics may only refer to immutable values\n+  --> $DIR/E0017.rs:10:52\n+   |\n+LL | static STATIC_MUT_REF: &'static mut i32 = unsafe { &mut M };\n+   |                                                    ^^^^^^ statics require immutable values\n+\n+error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0017, E0596.\n+Some errors have detailed explanations: E0017, E0019, E0596.\n For more information about an error, try `rustc --explain E0017`."}, {"sha": "3aa4ac9655cc976cdad4944451b19a9ef795b391", "filename": "src/test/ui/error-codes/E0388.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8438770e1fc647bc06745cfafc4da32dcc5b85b2/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8438770e1fc647bc06745cfafc4da32dcc5b85b2/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs?ref=8438770e1fc647bc06745cfafc4da32dcc5b85b2", "patch": "@@ -1,9 +0,0 @@\n-static X: i32 = 1;\n-const C: i32 = 2;\n-\n-const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n-static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-                                              //~| ERROR cannot borrow\n-static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n-\n-fn main() {}"}, {"sha": "b52d5260b13c82444cbaf444b35425e9c4c6e4a5", "filename": "src/test/ui/error-codes/E0388.stderr", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8438770e1fc647bc06745cfafc4da32dcc5b85b2/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8438770e1fc647bc06745cfafc4da32dcc5b85b2/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr?ref=8438770e1fc647bc06745cfafc4da32dcc5b85b2", "patch": "@@ -1,28 +0,0 @@\n-error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/E0388.rs:4:30\n-   |\n-LL | const CR: &'static mut i32 = &mut C;\n-   |                              ^^^^^^ constants require immutable values\n-\n-error[E0017]: references in statics may only refer to immutable values\n-  --> $DIR/E0388.rs:5:39\n-   |\n-LL | static STATIC_REF: &'static mut i32 = &mut X;\n-   |                                       ^^^^^^ statics require immutable values\n-\n-error[E0596]: cannot borrow immutable static item `X` as mutable\n-  --> $DIR/E0388.rs:5:39\n-   |\n-LL | static STATIC_REF: &'static mut i32 = &mut X;\n-   |                                       ^^^^^^ cannot borrow as mutable\n-\n-error[E0017]: references in statics may only refer to immutable values\n-  --> $DIR/E0388.rs:7:38\n-   |\n-LL | static CONST_REF: &'static mut i32 = &mut C;\n-   |                                      ^^^^^^ statics require immutable values\n-\n-error: aborting due to 4 previous errors\n-\n-Some errors have detailed explanations: E0017, E0596.\n-For more information about an error, try `rustc --explain E0017`."}]}