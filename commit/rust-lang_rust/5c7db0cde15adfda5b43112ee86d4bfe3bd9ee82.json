{"sha": "5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjN2RiMGNkZTE1YWRmZGE1YjQzMTEyZWU4NmQ0YmZlM2JkOWVlODI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-03T23:19:26Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-03T23:19:26Z"}, "message": "Rewrite rustboot's flow-graph wiring passes to be less awful. Add test for nested control-flow constructs.", "tree": {"sha": "b4d391d5b0196cbcbd4f433742c5d6fad5e1e846", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4d391d5b0196cbcbd4f433742c5d6fad5e1e846"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82", "html_url": "https://github.com/rust-lang/rust/commit/5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f74d4d4f2e0635d644be6e2259973b5cf559a2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f74d4d4f2e0635d644be6e2259973b5cf559a2e", "html_url": "https://github.com/rust-lang/rust/commit/7f74d4d4f2e0635d644be6e2259973b5cf559a2e"}], "stats": {"total": 379, "additions": 131, "deletions": 248}, "files": [{"sha": "49cc04567c1f6bbec93b4f7c97c924064bf613c3", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82", "patch": "@@ -521,6 +521,7 @@ TEST_XFAILS_RUSTC := $(CONST_TAG_XFAILS) \\\n                         task-life-0.rs \\\n                         threads.rs \\\n                         type-sizes.rs \\\n+                        typestate-cfg-nesting.rs \\\n                         use-import-export.rs \\\n                         user.rs \\\n                         utf8.rs \\"}, {"sha": "1c9c90eaa4a031dde6b637be698b1928ba8bcaf1", "filename": "src/boot/me/typestate.ml", "status": "modified", "additions": 104, "deletions": 248, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82/src%2Fboot%2Fme%2Ftypestate.ml", "raw_url": "https://github.com/rust-lang/rust/raw/5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82/src%2Fboot%2Fme%2Ftypestate.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftypestate.ml?ref=5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82", "patch": "@@ -24,7 +24,6 @@ type typestate_tables =\n       ts_prestates: (node_id,Bits.t) Hashtbl.t;\n       ts_poststates: (node_id,Bits.t) Hashtbl.t;\n       ts_graph: node_graph;\n-      ts_siblings: sibling_map;\n       ts_stmts: Ast.stmt Stack.t;\n       ts_maxid: int ref;\n     }\n@@ -38,7 +37,6 @@ let new_tables _ =\n     ts_poststates = Hashtbl.create 0;\n     ts_prestates = Hashtbl.create 0;\n     ts_graph = Hashtbl.create 0;\n-    ts_siblings = Hashtbl.create 0;\n     ts_stmts = Stack.create ();\n     ts_maxid = ref 0 }\n ;;\n@@ -790,279 +788,143 @@ let show_node cx graph s i =\n          s (int_of_node i) (lset_fmt (Hashtbl.find graph i)))\n ;;\n \n-let graph_sequence_building_visitor\n-    (cx:ctxt)\n-    (tables_stack:typestate_tables Stack.t)\n-    (inner:Walk.visitor)\n-    : Walk.visitor =\n+let add_flow_edges (graph:node_graph) (n:node_id) (dsts:node_id list) : unit =\n+  if Hashtbl.mem graph n\n+  then\n+    let existing = Hashtbl.find graph n in\n+      Hashtbl.replace graph n (lset_union existing dsts)\n+  else\n+    Hashtbl.add graph n dsts\n+;;\n \n-  let tables _ = Stack.top tables_stack in\n+let rec build_flow_graph_for_stmt\n+    (graph:node_graph)\n+    (predecessors:node_id list)\n+    (s:Ast.stmt)\n+    : node_id list =\n \n-  (* Flow each stmt to its sequence-successor. *)\n-  let visit_stmts stmts =\n-    let ts = tables () in\n-    let graph = ts.ts_graph in\n-    let sibs = ts.ts_siblings in\n-    let len = Array.length stmts in\n-      for i = 0 to len - 2\n-      do\n-        let stmt = stmts.(i) in\n-        let next = stmts.(i+1) in\n-          log cx \"sequential stmt edge %d -> %d\"\n-            (int_of_node stmt.id) (int_of_node next.id);\n-          htab_put graph stmt.id [next.id];\n-          htab_put sibs stmt.id next.id;\n-      done;\n-      (* Flow last node to nowhere. *)\n-      if len > 0\n-      then htab_put graph stmts.(len-1).id []\n+  let connect ps qs =\n+    List.iter\n+      (fun pred -> add_flow_edges graph pred qs)\n+      ps\n   in\n \n-  let visit_stmt_pre s =\n-    (* Sequence the prelude nodes on special stmts. *)\n-    begin\n-      match s.node with\n-          Ast.STMT_while sw ->\n-            let (stmts, _) = sw.Ast.while_lval in\n-              visit_stmts stmts\n-        | _ -> ()\n-    end;\n-    inner.Walk.visit_stmt_pre s\n+  let seq ps (ss:Ast.stmt array) =\n+    build_flow_graph_for_stmts graph ps ss\n   in\n \n-  let visit_block_pre b =\n-    visit_stmts b.node;\n-    inner.Walk.visit_block_pre b\n+  let blk ps b =\n+    connect ps [b.id];\n+    seq [b.id] b.node\n   in\n \n-    { inner with\n-        Walk.visit_stmt_pre = visit_stmt_pre;\n-        Walk.visit_block_pre = visit_block_pre }\n-;;\n-\n-let add_flow_edges (graph:node_graph) (n:node_id) (dsts:node_id list) : unit =\n-  let existing = Hashtbl.find graph n in\n-    Hashtbl.replace graph n (lset_union existing dsts)\n-;;\n+  let first ss =\n+    if Array.length ss = 0\n+    then []\n+    else [ss.(0).id]\n+  in\n \n-let remove_flow_edges\n-    (graph:node_graph)\n-    (n:node_id)\n-    (dsts:node_id list)\n-    : unit =\n-  let existing = Hashtbl.find graph n in\n-    Hashtbl.replace graph n (lset_diff existing dsts)\n-;;\n+    connect [s.id] [];\n+    let outs =\n+      match s.node with\n \n+        | Ast.STMT_while sw ->\n+            let (pre_loop_stmts, _) = sw.Ast.while_lval in\n+            let body = sw.Ast.while_body in\n+            let preloop_end = seq [s.id] pre_loop_stmts in\n+              connect predecessors [s.id];\n+              connect (blk preloop_end body) (first pre_loop_stmts);\n+              preloop_end\n+\n+        | Ast.STMT_for sf ->\n+            let body_end = blk [s.id] sf.Ast.for_body in\n+              connect predecessors [s.id];\n+              connect body_end (first sf.Ast.for_body.node);\n+              body_end\n+\n+        | Ast.STMT_for_each sfe ->\n+            let head_end = blk [s.id] sfe.Ast.for_each_head in\n+            let body_end = blk head_end sfe.Ast.for_each_body in\n+              connect predecessors [s.id];\n+              connect body_end (first sfe.Ast.for_each_head.node);\n+              body_end\n+\n+        | Ast.STMT_if sif ->\n+            connect predecessors [s.id];\n+            (blk [s.id] sif.Ast.if_then) @\n+              (match sif.Ast.if_else with\n+                   None -> [s.id]\n+                 | Some els -> blk [s.id] els)\n+\n+        | Ast.STMT_alt_tag sat ->\n+            connect predecessors [s.id];\n+            Array.fold_left\n+              (fun ends {node=(_, b); id=_} -> (blk [s.id] b) @ ends)\n+              [] sat.Ast.alt_tag_arms\n+\n+        | Ast.STMT_block b ->\n+            blk predecessors b\n+\n+        | _ ->\n+            connect predecessors [s.id];\n+            [s.id]\n+    in\n+      connect outs [];\n+      outs\n \n-let last_id (nodes:('a identified) array) : node_id =\n-  let len = Array.length nodes in\n-    nodes.(len-1).id\n+and build_flow_graph_for_stmts\n+    (graph:node_graph)\n+    (predecessors:node_id list)\n+    (ss:Ast.stmt array)\n+    : node_id list =\n+  Array.fold_left (build_flow_graph_for_stmt graph) predecessors ss\n ;;\n \n-let last_id_or_block_id (block:Ast.block) : node_id =\n-  let len = Array.length block.node in\n-    if len = 0\n-    then block.id\n-    else last_id block.node\n-;;\n \n-let graph_general_block_structure_building_visitor\n+let graph_building_visitor\n     (cx:ctxt)\n     (tables_stack:typestate_tables Stack.t)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n \n   let tables _ = Stack.top tables_stack in\n+  let graph _ = (tables()).ts_graph in\n+  let blk b =\n+    add_flow_edges (graph()) b.id [];\n+    ignore (build_flow_graph_for_stmts (graph()) [b.id] b.node)\n+  in\n \n-  let visit_stmt_pre s =\n-    let ts = tables () in\n-    let stmts = ts.ts_stmts in\n-      Stack.push s stmts;\n-      inner.Walk.visit_stmt_pre s\n+  let visit_mod_item_pre n p i =\n+    begin\n+      match i.node.Ast.decl_item with\n+          Ast.MOD_ITEM_fn fn -> blk fn.Ast.fn_body\n+        | _ -> ()\n+    end;\n+    inner.Walk.visit_mod_item_pre n p i\n   in\n \n-  let visit_stmt_post s =\n-    let ts = tables () in\n-    let stmts = ts.ts_stmts in\n-      inner.Walk.visit_stmt_post s;\n-      ignore (Stack.pop stmts)\n+  let visit_obj_fn_pre obj ident fn =\n+    blk fn.node.Ast.fn_body;\n+    inner.Walk.visit_obj_fn_pre obj ident fn\n   in\n \n-  let show_node =\n-    fun n id -> show_node cx (tables()).ts_graph n id\n+  let visit_obj_drop_pre obj b =\n+    blk b;\n+    inner.Walk.visit_obj_drop_pre obj b\n   in\n \n   let visit_block_pre b =\n-    begin\n-      let ts = tables () in\n-      let graph = ts.ts_graph in\n-      let sibs = ts.ts_siblings in\n-      let stmts = ts.ts_stmts in\n-      let len = Array.length b.node in\n-      let _ = htab_put graph b.id\n-        (if len > 0 then [b.node.(0).id] else [])\n-      in\n-\n-      (*\n-       * If block has len, \n-       * then flow block to block.node.(0) and block.node.(len-1) to dsts\n-       * else flow block to dsts\n-       * \n-       * so AST:\n-       * \n-       *   block#n{ stmt#0 ... stmt#k };\n-       *   stmt#j;\n-       * \n-       * turns into graph:\n-       * \n-       *   block#n -> stmt#0 -> ... -> stmt#k -> stmt#j\n-       * \n-       *)\n-        if Stack.is_empty stmts\n-        then ()\n-        else\n-          let s = Stack.top stmts in\n-            add_flow_edges graph s.id [b.id];\n-            match htab_search sibs s.id with\n-                None -> ()\n-              | Some sib_id ->\n-                  if len > 0\n-                  then\n-                    add_flow_edges graph (last_id b.node) [sib_id]\n-                  else\n-                    add_flow_edges graph b.id [sib_id]\n-    end;\n-    show_node \"block\" b.id;\n+    if Hashtbl.mem cx.ctxt_block_is_loop_body b.id\n+    then blk b;\n     inner.Walk.visit_block_pre b\n   in\n \n     { inner with\n-        Walk.visit_stmt_pre = visit_stmt_pre;\n-        Walk.visit_stmt_post = visit_stmt_post;\n+        Walk.visit_mod_item_pre = visit_mod_item_pre;\n+        Walk.visit_obj_fn_pre = visit_obj_fn_pre;\n+        Walk.visit_obj_drop_pre = visit_obj_drop_pre;\n         Walk.visit_block_pre = visit_block_pre }\n-;;\n-\n-\n-let graph_special_block_structure_building_visitor\n-    (cx:ctxt)\n-    (tables_stack:typestate_tables Stack.t)\n-    (inner:Walk.visitor)\n-    : Walk.visitor =\n \n-  let tables _ = Stack.top tables_stack in\n-\n-  let visit_stmt_pre s =\n-    begin\n-      match s.node with\n-\n-          Ast.STMT_if sif ->\n-            let ts = tables () in\n-            let graph = ts.ts_graph in\n-            let cond_id = s.id in\n-            let succ = Hashtbl.find graph cond_id in\n-            let then_id = sif.Ast.if_then.id in\n-            let then_end_id = last_id_or_block_id sif.Ast.if_then in\n-            let show_node = show_node cx graph in\n-            let succ = List.filter (fun x -> not (x = then_id)) succ in\n-              show_node \"initial cond\" cond_id;\n-              show_node \"initial then\" then_id;\n-              show_node \"initial then_end\" then_end_id;\n-              begin\n-                match sif.Ast.if_else with\n-                    None ->\n-                        Hashtbl.replace graph cond_id (then_id :: succ);\n-                        (* Kill residual messed-up block wiring.*)\n-                        remove_flow_edges graph then_end_id [then_id];\n-                        show_node \"cond\" cond_id;\n-                        show_node \"then\" then_id;\n-                        show_node \"then_end\" then_end_id;\n-\n-                  | Some e ->\n-                      let else_id = e.id in\n-                      let succ =\n-                        List.filter (fun x -> not (x = else_id)) succ\n-                      in\n-                      let else_end_id = last_id_or_block_id e in\n-                        show_node \"initial else\" else_id;\n-                        show_node \"initial else_end\" else_end_id;\n-                        Hashtbl.replace graph cond_id [then_id; else_id];\n-                        Hashtbl.replace graph then_end_id succ;\n-                        Hashtbl.replace graph else_end_id succ;\n-\n-                        (* Kill residual messed-up block wiring.*)\n-                        remove_flow_edges graph then_end_id [then_id];\n-                        remove_flow_edges graph else_id [then_id];\n-                        remove_flow_edges graph else_end_id [then_id];\n-                        show_node \"cond\" cond_id;\n-                        show_node \"then\" then_id;\n-                        show_node \"then_end\" then_end_id;\n-                        show_node \"else\" else_id;\n-                        show_node \"else_end\" else_end_id;\n-              end;\n-\n-        | Ast.STMT_while sw ->\n-            (* There are a bunch of rewirings to do on 'while' nodes. *)\n-\n-            begin\n-              let ts = tables () in\n-              let graph = ts.ts_graph in\n-              let dsts = Hashtbl.find graph s.id in\n-              let body = sw.Ast.while_body in\n-              let succ_stmts =\n-                List.filter (fun x -> not (x = body.id)) dsts\n-              in\n-\n-              let (pre_loop_stmts, _) = sw.Ast.while_lval in\n-              let loop_head_id =\n-                (* Splice loop prelude into flow graph, save loop-head\n-                 * node.\n-                 *)\n-                let slen = Array.length pre_loop_stmts in\n-                  if slen > 0\n-                  then\n-                    begin\n-                      let pre_loop_begin = pre_loop_stmts.(0).id in\n-                      let pre_loop_end = last_id pre_loop_stmts in\n-                        remove_flow_edges graph s.id [body.id];\n-                        add_flow_edges graph s.id [pre_loop_begin];\n-                        add_flow_edges graph pre_loop_end [body.id];\n-                        pre_loop_end\n-                    end\n-                  else\n-                    body.id\n-              in\n-\n-                (* Always flow s into the loop prelude; prelude may end\n-                 * loop.\n-                 *)\n-                remove_flow_edges graph s.id succ_stmts;\n-                add_flow_edges graph loop_head_id succ_stmts;\n-\n-                (* Flow loop-end to loop-head. *)\n-                let loop_end = last_id_or_block_id body in\n-                  add_flow_edges graph loop_end [loop_head_id]\n-            end\n-\n-        | Ast.STMT_alt_tag at ->\n-            let ts = tables () in\n-            let graph = ts.ts_graph in\n-            let dsts = Hashtbl.find graph s.id in\n-            let arm_blocks =\n-              let arm_block_id { node = (_, block); id = _ } = block.id in\n-              Array.to_list (Array.map arm_block_id at.Ast.alt_tag_arms)\n-            in\n-            let succ_stmts =\n-              List.filter (fun x -> not (List.mem x arm_blocks)) dsts\n-            in\n-              remove_flow_edges graph s.id succ_stmts\n-\n-        | _ -> ()\n-    end;\n-    inner.Walk.visit_stmt_post s\n-  in\n-    { inner with\n-        Walk.visit_stmt_pre = visit_stmt_pre }\n ;;\n \n let find_roots\n@@ -1631,13 +1493,7 @@ let process_crate\n             (condition_assigning_visitor cx tables_stack scopes\n                Walk.empty_visitor)));\n       (table_managed\n-         (graph_sequence_building_visitor cx tables_stack\n-            Walk.empty_visitor));\n-      (table_managed\n-         (graph_general_block_structure_building_visitor cx tables_stack\n-            Walk.empty_visitor));\n-      (table_managed\n-         (graph_special_block_structure_building_visitor cx tables_stack\n+         (graph_building_visitor cx tables_stack\n             Walk.empty_visitor));\n     |]\n   in"}, {"sha": "8f0506469b1e5cf0f43f9e14efdb39fec58ead20", "filename": "src/test/run-pass/typestate-cfg-nesting.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82/src%2Ftest%2Frun-pass%2Ftypestate-cfg-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82/src%2Ftest%2Frun-pass%2Ftypestate-cfg-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypestate-cfg-nesting.rs?ref=5c7db0cde15adfda5b43112ee86d4bfe3bd9ee82", "patch": "@@ -0,0 +1,26 @@\n+\n+fn f() {\n+\n+  auto x = 10;\n+  auto y = 11;\n+  if (true) {\n+    alt (x) {\n+      case (_) {\n+        y = x;\n+      }\n+    }\n+  } else {\n+  }\n+}\n+\n+fn main() {\n+\n+  auto x = 10;\n+  auto y = 11;\n+  if (true) {\n+    while (false) {\n+        y = x;\n+    }\n+  } else {\n+  }\n+}"}]}