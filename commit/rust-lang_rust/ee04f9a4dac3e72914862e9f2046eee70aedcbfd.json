{"sha": "ee04f9a4dac3e72914862e9f2046eee70aedcbfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMDRmOWE0ZGFjM2U3MjkxNDg2MmU5ZjIwNDZlZWU3MGFlZGNiZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-10T23:29:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-10T23:29:57Z"}, "message": "Auto merge of #74437 - ssomers:btree_no_root_in_noderef, r=Mark-Simulacrum\n\nBTreeMap: move up reference to map's root from NodeRef\n\nSince the introduction of `NodeRef` years ago, it also contained a mutable reference to the owner of the root node of the tree (somewhat disguised as *const). Its intent is to be used only when the rest of the `NodeRef` is no longer needed. Moving this to where it's actually used, thought me 2 things:\n- Some sort of \"postponed mutable reference\" is required in most places that it is/was used, and that's exactly where we also need to store a reference to the length (number of elements) of the tree, for the same reason. The length reference can be a normal reference, because the tree code does not care about tree length (just length per node).\n- It's downright obfuscation in `from_sorted_iter` (transplanted to #75329)\n- It's one of the reasons for the scary notice on `reborrow_mut`, the other one being addressed in #73971.\n\nThis does repeat the raw pointer code in a few places, but it could be bundled up with the length reference.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "38f4ae06371563453a6dfc001af973259ac4bfbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38f4ae06371563453a6dfc001af973259ac4bfbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee04f9a4dac3e72914862e9f2046eee70aedcbfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee04f9a4dac3e72914862e9f2046eee70aedcbfd", "html_url": "https://github.com/rust-lang/rust/commit/ee04f9a4dac3e72914862e9f2046eee70aedcbfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee04f9a4dac3e72914862e9f2046eee70aedcbfd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1947b3f9e2831e2060bc42f0c78e4a2bb67930a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1947b3f9e2831e2060bc42f0c78e4a2bb67930a", "html_url": "https://github.com/rust-lang/rust/commit/a1947b3f9e2831e2060bc42f0c78e4a2bb67930a"}, {"sha": "2b54ab880c1803ff1178205b9b0a1c02238c37bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b54ab880c1803ff1178205b9b0a1c02238c37bf", "html_url": "https://github.com/rust-lang/rust/commit/2b54ab880c1803ff1178205b9b0a1c02238c37bf"}], "stats": {"total": 280, "additions": 163, "deletions": 117}, "files": [{"sha": "5c95acfbe9c2095e052048b78d485a656c4c4c02", "filename": "library/alloc/src/collections/btree/borrow.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ee04f9a4dac3e72914862e9f2046eee70aedcbfd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee04f9a4dac3e72914862e9f2046eee70aedcbfd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs?ref=ee04f9a4dac3e72914862e9f2046eee70aedcbfd", "patch": "@@ -0,0 +1,44 @@\n+use core::marker::PhantomData;\n+use core::ptr::NonNull;\n+\n+/// Models a reborrow of some unique reference, when you know that the reborrow\n+/// and all its descendants (i.e., all pointers and references derived from it)\n+/// will not be used any more at some point, after which you want to use the\n+/// original unique reference again.\n+///\n+/// The borrow checker usually handles this stacking of borrows for you, but\n+/// some control flows that accomplish this stacking are too complicated for\n+/// the compiler to follow. A `DormantMutRef` allows you to check borrowing\n+/// yourself, while still expressing its stacked nature, and encapsulating\n+/// the raw pointer code needed to do this without undefined behavior.\n+pub struct DormantMutRef<'a, T> {\n+    ptr: NonNull<T>,\n+    _marker: PhantomData<&'a mut T>,\n+}\n+\n+impl<'a, T> DormantMutRef<'a, T> {\n+    /// Capture a unique borrow, and immediately reborrow it. For the compiler,\n+    /// the lifetime of the new reference is the same as the lifetime of the\n+    /// original reference, but you promise to use it for a shorter period.\n+    pub fn new(t: &'a mut T) -> (&'a mut T, Self) {\n+        let ptr = NonNull::from(t);\n+        // SAFETY: we hold the borrow throughout 'a via `_marker`, and we expose\n+        // only this reference, so it is unique.\n+        let new_ref = unsafe { &mut *ptr.as_ptr() };\n+        (new_ref, Self { ptr, _marker: PhantomData })\n+    }\n+\n+    /// Revert to the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn awaken(self) -> &'a mut T {\n+        // SAFETY: our own safety conditions imply this reference is again unique.\n+        unsafe { &mut *self.ptr.as_ptr() }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "56a8434fc71e67be57337346419d33caf0605a6c", "filename": "library/alloc/src/collections/btree/borrow/tests.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ee04f9a4dac3e72914862e9f2046eee70aedcbfd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee04f9a4dac3e72914862e9f2046eee70aedcbfd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow%2Ftests.rs?ref=ee04f9a4dac3e72914862e9f2046eee70aedcbfd", "patch": "@@ -0,0 +1,19 @@\n+use super::DormantMutRef;\n+\n+#[test]\n+fn test_borrow() {\n+    let mut data = 1;\n+    let mut stack = vec![];\n+    let mut rr = &mut data;\n+    for factor in [2, 3, 7].iter() {\n+        let (r, dormant_r) = DormantMutRef::new(rr);\n+        rr = r;\n+        assert_eq!(*rr, 1);\n+        stack.push((factor, dormant_r));\n+    }\n+    while let Some((factor, dormant_r)) = stack.pop() {\n+        let r = unsafe { dormant_r.awaken() };\n+        *r *= factor;\n+    }\n+    assert_eq!(data, 42);\n+}"}, {"sha": "aed898be08fb681305840287935fd4a88458f4fd", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 72, "deletions": 49, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/ee04f9a4dac3e72914862e9f2046eee70aedcbfd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee04f9a4dac3e72914862e9f2046eee70aedcbfd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=ee04f9a4dac3e72914862e9f2046eee70aedcbfd", "patch": "@@ -8,6 +8,7 @@ use core::mem::{self, ManuallyDrop};\n use core::ops::{Index, RangeBounds};\n use core::ptr;\n \n+use super::borrow::DormantMutRef;\n use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n use super::search::{self, SearchResult::*};\n use super::unwrap_unchecked;\n@@ -228,24 +229,23 @@ where\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n-        let root_node = self.root.as_mut()?.node_as_mut();\n+        let (map, dormant_map) = DormantMutRef::new(self);\n+        let root_node = map.root.as_mut()?.node_as_mut();\n         match search::search_tree(root_node, key) {\n-            Found(handle) => Some(\n-                OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n-                    .remove_kv()\n-                    .0,\n-            ),\n+            Found(handle) => {\n+                Some(OccupiedEntry { handle, dormant_map, _marker: PhantomData }.remove_kv().0)\n+            }\n             GoDown(_) => None,\n         }\n     }\n \n     fn replace(&mut self, key: K) -> Option<K> {\n-        let root = Self::ensure_is_owned(&mut self.root);\n-        match search::search_tree::<marker::Mut<'_>, K, (), K>(root.node_as_mut(), &key) {\n+        let (map, dormant_map) = DormantMutRef::new(self);\n+        let root_node = Self::ensure_is_owned(&mut map.root).node_as_mut();\n+        match search::search_tree::<marker::Mut<'_>, K, (), K>(root_node, &key) {\n             Found(handle) => Some(mem::replace(handle.into_key_mut(), key)),\n             GoDown(handle) => {\n-                VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData }\n-                    .insert(());\n+                VacantEntry { key, handle, dormant_map, _marker: PhantomData }.insert(());\n                 None\n             }\n         }\n@@ -459,7 +459,7 @@ impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     key: K,\n     handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    length: &'a mut usize,\n+    dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n \n     // Be invariant in `K` and `V`\n     _marker: PhantomData<&'a mut (K, V)>,\n@@ -479,8 +479,7 @@ impl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n-\n-    length: &'a mut usize,\n+    dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n \n     // Be invariant in `K` and `V`\n     _marker: PhantomData<&'a mut (K, V)>,\n@@ -644,13 +643,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n-        let root_node = self.root.as_mut()?.node_as_mut();\n+        let (map, dormant_map) = DormantMutRef::new(self);\n+        let root_node = map.root.as_mut()?.node_as_mut();\n         let kv = root_node.first_leaf_edge().right_kv().ok()?;\n-        Some(OccupiedEntry {\n-            handle: kv.forget_node_type(),\n-            length: &mut self.length,\n-            _marker: PhantomData,\n-        })\n+        Some(OccupiedEntry { handle: kv.forget_node_type(), dormant_map, _marker: PhantomData })\n     }\n \n     /// Removes and returns the first element in the map.\n@@ -721,13 +717,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n-        let root_node = self.root.as_mut()?.node_as_mut();\n+        let (map, dormant_map) = DormantMutRef::new(self);\n+        let root_node = map.root.as_mut()?.node_as_mut();\n         let kv = root_node.last_leaf_edge().left_kv().ok()?;\n-        Some(OccupiedEntry {\n-            handle: kv.forget_node_type(),\n-            length: &mut self.length,\n-            _marker: PhantomData,\n-        })\n+        Some(OccupiedEntry { handle: kv.forget_node_type(), dormant_map, _marker: PhantomData })\n     }\n \n     /// Removes and returns the last element in the map.\n@@ -901,12 +894,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        let root_node = self.root.as_mut()?.node_as_mut();\n+        let (map, dormant_map) = DormantMutRef::new(self);\n+        let root_node = map.root.as_mut()?.node_as_mut();\n         match search::search_tree(root_node, key) {\n-            Found(handle) => Some(\n-                OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n-                    .remove_entry(),\n-            ),\n+            Found(handle) => {\n+                Some(OccupiedEntry { handle, dormant_map, _marker: PhantomData }.remove_entry())\n+            }\n             GoDown(_) => None,\n         }\n     }\n@@ -1073,13 +1066,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n-        let root = Self::ensure_is_owned(&mut self.root);\n-        match search::search_tree(root.node_as_mut(), &key) {\n-            Found(handle) => {\n-                Occupied(OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData })\n-            }\n+        let (map, dormant_map) = DormantMutRef::new(self);\n+        let root_node = Self::ensure_is_owned(&mut map.root).node_as_mut();\n+        match search::search_tree(root_node, &key) {\n+            Found(handle) => Occupied(OccupiedEntry { handle, dormant_map, _marker: PhantomData }),\n             GoDown(handle) => {\n-                Vacant(VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData })\n+                Vacant(VacantEntry { key, handle, dormant_map, _marker: PhantomData })\n             }\n         }\n     }\n@@ -1284,9 +1276,17 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n \n     pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n-        let root_node = self.root.as_mut().map(|r| r.node_as_mut());\n-        let front = root_node.map(|rn| rn.first_leaf_edge());\n-        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n+        if let Some(root) = self.root.as_mut() {\n+            let (root, dormant_root) = DormantMutRef::new(root);\n+            let front = root.node_as_mut().first_leaf_edge();\n+            DrainFilterInner {\n+                length: &mut self.length,\n+                dormant_root: Some(dormant_root),\n+                cur_leaf_edge: Some(front),\n+            }\n+        } else {\n+            DrainFilterInner { length: &mut self.length, dormant_root: None, cur_leaf_edge: None }\n+        }\n     }\n \n     /// Creates a consuming iterator visiting all the keys, in sorted order.\n@@ -1671,6 +1671,9 @@ where\n /// of the predicate, thus also serving for BTreeSet::DrainFilter.\n pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n+    // dormant_root is wrapped in an Option to be able to `take` it.\n+    dormant_root: Option<DormantMutRef<'a, node::Root<K, V>>>,\n+    // cur_leaf_edge is wrapped in an Option because maps without root lack a leaf edge.\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n }\n \n@@ -1728,7 +1731,13 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n-                let (kv, pos) = kv.remove_kv_tracking();\n+                let (kv, pos) = kv.remove_kv_tracking(|| {\n+                    // SAFETY: we will touch the root in a way that will not\n+                    // invalidate the position returned.\n+                    let root = unsafe { self.dormant_root.take().unwrap().awaken() };\n+                    root.pop_internal_level();\n+                    self.dormant_root = Some(DormantMutRef::new(root).1);\n+                });\n                 self.cur_leaf_edge = Some(pos);\n                 return Some(kv);\n             }\n@@ -2456,13 +2465,20 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n-        *self.length += 1;\n-\n         let out_ptr = match self.handle.insert_recursing(self.key, value) {\n-            (Fit(_), val_ptr) => val_ptr,\n+            (Fit(_), val_ptr) => {\n+                // Safety: We have consumed self.handle and the handle returned.\n+                let map = unsafe { self.dormant_map.awaken() };\n+                map.length += 1;\n+                val_ptr\n+            }\n             (Split(ins), val_ptr) => {\n-                let root = ins.left.into_root_mut();\n+                drop(ins.left);\n+                // Safety: We have consumed self.handle and the reference returned.\n+                let map = unsafe { self.dormant_map.awaken() };\n+                let root = map.root.as_mut().unwrap();\n                 root.push_internal_level().push(ins.k, ins.v, ins.right);\n+                map.length += 1;\n                 val_ptr\n             }\n         };\n@@ -2636,18 +2652,25 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n     // Body of `remove_entry`, separate to keep the above implementations short.\n     fn remove_kv(self) -> (K, V) {\n-        *self.length -= 1;\n-\n-        let (old_kv, _) = self.handle.remove_kv_tracking();\n+        let mut emptied_internal_root = false;\n+        let (old_kv, _) = self.handle.remove_kv_tracking(|| emptied_internal_root = true);\n+        // SAFETY: we consumed the intermediate root borrow, `self.handle`.\n+        let map = unsafe { self.dormant_map.awaken() };\n+        map.length -= 1;\n+        if emptied_internal_root {\n+            let root = map.root.as_mut().unwrap();\n+            root.pop_internal_level();\n+        }\n         old_kv\n     }\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n     /// Removes a key/value-pair from the map, and returns that pair, as well as\n     /// the leaf edge corresponding to that former pair.\n-    fn remove_kv_tracking(\n+    fn remove_kv_tracking<F: FnOnce()>(\n         self,\n+        handle_emptied_internal_root: F,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         let (old_kv, mut pos, was_internal) = match self.force() {\n             Leaf(leaf) => {\n@@ -2700,7 +2723,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n                         // The parent that was just emptied must be the root,\n                         // because nodes on a lower level would not have been\n                         // left with a single child.\n-                        parent.into_root_mut().pop_internal_level();\n+                        handle_emptied_internal_root();\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();"}, {"sha": "ecbdacda4b618cd510ab5330f3cffe7c502ea979", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee04f9a4dac3e72914862e9f2046eee70aedcbfd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee04f9a4dac3e72914862e9f2046eee70aedcbfd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=ee04f9a4dac3e72914862e9f2046eee70aedcbfd", "patch": "@@ -1,3 +1,4 @@\n+mod borrow;\n pub mod map;\n mod navigate;\n mod node;"}, {"sha": "8832619a404cb252506adcdf48d574b635595bef", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 27, "deletions": 68, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ee04f9a4dac3e72914862e9f2046eee70aedcbfd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee04f9a4dac3e72914862e9f2046eee70aedcbfd/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=ee04f9a4dac3e72914862e9f2046eee70aedcbfd", "patch": "@@ -168,40 +168,20 @@ impl<K, V> Root<K, V> {\n \n     /// Borrows and returns an immutable reference to the node owned by the root.\n     pub fn node_as_ref(&self) -> NodeRef<marker::Immut<'_>, K, V, marker::LeafOrInternal> {\n-        NodeRef {\n-            height: self.height,\n-            node: self.node.as_ptr(),\n-            root: ptr::null(),\n-            _marker: PhantomData,\n-        }\n+        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n     }\n \n     /// Borrows and returns a mutable reference to the node owned by the root.\n     pub fn node_as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal> {\n-        NodeRef {\n-            height: self.height,\n-            node: self.node.as_ptr(),\n-            root: self as *mut _,\n-            _marker: PhantomData,\n-        }\n+        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n     }\n \n     pub fn node_as_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, marker::LeafOrInternal> {\n-        NodeRef {\n-            height: self.height,\n-            node: self.node.as_ptr(),\n-            root: ptr::null(),\n-            _marker: PhantomData,\n-        }\n+        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n     }\n \n     pub fn into_ref(self) -> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n-        NodeRef {\n-            height: self.height,\n-            node: self.node.as_ptr(),\n-            root: ptr::null(),\n-            _marker: PhantomData,\n-        }\n+        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n     }\n \n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n@@ -214,12 +194,8 @@ impl<K, V> Root<K, V> {\n         self.node = BoxedNode::from_internal(new_node);\n         self.height += 1;\n \n-        let mut ret = NodeRef {\n-            height: self.height,\n-            node: self.node.as_ptr(),\n-            root: self as *mut _,\n-            _marker: PhantomData,\n-        };\n+        let mut ret =\n+            NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData };\n \n         unsafe {\n             ret.reborrow_mut().first_edge().correct_parent_link();\n@@ -228,11 +204,15 @@ impl<K, V> Root<K, V> {\n         ret\n     }\n \n-    /// Removes the internal root node, using its first child as the new root.\n-    /// As it is intended only to be called when the root has only one child,\n-    /// no cleanup is done on any of the other children of the root.\n+    /// Removes the internal root node, using its first child as the new root node.\n+    /// As it is intended only to be called when the root node has only one child,\n+    /// no cleanup is done on any of the other children.\n     /// This decreases the height by 1 and is the opposite of `push_internal_level`.\n-    /// Panics if there is no internal level, i.e. if the root is a leaf.\n+    ///\n+    /// Requires exclusive access to the `Root` object but not to the root node;\n+    /// it will not invalidate existing handles or references to the root node.\n+    ///\n+    /// Panics if there is no internal level, i.e., if the root node is a leaf.\n     pub fn pop_internal_level(&mut self) {\n         assert!(self.height > 0);\n \n@@ -276,8 +256,6 @@ pub struct NodeRef<BorrowType, K, V, Type> {\n     /// The number of levels below the node.\n     height: usize,\n     node: NonNull<LeafNode<K, V>>,\n-    // `root` is null unless the borrow type is `Mut`\n-    root: *const Root<K, V>,\n     _marker: PhantomData<(BorrowType, Type)>,\n }\n \n@@ -342,7 +320,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n \n     /// Temporarily takes out another, immutable reference to the same node.\n     fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n-        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n     /// Exposes the leaf \"portion\" of any leaf or internal node.\n@@ -390,12 +368,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         let parent_as_leaf = unsafe { (*self.as_leaf_ptr()).parent as *const LeafNode<K, V> };\n         if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n-                node: NodeRef {\n-                    height: self.height + 1,\n-                    node: non_zero,\n-                    root: self.root,\n-                    _marker: PhantomData,\n-                },\n+                node: NodeRef { height: self.height + 1, node: non_zero, _marker: PhantomData },\n                 idx: unsafe { usize::from(*(*self.as_leaf_ptr()).parent_idx.as_ptr()) },\n                 _marker: PhantomData,\n             })\n@@ -465,21 +438,21 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// Unsafely asserts to the compiler some static information about whether this\n     /// node is a `Leaf` or an `Internal`.\n     unsafe fn cast_unchecked<NewType>(self) -> NodeRef<marker::Mut<'a>, K, V, NewType> {\n-        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n     /// Temporarily takes out another, mutable reference to the same node. Beware, as\n     /// this method is very dangerous, doubly so since it may not immediately appear\n     /// dangerous.\n     ///\n-    /// Because mutable pointers can roam anywhere around the tree and can even (through\n-    /// `into_root_mut`) mess with the root of the tree, the result of `reborrow_mut`\n-    /// can easily be used to make the original mutable pointer dangling, or, in the case\n-    /// of a reborrowed handle, out of bounds.\n-    // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n-    // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n+    /// Because mutable pointers can roam anywhere around the tree, the returned\n+    /// pointer can easily be used to make the original pointer dangling, out of\n+    /// bounds, or invalid under stacked borrow rules.\n+    // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef`\n+    // that restricts the use of navigation methods on reborrowed pointers,\n+    // preventing this unsafety.\n     unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {\n-        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n     /// Exposes the leaf \"portion\" of any leaf or internal node for writing.\n@@ -522,12 +495,6 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    /// Gets a mutable reference to the root itself. This is useful primarily when the\n-    /// height of the tree needs to be adjusted. Never call this on a reborrowed pointer.\n-    pub fn into_root_mut(self) -> &'a mut Root<K, V> {\n-        unsafe { &mut *(self.root as *mut Root<K, V>) }\n-    }\n-\n     fn into_key_slice_mut(mut self) -> &'a mut [K] {\n         // SAFETY: The keys of a node must always be initialized up to length.\n         unsafe {\n@@ -757,14 +724,12 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n             ForceResult::Leaf(NodeRef {\n                 height: self.height,\n                 node: self.node,\n-                root: self.root,\n                 _marker: PhantomData,\n             })\n         } else {\n             ForceResult::Internal(NodeRef {\n                 height: self.height,\n                 node: self.node,\n-                root: self.root,\n                 _marker: PhantomData,\n             })\n         }\n@@ -855,12 +820,7 @@ impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeT\n     /// this method is very dangerous, doubly so since it may not immediately appear\n     /// dangerous.\n     ///\n-    /// Because mutable pointers can roam anywhere around the tree and can even (through\n-    /// `into_root_mut`) mess with the root of the tree, the result of `reborrow_mut`\n-    /// can easily be used to make the original mutable pointer dangling, or, in the case\n-    /// of a reborrowed handle, out of bounds.\n-    // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n-    // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n+    /// For details, see `NodeRef::reborrow_mut`.\n     pub unsafe fn reborrow_mut(\n         &mut self,\n     ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NodeType>, HandleType> {\n@@ -1106,7 +1066,6 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n         NodeRef {\n             height: self.node.height - 1,\n             node: unsafe { (&*(*internal_node).edges.get_unchecked(self.idx).as_ptr()).as_ptr() },\n-            root: self.node.root,\n             _marker: PhantomData,\n         }\n     }\n@@ -1499,14 +1458,14 @@ unsafe fn move_edges<K, V>(\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Leaf> {\n     /// Removes any static information asserting that this node is a `Leaf` node.\n     pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n }\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     /// Removes any static information asserting that this node is an `Internal` node.\n     pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n }\n "}]}