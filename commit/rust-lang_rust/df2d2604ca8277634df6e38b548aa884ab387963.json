{"sha": "df2d2604ca8277634df6e38b548aa884ab387963", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMmQyNjA0Y2E4Mjc3NjM0ZGY2ZTM4YjU0OGFhODg0YWIzODc5NjM=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-12T23:52:02Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-14T00:13:53Z"}, "message": "Reintroduce linked failure\n\nThis reverts commit acb86921a62ba01726fd922f55d0176fa6c1df7c.", "tree": {"sha": "34b8916d68e9d7b0185f63f8da9cb3b5c5a0ef3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34b8916d68e9d7b0185f63f8da9cb3b5c5a0ef3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df2d2604ca8277634df6e38b548aa884ab387963", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df2d2604ca8277634df6e38b548aa884ab387963", "html_url": "https://github.com/rust-lang/rust/commit/df2d2604ca8277634df6e38b548aa884ab387963", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df2d2604ca8277634df6e38b548aa884ab387963/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad5c4ed351766d5cc97f74f9a4ef784950654e15", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad5c4ed351766d5cc97f74f9a4ef784950654e15", "html_url": "https://github.com/rust-lang/rust/commit/ad5c4ed351766d5cc97f74f9a4ef784950654e15"}], "stats": {"total": 255, "additions": 188, "deletions": 67}, "files": [{"sha": "0ddf3d77c91f2f95c935bdbc93f165a3b6adc89e", "filename": "src/libcore/task.rs", "status": "modified", "additions": 183, "deletions": 35, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/df2d2604ca8277634df6e38b548aa884ab387963/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2d2604ca8277634df6e38b548aa884ab387963/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=df2d2604ca8277634df6e38b548aa884ab387963", "patch": "@@ -26,6 +26,7 @@\n import result::result;\n import dvec::extensions;\n import dvec_iter::extensions;\n+import arc::methods;\n \n export task;\n export task_result;\n@@ -563,7 +564,11 @@ unsafe fn unkillable(f: fn()) {\n }\n \n \n-/* Internal */\n+/****************************************************************************\n+ * Internal\n+ ****************************************************************************/\n+\n+/* spawning */\n \n type sched_id = int;\n type task_id = int;\n@@ -573,42 +578,185 @@ type task_id = int;\n type rust_task = libc::c_void;\n type rust_closure = libc::c_void;\n \n-fn spawn_raw(opts: task_opts, +f: fn~()) {\n+/* linked failure */\n+\n+type taskgroup_arc = arc::exclusive<option<dvec::dvec<option<*rust_task>>>>;\n+\n+class taskgroup {\n+    // FIXME (#2816): Change dvec to an O(1) data structure (and change 'me'\n+    // to a node-handle or somesuch when so done (or remove the field entirely\n+    // if keyed by *rust_task)).\n+    let tasks:      taskgroup_arc; // 'none' means the group already failed.\n+    let me:         *rust_task;\n+    let my_pos:     uint;\n+    // let parent_group: taskgroup_arc; // TODO(bblum)\n+    // TODO XXX bblum: add a list of empty slots to get runtime back\n+    let mut failed: bool;\n+    new(-tasks: taskgroup_arc, me: *rust_task, my_pos: uint) {\n+        self.tasks = tasks; self.me = me; self.my_pos = my_pos;\n+        self.failed = true; // This will get un-set on successful exit.\n+    }\n+    // Runs on task exit.\n+    drop {\n+        if self.failed {\n+            // Take everybody down with us.\n+            kill_taskgroup(self.tasks, self.me, self.my_pos);\n+        } else {\n+            // Remove ourselves from the group.\n+            leave_taskgroup(self.tasks, self.me, self.my_pos);\n+        }\n+    }\n+}\n \n-    let mut f = if opts.supervise {\n-        f\n-    } else {\n-        // FIXME (#1868, #1789): The runtime supervision API is weird here\n-        // because it was designed to let the child unsupervise itself,\n-        // when what we actually want is for parents to unsupervise new\n-        // children.\n-        fn~() {\n-            rustrt::unsupervise();\n-            f();\n+fn taskgroup_key(+_group: @taskgroup) { } // For TLS\n+\n+fn enlist_in_taskgroup(group_arc: taskgroup_arc,\n+                       me: *rust_task) -> option<uint> {\n+    do group_arc.with |_c, state| {\n+        // If 'none', the group was failing. Can't enlist.\n+        do state.map |tasks| {\n+            // Try to find an empty slot.\n+            alt tasks.position(|x| x == none) {\n+                some(empty_index) {\n+                    tasks.set_elt(empty_index, some(me));\n+                    empty_index\n+                }\n+                none {\n+                    tasks.push(some(me));\n+                    tasks.len() - 1\n+                }\n+            }\n         }\n-    };\n+    }\n+}\n \n-    unsafe {\n-        let fptr = ptr::addr_of(f);\n-        let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n+// NB: Runs in destructor/post-exit context. Can't 'fail'.\n+fn leave_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint) {\n+    do group_arc.with |_c, state| {\n+        // If 'none', already failing and we've already gotten a kill signal.\n+        do state.map |tasks| {\n+            assert tasks[index] == some(me);\n+            tasks.set_elt(index, none);\n+        };\n+    };\n+}\n \n-        let new_task = alt opts.sched {\n-          none {\n-            rustrt::new_task()\n-          }\n-          some(sched_opts) {\n-            new_task_in_new_sched(sched_opts)\n-          }\n+// NB: Runs in destructor/post-exit context. Can't 'fail'.\n+fn kill_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint) {\n+    // NB: We could do the killing iteration outside of the group arc, by\n+    // having \"let mut newstate\" here, swapping inside, and iterating after.\n+    // But that would let other exiting tasks fall-through and exit while we\n+    // were trying to kill them, causing potential use-after-free. A task's\n+    // presence in the arc guarantees it's alive only while we hold the lock,\n+    // so if we're failing, all concurrently exiting tasks must wait for us.\n+    // To do it differently, we'd have to use the runtime's task refcounting.\n+    do group_arc.with |_c, state| {\n+        let mut newstate = none;\n+        *state <-> newstate;\n+        // Might already be none, if somebody is failing simultaneously.\n+        // That's ok; only one task needs to do the dirty work. (Might also\n+        // see 'none' if somebody already failed and we got a kill signal.)\n+        do newstate.map |tasks| {\n+            // First remove ourself (killing ourself won't do much good). This\n+            // is duplicated here to avoid having to lock twice.\n+            assert tasks[index] == some(me);\n+            tasks.set_elt(index, none);\n+            // Now send takedown signal.\n+            for tasks.each |entry| {\n+                do entry.map |task| {\n+                    rustrt::rust_task_kill_other(task);\n+                };\n+            }\n         };\n-        assert !new_task.is_null();\n+    };\n+}\n+\n+fn share_parent_taskgroup() -> taskgroup_arc {\n+    let me = rustrt::rust_get_task();\n+    alt unsafe { local_get(me, taskgroup_key) } {\n+        some(group) {\n+            group.tasks.clone()\n+        }\n+        none {\n+            /* Main task, doing first spawn ever. */\n+            let tasks = arc::exclusive(some(dvec::from_elem(some(me))));\n+            let group = @taskgroup(tasks.clone(), me, 0);\n+            unsafe { local_set(me, taskgroup_key, group); }\n+            tasks\n+        }\n+    }\n+}\n+\n+fn spawn_raw(opts: task_opts, +f: fn~()) {\n+    // Decide whether the child needs to be in a new linked failure group.\n+    let child_tg: taskgroup_arc = if opts.supervise {\n+        share_parent_taskgroup()\n+    } else {\n+        arc::exclusive(some(dvec::from_elem(none)))\n+    };\n \n-        do option::iter(opts.notify_chan) |c| {\n-            // FIXME (#1087): Would like to do notification in Rust\n-            rustrt::rust_task_config_notify(new_task, c);\n+    unsafe {\n+        let child_data_ptr = ~mut some((child_tg, f));\n+        // Being killed with the unsafe task/closure pointers would leak them.\n+        do unkillable {\n+            // Agh. Get move-mode items into the closure. FIXME (#2829)\n+            let mut child_data = none;\n+            *child_data_ptr <-> child_data;\n+            let (child_tg, f) = option::unwrap(child_data);\n+            // Create child task.\n+            let new_task = alt opts.sched {\n+              none             { rustrt::new_task() }\n+              some(sched_opts) { new_task_in_new_sched(sched_opts) }\n+            };\n+            assert !new_task.is_null();\n+            // Getting killed after here would leak the task.\n+\n+            let child_wrapper =\n+                make_child_wrapper(new_task, child_tg, opts.supervise, f);\n+            let fptr = ptr::addr_of(child_wrapper);\n+            let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n+\n+            do option::iter(opts.notify_chan) |c| {\n+                // FIXME (#1087): Would like to do notification in Rust\n+                rustrt::rust_task_config_notify(new_task, c);\n+            }\n+\n+            // Getting killed between these two calls would free the child's\n+            // closure. (Reordering them wouldn't help - then getting killed\n+            // between them would leak.)\n+            rustrt::start_task(new_task, closure);\n+            unsafe::forget(child_wrapper);\n         }\n+    }\n \n-        rustrt::start_task(new_task, closure);\n-        unsafe::forget(f);\n+    fn make_child_wrapper(child_task: *rust_task, -child_tg: taskgroup_arc,\n+                          supervise: bool, -f: fn~()) -> fn~() {\n+        let child_tg_ptr = ~mut some(child_tg);\n+        fn~() {\n+            // Agh. Get move-mode items into the closure. FIXME (#2829)\n+            let mut child_tg_opt = none;\n+            *child_tg_ptr <-> child_tg_opt;\n+            let child_tg = option::unwrap(child_tg_opt);\n+            // Child task runs this code.\n+            if !supervise {\n+                // FIXME (#1868, #1789) take this out later\n+                rustrt::unsupervise();\n+            }\n+            // Set up membership in taskgroup. If this returns none, the\n+            // parent was already failing, so don't bother doing anything.\n+            alt enlist_in_taskgroup(child_tg, child_task) {\n+                some(my_index) {\n+                    let group = @taskgroup(child_tg, child_task, my_index);\n+                    unsafe { local_set(child_task, taskgroup_key, group); }\n+                    // Run the child's body.\n+                    f();\n+                    // Report successful exit. (TLS cleanup code will tear\n+                    // down the group.)\n+                    group.failed = false;\n+                }\n+                none { }\n+            }\n+        }\n     }\n \n     fn new_task_in_new_sched(opts: sched_opts) -> *rust_task {\n@@ -640,7 +788,6 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n         };\n         rustrt::rust_new_task_in_sched(sched_id)\n     }\n-\n }\n \n /****************************************************************************\n@@ -760,7 +907,7 @@ unsafe fn local_get<T>(task: *rust_task,\n     local_get_helper(task, key, false)\n }\n \n-unsafe fn local_set<T>(task: *rust_task, key: local_data_key<T>, -data: @T) {\n+unsafe fn local_set<T>(task: *rust_task, key: local_data_key<T>, +data: @T) {\n     let map = get_task_local_map(task);\n     // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n     let keyval = key_to_key_value(key);\n@@ -822,7 +969,7 @@ unsafe fn local_data_get<T>(key: local_data_key<T>) -> option<@T> {\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n-unsafe fn local_data_set<T>(key: local_data_key<T>, -data: @T) {\n+unsafe fn local_data_set<T>(key: local_data_key<T>, +data: @T) {\n     local_set(rustrt::rust_get_task(), key, data)\n }\n /**\n@@ -853,11 +1000,12 @@ extern mod rustrt {\n \n     fn start_task(task: *rust_task, closure: *rust_closure);\n \n-    fn rust_task_is_unwinding(rt: *rust_task) -> bool;\n+    fn rust_task_is_unwinding(task: *rust_task) -> bool;\n     fn unsupervise();\n     fn rust_osmain_sched_id() -> sched_id;\n     fn rust_task_inhibit_kill();\n     fn rust_task_allow_kill();\n+    fn rust_task_kill_other(task: *rust_task);\n \n     #[rust_stack]\n     fn rust_get_task_local_data(task: *rust_task) -> *libc::c_void;\n@@ -1232,7 +1380,7 @@ fn test_unkillable() {\n     let ch = po.chan();\n \n     // We want to do this after failing\n-    do spawn {\n+    do spawn_raw({ supervise: false with default_task_opts() }) {\n         for iter::repeat(10u) { yield() }\n         ch.send(());\n     }\n@@ -1269,7 +1417,7 @@ fn test_unkillable_nested() {\n     let ch = po.chan();\n \n     // We want to do this after failing\n-    do spawn {\n+    do spawn_raw({ supervise: false with default_task_opts() }) {\n         for iter::repeat(10u) { yield() }\n         ch.send(());\n     }"}, {"sha": "d23d74b0ea2f41ea8ca4c245e3922c9617bdec30", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 5, "deletions": 30, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/df2d2604ca8277634df6e38b548aa884ab387963/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/df2d2604ca8277634df6e38b548aa884ab387963/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=df2d2604ca8277634df6e38b548aa884ab387963", "patch": "@@ -10,6 +10,8 @@\n #include \"rust_env.h\"\n #include \"rust_port.h\"\n \n+// TODO(bblum): get rid of supervisors\n+\n // Tasks\n rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n                      rust_task *spawner, const char *name,\n@@ -146,13 +148,9 @@ cleanup_task(cleanup_args *args) {\n \n     task->notify(!threw_exception);\n \n-    if (threw_exception) {\n-#ifndef __WIN32__\n-        task->conclude_failure();\n-#else\n-        assert(false && \"Shouldn't happen\");\n+#ifdef __WIN32__\n+    assert(!threw_exception && \"No exception-handling yet on windows builds\");\n #endif\n-    }\n }\n \n extern \"C\" CDECL void upcall_exchange_free(void *ptr);\n@@ -262,10 +260,7 @@ void\n rust_task::kill() {\n     scoped_lock with(kill_lock);\n \n-    if (dead()) {\n-        // Task is already dead, can't kill what's already dead.\n-        fail_parent();\n-    }\n+    // XXX: bblum: kill/kill race\n \n     // Note the distinction here: kill() is when you're in an upcall\n     // from task A and want to force-fail task B, you do B->kill().\n@@ -314,31 +309,11 @@ rust_task::begin_failure(char const *expr, char const *file, size_t line) {\n     throw this;\n #else\n     die();\n-    conclude_failure();\n     // FIXME (#908): Need unwinding on windows. This will end up aborting\n     sched_loop->fail();\n #endif\n }\n \n-void\n-rust_task::conclude_failure() {\n-    fail_parent();\n-}\n-\n-void\n-rust_task::fail_parent() {\n-    scoped_lock with(supervisor_lock);\n-    if (supervisor) {\n-        DLOG(sched_loop, task,\n-             \"task %s @0x%\" PRIxPTR\n-             \" propagating failure to supervisor %s @0x%\" PRIxPTR,\n-             name, this, supervisor->name, supervisor);\n-        supervisor->kill();\n-    }\n-    if (NULL == supervisor && propagate_failure)\n-        sched_loop->fail();\n-}\n-\n void\n rust_task::unsupervise()\n {"}, {"sha": "3bde520295492886abfb88484de1aa5184f5f04c", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df2d2604ca8277634df6e38b548aa884ab387963/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/df2d2604ca8277634df6e38b548aa884ab387963/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=df2d2604ca8277634df6e38b548aa884ab387963", "patch": "@@ -275,8 +275,6 @@ rust_task : public kernel_owned<rust_task>\n     // Fail self, assuming caller-on-stack is this task.\n     void fail();\n     void fail(char const *expr, char const *file, size_t line);\n-    void conclude_failure();\n-    void fail_parent();\n \n     // Disconnect from our supervisor.\n     void unsupervise();"}]}