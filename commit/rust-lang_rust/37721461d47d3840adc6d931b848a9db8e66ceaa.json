{"sha": "37721461d47d3840adc6d931b848a9db8e66ceaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NzIxNDYxZDQ3ZDM4NDBhZGM2ZDkzMWI4NDhhOWRiOGU2NmNlYWE=", "commit": {"author": {"name": "Artyom Pavlov", "email": "newpavlov@gmail.com", "date": "2019-08-24T22:50:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-24T22:50:20Z"}, "message": "Merge branch 'master' into wasi", "tree": {"sha": "4424a43dce056c6000de36eacc524cceccd822c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4424a43dce056c6000de36eacc524cceccd822c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37721461d47d3840adc6d931b848a9db8e66ceaa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdYb8sCRBK7hj4Ov3rIwAAdHIIAGyd4cKvr/T4daVUCZ9Mtms5\nrQthHnLFElV5az0Z8tN+xOug35bCAPIe0xg/ANbtQqwOihkcYHNLgKmpf0QChmuJ\nxTjvhliIZZ7KLGsiAgT2HghQp/9pA9v8hn9x5zUSaIQDFeLE8Bz0iD0M0SY879+8\nhUOE+LP58vaJceuEqGehH1tA5h0uuYYtp5IovZhzmG+5ecK2NWx4pdziEW4kMRt2\nkn25kh8PMS1ZdFzpm8pPPLKBSlh9kBi1wpTEaMdVRqD7S97C0F31bCE86nH2504m\nZcG47hemSGAtAVymKso2lGds12X8qq+YLhVM/UO7iKbUPSTd4eRTct+ZYxvctlk=\n=Swa/\n-----END PGP SIGNATURE-----\n", "payload": "tree 4424a43dce056c6000de36eacc524cceccd822c9\nparent 926f36400f1667edec92959d8b640dea5084674c\nparent eeba189cfb2cfc5c5898513352d4ca8f1df06e05\nauthor Artyom Pavlov <newpavlov@gmail.com> 1566687020 +0000\ncommitter GitHub <noreply@github.com> 1566687020 +0000\n\nMerge branch 'master' into wasi"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37721461d47d3840adc6d931b848a9db8e66ceaa", "html_url": "https://github.com/rust-lang/rust/commit/37721461d47d3840adc6d931b848a9db8e66ceaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37721461d47d3840adc6d931b848a9db8e66ceaa/comments", "author": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "926f36400f1667edec92959d8b640dea5084674c", "url": "https://api.github.com/repos/rust-lang/rust/commits/926f36400f1667edec92959d8b640dea5084674c", "html_url": "https://github.com/rust-lang/rust/commit/926f36400f1667edec92959d8b640dea5084674c"}, {"sha": "eeba189cfb2cfc5c5898513352d4ca8f1df06e05", "url": "https://api.github.com/repos/rust-lang/rust/commits/eeba189cfb2cfc5c5898513352d4ca8f1df06e05", "html_url": "https://github.com/rust-lang/rust/commit/eeba189cfb2cfc5c5898513352d4ca8f1df06e05"}], "stats": {"total": 9452, "additions": 4535, "deletions": 4917}, "files": [{"sha": "a7de7ce85593c140267bd3bafa3812859d8f259f", "filename": ".gitattributes", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -8,7 +8,7 @@\n src/etc/installer/gfx/* binary\n *.woff binary\n src/vendor/** -text\n-Cargo.lock -merge linguist-generated=false\n+Cargo.lock linguist-generated=false\n \n # Older git versions try to fix line endings on images, this prevents it.\n *.png binary"}, {"sha": "72c76006f7cb99667ccf73e2ef47b16838ea8bc3", "filename": ".mailmap", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -117,6 +117,9 @@ Jason Toffaletti <toffaletti@gmail.com> Jason Toffaletti <jason@topsy.com>\n Jauhien Piatlicki <jauhien@gentoo.org> Jauhien Piatlicki <jpiatlicki@zertisa.com>\n Jay True <glacjay@gmail.com>\n Jeremy Letang <letang.jeremy@gmail.com>\n+Jeremy Stucki <dev@jeremystucki.ch> <stucki.jeremy@gmail.com>\n+Jeremy Stucki <dev@jeremystucki.ch> <jeremy@myelin.ch>\n+Jeremy Stucki <dev@jeremystucki.ch>\n Jethro Beekman <github@jbeekman.nl>\n Jihyun Yu <j.yu@navercorp.com> <yjh0502@gmail.com>\n Jihyun Yu <j.yu@navercorp.com> jihyun <jihyun@nablecomm.com>"}, {"sha": "8ae21c8663706247c9bb9c629b6b0c4d37c5ecfe", "filename": "Cargo.lock", "status": "modified", "additions": 86, "deletions": 41, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -185,7 +185,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"time\",\n- \"toml 0.4.10\",\n+ \"toml\",\n ]\n \n [[package]]\n@@ -202,7 +202,7 @@ name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n  \"serde\",\n- \"toml 0.4.10\",\n+ \"toml\",\n ]\n \n [[package]]\n@@ -265,7 +265,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.39.0\"\n+version = \"0.40.0\"\n dependencies = [\n  \"atty\",\n  \"bytesize\",\n@@ -287,7 +287,7 @@ dependencies = [\n  \"git2-curl\",\n  \"glob\",\n  \"hex\",\n- \"home\",\n+ \"home 0.4.2\",\n  \"ignore\",\n  \"im-rc\",\n  \"jobserver\",\n@@ -309,16 +309,16 @@ dependencies = [\n  \"same-file\",\n  \"semver\",\n  \"serde\",\n- \"serde_ignored\",\n+ \"serde_ignored 0.1.0\",\n  \"serde_json\",\n  \"shell-escape\",\n  \"strip-ansi-escapes\",\n  \"tar\",\n  \"tempfile\",\n  \"termcolor\",\n- \"toml 0.5.1\",\n+ \"toml\",\n  \"unicode-width\",\n- \"url 2.0.0\",\n+ \"url 2.1.0\",\n  \"walkdir\",\n  \"winapi 0.3.6\",\n ]\n@@ -442,9 +442,9 @@ dependencies = [\n  \"semver\",\n  \"serde\",\n  \"smallvec\",\n- \"toml 0.5.1\",\n+ \"toml\",\n  \"unicode-normalization\",\n- \"url 1.7.2\",\n+ \"url 2.1.0\",\n ]\n \n [[package]]\n@@ -574,7 +574,7 @@ checksum = \"e7ca8a5221364ef15ce201e8ed2f609fc312682a8f4e0e3d4aa5879764e0fa3b\"\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.27.0\"\n+version = \"0.28.0\"\n dependencies = [\n  \"curl\",\n  \"failure\",\n@@ -583,7 +583,7 @@ dependencies = [\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n- \"url 2.0.0\",\n+ \"url 2.1.0\",\n ]\n \n [[package]]\n@@ -946,6 +946,7 @@ name = \"error_index_generator\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustdoc\",\n+ \"walkdir\",\n ]\n \n [[package]]\n@@ -1138,10 +1139,12 @@ dependencies = [\n \n [[package]]\n name = \"getopts\"\n-version = \"0.2.19\"\n+version = \"0.2.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72327b15c228bfe31f1390f93dd5e9279587f0463836393c9df719ce62a3e450\"\n+checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n dependencies = [\n+ \"rustc-std-workspace-core\",\n+ \"rustc-std-workspace-std\",\n  \"unicode-width\",\n ]\n \n@@ -1167,7 +1170,7 @@ dependencies = [\n  \"log\",\n  \"openssl-probe\",\n  \"openssl-sys\",\n- \"url 2.0.0\",\n+ \"url 2.1.0\",\n ]\n \n [[package]]\n@@ -1179,7 +1182,7 @@ dependencies = [\n  \"curl\",\n  \"git2\",\n  \"log\",\n- \"url 2.0.0\",\n+ \"url 2.1.0\",\n ]\n \n [[package]]\n@@ -1277,6 +1280,16 @@ dependencies = [\n  \"winapi 0.3.6\",\n ]\n \n+[[package]]\n+name = \"home\"\n+version = \"0.4.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"013e4e6e9134211bb4d6bf53dd8cfb75d9e2715cc33614b9c0827718c6fbe0b8\"\n+dependencies = [\n+ \"scopeguard 1.0.0\",\n+ \"winapi 0.3.6\",\n+]\n+\n [[package]]\n name = \"html5ever\"\n version = \"0.23.0\"\n@@ -1569,9 +1582,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.60\"\n+version = \"0.2.61\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d44e80633f007889c7eff624b709ab43c92d708caad982295768a7b13ca3b5eb\"\n+checksum = \"c665266eb592905e8503ba3403020f4b8794d26263f412ca33171600eca9a6fa\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -1775,7 +1788,7 @@ dependencies = [\n  \"serde_json\",\n  \"shlex\",\n  \"tempfile\",\n- \"toml 0.5.1\",\n+ \"toml\",\n  \"toml-query\",\n ]\n \n@@ -2364,6 +2377,9 @@ dependencies = [\n [[package]]\n name = \"proc_macro\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"std\",\n+]\n \n [[package]]\n name = \"profiler_builtins\"\n@@ -2720,7 +2736,7 @@ dependencies = [\n  \"failure\",\n  \"futures\",\n  \"heck\",\n- \"home\",\n+ \"home 0.3.3\",\n  \"itertools 0.8.0\",\n  \"jsonrpc-core\",\n  \"lazy_static 1.3.0\",\n@@ -2744,13 +2760,13 @@ dependencies = [\n  \"rustfmt-nightly\",\n  \"serde\",\n  \"serde_derive\",\n- \"serde_ignored\",\n+ \"serde_ignored 0.0.4\",\n  \"serde_json\",\n  \"tempfile\",\n  \"tokio\",\n  \"tokio-process\",\n  \"tokio-timer\",\n- \"toml 0.5.1\",\n+ \"toml\",\n  \"url 1.7.2\",\n  \"walkdir\",\n ]\n@@ -3052,6 +3068,13 @@ dependencies = [\n  \"core\",\n ]\n \n+[[package]]\n+name = \"rustc-std-workspace-std\"\n+version = \"1.0.0\"\n+dependencies = [\n+ \"std\",\n+]\n+\n [[package]]\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n@@ -3189,6 +3212,7 @@ dependencies = [\n  \"rustc_interface\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n+ \"rustc_plugin\",\n  \"rustc_plugin_impl\",\n  \"rustc_save_analysis\",\n  \"rustc_target\",\n@@ -3372,6 +3396,13 @@ dependencies = [\n  \"syntax_pos\",\n ]\n \n+[[package]]\n+name = \"rustc_plugin\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_plugin_impl\",\n+]\n+\n [[package]]\n name = \"rustc_plugin_impl\"\n version = \"0.0.0\"\n@@ -3546,7 +3577,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.4\"\n+version = \"1.4.5\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n@@ -3572,7 +3603,7 @@ dependencies = [\n  \"serde_json\",\n  \"structopt\",\n  \"term 0.6.0\",\n- \"toml 0.5.1\",\n+ \"toml\",\n  \"unicode-segmentation\",\n  \"unicode-width\",\n  \"unicode_categories\",\n@@ -3666,9 +3697,9 @@ checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.92\"\n+version = \"1.0.99\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"32746bf0f26eab52f06af0d0aa1984f641341d06d8d673c693871da2d188c9be\"\n+checksum = \"fec2851eb56d010dc9a21b89ca53ee75e6528bab60c11e89d38390904982da9f\"\n dependencies = [\n  \"serde_derive\",\n ]\n@@ -3693,6 +3724,15 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"serde_ignored\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3c24bbb8f4b81834f618cd3e28698235c2fba06ddf7f4fbe30519dd081364e59\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"serde_json\"\n version = \"1.0.40\"\n@@ -4040,6 +4080,10 @@ dependencies = [\n [[package]]\n name = \"term\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"core\",\n+ \"std\",\n+]\n \n [[package]]\n name = \"term\"\n@@ -4086,8 +4130,13 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n+ \"core\",\n  \"getopts\",\n+ \"libc\",\n+ \"panic_abort\",\n+ \"panic_unwind\",\n  \"proc_macro\",\n+ \"std\",\n  \"term 0.0.0\",\n ]\n \n@@ -4357,18 +4406,9 @@ dependencies = [\n \n [[package]]\n name = \"toml\"\n-version = \"0.4.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"758664fc71a3a69038656bee8b6be6477d2a6c315a6b81f7081f591bffa4111f\"\n-dependencies = [\n- \"serde\",\n-]\n-\n-[[package]]\n-name = \"toml\"\n-version = \"0.5.1\"\n+version = \"0.5.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b8c96d7873fa7ef8bdeb3a9cda3ac48389b4154f32b9803b4bc26220b677b039\"\n+checksum = \"c7aabe75941d914b72bf3e5d3932ed92ce0664d49d8432305a8b547c37227724\"\n dependencies = [\n  \"serde\",\n ]\n@@ -4384,7 +4424,7 @@ dependencies = [\n  \"is-match\",\n  \"lazy_static 1.3.0\",\n  \"regex\",\n- \"toml 0.5.1\",\n+ \"toml\",\n  \"toml-query_derive\",\n ]\n \n@@ -4464,9 +4504,14 @@ checksum = \"aa6024fc12ddfd1c6dbc14a80fa2324d4568849869b779f6bd37e5e4c03344d1\"\n \n [[package]]\n name = \"unicode-width\"\n-version = \"0.1.5\"\n+version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"882386231c45df4700b275c7ff55b6f3698780a650026380e72dabe76fa46526\"\n+checksum = \"7007dbd421b92cc6e28410fe7362e2e0a2503394908f417b68ec8d1c364c4e20\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+ \"rustc-std-workspace-std\",\n+]\n \n [[package]]\n name = \"unicode-xid\"\n@@ -4512,9 +4557,9 @@ dependencies = [\n \n [[package]]\n name = \"url\"\n-version = \"2.0.0\"\n+version = \"2.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"77ddaf52e65c6b81c56b7e957c0b1970f7937f21c5c6774c4e56fcb4e20b48c6\"\n+checksum = \"75b414f6c464c879d7f9babf951f23bc3743fb7313c081b2e6ca719067ea9d61\"\n dependencies = [\n  \"idna 0.2.0\",\n  \"matches\","}, {"sha": "a242f090fbc07e889723c334dcb8689b3314be7b", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -68,6 +68,7 @@ rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }\n # here\n rustc-std-workspace-core = { path = 'src/tools/rustc-std-workspace-core' }\n rustc-std-workspace-alloc = { path = 'src/tools/rustc-std-workspace-alloc' }\n+rustc-std-workspace-std = { path = 'src/tools/rustc-std-workspace-std' }\n \n [patch.\"https://github.com/rust-lang/rust-clippy\"]\n clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }"}, {"sha": "c27c318f5ad07201703bd2a424fc5caed3ac80f3", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -44,7 +44,7 @@ cc = \"1.0.35\"\n libc = \"0.2\"\n serde = { version = \"1.0.8\", features = [\"derive\"] }\n serde_json = \"1.0.2\"\n-toml = \"0.4\"\n+toml = \"0.5\"\n lazy_static = \"1.3.0\"\n time = \"0.1\"\n petgraph = \"0.4.13\""}, {"sha": "4f5de1ecd2b44f8aa0cabf0e56249e191f62197d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -337,7 +337,6 @@ impl<'a> Builder<'a> {\n         match kind {\n             Kind::Build => describe!(\n                 compile::Std,\n-                compile::Test,\n                 compile::Rustc,\n                 compile::CodegenBackend,\n                 compile::StartupObjects,\n@@ -363,7 +362,6 @@ impl<'a> Builder<'a> {\n             ),\n             Kind::Check | Kind::Clippy | Kind::Fix => describe!(\n                 check::Std,\n-                check::Test,\n                 check::Rustc,\n                 check::CodegenBackend,\n                 check::Rustdoc\n@@ -425,8 +423,6 @@ impl<'a> Builder<'a> {\n                 doc::TheBook,\n                 doc::Standalone,\n                 doc::Std,\n-                doc::Test,\n-                doc::WhitelistedRustc,\n                 doc::Rustc,\n                 doc::Rustdoc,\n                 doc::ErrorIndex,\n@@ -618,13 +614,7 @@ impl<'a> Builder<'a> {\n             }\n \n             fn run(self, builder: &Builder<'_>) -> Interned<PathBuf> {\n-                let compiler = self.compiler;\n-                let config = &builder.build.config;\n-                let lib = if compiler.stage >= 1 && config.libdir_relative().is_some() {\n-                    builder.build.config.libdir_relative().unwrap()\n-                } else {\n-                    Path::new(\"lib\")\n-                };\n+                let lib = builder.sysroot_libdir_relative(self.compiler);\n                 let sysroot = builder\n                     .sysroot(self.compiler)\n                     .join(lib)\n@@ -678,6 +668,18 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n+    /// Returns the compiler's relative libdir where the standard library and other artifacts are\n+    /// found for a compiler's sysroot.\n+    ///\n+    /// For example this returns `lib` on Unix and Windows.\n+    pub fn sysroot_libdir_relative(&self, compiler: Compiler) -> &Path {\n+        match self.config.libdir_relative() {\n+            Some(relative_libdir) if compiler.stage >= 1\n+                => relative_libdir,\n+            _ => Path::new(\"lib\")\n+        }\n+    }\n+\n     /// Adds the compiler's directory of dynamic libraries to `cmd`'s dynamic\n     /// library lookup path.\n     pub fn add_rustc_lib_path(&self, compiler: Compiler, cmd: &mut Command) {\n@@ -795,7 +797,7 @@ impl<'a> Builder<'a> {\n         }\n \n         match mode {\n-            Mode::Std | Mode::Test | Mode::ToolBootstrap | Mode::ToolStd | Mode::ToolTest=> {},\n+            Mode::Std | Mode::ToolBootstrap | Mode::ToolStd => {},\n             Mode::Rustc | Mode::Codegen | Mode::ToolRustc => {\n                 // Build proc macros both for the host and the target\n                 if target != compiler.host && cmd != \"check\" {\n@@ -846,7 +848,6 @@ impl<'a> Builder<'a> {\n         // things still build right, please do!\n         match mode {\n             Mode::Std => metadata.push_str(\"std\"),\n-            Mode::Test => metadata.push_str(\"test\"),\n             _ => {},\n         }\n         cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &metadata);\n@@ -859,18 +860,17 @@ impl<'a> Builder<'a> {\n             stage = compiler.stage;\n         }\n \n-        let mut extra_args = env::var(&format!(\"RUSTFLAGS_STAGE_{}\", stage)).unwrap_or_default();\n+        let mut extra_args = String::new();\n         if stage != 0 {\n-            let s = env::var(\"RUSTFLAGS_STAGE_NOT_0\").unwrap_or_default();\n-            if !extra_args.is_empty() {\n-                extra_args.push_str(\" \");\n-            }\n+            let s = env::var(\"RUSTFLAGS_NOT_BOOTSTRAP\").unwrap_or_default();\n+            extra_args.push_str(&s);\n+        } else {\n+            let s = env::var(\"RUSTFLAGS_BOOTSTRAP\").unwrap_or_default();\n             extra_args.push_str(&s);\n         }\n \n         if cmd == \"clippy\" {\n-            extra_args.push_str(\"-Zforce-unstable-if-unmarked -Zunstable-options \\\n-                --json-rendered=termcolor\");\n+            extra_args.push_str(\"-Zforce-unstable-if-unmarked\");\n         }\n \n         if !extra_args.is_empty() {\n@@ -943,9 +943,9 @@ impl<'a> Builder<'a> {\n \n         let debuginfo_level = match mode {\n             Mode::Rustc | Mode::Codegen => self.config.rust_debuginfo_level_rustc,\n-            Mode::Std | Mode::Test => self.config.rust_debuginfo_level_std,\n+            Mode::Std => self.config.rust_debuginfo_level_std,\n             Mode::ToolBootstrap | Mode::ToolStd |\n-            Mode::ToolTest | Mode::ToolRustc => self.config.rust_debuginfo_level_tools,\n+            Mode::ToolRustc => self.config.rust_debuginfo_level_tools,\n         };\n         cargo.env(\"RUSTC_DEBUGINFO_LEVEL\", debuginfo_level.to_string());\n \n@@ -1145,7 +1145,6 @@ impl<'a> Builder<'a> {\n \n         match (mode, self.config.rust_codegen_units_std, self.config.rust_codegen_units) {\n             (Mode::Std, Some(n), _) |\n-            (Mode::Test, Some(n), _) |\n             (_, _, Some(n)) => {\n                 cargo.env(\"RUSTC_CODEGEN_UNITS\", n.to_string());\n             }"}, {"sha": "2bb90fdb04edcef41bfe0e2df25743d1f4460307", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 64, "deletions": 89, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -365,27 +365,6 @@ fn dist_with_same_targets_and_hosts() {\n             },\n         ]\n     );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n-        &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-        ]\n-    );\n     assert_eq!(\n         first(builder.cache.all::<compile::Assemble>()),\n         &[\n@@ -415,7 +394,47 @@ fn build_default() {\n     let b = INTERNER.intern_str(\"B\");\n     let c = INTERNER.intern_str(\"C\");\n \n-    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Std>()),\n+        &[\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n     assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n     assert_eq!(\n         first(builder.cache.all::<compile::Rustc>()),\n@@ -450,63 +469,61 @@ fn build_default() {\n             },\n         ]\n     );\n+}\n+\n+#[test]\n+fn build_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true;\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n \n     assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n+        first(builder.cache.all::<compile::Std>()),\n         &[\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 0 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 1 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 1 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: c,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: c,\n             },\n         ]\n     );\n-}\n-\n-#[test]\n-fn build_with_target_flag() {\n-    let mut config = configure(&[\"B\"], &[\"C\"]);\n-    config.skip_only_host_steps = true;\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n-\n-    assert!(!builder.cache.all::<compile::Std>().is_empty());\n     assert_eq!(\n         first(builder.cache.all::<compile::Assemble>()),\n         &[\n@@ -541,48 +558,6 @@ fn build_with_target_flag() {\n             },\n         ]\n     );\n-\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n-        &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: c,\n-            },\n-        ]\n-    );\n }\n \n #[test]"}, {"sha": "e9a9b7881a068f9dd8d1bfa49ced037652a47aa9", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 2, "deletions": 53, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,6 +1,6 @@\n //! Implementation of compiling the compiler and standard library, in \"check\"-based modes.\n \n-use crate::compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, rustc_cargo_env,\n+use crate::compile::{run_cargo, std_cargo, rustc_cargo, rustc_cargo_env,\n                      add_to_sysroot};\n use crate::builder::{RunConfig, Builder, Kind, ShouldRun, Step};\n use crate::tool::{prepare_tool_cargo, SourceType};\n@@ -92,7 +92,7 @@ impl Step for Rustc {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n-        builder.ensure(Test { target });\n+        builder.ensure(Std { target });\n \n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target,\n             cargo_subcommand(builder.kind));\n@@ -159,47 +159,6 @@ impl Step for CodegenBackend {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Test {\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"test\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) {\n-        let compiler = builder.compiler(0, builder.config.build);\n-        let target = self.target;\n-\n-        builder.ensure(Std { target });\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, cargo_subcommand(builder.kind));\n-        test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        builder.info(&format!(\"Checking test artifacts ({} -> {})\", &compiler.host, target));\n-        run_cargo(builder,\n-                  &mut cargo,\n-                  args(builder.kind),\n-                  &libtest_stamp(builder, compiler, target),\n-                  true);\n-\n-        let libdir = builder.sysroot_libdir(compiler, target);\n-        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n-        add_to_sysroot(builder, &libdir, &hostdir, &libtest_stamp(builder, compiler, target));\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustdoc {\n     pub target: Interned<String>,\n@@ -258,16 +217,6 @@ pub fn libstd_stamp(\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n-/// Cargo's output path for libtest in a given stage, compiled by a particular\n-/// compiler for the specified target.\n-pub fn libtest_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest-check.stamp\")\n-}\n-\n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn librustc_stamp("}, {"sha": "7dad146b48d8333534cabbb35ca6f193db982021", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 3, "deletions": 136, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -216,7 +216,7 @@ pub fn std_cargo(builder: &Builder<'_>,\n \n         cargo.arg(\"--features\").arg(features)\n             .arg(\"--manifest-path\")\n-            .arg(builder.src.join(\"src/libstd/Cargo.toml\"));\n+            .arg(builder.src.join(\"src/libtest/Cargo.toml\"));\n \n         if target.contains(\"musl\") {\n             if let Some(p) = builder.musl_root(target) {\n@@ -358,129 +358,6 @@ impl Step for StartupObjects {\n     }\n }\n \n-#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Test {\n-    pub target: Interned<String>,\n-    pub compiler: Compiler,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"test\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Builds libtest.\n-    ///\n-    /// This will build libtest and supporting libraries for a particular stage of\n-    /// the build using the `compiler` targeting the `target` architecture. The\n-    /// artifacts created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder<'_>) {\n-        let target = self.target;\n-        let compiler = self.compiler;\n-\n-        builder.ensure(Std { compiler, target });\n-\n-        if builder.config.keep_stage.contains(&compiler.stage) {\n-            builder.info(\"Warning: Using a potentially old libtest. This may not behave well.\");\n-            builder.ensure(TestLink {\n-                compiler,\n-                target_compiler: compiler,\n-                target,\n-            });\n-            return;\n-        }\n-\n-        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n-        if compiler_to_use != compiler {\n-            builder.ensure(Test {\n-                compiler: compiler_to_use,\n-                target,\n-            });\n-            builder.info(\n-                &format!(\"Uplifting stage1 test ({} -> {})\", builder.config.build, target));\n-            builder.ensure(TestLink {\n-                compiler: compiler_to_use,\n-                target_compiler: compiler,\n-                target,\n-            });\n-            return;\n-        }\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"build\");\n-        test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        builder.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target));\n-        run_cargo(builder,\n-                  &mut cargo,\n-                  vec![],\n-                  &libtest_stamp(builder, compiler, target),\n-                  false);\n-\n-        builder.ensure(TestLink {\n-            compiler: builder.compiler(compiler.stage, builder.config.build),\n-            target_compiler: compiler,\n-            target,\n-        });\n-    }\n-}\n-\n-/// Same as `std_cargo`, but for libtest\n-pub fn test_cargo(builder: &Builder<'_>,\n-                  _compiler: &Compiler,\n-                  _target: Interned<String>,\n-                  cargo: &mut Command) {\n-    if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n-        cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n-    }\n-    cargo.arg(\"--manifest-path\")\n-        .arg(builder.src.join(\"src/libtest/Cargo.toml\"));\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct TestLink {\n-    pub compiler: Compiler,\n-    pub target_compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for TestLink {\n-    type Output = ();\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.never()\n-    }\n-\n-    /// Same as `std_link`, only for libtest\n-    fn run(self, builder: &Builder<'_>) {\n-        let compiler = self.compiler;\n-        let target_compiler = self.target_compiler;\n-        let target = self.target;\n-        builder.info(&format!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n-                target_compiler.stage,\n-                compiler.stage,\n-                &compiler.host,\n-                target_compiler.host,\n-                target));\n-        add_to_sysroot(\n-            builder,\n-            &builder.sysroot_libdir(target_compiler, target),\n-            &builder.sysroot_libdir(target_compiler, compiler.host),\n-            &libtest_stamp(builder, compiler, target)\n-        );\n-    }\n-}\n-\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n     pub target: Interned<String>,\n@@ -512,7 +389,7 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.ensure(Test { compiler, target });\n+        builder.ensure(Std { compiler, target });\n \n         if builder.config.keep_stage.contains(&compiler.stage) {\n             builder.info(\"Warning: Using a potentially old librustc. This may not behave well.\");\n@@ -541,7 +418,7 @@ impl Step for Rustc {\n         }\n \n         // Ensure that build scripts and proc macros have a std / libproc_macro to link against.\n-        builder.ensure(Test {\n+        builder.ensure(Std {\n             compiler: builder.compiler(self.compiler.stage, builder.config.build),\n             target: builder.config.build,\n         });\n@@ -872,16 +749,6 @@ pub fn libstd_stamp(\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd.stamp\")\n }\n \n-/// Cargo's output path for libtest in a given stage, compiled by a particular\n-/// compiler for the specified target.\n-pub fn libtest_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest.stamp\")\n-}\n-\n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn librustc_stamp("}, {"sha": "0f4ac63651ca9ff02b76312fc3fadb2d976775c8", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -469,7 +469,6 @@ impl Step for Rustc {\n         fn prepare_image(builder: &Builder<'_>, compiler: Compiler, image: &Path) {\n             let host = compiler.host;\n             let src = builder.sysroot(compiler);\n-            let libdir = builder.rustc_libdir(compiler);\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n@@ -481,20 +480,26 @@ impl Step for Rustc {\n \n             // Copy runtime DLLs needed by the compiler\n             if libdir_relative.to_str() != Some(\"bin\") {\n+                let libdir = builder.rustc_libdir(compiler);\n                 for entry in builder.read_dir(&libdir) {\n                     let name = entry.file_name();\n                     if let Some(s) = name.to_str() {\n                         if is_dylib(s) {\n-                            builder.install(&entry.path(), &image.join(&libdir_relative), 0o644);\n+                            // Don't use custom libdir here because ^lib/ will be resolved again\n+                            // with installer\n+                            builder.install(&entry.path(), &image.join(\"lib\"), 0o644);\n                         }\n                     }\n                 }\n             }\n \n             // Copy over the codegen backends\n             let backends_src = builder.sysroot_codegen_backends(compiler);\n-            let backends_rel = backends_src.strip_prefix(&src).unwrap();\n-            let backends_dst = image.join(&backends_rel);\n+            let backends_rel = backends_src.strip_prefix(&src).unwrap()\n+                .strip_prefix(builder.sysroot_libdir_relative(compiler)).unwrap();\n+            // Don't use custom libdir here because ^lib/ will be resolved again with installer\n+            let backends_dst = image.join(\"lib\").join(&backends_rel);\n+\n             t!(fs::create_dir_all(&backends_dst));\n             builder.cp_r(&backends_src, &backends_dst);\n \n@@ -673,12 +678,7 @@ impl Step for Std {\n         if builder.hosts.iter().any(|t| t == target) {\n             builder.ensure(compile::Rustc { compiler, target });\n         } else {\n-            if builder.no_std(target) == Some(true) {\n-                // the `test` doesn't compile for no-std targets\n-                builder.ensure(compile::Std { compiler, target });\n-            } else {\n-                builder.ensure(compile::Test { compiler, target });\n-            }\n+            builder.ensure(compile::Std { compiler, target });\n         }\n \n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n@@ -907,6 +907,7 @@ impl Step for Src {\n             \"src/libproc_macro\",\n             \"src/tools/rustc-std-workspace-core\",\n             \"src/tools/rustc-std-workspace-alloc\",\n+            \"src/tools/rustc-std-workspace-std\",\n             \"src/librustc\",\n             \"src/libsyntax\",\n         ];"}, {"sha": "6805474aa049f8aa16e3d7c3fe899e77f7cb2acc", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 2, "deletions": 129, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -478,138 +478,12 @@ impl Step for Std {\n             builder.run(&mut cargo);\n             builder.cp_r(&my_out, &out);\n         };\n-        for krate in &[\"alloc\", \"core\", \"std\"] {\n+        for krate in &[\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"] {\n             run_cargo_rustdoc_for(krate);\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Test {\n-    stage: u32,\n-    target: Interned<String>,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        run.krate(\"test\").default_condition(builder.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            stage: run.builder.top_stage,\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Compile all libtest documentation.\n-    ///\n-    /// This will generate all documentation for libtest and its dependencies. This\n-    /// is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n-        let target = self.target;\n-        builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n-        let out = builder.doc_out(target);\n-        t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n-\n-        // Build libstd docs so that we generate relative links\n-        builder.ensure(Std { stage, target });\n-\n-        builder.ensure(compile::Test { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Test)\n-                           .join(target).join(\"doc\");\n-\n-        // See docs in std above for why we symlink\n-        let my_out = builder.crate_doc_out(target);\n-        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"doc\");\n-        compile::test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        cargo.arg(\"--no-deps\")\n-             .arg(\"-p\").arg(\"test\")\n-             .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n-             .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n-\n-        builder.run(&mut cargo);\n-        builder.cp_r(&my_out, &out);\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct WhitelistedRustc {\n-    stage: u32,\n-    target: Interned<String>,\n-}\n-\n-impl Step for WhitelistedRustc {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        run.krate(\"rustc-main\").default_condition(builder.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(WhitelistedRustc {\n-            stage: run.builder.top_stage,\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Generates whitelisted compiler crate documentation.\n-    ///\n-    /// This will generate all documentation for crates that are whitelisted\n-    /// to be included in the standard documentation. This documentation is\n-    /// included in the standard Rust documentation, so we should always\n-    /// document it and symlink to merge with the rest of the std and test\n-    /// documentation. We don't build other compiler documentation\n-    /// here as we want to be able to keep it separate from the standard\n-    /// documentation. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n-        let target = self.target;\n-        builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n-        let out = builder.doc_out(target);\n-        t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n-\n-        // Build libstd docs so that we generate relative links\n-        builder.ensure(Std { stage, target });\n-\n-        builder.ensure(compile::Rustc { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Rustc)\n-                           .join(target).join(\"doc\");\n-\n-        // See docs in std above for why we symlink\n-        let my_out = builder.crate_doc_out(target);\n-        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        compile::rustc_cargo(builder, &mut cargo);\n-\n-        // We don't want to build docs for internal compiler dependencies in this\n-        // step (there is another step for that). Therefore, we whitelist the crates\n-        // for which docs must be built.\n-        for krate in &[\"proc_macro\"] {\n-            cargo.arg(\"-p\").arg(krate)\n-                 .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n-                 .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n-        }\n-\n-        builder.run(&mut cargo);\n-        builder.cp_r(&my_out, &out);\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustc {\n     stage: u32,\n@@ -825,8 +699,7 @@ impl Step for ErrorIndex {\n         index.arg(crate::channel::CFG_RELEASE_NUM);\n \n         // FIXME: shouldn't have to pass this env var\n-        index.env(\"CFG_BUILD\", &builder.config.build)\n-             .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n+        index.env(\"CFG_BUILD\", &builder.config.build);\n \n         builder.run(&mut index);\n     }"}, {"sha": "c0e0ad1a857b954ab1a69c8736cb0a84928dca11", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -297,9 +297,6 @@ pub enum Mode {\n     /// Build the standard library, placing output in the \"stageN-std\" directory.\n     Std,\n \n-    /// Build libtest, placing output in the \"stageN-test\" directory.\n-    Test,\n-\n     /// Build librustc, and compiler libraries, placing output in the \"stageN-rustc\" directory.\n     Rustc,\n \n@@ -315,7 +312,6 @@ pub enum Mode {\n     /// Compile a tool which uses all libraries we compile (up to rustc).\n     /// Doesn't use the stage0 compiler libraries like \"other\", and includes\n     /// tools like rustdoc, cargo, rls, etc.\n-    ToolTest,\n     ToolStd,\n     ToolRustc,\n }\n@@ -536,11 +532,10 @@ impl Build {\n     fn stage_out(&self, compiler: Compiler, mode: Mode) -> PathBuf {\n         let suffix = match mode {\n             Mode::Std => \"-std\",\n-            Mode::Test => \"-test\",\n             Mode::Rustc => \"-rustc\",\n             Mode::Codegen => \"-codegen\",\n             Mode::ToolBootstrap => \"-bootstrap-tools\",\n-            Mode::ToolStd | Mode::ToolTest | Mode::ToolRustc => \"-tools\",\n+            Mode::ToolStd | Mode::ToolRustc => \"-tools\",\n         };\n         self.out.join(&*compiler.host)\n                 .join(format!(\"stage{}{}\", compiler.stage, suffix))"}, {"sha": "2bb053cc2b002e7a914480c856a2baf5d3c7b1f7", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1040,21 +1040,10 @@ impl Step for Compiletest {\n             builder.ensure(compile::Rustc { compiler, target });\n         }\n \n-        if builder.no_std(target) == Some(true) {\n-            // the `test` doesn't compile for no-std targets\n-            builder.ensure(compile::Std { compiler, target });\n-        } else {\n-            builder.ensure(compile::Test { compiler, target });\n-        }\n-\n-        if builder.no_std(target) == Some(true) {\n-            // for no_std run-make (e.g., thumb*),\n-            // we need a host compiler which is called by cargo.\n-            builder.ensure(compile::Std { compiler, target: compiler.host });\n-        }\n+        builder.ensure(compile::Std { compiler, target });\n+        // ensure that `libproc_macro` is available on the host.\n+        builder.ensure(compile::Std { compiler, target: compiler.host });\n \n-        // HACK(eddyb) ensure that `libproc_macro` is available on the host.\n-        builder.ensure(compile::Test { compiler, target: compiler.host });\n         // Also provide `rust_test_helpers` for the host.\n         builder.ensure(native::TestHelpers { target: compiler.host });\n \n@@ -1399,7 +1388,7 @@ impl Step for DocTest {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Test {\n+        builder.ensure(compile::Std {\n             compiler,\n             target: compiler.host,\n         });\n@@ -1535,8 +1524,7 @@ impl Step for ErrorIndex {\n         );\n         tool.arg(\"markdown\")\n             .arg(&output)\n-            .env(\"CFG_BUILD\", &builder.config.build)\n-            .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n+            .env(\"CFG_BUILD\", &builder.config.build);\n \n         builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n         let _time = util::timeit(&builder);\n@@ -1710,8 +1698,7 @@ impl Step for Crate {\n \n     fn should_run(mut run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run = run.krate(\"test\");\n-        for krate in run.builder.in_tree_crates(\"std\") {\n+        for krate in run.builder.in_tree_crates(\"test\") {\n             if !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) {\n                 run = run.path(krate.local_path(&builder).to_str().unwrap());\n             }\n@@ -1735,14 +1722,9 @@ impl Step for Crate {\n             });\n         };\n \n-        for krate in builder.in_tree_crates(\"std\") {\n-            if run.path.ends_with(&krate.local_path(&builder)) {\n-                make(Mode::Std, krate);\n-            }\n-        }\n         for krate in builder.in_tree_crates(\"test\") {\n             if run.path.ends_with(&krate.local_path(&builder)) {\n-                make(Mode::Test, krate);\n+                make(Mode::Std, krate);\n             }\n         }\n     }\n@@ -1762,7 +1744,7 @@ impl Step for Crate {\n         let test_kind = self.test_kind;\n         let krate = self.krate;\n \n-        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(compile::Std { compiler, target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n         // If we're not doing a full bootstrap but we're testing a stage2\n@@ -1776,9 +1758,6 @@ impl Step for Crate {\n             Mode::Std => {\n                 compile::std_cargo(builder, &compiler, target, &mut cargo);\n             }\n-            Mode::Test => {\n-                compile::test_cargo(builder, &compiler, target, &mut cargo);\n-            }\n             Mode::Rustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n                 compile::rustc_cargo(builder, &mut cargo);\n@@ -1980,7 +1959,7 @@ impl Step for RemoteCopyLibs {\n             return;\n         }\n \n-        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(compile::Std { compiler, target });\n \n         builder.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n         t!(fs::create_dir_all(builder.out.join(\"tmp\")));"}, {"sha": "54fe26f18e741d0a7558ada111628bb68cc84ee3", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -577,12 +577,6 @@ impl Step for Cargo {\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        // Cargo depends on procedural macros, so make sure the host\n-        // libstd/libproc_macro is available.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n@@ -650,31 +644,10 @@ macro_rules! tool_extended {\n \n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n-    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {\n-        // Clippy depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n-    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n-        // Clippy depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n+    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {};\n+    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {};\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n-    CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {\n-        // Miri depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n+    CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {};\n     Rls, rls, \"src/tools/rls\", \"rls\", {\n         let clippy = builder.ensure(Clippy {\n             compiler: self.compiler,\n@@ -684,12 +657,6 @@ tool_extended!((self, builder),\n         if clippy.is_some() {\n             self.extra_features.push(\"clippy\".to_owned());\n         }\n-        // RLS depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n     };\n     Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n );"}, {"sha": "131d2034675e3db0f0897258dd90493c9c87ba38", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -262,7 +262,7 @@ pub fn native_lib_boilerplate(\n     if !up_to_date(Path::new(\"build.rs\"), &timestamp) || !up_to_date(src_dir, &timestamp) {\n         Ok(NativeLibBoilerplate {\n             src_dir: src_dir.to_path_buf(),\n-            out_dir: out_dir,\n+            out_dir,\n         })\n     } else {\n         Err(())"}, {"sha": "105791194628b3130866d55f5293fb1b6431756d", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -104,9 +104,7 @@ ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n-# FIXME: temporarily disable the redox builder,\n-# see: https://github.com/rust-lang/rust/issues/63160\n-# ENV TARGETS=$TARGETS,x86_64-unknown-redox\n+ENV TARGETS=$TARGETS,x86_64-unknown-redox\n ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n@@ -132,7 +130,7 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc \\\n     AR_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-ar \\\n     CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++\n-    \n+\n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-armv5te=/musl-armv5te \\\n       --musl-root-arm=/musl-arm \\"}, {"sha": "de8c359d16757a223b84fce8afce6ae2331bd61d", "filename": "src/ci/docker/dist-various-1/install-mipsel-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mipsel-linux-musl\n # Note that this originally came from:\n # https://downloads.openwrt.org/snapshots/trunk/malta/generic/\n # OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\n-URL=\"https://rust-lang-ci2.s3.amazonaws.com/libc\"\n+URL=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\"\n FILE=\"OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mipsel-linux-musl --strip-components=2\n "}, {"sha": "432ca26686c11d396eed6a59499f93ce1bf2433c", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1 +1 @@\n-Subproject commit c5da1e11915d3f28266168baaf55822f7e3fe999\n+Subproject commit 432ca26686c11d396eed6a59499f93ce1bf2433c"}, {"sha": "38b9a76bc8b59ac862663807fc51c9b757337fd6", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1 +1 @@\n-Subproject commit 8a7d05615e5bc0a7fb961b4919c44f5221ee54da\n+Subproject commit 38b9a76bc8b59ac862663807fc51c9b757337fd6"}, {"sha": "d191a0cdd3b92648e0f1e53b13140a14677cc65b", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1 +1 @@\n-Subproject commit b4b3536839042a6743fc76f0d9ad2a812020aeaa\n+Subproject commit d191a0cdd3b92648e0f1e53b13140a14677cc65b"}, {"sha": "580839d90aacd537f0293697096fa8355bc4e673", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1 +1 @@\n-Subproject commit f2c15ba5ee89ae9469a2cf60494977749901d764\n+Subproject commit 580839d90aacd537f0293697096fa8355bc4e673"}, {"sha": "6e25a3d0d3573eb42b2e2339f1219e969d1b3dee", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1 +1 @@\n-Subproject commit 6f4ba673ff9d4613e98415bc095347a6a0031e9c\n+Subproject commit 6e25a3d0d3573eb42b2e2339f1219e969d1b3dee"}, {"sha": "5eea9c86879001ef9a13ee6f3c8ecbc487697ccc", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -304,3 +304,10 @@ to customize the output:\n \n Note that it is invalid to combine the `--json` argument with the `--color`\n argument, and it is required to combine `--json` with `--error-format=json`.\n+\n+## `@path`: load command-line flags from a path\n+\n+If you specify `@path` on the command-line, then it will open `path` and read\n+command line options from it. These options are one per line; a blank line indicates\n+an empty option. The file can use Unix or Windows style line endings, and must be\n+encoded as UTF-8."}, {"sha": "d3dfc3197e2f69749bc3e6537f4d55fb97376016", "filename": "src/doc/rustc/src/lints/listing/allowed-by-default.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -208,7 +208,7 @@ error: missing documentation for a function\n \n To fix the lint, add documentation to all items.\n \n-## single-use-lifetime\n+## single-use-lifetimes\n \n This lint detects lifetimes that are only used once. Some example code that\n triggers this lint:"}, {"sha": "a4a0fbb194dd448083c320643d2c8a2ef505a60b", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1810,7 +1810,7 @@ impl<T> VecDeque<T> {\n         other\n     }\n \n-    /// Moves all the elements of `other` into `Self`, leaving `other` empty.\n+    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n     ///\n     /// # Panics\n     ///\n@@ -1847,7 +1847,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// let mut buf = VecDeque::new();\n     /// buf.extend(1..5);\n-    /// buf.retain(|&x| x%2 == 0);\n+    /// buf.retain(|&x| x % 2 == 0);\n     /// assert_eq!(buf, [2, 4]);\n     /// ```\n     ///"}, {"sha": "167a9dd1c3620cba039ea33ac1c1b3b996b2d596", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1012,9 +1012,11 @@ mod impls {\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n-                    if *self == *other { Equal }\n-                    else if *self < *other { Less }\n-                    else { Greater }\n+                    // The order here is important to generate more optimal assembly.\n+                    // See <https://github.com/rust-lang/rust/issues/63758> for more info.\n+                    if *self < *other { Less }\n+                    else if *self > *other { Greater }\n+                    else { Equal }\n                 }\n             }\n         )*)"}, {"sha": "c9612596b1ba0e8c523ecba69b1cbf7271f6a784", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -173,17 +173,23 @@ impl<A, B> Iterator for Chain<A, B> where\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (a_lower, a_upper) = self.a.size_hint();\n-        let (b_lower, b_upper) = self.b.size_hint();\n+        match self.state {\n+            ChainState::Both => {\n+                let (a_lower, a_upper) = self.a.size_hint();\n+                let (b_lower, b_upper) = self.b.size_hint();\n \n-        let lower = a_lower.saturating_add(b_lower);\n+                let lower = a_lower.saturating_add(b_lower);\n \n-        let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => x.checked_add(y),\n-            _ => None\n-        };\n+                let upper = match (a_upper, b_upper) {\n+                    (Some(x), Some(y)) => x.checked_add(y),\n+                    _ => None\n+                };\n \n-        (lower, upper)\n+                (lower, upper)\n+            }\n+            ChainState::Front => self.a.size_hint(),\n+            ChainState::Back => self.b.size_hint(),\n+        }\n     }\n }\n "}, {"sha": "f50781890ab225eabc5ea646bbc68e440792fb64", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1309,7 +1309,7 @@ impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n         match self.peeked.take() {\n-            Some(None) => return Try::from_ok(init),\n+            Some(None) => Try::from_ok(init),\n             Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n                 Ok(acc) => f(acc, v),\n                 Err(e) => {\n@@ -1326,7 +1326,7 @@ impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         match self.peeked {\n-            Some(None) => return init,\n+            Some(None) => init,\n             Some(Some(v)) => {\n                 let acc = self.iter.rfold(init, &mut fold);\n                 fold(acc, v)"}, {"sha": "ffaca029a8a78be3d31c72e8e349bec3eb81eaa3", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -734,7 +734,6 @@ pub(crate) mod builtin {\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[rustc_macro_transparency = \"opaque\"]\n     macro_rules! format_args {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -747,7 +746,6 @@ pub(crate) mod builtin {\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[rustc_macro_transparency = \"opaque\"]\n     macro_rules! format_args_nl {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -1235,42 +1233,36 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a function to turn it into a benchmark test.\n     #[unstable(feature = \"test\", issue = \"50297\",\n                reason = \"`bench` is a part of custom test frameworks which are unstable\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro bench($item:item) { /* compiler built-in */ }\n \n     /// An implementation detail of the `#[test]` and `#[bench]` macros.\n     #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n                reason = \"custom test frameworks are an unstable feature\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test_case($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a static to register it as a global allocator.\n     #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n     #[allow_internal_unstable(rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro global_allocator($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n     pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro RustcEncodable($item:item) { /* compiler built-in */ }"}, {"sha": "22e7573eca65b28c5693df365dc17af90fa5ed32", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -315,7 +315,7 @@ impl f32 {\n     /// use std::f32;\n     ///\n     /// let x = 2.0_f32;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```"}, {"sha": "bbe1d040780602df44831bab76ff835a01da7898", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -327,7 +327,7 @@ impl f64 {\n     ///\n     /// ```\n     /// let x = 2.0_f64;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```"}, {"sha": "931768564ca3cf8c5a34fca6a14e376567c4f1eb", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3026,8 +3026,7 @@ macro_rules! len {\n         if size == 0 {\n             // This _cannot_ use `unchecked_sub` because we depend on wrapping\n             // to represent the length of long ZST slice iterators.\n-            let diff = ($self.end as usize).wrapping_sub(start as usize);\n-            diff\n+            ($self.end as usize).wrapping_sub(start as usize)\n         } else {\n             // We know that `start <= end`, so can do better than `offset_from`,\n             // which needs to deal in signed.  By setting appropriate flags here\n@@ -4637,6 +4636,22 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n             Some(tail)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * self.chunk_size;\n+            let end = start + self.chunk_size;\n+            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (head, nth_back) = temp.split_at_mut(start);\n+            self.v = head;\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]"}, {"sha": "3a4f76852a0d7c384daeae71a76593942df01af4", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -152,6 +152,54 @@ fn test_iterator_chain_find() {\n     assert_eq!(iter.next(), None);\n }\n \n+#[test]\n+fn test_iterator_chain_size_hint() {\n+    struct Iter {\n+        is_empty: bool,\n+    }\n+\n+    impl Iterator for Iter {\n+        type Item = ();\n+\n+        // alternates between `None` and `Some(())`\n+        fn next(&mut self) -> Option<Self::Item> {\n+            if self.is_empty {\n+                self.is_empty = false;\n+                None\n+            } else {\n+                self.is_empty = true;\n+                Some(())\n+            }\n+        }\n+\n+        fn size_hint(&self) -> (usize, Option<usize>) {\n+            if self.is_empty {\n+                (0, Some(0))\n+            } else {\n+                (1, Some(1))\n+            }\n+        }\n+    }\n+\n+    impl DoubleEndedIterator for Iter {\n+        fn next_back(&mut self) -> Option<Self::Item> {\n+            self.next()\n+        }\n+    }\n+\n+    // this chains an iterator of length 0 with an iterator of length 1,\n+    // so after calling `.next()` once, the iterator is empty and the\n+    // state is `ChainState::Back`. `.size_hint()` should now disregard\n+    // the size hint of the left iterator\n+    let mut iter = Iter { is_empty: true }.chain(once(()));\n+    assert_eq!(iter.next(), Some(()));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+\n+    let mut iter = once(()).chain(Iter { is_empty: true });\n+    assert_eq!(iter.next_back(), Some(()));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+}\n+\n #[test]\n fn test_zip_nth() {\n     let xs = [0, 1, 2, 4, 5];"}, {"sha": "6609bc3135ae0bfbc64ef0e8684a00b1590b4992", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -374,6 +374,25 @@ fn test_chunks_exact_mut_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_chunks_exact_mut_nth_back() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.chunks_exact_mut(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next(), None);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c2 = v2.chunks_exact_mut(3);\n+    assert_eq!(c2.nth_back(0).unwrap(), &[0, 1, 2]);\n+    assert_eq!(c2.next(), None);\n+    assert_eq!(c2.next_back(), None);\n+\n+    let v3: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c3 = v3.chunks_exact_mut(10);\n+    assert_eq!(c3.nth_back(0), None);\n+}\n+\n #[test]\n fn test_chunks_exact_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];"}, {"sha": "187bdac80019d51e914a6c70ec31e914c567d231", "filename": "src/libproc_macro/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -6,3 +6,6 @@ edition = \"2018\"\n \n [lib]\n path = \"lib.rs\"\n+\n+[dependencies]\n+std = { path = \"../libstd\" }"}, {"sha": "a200a058f4f99bbd7a7e30e06a81c82fba8a4593", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2088,7 +2088,6 @@ generator can be constructed.\n Erroneous code example:\n \n ```edition2018,compile-fail,E0698\n-#![feature(async_await)]\n async fn bar<T>() -> () {}\n \n async fn foo() {\n@@ -2101,7 +2100,6 @@ To fix this you must bind `T` to a concrete type such as `String`\n so that a generator can then be constructed:\n \n ```edition2018\n-#![feature(async_await)]\n async fn bar<T>() -> () {}\n \n async fn foo() {"}, {"sha": "f80e527dfd9b70b131778f9f889d690984f690b6", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -514,8 +514,7 @@ impl<'hir> Map<'hir> {\n         &self.forest.krate.attrs\n     }\n \n-    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId)\n-    {\n+    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId) {\n         let hir_id = self.as_local_hir_id(module).unwrap();\n         self.read(hir_id);\n         match self.find_entry(hir_id).unwrap().node {\n@@ -525,7 +524,7 @@ impl<'hir> Map<'hir> {\n                 ..\n             }) => (m, span, hir_id),\n             Node::Crate => (&self.forest.krate.module, self.forest.krate.span, hir_id),\n-            _ => panic!(\"not a module\")\n+            node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n \n@@ -679,6 +678,16 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Wether `hir_id` corresponds to a `mod` or a crate.\n+    pub fn is_hir_id_module(&self, hir_id: HirId) -> bool {\n+        match self.lookup(hir_id) {\n+            Some(Entry { node: Node::Item(Item { node: ItemKind::Mod(_), .. }), .. }) |\n+            Some(Entry { node: Node::Crate, .. }) => true,\n+            _ => false,\n+        }\n+    }\n+\n+\n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n     /// last good `HirId` we found. Note that reaching the crate root (`id == 0`),"}, {"sha": "05e2c7854b49ce7917ffa383ae57d363fd0f8451", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -402,7 +402,6 @@ impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n     parent -> _,\n     call_site,\n     def_site,\n-    default_transparency,\n     allow_internal_unstable,\n     allow_internal_unsafe,\n     local_inner_macros,"}, {"sha": "9be73cf3c6d1645439e9e3af528318a097acdf5f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1650,7 +1650,7 @@ impl<'tcx> ObligationCause<'tcx> {\n                 hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\",\n                 _ => \"match arms have compatible types\",\n             },\n-            IfExpression { .. } => \"if and else have compatible types\",\n+            IfExpression { .. } => \"if and else have incompatible types\",\n             IfExpressionWithNoElse => \"if missing an else returns ()\",\n             MainFunctionType => \"`main` function has the correct type\",\n             StartFunctionType => \"`start` function has the correct type\","}, {"sha": "c70006b68d69aff5f3230a50abde2935206e7c3d", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -247,20 +247,32 @@ impl<'tcx> ty::TyS<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_type_err(self,\n-                                     db: &mut DiagnosticBuilder<'_>,\n-                                     err: &TypeError<'tcx>,\n-                                     sp: Span) {\n+    pub fn note_and_explain_type_err(\n+        self,\n+        db: &mut DiagnosticBuilder<'_>,\n+        err: &TypeError<'tcx>,\n+        sp: Span,\n+    ) {\n         use self::TypeError::*;\n \n-        match err.clone() {\n+        match err {\n             Sorts(values) => {\n                 let expected_str = values.expected.sort_string(self);\n                 let found_str = values.found.sort_string(self);\n                 if expected_str == found_str && expected_str == \"closure\" {\n                     db.note(\"no two closures, even if identical, have the same type\");\n                     db.help(\"consider boxing your closure and/or using it as a trait object\");\n                 }\n+                if expected_str == found_str && expected_str == \"opaque type\" { // Issue #63167\n+                    db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                    let e_str = values.expected.to_string();\n+                    let f_str = values.found.to_string();\n+                    if &e_str == &f_str && &e_str == \"impl std::future::Future\" {\n+                        // FIXME: use non-string based check.\n+                        db.help(\"if both `Future`s have the same `Output` type, consider \\\n+                                 `.await`ing on both of them\");\n+                    }\n+                }\n                 if let (ty::Infer(ty::IntVar(_)), ty::Float(_)) =\n                        (&values.found.sty, &values.expected.sty) // Issue #53280\n                 {"}, {"sha": "c21639d0dcaee0898e65e284684787ed1a6dc71d", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -23,7 +23,7 @@ use std::mem;\n use syntax::ast::NodeId;\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n-use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnData};\n+use syntax_pos::hygiene::{ExpnId, SyntaxContext};\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n@@ -593,8 +593,8 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n         // don't seem to be used after HIR lowering, so everything should be fine\n         // as long as incremental compilation does not kick in before that.\n         let location = || Span::with_root_ctxt(lo, hi);\n-        let recover_from_expn_data = |this: &Self, expn_data, pos| {\n-            let span = location().fresh_expansion(expn_data);\n+        let recover_from_expn_data = |this: &Self, expn_data, transparency, pos| {\n+            let span = location().fresh_expansion_with_transparency(expn_data, transparency);\n             this.synthetic_syntax_contexts.borrow_mut().insert(pos, span.ctxt());\n             span\n         };\n@@ -603,9 +603,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n                 location()\n             }\n             TAG_EXPN_DATA_INLINE => {\n-                let expn_data = Decodable::decode(self)?;\n+                let (expn_data, transparency) = Decodable::decode(self)?;\n                 recover_from_expn_data(\n-                    self, expn_data, AbsoluteBytePos::new(self.opaque.position())\n+                    self, expn_data, transparency, AbsoluteBytePos::new(self.opaque.position())\n                 )\n             }\n             TAG_EXPN_DATA_SHORTHAND => {\n@@ -614,9 +614,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n                 if let Some(ctxt) = cached_ctxt {\n                     Span::new(lo, hi, ctxt)\n                 } else {\n-                    let expn_data =\n-                        self.with_position(pos.to_usize(), |this| ExpnData::decode(this))?;\n-                    recover_from_expn_data(self, expn_data, pos)\n+                    let (expn_data, transparency) =\n+                        self.with_position(pos.to_usize(), |this| Decodable::decode(this))?;\n+                    recover_from_expn_data(self, expn_data, transparency, pos)\n                 }\n             }\n             _ => {\n@@ -819,15 +819,15 @@ where\n         if span_data.ctxt == SyntaxContext::root() {\n             TAG_NO_EXPN_DATA.encode(self)\n         } else {\n-            let (expn_id, expn_data) = span_data.ctxt.outer_expn_with_data();\n+            let (expn_id, transparency, expn_data) = span_data.ctxt.outer_mark_with_data();\n             if let Some(pos) = self.expn_data_shorthands.get(&expn_id).cloned() {\n                 TAG_EXPN_DATA_SHORTHAND.encode(self)?;\n                 pos.encode(self)\n             } else {\n                 TAG_EXPN_DATA_INLINE.encode(self)?;\n                 let pos = AbsoluteBytePos::new(self.position());\n                 self.expn_data_shorthands.insert(expn_id, pos);\n-                expn_data.encode(self)\n+                (expn_data, transparency).encode(self)\n             }\n         }\n     }"}, {"sha": "565447dd7e1afd7fc0fc63aff0b9e401383b70b3", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -8,7 +8,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::{ConstValue, Scalar, GlobalId};\n+use crate::mir::interpret::{ConstValue, Scalar};\n use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n@@ -551,26 +551,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     let tcx = relation.tcx();\n \n     let eagerly_eval = |x: &'tcx ty::Const<'tcx>| {\n-        if let ConstValue::Unevaluated(def_id, substs) = x.val {\n-            // FIXME(eddyb) get the right param_env.\n-            let param_env = ty::ParamEnv::empty();\n-            if !substs.has_local_value() {\n-                let instance = ty::Instance::resolve(\n-                    tcx.global_tcx(),\n-                    param_env,\n-                    def_id,\n-                    substs,\n-                );\n-                if let Some(instance) = instance {\n-                    let cid = GlobalId {\n-                        instance,\n-                        promoted: None,\n-                    };\n-                    if let Ok(ct) = tcx.const_eval(param_env.and(cid)) {\n-                        return ct.val;\n-                    }\n-                }\n-            }\n+        if !x.val.has_local_value() {\n+            return x.eval(tcx, relation.param_env()).val;\n         }\n         x.val\n     };"}, {"sha": "da66fdf5b1b1b724f9aba3042eeb37d224648b00", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2299,23 +2299,33 @@ impl<'tcx> Const<'tcx> {\n         assert_eq!(self.ty, ty);\n         // if `ty` does not depend on generic parameters, use an empty param_env\n         let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n+        self.eval(tcx, param_env).val.try_to_bits(size)\n+    }\n+\n+    #[inline]\n+    pub fn eval(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> &Const<'tcx> {\n+        // FIXME(const_generics): this doesn't work right now,\n+        // because it tries to relate an `Infer` to a `Param`.\n         match self.val {\n-            // FIXME(const_generics): this doesn't work right now,\n-            // because it tries to relate an `Infer` to a `Param`.\n             ConstValue::Unevaluated(did, substs) => {\n                 // if `substs` has no unresolved components, use and empty param_env\n                 let (param_env, substs) = param_env.with_reveal_all().and(substs).into_parts();\n                 // try to resolve e.g. associated constants to their definition on an impl\n-                let instance = ty::Instance::resolve(tcx, param_env, did, substs)?;\n+                let instance = match ty::Instance::resolve(tcx, param_env, did, substs) {\n+                    Some(instance) => instance,\n+                    None => return self,\n+                };\n                 let gid = GlobalId {\n                     instance,\n                     promoted: None,\n                 };\n-                let evaluated = tcx.const_eval(param_env.and(gid)).ok()?;\n-                evaluated.val.try_to_bits(size)\n+                tcx.const_eval(param_env.and(gid)).unwrap_or(self)\n             },\n-            // otherwise just extract a `ConstValue`'s bits if possible\n-            _ => self.val.try_to_bits(size),\n+            _ => self,\n         }\n     }\n "}, {"sha": "b030517e28ec271587ce4f2d915dfed8c3082866", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -20,6 +20,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n+rustc_plugin = { path = \"../librustc_plugin/deprecated\" } # To get this in the sysroot\n rustc_plugin_impl = { path = \"../librustc_plugin\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }"}, {"sha": "0906d358badd49dcbd940e5fc6e2f59ccd817756", "filename": "src/librustc_driver/args.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_driver%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_driver%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fargs.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,53 @@\n+use std::error;\n+use std::fmt;\n+use std::fs;\n+use std::io;\n+use std::str;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+static USED_ARGSFILE_FEATURE: AtomicBool = AtomicBool::new(false);\n+\n+pub fn used_unstable_argsfile() -> bool {\n+    USED_ARGSFILE_FEATURE.load(Ordering::Relaxed)\n+}\n+\n+pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n+    if arg.starts_with(\"@\") {\n+        let path = &arg[1..];\n+        let file = match fs::read_to_string(path) {\n+            Ok(file) => {\n+                USED_ARGSFILE_FEATURE.store(true, Ordering::Relaxed);\n+                file\n+            }\n+            Err(ref err) if err.kind() == io::ErrorKind::InvalidData => {\n+                return Err(Error::Utf8Error(Some(path.to_string())));\n+            }\n+            Err(err) => return Err(Error::IOError(path.to_string(), err)),\n+        };\n+        Ok(file.lines().map(ToString::to_string).collect())\n+    } else {\n+        Ok(vec![arg])\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    Utf8Error(Option<String>),\n+    IOError(String, io::Error),\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Error::Utf8Error(None) => write!(fmt, \"Utf8 error\"),\n+            Error::Utf8Error(Some(path)) => write!(fmt, \"Utf8 error in {}\", path),\n+            Error::IOError(path, err) => write!(fmt, \"IO Error: {}: {}\", path, err),\n+        }\n+    }\n+}\n+\n+impl error::Error for Error {\n+    fn description(&self) -> &'static str {\n+        \"argument error\"\n+    }\n+}"}, {"sha": "e7712ae115f5480dfd067eaecfd1dc3ee5ce3cea", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -68,6 +68,7 @@ use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n \n pub mod pretty;\n+mod args;\n \n /// Exit status code used for successful compilation and help output.\n pub const EXIT_SUCCESS: i32 = 0;\n@@ -141,14 +142,22 @@ impl Callbacks for TimePassesCallbacks {\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n pub fn run_compiler(\n-    args: &[String],\n+    at_args: &[String],\n     callbacks: &mut (dyn Callbacks + Send),\n     file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n     emitter: Option<Box<dyn Write + Send>>\n ) -> interface::Result<()> {\n+    let mut args = Vec::new();\n+    for arg in at_args {\n+        match args::arg_expand(arg.clone()) {\n+            Ok(arg) => args.extend(arg),\n+            Err(err) => early_error(ErrorOutputType::default(),\n+                &format!(\"Failed to load argument file: {}\", err)),\n+        }\n+    }\n     let diagnostic_output = emitter.map(|emitter| DiagnosticOutput::Raw(emitter))\n                                    .unwrap_or(DiagnosticOutput::Default);\n-    let matches = match handle_options(args) {\n+    let matches = match handle_options(&args) {\n         Some(matches) => matches,\n         None => return Ok(()),\n     };\n@@ -779,13 +788,19 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n     } else {\n         \"\\n    --help -v           Print the full set of options rustc accepts\"\n     };\n-    println!(\"{}\\nAdditional help:\n+    let at_path = if verbose && nightly_options::is_nightly_build() {\n+        \"    @path               Read newline separated options from `path`\\n\"\n+    } else {\n+        \"\"\n+    };\n+    println!(\"{options}{at_path}\\nAdditional help:\n     -C help             Print codegen options\n     -W help             \\\n-              Print 'lint' options and default settings{}{}\\n\",\n-             options.usage(message),\n-             nightly_help,\n-             verbose_help);\n+              Print 'lint' options and default settings{nightly}{verbose}\\n\",\n+             options = options.usage(message),\n+             at_path = at_path,\n+             nightly = nightly_help,\n+             verbose = verbose_help);\n }\n \n fn print_wall_help() {\n@@ -1010,6 +1025,12 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     //   (unstable option being used on stable)\n     nightly_options::check_nightly_options(&matches, &config::rustc_optgroups());\n \n+    // Late check to see if @file was used without unstable options enabled\n+    if crate::args::used_unstable_argsfile() && !nightly_options::is_unstable_enabled(&matches) {\n+        early_error(ErrorOutputType::default(),\n+            \"@path is unstable - use -Z unstable-options to enable its use\");\n+    }\n+\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         // Only show unstable options in --help if we accept unstable options.\n         usage(matches.opt_present(\"verbose\"), nightly_options::is_unstable_enabled(&matches));\n@@ -1190,7 +1211,7 @@ pub fn main() {\n     let result = report_ices_to_stderr_if_any(|| {\n         let args = env::args_os().enumerate()\n             .map(|(i, arg)| arg.into_string().unwrap_or_else(|arg| {\n-                early_error(ErrorOutputType::default(),\n+                    early_error(ErrorOutputType::default(),\n                             &format!(\"Argument {} is not valid Unicode: {:?}\", i, arg))\n             }))\n             .collect::<Vec<_>>();"}, {"sha": "efc77699313e054ba278dd70eaa0f45a8157b2ee", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -68,9 +68,9 @@ pub struct CrateMetadata {\n     pub alloc_decoding_state: AllocDecodingState,\n \n     // NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    // lifetime is only used behind `Lazy` / `LazySeq`, and therefore\n-    // acts like an universal (`for<'tcx>`), that is paired up with\n-    // whichever `TyCtxt` is being used to decode those values.\n+    // lifetime is only used behind `Lazy`, and therefore acts like an\n+    // universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n+    // is being used to decode those values.\n     pub root: schema::CrateRoot<'static>,\n \n     /// For each definition in this crate, we encode a key. When the\n@@ -80,7 +80,7 @@ pub struct CrateMetadata {\n     /// compilation support.\n     pub def_path_table: Lrc<DefPathTable>,\n \n-    pub trait_impls: FxHashMap<(u32, DefIndex), schema::LazySeq<DefIndex>>,\n+    pub trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n \n     pub dep_kind: Lock<DepKind>,\n     pub source: CrateSource,"}, {"sha": "da96728d2dec9c316a671b76805024dfc8a7d7b2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -134,14 +134,14 @@ impl<'a, 'tcx, T: Decodable> Lazy<T> {\n     }\n }\n \n-impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> LazySeq<T> {\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         meta: M,\n     ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n-        (0..self.len).map(move |_| T::decode(&mut dcx).unwrap())\n+        (0..self.meta).map(move |_| T::decode(&mut dcx).unwrap())\n     }\n }\n \n@@ -154,18 +154,22 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n \n-    fn read_lazy_distance(&mut self, min_size: usize) -> Result<usize, <Self as Decoder>::Error> {\n+    fn read_lazy_with_meta<T: ?Sized + LazyMeta>(\n+        &mut self,\n+        meta: T::Meta,\n+    ) -> Result<Lazy<T>, <Self as Decoder>::Error> {\n+        let min_size = T::min_size(meta);\n         let distance = self.read_usize()?;\n         let position = match self.lazy_state {\n-            LazyState::NoNode => bug!(\"read_lazy_distance: outside of a metadata node\"),\n+            LazyState::NoNode => bug!(\"read_lazy_with_meta: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n                 assert!(distance + min_size <= start);\n                 start - distance - min_size\n             }\n             LazyState::Previous(last_min_end) => last_min_end + distance,\n         };\n         self.lazy_state = LazyState::Previous(position + min_size);\n-        Ok(position)\n+        Ok(Lazy::from_position_and_meta(position, meta))\n     }\n }\n \n@@ -230,19 +234,18 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n-        Ok(Lazy::with_position(self.read_lazy_distance(Lazy::<T>::min_size())?))\n+        self.read_lazy_with_meta(())\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<LazySeq<T>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<LazySeq<T>, Self::Error> {\n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Lazy<[T]>, Self::Error> {\n         let len = self.read_usize()?;\n-        let position = if len == 0 {\n-            0\n+        if len == 0 {\n+            Ok(Lazy::empty())\n         } else {\n-            self.read_lazy_distance(LazySeq::<T>::min_size(len))?\n-        };\n-        Ok(LazySeq::with_position_and_length(position, len))\n+            self.read_lazy_with_meta(len)\n+        }\n     }\n }\n \n@@ -378,7 +381,7 @@ impl<'tcx> MetadataBlob {\n     }\n \n     pub fn get_rustc_version(&self) -> String {\n-        Lazy::with_position(METADATA_HEADER.len() + 4).decode(self)\n+        Lazy::<String>::from_position(METADATA_HEADER.len() + 4).decode(self)\n     }\n \n     pub fn get_root(&self) -> CrateRoot<'tcx> {\n@@ -387,7 +390,7 @@ impl<'tcx> MetadataBlob {\n         let pos = (((slice[offset + 0] as u32) << 24) | ((slice[offset + 1] as u32) << 16) |\n                    ((slice[offset + 2] as u32) << 8) |\n                    ((slice[offset + 3] as u32) << 0)) as usize;\n-        Lazy::with_position(pos).decode(self)\n+        Lazy::<CrateRoot<'tcx>>::from_position(pos).decode(self)\n     }\n \n     pub fn list_crate_metadata(&self,\n@@ -1140,7 +1143,7 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).arg_names,\n             EntryKind::Method(data) => data.decode(self).fn_data.arg_names,\n-            _ => LazySeq::empty(),\n+            _ => Lazy::empty(),\n         };\n         arg_names.decode(self).collect()\n     }"}, {"sha": "df3320c64a96085263713355780a129d6775b417", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 195, "deletions": 196, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -98,17 +98,17 @@ impl<'tcx> Encoder for EncodeContext<'tcx> {\n \n impl<'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n-        self.emit_lazy_distance(lazy.position, Lazy::<T>::min_size())\n+        self.emit_lazy_distance(*lazy)\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'tcx> {\n-    fn specialized_encode(&mut self, seq: &LazySeq<T>) -> Result<(), Self::Error> {\n-        self.emit_usize(seq.len)?;\n-        if seq.len == 0 {\n+impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n+    fn specialized_encode(&mut self, lazy: &Lazy<[T]>) -> Result<(), Self::Error> {\n+        self.emit_usize(lazy.meta)?;\n+        if lazy.meta == 0 {\n             return Ok(());\n         }\n-        self.emit_lazy_distance(seq.position, LazySeq::<T>::min_size(seq.len))\n+        self.emit_lazy_distance(*lazy)\n     }\n }\n \n@@ -239,21 +239,38 @@ impl<'tcx> TyEncoder for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx> EncodeContext<'tcx> {\n-    fn emit_node<F: FnOnce(&mut Self, usize) -> R, R>(&mut self, f: F) -> R {\n-        assert_eq!(self.lazy_state, LazyState::NoNode);\n-        let pos = self.position();\n-        self.lazy_state = LazyState::NodeStart(pos);\n-        let r = f(self, pos);\n-        self.lazy_state = LazyState::NoNode;\n-        r\n+/// Helper trait to allow overloading `EncodeContext::lazy` for iterators.\n+trait EncodeContentsForLazy<T: ?Sized + LazyMeta> {\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) -> T::Meta;\n+}\n+\n+impl<T: Encodable> EncodeContentsForLazy<T> for &T {\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) {\n+        self.encode(ecx).unwrap()\n+    }\n+}\n+\n+impl<T: Encodable> EncodeContentsForLazy<T> for T {\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) {\n+        self.encode(ecx).unwrap()\n+    }\n+}\n+\n+impl<I, T> EncodeContentsForLazy<[T]> for I\n+    where I: IntoIterator,\n+          I::Item: EncodeContentsForLazy<T>,\n+{\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) -> usize {\n+        self.into_iter().map(|value| value.encode_contents_for_lazy(ecx)).count()\n     }\n+}\n \n-    fn emit_lazy_distance(&mut self,\n-                          position: usize,\n-                          min_size: usize)\n-                          -> Result<(), <Self as Encoder>::Error> {\n-        let min_end = position + min_size;\n+impl<'tcx> EncodeContext<'tcx> {\n+    fn emit_lazy_distance<T: ?Sized + LazyMeta>(\n+        &mut self,\n+        lazy: Lazy<T>,\n+    ) -> Result<(), <Self as Encoder>::Error> {\n+        let min_end = lazy.position + T::min_size(lazy.meta);\n         let distance = match self.lazy_state {\n             LazyState::NoNode => bug!(\"emit_lazy_distance: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n@@ -262,48 +279,31 @@ impl<'tcx> EncodeContext<'tcx> {\n             }\n             LazyState::Previous(last_min_end) => {\n                 assert!(\n-                    last_min_end <= position,\n+                    last_min_end <= lazy.position,\n                     \"make sure that the calls to `lazy*` \\\n                     are in the same order as the metadata fields\",\n                 );\n-                position - last_min_end\n+                lazy.position - last_min_end\n             }\n         };\n         self.lazy_state = LazyState::Previous(min_end);\n         self.emit_usize(distance)\n     }\n \n-    pub fn lazy<T: Encodable>(&mut self, value: &T) -> Lazy<T> {\n-        self.emit_node(|ecx, pos| {\n-            value.encode(ecx).unwrap();\n-\n-            assert!(pos + Lazy::<T>::min_size() <= ecx.position());\n-            Lazy::with_position(pos)\n-        })\n-    }\n-\n-    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = T>,\n-              T: Encodable\n-    {\n-        self.emit_node(|ecx, pos| {\n-            let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n+    fn lazy<T: ?Sized + LazyMeta>(\n+        &mut self,\n+        value: impl EncodeContentsForLazy<T>,\n+    ) -> Lazy<T> {\n+        let pos = self.position();\n \n-            assert!(pos + LazySeq::<T>::min_size(len) <= ecx.position());\n-            LazySeq::with_position_and_length(pos, len)\n-        })\n-    }\n+        assert_eq!(self.lazy_state, LazyState::NoNode);\n+        self.lazy_state = LazyState::NodeStart(pos);\n+        let meta = value.encode_contents_for_lazy(self);\n+        self.lazy_state = LazyState::NoNode;\n \n-    pub fn lazy_seq_ref<'b, I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = &'b T>,\n-              T: 'b + Encodable\n-    {\n-        self.emit_node(|ecx, pos| {\n-            let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n+        assert!(pos + <T>::min_size(meta) <= self.position());\n \n-            assert!(pos + LazySeq::<T>::min_size(len) <= ecx.position());\n-            LazySeq::with_position_and_length(pos, len)\n-        })\n+        Lazy::from_position_and_meta(pos, meta)\n     }\n \n     /// Emit the data for a `DefId` to the metadata. The function to\n@@ -320,7 +320,7 @@ impl<'tcx> EncodeContext<'tcx> {\n         assert!(id.is_local());\n \n         let entry = op(self, data);\n-        let entry = self.lazy(&entry);\n+        let entry = self.lazy(entry);\n         self.entries_index.record(id, entry);\n     }\n \n@@ -341,7 +341,7 @@ impl<'tcx> EncodeContext<'tcx> {\n         self.lazy(definitions.def_path_table())\n     }\n \n-    fn encode_source_map(&mut self) -> LazySeq<syntax_pos::SourceFile> {\n+    fn encode_source_map(&mut self) -> Lazy<[syntax_pos::SourceFile]> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n \n@@ -380,7 +380,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             })\n             .collect::<Vec<_>>();\n \n-        self.lazy_seq_ref(adapted.iter().map(|rc| &**rc))\n+        self.lazy(adapted.iter().map(|rc| &**rc))\n     }\n \n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n@@ -463,7 +463,7 @@ impl<'tcx> EncodeContext<'tcx> {\n                 }\n                 n = new_n;\n             }\n-            self.lazy_seq(interpret_alloc_index)\n+            self.lazy(interpret_alloc_index)\n         };\n \n \n@@ -482,8 +482,7 @@ impl<'tcx> EncodeContext<'tcx> {\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n         let has_panic_handler = *tcx.sess.has_panic_handler.try_get().unwrap_or(&false);\n \n-\n-        let root = self.lazy(&CrateRoot {\n+        let root = self.lazy(CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n             extra_filename: tcx.sess.opts.cg.extra_filename.clone(),\n             triple: tcx.sess.opts.target_triple.clone(),\n@@ -562,17 +561,17 @@ impl<'tcx> EncodeContext<'tcx> {\n }\n \n impl EncodeContext<'tcx> {\n-    fn encode_variances_of(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n+    fn encode_variances_of(&mut self, def_id: DefId) -> Lazy<[ty::Variance]> {\n         debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy_seq_ref(&tcx.variances_of(def_id)[..])\n+        self.lazy(&tcx.variances_of(def_id)[..])\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n         let ty = tcx.type_of(def_id);\n         debug!(\"EncodeContext::encode_item_type({:?}) => {:?}\", def_id, ty);\n-        self.lazy(&ty)\n+        self.lazy(ty)\n     }\n \n     fn encode_enum_variant_info(\n@@ -601,23 +600,23 @@ impl EncodeContext<'tcx> {\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n         Entry {\n-            kind: EntryKind::Variant(self.lazy(&data)),\n-            visibility: self.lazy(&ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            kind: EntryKind::Variant(self.lazy(data)),\n+            visibility: self.lazy(ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: self.lazy_seq(variant.fields.iter().map(|f| {\n+            children: self.lazy(variant.fields.iter().map(|f| {\n                 assert!(f.did.is_local());\n                 f.did.index\n             })),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if variant.ctor_kind == CtorKind::Fn {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -642,7 +641,7 @@ impl EncodeContext<'tcx> {\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n             ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(&tcx.fn_sig(def_id)))\n+                Some(self.lazy(tcx.fn_sig(def_id)))\n             } else {\n                 None\n             }\n@@ -658,20 +657,20 @@ impl EncodeContext<'tcx> {\n         }\n \n         Entry {\n-            kind: EntryKind::Variant(self.lazy(&data)),\n-            visibility: self.lazy(&ctor_vis),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            kind: EntryKind::Variant(self.lazy(data)),\n+            visibility: self.lazy(ctor_vis),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if variant.ctor_kind == CtorKind::Fn {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -691,25 +690,25 @@ impl EncodeContext<'tcx> {\n \n         let data = ModData {\n             reexports: match tcx.module_exports(def_id) {\n-                Some(exports) => self.lazy_seq_ref(exports),\n-                _ => LazySeq::empty(),\n+                Some(exports) => self.lazy(exports),\n+                _ => Lazy::empty(),\n             },\n         };\n \n         Entry {\n-            kind: EntryKind::Mod(self.lazy(&data)),\n-            visibility: self.lazy(&ty::Visibility::from_hir(vis, id, tcx)),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            kind: EntryKind::Mod(self.lazy(data)),\n+            visibility: self.lazy(ty::Visibility::from_hir(vis, id, tcx)),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(attrs),\n-            children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n+            children: self.lazy(md.item_ids.iter().map(|item_id| {\n                 tcx.hir().local_def_id(item_id.id).index\n             })),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: None,\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: None,\n             predicates: None,\n             predicates_defined_on: None,\n@@ -734,16 +733,16 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind: EntryKind::Field,\n-            visibility: self.lazy(&field.vis),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            visibility: self.lazy(field.vis),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n             predicates_defined_on: None,\n@@ -763,7 +762,7 @@ impl EncodeContext<'tcx> {\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n             ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(&tcx.fn_sig(def_id)))\n+                Some(self.lazy(tcx.fn_sig(def_id)))\n             } else {\n                 None\n             }\n@@ -789,20 +788,20 @@ impl EncodeContext<'tcx> {\n         let repr_options = get_repr_options(tcx, adt_def_id);\n \n         Entry {\n-            kind: EntryKind::Struct(self.lazy(&data), repr_options),\n-            visibility: self.lazy(&ctor_vis),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            kind: EntryKind::Struct(self.lazy(data), repr_options),\n+            visibility: self.lazy(ctor_vis),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if variant.ctor_kind == CtorKind::Fn {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -821,13 +820,13 @@ impl EncodeContext<'tcx> {\n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n         debug!(\"EncodeContext::encode_predicates({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy(&tcx.predicates_of(def_id))\n+        self.lazy(&*tcx.predicates_of(def_id))\n     }\n \n     fn encode_predicates_defined_on(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n         debug!(\"EncodeContext::encode_predicates_defined_on({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy(&tcx.predicates_defined_on(def_id))\n+        self.lazy(&*tcx.predicates_defined_on(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n@@ -858,7 +857,7 @@ impl EncodeContext<'tcx> {\n \n                 let rendered =\n                     hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n-                let rendered_const = self.lazy(&RenderedConst(rendered));\n+                let rendered_const = self.lazy(RenderedConst(rendered));\n \n                 EntryKind::AssocConst(container, const_qualif, rendered_const)\n             }\n@@ -875,12 +874,12 @@ impl EncodeContext<'tcx> {\n                     FnData {\n                         constness: hir::Constness::NotConst,\n                         arg_names,\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::Method(self.lazy(&MethodData {\n+                EntryKind::Method(self.lazy(MethodData {\n                     fn_data,\n                     container,\n                     has_self: trait_item.method_has_self_argument,\n@@ -892,10 +891,10 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&trait_item.vis),\n-            span: self.lazy(&ast_item.span),\n+            visibility: self.lazy(trait_item.vis),\n+            span: self.lazy(ast_item.span),\n             attributes: self.encode_attributes(&ast_item.attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n@@ -913,11 +912,11 @@ impl EncodeContext<'tcx> {\n                 }\n                 ty::AssocKind::OpaqueTy => unreachable!(),\n             },\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if trait_item.kind == ty::AssocKind::Method {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -971,12 +970,12 @@ impl EncodeContext<'tcx> {\n                     FnData {\n                         constness: sig.header.constness,\n                         arg_names: self.encode_fn_arg_names_for_body(body),\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::Method(self.lazy(&MethodData {\n+                EntryKind::Method(self.lazy(MethodData {\n                     fn_data,\n                     container,\n                     has_self: impl_item.method_has_self_argument,\n@@ -1004,19 +1003,19 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&impl_item.vis),\n-            span: self.lazy(&ast_item.span),\n+            visibility: self.lazy(impl_item.vis),\n+            span: self.lazy(ast_item.span),\n             attributes: self.encode_attributes(&ast_item.attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if impl_item.kind == ty::AssocKind::Method {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -1027,10 +1026,10 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_fn_arg_names_for_body(&mut self, body_id: hir::BodyId)\n-                                    -> LazySeq<ast::Name> {\n+                                    -> Lazy<[ast::Name]> {\n         self.tcx.dep_graph.with_ignore(|| {\n             let body = self.tcx.hir().body(body_id);\n-            self.lazy_seq(body.arguments.iter().map(|arg| {\n+            self.lazy(body.arguments.iter().map(|arg| {\n                 match arg.pat.node {\n                     PatKind::Binding(_, _, ident, _) => ident.name,\n                     _ => kw::Invalid,\n@@ -1039,28 +1038,28 @@ impl EncodeContext<'tcx> {\n         })\n     }\n \n-    fn encode_fn_arg_names(&mut self, param_names: &[ast::Ident]) -> LazySeq<ast::Name> {\n-        self.lazy_seq(param_names.iter().map(|ident| ident.name))\n+    fn encode_fn_arg_names(&mut self, param_names: &[ast::Ident]) -> Lazy<[ast::Name]> {\n+        self.lazy(param_names.iter().map(|ident| ident.name))\n     }\n \n     fn encode_optimized_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Body<'tcx>>> {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n             let mir = self.tcx.optimized_mir(def_id);\n-            Some(self.lazy(&mir))\n+            Some(self.lazy(mir))\n         } else {\n             None\n         }\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n-    fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n+    fn encode_inherent_implementations(&mut self, def_id: DefId) -> Lazy<[DefIndex]> {\n         debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n         if implementations.is_empty() {\n-            LazySeq::empty()\n+            Lazy::empty()\n         } else {\n-            self.lazy_seq(implementations.iter().map(|&def_id| {\n+            self.lazy(implementations.iter().map(|&def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n             }))\n@@ -1074,7 +1073,7 @@ impl EncodeContext<'tcx> {\n \n     fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n         debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n-        self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n+        self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(depr))\n     }\n \n     fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n@@ -1103,10 +1102,10 @@ impl EncodeContext<'tcx> {\n                 let data = FnData {\n                     constness: header.constness,\n                     arg_names: self.encode_fn_arg_names_for_body(body),\n-                    sig: self.lazy(&tcx.fn_sig(def_id)),\n+                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n \n-                EntryKind::Fn(self.lazy(&data))\n+                EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod((item.hir_id, m, &item.attrs, &item.vis));\n@@ -1127,7 +1126,7 @@ impl EncodeContext<'tcx> {\n \n                 let repr_options = get_repr_options(tcx, def_id);\n \n-                EntryKind::Struct(self.lazy(&VariantData {\n+                EntryKind::Struct(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n@@ -1138,7 +1137,7 @@ impl EncodeContext<'tcx> {\n                 let variant = tcx.adt_def(def_id).non_enum_variant();\n                 let repr_options = get_repr_options(tcx, def_id);\n \n-                EntryKind::Union(self.lazy(&VariantData {\n+                EntryKind::Union(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n@@ -1175,10 +1174,10 @@ impl EncodeContext<'tcx> {\n                     defaultness,\n                     parent_impl: parent,\n                     coerce_unsized_info,\n-                    trait_ref: trait_ref.map(|trait_ref| self.lazy(&trait_ref)),\n+                    trait_ref: trait_ref.map(|trait_ref| self.lazy(trait_ref)),\n                 };\n \n-                EntryKind::Impl(self.lazy(&data))\n+                EntryKind::Impl(self.lazy(data))\n             }\n             hir::ItemKind::Trait(..) => {\n                 let trait_def = tcx.trait_def(def_id);\n@@ -1187,57 +1186,57 @@ impl EncodeContext<'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_auto_impl: tcx.trait_is_auto(def_id),\n                     is_marker: trait_def.is_marker,\n-                    super_predicates: self.lazy(&tcx.super_predicates_of(def_id)),\n+                    super_predicates: self.lazy(&*tcx.super_predicates_of(def_id)),\n                 };\n \n-                EntryKind::Trait(self.lazy(&data))\n+                EntryKind::Trait(self.lazy(data))\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 let data = TraitAliasData {\n-                    super_predicates: self.lazy(&tcx.super_predicates_of(def_id)),\n+                    super_predicates: self.lazy(&*tcx.super_predicates_of(def_id)),\n                 };\n \n-                EntryKind::TraitAlias(self.lazy(&data))\n+                EntryKind::TraitAlias(self.lazy(data))\n             }\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n-            span: self.lazy(&item.span),\n+            visibility: self.lazy(ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n+            span: self.lazy(item.span),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n                 hir::ItemKind::ForeignMod(ref fm) => {\n-                    self.lazy_seq(fm.items\n+                    self.lazy(fm.items\n                         .iter()\n                         .map(|foreign_item| tcx.hir().local_def_id(\n                             foreign_item.hir_id).index))\n                 }\n                 hir::ItemKind::Enum(..) => {\n                     let def = self.tcx.adt_def(def_id);\n-                    self.lazy_seq(def.variants.iter().map(|v| {\n+                    self.lazy(def.variants.iter().map(|v| {\n                         assert!(v.def_id.is_local());\n                         v.def_id.index\n                     }))\n                 }\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) => {\n                     let def = self.tcx.adt_def(def_id);\n-                    self.lazy_seq(def.non_enum_variant().fields.iter().map(|f| {\n+                    self.lazy(def.non_enum_variant().fields.iter().map(|f| {\n                         assert!(f.did.is_local());\n                         f.did.index\n                     }))\n                 }\n                 hir::ItemKind::Impl(..) |\n                 hir::ItemKind::Trait(..) => {\n-                    self.lazy_seq(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n+                    self.lazy(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n                         assert!(def_id.is_local());\n                         def_id.index\n                     }))\n                 }\n-                _ => LazySeq::empty(),\n+                _ => Lazy::empty(),\n             },\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n@@ -1260,7 +1259,7 @@ impl EncodeContext<'tcx> {\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) |\n                 hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => LazySeq::empty(),\n+                _ => Lazy::empty(),\n             },\n             generics: match item.node {\n                 hir::ItemKind::Static(..) |\n@@ -1333,20 +1332,20 @@ impl EncodeContext<'tcx> {\n         use syntax::print::pprust;\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n         Entry {\n-            kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n+            kind: EntryKind::MacroDef(self.lazy(MacroDef {\n                 body: pprust::tokens_to_string(macro_def.body.clone()),\n                 legacy: macro_def.legacy,\n             })),\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&macro_def.span),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(macro_def.span),\n             attributes: self.encode_attributes(&macro_def.attrs),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             ty: None,\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: None,\n             predicates: None,\n             predicates_defined_on: None,\n@@ -1363,15 +1362,15 @@ impl EncodeContext<'tcx> {\n         let tcx = self.tcx;\n         Entry {\n             kind: entry_kind,\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: None,\n             deprecation: None,\n             ty: if encode_type { Some(self.encode_item_type(def_id)) } else { None },\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: None,\n             predicates: None,\n             predicates_defined_on: None,\n@@ -1408,30 +1407,30 @@ impl EncodeContext<'tcx> {\n                 let data = GeneratorData {\n                     layout: layout.clone(),\n                 };\n-                EntryKind::Generator(self.lazy(&data))\n+                EntryKind::Generator(self.lazy(data))\n             }\n \n             ty::Closure(def_id, substs) => {\n                 let sig = substs.closure_sig(def_id, self.tcx);\n-                let data = ClosureData { sig: self.lazy(&sig) };\n-                EntryKind::Closure(self.lazy(&data))\n+                let data = ClosureData { sig: self.lazy(sig) };\n+                EntryKind::Closure(self.lazy(data))\n             }\n \n             _ => bug!(\"closure that is neither generator nor closure\")\n         };\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: None,\n             deprecation: None,\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: None,\n             predicates_defined_on: None,\n@@ -1450,16 +1449,16 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind: EntryKind::Const(self.const_qualif(mir, body_id), const_data),\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: None,\n             deprecation: None,\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n             predicates_defined_on: None,\n@@ -1468,37 +1467,37 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n-        self.lazy_seq_ref(attrs)\n+    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> Lazy<[ast::Attribute]> {\n+        self.lazy(attrs)\n     }\n \n-    fn encode_native_libraries(&mut self) -> LazySeq<NativeLibrary> {\n+    fn encode_native_libraries(&mut self) -> Lazy<[NativeLibrary]> {\n         let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n-        self.lazy_seq(used_libraries.iter().cloned())\n+        self.lazy(used_libraries.iter().cloned())\n     }\n \n-    fn encode_foreign_modules(&mut self) -> LazySeq<ForeignModule> {\n+    fn encode_foreign_modules(&mut self) -> Lazy<[ForeignModule]> {\n         let foreign_modules = self.tcx.foreign_modules(LOCAL_CRATE);\n-        self.lazy_seq(foreign_modules.iter().cloned())\n+        self.lazy(foreign_modules.iter().cloned())\n     }\n \n-    fn encode_proc_macros(&mut self) -> Option<LazySeq<DefIndex>> {\n+    fn encode_proc_macros(&mut self) -> Option<Lazy<[DefIndex]>> {\n         let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n         if is_proc_macro {\n-            let proc_macros: Vec<_> = self.tcx.hir().krate().items.values().filter_map(|item| {\n+            let tcx = self.tcx;\n+            Some(self.lazy(tcx.hir().krate().items.values().filter_map(|item| {\n                 if item.attrs.iter().any(|attr| is_proc_macro_attr(attr)) {\n                     Some(item.hir_id.owner)\n                 } else {\n                     None\n                 }\n-            }).collect();\n-            Some(self.lazy_seq(proc_macros))\n+            })))\n         } else {\n             None\n         }\n     }\n \n-    fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n+    fn encode_crate_deps(&mut self) -> Lazy<[CrateDep]> {\n         let crates = self.tcx.crates();\n \n         let mut deps = crates\n@@ -1529,20 +1528,20 @@ impl EncodeContext<'tcx> {\n         // the assumption that they are numbered 1 to n.\n         // FIXME (#2166): This is not nearly enough to support correct versioning\n         // but is enough to get transitive crate dependencies working.\n-        self.lazy_seq_ref(deps.iter().map(|&(_, ref dep)| dep))\n+        self.lazy(deps.iter().map(|&(_, ref dep)| dep))\n     }\n \n-    fn encode_lib_features(&mut self) -> LazySeq<(ast::Name, Option<ast::Name>)> {\n+    fn encode_lib_features(&mut self) -> Lazy<[(ast::Name, Option<ast::Name>)]> {\n         let tcx = self.tcx;\n         let lib_features = tcx.lib_features();\n-        self.lazy_seq(lib_features.to_vec())\n+        self.lazy(lib_features.to_vec())\n     }\n \n-    fn encode_lang_items(&mut self) -> LazySeq<(DefIndex, usize)> {\n+    fn encode_lang_items(&mut self) -> Lazy<[(DefIndex, usize)]> {\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items();\n         let lang_items = lang_items.items().iter();\n-        self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n+        self.lazy(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n             if let Some(def_id) = opt_def_id {\n                 if def_id.is_local() {\n                     return Some((def_id.index, i));\n@@ -1552,13 +1551,13 @@ impl EncodeContext<'tcx> {\n         }))\n     }\n \n-    fn encode_lang_items_missing(&mut self) -> LazySeq<lang_items::LangItem> {\n+    fn encode_lang_items_missing(&mut self) -> Lazy<[lang_items::LangItem]> {\n         let tcx = self.tcx;\n-        self.lazy_seq_ref(&tcx.lang_items().missing)\n+        self.lazy(&tcx.lang_items().missing)\n     }\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n-    fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n+    fn encode_impls(&mut self) -> Lazy<[TraitImpls]> {\n         debug!(\"EncodeContext::encode_impls()\");\n         let tcx = self.tcx;\n         let mut visitor = ImplVisitor {\n@@ -1584,12 +1583,12 @@ impl EncodeContext<'tcx> {\n \n                 TraitImpls {\n                     trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n-                    impls: self.lazy_seq_ref(&impls),\n+                    impls: self.lazy(&impls),\n                 }\n             })\n             .collect();\n \n-        self.lazy_seq_ref(&all_impls)\n+        self.lazy(&all_impls)\n     }\n \n     // Encodes all symbols exported from this crate into the metadata.\n@@ -1600,12 +1599,12 @@ impl EncodeContext<'tcx> {\n     // definition (as that's not defined in this crate).\n     fn encode_exported_symbols(&mut self,\n                                exported_symbols: &[(ExportedSymbol<'tcx>, SymbolExportLevel)])\n-                               -> LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n+                               -> Lazy<[(ExportedSymbol<'tcx>, SymbolExportLevel)]> {\n         // The metadata symbol name is special. It should not show up in\n         // downstream crates.\n         let metadata_symbol_name = SymbolName::new(&metadata_symbol_name(self.tcx));\n \n-        self.lazy_seq(exported_symbols\n+        self.lazy(exported_symbols\n             .iter()\n             .filter(|&&(ref exported_symbol, _)| {\n                 match *exported_symbol {\n@@ -1618,10 +1617,10 @@ impl EncodeContext<'tcx> {\n             .cloned())\n     }\n \n-    fn encode_dylib_dependency_formats(&mut self) -> LazySeq<Option<LinkagePreference>> {\n+    fn encode_dylib_dependency_formats(&mut self) -> Lazy<[Option<LinkagePreference>]> {\n         match self.tcx.sess.dependency_formats.borrow().get(&config::CrateType::Dylib) {\n             Some(arr) => {\n-                self.lazy_seq(arr.iter().map(|slot| {\n+                self.lazy(arr.iter().map(|slot| {\n                     match *slot {\n                         Linkage::NotLinked |\n                         Linkage::IncludedFromDylib => None,\n@@ -1631,7 +1630,7 @@ impl EncodeContext<'tcx> {\n                     }\n                 }))\n             }\n-            None => LazySeq::empty(),\n+            None => Lazy::empty(),\n         }\n     }\n \n@@ -1647,9 +1646,9 @@ impl EncodeContext<'tcx> {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n                     arg_names: self.encode_fn_arg_names(names),\n-                    sig: self.lazy(&tcx.fn_sig(def_id)),\n+                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n-                EntryKind::ForeignFn(self.lazy(&data))\n+                EntryKind::ForeignFn(self.lazy(data))\n             }\n             hir::ForeignItemKind::Static(_, hir::MutMutable) => EntryKind::ForeignMutStatic,\n             hir::ForeignItemKind::Static(_, hir::MutImmutable) => EntryKind::ForeignImmStatic,\n@@ -1658,18 +1657,18 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, tcx)),\n-            span: self.lazy(&nitem.span),\n+            visibility: self.lazy(ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, tcx)),\n+            span: self.lazy(nitem.span),\n             attributes: self.encode_attributes(&nitem.attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: match nitem.node {\n                 hir::ForeignItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => LazySeq::empty(),\n+                _ => Lazy::empty(),\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),"}, {"sha": "6f248f22cf2527502e3b60bbd39c9ea38788f810", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -108,34 +108,34 @@ impl Index<'tcx> {\n         position.write_to_bytes_at(positions, array_index)\n     }\n \n-    pub fn write_index(&self, buf: &mut Encoder) -> LazySeq<Self> {\n+    pub fn write_index(&self, buf: &mut Encoder) -> Lazy<[Self]> {\n         let pos = buf.position();\n \n         // First we write the length of the lower range ...\n         buf.emit_raw_bytes(&(self.positions.len() as u32 / 4).to_le_bytes());\n         // ... then the values.\n         buf.emit_raw_bytes(&self.positions);\n-        LazySeq::with_position_and_length(pos as usize, self.positions.len() / 4 + 1)\n+        Lazy::from_position_and_meta(pos as usize, self.positions.len() / 4 + 1)\n     }\n }\n \n-impl LazySeq<Index<'tcx>> {\n+impl Lazy<[Index<'tcx>]> {\n     /// Given the metadata, extract out the offset of a particular\n     /// DefIndex (if any).\n     #[inline(never)]\n     pub fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n         let bytes = &bytes[self.position..];\n         debug!(\"Index::lookup: index={:?} len={:?}\",\n                def_index,\n-               self.len);\n+               self.meta);\n \n         let position = u32::read_from_bytes_at(bytes, 1 + def_index.index());\n         if position == u32::MAX {\n             debug!(\"Index::lookup: position=u32::MAX\");\n             None\n         } else {\n             debug!(\"Index::lookup: position={:?}\", position);\n-            Some(Lazy::with_position(position as usize))\n+            Some(Lazy::from_position(position as usize))\n         }\n     }\n }"}, {"sha": "f37877b437e157582b7e5d0938ad91a1844d96e5", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 78, "deletions": 75, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -41,6 +41,33 @@ pub const METADATA_VERSION: u8 = 4;\n pub const METADATA_HEADER: &[u8; 12] =\n     &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n+/// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n+/// e.g. for `Lazy<[T]>`, this is the length (count of `T` values).\n+pub trait LazyMeta {\n+    type Meta: Copy + 'static;\n+\n+    /// Returns the minimum encoded size.\n+    // FIXME(eddyb) Give better estimates for certain types.\n+    fn min_size(meta: Self::Meta) -> usize;\n+}\n+\n+impl<T> LazyMeta for T {\n+    type Meta = ();\n+\n+    fn min_size(_: ()) -> usize {\n+        assert_ne!(std::mem::size_of::<T>(), 0);\n+        1\n+    }\n+}\n+\n+impl<T> LazyMeta for [T] {\n+    type Meta = usize;\n+\n+    fn min_size(len: usize) -> usize {\n+        len * T::min_size(())\n+    }\n+}\n+\n /// A value of type T referred to by its absolute position\n /// in the metadata, and which can be decoded lazily.\n ///\n@@ -56,40 +83,8 @@ pub const METADATA_HEADER: &[u8; 12] =\n /// Distances start at 1, as 0-byte nodes are invalid.\n /// Also invalid are nodes being referred in a different\n /// order than they were encoded in.\n-#[must_use]\n-pub struct Lazy<T> {\n-    pub position: usize,\n-    _marker: PhantomData<T>,\n-}\n-\n-impl<T> Lazy<T> {\n-    pub fn with_position(position: usize) -> Lazy<T> {\n-        Lazy {\n-            position,\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    /// Returns the minimum encoded size of a value of type `T`.\n-    // FIXME(eddyb) Give better estimates for certain types.\n-    pub fn min_size() -> usize {\n-        1\n-    }\n-}\n-\n-impl<T> Copy for Lazy<T> {}\n-impl<T> Clone for Lazy<T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-impl<T> rustc_serialize::UseSpecializedEncodable for Lazy<T> {}\n-impl<T> rustc_serialize::UseSpecializedDecodable for Lazy<T> {}\n-\n-/// A sequence of type T referred to by its absolute position\n-/// in the metadata and length, and which can be decoded lazily.\n-/// The sequence is a single node for the purposes of `Lazy`.\n+///\n+/// # Sequences (`Lazy<[T]>`)\n ///\n /// Unlike `Lazy<Vec<T>>`, the length is encoded next to the\n /// position, not at the position, which means that the length\n@@ -100,54 +95,62 @@ impl<T> rustc_serialize::UseSpecializedDecodable for Lazy<T> {}\n /// the minimal distance the length of the sequence, i.e.\n /// it's assumed there's no 0-byte element in the sequence.\n #[must_use]\n-pub struct LazySeq<T> {\n-    pub len: usize,\n+// FIXME(#59875) the `Meta` parameter only exists to dodge\n+// invariance wrt `T` (coming from the `meta: T::Meta` field).\n+pub struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n+    where T: ?Sized + LazyMeta<Meta = Meta>,\n+          Meta: 'static + Copy,\n+{\n     pub position: usize,\n+    pub meta: Meta,\n     _marker: PhantomData<T>,\n }\n \n-impl<T> LazySeq<T> {\n-    pub fn empty() -> LazySeq<T> {\n-        LazySeq::with_position_and_length(0, 0)\n-    }\n-\n-    pub fn with_position_and_length(position: usize, len: usize) -> LazySeq<T> {\n-        LazySeq {\n-            len,\n+impl<T: ?Sized + LazyMeta> Lazy<T> {\n+    pub fn from_position_and_meta(position: usize, meta: T::Meta) -> Lazy<T> {\n+        Lazy {\n             position,\n+            meta,\n             _marker: PhantomData,\n         }\n     }\n+}\n+\n+impl<T> Lazy<T> {\n+    pub fn from_position(position: usize) -> Lazy<T> {\n+        Lazy::from_position_and_meta(position, ())\n+    }\n+}\n \n-    /// Returns the minimum encoded size of `length` values of type `T`.\n-    pub fn min_size(length: usize) -> usize {\n-        length\n+impl<T> Lazy<[T]> {\n+    pub fn empty() -> Lazy<[T]> {\n+        Lazy::from_position_and_meta(0, 0)\n     }\n }\n \n-impl<T> Copy for LazySeq<T> {}\n-impl<T> Clone for LazySeq<T> {\n+impl<T: ?Sized + LazyMeta> Copy for Lazy<T> {}\n+impl<T: ?Sized + LazyMeta> Clone for Lazy<T> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<T> rustc_serialize::UseSpecializedEncodable for LazySeq<T> {}\n-impl<T> rustc_serialize::UseSpecializedDecodable for LazySeq<T> {}\n+impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedEncodable for Lazy<T> {}\n+impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedDecodable for Lazy<T> {}\n \n-/// Encoding / decoding state for `Lazy` and `LazySeq`.\n+/// Encoding / decoding state for `Lazy`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum LazyState {\n     /// Outside of a metadata node.\n     NoNode,\n \n-    /// Inside a metadata node, and before any `Lazy` or `LazySeq`.\n+    /// Inside a metadata node, and before any `Lazy`.\n     /// The position is that of the node itself.\n     NodeStart(usize),\n \n-    /// Inside a metadata node, with a previous `Lazy` or `LazySeq`.\n+    /// Inside a metadata node, with a previous `Lazy`.\n     /// The position is a conservative estimate of where that\n-    /// previous `Lazy` / `LazySeq` would end (see their comments).\n+    /// previous `Lazy` would end (see their comments).\n     Previous(usize),\n }\n \n@@ -167,24 +170,24 @@ pub struct CrateRoot<'tcx> {\n     pub proc_macro_decls_static: Option<DefIndex>,\n     pub proc_macro_stability: Option<attr::Stability>,\n \n-    pub crate_deps: LazySeq<CrateDep>,\n-    pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,\n-    pub lib_features: LazySeq<(Symbol, Option<Symbol>)>,\n-    pub lang_items: LazySeq<(DefIndex, usize)>,\n-    pub lang_items_missing: LazySeq<lang_items::LangItem>,\n-    pub native_libraries: LazySeq<NativeLibrary>,\n-    pub foreign_modules: LazySeq<ForeignModule>,\n-    pub source_map: LazySeq<syntax_pos::SourceFile>,\n+    pub crate_deps: Lazy<[CrateDep]>,\n+    pub dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n+    pub lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n+    pub lang_items: Lazy<[(DefIndex, usize)]>,\n+    pub lang_items_missing: Lazy<[lang_items::LangItem]>,\n+    pub native_libraries: Lazy<[NativeLibrary]>,\n+    pub foreign_modules: Lazy<[ForeignModule]>,\n+    pub source_map: Lazy<[syntax_pos::SourceFile]>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n-    pub impls: LazySeq<TraitImpls>,\n-    pub exported_symbols: LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)>,\n-    pub interpret_alloc_index: LazySeq<u32>,\n+    pub impls: Lazy<[TraitImpls]>,\n+    pub exported_symbols: Lazy<[(ExportedSymbol<'tcx>, SymbolExportLevel)]>,\n+    pub interpret_alloc_index: Lazy<[u32]>,\n \n-    pub entries_index: LazySeq<index::Index<'tcx>>,\n+    pub entries_index: Lazy<[index::Index<'tcx>]>,\n \n     /// The DefIndex's of any proc macros delcared by\n     /// this crate\n-    pub proc_macro_data: Option<LazySeq<DefIndex>>,\n+    pub proc_macro_data: Option<Lazy<[DefIndex]>>,\n \n     pub compiler_builtins: bool,\n     pub needs_allocator: bool,\n@@ -207,22 +210,22 @@ pub struct CrateDep {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n-    pub impls: LazySeq<DefIndex>,\n+    pub impls: Lazy<[DefIndex]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n     pub visibility: Lazy<ty::Visibility>,\n     pub span: Lazy<Span>,\n-    pub attributes: LazySeq<ast::Attribute>,\n-    pub children: LazySeq<DefIndex>,\n+    pub attributes: Lazy<[ast::Attribute]>,\n+    pub children: Lazy<[DefIndex]>,\n     pub stability: Option<Lazy<attr::Stability>>,\n     pub deprecation: Option<Lazy<attr::Deprecation>>,\n \n     pub ty: Option<Lazy<Ty<'tcx>>>,\n-    pub inherent_impls: LazySeq<DefIndex>,\n-    pub variances: LazySeq<ty::Variance>,\n+    pub inherent_impls: Lazy<[DefIndex]>,\n+    pub variances: Lazy<[ty::Variance]>,\n     pub generics: Option<Lazy<ty::Generics>>,\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n     pub predicates_defined_on: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n@@ -278,7 +281,7 @@ pub struct RenderedConst(pub String);\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n-    pub reexports: LazySeq<def::Export<hir::HirId>>,\n+    pub reexports: Lazy<[def::Export<hir::HirId>]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -290,7 +293,7 @@ pub struct MacroDef {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData<'tcx> {\n     pub constness: hir::Constness,\n-    pub arg_names: LazySeq<ast::Name>,\n+    pub arg_names: Lazy<[ast::Name]>,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n "}, {"sha": "a30cd8a627fe3e32d0e67a3dbd4e8296b236c86c", "filename": "src/librustc_passes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_passes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_passes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Ferror_codes.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -131,7 +131,7 @@ be taken. Erroneous code example:\n \n ```compile_fail,E0268\n fn some_func() {\n-    break; // error: `break` outside of loop\n+    break; // error: `break` outside of a loop\n }\n ```\n "}, {"sha": "dbfbec32a6fbf53508d9f4cb77b1ccdae11b8f73", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -16,8 +16,8 @@ use errors::Applicability;\n enum Context {\n     Normal,\n     Loop(hir::LoopSource),\n-    Closure,\n-    AsyncClosure,\n+    Closure(Span),\n+    AsyncClosure(Span),\n     LabeledBlock,\n     AnonConst,\n }\n@@ -58,11 +58,11 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n             hir::ExprKind::Loop(ref b, _, source) => {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n-            hir::ExprKind::Closure(_, ref function_decl, b, _, movability) => {\n+            hir::ExprKind::Closure(_, ref function_decl, b, span, movability) => {\n                 let cx = if let Some(GeneratorMovability::Static) = movability {\n-                    AsyncClosure\n+                    AsyncClosure(span)\n                 } else {\n-                    Closure\n+                    Closure(span)\n                 };\n                 self.visit_fn_decl(&function_decl);\n                 self.with_context(cx, |v| v.visit_nested_body(b));\n@@ -170,23 +170,22 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n     }\n \n     fn require_break_cx(&self, name: &str, span: Span) {\n-        match self.cx {\n-            LabeledBlock | Loop(_) => {}\n-            Closure => {\n-                struct_span_err!(self.sess, span, E0267, \"`{}` inside of a closure\", name)\n-                .span_label(span, \"cannot break inside of a closure\")\n+        let err_inside_of = |article, ty, closure_span| {\n+            struct_span_err!(self.sess, span, E0267, \"`{}` inside of {} {}\", name, article, ty)\n+                .span_label(span, format!(\"cannot `{}` inside of {} {}\", name, article, ty))\n+                .span_label(closure_span, &format!(\"enclosing {}\", ty))\n                 .emit();\n-            }\n-            AsyncClosure => {\n-                struct_span_err!(self.sess, span, E0267, \"`{}` inside of an async block\", name)\n-                    .span_label(span, \"cannot break inside of an async block\")\n-                    .emit();\n-            }\n+        };\n+\n+        match self.cx {\n+            LabeledBlock | Loop(_) => {},\n+            Closure(closure_span) => err_inside_of(\"a\", \"closure\", closure_span),\n+            AsyncClosure(closure_span) => err_inside_of(\"an\", \"`async` block\", closure_span),\n             Normal | AnonConst => {\n-                struct_span_err!(self.sess, span, E0268, \"`{}` outside of loop\", name)\n-                .span_label(span, \"cannot break outside of a loop\")\n+                struct_span_err!(self.sess, span, E0268, \"`{}` outside of a loop\", name)\n+                .span_label(span, format!(\"cannot `{}` outside of a loop\", name))\n                 .emit();\n-            }\n+            },\n         }\n     }\n "}, {"sha": "1d0afe84c25a89913ea844f143836a2e063a4903", "filename": "src/librustc_plugin/deprecated/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,6 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(staged_api)]\n-#![unstable(feature = \"rustc_plugin\", issue = \"29597\")]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n #![rustc_deprecated(since = \"1.38.0\", reason = \"\\\n     import this through `rustc_driver::plugin` instead to make TLS work correctly. \\\n     See https://github.com/rust-lang/rust/issues/62717\")]"}, {"sha": "146058963b69dd67e549c6f01ae81dd587194ef6", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -508,11 +508,7 @@ impl EmbargoVisitor<'tcx> {\n         }\n     }\n \n-    fn update_macro_reachable_mod(\n-        &mut self,\n-        reachable_mod: hir::HirId,\n-        defining_mod: DefId,\n-    ) {\n+    fn update_macro_reachable_mod(&mut self, reachable_mod: hir::HirId, defining_mod: DefId) {\n         let module_def_id = self.tcx.hir().local_def_id(reachable_mod);\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in &module.item_ids {\n@@ -524,19 +520,13 @@ impl EmbargoVisitor<'tcx> {\n                 self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n             }\n         }\n-\n         if let Some(exports) = self.tcx.module_exports(module_def_id) {\n             for export in exports {\n                 if export.vis.is_accessible_from(defining_mod, self.tcx) {\n                     if let Res::Def(def_kind, def_id) = export.res {\n                         let vis = def_id_visibility(self.tcx, def_id).0;\n                         if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n-                            self.update_macro_reachable_def(\n-                                hir_id,\n-                                def_kind,\n-                                vis,\n-                                defining_mod,\n-                            );\n+                            self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n                         }\n                     }\n                 }\n@@ -892,10 +882,14 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             self.tcx.hir().local_def_id(md.hir_id)\n         ).unwrap();\n         let mut module_id = self.tcx.hir().as_local_hir_id(macro_module_def_id).unwrap();\n+        if !self.tcx.hir().is_hir_id_module(module_id) {\n+            // `module_id` doesn't correspond to a `mod`, return early (#63164).\n+            return;\n+        }\n         let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n         let new_level = self.update(md.hir_id, level);\n         if new_level.is_none() {\n-            return\n+            return;\n         }\n \n         loop {"}, {"sha": "9a794ade729c208d92435992a2dd365bff90f1d6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -145,7 +145,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n+    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return Some(ext.clone());\n         }"}, {"sha": "875ae449d94e0f0e9d5f47d208b88cf71b208e64", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1647,10 +1647,14 @@ impl<'a> Resolver<'a> {\n             if module.expansion != parent.expansion &&\n             module.expansion.is_descendant_of(parent.expansion) {\n                 // The macro is a proc macro derive\n-                if module.expansion.looks_like_proc_macro_derive() {\n-                    if parent.expansion.outer_expn_is_descendant_of(span.ctxt()) {\n-                        *poisoned = Some(node_id);\n-                        return module.parent;\n+                if let Some(&def_id) = self.macro_defs.get(&module.expansion) {\n+                    if let Some(ext) = self.get_macro_by_def_id(def_id) {\n+                        if !ext.is_builtin && ext.macro_kind() == MacroKind::Derive {\n+                            if parent.expansion.outer_expn_is_descendant_of(span.ctxt()) {\n+                                *poisoned = Some(node_id);\n+                                return module.parent;\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "719167eb057b21ded168838155838addc2efe1aa", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -140,9 +140,23 @@ impl<'a> base::Resolver for Resolver<'a> {\n         ImportResolver { r: self }.resolve_imports()\n     }\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n-                                -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n-        let parent_scope = self.invocation_parent_scopes[&invoc_id];\n+    fn resolve_macro_invocation(\n+        &mut self, invoc: &Invocation, eager_expansion_root: ExpnId, force: bool\n+    ) -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n+        let invoc_id = invoc.expansion_data.id;\n+        let parent_scope = match self.invocation_parent_scopes.get(&invoc_id) {\n+            Some(parent_scope) => *parent_scope,\n+            None => {\n+                // If there's no entry in the table, then we are resolving an eagerly expanded\n+                // macro, which should inherit its parent scope from its eager expansion root -\n+                // the macro that requested this eager expansion.\n+                let parent_scope = *self.invocation_parent_scopes.get(&eager_expansion_root)\n+                    .expect(\"non-eager expansion without a parent scope\");\n+                self.invocation_parent_scopes.insert(invoc_id, parent_scope);\n+                parent_scope\n+            }\n+        };\n+\n         let (path, kind, derives, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n                 (&attr.path, MacroKind::Attr, self.arenas.alloc_ast_paths(derives), after_derive),\n@@ -161,7 +175,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                         match self.resolve_macro_path(path, Some(MacroKind::Derive),\n                                                       &parent_scope, true, force) {\n                             Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n-                                self.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n+                                self.add_derives(invoc_id, SpecialDerives::COPY);\n                                 return Ok(None);\n                             }\n                             Err(Determinacy::Undetermined) => result = Err(Indeterminate),\n@@ -178,19 +192,15 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n \n         let span = invoc.span();\n-        invoc.expansion_data.id.set_expn_data(\n-            ext.expn_data(parent_scope.expansion, span, fast_print_path(path))\n-        );\n+        invoc_id.set_expn_data(ext.expn_data(parent_scope.expansion, span, fast_print_path(path)));\n \n         if let Res::Def(_, def_id) = res {\n             if after_derive {\n                 self.session.span_err(span, \"macro attributes must be placed before `#[derive]`\");\n             }\n-            self.macro_defs.insert(invoc.expansion_data.id, def_id);\n-            let normal_module_def_id =\n-                self.macro_def_scope(invoc.expansion_data.id).normal_ancestor_id;\n-            self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.id,\n-                                                            normal_module_def_id);\n+            self.macro_defs.insert(invoc_id, def_id);\n+            let normal_module_def_id = self.macro_def_scope(invoc_id).normal_ancestor_id;\n+            self.definitions.add_parent_module_of_macro_def(invoc_id, normal_module_def_id);\n         }\n \n         Ok(Some(ext))"}, {"sha": "9c7ac83e82e9712d10de1bc31b0930a5788cebc7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4197,8 +4197,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// A possible error is to forget to add `.await` when using futures:\n     ///\n     /// ```\n-    /// #![feature(async_await)]\n-    ///\n     /// async fn make_u32() -> u32 {\n     ///     22\n     /// }"}, {"sha": "b52183d4b1b56de2e6aaec4ea4d2ddc93e218560", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4751,7 +4751,6 @@ E0733: r##\"\n Recursion in an `async fn` requires boxing. For example, this will not compile:\n \n ```edition2018,compile_fail,E0733\n-#![feature(async_await)]\n async fn foo(n: usize) {\n     if n > 0 {\n         foo(n - 1).await;\n@@ -4763,12 +4762,11 @@ To achieve async recursion, the `async fn` needs to be desugared\n such that the `Future` is explicit in the return type:\n \n ```edition2018,compile_fail,E0720\n-# #![feature(async_await)]\n use std::future::Future;\n-fn foo_desugered(n: usize) -> impl Future<Output = ()> {\n+fn foo_desugared(n: usize) -> impl Future<Output = ()> {\n     async move {\n         if n > 0 {\n-            foo_desugered(n - 1).await;\n+            foo_desugared(n - 1).await;\n         }\n     }\n }\n@@ -4777,7 +4775,6 @@ fn foo_desugered(n: usize) -> impl Future<Output = ()> {\n Finally, the future is wrapped in a pinned box:\n \n ```edition2018\n-# #![feature(async_await)]\n use std::future::Future;\n use std::pin::Pin;\n fn foo_recursive(n: usize) -> Pin<Box<dyn Future<Output = ()>>> {"}, {"sha": "b64e74468e6e9e1bac9d0917cec62aa9472d0421", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -876,22 +876,22 @@ r#\"var themes = document.getElementById(\"theme-choices\");\n var themePicker = document.getElementById(\"theme-picker\");\n \n function showThemeButtonState() {{\n-    themes.style.display = \"none\";\n-    themePicker.style.borderBottomRightRadius = \"3px\";\n-    themePicker.style.borderBottomLeftRadius = \"3px\";\n-}}\n-\n-function hideThemeButtonState() {{\n     themes.style.display = \"block\";\n     themePicker.style.borderBottomRightRadius = \"0\";\n     themePicker.style.borderBottomLeftRadius = \"0\";\n }}\n \n+function hideThemeButtonState() {{\n+    themes.style.display = \"none\";\n+    themePicker.style.borderBottomRightRadius = \"3px\";\n+    themePicker.style.borderBottomLeftRadius = \"3px\";\n+}}\n+\n function switchThemeButtonState() {{\n     if (themes.style.display === \"block\") {{\n-        showThemeButtonState();\n-    }} else {{\n         hideThemeButtonState();\n+    }} else {{\n+        showThemeButtonState();\n     }}\n }};\n \n@@ -914,7 +914,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n     var but = document.createElement('button');\n     but.innerHTML = item;\n     but.onclick = function(el) {{\n-        switchTheme(currentTheme, mainTheme, item);\n+        switchTheme(currentTheme, mainTheme, item, true);\n     }};\n     but.onblur = handleThemeButtonsBlur;\n     themes.appendChild(but);"}, {"sha": "3d0f00095aca3f05a70248c22694954745d16255", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -105,9 +105,9 @@ if (!DOMTokenList.prototype.remove) {\n                 sidebar.appendChild(div);\n             }\n         }\n-        var themePicker = document.getElementsByClassName(\"theme-picker\");\n-        if (themePicker && themePicker.length > 0) {\n-            themePicker[0].style.display = \"none\";\n+        var themePickers = document.getElementsByClassName(\"theme-picker\");\n+        if (themePickers && themePickers.length > 0) {\n+            themePickers[0].style.display = \"none\";\n         }\n     }\n \n@@ -123,9 +123,9 @@ if (!DOMTokenList.prototype.remove) {\n             filler.remove();\n         }\n         document.getElementsByTagName(\"body\")[0].style.marginTop = \"\";\n-        var themePicker = document.getElementsByClassName(\"theme-picker\");\n-        if (themePicker && themePicker.length > 0) {\n-            themePicker[0].style.display = null;\n+        var themePickers = document.getElementsByClassName(\"theme-picker\");\n+        if (themePickers && themePickers.length > 0) {\n+            themePickers[0].style.display = null;\n         }\n     }\n "}, {"sha": "244b24af43f35b40af552940bd8b3808f91f9085", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -54,6 +54,21 @@\n \t\t  box-sizing: border-box;\n }\n \n+/* This part handles the \"default\" theme being used depending on the system one. */\n+html {\n+\tcontent: \"\";\n+}\n+@media (prefers-color-scheme: light) {\n+\thtml {\n+\t\tcontent: \"light\";\n+\t}\n+}\n+@media (prefers-color-scheme: dark) {\n+\thtml {\n+\t\tcontent: \"dark\";\n+\t}\n+}\n+\n /* General structure and fonts */\n \n body {"}, {"sha": "c55b1e414436c69276c8ab713b0c6507ea9957a2", "filename": "src/librustdoc/html/static/storage.js", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -86,7 +86,7 @@ function getCurrentValue(name) {\n     return null;\n }\n \n-function switchTheme(styleElem, mainStyleElem, newTheme) {\n+function switchTheme(styleElem, mainStyleElem, newTheme, saveTheme) {\n     var fullBasicCss = \"rustdoc\" + resourcesSuffix + \".css\";\n     var fullNewTheme = newTheme + resourcesSuffix + \".css\";\n     var newHref = mainStyleElem.href.replace(fullBasicCss, fullNewTheme);\n@@ -109,8 +109,18 @@ function switchTheme(styleElem, mainStyleElem, newTheme) {\n     });\n     if (found === true) {\n         styleElem.href = newHref;\n-        updateLocalStorage(\"rustdoc-theme\", newTheme);\n+        // If this new value comes from a system setting or from the previously saved theme, no\n+        // need to save it.\n+        if (saveTheme === true) {\n+            updateLocalStorage(\"rustdoc-theme\", newTheme);\n+        }\n     }\n }\n \n-switchTheme(currentTheme, mainTheme, getCurrentValue(\"rustdoc-theme\") || \"light\");\n+function getSystemValue() {\n+    return getComputedStyle(document.documentElement).getPropertyValue('content');\n+}\n+\n+switchTheme(currentTheme, mainTheme,\n+            getCurrentValue(\"rustdoc-theme\") || getSystemValue() || \"light\",\n+            false);"}, {"sha": "e55afc2344f79d41f786b2600e67d234c7d7ae77", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -236,7 +236,7 @@ impl f32 {\n     /// let b = 60.0_f32;\n     ///\n     /// // 100.0\n-    /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n+    /// let abs_difference = (m.mul_add(x, b) - ((m * x) + b)).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n@@ -318,7 +318,7 @@ impl f32 {\n     /// use std::f32;\n     ///\n     /// let x = 2.0_f32;\n-    /// let abs_difference = (x.powi(2) - x*x).abs();\n+    /// let abs_difference = (x.powi(2) - (x * x)).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n@@ -336,7 +336,7 @@ impl f32 {\n     /// use std::f32;\n     ///\n     /// let x = 2.0_f32;\n-    /// let abs_difference = (x.powf(2.0) - x*x).abs();\n+    /// let abs_difference = (x.powf(2.0) - (x * x)).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n@@ -600,7 +600,7 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let x = f32::consts::PI/2.0;\n+    /// let x = f32::consts::FRAC_PI_2;\n     ///\n     /// let abs_difference = (x.sin() - 1.0).abs();\n     ///\n@@ -623,7 +623,7 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let x = 2.0*f32::consts::PI;\n+    /// let x = 2.0 * f32::consts::PI;\n     ///\n     /// let abs_difference = (x.cos() - 1.0).abs();\n     ///\n@@ -646,7 +646,7 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let x = f32::consts::PI / 4.0;\n+    /// let x = f32::consts::FRAC_PI_4;\n     /// let abs_difference = (x.tan() - 1.0).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n@@ -666,10 +666,10 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let f = f32::consts::PI / 2.0;\n+    /// let f = f32::consts::FRAC_PI_2;\n     ///\n     /// // asin(sin(pi/2))\n-    /// let abs_difference = (f.sin().asin() - f32::consts::PI / 2.0).abs();\n+    /// let abs_difference = (f.sin().asin() - f32::consts::FRAC_PI_2).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n@@ -688,10 +688,10 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let f = f32::consts::PI / 4.0;\n+    /// let f = f32::consts::FRAC_PI_4;\n     ///\n     /// // acos(cos(pi/4))\n-    /// let abs_difference = (f.cos().acos() - f32::consts::PI / 4.0).abs();\n+    /// let abs_difference = (f.cos().acos() - f32::consts::FRAC_PI_4).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n@@ -734,7 +734,6 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let pi = f32::consts::PI;\n     /// // Positive angles measured counter-clockwise\n     /// // from positive x axis\n     /// // -pi/4 radians (45 deg clockwise)\n@@ -745,8 +744,8 @@ impl f32 {\n     /// let x2 = -3.0f32;\n     /// let y2 = 3.0f32;\n     ///\n-    /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n-    /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n+    /// let abs_difference_1 = (y1.atan2(x1) - (-f32::consts::FRAC_PI_4)).abs();\n+    /// let abs_difference_2 = (y2.atan2(x2) - (3.0 * f32::consts::FRAC_PI_4)).abs();\n     ///\n     /// assert!(abs_difference_1 <= f32::EPSILON);\n     /// assert!(abs_difference_2 <= f32::EPSILON);\n@@ -765,7 +764,7 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let x = f32::consts::PI/4.0;\n+    /// let x = f32::consts::FRAC_PI_4;\n     /// let f = x.sin_cos();\n     ///\n     /// let abs_difference_0 = (f.0 - x.sin()).abs();\n@@ -834,7 +833,7 @@ impl f32 {\n     ///\n     /// let f = x.sinh();\n     /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n-    /// let g = (e*e - 1.0)/(2.0*e);\n+    /// let g = ((e * e) - 1.0) / (2.0 * e);\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n@@ -856,7 +855,7 @@ impl f32 {\n     /// let x = 1.0f32;\n     /// let f = x.cosh();\n     /// // Solving cosh() at 1 gives this result\n-    /// let g = (e*e + 1.0)/(2.0*e);\n+    /// let g = ((e * e) + 1.0) / (2.0 * e);\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// // Same result\n@@ -880,7 +879,7 @@ impl f32 {\n     ///\n     /// let f = x.tanh();\n     /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n-    /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n+    /// let g = (1.0 - e.powi(-2)) / (1.0 + e.powi(-2));\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);"}, {"sha": "b3571026300911ece9365454d786aa59ec084fd8", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -212,7 +212,7 @@ impl f64 {\n     /// let b = 60.0_f64;\n     ///\n     /// // 100.0\n-    /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n+    /// let abs_difference = (m.mul_add(x, b) - ((m * x) + b)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n@@ -291,7 +291,7 @@ impl f64 {\n     ///\n     /// ```\n     /// let x = 2.0_f64;\n-    /// let abs_difference = (x.powi(2) - x*x).abs();\n+    /// let abs_difference = (x.powi(2) - (x * x)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n@@ -307,7 +307,7 @@ impl f64 {\n     ///\n     /// ```\n     /// let x = 2.0_f64;\n-    /// let abs_difference = (x.powf(2.0) - x*x).abs();\n+    /// let abs_difference = (x.powf(2.0) - (x * x)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n@@ -537,7 +537,7 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let x = f64::consts::PI/2.0;\n+    /// let x = f64::consts::FRAC_PI_2;\n     ///\n     /// let abs_difference = (x.sin() - 1.0).abs();\n     ///\n@@ -556,7 +556,7 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let x = 2.0*f64::consts::PI;\n+    /// let x = 2.0 * f64::consts::PI;\n     ///\n     /// let abs_difference = (x.cos() - 1.0).abs();\n     ///\n@@ -575,7 +575,7 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let x = f64::consts::PI/4.0;\n+    /// let x = f64::consts::FRAC_PI_4;\n     /// let abs_difference = (x.tan() - 1.0).abs();\n     ///\n     /// assert!(abs_difference < 1e-14);\n@@ -595,10 +595,10 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let f = f64::consts::PI / 2.0;\n+    /// let f = f64::consts::FRAC_PI_2;\n     ///\n     /// // asin(sin(pi/2))\n-    /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();\n+    /// let abs_difference = (f.sin().asin() - f64::consts::FRAC_PI_2).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n@@ -617,10 +617,10 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let f = f64::consts::PI / 4.0;\n+    /// let f = f64::consts::FRAC_PI_4;\n     ///\n     /// // acos(cos(pi/4))\n-    /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();\n+    /// let abs_difference = (f.cos().acos() - f64::consts::FRAC_PI_4).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n@@ -661,7 +661,6 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let pi = f64::consts::PI;\n     /// // Positive angles measured counter-clockwise\n     /// // from positive x axis\n     /// // -pi/4 radians (45 deg clockwise)\n@@ -672,8 +671,8 @@ impl f64 {\n     /// let x2 = -3.0_f64;\n     /// let y2 = 3.0_f64;\n     ///\n-    /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n-    /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n+    /// let abs_difference_1 = (y1.atan2(x1) - (-f64::consts::FRAC_PI_4)).abs();\n+    /// let abs_difference_2 = (y2.atan2(x2) - (3.0 * f64::consts::FRAC_PI_4)).abs();\n     ///\n     /// assert!(abs_difference_1 < 1e-10);\n     /// assert!(abs_difference_2 < 1e-10);\n@@ -692,7 +691,7 @@ impl f64 {\n     /// ```\n     /// use std::f64;\n     ///\n-    /// let x = f64::consts::PI/4.0;\n+    /// let x = f64::consts::FRAC_PI_4;\n     /// let f = x.sin_cos();\n     ///\n     /// let abs_difference_0 = (f.0 - x.sin()).abs();\n@@ -759,7 +758,7 @@ impl f64 {\n     ///\n     /// let f = x.sinh();\n     /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n-    /// let g = (e*e - 1.0)/(2.0*e);\n+    /// let g = ((e * e) - 1.0) / (2.0 * e);\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n@@ -781,7 +780,7 @@ impl f64 {\n     /// let x = 1.0_f64;\n     /// let f = x.cosh();\n     /// // Solving cosh() at 1 gives this result\n-    /// let g = (e*e + 1.0)/(2.0*e);\n+    /// let g = ((e * e) + 1.0) / (2.0 * e);\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// // Same result\n@@ -805,7 +804,7 @@ impl f64 {\n     ///\n     /// let f = x.tanh();\n     /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n-    /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n+    /// let g = (1.0 - e.powi(-2)) / (1.0 + e.powi(-2));\n     /// let abs_difference = (f - g).abs();\n     ///\n     /// assert!(abs_difference < 1.0e-10);"}, {"sha": "65f4e0cafe09e321503233608cd1eb8352f00c91", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -572,8 +572,8 @@ impl CString {\n     /// use std::ffi::{CString, CStr};\n     ///\n     /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n-    /// let c_str = c_string.as_c_str();\n-    /// assert_eq!(c_str,\n+    /// let cstr = c_string.as_c_str();\n+    /// assert_eq!(cstr,\n     ///            CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\"));\n     /// ```\n     #[inline]\n@@ -994,17 +994,17 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"hello\");\n-    /// assert!(c_str.is_err());\n+    /// let cstr = CStr::from_bytes_with_nul(b\"hello\");\n+    /// assert!(cstr.is_err());\n     /// ```\n     ///\n     /// Creating a `CStr` with an interior nul byte is an error:\n     ///\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\n-    /// assert!(c_str.is_err());\n+    /// let cstr = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\n+    /// assert!(cstr.is_err());\n     /// ```\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     pub fn from_bytes_with_nul(bytes: &[u8])\n@@ -1111,8 +1111,8 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n-    /// assert_eq!(c_str.to_bytes(), b\"foo\");\n+    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n+    /// assert_eq!(cstr.to_bytes(), b\"foo\");\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1137,8 +1137,8 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n-    /// assert_eq!(c_str.to_bytes_with_nul(), b\"foo\\0\");\n+    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n+    /// assert_eq!(cstr.to_bytes_with_nul(), b\"foo\\0\");\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1164,8 +1164,8 @@ impl CStr {\n     /// ```\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n-    /// assert_eq!(c_str.to_str(), Ok(\"foo\"));\n+    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n+    /// assert_eq!(cstr.to_str(), Ok(\"foo\"));\n     /// ```\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n     pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n@@ -1205,9 +1205,9 @@ impl CStr {\n     /// use std::borrow::Cow;\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"Hello World\\0\")\n+    /// let cstr = CStr::from_bytes_with_nul(b\"Hello World\\0\")\n     ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n-    /// assert_eq!(c_str.to_string_lossy(), Cow::Borrowed(\"Hello World\"));\n+    /// assert_eq!(cstr.to_string_lossy(), Cow::Borrowed(\"Hello World\"));\n     /// ```\n     ///\n     /// Calling `to_string_lossy` on a `CStr` containing invalid UTF-8:\n@@ -1216,10 +1216,10 @@ impl CStr {\n     /// use std::borrow::Cow;\n     /// use std::ffi::CStr;\n     ///\n-    /// let c_str = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\")\n+    /// let cstr = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\")\n     ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n     /// assert_eq!(\n-    ///     c_str.to_string_lossy(),\n+    ///     cstr.to_string_lossy(),\n     ///     Cow::Owned(String::from(\"Hello \ufffdWorld\")) as Cow<'_, str>\n     /// );\n     /// ```"}, {"sha": "6cf062d4f30c0f5a24e70c4507ad0db39ad03856", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -233,7 +233,7 @@ impl OsString {\n     /// ```\n     /// use std::ffi::OsString;\n     ///\n-    /// let mut os_string = OsString::with_capacity(10);\n+    /// let os_string = OsString::with_capacity(10);\n     /// assert!(os_string.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n@@ -616,7 +616,7 @@ impl OsStr {\n     /// Note that this does **not** return the number of bytes in the string in\n     /// OS string form.\n     ///\n-    /// The length returned is that of the underlying storage used by `OsStr`;\n+    /// The length returned is that of the underlying storage used by `OsStr`.\n     /// As discussed in the [`OsString`] introduction, [`OsString`] and `OsStr`\n     /// store strings in a form best suited for cheap inter-conversion between\n     /// native-platform and Rust string forms, which may differ significantly"}, {"sha": "5060f368229bb848821664e8fe48baadc9a227fe", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -353,20 +353,25 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n // Because we're extending the buffer with uninitialized data for trusted\n // readers, we need to make sure to truncate that if any of this panics.\n fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n-    read_to_end_with_reservation(r, buf, 32)\n+    read_to_end_with_reservation(r, buf, |_| 32)\n }\n \n-fn read_to_end_with_reservation<R: Read + ?Sized>(r: &mut R,\n-                                                  buf: &mut Vec<u8>,\n-                                                  reservation_size: usize) -> Result<usize>\n+fn read_to_end_with_reservation<R, F>(\n+    r: &mut R,\n+    buf: &mut Vec<u8>,\n+    mut reservation_size: F,\n+) -> Result<usize>\n+where\n+    R: Read + ?Sized,\n+    F: FnMut(&R) -> usize,\n {\n     let start_len = buf.len();\n     let mut g = Guard { len: buf.len(), buf: buf };\n     let ret;\n     loop {\n         if g.len == g.buf.len() {\n             unsafe {\n-                g.buf.reserve(reservation_size);\n+                g.buf.reserve(reservation_size(r));\n                 let capacity = g.buf.capacity();\n                 g.buf.set_len(capacity);\n                 r.initializer().initialize(&mut g.buf[g.len..]);\n@@ -2253,9 +2258,10 @@ impl<T: Read> Read for Take<T> {\n     }\n \n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n-        let reservation_size = cmp::min(self.limit, 32) as usize;\n-\n-        read_to_end_with_reservation(self, buf, reservation_size)\n+        // Pass in a reservation_size closure that respects the current value\n+        // of limit for each read. If we hit the read limit, this prevents the\n+        // final zero-byte read from allocating again.\n+        read_to_end_with_reservation(self, buf, |self_| cmp::min(self_.limit, 32) as usize)\n     }\n }\n \n@@ -2378,6 +2384,7 @@ impl<B: BufRead> Iterator for Lines<B> {\n \n #[cfg(test)]\n mod tests {\n+    use crate::cmp;\n     use crate::io::prelude::*;\n     use super::{Cursor, SeekFrom, repeat};\n     use crate::io::{self, IoSlice, IoSliceMut};\n@@ -2651,6 +2658,49 @@ mod tests {\n         Ok(())\n     }\n \n+    // A simple example reader which uses the default implementation of\n+    // read_to_end.\n+    struct ExampleSliceReader<'a> {\n+        slice: &'a [u8],\n+    }\n+\n+    impl<'a> Read for ExampleSliceReader<'a> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            let len = cmp::min(self.slice.len(), buf.len());\n+            buf[..len].copy_from_slice(&self.slice[..len]);\n+            self.slice = &self.slice[len..];\n+            Ok(len)\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_to_end_capacity() -> io::Result<()> {\n+        let input = &b\"foo\"[..];\n+\n+        // read_to_end() generally needs to over-allocate, both for efficiency\n+        // and so that it can distinguish EOF. Assert that this is the case\n+        // with this simple ExampleSliceReader struct, which uses the default\n+        // implementation of read_to_end. Even though vec1 is allocated with\n+        // exactly enough capacity for the read, read_to_end will allocate more\n+        // space here.\n+        let mut vec1 = Vec::with_capacity(input.len());\n+        ExampleSliceReader { slice: input }.read_to_end(&mut vec1)?;\n+        assert_eq!(vec1.len(), input.len());\n+        assert!(vec1.capacity() > input.len(), \"allocated more\");\n+\n+        // However, std::io::Take includes an implementation of read_to_end\n+        // that will not allocate when the limit has already been reached. In\n+        // this case, vec2 never grows.\n+        let mut vec2 = Vec::with_capacity(input.len());\n+        ExampleSliceReader { slice: input }\n+            .take(input.len() as u64)\n+            .read_to_end(&mut vec2)?;\n+        assert_eq!(vec2.len(), input.len());\n+        assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n+\n+        Ok(())\n+    }\n+\n     #[test]\n     fn io_slice_mut_advance() {\n         let mut buf1 = [1; 8];"}, {"sha": "85a9dea09ed0d7500433340a5352a1bbc0cd1dcf", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -984,7 +984,6 @@ mod where_keyword { }\n \n // 2018 Edition keywords\n \n-#[unstable(feature = \"async_await\", issue = \"50547\")]\n #[doc(keyword = \"async\")]\n //\n /// Return a [`Future`] instead of blocking the current thread.\n@@ -995,7 +994,6 @@ mod where_keyword { }\n /// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n mod async_keyword { }\n \n-#[unstable(feature = \"async_await\", issue = \"50547\")]\n #[doc(keyword = \"await\")]\n //\n /// Suspend execution until the result of a [`Future`] is ready."}, {"sha": "45816ffd229f0261a591a58c328607ede4d4ca47", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -655,7 +655,7 @@ mod prim_slice { }\n /// [`len`]: #method.len\n ///\n /// Note: This example shows the internals of `&str`. `unsafe` should not be\n-/// used to get a string slice under normal circumstances. Use `as_slice`\n+/// used to get a string slice under normal circumstances. Use `as_str`\n /// instead.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_str { }"}, {"sha": "21fca23a8fe9ea98aa4077dcda4e40aa2e3c59a5", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -20,6 +20,30 @@ cfg_if::cfg_if! {\n     }\n }\n \n+// Android with api less than 21 define sig* functions inline, so it is not\n+// available for dynamic link. Implementing sigemptyset and sigaddset allow us\n+// to support older Android version (independent of libc version).\n+// The following implementations are based on https://git.io/vSkNf\n+cfg_if::cfg_if! {\n+    if #[cfg(target_os = \"android\")] {\n+        pub unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n+            set.write_bytes(0u8, 1);\n+            return 0;\n+        }\n+        #[allow(dead_code)]\n+        pub unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n+            use crate::{slice, mem};\n+\n+            let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n+            let bit = (signum - 1) as usize;\n+            raw[bit / 8] |= 1 << (bit % 8);\n+            return 0;\n+        }\n+    } else {\n+        pub use libc::{sigemptyset, sigaddset};\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n@@ -429,36 +453,6 @@ mod tests {\n         }\n     }\n \n-    // Android with api less than 21 define sig* functions inline, so it is not\n-    // available for dynamic link. Implementing sigemptyset and sigaddset allow us\n-    // to support older Android version (independent of libc version).\n-    // The following implementations are based on https://git.io/vSkNf\n-\n-    #[cfg(not(target_os = \"android\"))]\n-    extern {\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigemptyset14\")]\n-        fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int;\n-\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n-        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n-    }\n-\n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n-        set.write_bytes(0u8, 1);\n-        return 0;\n-    }\n-\n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n-        use crate::slice;\n-\n-        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n-        let bit = (signum - 1) as usize;\n-        raw[bit / 8] |= 1 << (bit % 8);\n-        return 0;\n-    }\n-\n     // See #14232 for more information, but it appears that signal delivery to a\n     // newly spawned process may just be raced in the macOS, so to prevent this\n     // test from being flaky we ignore it on macOS."}, {"sha": "e6a742bd45d0bb0e8041f89f544ac21c898fe871", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -178,23 +178,22 @@ impl Command {\n             cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO))?;\n         }\n \n-        if cfg!(not(any(target_os = \"l4re\"))) {\n+        #[cfg(not(target_os = \"l4re\"))]\n+        {\n             if let Some(u) = self.get_gid() {\n                 cvt(libc::setgid(u as gid_t))?;\n             }\n             if let Some(u) = self.get_uid() {\n+                // When dropping privileges from root, the `setgroups` call\n+                // will remove any extraneous groups. If we don't call this,\n+                // then even though our uid has dropped, we may still have\n+                // groups that enable us to do super-user things. This will\n+                // fail if we aren't root, so don't bother checking the\n+                // return value, this is just done as an optimistic\n+                // privilege dropping function.\n                 //FIXME: Redox kernel does not support setgroups yet\n-                if cfg!(not(target_os = \"redox\")) {\n-                    // When dropping privileges from root, the `setgroups` call\n-                    // will remove any extraneous groups. If we don't call this,\n-                    // then even though our uid has dropped, we may still have\n-                    // groups that enable us to do super-user things. This will\n-                    // fail if we aren't root, so don't bother checking the\n-                    // return value, this is just done as an optimistic\n-                    // privilege dropping function.\n-                    let _ = libc::setgroups(0, ptr::null());\n-                }\n-\n+                #[cfg(not(target_os = \"redox\"))]\n+                let _ = libc::setgroups(0, ptr::null());\n                 cvt(libc::setuid(u as uid_t))?;\n             }\n         }\n@@ -203,7 +202,7 @@ impl Command {\n         }\n \n         // emscripten has no signal support.\n-        #[cfg(not(any(target_os = \"emscripten\")))]\n+        #[cfg(not(target_os = \"emscripten\"))]\n         {\n             use crate::mem::MaybeUninit;\n             // Reset signal handling so the child process starts in a\n@@ -214,14 +213,7 @@ impl Command {\n             // need to clean things up now to avoid confusing the program\n             // we're about to run.\n             let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n-            if cfg!(target_os = \"android\") {\n-                // Implementing sigemptyset allow us to support older Android\n-                // versions. See the comment about Android and sig* functions in\n-                // process_common.rs\n-                set.as_mut_ptr().write_bytes(0u8, 1);\n-            } else {\n-                cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n-            }\n+            cvt(sigemptyset(set.as_mut_ptr()))?;\n             cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(),\n                                          ptr::null_mut()))?;\n             let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n@@ -363,10 +355,10 @@ impl Command {\n             }\n \n             let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n-            cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n+            cvt(sigemptyset(set.as_mut_ptr()))?;\n             cvt(libc::posix_spawnattr_setsigmask(attrs.0.as_mut_ptr(),\n                                                  set.as_ptr()))?;\n-            cvt(libc::sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n+            cvt(sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n             cvt(libc::posix_spawnattr_setsigdefault(attrs.0.as_mut_ptr(),\n                                                     set.as_ptr()))?;\n "}, {"sha": "4007b7ac0ec5f06edb126182ec3240eabbeb6a6b", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -67,8 +67,25 @@ pub fn unsupported_err() -> std_io::Error {\n     )\n }\n \n-pub fn decode_error_kind(_code: i32) -> std_io::ErrorKind {\n-    std_io::ErrorKind::Other\n+pub fn decode_error_kind(errno: i32) -> std_io::ErrorKind {\n+    use std_io::ErrorKind::*;\n+    match errno as libc::c_int {\n+        wasi::ECONNREFUSED => ConnectionRefused,\n+        wasi::ECONNRESET => ConnectionReset,\n+        wasi::EPERM | libc::EACCES => PermissionDenied,\n+        wasi::EPIPE => BrokenPipe,\n+        wasi::ENOTCONN => NotConnected,\n+        wasi::ECONNABORTED => ConnectionAborted,\n+        wasi::EADDRNOTAVAIL => AddrNotAvailable,\n+        wasi::EADDRINUSE => AddrInUse,\n+        wasi::ENOENT => NotFound,\n+        wasi::EINTR => Interrupted,\n+        wasi::EINVAL => InvalidInput,\n+        wasi::ETIMEDOUT => TimedOut,\n+        wasi::EEXIST => AlreadyExists,\n+        wasi::EAGAIN => WouldBlock,\n+        _ => ErrorKind::Other,\n+    }\n }\n \n // This enum is used as the storage for a bunch of types which can't actually"}, {"sha": "53f37bb10bdc0ecfb61bb228826c27c66fea896d", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/926f36400f1667edec92959d8b640dea5084674c/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f36400f1667edec92959d8b640dea5084674c/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=926f36400f1667edec92959d8b640dea5084674c", "patch": "@@ -1,93 +0,0 @@\n-//! This module contains utilities for outputting metadata for diagnostic errors.\n-//!\n-//! Each set of errors is mapped to a metadata file by a name, which is\n-//! currently always a crate name.\n-\n-use std::collections::BTreeMap;\n-use std::env;\n-use std::fs::{remove_file, create_dir_all, File};\n-use std::io::Write;\n-use std::path::PathBuf;\n-use std::error::Error;\n-use rustc_serialize::json::as_json;\n-\n-use syntax_pos::{Span, FileName};\n-\n-use crate::ext::base::ExtCtxt;\n-use crate::diagnostics::plugin::{ErrorMap, ErrorInfo};\n-\n-/// JSON encodable/decodable version of `ErrorInfo`.\n-#[derive(PartialEq, RustcDecodable, RustcEncodable)]\n-pub struct ErrorMetadata {\n-    pub description: Option<String>,\n-    pub use_site: Option<ErrorLocation>\n-}\n-\n-/// Mapping from error codes to metadata that can be (de)serialized.\n-pub type ErrorMetadataMap = BTreeMap<String, ErrorMetadata>;\n-\n-/// JSON encodable error location type with filename and line number.\n-#[derive(PartialEq, RustcDecodable, RustcEncodable)]\n-pub struct ErrorLocation {\n-    pub filename: FileName,\n-    pub line: usize\n-}\n-\n-impl ErrorLocation {\n-    /// Creates an error location from a span.\n-    pub fn from_span(ecx: &ExtCtxt<'_>, sp: Span) -> ErrorLocation {\n-        let loc = ecx.source_map().lookup_char_pos(sp.lo());\n-        ErrorLocation {\n-            filename: loc.file.name.clone(),\n-            line: loc.line\n-        }\n-    }\n-}\n-\n-/// Gets the directory where metadata for a given `prefix` should be stored.\n-///\n-/// See `output_metadata`.\n-pub fn get_metadata_dir(prefix: &str) -> PathBuf {\n-    env::var_os(\"RUSTC_ERROR_METADATA_DST\")\n-        .map(PathBuf::from)\n-        .expect(\"env var `RUSTC_ERROR_METADATA_DST` isn't set\")\n-        .join(prefix)\n-}\n-\n-/// Map `name` to a path in the given directory: <directory>/<name>.json\n-fn get_metadata_path(directory: PathBuf, name: &str) -> PathBuf {\n-    directory.join(format!(\"{}.json\", name))\n-}\n-\n-/// Write metadata for the errors in `err_map` to disk, to a file corresponding to `prefix/name`.\n-///\n-/// For our current purposes the prefix is the target architecture and the name is a crate name.\n-/// If an error occurs steps will be taken to ensure that no file is created.\n-pub fn output_metadata(ecx: &ExtCtxt<'_>, prefix: &str, name: &str, err_map: &ErrorMap)\n-    -> Result<(), Box<dyn Error>>\n-{\n-    // Create the directory to place the file in.\n-    let metadata_dir = get_metadata_dir(prefix);\n-    create_dir_all(&metadata_dir)?;\n-\n-    // Open the metadata file.\n-    let metadata_path = get_metadata_path(metadata_dir, name);\n-    let mut metadata_file = File::create(&metadata_path)?;\n-\n-    // Construct a serializable map.\n-    let json_map = err_map.iter().map(|(k, &ErrorInfo { description, use_site })| {\n-        let key = k.as_str().to_string();\n-        let value = ErrorMetadata {\n-            description: description.map(|n| n.as_str().to_string()),\n-            use_site: use_site.map(|sp| ErrorLocation::from_span(ecx, sp))\n-        };\n-        (key, value)\n-    }).collect::<ErrorMetadataMap>();\n-\n-    // Write the data to the file, deleting it if the write fails.\n-    let result = write!(&mut metadata_file, \"{}\", as_json(&json_map));\n-    if result.is_err() {\n-        remove_file(&metadata_path)?;\n-    }\n-    Ok(result?)\n-}"}, {"sha": "e9a55af52e8780001625dbd79a97fd9632edbe62", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,4 @@\n use std::collections::BTreeMap;\n-use std::env;\n \n use crate::ast::{self, Ident, Name};\n use crate::source_map;\n@@ -12,8 +11,6 @@ use crate::tokenstream::{TokenTree};\n use smallvec::smallvec;\n use syntax_pos::Span;\n \n-use crate::diagnostics::metadata::output_metadata;\n-\n pub use errors::*;\n \n // Maximum width of any line in an extended error description (inclusive).\n@@ -127,36 +124,13 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                           token_tree: &[TokenTree])\n                                           -> Box<dyn MacResult+'cx> {\n     assert_eq!(token_tree.len(), 3);\n-    let (crate_name, ident) = match (&token_tree[0], &token_tree[2]) {\n-        (\n-            // Crate name.\n-            &TokenTree::Token(Token { kind: token::Ident(crate_name, _), .. }),\n-            // DIAGNOSTICS ident.\n-            &TokenTree::Token(Token { kind: token::Ident(name, _), span })\n-        ) => (crate_name, Ident::new(name, span)),\n+    let ident = match &token_tree[2] {\n+        // DIAGNOSTICS ident.\n+        &TokenTree::Token(Token { kind: token::Ident(name, _), span })\n+        => Ident::new(name, span),\n         _ => unreachable!()\n     };\n \n-    // Output error metadata to `tmp/extended-errors/<target arch>/<crate name>.json`\n-    if let Ok(target_triple) = env::var(\"CFG_COMPILER_HOST_TRIPLE\") {\n-        ecx.parse_sess.registered_diagnostics.with_lock(|diagnostics| {\n-            if let Err(e) = output_metadata(ecx,\n-                                            &target_triple,\n-                                            &crate_name.as_str(),\n-                                            diagnostics) {\n-                ecx.span_bug(span, &format!(\n-                    \"error writing metadata for triple `{}` and crate `{}`, error: {}, \\\n-                     cause: {:?}\",\n-                    target_triple, crate_name, e.description(), e.source()\n-                ));\n-            }\n-        });\n-    } else {\n-        ecx.span_err(span, &format!(\n-            \"failed to write metadata for crate `{}` because $CFG_COMPILER_HOST_TRIPLE is not set\",\n-            crate_name));\n-    }\n-\n     // Construct the output expression.\n     let (count, expr) =\n         ecx.parse_sess.registered_diagnostics.with_lock(|diagnostics| {"}, {"sha": "a63c4181d5e039a1d2a996e7327c63526f2768dc", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,7 +3,7 @@ use crate::attr::{HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n-use crate::ext::hygiene::{ExpnId, SyntaxContext, Transparency};\n+use crate::ext::hygiene::{ExpnId, Transparency};\n use crate::mut_visit::{self, MutVisitor};\n use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n@@ -549,8 +549,6 @@ pub struct SyntaxExtension {\n     pub kind: SyntaxExtensionKind,\n     /// Span of the macro definition.\n     pub span: Span,\n-    /// Hygienic properties of spans produced by this macro by default.\n-    pub default_transparency: Transparency,\n     /// Whitelist of unstable features that are treated as stable inside this macro.\n     pub allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     /// Suppresses the `unsafe_code` lint for code produced by this macro.\n@@ -572,22 +570,6 @@ pub struct SyntaxExtension {\n     pub is_derive_copy: bool,\n }\n \n-impl SyntaxExtensionKind {\n-    /// When a syntax extension is constructed,\n-    /// its transparency can often be inferred from its kind.\n-    fn default_transparency(&self) -> Transparency {\n-        match self {\n-            SyntaxExtensionKind::Bang(..) |\n-            SyntaxExtensionKind::Attr(..) |\n-            SyntaxExtensionKind::Derive(..) |\n-            SyntaxExtensionKind::NonMacroAttr { .. } => Transparency::Opaque,\n-            SyntaxExtensionKind::LegacyBang(..) |\n-            SyntaxExtensionKind::LegacyAttr(..) |\n-            SyntaxExtensionKind::LegacyDerive(..) => Transparency::SemiTransparent,\n-        }\n-    }\n-}\n-\n impl SyntaxExtension {\n     /// Returns which kind of macro calls this syntax extension.\n     pub fn macro_kind(&self) -> MacroKind {\n@@ -606,7 +588,6 @@ impl SyntaxExtension {\n     pub fn default(kind: SyntaxExtensionKind, edition: Edition) -> SyntaxExtension {\n         SyntaxExtension {\n             span: DUMMY_SP,\n-            default_transparency: kind.default_transparency(),\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n@@ -646,7 +627,6 @@ impl SyntaxExtension {\n             parent,\n             call_site,\n             def_site: self.span,\n-            default_transparency: self.default_transparency,\n             allow_internal_unstable: self.allow_internal_unstable.clone(),\n             allow_internal_unsafe: self.allow_internal_unsafe,\n             local_inner_macros: self.local_inner_macros,\n@@ -682,8 +662,9 @@ pub trait Resolver {\n \n     fn resolve_imports(&mut self);\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n-                                -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate>;\n+    fn resolve_macro_invocation(\n+        &mut self, invoc: &Invocation, eager_expansion_root: ExpnId, force: bool\n+    ) -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate>;\n \n     fn check_unused_macros(&self);\n \n@@ -759,23 +740,39 @@ impl<'a> ExtCtxt<'a> {\n     pub fn call_site(&self) -> Span {\n         self.current_expansion.id.expn_data().call_site\n     }\n-    pub fn backtrace(&self) -> SyntaxContext {\n-        SyntaxContext::root().apply_mark(self.current_expansion.id)\n+\n+    /// Equivalent of `Span::def_site` from the proc macro API,\n+    /// except that the location is taken from the span passed as an argument.\n+    pub fn with_def_site_ctxt(&self, span: Span) -> Span {\n+        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Opaque)\n+    }\n+\n+    /// Equivalent of `Span::call_site` from the proc macro API,\n+    /// except that the location is taken from the span passed as an argument.\n+    pub fn with_call_site_ctxt(&self, span: Span) -> Span {\n+        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Transparent)\n+    }\n+\n+    /// Span with a context reproducing `macro_rules` hygiene (hygienic locals, unhygienic items).\n+    /// FIXME: This should be eventually replaced either with `with_def_site_ctxt` (preferably),\n+    /// or with `with_call_site_ctxt` (where necessary).\n+    pub fn with_legacy_ctxt(&self, span: Span) -> Span {\n+        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::SemiTransparent)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n     ///\n     /// Stops backtracing at include! boundary.\n     pub fn expansion_cause(&self) -> Option<Span> {\n-        let mut ctxt = self.backtrace();\n+        let mut expn_id = self.current_expansion.id;\n         let mut last_macro = None;\n         loop {\n-            let expn_data = ctxt.outer_expn_data();\n+            let expn_data = expn_id.expn_data();\n             // Stop going up the backtrace once include! is encountered\n             if expn_data.is_root() || expn_data.kind.descr() == sym::include {\n                 break;\n             }\n-            ctxt = expn_data.call_site.ctxt();\n+            expn_id = expn_data.call_site.ctxt().outer_expn();\n             last_macro = Some(expn_data.call_site);\n         }\n         last_macro\n@@ -864,7 +861,7 @@ impl<'a> ExtCtxt<'a> {\n         ast::Ident::from_str(st)\n     }\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n-        let def_site = DUMMY_SP.apply_mark(self.current_expansion.id);\n+        let def_site = self.with_def_site_ctxt(DUMMY_SP);\n         iter::once(Ident::new(kw::DollarCrate, def_site))\n             .chain(components.iter().map(|&s| Ident::with_dummy_span(s)))\n             .collect()\n@@ -908,12 +905,9 @@ impl<'a> ExtCtxt<'a> {\n /// compilation on error, merely emits a non-fatal error and returns `None`.\n pub fn expr_to_spanned_string<'a>(\n     cx: &'a mut ExtCtxt<'_>,\n-    mut expr: P<ast::Expr>,\n+    expr: P<ast::Expr>,\n     err_msg: &str,\n ) -> Result<(Symbol, ast::StrStyle, Span), Option<DiagnosticBuilder<'a>>> {\n-    // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n-    expr.span = expr.span.apply_mark(cx.current_expansion.id);\n-\n     // Perform eager expansion on the expression.\n     // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`.\n     let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();"}, {"sha": "c8c0f4ce36e8edbc8122f4bc7c70242bcf2b4b2b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -305,9 +305,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 continue\n             };\n \n-            let scope =\n+            let eager_expansion_root =\n                 if self.monotonic { invoc.expansion_data.id } else { orig_expansion_data.id };\n-            let ext = match self.cx.resolver.resolve_macro_invocation(&invoc, scope, force) {\n+            let ext = match self.cx.resolver.resolve_macro_invocation(\n+                &invoc, eager_expansion_root, force\n+            ) {\n                 Ok(ext) => ext,\n                 Err(Indeterminate) => {\n                     undetermined_invocations.push(invoc);\n@@ -318,7 +320,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             progress = true;\n             let ExpansionData { depth, id: expn_id, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n-            self.cx.current_expansion.id = scope;\n \n             // FIXME(jseyfried): Refactor out the following logic\n             let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n@@ -564,7 +565,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         return fragment_kind.dummy(span);\n                     }\n                     let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span, path };\n-                    let span = span.with_ctxt(self.cx.backtrace());\n                     let items = expander.expand(self.cx, span, &meta, item);\n                     fragment_kind.expect_from_annotatables(items)\n                 }\n@@ -1388,17 +1388,3 @@ impl<'feat> ExpansionConfig<'feat> {\n         self.features.map_or(false, |features| features.custom_inner_attributes)\n     }\n }\n-\n-// A Marker adds the given mark to the syntax context.\n-#[derive(Debug)]\n-pub struct Marker(pub ExpnId);\n-\n-impl MutVisitor for Marker {\n-    fn visit_span(&mut self, span: &mut Span) {\n-        *span = span.apply_mark(self.0)\n-    }\n-\n-    fn visit_mac(&mut self, mac: &mut ast::Mac) {\n-        noop_visit_mac(mac, self)\n-    }\n-}"}, {"sha": "b1bbd2aaac9714b206ae517b2cf7a23f010cf6dc", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -7,7 +7,6 @@ use crate::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint}\n use errors::{Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n-use syntax_pos::hygiene::{SyntaxContext, Transparency};\n use syntax_pos::symbol::{kw, sym, Symbol};\n \n use proc_macro::{Delimiter, Level, LineColumn, Spacing};\n@@ -363,16 +362,10 @@ impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         // No way to determine def location for a proc macro right now, so use call location.\n         let location = cx.current_expansion.id.expn_data().call_site;\n-        let to_span = |transparency| {\n-            location.with_ctxt(\n-                SyntaxContext::root()\n-                    .apply_mark_with_transparency(cx.current_expansion.id, transparency),\n-            )\n-        };\n         Rustc {\n             sess: cx.parse_sess,\n-            def_site: to_span(Transparency::Opaque),\n-            call_site: to_span(Transparency::Transparent),\n+            def_site: cx.with_def_site_ctxt(location),\n+            call_site: cx.with_call_site_ctxt(location),\n         }\n     }\n "}, {"sha": "37cb8467ff5eefb81c1b1a4162fd5c7215442521", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -19,6 +19,7 @@ use crate::{ast, attr, attr::TransparencyError};\n \n use errors::{DiagnosticBuilder, FatalError};\n use log::debug;\n+use syntax_pos::hygiene::Transparency;\n use syntax_pos::Span;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -128,6 +129,7 @@ impl<'a> ParserAnyMacro<'a> {\n struct MacroRulesMacroExpander {\n     name: ast::Ident,\n     span: Span,\n+    transparency: Transparency,\n     lhses: Vec<quoted::TokenTree>,\n     rhses: Vec<quoted::TokenTree>,\n     valid: bool,\n@@ -143,7 +145,9 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n         if !self.valid {\n             return DummyResult::any(sp);\n         }\n-        generic_extension(cx, sp, self.span, self.name, input, &self.lhses, &self.rhses)\n+        generic_extension(\n+            cx, sp, self.span, self.name, self.transparency, input, &self.lhses, &self.rhses\n+        )\n     }\n }\n \n@@ -158,6 +162,7 @@ fn generic_extension<'cx>(\n     sp: Span,\n     def_span: Span,\n     name: ast::Ident,\n+    transparency: Transparency,\n     arg: TokenStream,\n     lhses: &[quoted::TokenTree],\n     rhses: &[quoted::TokenTree],\n@@ -187,7 +192,7 @@ fn generic_extension<'cx>(\n \n                 let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = transcribe(cx, &named_matches, rhs);\n+                let mut tts = transcribe(cx, &named_matches, rhs, transparency);\n \n                 // Replace all the tokens for the corresponding positions in the macro, to maintain\n                 // proper positions in error reporting, while maintaining the macro_backtrace.\n@@ -415,11 +420,7 @@ pub fn compile(\n     // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n     valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n \n-    let expander: Box<_> =\n-        Box::new(MacroRulesMacroExpander { name: def.ident, span: def.span, lhses, rhses, valid });\n-\n-    let (default_transparency, transparency_error) =\n-        attr::find_transparency(&def.attrs, body.legacy);\n+    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, body.legacy);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) =>\n             sess.span_diagnostic.span_err(\n@@ -432,6 +433,10 @@ pub fn compile(\n         None => {}\n     }\n \n+    let expander: Box<_> = Box::new(MacroRulesMacroExpander {\n+        name: def.ident, span: def.span, transparency, lhses, rhses, valid\n+    });\n+\n     let allow_internal_unstable =\n         attr::find_by_name(&def.attrs, sym::allow_internal_unstable).map(|attr| {\n             attr.meta_item_list()\n@@ -473,7 +478,6 @@ pub fn compile(\n     SyntaxExtension {\n         kind: SyntaxExtensionKind::LegacyBang(expander),\n         span: def.span,\n-        default_transparency,\n         allow_internal_unstable,\n         allow_internal_unsafe: attr::contains_name(&def.attrs, sym::allow_internal_unsafe),\n         local_inner_macros,"}, {"sha": "30d5df13dcedb1d3551c2cb337f3d76a25f36b5d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,18 +1,40 @@\n-use crate::ast::Ident;\n+use crate::ast::{Ident, Mac};\n use crate::ext::base::ExtCtxt;\n-use crate::ext::expand::Marker;\n use crate::ext::tt::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n use crate::ext::tt::quoted;\n-use crate::mut_visit::noop_visit_tt;\n+use crate::mut_visit::{self, MutVisitor};\n use crate::parse::token::{self, NtTT, Token};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n \n use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use syntax_pos::hygiene::{ExpnId, Transparency};\n+use syntax_pos::Span;\n+\n use std::mem;\n \n+// A Marker adds the given mark to the syntax context.\n+struct Marker(ExpnId, Transparency);\n+\n+impl MutVisitor for Marker {\n+    fn visit_span(&mut self, span: &mut Span) {\n+        *span = span.apply_mark(self.0, self.1)\n+    }\n+\n+    fn visit_mac(&mut self, mac: &mut Mac) {\n+        mut_visit::noop_visit_mac(mac, self)\n+    }\n+}\n+\n+impl Marker {\n+    fn visit_delim_span(&mut self, dspan: &mut DelimSpan) {\n+        self.visit_span(&mut dspan.open);\n+        self.visit_span(&mut dspan.close);\n+    }\n+}\n+\n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n     Delimited { forest: Lrc<quoted::Delimited>, idx: usize, span: DelimSpan },\n@@ -68,6 +90,7 @@ pub(super) fn transcribe(\n     cx: &ExtCtxt<'_>,\n     interp: &FxHashMap<Ident, NamedMatch>,\n     src: Vec<quoted::TokenTree>,\n+    transparency: Transparency,\n ) -> TokenStream {\n     // Nothing for us to transcribe...\n     if src.is_empty() {\n@@ -96,6 +119,7 @@ pub(super) fn transcribe(\n     // again, and we are done transcribing.\n     let mut result: Vec<TreeAndJoint> = Vec::new();\n     let mut result_stack = Vec::new();\n+    let mut marker = Marker(cx.current_expansion.id, transparency);\n \n     loop {\n         // Look at the last frame on the stack.\n@@ -207,7 +231,7 @@ pub(super) fn transcribe(\n             }\n \n             // Replace the meta-var with the matched token tree from the invocation.\n-            quoted::TokenTree::MetaVar(mut sp, ident) => {\n+            quoted::TokenTree::MetaVar(mut sp, mut ident) => {\n                 // Find the matched nonterminal from the macro invocation, and use it to replace\n                 // the meta-var.\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n@@ -218,7 +242,7 @@ pub(super) fn transcribe(\n                         if let NtTT(ref tt) = **nt {\n                             result.push(tt.clone().into());\n                         } else {\n-                            sp = sp.apply_mark(cx.current_expansion.id);\n+                            marker.visit_span(&mut sp);\n                             let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n                             result.push(token.into());\n                         }\n@@ -232,9 +256,8 @@ pub(super) fn transcribe(\n                 } else {\n                     // If we aren't able to match the meta-var, we push it back into the result but\n                     // with modified syntax context. (I believe this supports nested macros).\n-                    let ident =\n-                        Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.id));\n-                    sp = sp.apply_mark(cx.current_expansion.id);\n+                    marker.visit_span(&mut sp);\n+                    marker.visit_ident(&mut ident);\n                     result.push(TokenTree::token(token::Dollar, sp).into());\n                     result.push(TokenTree::Token(Token::from_ast_ident(ident)).into());\n                 }\n@@ -246,17 +269,16 @@ pub(super) fn transcribe(\n             // jump back out of the Delimited, pop the result_stack and add the new results back to\n             // the previous results (from outside the Delimited).\n             quoted::TokenTree::Delimited(mut span, delimited) => {\n-                span = span.apply_mark(cx.current_expansion.id);\n+                marker.visit_delim_span(&mut span);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span });\n                 result_stack.push(mem::take(&mut result));\n             }\n \n             // Nothing much to do here. Just push the token to the result, being careful to\n             // preserve syntax context.\n             quoted::TokenTree::Token(token) => {\n-                let mut marker = Marker(cx.current_expansion.id);\n                 let mut tt = TokenTree::Token(token);\n-                noop_visit_tt(&mut tt, &mut marker);\n+                marker.visit_tt(&mut tt);\n                 result.push(tt.into());\n             }\n "}, {"sha": "bbc3ae28225587491bc700aa5633de2eb25736d8", "filename": "src/libsyntax/feature_gate.rs", "status": "removed", "additions": 0, "deletions": 2510, "changes": 2510, "blob_url": "https://github.com/rust-lang/rust/blob/926f36400f1667edec92959d8b640dea5084674c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f36400f1667edec92959d8b640dea5084674c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=926f36400f1667edec92959d8b640dea5084674c"}, {"sha": "32a0b76d5f0d836d257843f07443bf3ef67e54ae", "filename": "src/libsyntax/feature_gate/accepted.rs", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,236 @@\n+//! List of the accepted feature gates.\n+\n+use crate::symbol::{Symbol, sym};\n+\n+macro_rules! declare_features {\n+    ($((accepted, $feature: ident, $ver: expr, $issue: expr, None),)+) => {\n+        /// Those language feature has since been Accepted (it was once Active)\n+        pub const ACCEPTED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, None)),+\n+        ];\n+    }\n+}\n+\n+declare_features! (\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: for testing purposes\n+    // -------------------------------------------------------------------------\n+\n+    // A temporary feature gate used to enable parser extensions needed\n+    // to bootstrap fix for #5723.\n+    (accepted, issue_5723_bootstrap, \"1.0.0\", None, None),\n+    // These are used to test this portion of the compiler,\n+    // they don't actually mean anything.\n+    (accepted, test_accepted_feature, \"1.0.0\", None, None),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: for testing purposes\n+    // -------------------------------------------------------------------------\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: accepted features\n+    // -------------------------------------------------------------------------\n+\n+    // Allows using associated `type`s in `trait`s.\n+    (accepted, associated_types, \"1.0.0\", None, None),\n+    // Allows using assigning a default type to type parameters in algebraic data type definitions.\n+    (accepted, default_type_params, \"1.0.0\", None, None),\n+    // FIXME: explain `globs`.\n+    (accepted, globs, \"1.0.0\", None, None),\n+    // Allows `macro_rules!` items.\n+    (accepted, macro_rules, \"1.0.0\", None, None),\n+    // Allows use of `&foo[a..b]` as a slicing syntax.\n+    (accepted, slicing_syntax, \"1.0.0\", None, None),\n+    // Allows struct variants `Foo { baz: u8, .. }` in enums (RFC 418).\n+    (accepted, struct_variant, \"1.0.0\", None, None),\n+    // Allows indexing tuples.\n+    (accepted, tuple_indexing, \"1.0.0\", None, None),\n+    // Allows the use of `if let` expressions.\n+    (accepted, if_let, \"1.0.0\", None, None),\n+    // Allows the use of `while let` expressions.\n+    (accepted, while_let, \"1.0.0\", None, None),\n+    // Allows using `#![no_std]`.\n+    (accepted, no_std, \"1.6.0\", None, None),\n+    // Allows overloading augmented assignment operations like `a += b`.\n+    (accepted, augmented_assignments, \"1.8.0\", Some(28235), None),\n+    // Allows empty structs and enum variants with braces.\n+    (accepted, braced_empty_structs, \"1.8.0\", Some(29720), None),\n+    // Allows `#[deprecated]` attribute.\n+    (accepted, deprecated, \"1.9.0\", Some(29935), None),\n+    // Allows macros to appear in the type position.\n+    (accepted, type_macros, \"1.13.0\", Some(27245), None),\n+    // Allows use of the postfix `?` operator in expressions.\n+    (accepted, question_mark, \"1.13.0\", Some(31436), None),\n+    // Allows `..` in tuple (struct) patterns.\n+    (accepted, dotdot_in_tuple_patterns, \"1.14.0\", Some(33627), None),\n+    // Allows some increased flexibility in the name resolution rules,\n+    // especially around globs and shadowing (RFC 1560).\n+    (accepted, item_like_imports, \"1.15.0\", Some(35120), None),\n+    // Allows using `Self` and associated types in struct expressions and patterns.\n+    (accepted, more_struct_aliases, \"1.16.0\", Some(37544), None),\n+    // Allows elision of `'static` lifetimes in `static`s and `const`s.\n+    (accepted, static_in_const, \"1.17.0\", Some(35897), None),\n+    // Allows field shorthands (`x` meaning `x: x`) in struct literal expressions.\n+    (accepted, field_init_shorthand, \"1.17.0\", Some(37340), None),\n+    // Allows the definition recursive static items.\n+    (accepted, static_recursion, \"1.17.0\", Some(29719), None),\n+    // Allows `pub(restricted)` visibilities (RFC 1422).\n+    (accepted, pub_restricted, \"1.18.0\", Some(32409), None),\n+    // Allows `#![windows_subsystem]`.\n+    (accepted, windows_subsystem, \"1.18.0\", Some(37499), None),\n+    // Allows `break {expr}` with a value inside `loop`s.\n+    (accepted, loop_break_value, \"1.19.0\", Some(37339), None),\n+    // Allows numeric fields in struct expressions and patterns.\n+    (accepted, relaxed_adts, \"1.19.0\", Some(35626), None),\n+    // Allows coercing non capturing closures to function pointers.\n+    (accepted, closure_to_fn_coercion, \"1.19.0\", Some(39817), None),\n+    // Allows attributes on struct literal fields.\n+    (accepted, struct_field_attributes, \"1.20.0\", Some(38814), None),\n+    // Allows the definition of associated constants in `trait` or `impl` blocks.\n+    (accepted, associated_consts, \"1.20.0\", Some(29646), None),\n+    // Allows usage of the `compile_error!` macro.\n+    (accepted, compile_error, \"1.20.0\", Some(40872), None),\n+    // Allows code like `let x: &'static u32 = &42` to work (RFC 1414).\n+    (accepted, rvalue_static_promotion, \"1.21.0\", Some(38865), None),\n+    // Allows `Drop` types in constants (RFC 1440).\n+    (accepted, drop_types_in_const, \"1.22.0\", Some(33156), None),\n+    // Allows the sysV64 ABI to be specified on all platforms\n+    // instead of just the platforms on which it is the C ABI.\n+    (accepted, abi_sysv64, \"1.24.0\", Some(36167), None),\n+    // Allows `repr(align(16))` struct attribute (RFC 1358).\n+    (accepted, repr_align, \"1.25.0\", Some(33626), None),\n+    // Allows '|' at beginning of match arms (RFC 1925).\n+    (accepted, match_beginning_vert, \"1.25.0\", Some(44101), None),\n+    // Allows nested groups in `use` items (RFC 2128).\n+    (accepted, use_nested_groups, \"1.25.0\", Some(44494), None),\n+    // Allows indexing into constant arrays.\n+    (accepted, const_indexing, \"1.26.0\", Some(29947), None),\n+    // Allows using `a..=b` and `..=b` as inclusive range syntaxes.\n+    (accepted, inclusive_range_syntax, \"1.26.0\", Some(28237), None),\n+    // Allows `..=` in patterns (RFC 1192).\n+    (accepted, dotdoteq_in_patterns, \"1.26.0\", Some(28237), None),\n+    // Allows `fn main()` with return types which implements `Termination` (RFC 1937).\n+    (accepted, termination_trait, \"1.26.0\", Some(43301), None),\n+    // Allows implementing `Clone` for closures where possible (RFC 2132).\n+    (accepted, clone_closures, \"1.26.0\", Some(44490), None),\n+    // Allows implementing `Copy` for closures where possible (RFC 2132).\n+    (accepted, copy_closures, \"1.26.0\", Some(44490), None),\n+    // Allows `impl Trait` in function arguments.\n+    (accepted, universal_impl_trait, \"1.26.0\", Some(34511), None),\n+    // Allows `impl Trait` in function return types.\n+    (accepted, conservative_impl_trait, \"1.26.0\", Some(34511), None),\n+    // Allows using the `u128` and `i128` types.\n+    (accepted, i128_type, \"1.26.0\", Some(35118), None),\n+    // Allows default match binding modes (RFC 2005).\n+    (accepted, match_default_bindings, \"1.26.0\", Some(42640), None),\n+    // Allows `'_` placeholder lifetimes.\n+    (accepted, underscore_lifetimes, \"1.26.0\", Some(44524), None),\n+    // Allows attributes on lifetime/type formal parameters in generics (RFC 1327).\n+    (accepted, generic_param_attrs, \"1.27.0\", Some(48848), None),\n+    // Allows `cfg(target_feature = \"...\")`.\n+    (accepted, cfg_target_feature, \"1.27.0\", Some(29717), None),\n+    // Allows `#[target_feature(...)]`.\n+    (accepted, target_feature, \"1.27.0\", None, None),\n+    // Allows using `dyn Trait` as a syntax for trait objects.\n+    (accepted, dyn_trait, \"1.27.0\", Some(44662), None),\n+    // Allows `#[must_use]` on functions, and introduces must-use operators (RFC 1940).\n+    (accepted, fn_must_use, \"1.27.0\", Some(43302), None),\n+    // Allows use of the `:lifetime` macro fragment specifier.\n+    (accepted, macro_lifetime_matcher, \"1.27.0\", Some(34303), None),\n+    // Allows `#[test]` functions where the return type implements `Termination` (RFC 1937).\n+    (accepted, termination_trait_test, \"1.27.0\", Some(48854), None),\n+    // Allows the `#[global_allocator]` attribute.\n+    (accepted, global_allocator, \"1.28.0\", Some(27389), None),\n+    // Allows `#[repr(transparent)]` attribute on newtype structs.\n+    (accepted, repr_transparent, \"1.28.0\", Some(43036), None),\n+    // Allows procedural macros in `proc-macro` crates.\n+    (accepted, proc_macro, \"1.29.0\", Some(38356), None),\n+    // Allows `foo.rs` as an alternative to `foo/mod.rs`.\n+    (accepted, non_modrs_mods, \"1.30.0\", Some(44660), None),\n+    // Allows use of the `:vis` macro fragment specifier\n+    (accepted, macro_vis_matcher, \"1.30.0\", Some(41022), None),\n+    // Allows importing and reexporting macros with `use`,\n+    // enables macro modularization in general.\n+    (accepted, use_extern_macros, \"1.30.0\", Some(35896), None),\n+    // Allows keywords to be escaped for use as identifiers.\n+    (accepted, raw_identifiers, \"1.30.0\", Some(48589), None),\n+    // Allows attributes scoped to tools.\n+    (accepted, tool_attributes, \"1.30.0\", Some(44690), None),\n+    // Allows multi-segment paths in attributes and derives.\n+    (accepted, proc_macro_path_invoc, \"1.30.0\", Some(38356), None),\n+    // Allows all literals in attribute lists and values of key-value pairs.\n+    (accepted, attr_literals, \"1.30.0\", Some(34981), None),\n+    // Allows inferring outlives requirements (RFC 2093).\n+    (accepted, infer_outlives_requirements, \"1.30.0\", Some(44493), None),\n+    // Allows annotating functions conforming to `fn(&PanicInfo) -> !` with `#[panic_handler]`.\n+    // This defines the behavior of panics.\n+    (accepted, panic_handler, \"1.30.0\", Some(44489), None),\n+    // Allows `#[used]` to preserve symbols (see llvm.used).\n+    (accepted, used, \"1.30.0\", Some(40289), None),\n+    // Allows `crate` in paths.\n+    (accepted, crate_in_paths, \"1.30.0\", Some(45477), None),\n+    // Allows resolving absolute paths as paths from other crates.\n+    (accepted, extern_absolute_paths, \"1.30.0\", Some(44660), None),\n+    // Allows access to crate names passed via `--extern` through prelude.\n+    (accepted, extern_prelude, \"1.30.0\", Some(44660), None),\n+    // Allows parentheses in patterns.\n+    (accepted, pattern_parentheses, \"1.31.0\", Some(51087), None),\n+    // Allows the definition of `const fn` functions.\n+    (accepted, min_const_fn, \"1.31.0\", Some(53555), None),\n+    // Allows scoped lints.\n+    (accepted, tool_lints, \"1.31.0\", Some(44690), None),\n+    // Allows lifetime elision in `impl` headers. For example:\n+    // + `impl<I:Iterator> Iterator for &mut Iterator`\n+    // + `impl Debug for Foo<'_>`\n+    (accepted, impl_header_lifetime_elision, \"1.31.0\", Some(15872), None),\n+    // Allows `extern crate foo as bar;`. This puts `bar` into extern prelude.\n+    (accepted, extern_crate_item_prelude, \"1.31.0\", Some(55599), None),\n+    // Allows use of the `:literal` macro fragment specifier (RFC 1576).\n+    (accepted, macro_literal_matcher, \"1.32.0\", Some(35625), None),\n+    // Allows use of `?` as the Kleene \"at most one\" operator in macros.\n+    (accepted, macro_at_most_once_rep, \"1.32.0\", Some(48075), None),\n+    // Allows `Self` struct constructor (RFC 2302).\n+    (accepted, self_struct_ctor, \"1.32.0\", Some(51994), None),\n+    // Allows `Self` in type definitions (RFC 2300).\n+    (accepted, self_in_typedefs, \"1.32.0\", Some(49303), None),\n+    // Allows `use x::y;` to search `x` in the current scope.\n+    (accepted, uniform_paths, \"1.32.0\", Some(53130), None),\n+    // Allows integer match exhaustiveness checking (RFC 2591).\n+    (accepted, exhaustive_integer_patterns, \"1.33.0\", Some(50907), None),\n+    // Allows `use path as _;` and `extern crate c as _;`.\n+    (accepted, underscore_imports, \"1.33.0\", Some(48216), None),\n+    // Allows `#[repr(packed(N))]` attribute on structs.\n+    (accepted, repr_packed, \"1.33.0\", Some(33158), None),\n+    // Allows irrefutable patterns in `if let` and `while let` statements (RFC 2086).\n+    (accepted, irrefutable_let_patterns, \"1.33.0\", Some(44495), None),\n+    // Allows calling `const unsafe fn` inside `unsafe` blocks in `const fn` functions.\n+    (accepted, min_const_unsafe_fn, \"1.33.0\", Some(55607), None),\n+    // Allows let bindings, assignments and destructuring in `const` functions and constants.\n+    // As long as control flow is not implemented in const eval, `&&` and `||` may not be used\n+    // at the same time as let bindings.\n+    (accepted, const_let, \"1.33.0\", Some(48821), None),\n+    // Allows `#[cfg_attr(predicate, multiple, attributes, here)]`.\n+    (accepted, cfg_attr_multi, \"1.33.0\", Some(54881), None),\n+    // Allows top level or-patterns (`p | q`) in `if let` and `while let`.\n+    (accepted, if_while_or_patterns, \"1.33.0\", Some(48215), None),\n+    // Allows `cfg(target_vendor = \"...\")`.\n+    (accepted, cfg_target_vendor, \"1.33.0\", Some(29718), None),\n+    // Allows `extern crate self as foo;`.\n+    // This puts local crate root into extern prelude under name `foo`.\n+    (accepted, extern_crate_self, \"1.34.0\", Some(56409), None),\n+    // Allows arbitrary delimited token streams in non-macro attributes.\n+    (accepted, unrestricted_attribute_tokens, \"1.34.0\", Some(55208), None),\n+    // Allows paths to enum variants on type aliases including `Self`.\n+    (accepted, type_alias_enum_variants, \"1.37.0\", Some(49683), None),\n+    // Allows using `#[repr(align(X))]` on enums with equivalent semantics\n+    // to wrapping an enum in a wrapper struct with `#[repr(align(X))]`.\n+    (accepted, repr_align_enum, \"1.37.0\", Some(57996), None),\n+    // Allows `const _: TYPE = VALUE`.\n+    (accepted, underscore_const_names, \"1.37.0\", Some(54912), None),\n+    // Allows free and inherent `async fn`s, `async` blocks, and `<expr>.await` expressions.\n+    (accepted, async_await, \"1.39.0\", Some(50547), None),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: accepted features\n+    // -------------------------------------------------------------------------\n+);"}, {"sha": "0bff4ed24a4ce44988191865fb988d42f5d4af7e", "filename": "src/libsyntax/feature_gate/active.rs", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Factive.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,522 @@\n+//! List of the active feature gates.\n+\n+use crate::edition::Edition;\n+use crate::symbol::{Symbol, sym};\n+use syntax_pos::Span;\n+\n+macro_rules! set {\n+    ($field: ident) => {{\n+        fn f(features: &mut Features, _: Span) {\n+            features.$field = true;\n+        }\n+        f as fn(&mut Features, Span)\n+    }}\n+}\n+\n+macro_rules! declare_features {\n+    ($((active, $feature: ident, $ver: expr, $issue: expr, $edition: expr),)+) => {\n+        /// Represents active features that are currently being implemented or\n+        /// currently being considered for addition/removal.\n+        pub const ACTIVE_FEATURES:\n+            &[(Symbol, &str, Option<u32>, Option<Edition>, fn(&mut Features, Span))] =\n+            &[$((sym::$feature, $ver, $issue, $edition, set!($feature))),+];\n+\n+        /// A set of features to be used by later passes.\n+        #[derive(Clone)]\n+        pub struct Features {\n+            /// `#![feature]` attrs for language features, for error reporting\n+            pub declared_lang_features: Vec<(Symbol, Span, Option<Symbol>)>,\n+            /// `#![feature]` attrs for non-language (library) features\n+            pub declared_lib_features: Vec<(Symbol, Span)>,\n+            $(pub $feature: bool),+\n+        }\n+\n+        impl Features {\n+            pub fn new() -> Features {\n+                Features {\n+                    declared_lang_features: Vec::new(),\n+                    declared_lib_features: Vec::new(),\n+                    $($feature: false),+\n+                }\n+            }\n+\n+            pub fn walk_feature_fields<F>(&self, mut f: F)\n+                where F: FnMut(&str, bool)\n+            {\n+                $(f(stringify!($feature), self.$feature);)+\n+            }\n+        }\n+    };\n+}\n+\n+// If you change this, please modify `src/doc/unstable-book` as well.\n+//\n+// Don't ever remove anything from this list; move them to `removed.rs`.\n+//\n+// The version numbers here correspond to the version in which the current status\n+// was set. This is most important for knowing when a particular feature became\n+// stable (active).\n+//\n+// Note that the features are grouped into internal/user-facing and then\n+// sorted by version inside those groups. This is inforced with tidy.\n+//\n+// N.B., `tools/tidy/src/features.rs` parses this information directly out of the\n+// source, so take care when modifying it.\n+\n+declare_features! (\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: internal feature gates\n+    // -------------------------------------------------------------------------\n+\n+    // no-tracking-issue-start\n+\n+    // Allows using compiler's own crates.\n+    (active, rustc_private, \"1.0.0\", Some(27812), None),\n+\n+    // Allows using the `rust-intrinsic`'s \"ABI\".\n+    (active, intrinsics, \"1.0.0\", None, None),\n+\n+    // Allows using `#[lang = \"..\"]` attribute for linking items to special compiler logic.\n+    (active, lang_items, \"1.0.0\", None, None),\n+\n+    // Allows using the `#[stable]` and `#[unstable]` attributes.\n+    (active, staged_api, \"1.0.0\", None, None),\n+\n+    // Allows using `#[allow_internal_unstable]`. This is an\n+    // attribute on `macro_rules!` and can't use the attribute handling\n+    // below (it has to be checked before expansion possibly makes\n+    // macros disappear).\n+    (active, allow_internal_unstable, \"1.0.0\", None, None),\n+\n+    // Allows using `#[allow_internal_unsafe]`. This is an\n+    // attribute on `macro_rules!` and can't use the attribute handling\n+    // below (it has to be checked before expansion possibly makes\n+    // macros disappear).\n+    (active, allow_internal_unsafe, \"1.0.0\", None, None),\n+\n+    // Allows using the macros:\n+    // + `__diagnostic_used`\n+    // + `__register_diagnostic`\n+    // +`__build_diagnostic_array`\n+    (active, rustc_diagnostic_macros, \"1.0.0\", None, None),\n+\n+    // Allows using `#[rustc_const_unstable(feature = \"foo\", ..)]` which\n+    // lets a function to be `const` when opted into with `#![feature(foo)]`.\n+    (active, rustc_const_unstable, \"1.0.0\", None, None),\n+\n+    // no-tracking-issue-end\n+\n+    // Allows using `#[link_name=\"llvm.*\"]`.\n+    (active, link_llvm_intrinsics, \"1.0.0\", Some(29602), None),\n+\n+    // Allows using `rustc_*` attributes (RFC 572).\n+    (active, rustc_attrs, \"1.0.0\", Some(29642), None),\n+\n+    // Allows using `#[on_unimplemented(..)]` on traits.\n+    (active, on_unimplemented, \"1.0.0\", Some(29628), None),\n+\n+    // Allows using the `box $expr` syntax.\n+    (active, box_syntax, \"1.0.0\", Some(49733), None),\n+\n+    // Allows using `#[main]` to replace the entrypoint `#[lang = \"start\"]` calls.\n+    (active, main, \"1.0.0\", Some(29634), None),\n+\n+    // Allows using `#[start]` on a function indicating that it is the program entrypoint.\n+    (active, start, \"1.0.0\", Some(29633), None),\n+\n+    // Allows using the `#[fundamental]` attribute.\n+    (active, fundamental, \"1.0.0\", Some(29635), None),\n+\n+    // Allows using the `rust-call` ABI.\n+    (active, unboxed_closures, \"1.0.0\", Some(29625), None),\n+\n+    // Allows using the `#[linkage = \"..\"]` attribute.\n+    (active, linkage, \"1.0.0\", Some(29603), None),\n+\n+    // Allows features specific to OIBIT (auto traits).\n+    (active, optin_builtin_traits, \"1.0.0\", Some(13231), None),\n+\n+    // Allows using `box` in patterns (RFC 469).\n+    (active, box_patterns, \"1.0.0\", Some(29641), None),\n+\n+    // no-tracking-issue-start\n+\n+    // Allows using `#[prelude_import]` on glob `use` items.\n+    (active, prelude_import, \"1.2.0\", None, None),\n+\n+    // no-tracking-issue-end\n+\n+    // no-tracking-issue-start\n+\n+    // Allows using `#[omit_gdb_pretty_printer_section]`.\n+    (active, omit_gdb_pretty_printer_section, \"1.5.0\", None, None),\n+\n+    // Allows using the `vectorcall` ABI.\n+    (active, abi_vectorcall, \"1.7.0\", None, None),\n+\n+    // no-tracking-issue-end\n+\n+    // Allows using `#[structural_match]` which indicates that a type is structurally matchable.\n+    (active, structural_match, \"1.8.0\", Some(31434), None),\n+\n+    // Allows using the `may_dangle` attribute (RFC 1327).\n+    (active, dropck_eyepatch, \"1.10.0\", Some(34761), None),\n+\n+    // Allows using the `#![panic_runtime]` attribute.\n+    (active, panic_runtime, \"1.10.0\", Some(32837), None),\n+\n+    // Allows declaring with `#![needs_panic_runtime]` that a panic runtime is needed.\n+    (active, needs_panic_runtime, \"1.10.0\", Some(32837), None),\n+\n+    // no-tracking-issue-start\n+\n+    // Allows identifying the `compiler_builtins` crate.\n+    (active, compiler_builtins, \"1.13.0\", None, None),\n+\n+    // Allows using the `unadjusted` ABI; perma-unstable.\n+    (active, abi_unadjusted, \"1.16.0\", None, None),\n+\n+    // Allows identifying crates that contain sanitizer runtimes.\n+    (active, sanitizer_runtime, \"1.17.0\", None, None),\n+\n+    // Used to identify crates that contain the profiler runtime.\n+    (active, profiler_runtime, \"1.18.0\", None, None),\n+\n+    // Allows using the `thiscall` ABI.\n+    (active, abi_thiscall, \"1.19.0\", None, None),\n+\n+    // Allows using `#![needs_allocator]`, an implementation detail of `#[global_allocator]`.\n+    (active, allocator_internals, \"1.20.0\", None, None),\n+\n+    // no-tracking-issue-end\n+\n+    // Added for testing E0705; perma-unstable.\n+    (active, test_2018_feature, \"1.31.0\", Some(0), Some(Edition::Edition2018)),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: internal feature gates\n+    // -------------------------------------------------------------------------\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: actual feature gates (target features)\n+    // -------------------------------------------------------------------------\n+\n+    // FIXME: Document these and merge with the list below.\n+\n+    // Unstable `#[target_feature]` directives.\n+    (active, arm_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, aarch64_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, hexagon_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, powerpc_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, mips_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, avx512_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, mmx_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, sse4a_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, tbm_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, wasm_target_feature, \"1.30.0\", Some(44839), None),\n+    (active, adx_target_feature, \"1.32.0\", Some(44839), None),\n+    (active, cmpxchg16b_target_feature, \"1.32.0\", Some(44839), None),\n+    (active, movbe_target_feature, \"1.34.0\", Some(44839), None),\n+    (active, rtm_target_feature, \"1.35.0\", Some(44839), None),\n+    (active, f16c_target_feature, \"1.36.0\", Some(44839), None),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: actual feature gates (target features)\n+    // -------------------------------------------------------------------------\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: actual feature gates\n+    // -------------------------------------------------------------------------\n+\n+    // Allows using the `#[link_args]` attribute.\n+    (active, link_args, \"1.0.0\", Some(29596), None),\n+\n+    // Allows defining identifiers beyond ASCII.\n+    (active, non_ascii_idents, \"1.0.0\", Some(55467), None),\n+\n+    // Allows using `#[plugin_registrar]` on functions.\n+    (active, plugin_registrar, \"1.0.0\", Some(29597), None),\n+\n+    // Allows using `#![plugin(myplugin)]`.\n+    (active, plugin, \"1.0.0\", Some(29597), None),\n+\n+    // Allows using `#[thread_local]` on `static` items.\n+    (active, thread_local, \"1.0.0\", Some(29594), None),\n+\n+    // Allows the use of SIMD types in functions declared in `extern` blocks.\n+    (active, simd_ffi, \"1.0.0\", Some(27731), None),\n+\n+    // Allows using custom attributes (RFC 572).\n+    (active, custom_attribute, \"1.0.0\", Some(29642), None),\n+\n+    // Allows using non lexical lifetimes (RFC 2094).\n+    (active, nll, \"1.0.0\", Some(43234), None),\n+\n+    // Allows using slice patterns.\n+    (active, slice_patterns, \"1.0.0\", Some(62254), None),\n+\n+    // Allows the definition of `const` functions with some advanced features.\n+    (active, const_fn, \"1.2.0\", Some(57563), None),\n+\n+    // Allows associated type defaults.\n+    (active, associated_type_defaults, \"1.2.0\", Some(29661), None),\n+\n+    // Allows `#![no_core]`.\n+    (active, no_core, \"1.3.0\", Some(29639), None),\n+\n+    // Allows default type parameters to influence type inference.\n+    (active, default_type_parameter_fallback, \"1.3.0\", Some(27336), None),\n+\n+    // Allows `repr(simd)` and importing the various simd intrinsics.\n+    (active, repr_simd, \"1.4.0\", Some(27731), None),\n+\n+    // Allows `extern \"platform-intrinsic\" { ... }`.\n+    (active, platform_intrinsics, \"1.4.0\", Some(27731), None),\n+\n+    // Allows `#[unwind(..)]`.\n+    //\n+    // Permits specifying whether a function should permit unwinding or abort on unwind.\n+    (active, unwind_attributes, \"1.4.0\", Some(58760), None),\n+\n+    // Allows `#[no_debug]`.\n+    (active, no_debug, \"1.5.0\", Some(29721), None),\n+\n+    // Allows attributes on expressions and non-item statements.\n+    (active, stmt_expr_attributes, \"1.6.0\", Some(15701), None),\n+\n+    // Allows the use of type ascription in expressions.\n+    (active, type_ascription, \"1.6.0\", Some(23416), None),\n+\n+    // Allows `cfg(target_thread_local)`.\n+    (active, cfg_target_thread_local, \"1.7.0\", Some(29594), None),\n+\n+    // Allows specialization of implementations (RFC 1210).\n+    (active, specialization, \"1.7.0\", Some(31844), None),\n+\n+    // Allows using `#[naked]` on functions.\n+    (active, naked_functions, \"1.9.0\", Some(32408), None),\n+\n+    // Allows `cfg(target_has_atomic = \"...\")`.\n+    (active, cfg_target_has_atomic, \"1.9.0\", Some(32976), None),\n+\n+    // Allows `X..Y` patterns.\n+    (active, exclusive_range_pattern, \"1.11.0\", Some(37854), None),\n+\n+    // Allows the `!` type. Does not imply 'exhaustive_patterns' (below) any more.\n+    (active, never_type, \"1.13.0\", Some(35121), None),\n+\n+    // Allows exhaustive pattern matching on types that contain uninhabited types.\n+    (active, exhaustive_patterns, \"1.13.0\", Some(51085), None),\n+\n+    // Allows untagged unions `union U { ... }`.\n+    (active, untagged_unions, \"1.13.0\", Some(32836), None),\n+\n+    // Allows `#[link(..., cfg(..))]`.\n+    (active, link_cfg, \"1.14.0\", Some(37406), None),\n+\n+    // Allows `extern \"ptx-*\" fn()`.\n+    (active, abi_ptx, \"1.15.0\", Some(38788), None),\n+\n+    // Allows the `#[repr(i128)]` attribute for enums.\n+    (active, repr128, \"1.16.0\", Some(35118), None),\n+\n+    // Allows `#[link(kind=\"static-nobundle\"...)]`.\n+    (active, static_nobundle, \"1.16.0\", Some(37403), None),\n+\n+    // Allows `extern \"msp430-interrupt\" fn()`.\n+    (active, abi_msp430_interrupt, \"1.16.0\", Some(38487), None),\n+\n+    // Allows declarative macros 2.0 (`macro`).\n+    (active, decl_macro, \"1.17.0\", Some(39412), None),\n+\n+    // Allows `extern \"x86-interrupt\" fn()`.\n+    (active, abi_x86_interrupt, \"1.17.0\", Some(40180), None),\n+\n+    // Allows overlapping impls of marker traits.\n+    (active, overlapping_marker_traits, \"1.18.0\", Some(29864), None),\n+\n+    // Allows a test to fail without failing the whole suite.\n+    (active, allow_fail, \"1.19.0\", Some(46488), None),\n+\n+    // Allows unsized tuple coercion.\n+    (active, unsized_tuple_coercion, \"1.20.0\", Some(42877), None),\n+\n+    // Allows defining generators.\n+    (active, generators, \"1.21.0\", Some(43122), None),\n+\n+    // Allows `#[doc(cfg(...))]`.\n+    (active, doc_cfg, \"1.21.0\", Some(43781), None),\n+\n+    // Allows `#[doc(masked)]`.\n+    (active, doc_masked, \"1.21.0\", Some(44027), None),\n+\n+    // Allows `#[doc(spotlight)]`.\n+    (active, doc_spotlight, \"1.22.0\", Some(45040), None),\n+\n+    // Allows `#[doc(include = \"some-file\")]`.\n+    (active, external_doc, \"1.22.0\", Some(44732), None),\n+\n+    // Allows future-proofing enums/structs with the `#[non_exhaustive]` attribute (RFC 2008).\n+    (active, non_exhaustive, \"1.22.0\", Some(44109), None),\n+\n+    // Allows using `crate` as visibility modifier, synonymous with `pub(crate)`.\n+    (active, crate_visibility_modifier, \"1.23.0\", Some(53120), None),\n+\n+    // Allows defining `extern type`s.\n+    (active, extern_types, \"1.23.0\", Some(43467), None),\n+\n+    // Allows trait methods with arbitrary self types.\n+    (active, arbitrary_self_types, \"1.23.0\", Some(44874), None),\n+\n+    // Allows in-band quantification of lifetime bindings (e.g., `fn foo(x: &'a u8) -> &'a u8`).\n+    (active, in_band_lifetimes, \"1.23.0\", Some(44524), None),\n+\n+    // Allows associated types to be generic, e.g., `type Foo<T>;` (RFC 1598).\n+    (active, generic_associated_types, \"1.23.0\", Some(44265), None),\n+\n+    // Allows defining `trait X = A + B;` alias items.\n+    (active, trait_alias, \"1.24.0\", Some(41517), None),\n+\n+    // Allows infering `'static` outlives requirements (RFC 2093).\n+    (active, infer_static_outlives_requirements, \"1.26.0\", Some(54185), None),\n+\n+    // Allows macro invocations in `extern {}` blocks.\n+    (active, macros_in_extern, \"1.27.0\", Some(49476), None),\n+\n+    // Allows accessing fields of unions inside `const` functions.\n+    (active, const_fn_union, \"1.27.0\", Some(51909), None),\n+\n+    // Allows casting raw pointers to `usize` during const eval.\n+    (active, const_raw_ptr_to_usize_cast, \"1.27.0\", Some(51910), None),\n+\n+    // Allows dereferencing raw pointers during const eval.\n+    (active, const_raw_ptr_deref, \"1.27.0\", Some(51911), None),\n+\n+    // Allows comparing raw pointers during const eval.\n+    (active, const_compare_raw_pointers, \"1.27.0\", Some(53020), None),\n+\n+    // Allows `#[doc(alias = \"...\")]`.\n+    (active, doc_alias, \"1.27.0\", Some(50146), None),\n+\n+    // Allows inconsistent bounds in where clauses.\n+    (active, trivial_bounds, \"1.28.0\", Some(48214), None),\n+\n+    // Allows `'a: { break 'a; }`.\n+    (active, label_break_value, \"1.28.0\", Some(48594), None),\n+\n+    // Allows using `#[doc(keyword = \"...\")]`.\n+    (active, doc_keyword, \"1.28.0\", Some(51315), None),\n+\n+    // Allows reinterpretation of the bits of a value of one type as another type during const eval.\n+    (active, const_transmute, \"1.29.0\", Some(53605), None),\n+\n+    // Allows using `try {...}` expressions.\n+    (active, try_blocks, \"1.29.0\", Some(31436), None),\n+\n+    // Allows defining an `#[alloc_error_handler]`.\n+    (active, alloc_error_handler, \"1.29.0\", Some(51540), None),\n+\n+    // Allows using the `amdgpu-kernel` ABI.\n+    (active, abi_amdgpu_kernel, \"1.29.0\", Some(51575), None),\n+\n+    // Allows panicking during const eval (producing compile-time errors).\n+    (active, const_panic, \"1.30.0\", Some(51999), None),\n+\n+    // Allows `#[marker]` on certain traits allowing overlapping implementations.\n+    (active, marker_trait_attr, \"1.30.0\", Some(29864), None),\n+\n+    // Allows macro invocations on modules expressions and statements and\n+    // procedural macros to expand to non-items.\n+    (active, proc_macro_hygiene, \"1.30.0\", Some(54727), None),\n+\n+    // Allows unsized rvalues at arguments and parameters.\n+    (active, unsized_locals, \"1.30.0\", Some(48055), None),\n+\n+    // Allows custom test frameworks with `#![test_runner]` and `#[test_case]`.\n+    (active, custom_test_frameworks, \"1.30.0\", Some(50297), None),\n+\n+    // Allows non-builtin attributes in inner attribute position.\n+    (active, custom_inner_attributes, \"1.30.0\", Some(54726), None),\n+\n+    // Allows mixing bind-by-move in patterns and references to those identifiers in guards.\n+    (active, bind_by_move_pattern_guards, \"1.30.0\", Some(15287), None),\n+\n+    // Allows `impl Trait` in bindings (`let`, `const`, `static`).\n+    (active, impl_trait_in_bindings, \"1.30.0\", Some(63065), None),\n+\n+    // Allows using `reason` in lint attributes and the `#[expect(lint)]` lint check.\n+    (active, lint_reasons, \"1.31.0\", Some(54503), None),\n+\n+    // Allows exhaustive integer pattern matching on `usize` and `isize`.\n+    (active, precise_pointer_size_matching, \"1.32.0\", Some(56354), None),\n+\n+    // Allows relaxing the coherence rules such that\n+    // `impl<T> ForeignTrait<LocalType> for ForeignType<T> is permitted.\n+    (active, re_rebalance_coherence, \"1.32.0\", Some(55437), None),\n+\n+    // Allows using `#[ffi_returns_twice]` on foreign functions.\n+    (active, ffi_returns_twice, \"1.34.0\", Some(58314), None),\n+\n+    // Allows const generic types (e.g. `struct Foo<const N: usize>(...);`).\n+    (active, const_generics, \"1.34.0\", Some(44580), None),\n+\n+    // Allows using `#[optimize(X)]`.\n+    (active, optimize_attribute, \"1.34.0\", Some(54882), None),\n+\n+    // Allows using C-variadics.\n+    (active, c_variadic, \"1.34.0\", Some(44930), None),\n+\n+    // Allows the user of associated type bounds.\n+    (active, associated_type_bounds, \"1.34.0\", Some(52662), None),\n+\n+    // Attributes on formal function params.\n+    (active, param_attrs, \"1.36.0\", Some(60406), None),\n+\n+    // Allows calling constructor functions in `const fn`.\n+    (active, const_constructor, \"1.37.0\", Some(61456), None),\n+\n+    // Allows `if/while p && let q = r && ...` chains.\n+    (active, let_chains, \"1.37.0\", Some(53667), None),\n+\n+    // Allows #[repr(transparent)] on enums (RFC 2645).\n+    (active, transparent_enums, \"1.37.0\", Some(60405), None),\n+\n+    // Allows #[repr(transparent)] on unions (RFC 2645).\n+    (active, transparent_unions, \"1.37.0\", Some(60405), None),\n+\n+    // Allows explicit discriminants on non-unit enum variants.\n+    (active, arbitrary_enum_discriminant, \"1.37.0\", Some(60553), None),\n+\n+    // Allows `impl Trait` with multiple unrelated lifetimes.\n+    (active, member_constraints, \"1.37.0\", Some(61977), None),\n+\n+    // Allows `async || body` closures.\n+    (active, async_closure, \"1.37.0\", Some(62290), None),\n+\n+    // Allows the use of `#[cfg(doctest)]`, set when rustdoc is collecting doctests\n+    (active, cfg_doctest, \"1.37.0\", Some(62210), None),\n+\n+    // Allows `[x; N]` where `x` is a constant (RFC 2203).\n+    (active, const_in_array_repeat_expressions, \"1.37.0\", Some(49147), None),\n+\n+    // Allows `impl Trait` to be used inside type aliases (RFC 2515).\n+    (active, type_alias_impl_trait, \"1.38.0\", Some(63063), None),\n+\n+    // Allows the use of or-patterns, e.g. `0 | 1`.\n+    (active, or_patterns, \"1.38.0\", Some(54883), None),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: actual feature gates\n+    // -------------------------------------------------------------------------\n+);\n+\n+/// Some features are known to be incomplete and using them is likely to have\n+/// unanticipated results, such as compiler crashes. We warn the user about these\n+/// to alert them.\n+pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n+    sym::impl_trait_in_bindings,\n+    sym::generic_associated_types,\n+    sym::const_generics,\n+    sym::or_patterns,\n+    sym::let_chains,\n+];"}, {"sha": "b934f2e7f64efef80dc9b46d4faedaa4a69f30b1", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "added", "additions": 562, "deletions": 0, "changes": 562, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,562 @@\n+//! Built-in attributes and `cfg` flag gating.\n+\n+use AttributeType::*;\n+use AttributeGate::*;\n+\n+use super::check::{emit_feature_err, GateIssue};\n+use super::check::{Stability, EXPLAIN_ALLOW_INTERNAL_UNSAFE, EXPLAIN_ALLOW_INTERNAL_UNSTABLE};\n+use super::active::Features;\n+\n+use crate::ast;\n+use crate::attr::AttributeTemplate;\n+use crate::symbol::{Symbol, sym};\n+use crate::parse::ParseSess;\n+\n+use syntax_pos::Span;\n+use rustc_data_structures::fx::FxHashMap;\n+use lazy_static::lazy_static;\n+\n+type GateFn = fn(&Features) -> bool;\n+\n+macro_rules! cfg_fn {\n+    ($field: ident) => {\n+        (|features| { features.$field }) as GateFn\n+    }\n+}\n+\n+/// `cfg(...)`'s that are feature gated.\n+const GATED_CFGS: &[(Symbol, Symbol, GateFn)] = &[\n+    // (name in cfg, feature, function to check if the feature is enabled)\n+    (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n+    (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n+    (sym::rustdoc, sym::doc_cfg, cfg_fn!(doc_cfg)),\n+    (sym::doctest, sym::cfg_doctest, cfg_fn!(cfg_doctest)),\n+];\n+\n+#[derive(Debug)]\n+pub struct GatedCfg {\n+    span: Span,\n+    index: usize,\n+}\n+\n+impl GatedCfg {\n+    pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n+        GATED_CFGS.iter()\n+                  .position(|info| cfg.check_name(info.0))\n+                  .map(|idx| {\n+                      GatedCfg {\n+                          span: cfg.span,\n+                          index: idx\n+                      }\n+                  })\n+    }\n+\n+    pub fn check_and_emit(&self, sess: &ParseSess, features: &Features) {\n+        let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n+        if !has_feature(features) && !self.span.allows_unstable(feature) {\n+            let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n+            emit_feature_err(sess, feature, self.span, GateIssue::Language, &explain);\n+        }\n+    }\n+}\n+\n+// If you change this, please modify `src/doc/unstable-book` as well. You must\n+// move that documentation into the relevant place in the other docs, and\n+// remove the chapter on the flag.\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum AttributeType {\n+    /// Normal, builtin attribute that is consumed\n+    /// by the compiler before the unused_attribute check\n+    Normal,\n+\n+    /// Builtin attribute that may not be consumed by the compiler\n+    /// before the unused_attribute check. These attributes\n+    /// will be ignored by the unused_attribute lint\n+    Whitelisted,\n+\n+    /// Builtin attribute that is only allowed at the crate level\n+    CrateLevel,\n+}\n+\n+pub enum AttributeGate {\n+    /// Is gated by a given feature gate, reason\n+    /// and function to check if enabled\n+    Gated(Stability, Symbol, &'static str, fn(&Features) -> bool),\n+\n+    /// Ungated attribute, can be used on all release channels\n+    Ungated,\n+}\n+\n+// fn() is not Debug\n+impl std::fmt::Debug for AttributeGate {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match *self {\n+            Self::Gated(ref stab, name, expl, _) =>\n+                write!(fmt, \"Gated({:?}, {}, {})\", stab, name, expl),\n+            Self::Ungated => write!(fmt, \"Ungated\")\n+        }\n+    }\n+}\n+\n+impl AttributeGate {\n+    fn is_deprecated(&self) -> bool {\n+        match *self {\n+            Self::Gated(Stability::Deprecated(_, _), ..) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// A convenience macro for constructing attribute templates.\n+/// E.g., `template!(Word, List: \"description\")` means that the attribute\n+/// supports forms `#[attr]` and `#[attr(description)]`.\n+macro_rules! template {\n+    (Word) => { template!(@ true, None, None) };\n+    (List: $descr: expr) => { template!(@ false, Some($descr), None) };\n+    (NameValueStr: $descr: expr) => { template!(@ false, None, Some($descr)) };\n+    (Word, List: $descr: expr) => { template!(@ true, Some($descr), None) };\n+    (Word, NameValueStr: $descr: expr) => { template!(@ true, None, Some($descr)) };\n+    (List: $descr1: expr, NameValueStr: $descr2: expr) => {\n+        template!(@ false, Some($descr1), Some($descr2))\n+    };\n+    (Word, List: $descr1: expr, NameValueStr: $descr2: expr) => {\n+        template!(@ true, Some($descr1), Some($descr2))\n+    };\n+    (@ $word: expr, $list: expr, $name_value_str: expr) => { AttributeTemplate {\n+        word: $word, list: $list, name_value_str: $name_value_str\n+    } };\n+}\n+\n+macro_rules! ungated {\n+    ($attr:ident, $typ:expr, $tpl:expr $(,)?) => {\n+        (sym::$attr, $typ, $tpl, Ungated)\n+    };\n+}\n+\n+macro_rules! gated {\n+    ($attr:ident, $typ:expr, $tpl:expr, $gate:ident, $msg:expr $(,)?) => {\n+        (sym::$attr, $typ, $tpl, Gated(Stability::Unstable, sym::$gate, $msg, cfg_fn!($gate)))\n+    };\n+    ($attr:ident, $typ:expr, $tpl:expr, $msg:expr $(,)?) => {\n+        (sym::$attr, $typ, $tpl, Gated(Stability::Unstable, sym::$attr, $msg, cfg_fn!($attr)))\n+    };\n+}\n+\n+macro_rules! rustc_attr {\n+    (TEST, $attr:ident, $typ:expr, $tpl:expr $(,)?) => {\n+        rustc_attr!(\n+            $attr, $typ, $tpl,\n+            concat!(\"the `#[\", stringify!($attr), \"]` attribute is just used for rustc unit tests \\\n+                and will never be stable\",\n+            ),\n+        )\n+    };\n+    ($attr:ident, $typ:expr, $tpl:expr, $msg:expr $(,)?) => {\n+        (sym::$attr, $typ, $tpl,\n+         Gated(Stability::Unstable, sym::rustc_attrs, $msg, cfg_fn!(rustc_attrs)))\n+    };\n+}\n+\n+macro_rules! experimental {\n+    ($attr:ident) => {\n+        concat!(\"the `#[\", stringify!($attr), \"]` attribute is an experimental feature\")\n+    }\n+}\n+\n+const IMPL_DETAIL: &str = \"internal implementation detail\";\n+const INTERAL_UNSTABLE: &str = \"this is an internal attribute that will never be stable\";\n+\n+pub type BuiltinAttribute = (Symbol, AttributeType, AttributeTemplate, AttributeGate);\n+\n+/// Attributes that have a special meaning to rustc or rustdoc\n+pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n+    // ==========================================================================\n+    // Stable attributes:\n+    // ==========================================================================\n+\n+    // Condtional compilation:\n+    ungated!(cfg, Normal, template!(List: \"predicate\")),\n+    ungated!(cfg_attr, Normal, template!(List: \"predicate, attr1, attr2, ...\")),\n+\n+    // Testing:\n+    ungated!(ignore, Normal, template!(Word, NameValueStr: \"reason\")),\n+    ungated!(\n+        should_panic, Normal,\n+        template!(Word, List: r#\"expected = \"reason\"#, NameValueStr: \"reason\"),\n+    ),\n+    // FIXME(Centril): This can be used on stable but shouldn't.\n+    ungated!(reexport_test_harness_main, Normal, template!(NameValueStr: \"name\")),\n+\n+    // Macros:\n+    ungated!(derive, Normal, template!(List: \"Trait1, Trait2, ...\")),\n+    ungated!(automatically_derived, Normal, template!(Word)),\n+    // FIXME(#14407)\n+    ungated!(macro_use, Normal, template!(Word, List: \"name1, name2, ...\")),\n+    ungated!(macro_escape, Normal, template!(Word)), // Deprecated synonym for `macro_use`.\n+    ungated!(macro_export, Normal, template!(Word, List: \"local_inner_macros\")),\n+    ungated!(proc_macro, Normal, template!(Word)),\n+    ungated!(\n+        proc_macro_derive, Normal,\n+        template!(List: \"TraitName, /*opt*/ attributes(name1, name2, ...)\"),\n+    ),\n+    ungated!(proc_macro_attribute, Normal, template!(Word)),\n+\n+    // Lints:\n+    ungated!(warn, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n+    ungated!(allow, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n+    ungated!(forbid, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n+    ungated!(deny, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n+    ungated!(must_use, Whitelisted, template!(Word, NameValueStr: \"reason\")),\n+    // FIXME(#14407)\n+    ungated!(\n+        deprecated, Normal,\n+        template!(\n+            Word,\n+            List: r#\"/*opt*/ since = \"version\", /*opt*/ note = \"reason\"\"#,\n+            NameValueStr: \"reason\"\n+        ),\n+    ),\n+\n+    // Crate properties:\n+    ungated!(crate_name, CrateLevel, template!(NameValueStr: \"name\")),\n+    ungated!(crate_type, CrateLevel, template!(NameValueStr: \"bin|lib|...\")),\n+    ungated!(crate_id, CrateLevel, template!(NameValueStr: \"ignored\")),\n+\n+    // ABI, linking, symbols, and FFI\n+    ungated!(\n+        link, Whitelisted,\n+        template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ cfg = \"...\"\"#),\n+    ),\n+    ungated!(link_name, Whitelisted, template!(NameValueStr: \"name\")),\n+    ungated!(no_link, Normal, template!(Word)),\n+    ungated!(repr, Normal, template!(List: \"C, packed, ...\")),\n+    ungated!(export_name, Whitelisted, template!(NameValueStr: \"name\")),\n+    ungated!(link_section, Whitelisted, template!(NameValueStr: \"name\")),\n+    ungated!(no_mangle, Whitelisted, template!(Word)),\n+    ungated!(used, Whitelisted, template!(Word)),\n+\n+    // Limits:\n+    ungated!(recursion_limit, CrateLevel, template!(NameValueStr: \"N\")),\n+    ungated!(type_length_limit, CrateLevel, template!(NameValueStr: \"N\")),\n+\n+    // Entry point:\n+    ungated!(main, Normal, template!(Word)),\n+    ungated!(start, Normal, template!(Word)),\n+    ungated!(no_start, CrateLevel, template!(Word)),\n+    ungated!(no_main, CrateLevel, template!(Word)),\n+\n+    // Modules, prelude, and resolution:\n+    ungated!(path, Normal, template!(NameValueStr: \"file\")),\n+    ungated!(no_std, CrateLevel, template!(Word)),\n+    ungated!(no_implicit_prelude, Normal, template!(Word)),\n+\n+    // Runtime\n+    ungated!(windows_subsystem, Whitelisted, template!(NameValueStr: \"windows|console\")),\n+    ungated!(panic_handler, Normal, template!(Word)), // RFC 2070\n+\n+    // Code generation:\n+    ungated!(inline, Whitelisted, template!(Word, List: \"always|never\")),\n+    ungated!(cold, Whitelisted, template!(Word)),\n+    ungated!(no_builtins, Whitelisted, template!(Word)),\n+    ungated!(target_feature, Whitelisted, template!(List: r#\"enable = \"name\"\"#)),\n+\n+    // FIXME: #14408 whitelist docs since rustdoc looks at them\n+    ungated!(doc, Whitelisted, template!(List: \"hidden|inline|...\", NameValueStr: \"string\")),\n+\n+    // ==========================================================================\n+    // Unstable attributes:\n+    // ==========================================================================\n+\n+    // Linking:\n+    gated!(naked, Whitelisted, template!(Word), naked_functions, experimental!(naked)),\n+    gated!(\n+        link_args, Normal, template!(NameValueStr: \"args\"),\n+        \"the `link_args` attribute is experimental and not portable across platforms, \\\n+        it is recommended to use `#[link(name = \\\"foo\\\")] instead\",\n+    ),\n+\n+    // Plugins:\n+    ungated!(plugin_registrar, Normal, template!(Word)),\n+    gated!(\n+        plugin, CrateLevel, template!(List: \"name|name(args)\"),\n+        \"compiler plugins are experimental and possibly buggy\",\n+    ),\n+\n+    // Testing:\n+    gated!(allow_fail, Normal, template!(Word), experimental!(allow_fail)),\n+    gated!(\n+        test_runner, CrateLevel, template!(List: \"path\"), custom_test_frameworks,\n+        \"custom test frameworks are an unstable feature\",\n+    ),\n+\n+    // RFC #2008\n+    gated!(non_exhaustive, Whitelisted, template!(Word), experimental!(non_exhaustive)),\n+    // RFC #1268\n+    gated!(marker, Normal, template!(Word), marker_trait_attr, experimental!(marker)),\n+    gated!(\n+        thread_local, Whitelisted, template!(Word),\n+        \"`#[thread_local]` is an experimental feature, and does not currently handle destructors\",\n+    ),\n+    gated!(no_core, CrateLevel, template!(Word), experimental!(no_core)),\n+    // RFC 2412\n+    gated!(\n+        optimize, Whitelisted, template!(List: \"size|speed\"), optimize_attribute,\n+        experimental!(optimize),\n+    ),\n+\n+    gated!(ffi_returns_twice, Whitelisted, template!(Word), experimental!(ffi_returns_twice)),\n+\n+    // ==========================================================================\n+    // Internal attributes: Stability, deprecation, and unsafe:\n+    // ==========================================================================\n+\n+    ungated!(feature, CrateLevel, template!(List: \"name1, name1, ...\")),\n+    // FIXME(#14407) -- only looked at on-demand so we can't\n+    // guarantee they'll have already been checked.\n+    ungated!(\n+        rustc_deprecated, Whitelisted,\n+        template!(List: r#\"since = \"version\", reason = \"...\"\"#)\n+    ),\n+    // FIXME(#14407)\n+    ungated!(stable, Whitelisted, template!(List: r#\"feature = \"name\", since = \"version\"\"#)),\n+    // FIXME(#14407)\n+    ungated!(\n+        unstable, Whitelisted,\n+        template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#),\n+    ),\n+    gated!(\n+        rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#),\n+        \"the `#[rustc_const_unstable]` attribute is an internal feature\",\n+    ),\n+    gated!(\n+        allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"),\n+        EXPLAIN_ALLOW_INTERNAL_UNSTABLE,\n+    ),\n+    gated!(allow_internal_unsafe, Normal, template!(Word), EXPLAIN_ALLOW_INTERNAL_UNSAFE),\n+\n+    // ==========================================================================\n+    // Internal attributes: Type system related:\n+    // ==========================================================================\n+\n+    gated!(fundamental, Whitelisted, template!(Word), experimental!(fundamental)),\n+    gated!(\n+        // RFC #1445.\n+        structural_match, Whitelisted, template!(Word),\n+        \"the semantics of constant patterns is not yet settled\",\n+    ),\n+    gated!(\n+        may_dangle, Normal, template!(Word), dropck_eyepatch,\n+        \"`may_dangle` has unstable semantics and may be removed in the future\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes: Runtime related:\n+    // ==========================================================================\n+\n+    rustc_attr!(rustc_allocator, Whitelisted, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_allocator_nounwind, Whitelisted, template!(Word), IMPL_DETAIL),\n+    gated!(alloc_error_handler, Normal, template!(Word), experimental!(alloc_error_handler)),\n+    gated!(\n+        default_lib_allocator, Whitelisted, template!(Word), allocator_internals,\n+        experimental!(default_lib_allocator),\n+    ),\n+    gated!(\n+        needs_allocator, Normal, template!(Word), allocator_internals,\n+        experimental!(needs_allocator),\n+    ),\n+    gated!(panic_runtime, Whitelisted, template!(Word), experimental!(panic_runtime)),\n+    gated!(needs_panic_runtime, Whitelisted, template!(Word), experimental!(needs_panic_runtime)),\n+    gated!(\n+        unwind, Whitelisted, template!(List: \"allowed|aborts\"), unwind_attributes,\n+        experimental!(unwind),\n+    ),\n+    gated!(\n+        compiler_builtins, Whitelisted, template!(Word),\n+        \"the `#[compiler_builtins]` attribute is used to identify the `compiler_builtins` crate \\\n+        which contains compiler-rt intrinsics and will never be stable\",\n+    ),\n+    gated!(\n+        sanitizer_runtime, Whitelisted, template!(Word),\n+        \"the `#[sanitizer_runtime]` attribute is used to identify crates that contain the runtime \\\n+        of a sanitizer and will never be stable\",\n+    ),\n+    gated!(\n+        profiler_runtime, Whitelisted, template!(Word),\n+        \"the `#[profiler_runtime]` attribute is used to identify the `profiler_builtins` crate \\\n+        which contains the profiler runtime and will never be stable\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Linkage:\n+    // ==========================================================================\n+\n+    gated!(\n+        linkage, Whitelisted, template!(NameValueStr: \"external|internal|...\"),\n+        \"the `linkage` attribute is experimental and not portable across platforms\",\n+    ),\n+    rustc_attr!(rustc_std_internal_symbol, Whitelisted, template!(Word), INTERAL_UNSTABLE),\n+\n+    // ==========================================================================\n+    // Internal attributes, Macro related:\n+    // ==========================================================================\n+\n+    rustc_attr!(rustc_builtin_macro, Whitelisted, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_proc_macro_decls, Normal, template!(Word), INTERAL_UNSTABLE),\n+    rustc_attr!(\n+        rustc_macro_transparency, Whitelisted,\n+        template!(NameValueStr: \"transparent|semitransparent|opaque\"),\n+        \"used internally for testing macro hygiene\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Diagnostics related:\n+    // ==========================================================================\n+\n+    gated!(\n+        rustc_on_unimplemented, Whitelisted,\n+        template!(\n+            List: r#\"/*opt*/ message = \"...\", /*opt*/ label = \"...\", /*opt*/ note = \"...\"\"#,\n+            NameValueStr: \"message\"\n+        ),\n+        on_unimplemented,\n+        experimental!(rustc_on_unimplemented),\n+    ),\n+    // Whitelists \"identity-like\" conversion methods to suggest on type mismatch.\n+    rustc_attr!(rustc_conversion_suggestion, Whitelisted, template!(Word), INTERAL_UNSTABLE),\n+\n+    // ==========================================================================\n+    // Internal attributes, Const related:\n+    // ==========================================================================\n+\n+    rustc_attr!(rustc_promotable, Whitelisted, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_allow_const_fn_ptr, Whitelisted, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_args_required_const, Whitelisted, template!(List: \"N\"), INTERAL_UNSTABLE),\n+\n+    // ==========================================================================\n+    // Internal attributes, Layout related:\n+    // ==========================================================================\n+\n+    rustc_attr!(\n+        rustc_layout_scalar_valid_range_start, Whitelisted, template!(List: \"value\"),\n+        \"the `#[rustc_layout_scalar_valid_range_start]` attribute is just used to enable \\\n+        niche optimizations in libcore and will never be stable\",\n+    ),\n+    rustc_attr!(\n+        rustc_layout_scalar_valid_range_end, Whitelisted, template!(List: \"value\"),\n+        \"the `#[rustc_layout_scalar_valid_range_end]` attribute is just used to enable \\\n+        niche optimizations in libcore and will never be stable\",\n+    ),\n+    rustc_attr!(\n+        rustc_nonnull_optimization_guaranteed, Whitelisted, template!(Word),\n+        \"the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable \\\n+        niche optimizations in libcore and will never be stable\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Misc:\n+    // ==========================================================================\n+\n+    gated!(\n+        lang, Normal, template!(NameValueStr: \"name\"), lang_items,\n+        \"language items are subject to change\",\n+    ),\n+    (\n+        sym::no_debug, Whitelisted, template!(Word),\n+        Gated(\n+            Stability::Deprecated(\"https://github.com/rust-lang/rust/issues/29721\", None),\n+            sym::no_debug,\n+            \"the `#[no_debug]` attribute was an experimental feature that has been \\\n+            deprecated due to lack of demand\",\n+            cfg_fn!(no_debug)\n+        )\n+    ),\n+    gated!(\n+        // Used in resolve:\n+        prelude_import, Whitelisted, template!(Word),\n+        \"`#[prelude_import]` is for use by rustc only\",\n+    ),\n+    gated!(\n+        rustc_paren_sugar, Normal, template!(Word), unboxed_closures,\n+        \"unboxed_closures are still evolving\",\n+    ),\n+    rustc_attr!(\n+        rustc_inherit_overflow_checks, Whitelisted, template!(Word),\n+        \"the `#[rustc_inherit_overflow_checks]` attribute is just used to control \\\n+        overflow checking behavior of several libcore functions that are inlined \\\n+        across crates and will never be stable\",\n+    ),\n+    rustc_attr!(\n+        rustc_test_marker, Normal, template!(Word),\n+        \"the `#[rustc_test_marker]` attribute is used internally to track tests\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Testing:\n+    // ==========================================================================\n+\n+    rustc_attr!(TEST, rustc_outlives, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_variance, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\")),\n+    rustc_attr!(TEST, rustc_regions, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_error, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_dump_user_substs, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_if_this_changed, Whitelisted, template!(Word, List: \"DepNode\")),\n+    rustc_attr!(TEST, rustc_then_this_would_need, Whitelisted, template!(List: \"DepNode\")),\n+    rustc_attr!(\n+        TEST, rustc_dirty, Whitelisted,\n+        template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_clean, Whitelisted,\n+        template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_partition_reused, Whitelisted,\n+        template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_partition_codegened, Whitelisted,\n+        template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_expected_cgu_reuse, Whitelisted,\n+        template!(List: r#\"cfg = \"...\", module = \"...\", kind = \"...\"\"#),\n+    ),\n+    rustc_attr!(TEST, rustc_synthetic, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_symbol_name, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_def_path, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_mir, Whitelisted, template!(List: \"arg1, arg2, ...\")),\n+    rustc_attr!(TEST, rustc_dump_program_clauses, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_dump_env_program_clauses, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_object_lifetime_default, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_dummy, Normal, template!(Word /* doesn't matter*/)),\n+    gated!(\n+        omit_gdb_pretty_printer_section, Whitelisted, template!(Word),\n+        \"the `#[omit_gdb_pretty_printer_section]` attribute is just used for the Rust test suite\",\n+    ),\n+];\n+\n+pub fn deprecated_attributes() -> Vec<&'static BuiltinAttribute> {\n+    BUILTIN_ATTRIBUTES.iter().filter(|(.., gate)| gate.is_deprecated()).collect()\n+}\n+\n+pub fn is_builtin_attr_name(name: ast::Name) -> bool {\n+    BUILTIN_ATTRIBUTE_MAP.get(&name).is_some()\n+}\n+\n+pub fn is_builtin_attr(attr: &ast::Attribute) -> bool {\n+    attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name)).is_some()\n+}\n+\n+lazy_static! {\n+    pub static ref BUILTIN_ATTRIBUTE_MAP: FxHashMap<Symbol, &'static BuiltinAttribute> = {\n+        let mut map = FxHashMap::default();\n+        for attr in BUILTIN_ATTRIBUTES.iter() {\n+            if map.insert(attr.0, attr).is_some() {\n+                panic!(\"duplicate builtin attribute `{}`\", attr.0);\n+            }\n+        }\n+        map\n+    };\n+}"}, {"sha": "d82b287b6fb05f693a66e3f58147fd4143b0bd3d", "filename": "src/libsyntax/feature_gate/check.rs", "status": "added", "additions": 951, "deletions": 0, "changes": 951, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,951 @@\n+use super::active::{ACTIVE_FEATURES, Features};\n+use super::accepted::ACCEPTED_FEATURES;\n+use super::removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};\n+use super::builtin_attrs::{AttributeGate, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n+\n+use crate::ast::{\n+    self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n+    PatKind, RangeEnd,\n+};\n+use crate::attr::{self, check_builtin_attribute};\n+use crate::source_map::Spanned;\n+use crate::edition::{ALL_EDITIONS, Edition};\n+use crate::visit::{self, FnKind, Visitor};\n+use crate::parse::{token, ParseSess};\n+use crate::parse::parser::Parser;\n+use crate::symbol::{Symbol, sym};\n+use crate::tokenstream::TokenTree;\n+\n+use errors::{Applicability, DiagnosticBuilder, Handler};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_target::spec::abi::Abi;\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n+use log::debug;\n+\n+use std::env;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum Stability {\n+    Unstable,\n+    // First argument is tracking issue link; second argument is an optional\n+    // help message, which defaults to \"remove this attribute\"\n+    Deprecated(&'static str, Option<&'static str>),\n+}\n+\n+struct Context<'a> {\n+    features: &'a Features,\n+    parse_sess: &'a ParseSess,\n+    plugin_attributes: &'a [(Symbol, AttributeType)],\n+}\n+\n+macro_rules! gate_feature_fn {\n+    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $level: expr) => {{\n+        let (cx, has_feature, span,\n+             name, explain, level) = ($cx, $has_feature, $span, $name, $explain, $level);\n+        let has_feature: bool = has_feature(&$cx.features);\n+        debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n+        if !has_feature && !span.allows_unstable($name) {\n+            leveled_feature_err(cx.parse_sess, name, span, GateIssue::Language, explain, level)\n+                .emit();\n+        }\n+    }}\n+}\n+\n+macro_rules! gate_feature {\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n+        gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n+                         sym::$feature, $explain, GateStrength::Hard)\n+    };\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {\n+        gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n+                         sym::$feature, $explain, $level)\n+    };\n+}\n+\n+impl<'a> Context<'a> {\n+    fn check_attribute(\n+        &self,\n+        attr: &ast::Attribute,\n+        attr_info: Option<&BuiltinAttribute>,\n+        is_macro: bool\n+    ) {\n+        debug!(\"check_attribute(attr = {:?})\", attr);\n+        if let Some(&(name, ty, _template, ref gateage)) = attr_info {\n+            if let AttributeGate::Gated(_, name, desc, ref has_feature) = *gateage {\n+                if !attr.span.allows_unstable(name) {\n+                    gate_feature_fn!(\n+                        self, has_feature, attr.span, name, desc, GateStrength::Hard\n+                    );\n+                }\n+            } else if name == sym::doc {\n+                if let Some(content) = attr.meta_item_list() {\n+                    if content.iter().any(|c| c.check_name(sym::include)) {\n+                        gate_feature!(self, external_doc, attr.span,\n+                            \"`#[doc(include = \\\"...\\\")]` is experimental\"\n+                        );\n+                    }\n+                }\n+            }\n+            debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n+            return;\n+        } else {\n+            for segment in &attr.path.segments {\n+                if segment.ident.as_str().starts_with(\"rustc\") {\n+                    let msg = \"attributes starting with `rustc` are \\\n+                               reserved for use by the `rustc` compiler\";\n+                    gate_feature!(self, rustc_attrs, segment.ident.span, msg);\n+                }\n+            }\n+        }\n+        for &(n, ty) in self.plugin_attributes {\n+            if attr.path == n {\n+                // Plugins can't gate attributes, so we don't check for it\n+                // unlike the code above; we only use this loop to\n+                // short-circuit to avoid the checks below.\n+                debug!(\"check_attribute: {:?} is registered by a plugin, {:?}\", attr.path, ty);\n+                return;\n+            }\n+        }\n+        if !is_macro && !attr::is_known(attr) {\n+            // Only run the custom attribute lint during regular feature gate\n+            // checking. Macro gating runs before the plugin attributes are\n+            // registered, so we skip this in that case.\n+            let msg = format!(\"the attribute `{}` is currently unknown to the compiler and \\\n+                               may have meaning added to it in the future\", attr.path);\n+            gate_feature!(self, custom_attribute, attr.span, &msg);\n+        }\n+    }\n+}\n+\n+pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n+    let cx = Context { features, parse_sess, plugin_attributes: &[] };\n+    cx.check_attribute(\n+        attr,\n+        attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name).map(|a| *a)),\n+        true\n+    );\n+}\n+\n+fn find_lang_feature_issue(feature: Symbol) -> Option<u32> {\n+    if let Some(info) = ACTIVE_FEATURES.iter().find(|t| t.0 == feature) {\n+        let issue = info.2;\n+        // FIXME (#28244): enforce that active features have issue numbers\n+        // assert!(issue.is_some())\n+        issue\n+    } else {\n+        // search in Accepted, Removed, or Stable Removed features\n+        let found = ACCEPTED_FEATURES.iter().chain(REMOVED_FEATURES).chain(STABLE_REMOVED_FEATURES)\n+            .find(|t| t.0 == feature);\n+        match found {\n+            Some(&(_, _, issue, _)) => issue,\n+            None => panic!(\"Feature `{}` is not declared anywhere\", feature),\n+        }\n+    }\n+}\n+\n+pub enum GateIssue {\n+    Language,\n+    Library(Option<u32>)\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq)]\n+pub enum GateStrength {\n+    /// A hard error. (Most feature gates should use this.)\n+    Hard,\n+    /// Only a warning. (Use this only as backwards-compatibility demands.)\n+    Soft,\n+}\n+\n+pub fn emit_feature_err(\n+    sess: &ParseSess,\n+    feature: Symbol,\n+    span: Span,\n+    issue: GateIssue,\n+    explain: &str,\n+) {\n+    feature_err(sess, feature, span, issue, explain).emit();\n+}\n+\n+pub fn feature_err<'a, S: Into<MultiSpan>>(\n+    sess: &'a ParseSess,\n+    feature: Symbol,\n+    span: S,\n+    issue: GateIssue,\n+    explain: &str,\n+) -> DiagnosticBuilder<'a> {\n+    leveled_feature_err(sess, feature, span, issue, explain, GateStrength::Hard)\n+}\n+\n+fn leveled_feature_err<'a, S: Into<MultiSpan>>(\n+    sess: &'a ParseSess,\n+    feature: Symbol,\n+    span: S,\n+    issue: GateIssue,\n+    explain: &str,\n+    level: GateStrength,\n+) -> DiagnosticBuilder<'a> {\n+    let diag = &sess.span_diagnostic;\n+\n+    let issue = match issue {\n+        GateIssue::Language => find_lang_feature_issue(feature),\n+        GateIssue::Library(lib) => lib,\n+    };\n+\n+    let mut err = match level {\n+        GateStrength::Hard => {\n+            diag.struct_span_err_with_code(span, explain, stringify_error_code!(E0658))\n+        }\n+        GateStrength::Soft => diag.struct_span_warn(span, explain),\n+    };\n+\n+    match issue {\n+        None | Some(0) => {}  // We still accept `0` as a stand-in for backwards compatibility\n+        Some(n) => {\n+            err.note(&format!(\n+                \"for more information, see https://github.com/rust-lang/rust/issues/{}\",\n+                n,\n+            ));\n+        }\n+    }\n+\n+    // #23973: do not suggest `#![feature(...)]` if we are in beta/stable\n+    if sess.unstable_features.is_nightly_build() {\n+        err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", feature));\n+    }\n+\n+    // If we're on stable and only emitting a \"soft\" warning, add a note to\n+    // clarify that the feature isn't \"on\" (rather than being on but\n+    // warning-worthy).\n+    if !sess.unstable_features.is_nightly_build() && level == GateStrength::Soft {\n+        err.help(\"a nightly build of the compiler is required to enable this feature\");\n+    }\n+\n+    err\n+\n+}\n+\n+const EXPLAIN_BOX_SYNTAX: &str =\n+    \"box expression syntax is experimental; you can call `Box::new` instead\";\n+\n+pub const EXPLAIN_STMT_ATTR_SYNTAX: &str =\n+    \"attributes on expressions are experimental\";\n+\n+pub const EXPLAIN_ALLOW_INTERNAL_UNSTABLE: &str =\n+    \"allow_internal_unstable side-steps feature gating and stability checks\";\n+pub const EXPLAIN_ALLOW_INTERNAL_UNSAFE: &str =\n+    \"allow_internal_unsafe side-steps the unsafe_code lint\";\n+\n+pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &str =\n+    \"unsized tuple coercion is not stable enough for use and is subject to change\";\n+\n+struct PostExpansionVisitor<'a> {\n+    context: &'a Context<'a>,\n+    builtin_attributes: &'static FxHashMap<Symbol, &'static BuiltinAttribute>,\n+}\n+\n+macro_rules! gate_feature_post {\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n+        let (cx, span) = ($cx, $span);\n+        if !span.allows_unstable(sym::$feature) {\n+            gate_feature!(cx.context, $feature, span, $explain)\n+        }\n+    }};\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {{\n+        let (cx, span) = ($cx, $span);\n+        if !span.allows_unstable(sym::$feature) {\n+            gate_feature!(cx.context, $feature, span, $explain, $level)\n+        }\n+    }}\n+}\n+\n+impl<'a> PostExpansionVisitor<'a> {\n+    fn check_abi(&self, abi: Abi, span: Span) {\n+        match abi {\n+            Abi::RustIntrinsic => {\n+                gate_feature_post!(&self, intrinsics, span,\n+                                   \"intrinsics are subject to change\");\n+            },\n+            Abi::PlatformIntrinsic => {\n+                gate_feature_post!(&self, platform_intrinsics, span,\n+                                   \"platform intrinsics are experimental and possibly buggy\");\n+            },\n+            Abi::Vectorcall => {\n+                gate_feature_post!(&self, abi_vectorcall, span,\n+                                   \"vectorcall is experimental and subject to change\");\n+            },\n+            Abi::Thiscall => {\n+                gate_feature_post!(&self, abi_thiscall, span,\n+                                   \"thiscall is experimental and subject to change\");\n+            },\n+            Abi::RustCall => {\n+                gate_feature_post!(&self, unboxed_closures, span,\n+                                   \"rust-call ABI is subject to change\");\n+            },\n+            Abi::PtxKernel => {\n+                gate_feature_post!(&self, abi_ptx, span,\n+                                   \"PTX ABIs are experimental and subject to change\");\n+            },\n+            Abi::Unadjusted => {\n+                gate_feature_post!(&self, abi_unadjusted, span,\n+                                   \"unadjusted ABI is an implementation detail and perma-unstable\");\n+            },\n+            Abi::Msp430Interrupt => {\n+                gate_feature_post!(&self, abi_msp430_interrupt, span,\n+                                   \"msp430-interrupt ABI is experimental and subject to change\");\n+            },\n+            Abi::X86Interrupt => {\n+                gate_feature_post!(&self, abi_x86_interrupt, span,\n+                                   \"x86-interrupt ABI is experimental and subject to change\");\n+            },\n+            Abi::AmdGpuKernel => {\n+                gate_feature_post!(&self, abi_amdgpu_kernel, span,\n+                                   \"amdgpu-kernel ABI is experimental and subject to change\");\n+            },\n+            // Stable\n+            Abi::Cdecl |\n+            Abi::Stdcall |\n+            Abi::Fastcall |\n+            Abi::Aapcs |\n+            Abi::Win64 |\n+            Abi::SysV64 |\n+            Abi::Rust |\n+            Abi::C |\n+            Abi::System => {}\n+        }\n+    }\n+}\n+\n+impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+        let attr_info = attr.ident().and_then(|ident| {\n+            self.builtin_attributes.get(&ident.name).map(|a| *a)\n+        });\n+\n+        // Check for gated attributes.\n+        self.context.check_attribute(attr, attr_info, false);\n+\n+        if attr.check_name(sym::doc) {\n+            if let Some(content) = attr.meta_item_list() {\n+                if content.len() == 1 && content[0].check_name(sym::cfg) {\n+                    gate_feature_post!(&self, doc_cfg, attr.span,\n+                        \"`#[doc(cfg(...))]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::masked)) {\n+                    gate_feature_post!(&self, doc_masked, attr.span,\n+                        \"`#[doc(masked)]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::spotlight)) {\n+                    gate_feature_post!(&self, doc_spotlight, attr.span,\n+                        \"`#[doc(spotlight)]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::alias)) {\n+                    gate_feature_post!(&self, doc_alias, attr.span,\n+                        \"`#[doc(alias = \\\"...\\\")]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::keyword)) {\n+                    gate_feature_post!(&self, doc_keyword, attr.span,\n+                        \"`#[doc(keyword = \\\"...\\\")]` is experimental\"\n+                    );\n+                }\n+            }\n+        }\n+\n+        match attr_info {\n+            // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n+            Some(&(name, _, template, _)) if name != sym::rustc_dummy =>\n+                check_builtin_attribute(self.context.parse_sess, attr, name, template),\n+            _ => if let Some(TokenTree::Token(token)) = attr.tokens.trees().next() {\n+                if token == token::Eq {\n+                    // All key-value attributes are restricted to meta-item syntax.\n+                    attr.parse_meta(self.context.parse_sess).map_err(|mut err| err.emit()).ok();\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n+        if !name.as_str().is_ascii() {\n+            gate_feature_post!(\n+                &self,\n+                non_ascii_idents,\n+                self.context.parse_sess.source_map().def_span(sp),\n+                \"non-ascii idents are not fully supported\"\n+            );\n+        }\n+    }\n+\n+    fn visit_item(&mut self, i: &'a ast::Item) {\n+        match i.node {\n+            ast::ItemKind::ForeignMod(ref foreign_module) => {\n+                self.check_abi(foreign_module.abi, i.span);\n+            }\n+\n+            ast::ItemKind::Fn(..) => {\n+                if attr::contains_name(&i.attrs[..], sym::plugin_registrar) {\n+                    gate_feature_post!(&self, plugin_registrar, i.span,\n+                                       \"compiler plugins are experimental and possibly buggy\");\n+                }\n+                if attr::contains_name(&i.attrs[..], sym::start) {\n+                    gate_feature_post!(&self, start, i.span,\n+                                      \"a `#[start]` function is an experimental \\\n+                                       feature whose signature may change \\\n+                                       over time\");\n+                }\n+                if attr::contains_name(&i.attrs[..], sym::main) {\n+                    gate_feature_post!(&self, main, i.span,\n+                                       \"declaration of a non-standard `#[main]` \\\n+                                        function may change over time, for now \\\n+                                        a top-level `fn main()` is required\");\n+                }\n+            }\n+\n+            ast::ItemKind::Struct(..) => {\n+                for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n+                    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+                        if item.check_name(sym::simd) {\n+                            gate_feature_post!(&self, repr_simd, attr.span,\n+                                               \"SIMD types are experimental and possibly buggy\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ast::ItemKind::Enum(ast::EnumDef{ref variants, ..}, ..) => {\n+                for variant in variants {\n+                    match (&variant.data, &variant.disr_expr) {\n+                        (ast::VariantData::Unit(..), _) => {},\n+                        (_, Some(disr_expr)) =>\n+                            gate_feature_post!(\n+                                &self,\n+                                arbitrary_enum_discriminant,\n+                                disr_expr.value.span,\n+                                \"discriminants on non-unit variants are experimental\"),\n+                        _ => {},\n+                    }\n+                }\n+\n+                let has_feature = self.context.features.arbitrary_enum_discriminant;\n+                if !has_feature && !i.span.allows_unstable(sym::arbitrary_enum_discriminant) {\n+                    Parser::maybe_report_invalid_custom_discriminants(\n+                        self.context.parse_sess,\n+                        &variants,\n+                    );\n+                }\n+            }\n+\n+            ast::ItemKind::Impl(_, polarity, defaultness, ..) => {\n+                if polarity == ast::ImplPolarity::Negative {\n+                    gate_feature_post!(&self, optin_builtin_traits,\n+                                       i.span,\n+                                       \"negative trait bounds are not yet fully implemented; \\\n+                                        use marker types for now\");\n+                }\n+\n+                if let ast::Defaultness::Default = defaultness {\n+                    gate_feature_post!(&self, specialization,\n+                                       i.span,\n+                                       \"specialization is unstable\");\n+                }\n+            }\n+\n+            ast::ItemKind::Trait(ast::IsAuto::Yes, ..) => {\n+                gate_feature_post!(&self, optin_builtin_traits,\n+                                   i.span,\n+                                   \"auto traits are experimental and possibly buggy\");\n+            }\n+\n+            ast::ItemKind::TraitAlias(..) => {\n+                gate_feature_post!(\n+                    &self,\n+                    trait_alias,\n+                    i.span,\n+                    \"trait aliases are experimental\"\n+                );\n+            }\n+\n+            ast::ItemKind::MacroDef(ast::MacroDef { legacy: false, .. }) => {\n+                let msg = \"`macro` is experimental\";\n+                gate_feature_post!(&self, decl_macro, i.span, msg);\n+            }\n+\n+            ast::ItemKind::OpaqueTy(..) => {\n+                gate_feature_post!(\n+                    &self,\n+                    type_alias_impl_trait,\n+                    i.span,\n+                    \"`impl Trait` in type aliases is unstable\"\n+                );\n+            }\n+\n+            _ => {}\n+        }\n+\n+        visit::walk_item(self, i);\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n+        match i.node {\n+            ast::ForeignItemKind::Fn(..) |\n+            ast::ForeignItemKind::Static(..) => {\n+                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n+                let links_to_llvm = match link_name {\n+                    Some(val) => val.as_str().starts_with(\"llvm.\"),\n+                    _ => false\n+                };\n+                if links_to_llvm {\n+                    gate_feature_post!(&self, link_llvm_intrinsics, i.span,\n+                                       \"linking to LLVM intrinsics is experimental\");\n+                }\n+            }\n+            ast::ForeignItemKind::Ty => {\n+                    gate_feature_post!(&self, extern_types, i.span,\n+                                       \"extern types are experimental\");\n+            }\n+            ast::ForeignItemKind::Macro(..) => {}\n+        }\n+\n+        visit::walk_foreign_item(self, i)\n+    }\n+\n+    fn visit_ty(&mut self, ty: &'a ast::Ty) {\n+        match ty.node {\n+            ast::TyKind::BareFn(ref bare_fn_ty) => {\n+                self.check_abi(bare_fn_ty.abi, ty.span);\n+            }\n+            ast::TyKind::Never => {\n+                gate_feature_post!(&self, never_type, ty.span,\n+                                   \"The `!` type is experimental\");\n+            }\n+            _ => {}\n+        }\n+        visit::walk_ty(self, ty)\n+    }\n+\n+    fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FunctionRetTy) {\n+        if let ast::FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n+            if let ast::TyKind::Never = output_ty.node {\n+                // Do nothing.\n+            } else {\n+                self.visit_ty(output_ty)\n+            }\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, e: &'a ast::Expr) {\n+        match e.node {\n+            ast::ExprKind::Box(_) => {\n+                gate_feature_post!(&self, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n+            }\n+            ast::ExprKind::Type(..) => {\n+                // To avoid noise about type ascription in common syntax errors, only emit if it\n+                // is the *only* error.\n+                if self.context.parse_sess.span_diagnostic.err_count() == 0 {\n+                    gate_feature_post!(&self, type_ascription, e.span,\n+                                       \"type ascription is experimental\");\n+                }\n+            }\n+            ast::ExprKind::TryBlock(_) => {\n+                gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n+            }\n+            ast::ExprKind::Block(_, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    gate_feature_post!(&self, label_break_value, label.ident.span,\n+                                    \"labels on blocks are unstable\");\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_expr(self, e)\n+    }\n+\n+    fn visit_arm(&mut self, arm: &'a ast::Arm) {\n+        visit::walk_arm(self, arm)\n+    }\n+\n+    fn visit_pat(&mut self, pattern: &'a ast::Pat) {\n+        match &pattern.node {\n+            PatKind::Slice(pats) => {\n+                for pat in &*pats {\n+                    let span = pat.span;\n+                    let inner_pat = match &pat.node {\n+                        PatKind::Ident(.., Some(pat)) => pat,\n+                        _ => pat,\n+                    };\n+                    if inner_pat.is_rest() {\n+                        gate_feature_post!(\n+                            &self,\n+                            slice_patterns,\n+                            span,\n+                            \"subslice patterns are unstable\"\n+                        );\n+                    }\n+                }\n+            }\n+            PatKind::Box(..) => {\n+                gate_feature_post!(&self, box_patterns,\n+                                  pattern.span,\n+                                  \"box pattern syntax is experimental\");\n+            }\n+            PatKind::Range(_, _, Spanned { node: RangeEnd::Excluded, .. }) => {\n+                gate_feature_post!(&self, exclusive_range_pattern, pattern.span,\n+                                   \"exclusive range pattern syntax is experimental\");\n+            }\n+            _ => {}\n+        }\n+        visit::walk_pat(self, pattern)\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fn_kind: FnKind<'a>,\n+                fn_decl: &'a ast::FnDecl,\n+                span: Span,\n+                _node_id: NodeId) {\n+        if let Some(header) = fn_kind.header() {\n+            // Stability of const fn methods are covered in\n+            // `visit_trait_item` and `visit_impl_item` below; this is\n+            // because default methods don't pass through this point.\n+            self.check_abi(header.abi, span);\n+        }\n+\n+        if fn_decl.c_variadic {\n+            gate_feature_post!(&self, c_variadic, span, \"C-variadic functions are unstable\");\n+        }\n+\n+        visit::walk_fn(self, fn_kind, fn_decl, span)\n+    }\n+\n+    fn visit_generic_param(&mut self, param: &'a GenericParam) {\n+        match param.kind {\n+            GenericParamKind::Const { .. } =>\n+                gate_feature_post!(&self, const_generics, param.ident.span,\n+                    \"const generics are unstable\"),\n+            _ => {}\n+        }\n+        visit::walk_generic_param(self, param)\n+    }\n+\n+    fn visit_assoc_ty_constraint(&mut self, constraint: &'a AssocTyConstraint) {\n+        match constraint.kind {\n+            AssocTyConstraintKind::Bound { .. } =>\n+                gate_feature_post!(&self, associated_type_bounds, constraint.span,\n+                    \"associated type bounds are unstable\"),\n+            _ => {}\n+        }\n+        visit::walk_assoc_ty_constraint(self, constraint)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'a ast::TraitItem) {\n+        match ti.node {\n+            ast::TraitItemKind::Method(ref sig, ref block) => {\n+                if block.is_none() {\n+                    self.check_abi(sig.header.abi, ti.span);\n+                }\n+                if sig.decl.c_variadic {\n+                    gate_feature_post!(&self, c_variadic, ti.span,\n+                                       \"C-variadic functions are unstable\");\n+                }\n+                if sig.header.constness.node == ast::Constness::Const {\n+                    gate_feature_post!(&self, const_fn, ti.span, \"const fn is unstable\");\n+                }\n+            }\n+            ast::TraitItemKind::Type(_, ref default) => {\n+                // We use three if statements instead of something like match guards so that all\n+                // of these errors can be emitted if all cases apply.\n+                if default.is_some() {\n+                    gate_feature_post!(&self, associated_type_defaults, ti.span,\n+                                       \"associated type defaults are unstable\");\n+                }\n+                if !ti.generics.params.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ti.span,\n+                                       \"generic associated types are unstable\");\n+                }\n+                if !ti.generics.where_clause.predicates.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ti.span,\n+                                       \"where clauses on associated types are unstable\");\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_trait_item(self, ti)\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'a ast::ImplItem) {\n+        if ii.defaultness == ast::Defaultness::Default {\n+            gate_feature_post!(&self, specialization,\n+                              ii.span,\n+                              \"specialization is unstable\");\n+        }\n+\n+        match ii.node {\n+            ast::ImplItemKind::Method(..) => {}\n+            ast::ImplItemKind::OpaqueTy(..) => {\n+                gate_feature_post!(\n+                    &self,\n+                    type_alias_impl_trait,\n+                    ii.span,\n+                    \"`impl Trait` in type aliases is unstable\"\n+                );\n+            }\n+            ast::ImplItemKind::TyAlias(_) => {\n+                if !ii.generics.params.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ii.span,\n+                                       \"generic associated types are unstable\");\n+                }\n+                if !ii.generics.where_clause.predicates.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ii.span,\n+                                       \"where clauses on associated types are unstable\");\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_impl_item(self, ii)\n+    }\n+\n+    fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n+        if let ast::VisibilityKind::Crate(ast::CrateSugar::JustCrate) = vis.node {\n+            gate_feature_post!(&self, crate_visibility_modifier, vis.span,\n+                               \"`crate` visibility modifier is experimental\");\n+        }\n+        visit::walk_vis(self, vis)\n+    }\n+}\n+\n+pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n+                    crate_edition: Edition, allow_features: &Option<Vec<String>>) -> Features {\n+    fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n+        let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n+        if let Some(reason) = reason {\n+            err.span_note(span, reason);\n+        } else {\n+            err.span_label(span, \"feature has been removed\");\n+        }\n+        err.emit();\n+    }\n+\n+    let mut features = Features::new();\n+    let mut edition_enabled_features = FxHashMap::default();\n+\n+    for &edition in ALL_EDITIONS {\n+        if edition <= crate_edition {\n+            // The `crate_edition` implies its respective umbrella feature-gate\n+            // (i.e., `#![feature(rust_20XX_preview)]` isn't needed on edition 20XX).\n+            edition_enabled_features.insert(edition.feature_name(), edition);\n+        }\n+    }\n+\n+    for &(name, .., f_edition, set) in ACTIVE_FEATURES {\n+        if let Some(f_edition) = f_edition {\n+            if f_edition <= crate_edition {\n+                set(&mut features, DUMMY_SP);\n+                edition_enabled_features.insert(name, crate_edition);\n+            }\n+        }\n+    }\n+\n+    // Process the edition umbrella feature-gates first, to ensure\n+    // `edition_enabled_features` is completed before it's queried.\n+    for attr in krate_attrs {\n+        if !attr.check_name(sym::feature) {\n+            continue\n+        }\n+\n+        let list = match attr.meta_item_list() {\n+            Some(list) => list,\n+            None => continue,\n+        };\n+\n+        for mi in list {\n+            if !mi.is_word() {\n+                continue;\n+            }\n+\n+            let name = mi.name_or_empty();\n+\n+            if let Some(edition) = ALL_EDITIONS.iter().find(|e| name == e.feature_name()) {\n+                if *edition <= crate_edition {\n+                    continue;\n+                }\n+\n+                for &(name, .., f_edition, set) in ACTIVE_FEATURES {\n+                    if let Some(f_edition) = f_edition {\n+                        if f_edition <= *edition {\n+                            // FIXME(Manishearth) there is currently no way to set\n+                            // lib features by edition\n+                            set(&mut features, DUMMY_SP);\n+                            edition_enabled_features.insert(name, *edition);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    for attr in krate_attrs {\n+        if !attr.check_name(sym::feature) {\n+            continue\n+        }\n+\n+        let list = match attr.meta_item_list() {\n+            Some(list) => list,\n+            None => continue,\n+        };\n+\n+        let bad_input = |span| {\n+            struct_span_err!(span_handler, span, E0556, \"malformed `feature` attribute input\")\n+        };\n+\n+        for mi in list {\n+            let name = match mi.ident() {\n+                Some(ident) if mi.is_word() => ident.name,\n+                Some(ident) => {\n+                    bad_input(mi.span()).span_suggestion(\n+                        mi.span(),\n+                        \"expected just one word\",\n+                        format!(\"{}\", ident.name),\n+                        Applicability::MaybeIncorrect,\n+                    ).emit();\n+                    continue\n+                }\n+                None => {\n+                    bad_input(mi.span()).span_label(mi.span(), \"expected just one word\").emit();\n+                    continue\n+                }\n+            };\n+\n+            if let Some(edition) = edition_enabled_features.get(&name) {\n+                struct_span_warn!(\n+                    span_handler,\n+                    mi.span(),\n+                    E0705,\n+                    \"the feature `{}` is included in the Rust {} edition\",\n+                    name,\n+                    edition,\n+                ).emit();\n+                continue;\n+            }\n+\n+            if ALL_EDITIONS.iter().any(|e| name == e.feature_name()) {\n+                // Handled in the separate loop above.\n+                continue;\n+            }\n+\n+            let removed = REMOVED_FEATURES.iter().find(|f| name == f.0);\n+            let stable_removed = STABLE_REMOVED_FEATURES.iter().find(|f| name == f.0);\n+            if let Some((.., reason)) = removed.or(stable_removed) {\n+                feature_removed(span_handler, mi.span(), *reason);\n+                continue;\n+            }\n+\n+            if let Some((_, since, ..)) = ACCEPTED_FEATURES.iter().find(|f| name == f.0) {\n+                let since = Some(Symbol::intern(since));\n+                features.declared_lang_features.push((name, mi.span(), since));\n+                continue;\n+            }\n+\n+            if let Some(allowed) = allow_features.as_ref() {\n+                if allowed.iter().find(|f| *f == name.as_str()).is_none() {\n+                    span_err!(span_handler, mi.span(), E0725,\n+                              \"the feature `{}` is not in the list of allowed features\",\n+                              name);\n+                    continue;\n+                }\n+            }\n+\n+            if let Some((.., set)) = ACTIVE_FEATURES.iter().find(|f| name == f.0) {\n+                set(&mut features, mi.span());\n+                features.declared_lang_features.push((name, mi.span(), None));\n+                continue;\n+            }\n+\n+            features.declared_lib_features.push((name, mi.span()));\n+        }\n+    }\n+\n+    features\n+}\n+\n+pub fn check_crate(krate: &ast::Crate,\n+                   sess: &ParseSess,\n+                   features: &Features,\n+                   plugin_attributes: &[(Symbol, AttributeType)],\n+                   unstable: UnstableFeatures) {\n+    maybe_stage_features(&sess.span_diagnostic, krate, unstable);\n+    let ctx = Context {\n+        features,\n+        parse_sess: sess,\n+        plugin_attributes,\n+    };\n+\n+    macro_rules! gate_all {\n+        ($gate:ident, $msg:literal) => { gate_all!($gate, $gate, $msg); };\n+        ($spans:ident, $gate:ident, $msg:literal) => {\n+            for span in &*sess.gated_spans.$spans.borrow() {\n+                gate_feature!(&ctx, $gate, *span, $msg);\n+            }\n+        }\n+    }\n+\n+    gate_all!(param_attrs, \"attributes on function parameters are unstable\");\n+    gate_all!(let_chains, \"`let` expressions in this position are experimental\");\n+    gate_all!(async_closure, \"async closures are unstable\");\n+    gate_all!(yields, generators, \"yield syntax is experimental\");\n+    gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n+\n+    let visitor = &mut PostExpansionVisitor {\n+        context: &ctx,\n+        builtin_attributes: &*BUILTIN_ATTRIBUTE_MAP,\n+    };\n+    visit::walk_crate(visitor, krate);\n+}\n+\n+#[derive(Clone, Copy, Hash)]\n+pub enum UnstableFeatures {\n+    /// Hard errors for unstable features are active, as on beta/stable channels.\n+    Disallow,\n+    /// Allow features to be activated, as on nightly.\n+    Allow,\n+    /// Errors are bypassed for bootstrapping. This is required any time\n+    /// during the build that feature-related lints are set to warn or above\n+    /// because the build turns on warnings-as-errors and uses lots of unstable\n+    /// features. As a result, this is always required for building Rust itself.\n+    Cheat\n+}\n+\n+impl UnstableFeatures {\n+    pub fn from_environment() -> UnstableFeatures {\n+        // Whether this is a feature-staged build, i.e., on the beta or stable channel\n+        let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+        // Whether we should enable unstable features for bootstrapping\n+        let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n+        match (disable_unstable_features, bootstrap) {\n+            (_, true) => UnstableFeatures::Cheat,\n+            (true, _) => UnstableFeatures::Disallow,\n+            (false, _) => UnstableFeatures::Allow\n+        }\n+    }\n+\n+    pub fn is_nightly_build(&self) -> bool {\n+        match *self {\n+            UnstableFeatures::Allow | UnstableFeatures::Cheat => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate, unstable: UnstableFeatures) {\n+    let allow_features = match unstable {\n+        UnstableFeatures::Allow => true,\n+        UnstableFeatures::Disallow => false,\n+        UnstableFeatures::Cheat => true\n+    };\n+    if !allow_features {\n+        for attr in &krate.attrs {\n+            if attr.check_name(sym::feature) {\n+                let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n+                span_err!(span_handler, attr.span, E0554,\n+                          \"`#![feature]` may not be used on the {} release channel\",\n+                          release_channel);\n+            }\n+        }\n+    }\n+}"}, {"sha": "97793bca1f5891ad5520b5d8e00f76c99c4337cd", "filename": "src/libsyntax/feature_gate/mod.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fmod.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,31 @@\n+//! # Feature gating\n+//!\n+//! This module implements the gating necessary for preventing certain compiler\n+//! features from being used by default. This module will crawl a pre-expanded\n+//! AST to ensure that there are no features which are used that are not\n+//! enabled.\n+//!\n+//! Features are enabled in programs via the crate-level attributes of\n+//! `#![feature(...)]` with a comma-separated list of features.\n+//!\n+//! For the purpose of future feature-tracking, once code for detection of feature\n+//! gate usage is added, *do not remove it again* even once the feature\n+//! becomes stable.\n+\n+mod accepted;\n+mod removed;\n+mod active;\n+mod builtin_attrs;\n+mod check;\n+\n+pub use active::{Features, INCOMPLETE_FEATURES};\n+pub use builtin_attrs::{\n+    AttributeGate, AttributeType, GatedCfg,\n+    BuiltinAttribute, BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n+    deprecated_attributes, is_builtin_attr,  is_builtin_attr_name,\n+};\n+pub use check::{\n+    check_attribute, check_crate, get_features, feature_err, emit_feature_err,\n+    Stability, GateIssue, UnstableFeatures,\n+    EXPLAIN_STMT_ATTR_SYNTAX, EXPLAIN_UNSIZED_TUPLE_COERCION,\n+};"}, {"sha": "6ebfeb29f677ba8ceea1819a6371dc2b5f44ad59", "filename": "src/libsyntax/feature_gate/removed.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,82 @@\n+//! List of the removed feature gates.\n+\n+use crate::symbol::{Symbol, sym};\n+\n+macro_rules! declare_features {\n+    ($((removed, $feature: ident, $ver: expr, $issue: expr, None, $reason: expr),)+) => {\n+        /// Represents unstable features which have since been removed (it was once Active)\n+        pub const REMOVED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, $reason)),+\n+        ];\n+    };\n+\n+    ($((stable_removed, $feature: ident, $ver: expr, $issue: expr, None),)+) => {\n+        /// Represents stable features which have since been removed (it was once Accepted)\n+        pub const STABLE_REMOVED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, None)),+\n+        ];\n+    };\n+}\n+\n+declare_features! (\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: removed features\n+    // -------------------------------------------------------------------------\n+\n+    (removed, import_shadowing, \"1.0.0\", None, None, None),\n+    (removed, managed_boxes, \"1.0.0\", None, None, None),\n+    // Allows use of unary negate on unsigned integers, e.g., -e for e: u8\n+    (removed, negate_unsigned, \"1.0.0\", Some(29645), None, None),\n+    (removed, reflect, \"1.0.0\", Some(27749), None, None),\n+    // A way to temporarily opt out of opt in copy. This will *never* be accepted.\n+    (removed, opt_out_copy, \"1.0.0\", None, None, None),\n+    (removed, quad_precision_float, \"1.0.0\", None, None, None),\n+    (removed, struct_inherit, \"1.0.0\", None, None, None),\n+    (removed, test_removed_feature, \"1.0.0\", None, None, None),\n+    (removed, visible_private_types, \"1.0.0\", None, None, None),\n+    (removed, unsafe_no_drop_flag, \"1.0.0\", None, None, None),\n+    // Allows using items which are missing stability attributes\n+    (removed, unmarked_api, \"1.0.0\", None, None, None),\n+    (removed, allocator, \"1.0.0\", None, None, None),\n+    (removed, simd, \"1.0.0\", Some(27731), None,\n+     Some(\"removed in favor of `#[repr(simd)]`\")),\n+    (removed, advanced_slice_patterns, \"1.0.0\", Some(62254), None,\n+     Some(\"merged into `#![feature(slice_patterns)]`\")),\n+    (removed, macro_reexport, \"1.0.0\", Some(29638), None,\n+     Some(\"subsumed by `pub use`\")),\n+    (removed, pushpop_unsafe, \"1.2.0\", None, None, None),\n+    (removed, needs_allocator, \"1.4.0\", Some(27389), None,\n+     Some(\"subsumed by `#![feature(allocator_internals)]`\")),\n+    (removed, proc_macro_mod, \"1.27.0\", Some(54727), None,\n+     Some(\"subsumed by `#![feature(proc_macro_hygiene)]`\")),\n+    (removed, proc_macro_expr, \"1.27.0\", Some(54727), None,\n+     Some(\"subsumed by `#![feature(proc_macro_hygiene)]`\")),\n+    (removed, proc_macro_non_items, \"1.27.0\", Some(54727), None,\n+     Some(\"subsumed by `#![feature(proc_macro_hygiene)]`\")),\n+    (removed, proc_macro_gen, \"1.27.0\", Some(54727), None,\n+     Some(\"subsumed by `#![feature(proc_macro_hygiene)]`\")),\n+    (removed, panic_implementation, \"1.28.0\", Some(44489), None,\n+     Some(\"subsumed by `#[panic_handler]`\")),\n+    // Allows the use of `#[derive(Anything)]` as sugar for `#[derive_Anything]`.\n+    (removed, custom_derive, \"1.32.0\", Some(29644), None,\n+     Some(\"subsumed by `#[proc_macro_derive]`\")),\n+    // Paths of the form: `extern::foo::bar`\n+    (removed, extern_in_paths, \"1.33.0\", Some(55600), None,\n+     Some(\"subsumed by `::foo::bar` paths\")),\n+    (removed, quote, \"1.33.0\", Some(29601), None, None),\n+    // Allows using `#[unsafe_destructor_blind_to_params]` (RFC 1238).\n+    (removed, dropck_parametricity, \"1.38.0\", Some(28498), None, None),\n+    (removed, await_macro, \"1.38.0\", Some(50547), None,\n+     Some(\"subsumed by `.await` syntax\")),\n+    // Allows defining `existential type`s.\n+    (removed, existential_type, \"1.38.0\", Some(63063), None,\n+     Some(\"removed in favor of `#![feature(type_alias_impl_trait)]`\")),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: removed features\n+    // -------------------------------------------------------------------------\n+);\n+\n+declare_features! (\n+    (stable_removed, no_stack_check, \"1.0.0\", None, None),\n+);"}, {"sha": "1741932c1b80e30f86abfe47d345b37678f24068", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -124,7 +124,6 @@ pub mod diagnostics {\n     #[macro_use]\n     pub mod macros;\n     pub mod plugin;\n-    pub mod metadata;\n }\n \n // N.B., this module needs to be declared first so diagnostics are"}, {"sha": "c703058e7952de818f5dbb79ad4b45eeaaf1bc26", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -21,9 +21,8 @@ const DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG: &str = \"an inner attribute is not \\\n impl<'a> Parser<'a> {\n     crate fn parse_arg_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let attrs = self.parse_outer_attributes()?;\n-        attrs.iter().for_each(|a|\n-            self.sess.param_attr_spans.borrow_mut().push(a.span)\n-        );\n+        self.sess.gated_spans.param_attrs.borrow_mut()\n+            .extend(attrs.iter().map(|a| a.span));\n         Ok(attrs)\n     }\n "}, {"sha": "b1af4806e2d787dde3b9f17b200550fc42931834", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -39,6 +39,22 @@ crate mod unescape_error_reporting;\n \n pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n \n+/// Collected spans during parsing for places where a certain feature was\n+/// used and should be feature gated accordingly in `check_crate`.\n+#[derive(Default)]\n+pub struct GatedSpans {\n+    /// Spans collected for gating `param_attrs`, e.g. `fn foo(#[attr] x: u8) {}`.\n+    pub param_attrs: Lock<Vec<Span>>,\n+    /// Spans collected for gating `let_chains`, e.g. `if a && let b = c {}`.\n+    pub let_chains: Lock<Vec<Span>>,\n+    /// Spans collected for gating `async_closure`, e.g. `async || ..`.\n+    pub async_closure: Lock<Vec<Span>>,\n+    /// Spans collected for gating `yield e?` expressions (`generators` gate).\n+    pub yields: Lock<Vec<Span>>,\n+    /// Spans collected for gating `or_patterns`, e.g. `Some(Foo | Bar)`.\n+    pub or_patterns: Lock<Vec<Span>>,\n+}\n+\n /// Info about a parsing session.\n pub struct ParseSess {\n     pub span_diagnostic: Handler,\n@@ -58,16 +74,8 @@ pub struct ParseSess {\n     /// operation token that followed it, but that the parser cannot identify without further\n     /// analysis.\n     pub ambiguous_block_expr_parse: Lock<FxHashMap<Span, Span>>,\n-    pub param_attr_spans: Lock<Vec<Span>>,\n-    // Places where `let` exprs were used and should be feature gated according to `let_chains`.\n-    pub let_chains_spans: Lock<Vec<Span>>,\n-    // Places where `async || ..` exprs were used and should be feature gated.\n-    pub async_closure_spans: Lock<Vec<Span>>,\n-    // Places where `yield e?` exprs were used and should be feature gated.\n-    pub yield_spans: Lock<Vec<Span>>,\n     pub injected_crate_name: Once<Symbol>,\n-    // Places where or-patterns e.g. `Some(Foo | Bar)` were used and should be feature gated.\n-    pub or_pattern_spans: Lock<Vec<Span>>,\n+    pub gated_spans: GatedSpans,\n }\n \n impl ParseSess {\n@@ -93,12 +101,8 @@ impl ParseSess {\n             buffered_lints: Lock::new(vec![]),\n             edition: ExpnId::root().expn_data().edition,\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n-            param_attr_spans: Lock::new(Vec::new()),\n-            let_chains_spans: Lock::new(Vec::new()),\n-            async_closure_spans: Lock::new(Vec::new()),\n-            yield_spans: Lock::new(Vec::new()),\n             injected_crate_name: Once::new(),\n-            or_pattern_spans: Lock::new(Vec::new()),\n+            gated_spans: GatedSpans::default(),\n         }\n     }\n "}, {"sha": "5da9b75d53b045cfb2b8deb6bc1ee6ab56322197", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -999,7 +999,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     let span = lo.to(hi);\n-                    self.sess.yield_spans.borrow_mut().push(span);\n+                    self.sess.gated_spans.yields.borrow_mut().push(span);\n                 } else if self.eat_keyword(kw::Let) {\n                     return self.parse_let_expr(attrs);\n                 } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n@@ -1111,7 +1111,7 @@ impl<'a> Parser<'a> {\n         };\n         if asyncness.is_async() {\n             // Feature gate `async ||` closures.\n-            self.sess.async_closure_spans.borrow_mut().push(self.prev_span);\n+            self.sess.gated_spans.async_closure.borrow_mut().push(self.prev_span);\n         }\n \n         let capture_clause = self.parse_capture_clause();\n@@ -1234,7 +1234,7 @@ impl<'a> Parser<'a> {\n \n         if let ExprKind::Let(..) = cond.node {\n             // Remove the last feature gating of a `let` expression since it's stable.\n-            let last = self.sess.let_chains_spans.borrow_mut().pop();\n+            let last = self.sess.gated_spans.let_chains.borrow_mut().pop();\n             debug_assert_eq!(cond.span, last.unwrap());\n         }\n \n@@ -1252,7 +1252,7 @@ impl<'a> Parser<'a> {\n             |this| this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         )?;\n         let span = lo.to(expr.span);\n-        self.sess.let_chains_spans.borrow_mut().push(span);\n+        self.sess.gated_spans.let_chains.borrow_mut().push(span);\n         Ok(self.mk_expr(span, ExprKind::Let(pats, expr), attrs))\n     }\n "}, {"sha": "03d7e9221238245ab61014040fb4330bdb5f4643", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -825,6 +825,7 @@ impl<'a> Parser<'a> {\n             self.is_keyword_ahead(1, &[\n                 kw::Impl,\n                 kw::Const,\n+                kw::Async,\n                 kw::Fn,\n                 kw::Unsafe,\n                 kw::Extern,"}, {"sha": "8cfa6abbe6270e7181a337791940c90f98e5bfe1", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -123,7 +123,7 @@ impl<'a> Parser<'a> {\n \n         let or_pattern_span = lo.to(self.prev_span);\n \n-        self.sess.or_pattern_spans.borrow_mut().push(or_pattern_span);\n+        self.sess.gated_spans.or_patterns.borrow_mut().push(or_pattern_span);\n \n         Ok(self.mk_pat(or_pattern_span, PatKind::Or(pats)))\n     }"}, {"sha": "0d9f3769ce90447133c3e3a548eaaf60406ec789", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -19,7 +19,7 @@ use crate::parse::Directory;\n use crate::parse::token::{self, DelimToken, Token, TokenKind};\n use crate::print::pprust;\n \n-use syntax_pos::{BytePos, ExpnId, Span, DUMMY_SP};\n+use syntax_pos::{BytePos, Span, DUMMY_SP};\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert_size;\n use rustc_data_structures::sync::Lrc;\n@@ -547,11 +547,4 @@ impl DelimSpan {\n     pub fn entire(self) -> Span {\n         self.open.with_hi(self.close.hi())\n     }\n-\n-    pub fn apply_mark(self, expn_id: ExpnId) -> Self {\n-        DelimSpan {\n-            open: self.open.apply_mark(expn_id),\n-            close: self.close.apply_mark(expn_id),\n-        }\n-    }\n }"}, {"sha": "28f907441d872391f8d3eb17aa98b9b3c13fd81c", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -63,7 +63,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprKind::InlineAsm(P(inline_asm)),\n-        span: sp.with_ctxt(cx.backtrace()),\n+        span: cx.with_legacy_ctxt(sp),\n         attrs: ThinVec::new(),\n     }))\n }"}, {"sha": "84583d0e5eca7410e2e23a0afd448386c2cc1f1b", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -23,7 +23,7 @@ pub fn expand_assert<'cx>(\n         }\n     };\n \n-    let sp = sp.apply_mark(cx.current_expansion.id);\n+    let sp = cx.with_legacy_ctxt(sp);\n     let panic_call = Mac {\n         path: Path::from_ident(Ident::new(sym::panic, sp)),\n         tts: custom_message.unwrap_or_else(|| {"}, {"sha": "21cee8ae1cb9c661c630ee9f788450e5d4d93aab", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -16,7 +16,7 @@ pub fn expand_cfg(\n     sp: Span,\n     tts: &[tokenstream::TokenTree],\n ) -> Box<dyn base::MacResult + 'static> {\n-    let sp = sp.apply_mark(cx.current_expansion.id);\n+    let sp = cx.with_legacy_ctxt(sp);\n \n     match parse_cfg(cx, sp, tts) {\n         Ok(cfg) => {"}, {"sha": "ffa5154ca0c36b6cc1b03e2ae57b9be7303b7039", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -59,6 +59,6 @@ pub fn expand_syntax_ext(\n     } else if has_errors {\n         return DummyResult::any(sp);\n     }\n-    let sp = sp.apply_mark(cx.current_expansion.id);\n+    let sp = cx.with_legacy_ctxt(sp);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&accumulator)))\n }"}, {"sha": "96677072d1b80bfc153e2fd2ac96afbc9570665e", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -39,7 +39,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         }\n     }\n \n-    let ident = ast::Ident::new(Symbol::intern(&res_str), sp.apply_mark(cx.current_expansion.id));\n+    let ident = ast::Ident::new(Symbol::intern(&res_str), cx.with_legacy_ctxt(sp));\n \n     struct ConcatIdentsResult { ident: ast::Ident }\n "}, {"sha": "4dd0ecfebefd41d8ed260dbfd459834469870868", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -112,7 +112,7 @@ fn cs_clone_shallow(name: &str,\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n-        let span = span.with_ctxt(cx.backtrace());\n+        let span = cx.with_def_site_ctxt(span);\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[sym::clone, Symbol::intern(helper_name)]),\n                                         vec![GenericArg::Type(ty)], vec![]);"}, {"sha": "32ab47969ada4f6c9f36640d5eac0fb162904852", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -53,7 +53,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt<'_>,\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n-        let span = span.with_ctxt(cx.backtrace());\n+        let span = cx.with_def_site_ctxt(span);\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[sym::cmp, Symbol::intern(helper_name)]),\n                                         vec![GenericArg::Type(ty)], vec![]);"}, {"sha": "781645a574e9ac76993e70aa86b86c713b1bfb04", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -60,7 +60,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     };\n \n     // We want to make sure we have the ctxt set so that we can use unstable methods\n-    let span = span.with_ctxt(cx.backtrace());\n+    let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n     let builder = Ident::from_str_and_span(\"debug_trait_builder\", span);\n     let builder_expr = cx.expr_ident(span, builder.clone());"}, {"sha": "cb1c7b21fee0d21b0b932c4f2ebac161ede26273", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -85,7 +85,7 @@ impl<'a> Path<'a> {\n             PathKind::Global => cx.path_all(span, true, idents, params, Vec::new()),\n             PathKind::Local => cx.path_all(span, false, idents, params, Vec::new()),\n             PathKind::Std => {\n-                let def_site = DUMMY_SP.apply_mark(cx.current_expansion.id);\n+                let def_site = cx.with_def_site_ctxt(DUMMY_SP);\n                 idents.insert(0, Ident::new(kw::DollarCrate, def_site));\n                 cx.path_all(span, false, idents, params, Vec::new())\n             }"}, {"sha": "60b6eba7a4b53d54baa4a6505c600cddf69674e7", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -48,6 +48,9 @@ impl MultiItemModifier for BuiltinDerive {\n               meta_item: &MetaItem,\n               item: Annotatable)\n               -> Vec<Annotatable> {\n+        // FIXME: Built-in derives often forget to give spans contexts,\n+        // so we are doing it here in a centralized way.\n+        let span = ecx.with_def_site_ctxt(span);\n         let mut items = Vec::new();\n         (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n         items\n@@ -60,7 +63,7 @@ fn call_intrinsic(cx: &ExtCtxt<'_>,\n                   intrinsic: &str,\n                   args: Vec<P<ast::Expr>>)\n                   -> P<ast::Expr> {\n-    let span = span.with_ctxt(cx.backtrace());\n+    let span = cx.with_def_site_ctxt(span);\n     let path = cx.std_path(&[sym::intrinsics, Symbol::intern(intrinsic)]);\n     let call = cx.expr_call_global(span, path, args);\n "}, {"sha": "6343d218de82921520e4c3e9f50b316234ef3d8e", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -20,7 +20,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         Some(v) => v,\n     };\n \n-    let sp = sp.apply_mark(cx.current_expansion.id);\n+    let sp = cx.with_legacy_ctxt(sp);\n     let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n             let lt = cx.lifetime(sp, Ident::with_dummy_span(kw::StaticLifetime));"}, {"sha": "47394c02b4186cca294de29f49f7ba9180f4be09", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -12,7 +12,7 @@ use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, sym};\n use syntax::tokenstream;\n-use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n+use syntax_pos::{MultiSpan, Span};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::borrow::Cow;\n@@ -666,8 +666,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         // passed to this function.\n         for (i, e) in self.args.into_iter().enumerate() {\n             let name = names_pos[i];\n-            let span =\n-                DUMMY_SP.with_ctxt(e.span.ctxt().apply_mark(self.ecx.current_expansion.id));\n+            let span = self.ecx.with_def_site_ctxt(e.span);\n             pats.push(self.ecx.pat_ident(span, name));\n             for ref arg_ty in self.arg_unique_types[i].iter() {\n                 locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty, name));\n@@ -745,7 +744,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         ty: &ArgumentType,\n         arg: ast::Ident,\n     ) -> P<ast::Expr> {\n-        sp = sp.apply_mark(ecx.current_expansion.id);\n+        sp = ecx.with_def_site_ctxt(sp);\n         let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n             Placeholder(ref tyname) => {\n@@ -798,7 +797,7 @@ fn expand_format_args_impl<'cx>(\n     tts: &[tokenstream::TokenTree],\n     nl: bool,\n ) -> Box<dyn base::MacResult + 'cx> {\n-    sp = sp.apply_mark(ecx.current_expansion.id);\n+    sp = ecx.with_def_site_ctxt(sp);\n     match parse_args(ecx, sp, tts) {\n         Ok((efmt, args, names)) => {\n             MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names, nl))\n@@ -842,7 +841,7 @@ pub fn expand_preparsed_format_args(\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n \n     let mut macsp = ecx.call_site();\n-    macsp = macsp.with_ctxt(ecx.backtrace());\n+    macsp = ecx.with_def_site_ctxt(macsp);\n \n     let msg = \"format argument must be a string literal\";\n     let fmt_sp = efmt.span;"}, {"sha": "97b8087ad1581647656716e0275bf6b9bcc6026b", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,7 +3,6 @@ use syntax::ast::{self, Arg, Attribute, Expr, FnHeader, Generics, Ident};\n use syntax::attr::check_builtin_macro_attribute;\n use syntax::ext::allocator::{AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n@@ -29,7 +28,7 @@ pub fn expand(\n     };\n \n     // Generate a bunch of new items using the AllocFnFactory\n-    let span = item.span.with_ctxt(SyntaxContext::root().apply_mark(ecx.current_expansion.id));\n+    let span = ecx.with_legacy_ctxt(item.span);\n     let f = AllocFnFactory {\n         span,\n         kind: AllocatorKind::Global,"}, {"sha": "a8b61593db749a1b04a62c817e4acce39f26bf35", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -30,7 +30,7 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ItemKind::GlobalAsm(P(global_asm)),\n                 vis: respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-                span: sp.with_ctxt(cx.backtrace()),\n+                span: cx.with_legacy_ctxt(sp),\n                 tokens: None,\n             })])\n         }"}, {"sha": "5fd87d3a0e5c60d45f3c8296880cd10a973045b5", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4,7 +4,6 @@\n use syntax::ast;\n use syntax::attr::{self, check_builtin_macro_attribute};\n use syntax::ext::base::*;\n-use syntax::ext::hygiene::SyntaxContext;\n use syntax::print::pprust;\n use syntax::source_map::respan;\n use syntax::symbol::{Symbol, sym};\n@@ -29,7 +28,7 @@ pub fn expand_test_case(\n \n     if !ecx.ecfg.should_test { return vec![]; }\n \n-    let sp = attr_sp.with_ctxt(SyntaxContext::root().apply_mark(ecx.current_expansion.id));\n+    let sp = ecx.with_legacy_ctxt(attr_sp);\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n@@ -93,8 +92,7 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let ctxt = SyntaxContext::root().apply_mark(cx.current_expansion.id);\n-    let (sp, attr_sp) = (item.span.with_ctxt(ctxt), attr_sp.with_ctxt(ctxt));\n+    let (sp, attr_sp) = (cx.with_legacy_ctxt(item.span), cx.with_legacy_ctxt(attr_sp));\n \n     // Gensym \"test\" so we can extern crate without conflicting with any local names\n     let test_id = cx.ident_of(\"test\").gensym();"}, {"sha": "733f6f0449065c6cfc157802fa66c345631022ac", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 29, "deletions": 51, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -119,18 +119,6 @@ impl ExpnId {\n     pub fn outer_expn_is_descendant_of(self, ctxt: SyntaxContext) -> bool {\n         HygieneData::with(|data| data.is_descendant_of(self, data.outer_expn(ctxt)))\n     }\n-\n-    // Used for enabling some compatibility fallback in resolve.\n-    #[inline]\n-    pub fn looks_like_proc_macro_derive(self) -> bool {\n-        HygieneData::with(|data| {\n-            let expn_data = data.expn_data(self);\n-            if let ExpnKind::Macro(MacroKind::Derive, _) = expn_data.kind {\n-                return expn_data.default_transparency == Transparency::Opaque;\n-            }\n-            false\n-        })\n-    }\n }\n \n #[derive(Debug)]\n@@ -195,24 +183,25 @@ impl HygieneData {\n         self.syntax_context_data[ctxt.0 as usize].outer_expn\n     }\n \n-    fn outer_transparency(&self, ctxt: SyntaxContext) -> Transparency {\n-        self.syntax_context_data[ctxt.0 as usize].outer_transparency\n+    fn outer_mark(&self, ctxt: SyntaxContext) -> (ExpnId, Transparency) {\n+        let data = &self.syntax_context_data[ctxt.0 as usize];\n+        (data.outer_expn, data.outer_transparency)\n     }\n \n     fn parent_ctxt(&self, ctxt: SyntaxContext) -> SyntaxContext {\n         self.syntax_context_data[ctxt.0 as usize].parent\n     }\n \n-    fn remove_mark(&self, ctxt: &mut SyntaxContext) -> ExpnId {\n-        let outer_expn = self.outer_expn(*ctxt);\n+    fn remove_mark(&self, ctxt: &mut SyntaxContext) -> (ExpnId, Transparency) {\n+        let outer_mark = self.outer_mark(*ctxt);\n         *ctxt = self.parent_ctxt(*ctxt);\n-        outer_expn\n+        outer_mark\n     }\n \n     fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(ExpnId, Transparency)> {\n         let mut marks = Vec::new();\n         while ctxt != SyntaxContext::root() {\n-            marks.push((self.outer_expn(ctxt), self.outer_transparency(ctxt)));\n+            marks.push(self.outer_mark(ctxt));\n             ctxt = self.parent_ctxt(ctxt);\n         }\n         marks.reverse();\n@@ -229,20 +218,14 @@ impl HygieneData {\n     fn adjust(&self, ctxt: &mut SyntaxContext, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut scope = None;\n         while !self.is_descendant_of(expn_id, self.outer_expn(*ctxt)) {\n-            scope = Some(self.remove_mark(ctxt));\n+            scope = Some(self.remove_mark(ctxt).0);\n         }\n         scope\n     }\n \n-    fn apply_mark(&mut self, ctxt: SyntaxContext, expn_id: ExpnId) -> SyntaxContext {\n-        assert_ne!(expn_id, ExpnId::root());\n-        self.apply_mark_with_transparency(\n-            ctxt, expn_id, self.expn_data(expn_id).default_transparency\n-        )\n-    }\n-\n-    fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, expn_id: ExpnId,\n-                                    transparency: Transparency) -> SyntaxContext {\n+    fn apply_mark(\n+        &mut self, ctxt: SyntaxContext, expn_id: ExpnId, transparency: Transparency\n+    ) -> SyntaxContext {\n         assert_ne!(expn_id, ExpnId::root());\n         if transparency == Transparency::Opaque {\n             return self.apply_mark_internal(ctxt, expn_id, transparency);\n@@ -376,15 +359,9 @@ impl SyntaxContext {\n         SyntaxContext(raw)\n     }\n \n-    /// Extend a syntax context with a given expansion and default transparency for that expansion.\n-    pub fn apply_mark(self, expn_id: ExpnId) -> SyntaxContext {\n-        HygieneData::with(|data| data.apply_mark(self, expn_id))\n-    }\n-\n     /// Extend a syntax context with a given expansion and transparency.\n-    pub fn apply_mark_with_transparency(self, expn_id: ExpnId, transparency: Transparency)\n-                                        -> SyntaxContext {\n-        HygieneData::with(|data| data.apply_mark_with_transparency(self, expn_id, transparency))\n+    pub fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n+        HygieneData::with(|data| data.apply_mark(self, expn_id, transparency))\n     }\n \n     /// Pulls a single mark off of the syntax context. This effectively moves the\n@@ -404,7 +381,7 @@ impl SyntaxContext {\n     /// invocation of f that created g1.\n     /// Returns the mark that was removed.\n     pub fn remove_mark(&mut self) -> ExpnId {\n-        HygieneData::with(|data| data.remove_mark(self))\n+        HygieneData::with(|data| data.remove_mark(self).0)\n     }\n \n     pub fn marks(self) -> Vec<(ExpnId, Transparency)> {\n@@ -477,8 +454,8 @@ impl SyntaxContext {\n             let mut scope = None;\n             let mut glob_ctxt = data.modern(glob_span.ctxt());\n             while !data.is_descendant_of(expn_id, data.outer_expn(glob_ctxt)) {\n-                scope = Some(data.remove_mark(&mut glob_ctxt));\n-                if data.remove_mark(self) != scope.unwrap() {\n+                scope = Some(data.remove_mark(&mut glob_ctxt).0);\n+                if data.remove_mark(self).0 != scope.unwrap() {\n                     return None;\n                 }\n             }\n@@ -509,9 +486,9 @@ impl SyntaxContext {\n                 marks.push(data.remove_mark(&mut glob_ctxt));\n             }\n \n-            let scope = marks.last().cloned();\n-            while let Some(mark) = marks.pop() {\n-                *self = data.apply_mark(*self, mark);\n+            let scope = marks.last().map(|mark| mark.0);\n+            while let Some((expn_id, transparency)) = marks.pop() {\n+                *self = data.apply_mark(*self, expn_id, transparency);\n             }\n             Some(scope)\n         })\n@@ -547,13 +524,11 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.expn_data(data.outer_expn(self)).clone())\n     }\n \n-    /// `ctxt.outer_expn_with_data()` is equivalent to but faster than\n-    /// `{ let outer = ctxt.outer_expn(); (outer, outer.expn_data()) }`.\n     #[inline]\n-    pub fn outer_expn_with_data(self) -> (ExpnId, ExpnData) {\n+    pub fn outer_mark_with_data(self) -> (ExpnId, Transparency, ExpnData) {\n         HygieneData::with(|data| {\n-            let outer = data.outer_expn(self);\n-            (outer, data.expn_data(outer).clone())\n+            let (expn_id, transparency) = data.outer_mark(self);\n+            (expn_id, transparency, data.expn_data(expn_id).clone())\n         })\n     }\n \n@@ -575,9 +550,15 @@ impl Span {\n     /// The returned span belongs to the created expansion and has the new properties,\n     /// but its location is inherited from the current span.\n     pub fn fresh_expansion(self, expn_data: ExpnData) -> Span {\n+        self.fresh_expansion_with_transparency(expn_data, Transparency::SemiTransparent)\n+    }\n+\n+    pub fn fresh_expansion_with_transparency(\n+        self, expn_data: ExpnData, transparency: Transparency\n+    ) -> Span {\n         HygieneData::with(|data| {\n             let expn_id = data.fresh_expn(Some(expn_data));\n-            self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id))\n+            self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id, transparency))\n         })\n     }\n }\n@@ -609,8 +590,6 @@ pub struct ExpnData {\n     /// The span of the macro definition (possibly dummy).\n     /// This span serves only informational purpose and is not used for resolution.\n     pub def_site: Span,\n-    /// Transparency used by `apply_mark` for the expansion with this expansion data by default.\n-    pub default_transparency: Transparency,\n     /// List of #[unstable]/feature-gated features that the macro is allowed to use\n     /// internally without forcing the whole crate to opt-in\n     /// to them.\n@@ -633,7 +612,6 @@ impl ExpnData {\n             parent: ExpnId::root(),\n             call_site,\n             def_site: DUMMY_SP,\n-            default_transparency: Transparency::SemiTransparent,\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,"}, {"sha": "3d8bfc77a89500533316eaa19161c711445891a8", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -22,6 +22,7 @@ pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n pub use hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind, MacroKind, DesugaringKind};\n+use hygiene::Transparency;\n \n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -512,10 +513,17 @@ impl Span {\n                   span.ctxt)\n     }\n \n+    /// Produces a span with the same location as `self` and context produced by a macro with the\n+    /// given ID and transparency, assuming that macro was defined directly and not produced by\n+    /// some other macro (which is the case for built-in and procedural macros).\n+    pub fn with_ctxt_from_mark(self, expn_id: ExpnId, transparency: Transparency) -> Span {\n+        self.with_ctxt(SyntaxContext::root().apply_mark(expn_id, transparency))\n+    }\n+\n     #[inline]\n-    pub fn apply_mark(self, mark: ExpnId) -> Span {\n+    pub fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> Span {\n         let span = self.data();\n-        span.with_ctxt(span.ctxt.apply_mark(mark))\n+        span.with_ctxt(span.ctxt.apply_mark(expn_id, transparency))\n     }\n \n     #[inline]"}, {"sha": "2931e0bda95185cc5ee5a84c883276aa73f113eb", "filename": "src/libterm/Cargo.toml", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibterm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibterm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2FCargo.toml?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -5,6 +5,8 @@ version = \"0.0.0\"\n edition = \"2018\"\n \n [lib]\n-name = \"term\"\n path = \"lib.rs\"\n-crate-type = [\"dylib\", \"rlib\"]\n+\n+[dependencies]\n+core = { path = \"../libcore\" }\n+std = { path = \"../libstd\" }"}, {"sha": "170fbb984cf9b5aa7bfed063c320f24e8fe178a1", "filename": "src/libtest/Cargo.toml", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibtest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibtest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2FCargo.toml?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -10,8 +10,22 @@ path = \"lib.rs\"\n crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n-getopts = \"0.2.19\"\n+getopts = { version = \"0.2.21\", features = ['rustc-dep-of-std'] }\n term = { path = \"../libterm\" }\n+std = { path = \"../libstd\" }\n+core = { path = \"../libcore\" }\n+libc = { version = \"0.2\", default-features = false }\n+panic_unwind = { path = \"../libpanic_unwind\" }\n+panic_abort = { path = \"../libpanic_abort\" }\n \n # not actually used but needed to always have proc_macro in the sysroot\n proc_macro = { path = \"../libproc_macro\" }\n+\n+# Forward features to the `std` crate as necessary\n+[features]\n+backtrace = [\"std/backtrace\"]\n+compiler-builtins-c = [\"std/compiler-builtins-c\"]\n+llvm-libunwind = [\"std/llvm-libunwind\"]\n+panic-unwind = [\"std/panic_unwind\"]\n+panic_immediate_abort = [\"std/panic_immediate_abort\"]\n+profiler = [\"std/profiler\"]"}, {"sha": "5e0f19fe553d92c30394706dfc525433d856403d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -965,12 +965,11 @@ fn use_color(opts: &TestOpts) -> bool {\n \n #[cfg(any(\n     target_os = \"cloudabi\",\n-    target_os = \"redox\",\n     all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n     all(target_vendor = \"fortanix\", target_env = \"sgx\")\n ))]\n fn stdout_isatty() -> bool {\n-    // FIXME: Implement isatty on Redox and SGX\n+    // FIXME: Implement isatty on SGX\n     false\n }\n #[cfg(unix)]\n@@ -1193,15 +1192,15 @@ fn get_concurrency() -> usize {\n         }\n     }\n \n-    #[cfg(target_os = \"redox\")]\n+    #[cfg(target_os = \"vxworks\")]\n     fn num_cpus() -> usize {\n-        // FIXME: Implement num_cpus on Redox\n+        // FIXME: Implement num_cpus on vxWorks\n         1\n     }\n \n-    #[cfg(target_os = \"vxworks\")]\n+    #[cfg(target_os = \"redox\")]\n     fn num_cpus() -> usize {\n-        // FIXME: Implement num_cpus on vxWorks\n+        // FIXME: Implement num_cpus on Redox\n         1\n     }\n \n@@ -1221,7 +1220,7 @@ fn get_concurrency() -> usize {\n         target_os = \"ios\",\n         target_os = \"linux\",\n         target_os = \"macos\",\n-        target_os = \"solaris\"\n+        target_os = \"solaris\",\n     ))]\n     fn num_cpus() -> usize {\n         unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }"}, {"sha": "1373b12e3721c3b36fafaff227b368f14639931e", "filename": "src/test/codegen/integer-cmp.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fcodegen%2Finteger-cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fcodegen%2Finteger-cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Finteger-cmp.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,28 @@\n+// This is test for more optimal Ord implementation for integers.\n+// See <https://github.com/rust-lang/rust/issues/63758> for more info.\n+\n+// compile-flags: -C opt-level=3\n+\n+#![crate_type = \"lib\"]\n+\n+use std::cmp::Ordering;\n+\n+// CHECK-LABEL: @cmp_signed\n+#[no_mangle]\n+pub fn cmp_signed(a: i64, b: i64) -> Ordering {\n+// CHECK: icmp slt\n+// CHECK: icmp sgt\n+// CHECK: zext i1\n+// CHECK: select i1\n+    a.cmp(&b)\n+}\n+\n+// CHECK-LABEL: @cmp_unsigned\n+#[no_mangle]\n+pub fn cmp_unsigned(a: u32, b: u32) -> Ordering {\n+// CHECK: icmp ult\n+// CHECK: icmp ugt\n+// CHECK: zext i1\n+// CHECK: select i1\n+    a.cmp(&b)\n+}"}, {"sha": "7aadc8a095498a56fbe19d2e1f1b2d07ec5fb9bf", "filename": "src/test/codegen/issue-45222.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fcodegen%2Fissue-45222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fcodegen%2Fissue-45222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-45222.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -5,7 +5,6 @@\n \n // verify that LLVM recognizes a loop involving 0..=n and will const-fold it.\n \n-//------------------------------------------------------------------------------\n // Example from original issue #45222\n \n fn foo2(n: u64) -> u64 {\n@@ -25,7 +24,6 @@ pub fn check_foo2() -> u64 {\n     foo2(100000)\n }\n \n-//------------------------------------------------------------------------------\n // Simplified example of #45222\n \n fn triangle_inc(n: u64) -> u64 {\n@@ -43,7 +41,6 @@ pub fn check_triangle_inc() -> u64 {\n     triangle_inc(100000)\n }\n \n-//------------------------------------------------------------------------------\n // Demo in #48012\n \n fn foo3r(n: u64) -> u64 {"}, {"sha": "50d3657d417f38cc1a9549a429fb95501a72a3d5", "filename": "src/test/incremental/hashes/call_expressions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -18,7 +18,7 @@ fn callee1(_x: u32, _y: i64) {}\n fn callee2(_x: u32, _y: i64) {}\n \n \n-// Change Callee (Function) ----------------------------------------------------\n+// Change Callee (Function)\n #[cfg(cfail1)]\n pub fn change_callee_function() {\n     callee1(1, 2)\n@@ -33,7 +33,7 @@ pub fn change_callee_function() {\n \n \n \n-// Change Argument (Function) --------------------------------------------------\n+// Change Argument (Function)\n #[cfg(cfail1)]\n pub fn change_argument_function() {\n     callee1(1, 2)\n@@ -48,7 +48,7 @@ pub fn change_argument_function() {\n \n \n \n-// Change Callee Indirectly (Function) -----------------------------------------\n+// Change Callee Indirectly (Function)\n mod change_callee_indirectly_function {\n     #[cfg(cfail1)]\n     use super::callee1 as callee;\n@@ -73,7 +73,7 @@ impl Struct {\n     fn method2(&self, _x: char, _y: bool) {}\n }\n \n-// Change Callee (Method) ------------------------------------------------------\n+// Change Callee (Method)\n #[cfg(cfail1)]\n pub fn change_callee_method() {\n     let s = Struct;\n@@ -90,7 +90,7 @@ pub fn change_callee_method() {\n \n \n \n-// Change Argument (Method) ----------------------------------------------------\n+// Change Argument (Method)\n #[cfg(cfail1)]\n pub fn change_argument_method() {\n     let s = Struct;\n@@ -107,7 +107,7 @@ pub fn change_argument_method() {\n \n \n \n-// Change Callee (Method, UFCS) ------------------------------------------------\n+// Change Callee (Method, UFCS)\n #[cfg(cfail1)]\n pub fn change_ufcs_callee_method() {\n     let s = Struct;\n@@ -124,7 +124,7 @@ pub fn change_ufcs_callee_method() {\n \n \n \n-// Change Argument (Method, UFCS) ----------------------------------------------\n+// Change Argument (Method, UFCS)\n #[cfg(cfail1)]\n pub fn change_argument_method_ufcs() {\n     let s = Struct;\n@@ -141,7 +141,7 @@ pub fn change_argument_method_ufcs() {\n \n \n \n-// Change To UFCS --------------------------------------------------------------\n+// Change To UFCS\n #[cfg(cfail1)]\n pub fn change_to_ufcs() {\n     let s = Struct;\n@@ -164,7 +164,7 @@ impl Struct2 {\n     fn method1(&self, _x: char, _y: bool) {}\n }\n \n-// Change UFCS Callee Indirectly -----------------------------------------------\n+// Change UFCS Callee Indirectly\n pub mod change_ufcs_callee_indirectly {\n     #[cfg(cfail1)]\n     use super::Struct as Struct;"}, {"sha": "08693560d0b6e7f6d4d2e06b60390785bbe6880a", "filename": "src/test/incremental/hashes/closure_expressions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -14,7 +14,7 @@\n #![crate_type=\"rlib\"]\n \n \n-// Change closure body ---------------------------------------------------------\n+// Change closure body\n #[cfg(cfail1)]\n pub fn change_closure_body() {\n     let _ = || 1u32;\n@@ -29,7 +29,7 @@ pub fn change_closure_body() {\n \n \n \n-// Add parameter ---------------------------------------------------------------\n+// Add parameter\n #[cfg(cfail1)]\n pub fn add_parameter() {\n     let x = 0u32;\n@@ -46,7 +46,7 @@ pub fn add_parameter() {\n \n \n \n-// Change parameter pattern ----------------------------------------------------\n+// Change parameter pattern\n #[cfg(cfail1)]\n pub fn change_parameter_pattern() {\n     let _ = |x: (u32,)| x;\n@@ -61,7 +61,7 @@ pub fn change_parameter_pattern() {\n \n \n \n-// Add `move` to closure -------------------------------------------------------\n+// Add `move` to closure\n #[cfg(cfail1)]\n pub fn add_move() {\n     let _ = || 1;\n@@ -76,7 +76,7 @@ pub fn add_move() {\n \n \n \n-// Add type ascription to parameter --------------------------------------------\n+// Add type ascription to parameter\n #[cfg(cfail1)]\n pub fn add_type_ascription_to_parameter() {\n     let closure = |x| x + 1u32;\n@@ -93,7 +93,7 @@ pub fn add_type_ascription_to_parameter() {\n \n \n \n-// Change parameter type -------------------------------------------------------\n+// Change parameter type\n #[cfg(cfail1)]\n pub fn change_parameter_type() {\n     let closure = |x: u32| (x as u64) + 1;"}, {"sha": "3d2eed89636e856243bc6e2171d8b1a8cf2b2f89", "filename": "src/test/incremental/hashes/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -14,7 +14,7 @@\n #![crate_type=\"rlib\"]\n \n \n-// Change const visibility ---------------------------------------------------\n+// Change const visibility\n #[cfg(cfail1)]\n const CONST_VISIBILITY: u8 = 0;\n \n@@ -24,7 +24,7 @@ const CONST_VISIBILITY: u8 = 0;\n pub const CONST_VISIBILITY: u8 = 0;\n \n \n-// Change type from i32 to u32 ------------------------------------------------\n+// Change type from i32 to u32\n #[cfg(cfail1)]\n const CONST_CHANGE_TYPE_1: i32 = 0;\n \n@@ -34,7 +34,7 @@ const CONST_CHANGE_TYPE_1: i32 = 0;\n const CONST_CHANGE_TYPE_1: u32 = 0;\n \n \n-// Change type from Option<u32> to Option<u64> --------------------------------\n+// Change type from Option<u32> to Option<u64>\n #[cfg(cfail1)]\n const CONST_CHANGE_TYPE_2: Option<u32> = None;\n \n@@ -44,7 +44,7 @@ const CONST_CHANGE_TYPE_2: Option<u32> = None;\n const CONST_CHANGE_TYPE_2: Option<u64> = None;\n \n \n-// Change value between simple literals ---------------------------------------\n+// Change value between simple literals\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n #[rustc_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_1: i16 = {\n@@ -56,7 +56,7 @@ const CONST_CHANGE_VALUE_1: i16 = {\n };\n \n \n-// Change value between expressions -------------------------------------------\n+// Change value between expressions\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n #[rustc_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_2: i16 = {\n@@ -88,7 +88,7 @@ const CONST_CHANGE_VALUE_4: i16 = {\n };\n \n \n-// Change type indirectly -----------------------------------------------------\n+// Change type indirectly\n struct ReferencedType1;\n struct ReferencedType2;\n "}, {"sha": "4b73f1371f872607ce706e1666bd1d7444d8d235", "filename": "src/test/incremental/hashes/if_expressions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -14,7 +14,7 @@\n #![feature(rustc_attrs)]\n #![crate_type=\"rlib\"]\n \n-// Change condition (if) -------------------------------------------------------\n+// Change condition (if)\n #[cfg(cfail1)]\n pub fn change_condition(x: bool) -> u32 {\n     if x {\n@@ -35,7 +35,7 @@ pub fn change_condition(x: bool) -> u32 {\n     return 0\n }\n \n-// Change then branch (if) -----------------------------------------------------\n+// Change then branch (if)\n #[cfg(cfail1)]\n pub fn change_then_branch(x: bool) -> u32 {\n     if x {\n@@ -58,7 +58,7 @@ pub fn change_then_branch(x: bool) -> u32 {\n \n \n \n-// Change else branch (if) -----------------------------------------------------\n+// Change else branch (if)\n #[cfg(cfail1)]\n pub fn change_else_branch(x: bool) -> u32 {\n     if x {\n@@ -81,7 +81,7 @@ pub fn change_else_branch(x: bool) -> u32 {\n \n \n \n-// Add else branch (if) --------------------------------------------------------\n+// Add else branch (if)\n #[cfg(cfail1)]\n pub fn add_else_branch(x: bool) -> u32 {\n     let mut ret = 1;\n@@ -109,7 +109,7 @@ pub fn add_else_branch(x: bool) -> u32 {\n \n \n \n-// Change condition (if let) ---------------------------------------------------\n+// Change condition (if let)\n #[cfg(cfail1)]\n pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n     if let Some(_x) = x {\n@@ -132,7 +132,7 @@ pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n \n \n \n-// Change then branch (if let) -------------------------------------------------\n+// Change then branch (if let)\n #[cfg(cfail1)]\n pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n     if let Some(x) = x {\n@@ -155,7 +155,7 @@ pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n \n \n \n-// Change else branch (if let) -------------------------------------------------\n+// Change else branch (if let)\n #[cfg(cfail1)]\n pub fn change_else_branch_if_let(x: Option<u32>) -> u32 {\n     if let Some(x) = x {\n@@ -178,7 +178,7 @@ pub fn change_else_branch_if_let(x: Option<u32>) -> u32 {\n \n \n \n-// Add else branch (if let) ----------------------------------------------------\n+// Add else branch (if let)\n #[cfg(cfail1)]\n pub fn add_else_branch_if_let(x: Option<u32>) -> u32 {\n     let mut ret = 1;"}, {"sha": "08cf19d7760282b9739fbd60ff38a9039f66c60f", "filename": "src/test/incremental/hashes/indexing_expressions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -13,7 +13,7 @@\n #![feature(rustc_attrs)]\n #![crate_type=\"rlib\"]\n \n-// Change simple index ---------------------------------------------------------\n+// Change simple index\n #[cfg(cfail1)]\n fn change_simple_index(slice: &[u32]) -> u32 {\n     slice[3]\n@@ -30,7 +30,7 @@ fn change_simple_index(slice: &[u32]) -> u32 {\n \n \n \n-// Change lower bound ----------------------------------------------------------\n+// Change lower bound\n #[cfg(cfail1)]\n fn change_lower_bound(slice: &[u32]) -> &[u32] {\n     &slice[3..5]\n@@ -47,7 +47,7 @@ fn change_lower_bound(slice: &[u32]) -> &[u32] {\n \n \n \n-// Change upper bound ----------------------------------------------------------\n+// Change upper bound\n #[cfg(cfail1)]\n fn change_upper_bound(slice: &[u32]) -> &[u32] {\n     &slice[3..5]\n@@ -64,7 +64,7 @@ fn change_upper_bound(slice: &[u32]) -> &[u32] {\n \n \n \n-// Add lower bound -------------------------------------------------------------\n+// Add lower bound\n #[cfg(cfail1)]\n fn add_lower_bound(slice: &[u32]) -> &[u32] {\n     &slice[..4]\n@@ -81,7 +81,7 @@ fn add_lower_bound(slice: &[u32]) -> &[u32] {\n \n \n \n-// Add upper bound -------------------------------------------------------------\n+// Add upper bound\n #[cfg(cfail1)]\n fn add_upper_bound(slice: &[u32]) -> &[u32] {\n     &slice[3..]\n@@ -98,7 +98,7 @@ fn add_upper_bound(slice: &[u32]) -> &[u32] {\n \n \n \n-// Change mutability -----------------------------------------------------------\n+// Change mutability\n #[cfg(cfail1)]\n fn change_mutability(slice: &mut [u32]) -> u32 {\n     (&mut slice[3..5])[0]\n@@ -115,7 +115,7 @@ fn change_mutability(slice: &mut [u32]) -> u32 {\n \n \n \n-// Exclusive to inclusive range ------------------------------------------------\n+// Exclusive to inclusive range\n #[cfg(cfail1)]\n fn exclusive_to_inclusive_range(slice: &[u32]) -> &[u32] {\n     &slice[3..7]"}, {"sha": "c50ee73d71438c4c16b095ff2fbb80b1362d4220", "filename": "src/test/incremental/hashes/inline_asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -16,7 +16,7 @@\n \n \n \n-// Change template -------------------------------------------------------------\n+// Change template\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_template(a: i32) -> i32 {\n@@ -51,7 +51,7 @@ pub fn change_template(a: i32) -> i32 {\n \n \n \n-// Change output -------------------------------------------------------------\n+// Change output\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_output(a: i32) -> i32 {\n@@ -88,7 +88,7 @@ pub fn change_output(a: i32) -> i32 {\n \n \n \n-// Change input -------------------------------------------------------------\n+// Change input\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_input(_a: i32, _b: i32) -> i32 {\n@@ -123,7 +123,7 @@ pub fn change_input(_a: i32, _b: i32) -> i32 {\n \n \n \n-// Change input constraint -----------------------------------------------------\n+// Change input constraint\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n@@ -158,7 +158,7 @@ pub fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n \n \n \n-// Change clobber --------------------------------------------------------------\n+// Change clobber\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_clobber(_a: i32) -> i32 {\n@@ -193,7 +193,7 @@ pub fn change_clobber(_a: i32) -> i32 {\n \n \n \n-// Change options --------------------------------------------------------------\n+// Change options\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_options(_a: i32) -> i32 {"}, {"sha": "a2222db4c59ad37a57c59ba3a4bad2525a67cee5", "filename": "src/test/incremental/hashes/loop_expressions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -14,7 +14,7 @@\n #![crate_type=\"rlib\"]\n \n \n-// Change loop body ------------------------------------------------------------\n+// Change loop body\n #[cfg(cfail1)]\n pub fn change_loop_body() {\n     let mut _x = 0;\n@@ -37,7 +37,7 @@ pub fn change_loop_body() {\n \n \n \n-// Add break -------------------------------------------------------------------\n+// Add break\n #[cfg(cfail1)]\n pub fn add_break() {\n     let mut _x = 0;\n@@ -59,7 +59,7 @@ pub fn add_break() {\n \n \n \n-// Add loop label --------------------------------------------------------------\n+// Add loop label\n #[cfg(cfail1)]\n pub fn add_loop_label() {\n     let mut _x = 0;\n@@ -82,7 +82,7 @@ pub fn add_loop_label() {\n \n \n \n-// Add loop label to break -----------------------------------------------------\n+// Add loop label to break\n #[cfg(cfail1)]\n pub fn add_loop_label_to_break() {\n     let mut _x = 0;\n@@ -105,7 +105,7 @@ pub fn add_loop_label_to_break() {\n \n \n \n-// Change break label ----------------------------------------------------------\n+// Change break label\n #[cfg(cfail1)]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -132,7 +132,7 @@ pub fn change_break_label() {\n \n \n \n-// Add loop label to continue --------------------------------------------------\n+// Add loop label to continue\n #[cfg(cfail1)]\n pub fn add_loop_label_to_continue() {\n     let mut _x = 0;\n@@ -155,7 +155,7 @@ pub fn add_loop_label_to_continue() {\n \n \n \n-// Change continue label ----------------------------------------------------------\n+// Change continue label\n #[cfg(cfail1)]\n pub fn change_continue_label() {\n     let mut _x = 0;\n@@ -182,7 +182,7 @@ pub fn change_continue_label() {\n \n \n \n-// Change continue to break ----------------------------------------------------\n+// Change continue to break\n #[cfg(cfail1)]\n pub fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "70b0a5ab78cd7dcfa8b52e80013a0555570c5970", "filename": "src/test/incremental/hashes/panic_exprs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -17,7 +17,7 @@\n #![crate_type=\"rlib\"]\n \n \n-// Indexing expression ---------------------------------------------------------\n+// Indexing expression\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn indexing(slice: &[u8]) -> u8 {\n@@ -32,7 +32,7 @@ pub fn indexing(slice: &[u8]) -> u8 {\n }\n \n \n-// Arithmetic overflow plus ----------------------------------------------------\n+// Arithmetic overflow plus\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n@@ -47,7 +47,7 @@ pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n }\n \n \n-// Arithmetic overflow minus ----------------------------------------------------\n+// Arithmetic overflow minus\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n@@ -62,7 +62,7 @@ pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n }\n \n \n-// Arithmetic overflow mult ----------------------------------------------------\n+// Arithmetic overflow mult\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n@@ -77,7 +77,7 @@ pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n }\n \n \n-// Arithmetic overflow negation ------------------------------------------------\n+// Arithmetic overflow negation\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n@@ -92,7 +92,7 @@ pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n }\n \n \n-// Division by zero ------------------------------------------------------------\n+// Division by zero\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn division_by_zero(val: i32) -> i32 {\n@@ -106,7 +106,7 @@ pub fn division_by_zero(val: i32) -> i32 {\n     }\n }\n \n-// Division by zero ------------------------------------------------------------\n+// Division by zero\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn mod_by_zero(val: i32) -> i32 {\n@@ -121,7 +121,7 @@ pub fn mod_by_zero(val: i32) -> i32 {\n }\n \n \n-// shift left ------------------------------------------------------------------\n+// shift left\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn shift_left(val: i32, shift: usize) -> i32 {\n@@ -136,7 +136,7 @@ pub fn shift_left(val: i32, shift: usize) -> i32 {\n }\n \n \n-// shift right ------------------------------------------------------------------\n+// shift right\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn shift_right(val: i32, shift: usize) -> i32 {"}, {"sha": "d70ebb08b715a74e71820476443772c6a1000515", "filename": "src/test/incremental/hashes/statics.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -16,7 +16,7 @@\n #![crate_type=\"rlib\"]\n \n \n-// Change static visibility ---------------------------------------------------\n+// Change static visibility\n #[cfg(cfail1)]\n static STATIC_VISIBILITY: u8 = 0;\n \n@@ -26,7 +26,7 @@ static STATIC_VISIBILITY: u8 = 0;\n pub static STATIC_VISIBILITY: u8 = 0;\n \n \n-// Change static mutability ---------------------------------------------------\n+// Change static mutability\n #[cfg(cfail1)]\n static STATIC_MUTABILITY: u8 = 0;\n \n@@ -36,7 +36,7 @@ static STATIC_MUTABILITY: u8 = 0;\n static mut STATIC_MUTABILITY: u8 = 0;\n \n \n-// Add linkage attribute ------------------------------------------------------\n+// Add linkage attribute\n #[cfg(cfail1)]\n static STATIC_LINKAGE: u8 = 0;\n \n@@ -47,7 +47,7 @@ static STATIC_LINKAGE: u8 = 0;\n static STATIC_LINKAGE: u8 = 0;\n \n \n-// Add no_mangle attribute ----------------------------------------------------\n+// Add no_mangle attribute\n #[cfg(cfail1)]\n static STATIC_NO_MANGLE: u8 = 0;\n \n@@ -58,7 +58,7 @@ static STATIC_NO_MANGLE: u8 = 0;\n static STATIC_NO_MANGLE: u8 = 0;\n \n \n-// Add thread_local attribute -------------------------------------------------\n+// Add thread_local attribute\n #[cfg(cfail1)]\n static STATIC_THREAD_LOCAL: u8 = 0;\n \n@@ -69,7 +69,7 @@ static STATIC_THREAD_LOCAL: u8 = 0;\n static STATIC_THREAD_LOCAL: u8 = 0;\n \n \n-// Change type from i16 to u64 ------------------------------------------------\n+// Change type from i16 to u64\n #[cfg(cfail1)]\n static STATIC_CHANGE_TYPE_1: i16 = 0;\n \n@@ -79,7 +79,7 @@ static STATIC_CHANGE_TYPE_1: i16 = 0;\n static STATIC_CHANGE_TYPE_1: u64 = 0;\n \n \n-// Change type from Option<i8> to Option<u16> ---------------------------------\n+// Change type from Option<i8> to Option<u16>\n #[cfg(cfail1)]\n static STATIC_CHANGE_TYPE_2: Option<i8> = None;\n \n@@ -89,7 +89,7 @@ static STATIC_CHANGE_TYPE_2: Option<i8> = None;\n static STATIC_CHANGE_TYPE_2: Option<u16> = None;\n \n \n-// Change value between simple literals ---------------------------------------\n+// Change value between simple literals\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n #[rustc_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_1: i16 = {\n@@ -101,7 +101,7 @@ static STATIC_CHANGE_VALUE_1: i16 = {\n };\n \n \n-// Change value between expressions -------------------------------------------\n+// Change value between expressions\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n #[rustc_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_2: i16 = {\n@@ -133,7 +133,7 @@ static STATIC_CHANGE_VALUE_4: i16 = {\n };\n \n \n-// Change type indirectly -----------------------------------------------------\n+// Change type indirectly\n struct ReferencedType1;\n struct ReferencedType2;\n "}, {"sha": "456d5e74751ae82b6ba1d7482533a5ff6116681a", "filename": "src/test/incremental/hashes/struct_constructors.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -20,7 +20,7 @@ pub struct RegularStruct {\n     z: i16,\n }\n \n-// Change field value (regular struct) -----------------------------------------\n+// Change field value (regular struct)\n #[cfg(cfail1)]\n pub fn change_field_value_regular_struct() -> RegularStruct {\n     RegularStruct {\n@@ -43,7 +43,7 @@ pub fn change_field_value_regular_struct() -> RegularStruct {\n \n \n \n-// Change field order (regular struct) -----------------------------------------\n+// Change field order (regular struct)\n #[cfg(cfail1)]\n pub fn change_field_order_regular_struct() -> RegularStruct {\n     RegularStruct {\n@@ -66,7 +66,7 @@ pub fn change_field_order_regular_struct() -> RegularStruct {\n \n \n \n-// Add field (regular struct) --------------------------------------------------\n+// Add field (regular struct)\n #[cfg(cfail1)]\n pub fn add_field_regular_struct() -> RegularStruct {\n     let struct1 = RegularStruct {\n@@ -100,7 +100,7 @@ pub fn add_field_regular_struct() -> RegularStruct {\n \n \n \n-// Change field label (regular struct) -----------------------------------------\n+// Change field label (regular struct)\n #[cfg(cfail1)]\n pub fn change_field_label_regular_struct() -> RegularStruct {\n     let struct1 = RegularStruct {\n@@ -141,7 +141,7 @@ pub struct RegularStruct2 {\n     z: i8,\n }\n \n-// Change constructor path (regular struct) ------------------------------------\n+// Change constructor path (regular struct)\n #[cfg(cfail1)]\n pub fn change_constructor_path_regular_struct() {\n     let _ = RegularStruct {\n@@ -164,7 +164,7 @@ pub fn change_constructor_path_regular_struct() {\n \n \n \n-// Change constructor path indirectly (regular struct) -------------------------\n+// Change constructor path indirectly (regular struct)\n pub mod change_constructor_path_indirectly_regular_struct {\n     #[cfg(cfail1)]\n     use super::RegularStruct as Struct;\n@@ -189,7 +189,7 @@ pub mod change_constructor_path_indirectly_regular_struct {\n \n pub struct TupleStruct(i32, i64, i16);\n \n-// Change field value (tuple struct) -------------------------------------------\n+// Change field value (tuple struct)\n #[cfg(cfail1)]\n pub fn change_field_value_tuple_struct() -> TupleStruct {\n     TupleStruct(0, 1, 2)\n@@ -206,7 +206,7 @@ pub fn change_field_value_tuple_struct() -> TupleStruct {\n \n pub struct TupleStruct2(u16, u16, u16);\n \n-// Change constructor path (tuple struct) --------------------------------------\n+// Change constructor path (tuple struct)\n #[cfg(cfail1)]\n pub fn change_constructor_path_tuple_struct() {\n     let _ = TupleStruct(0, 1, 2);\n@@ -221,7 +221,7 @@ pub fn change_constructor_path_tuple_struct() {\n \n \n \n-// Change constructor path indirectly (tuple struct) ---------------------------\n+// Change constructor path indirectly (tuple struct)\n pub mod change_constructor_path_indirectly_tuple_struct {\n     #[cfg(cfail1)]\n     use super::TupleStruct as Struct;"}, {"sha": "81ff99533fc916aca0fd10fc2ce546765d4b13c0", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -21,7 +21,7 @@\n #![feature(intrinsics)]\n \n \n-// Change trait visibility --------------------------------------------------------\n+// Change trait visibility\n #[cfg(cfail1)]\n trait TraitVisibility { }\n \n@@ -32,7 +32,7 @@ pub trait TraitVisibility { }\n \n \n \n-// Change trait unsafety ----------------------------------------------------------\n+// Change trait unsafety\n #[cfg(cfail1)]\n trait TraitUnsafety { }\n \n@@ -43,7 +43,7 @@ unsafe trait TraitUnsafety { }\n \n \n \n-// Add method ---------------------------------------------------------------------\n+// Add method\n #[cfg(cfail1)]\n trait TraitAddMethod {\n }\n@@ -57,7 +57,7 @@ pub trait TraitAddMethod {\n \n \n \n-// Change name of method ----------------------------------------------------------\n+// Change name of method\n #[cfg(cfail1)]\n trait TraitChangeMethodName {\n     fn method();\n@@ -72,7 +72,7 @@ trait TraitChangeMethodName {\n \n \n \n-// Add return type to method ------------------------------------------------------\n+// Add return type to method\n #[cfg(cfail1)]\n trait TraitAddReturnType {\n     fn method();\n@@ -89,7 +89,7 @@ trait TraitAddReturnType {\n \n \n \n-// Change return type of method ---------------------------------------------------\n+// Change return type of method\n #[cfg(cfail1)]\n trait TraitChangeReturnType {\n     fn method() -> u32;\n@@ -106,7 +106,7 @@ trait TraitChangeReturnType {\n \n \n \n-// Add parameter to method --------------------------------------------------------\n+// Add parameter to method\n #[cfg(cfail1)]\n trait TraitAddParameterToMethod {\n     fn method();\n@@ -123,7 +123,7 @@ trait TraitAddParameterToMethod {\n \n \n \n-// Change name of method parameter ------------------------------------------------\n+// Change name of method parameter\n #[cfg(cfail1)]\n trait TraitChangeMethodParameterName {\n     fn method(a: u32);\n@@ -148,7 +148,7 @@ trait TraitChangeMethodParameterName {\n \n \n \n-// Change type of method parameter (i32 => i64) -----------------------------------\n+// Change type of method parameter (i32 => i64)\n #[cfg(cfail1)]\n trait TraitChangeMethodParameterType {\n     fn method(a: i32);\n@@ -165,7 +165,7 @@ trait TraitChangeMethodParameterType {\n \n \n \n-// Change type of method parameter (&i32 => &mut i32) -----------------------------\n+// Change type of method parameter (&i32 => &mut i32)\n #[cfg(cfail1)]\n trait TraitChangeMethodParameterTypeRef {\n     fn method(a: &i32);\n@@ -182,7 +182,7 @@ trait TraitChangeMethodParameterTypeRef {\n \n \n \n-// Change order of method parameters ----------------------------------------------\n+// Change order of method parameters\n #[cfg(cfail1)]\n trait TraitChangeMethodParametersOrder {\n     fn method(a: i32, b: i64);\n@@ -199,7 +199,7 @@ trait TraitChangeMethodParametersOrder {\n \n \n \n-// Add default implementation to method -------------------------------------------\n+// Add default implementation to method\n #[cfg(cfail1)]\n trait TraitAddMethodAutoImplementation {\n     fn method();\n@@ -216,7 +216,7 @@ trait TraitAddMethodAutoImplementation {\n \n \n \n-// Change order of methods --------------------------------------------------------\n+// Change order of methods\n #[cfg(cfail1)]\n trait TraitChangeOrderOfMethods {\n     fn method0();\n@@ -233,7 +233,7 @@ trait TraitChangeOrderOfMethods {\n \n \n \n-// Change mode of self parameter --------------------------------------------------\n+// Change mode of self parameter\n #[cfg(cfail1)]\n trait TraitChangeModeSelfRefToMut {\n     fn method(&self);\n@@ -284,7 +284,7 @@ trait TraitChangeModeSelfOwnToRef {\n \n \n \n-// Add unsafe modifier to method --------------------------------------------------\n+// Add unsafe modifier to method\n #[cfg(cfail1)]\n trait TraitAddUnsafeModifier {\n     fn method();\n@@ -301,7 +301,7 @@ trait TraitAddUnsafeModifier {\n \n \n \n-// Add extern modifier to method --------------------------------------------------\n+// Add extern modifier to method\n #[cfg(cfail1)]\n trait TraitAddExternModifier {\n     fn method();\n@@ -318,7 +318,7 @@ trait TraitAddExternModifier {\n \n \n \n-// Change extern \"C\" to extern \"rust-intrinsic\" -----------------------------------\n+// Change extern \"C\" to extern \"rust-intrinsic\"\n #[cfg(cfail1)]\n trait TraitChangeExternCToRustIntrinsic {\n     extern \"C\" fn method();\n@@ -335,7 +335,7 @@ trait TraitChangeExternCToRustIntrinsic {\n \n \n \n-// Add type parameter to method ---------------------------------------------------\n+// Add type parameter to method\n #[cfg(cfail1)]\n trait TraitAddTypeParameterToMethod {\n     fn method();\n@@ -352,7 +352,7 @@ trait TraitAddTypeParameterToMethod {\n \n \n \n-// Add lifetime parameter to method -----------------------------------------------\n+// Add lifetime parameter to method\n #[cfg(cfail1)]\n trait TraitAddLifetimeParameterToMethod {\n     fn method();\n@@ -373,7 +373,7 @@ trait TraitAddLifetimeParameterToMethod {\n trait ReferencedTrait0 { }\n trait ReferencedTrait1 { }\n \n-// Add trait bound to method type parameter ---------------------------------------\n+// Add trait bound to method type parameter\n #[cfg(cfail1)]\n trait TraitAddTraitBoundToMethodTypeParameter {\n     fn method<T>();\n@@ -390,7 +390,7 @@ trait TraitAddTraitBoundToMethodTypeParameter {\n \n \n \n-// Add builtin bound to method type parameter -------------------------------------\n+// Add builtin bound to method type parameter\n #[cfg(cfail1)]\n trait TraitAddBuiltinBoundToMethodTypeParameter {\n     fn method<T>();\n@@ -407,7 +407,7 @@ trait TraitAddBuiltinBoundToMethodTypeParameter {\n \n \n \n-// Add lifetime bound to method lifetime parameter ------------------------------------\n+// Add lifetime bound to method lifetime parameter\n #[cfg(cfail1)]\n trait TraitAddLifetimeBoundToMethodLifetimeParameter {\n     fn method<'a, 'b>(a: &'a u32, b: &'b u32);\n@@ -424,7 +424,7 @@ trait TraitAddLifetimeBoundToMethodLifetimeParameter {\n \n \n \n-// Add second trait bound to method type parameter --------------------------------\n+// Add second trait bound to method type parameter\n #[cfg(cfail1)]\n trait TraitAddSecondTraitBoundToMethodTypeParameter {\n     fn method<T: ReferencedTrait0>();\n@@ -441,7 +441,7 @@ trait TraitAddSecondTraitBoundToMethodTypeParameter {\n \n \n \n-// Add second builtin bound to method type parameter ------------------------------\n+// Add second builtin bound to method type parameter\n #[cfg(cfail1)]\n trait TraitAddSecondBuiltinBoundToMethodTypeParameter {\n     fn method<T: Sized>();\n@@ -458,7 +458,7 @@ trait TraitAddSecondBuiltinBoundToMethodTypeParameter {\n \n \n \n-// Add second lifetime bound to method lifetime parameter -----------------------------\n+// Add second lifetime bound to method lifetime parameter\n #[cfg(cfail1)]\n trait TraitAddSecondLifetimeBoundToMethodLifetimeParameter {\n     fn method<'a, 'b, 'c: 'a>(a: &'a u32, b: &'b u32, c: &'c u32);\n@@ -475,7 +475,7 @@ trait TraitAddSecondLifetimeBoundToMethodLifetimeParameter {\n \n \n \n-// Add associated type ------------------------------------------------------------\n+// Add associated type\n #[cfg(cfail1)]\n trait TraitAddAssociatedType {\n \n@@ -495,7 +495,7 @@ trait TraitAddAssociatedType {\n \n \n \n-// Add trait bound to associated type ---------------------------------------------\n+// Add trait bound to associated type\n #[cfg(cfail1)]\n trait TraitAddTraitBoundToAssociatedType {\n     type Associated;\n@@ -519,7 +519,7 @@ trait TraitAddTraitBoundToAssociatedType {\n \n \n \n-// Add lifetime bound to associated type ------------------------------------------\n+// Add lifetime bound to associated type\n #[cfg(cfail1)]\n trait TraitAddLifetimeBoundToAssociatedType<'a> {\n     type Associated;\n@@ -540,7 +540,7 @@ trait TraitAddLifetimeBoundToAssociatedType<'a> {\n \n \n \n-// Add default to associated type -------------------------------------------------\n+// Add default to associated type\n #[cfg(cfail1)]\n trait TraitAddDefaultToAssociatedType {\n     type Associated;\n@@ -561,7 +561,7 @@ trait TraitAddDefaultToAssociatedType {\n \n \n \n-// Add associated constant --------------------------------------------------------\n+// Add associated constant\n #[cfg(cfail1)]\n trait TraitAddAssociatedConstant {\n     fn method();\n@@ -578,7 +578,7 @@ trait TraitAddAssociatedConstant {\n \n \n \n-// Add initializer to associated constant -----------------------------------------\n+// Add initializer to associated constant\n #[cfg(cfail1)]\n trait TraitAddInitializerToAssociatedConstant {\n     const Value: u32;\n@@ -601,7 +601,7 @@ trait TraitAddInitializerToAssociatedConstant {\n \n \n \n-// Change type of associated constant ---------------------------------------------\n+// Change type of associated constant\n #[cfg(cfail1)]\n trait TraitChangeTypeOfAssociatedConstant {\n     const Value: u32;\n@@ -624,7 +624,7 @@ trait TraitChangeTypeOfAssociatedConstant {\n \n \n \n-// Add super trait ----------------------------------------------------------------\n+// Add super trait\n #[cfg(cfail1)]\n trait TraitAddSuperTrait { }\n \n@@ -635,7 +635,7 @@ trait TraitAddSuperTrait : ReferencedTrait0 { }\n \n \n \n-// Add builtin bound (Send or Copy) -----------------------------------------------\n+// Add builtin bound (Send or Copy)\n #[cfg(cfail1)]\n trait TraitAddBuiltiBound { }\n \n@@ -646,7 +646,7 @@ trait TraitAddBuiltiBound : Send { }\n \n \n \n-// Add 'static lifetime bound to trait --------------------------------------------\n+// Add 'static lifetime bound to trait\n #[cfg(cfail1)]\n trait TraitAddStaticLifetimeBound { }\n \n@@ -657,7 +657,7 @@ trait TraitAddStaticLifetimeBound : 'static { }\n \n \n \n-// Add super trait as second bound ------------------------------------------------\n+// Add super trait as second bound\n #[cfg(cfail1)]\n trait TraitAddTraitAsSecondBound : ReferencedTrait0 { }\n \n@@ -676,7 +676,7 @@ trait TraitAddTraitAsSecondBoundFromBuiltin : Send + ReferencedTrait0 { }\n \n \n \n-// Add builtin bound as second bound ----------------------------------------------\n+// Add builtin bound as second bound\n #[cfg(cfail1)]\n trait TraitAddBuiltinBoundAsSecondBound : ReferencedTrait0 { }\n \n@@ -695,7 +695,7 @@ trait TraitAddBuiltinBoundAsSecondBoundFromBuiltin: Send + Copy { }\n \n \n \n-// Add 'static bounds as second bound ---------------------------------------------\n+// Add 'static bounds as second bound\n #[cfg(cfail1)]\n trait TraitAddStaticBoundAsSecondBound : ReferencedTrait0 { }\n \n@@ -714,7 +714,7 @@ trait TraitAddStaticBoundAsSecondBoundFromBuiltin : Send + 'static { }\n \n \n \n-// Add type parameter to trait ----------------------------------------------------\n+// Add type parameter to trait\n #[cfg(cfail1)]\n trait TraitAddTypeParameterToTrait { }\n \n@@ -725,7 +725,7 @@ trait TraitAddTypeParameterToTrait<T> { }\n \n \n \n-// Add lifetime parameter to trait ------------------------------------------------\n+// Add lifetime parameter to trait\n #[cfg(cfail1)]\n trait TraitAddLifetimeParameterToTrait { }\n \n@@ -736,7 +736,7 @@ trait TraitAddLifetimeParameterToTrait<'a> { }\n \n \n \n-// Add trait bound to type parameter of trait -------------------------------------\n+// Add trait bound to type parameter of trait\n #[cfg(cfail1)]\n trait TraitAddTraitBoundToTypeParameterOfTrait<T> { }\n \n@@ -747,7 +747,7 @@ trait TraitAddTraitBoundToTypeParameterOfTrait<T: ReferencedTrait0> { }\n \n \n \n-// Add lifetime bound to type parameter of trait ----------------------------------\n+// Add lifetime bound to type parameter of trait\n #[cfg(cfail1)]\n trait TraitAddLifetimeBoundToTypeParameterOfTrait<'a, T> { }\n \n@@ -758,7 +758,7 @@ trait TraitAddLifetimeBoundToTypeParameterOfTrait<'a, T: 'a> { }\n \n \n \n-// Add lifetime bound to lifetime parameter of trait ------------------------------\n+// Add lifetime bound to lifetime parameter of trait\n #[cfg(cfail1)]\n trait TraitAddLifetimeBoundToLifetimeParameterOfTrait<'a, 'b> { }\n \n@@ -769,7 +769,7 @@ trait TraitAddLifetimeBoundToLifetimeParameterOfTrait<'a: 'b, 'b> { }\n \n \n \n-// Add builtin bound to type parameter of trait -----------------------------------\n+// Add builtin bound to type parameter of trait\n #[cfg(cfail1)]\n trait TraitAddBuiltinBoundToTypeParameterOfTrait<T> { }\n \n@@ -780,7 +780,7 @@ trait TraitAddBuiltinBoundToTypeParameterOfTrait<T: Send> { }\n \n \n \n-// Add second type parameter to trait ---------------------------------------------\n+// Add second type parameter to trait\n #[cfg(cfail1)]\n trait TraitAddSecondTypeParameterToTrait<T> { }\n \n@@ -791,7 +791,7 @@ trait TraitAddSecondTypeParameterToTrait<T, S> { }\n \n \n \n-// Add second lifetime parameter to trait -----------------------------------------\n+// Add second lifetime parameter to trait\n #[cfg(cfail1)]\n trait TraitAddSecondLifetimeParameterToTrait<'a> { }\n \n@@ -802,7 +802,7 @@ trait TraitAddSecondLifetimeParameterToTrait<'a, 'b> { }\n \n \n \n-// Add second trait bound to type parameter of trait ------------------------------\n+// Add second trait bound to type parameter of trait\n #[cfg(cfail1)]\n trait TraitAddSecondTraitBoundToTypeParameterOfTrait<T: ReferencedTrait0> { }\n \n@@ -813,7 +813,7 @@ trait TraitAddSecondTraitBoundToTypeParameterOfTrait<T: ReferencedTrait0 + Refer\n \n \n \n-// Add second lifetime bound to type parameter of trait ---------------------------\n+// Add second lifetime bound to type parameter of trait\n #[cfg(cfail1)]\n trait TraitAddSecondLifetimeBoundToTypeParameterOfTrait<'a, 'b, T: 'a> { }\n \n@@ -824,7 +824,7 @@ trait TraitAddSecondLifetimeBoundToTypeParameterOfTrait<'a, 'b, T: 'a + 'b> { }\n \n \n \n-// Add second lifetime bound to lifetime parameter of trait------------------------\n+// Add second lifetime bound to lifetime parameter of trait\n #[cfg(cfail1)]\n trait TraitAddSecondLifetimeBoundToLifetimeParameterOfTrait<'a: 'b, 'b, 'c> { }\n \n@@ -835,7 +835,7 @@ trait TraitAddSecondLifetimeBoundToLifetimeParameterOfTrait<'a: 'b + 'c, 'b, 'c>\n \n \n \n-// Add second builtin bound to type parameter of trait ----------------------------\n+// Add second builtin bound to type parameter of trait\n #[cfg(cfail1)]\n trait TraitAddSecondBuiltinBoundToTypeParameterOfTrait<T: Send> { }\n \n@@ -846,13 +846,12 @@ trait TraitAddSecondBuiltinBoundToTypeParameterOfTrait<T: Send + Sync> { }\n \n \n \n-// --------------------------------------------------------------------------------\n struct ReferenceType0 {}\n struct ReferenceType1 {}\n \n \n \n-// Add trait bound to type parameter of trait in where clause----------------------\n+// Add trait bound to type parameter of trait in where clause\n #[cfg(cfail1)]\n trait TraitAddTraitBoundToTypeParameterOfTraitWhere<T> { }\n \n@@ -863,7 +862,7 @@ trait TraitAddTraitBoundToTypeParameterOfTraitWhere<T> where T: ReferencedTrait0\n \n \n \n-// Add lifetime bound to type parameter of trait in where clause-------------------\n+// Add lifetime bound to type parameter of trait in where clause\n #[cfg(cfail1)]\n trait TraitAddLifetimeBoundToTypeParameterOfTraitWhere<'a, T> { }\n \n@@ -874,7 +873,7 @@ trait TraitAddLifetimeBoundToTypeParameterOfTraitWhere<'a, T> where T: 'a { }\n \n \n \n-// Add lifetime bound to lifetime parameter of trait in where clause---------------\n+// Add lifetime bound to lifetime parameter of trait in where clause\n #[cfg(cfail1)]\n trait TraitAddLifetimeBoundToLifetimeParameterOfTraitWhere<'a, 'b> { }\n \n@@ -885,7 +884,7 @@ trait TraitAddLifetimeBoundToLifetimeParameterOfTraitWhere<'a, 'b> where 'a: 'b\n \n \n \n-// Add builtin bound to type parameter of trait in where clause--------------------\n+// Add builtin bound to type parameter of trait in where clause\n #[cfg(cfail1)]\n trait TraitAddBuiltinBoundToTypeParameterOfTraitWhere<T> { }\n \n@@ -896,7 +895,7 @@ trait TraitAddBuiltinBoundToTypeParameterOfTraitWhere<T> where T: Send { }\n \n \n \n-// Add second trait bound to type parameter of trait in where clause---------------\n+// Add second trait bound to type parameter of trait in where clause\n #[cfg(cfail1)]\n trait TraitAddSecondTraitBoundToTypeParameterOfTraitWhere<T> where T: ReferencedTrait0 { }\n \n@@ -908,7 +907,7 @@ trait TraitAddSecondTraitBoundToTypeParameterOfTraitWhere<T>\n \n \n \n-// Add second lifetime bound to type parameter of trait in where clause------------\n+// Add second lifetime bound to type parameter of trait in where clause\n #[cfg(cfail1)]\n trait TraitAddSecondLifetimeBoundToTypeParameterOfTraitWhere<'a, 'b, T> where T: 'a { }\n \n@@ -919,7 +918,7 @@ trait TraitAddSecondLifetimeBoundToTypeParameterOfTraitWhere<'a, 'b, T> where T:\n \n \n \n-// Add second lifetime bound to lifetime parameter of trait in where clause--------\n+// Add second lifetime bound to lifetime parameter of trait in where clause\n #[cfg(cfail1)]\n trait TraitAddSecondLifetimeBoundToLifetimeParameterOfTraitWhere<'a, 'b, 'c> where 'a: 'b { }\n \n@@ -930,7 +929,7 @@ trait TraitAddSecondLifetimeBoundToLifetimeParameterOfTraitWhere<'a, 'b, 'c> whe\n \n \n \n-// Add second builtin bound to type parameter of trait in where clause-------------\n+// Add second builtin bound to type parameter of trait in where clause\n #[cfg(cfail1)]\n trait TraitAddSecondBuiltinBoundToTypeParameterOfTraitWhere<T> where T: Send { }\n \n@@ -940,7 +939,7 @@ trait TraitAddSecondBuiltinBoundToTypeParameterOfTraitWhere<T> where T: Send { }\n trait TraitAddSecondBuiltinBoundToTypeParameterOfTraitWhere<T> where T: Send + Sync { }\n \n \n-// Change return type of method indirectly by modifying a use statement------------\n+// Change return type of method indirectly by modifying a use statement\n mod change_return_type_of_method_indirectly_use {\n     #[cfg(cfail1)]\n     use super::ReferenceType0 as ReturnType;\n@@ -958,7 +957,7 @@ mod change_return_type_of_method_indirectly_use {\n \n \n \n-// Change type of method parameter indirectly by modifying a use statement---------\n+// Change type of method parameter indirectly by modifying a use statement\n mod change_method_parameter_type_indirectly_by_use {\n     #[cfg(cfail1)]\n     use super::ReferenceType0 as ArgType;"}, {"sha": "da3c957741fb22dd0939c0b464c22d6e199cf597", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -14,7 +14,7 @@\n #![crate_type=\"rlib\"]\n \n \n-// Change loop body ------------------------------------------------------------\n+// Change loop body\n #[cfg(cfail1)]\n pub fn change_loop_body() {\n     let mut _x = 0;\n@@ -37,7 +37,7 @@ pub fn change_loop_body() {\n \n \n \n-// Change loop body ------------------------------------------------------------\n+// Change loop body\n #[cfg(cfail1)]\n pub fn change_loop_condition() {\n     let mut _x = 0;\n@@ -60,7 +60,7 @@ pub fn change_loop_condition() {\n \n \n \n-// Add break -------------------------------------------------------------------\n+// Add break\n #[cfg(cfail1)]\n pub fn add_break() {\n     let mut _x = 0;\n@@ -82,7 +82,7 @@ pub fn add_break() {\n \n \n \n-// Add loop label --------------------------------------------------------------\n+// Add loop label\n #[cfg(cfail1)]\n pub fn add_loop_label() {\n     let mut _x = 0;\n@@ -105,7 +105,7 @@ pub fn add_loop_label() {\n \n \n \n-// Add loop label to break -----------------------------------------------------\n+// Add loop label to break\n #[cfg(cfail1)]\n pub fn add_loop_label_to_break() {\n     let mut _x = 0;\n@@ -128,7 +128,7 @@ pub fn add_loop_label_to_break() {\n \n \n \n-// Change break label ----------------------------------------------------------\n+// Change break label\n #[cfg(cfail1)]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -155,7 +155,7 @@ pub fn change_break_label() {\n \n \n \n-// Add loop label to continue --------------------------------------------------\n+// Add loop label to continue\n #[cfg(cfail1)]\n pub fn add_loop_label_to_continue() {\n     let mut _x = 0;\n@@ -178,7 +178,7 @@ pub fn add_loop_label_to_continue() {\n \n \n \n-// Change continue label ----------------------------------------------------------\n+// Change continue label\n #[cfg(cfail1)]\n pub fn change_continue_label() {\n     let mut _x = 0;\n@@ -205,7 +205,7 @@ pub fn change_continue_label() {\n \n \n \n-// Change continue to break ----------------------------------------------------\n+// Change continue to break\n #[cfg(cfail1)]\n pub fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "3be42e7a4ee7a793042606b53a21bd2ac5b290cb", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -14,7 +14,7 @@\n #![crate_type=\"rlib\"]\n \n \n-// Change loop body ------------------------------------------------------------\n+// Change loop body\n #[cfg(cfail1)]\n pub fn change_loop_body() {\n     let mut _x = 0;\n@@ -37,7 +37,7 @@ pub fn change_loop_body() {\n \n \n \n-// Change loop body ------------------------------------------------------------\n+// Change loop body\n #[cfg(cfail1)]\n pub fn change_loop_condition() {\n     let mut _x = 0;\n@@ -60,7 +60,7 @@ pub fn change_loop_condition() {\n \n \n \n-// Add break -------------------------------------------------------------------\n+// Add break\n #[cfg(cfail1)]\n pub fn add_break() {\n     let mut _x = 0;\n@@ -82,7 +82,7 @@ pub fn add_break() {\n \n \n \n-// Add loop label --------------------------------------------------------------\n+// Add loop label\n #[cfg(cfail1)]\n pub fn add_loop_label() {\n     let mut _x = 0;\n@@ -105,7 +105,7 @@ pub fn add_loop_label() {\n \n \n \n-// Add loop label to break -----------------------------------------------------\n+// Add loop label to break\n #[cfg(cfail1)]\n pub fn add_loop_label_to_break() {\n     let mut _x = 0;\n@@ -128,7 +128,7 @@ pub fn add_loop_label_to_break() {\n \n \n \n-// Change break label ----------------------------------------------------------\n+// Change break label\n #[cfg(cfail1)]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -155,7 +155,7 @@ pub fn change_break_label() {\n \n \n \n-// Add loop label to continue --------------------------------------------------\n+// Add loop label to continue\n #[cfg(cfail1)]\n pub fn add_loop_label_to_continue() {\n     let mut _x = 0;\n@@ -178,7 +178,7 @@ pub fn add_loop_label_to_continue() {\n \n \n \n-// Change continue label ----------------------------------------------------------\n+// Change continue label\n #[cfg(cfail1)]\n pub fn change_continue_label() {\n     let mut _x = 0;\n@@ -205,7 +205,7 @@ pub fn change_continue_label() {\n \n \n \n-// Change continue to break ----------------------------------------------------\n+// Change continue to break\n #[cfg(cfail1)]\n pub fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "5f9708a39722a6532521e8df3cd95d9d29fbcb13", "filename": "src/test/rustdoc/async-fn.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Frustdoc%2Fasync-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Frustdoc%2Fasync-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fasync-fn.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,5 @@\n // edition:2018\n \n-#![feature(async_await)]\n-\n // @has async_fn/fn.foo.html '//pre[@class=\"rust fn\"]' 'pub async fn foo() -> Option<Foo>'\n pub async fn foo() -> Option<Foo> {\n     None"}, {"sha": "2ba61388c9e3b046dbcdf01f7c5dd3c86febcd1f", "filename": "src/test/rustdoc/async-move-doctest.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Frustdoc%2Fasync-move-doctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Frustdoc%2Fasync-move-doctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fasync-move-doctest.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,13 +1,11 @@\n // compile-flags:--test\n // edition:2018\n \n-// prior to setting the default edition for the doctest pre-parser, this doctest would fail due to\n-// a fatal parsing error\n+// Prior to setting the default edition for the doctest pre-parser,\n+// this doctest would fail due to a fatal parsing error.\n // see https://github.com/rust-lang/rust/issues/59313\n \n //! ```\n-//! #![feature(async_await)]\n-//!\n //! fn foo() {\n //!     drop(async move {});\n //! }"}, {"sha": "ddbc2be651d904c23240902fa9591e93222e1831", "filename": "src/test/rustdoc/edition-flag.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Frustdoc%2Fedition-flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Frustdoc%2Fedition-flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fedition-flag.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,10 +1,7 @@\n // compile-flags:--test -Z unstable-options\n // edition:2018\n \n-#![feature(async_await)]\n-\n /// ```rust\n-/// #![feature(async_await)]\n /// fn main() {\n ///     let _ = async { };\n /// }"}, {"sha": "959f4a2babbf8a522769fa41b368b6904ed090bf", "filename": "src/test/ui/array-break-length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Farray-break-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Farray-break-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-break-length.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,11 +1,11 @@\n fn main() {\n     loop {\n-        |_: [_; break]| {} //~ ERROR: `break` outside of loop\n+        |_: [_; break]| {} //~ ERROR: `break` outside of a loop\n         //~^ ERROR mismatched types\n     }\n \n     loop {\n-        |_: [_; continue]| {} //~ ERROR: `continue` outside of loop\n+        |_: [_; continue]| {} //~ ERROR: `continue` outside of a loop\n         //~^ ERROR mismatched types\n     }\n }"}, {"sha": "45f529bafe7286889592c8fb6d4339e21fdaea38", "filename": "src/test/ui/array-break-length.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Farray-break-length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Farray-break-length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-break-length.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,14 +1,14 @@\n-error[E0268]: `break` outside of loop\n+error[E0268]: `break` outside of a loop\n   --> $DIR/array-break-length.rs:3:17\n    |\n LL |         |_: [_; break]| {}\n-   |                 ^^^^^ cannot break outside of a loop\n+   |                 ^^^^^ cannot `break` outside of a loop\n \n-error[E0268]: `continue` outside of loop\n+error[E0268]: `continue` outside of a loop\n   --> $DIR/array-break-length.rs:8:17\n    |\n LL |         |_: [_; continue]| {}\n-   |                 ^^^^^^^^ cannot break outside of a loop\n+   |                 ^^^^^^^^ cannot `continue` outside of a loop\n \n error[E0308]: mismatched types\n   --> $DIR/array-break-length.rs:3:9"}, {"sha": "0e42f48b8351e90ff7e081ff3a85abbf22d8f901", "filename": "src/test/ui/async-await/argument-patterns.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fargument-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fargument-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fargument-patterns.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,7 +3,6 @@\n \n #![allow(unused_variables)]\n #![deny(unused_mut)]\n-#![feature(async_await)]\n \n type A = Vec<u32>;\n "}, {"sha": "bf8bf0bcce0fef4f5ed4a31b2040a46ea0bc8b22", "filename": "src/test/ui/async-await/async-await.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,8 +3,6 @@\n // edition:2018\n // aux-build:arc_wake.rs\n \n-#![feature(async_await)]\n-\n extern crate arc_wake;\n \n use std::pin::Pin;"}, {"sha": "753a4e491550f0d8346437ddbe155a7a72f748b9", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -6,8 +6,6 @@\n // edition:2018\n // ignore-tidy-linelength\n \n-#![feature(async_await)]\n-\n fn main() {}\n \n use core::future::Future;\n@@ -32,14 +30,14 @@ async fn return_targets_async_block_not_async_fn() -> u8 {\n \n fn no_break_in_async_block() {\n     async {\n-        break 0u8; //~ ERROR `break` inside of an async block\n+        break 0u8; //~ ERROR `break` inside of an `async` block\n     };\n }\n \n fn no_break_in_async_block_even_with_outer_loop() {\n     loop {\n         async {\n-            break 0u8; //~ ERROR `break` inside of an async block\n+            break 0u8; //~ ERROR `break` inside of an `async` block\n         };\n     }\n }"}, {"sha": "c36caa5586fb0936a80521becd8c30aea4cce3ab", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,17 +1,25 @@\n-error[E0267]: `break` inside of an async block\n-  --> $DIR/async-block-control-flow-static-semantics.rs:35:9\n+error[E0267]: `break` inside of an `async` block\n+  --> $DIR/async-block-control-flow-static-semantics.rs:33:9\n    |\n-LL |         break 0u8;\n-   |         ^^^^^^^^^ cannot break inside of an async block\n+LL |       async {\n+   |  ___________-\n+LL | |         break 0u8;\n+   | |         ^^^^^^^^^ cannot `break` inside of an `async` block\n+LL | |     };\n+   | |_____- enclosing `async` block\n \n-error[E0267]: `break` inside of an async block\n-  --> $DIR/async-block-control-flow-static-semantics.rs:42:13\n+error[E0267]: `break` inside of an `async` block\n+  --> $DIR/async-block-control-flow-static-semantics.rs:40:13\n    |\n-LL |             break 0u8;\n-   |             ^^^^^^^^^ cannot break inside of an async block\n+LL |           async {\n+   |  _______________-\n+LL | |             break 0u8;\n+   | |             ^^^^^^^^^ cannot `break` inside of an `async` block\n+LL | |         };\n+   | |_________- enclosing `async` block\n \n error[E0308]: mismatched types\n-  --> $DIR/async-block-control-flow-static-semantics.rs:15:43\n+  --> $DIR/async-block-control-flow-static-semantics.rs:13:43\n    |\n LL | fn return_targets_async_block_not_fn() -> u8 {\n    |    ---------------------------------      ^^ expected u8, found ()\n@@ -22,7 +30,7 @@ LL | fn return_targets_async_block_not_fn() -> u8 {\n               found type `()`\n \n error[E0271]: type mismatch resolving `<impl std::future::Future as std::future::Future>::Output == ()`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:20:39\n+  --> $DIR/async-block-control-flow-static-semantics.rs:18:39\n    |\n LL |     let _: &dyn Future<Output = ()> = &block;\n    |                                       ^^^^^^ expected u8, found ()\n@@ -32,7 +40,7 @@ LL |     let _: &dyn Future<Output = ()> = &block;\n    = note: required for the cast to the object type `dyn std::future::Future<Output = ()>`\n \n error[E0271]: type mismatch resolving `<impl std::future::Future as std::future::Future>::Output == ()`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:29:39\n+  --> $DIR/async-block-control-flow-static-semantics.rs:27:39\n    |\n LL |     let _: &dyn Future<Output = ()> = &block;\n    |                                       ^^^^^^ expected u8, found ()\n@@ -42,7 +50,7 @@ LL |     let _: &dyn Future<Output = ()> = &block;\n    = note: required for the cast to the object type `dyn std::future::Future<Output = ()>`\n \n error[E0271]: type mismatch resolving `<impl std::future::Future as std::future::Future>::Output == u8`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:24:55\n+  --> $DIR/async-block-control-flow-static-semantics.rs:22:55\n    |\n LL | async fn return_targets_async_block_not_async_fn() -> u8 {\n    |                                                       ^^ expected (), found u8\n@@ -52,7 +60,7 @@ LL | async fn return_targets_async_block_not_async_fn() -> u8 {\n    = note: the return type of a function must have a statically known size\n \n error[E0308]: mismatched types\n-  --> $DIR/async-block-control-flow-static-semantics.rs:50:44\n+  --> $DIR/async-block-control-flow-static-semantics.rs:48:44\n    |\n LL | fn rethrow_targets_async_block_not_fn() -> Result<u8, MyErr> {\n    |    ----------------------------------      ^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found ()\n@@ -63,7 +71,7 @@ LL | fn rethrow_targets_async_block_not_fn() -> Result<u8, MyErr> {\n               found type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/async-block-control-flow-static-semantics.rs:59:50\n+  --> $DIR/async-block-control-flow-static-semantics.rs:57:50\n    |\n LL | fn rethrow_targets_async_block_not_async_fn() -> Result<u8, MyErr> {\n    |    ----------------------------------------      ^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found ()"}, {"sha": "d82fbcdc5505b638fb54cb6a1ab370e959882653", "filename": "src/test/ui/async-await/async-closure-matches-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-closure-matches-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-closure-matches-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-closure-matches-expr.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,7 @@\n // build-pass\n // edition:2018\n \n-#![feature(async_await, async_closure)]\n+#![feature(async_closure)]\n \n macro_rules! match_expr {\n     ($x:expr) => {}"}, {"sha": "9a24bd8c9543953251f5bf54c02cab1e9bda9fcd", "filename": "src/test/ui/async-await/async-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-closure.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,7 +3,7 @@\n // edition:2018\n // aux-build:arc_wake.rs\n \n-#![feature(async_await, async_closure)]\n+#![feature(async_closure)]\n \n extern crate arc_wake;\n "}, {"sha": "dec3ac0f685547b5d66877babf9c4d3de1d1fade", "filename": "src/test/ui/async-await/async-error-span.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,6 @@\n // edition:2018\n-#![feature(async_await)]\n \n-// Regression test for issue #62382\n+// Regression test for issue #62382.\n \n use std::future::Future;\n "}, {"sha": "47441f5e4efcefc2d7c6f352c772dce285777581", "filename": "src/test/ui/async-await/async-error-span.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,11 +1,11 @@\n error[E0698]: type inside `async` object must be known in this context\n-  --> $DIR/async-error-span.rs:13:9\n+  --> $DIR/async-error-span.rs:12:9\n    |\n LL |     let a;\n    |         ^ cannot infer type\n    |\n note: the type is part of the `async` object because of this `await`\n-  --> $DIR/async-error-span.rs:14:5\n+  --> $DIR/async-error-span.rs:13:5\n    |\n LL |     get_future().await;\n    |     ^^^^^^^^^^^^^^^^^^"}, {"sha": "1c369fd7415db7be6063a69615d62ee8ff96b6c7", "filename": "src/test/ui/async-await/async-fn-elided-impl-lifetime-parameter.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-elided-impl-lifetime-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-elided-impl-lifetime-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-elided-impl-lifetime-parameter.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -6,8 +6,6 @@\n // check-pass\n // edition:2018\n \n-#![feature(async_await)]\n-\n struct Foo<'a>(&'a u8);\n \n impl Foo<'_> {"}, {"sha": "1f1bf4250eadf7547e2149786d2920e1fde58048", "filename": "src/test/ui/async-await/async-fn-nonsend.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-#![feature(async_await)]\n-\n use std::{\n     cell::RefCell,\n     fmt::Debug,"}, {"sha": "6b4fff2dc6844bbe60054690591c0b1a974c0067", "filename": "src/test/ui/async-await/async-fn-nonsend.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,43 +1,43 @@\n error[E0277]: `std::rc::Rc<()>` cannot be sent between threads safely\n-  --> $DIR/async-fn-nonsend.rs:52:5\n+  --> $DIR/async-fn-nonsend.rs:50:5\n    |\n LL |     assert_send(local_dropped_before_await());\n    |     ^^^^^^^^^^^ `std::rc::Rc<()>` cannot be sent between threads safely\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<()>`\n    = note: required because it appears within the type `impl std::fmt::Debug`\n    = note: required because it appears within the type `{impl std::fmt::Debug, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:23:39: 28:2 {impl std::fmt::Debug, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:23:39: 28:2 {impl std::fmt::Debug, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n note: required by `assert_send`\n-  --> $DIR/async-fn-nonsend.rs:49:1\n+  --> $DIR/async-fn-nonsend.rs:47:1\n    |\n LL | fn assert_send(_: impl Send) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: `std::rc::Rc<()>` cannot be sent between threads safely\n-  --> $DIR/async-fn-nonsend.rs:54:5\n+  --> $DIR/async-fn-nonsend.rs:52:5\n    |\n LL |     assert_send(non_send_temporary_in_match());\n    |     ^^^^^^^^^^^ `std::rc::Rc<()>` cannot be sent between threads safely\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<()>`\n    = note: required because it appears within the type `impl std::fmt::Debug`\n    = note: required because it appears within the type `{fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:30:40: 39:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:30:40: 39:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n note: required by `assert_send`\n-  --> $DIR/async-fn-nonsend.rs:49:1\n+  --> $DIR/async-fn-nonsend.rs:47:1\n    |\n LL | fn assert_send(_: impl Send) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: `dyn std::fmt::Write` cannot be sent between threads safely\n-  --> $DIR/async-fn-nonsend.rs:56:5\n+  --> $DIR/async-fn-nonsend.rs:54:5\n    |\n LL |     assert_send(non_sync_with_method_call());\n    |     ^^^^^^^^^^^ `dyn std::fmt::Write` cannot be sent between threads safely\n@@ -47,18 +47,18 @@ LL |     assert_send(non_sync_with_method_call());\n    = note: required because it appears within the type `std::fmt::Formatter<'_>`\n    = note: required because of the requirements on the impl of `std::marker::Send` for `&mut std::fmt::Formatter<'_>`\n    = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:41:38: 47:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:41:38: 47:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n note: required by `assert_send`\n-  --> $DIR/async-fn-nonsend.rs:49:1\n+  --> $DIR/async-fn-nonsend.rs:47:1\n    |\n LL | fn assert_send(_: impl Send) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n-  --> $DIR/async-fn-nonsend.rs:56:5\n+  --> $DIR/async-fn-nonsend.rs:54:5\n    |\n LL |     assert_send(non_sync_with_method_call());\n    |     ^^^^^^^^^^^ `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n@@ -72,12 +72,12 @@ LL |     assert_send(non_sync_with_method_call());\n    = note: required because it appears within the type `std::fmt::Formatter<'_>`\n    = note: required because of the requirements on the impl of `std::marker::Send` for `&mut std::fmt::Formatter<'_>`\n    = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:41:38: 47:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:41:38: 47:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n note: required by `assert_send`\n-  --> $DIR/async-fn-nonsend.rs:49:1\n+  --> $DIR/async-fn-nonsend.rs:47:1\n    |\n LL | fn assert_send(_: impl Send) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "3f1f51c20ca0c3ce20d54462018398c918a2b393", "filename": "src/test/ui/async-await/async-fn-path-elision.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,5 @@\n // edition:2018\n \n-#![feature(async_await)]\n-#![allow(dead_code)]\n-\n struct HasLifetime<'a>(&'a bool);\n \n async fn error(lt: HasLifetime) { //~ ERROR implicit elided lifetime not allowed here"}, {"sha": "9694742200ef07d658e0a5606156f0f04f53a4ba", "filename": "src/test/ui/async-await/async-fn-path-elision.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0726]: implicit elided lifetime not allowed here\n-  --> $DIR/async-fn-path-elision.rs:8:20\n+  --> $DIR/async-fn-path-elision.rs:5:20\n    |\n LL | async fn error(lt: HasLifetime) {\n    |                    ^^^^^^^^^^^- help: indicate the anonymous lifetime: `<'_>`"}, {"sha": "35d9cb15540d1f753d8af69098a7bf641b92cf3c", "filename": "src/test/ui/async-await/async-fn-send-uses-nonsend.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-send-uses-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-send-uses-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-send-uses-nonsend.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-#![feature(async_await)]\n-\n use std::{\n     cell::RefCell,\n     fmt::Debug,"}, {"sha": "3ffcbb58595eb75807f772be549d11f4cdda2726", "filename": "src/test/ui/async-await/async-fn-size-moved-locals.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -12,8 +12,6 @@\n \n // edition:2018\n \n-#![feature(async_await)]\n-\n use std::future::Future;\n use std::pin::Pin;\n use std::task::{Context, Poll};"}, {"sha": "b5c94ecb716902bc14b2bb4efc956ecc0fff5e21", "filename": "src/test/ui/async-await/async-fn-size.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // aux-build:arc_wake.rs\n // edition:2018\n \n-#![feature(async_await)]\n-\n extern crate arc_wake;\n \n use std::pin::Pin;"}, {"sha": "299faa0587bd58d8be20d7015ec27dee2c00b110", "filename": "src/test/ui/async-await/async-matches-expr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-matches-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-matches-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-matches-expr.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n \n-#![feature(async_await)]\n-\n macro_rules! match_expr {\n     ($x:expr) => {}\n }"}, {"sha": "ccc1b8553f07144c9af97dbe32db522130964579", "filename": "src/test/ui/async-await/async-unsafe-fn-call-in-safe.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,5 @@\n // edition:2018\n \n-#![feature(async_await)]\n-\n struct S;\n \n impl S {"}, {"sha": "c95fe17348877a2627a5a6ee480d9af99071c515", "filename": "src/test/ui/async-await/async-unsafe-fn-call-in-safe.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,29 +1,29 @@\n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/async-unsafe-fn-call-in-safe.rs:14:5\n+  --> $DIR/async-unsafe-fn-call-in-safe.rs:12:5\n    |\n LL |     S::f();\n    |     ^^^^^^ call to unsafe function\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/async-unsafe-fn-call-in-safe.rs:15:5\n+  --> $DIR/async-unsafe-fn-call-in-safe.rs:13:5\n    |\n LL |     f();\n    |     ^^^ call to unsafe function\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/async-unsafe-fn-call-in-safe.rs:19:5\n+  --> $DIR/async-unsafe-fn-call-in-safe.rs:17:5\n    |\n LL |     S::f();\n    |     ^^^^^^ call to unsafe function\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/async-unsafe-fn-call-in-safe.rs:20:5\n+  --> $DIR/async-unsafe-fn-call-in-safe.rs:18:5\n    |\n LL |     f();\n    |     ^^^ call to unsafe function"}, {"sha": "0b2255266753d01f004cc93ddc60dec188369374", "filename": "src/test/ui/async-await/async-with-closure.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-with-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fasync-with-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-with-closure.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n \n-#![feature(async_await)]\n-\n trait MyClosure {\n     type Args;\n }"}, {"sha": "a3a20cb97e150d45e03d094342e7a6d70cdb3888", "filename": "src/test/ui/async-await/await-keyword/2015-edition-error-various-positions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2015-edition-error-various-positions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2015-edition-error-various-positions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2015-edition-error-various-positions.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,4 +1,3 @@\n-#![feature(async_await)]\n #![allow(non_camel_case_types)]\n #![deny(keyword_idents)]\n "}, {"sha": "f1a22cda51b2135af61fa189e5a9d9d2e7e07ec6", "filename": "src/test/ui/async-await/await-keyword/2015-edition-error-various-positions.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2015-edition-error-various-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2015-edition-error-various-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2015-edition-error-various-positions.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,19 +1,19 @@\n error: `await` is a keyword in the 2018 edition\n-  --> $DIR/2015-edition-error-various-positions.rs:6:13\n+  --> $DIR/2015-edition-error-various-positions.rs:5:13\n    |\n LL |     pub mod await {\n    |             ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n    |\n note: lint level defined here\n-  --> $DIR/2015-edition-error-various-positions.rs:3:9\n+  --> $DIR/2015-edition-error-various-positions.rs:2:9\n    |\n LL | #![deny(keyword_idents)]\n    |         ^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `await` is a keyword in the 2018 edition\n-  --> $DIR/2015-edition-error-various-positions.rs:8:20\n+  --> $DIR/2015-edition-error-various-positions.rs:7:20\n    |\n LL |         pub struct await;\n    |                    ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n@@ -22,7 +22,7 @@ LL |         pub struct await;\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `await` is a keyword in the 2018 edition\n-  --> $DIR/2015-edition-error-various-positions.rs:12:16\n+  --> $DIR/2015-edition-error-various-positions.rs:11:16\n    |\n LL | use outer_mod::await::await;\n    |                ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n@@ -31,7 +31,7 @@ LL | use outer_mod::await::await;\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `await` is a keyword in the 2018 edition\n-  --> $DIR/2015-edition-error-various-positions.rs:12:23\n+  --> $DIR/2015-edition-error-various-positions.rs:11:23\n    |\n LL | use outer_mod::await::await;\n    |                       ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n@@ -40,7 +40,7 @@ LL | use outer_mod::await::await;\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `await` is a keyword in the 2018 edition\n-  --> $DIR/2015-edition-error-various-positions.rs:17:14\n+  --> $DIR/2015-edition-error-various-positions.rs:16:14\n    |\n LL | struct Foo { await: () }\n    |              ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n@@ -49,7 +49,7 @@ LL | struct Foo { await: () }\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `await` is a keyword in the 2018 edition\n-  --> $DIR/2015-edition-error-various-positions.rs:21:15\n+  --> $DIR/2015-edition-error-various-positions.rs:20:15\n    |\n LL | impl Foo { fn await() {} }\n    |               ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n@@ -58,7 +58,7 @@ LL | impl Foo { fn await() {} }\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `await` is a keyword in the 2018 edition\n-  --> $DIR/2015-edition-error-various-positions.rs:25:14\n+  --> $DIR/2015-edition-error-various-positions.rs:24:14\n    |\n LL | macro_rules! await {\n    |              ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n@@ -67,7 +67,7 @@ LL | macro_rules! await {\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `await` is a keyword in the 2018 edition\n-  --> $DIR/2015-edition-error-various-positions.rs:32:5\n+  --> $DIR/2015-edition-error-various-positions.rs:31:5\n    |\n LL |     await!();\n    |     ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n@@ -76,7 +76,7 @@ LL |     await!();\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `await` is a keyword in the 2018 edition\n-  --> $DIR/2015-edition-error-various-positions.rs:35:11\n+  --> $DIR/2015-edition-error-various-positions.rs:34:11\n    |\n LL |     match await { await => {} }\n    |           ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n@@ -85,7 +85,7 @@ LL |     match await { await => {} }\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `await` is a keyword in the 2018 edition\n-  --> $DIR/2015-edition-error-various-positions.rs:35:19\n+  --> $DIR/2015-edition-error-various-positions.rs:34:19\n    |\n LL |     match await { await => {} }\n    |                   ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`"}, {"sha": "5d85b0a243e0358858794fb439cf2f5e911e377e", "filename": "src/test/ui/async-await/await-keyword/2018-edition-error-in-non-macro-position.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,6 @@\n // edition:2018\n \n #![allow(non_camel_case_types)]\n-#![feature(async_await)]\n \n mod outer_mod {\n     pub mod await { //~ ERROR expected identifier, found reserved keyword `await`"}, {"sha": "05f28d0a5b2267f6b680b1649a613778b73205cf", "filename": "src/test/ui/async-await/await-keyword/2018-edition-error-in-non-macro-position.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error: expected identifier, found reserved keyword `await`\n-  --> $DIR/2018-edition-error-in-non-macro-position.rs:7:13\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:6:13\n    |\n LL |     pub mod await {\n    |             ^^^^^ expected identifier, found reserved keyword\n@@ -9,7 +9,7 @@ LL |     pub mod r#await {\n    |             ^^^^^^^\n \n error: expected identifier, found reserved keyword `await`\n-  --> $DIR/2018-edition-error-in-non-macro-position.rs:8:20\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:7:20\n    |\n LL |         pub struct await;\n    |                    ^^^^^ expected identifier, found reserved keyword\n@@ -19,7 +19,7 @@ LL |         pub struct r#await;\n    |                    ^^^^^^^\n \n error: expected identifier, found reserved keyword `await`\n-  --> $DIR/2018-edition-error-in-non-macro-position.rs:11:22\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:10:22\n    |\n LL | use self::outer_mod::await::await;\n    |                      ^^^^^ expected identifier, found reserved keyword\n@@ -29,7 +29,7 @@ LL | use self::outer_mod::r#await::await;\n    |                      ^^^^^^^\n \n error: expected identifier, found reserved keyword `await`\n-  --> $DIR/2018-edition-error-in-non-macro-position.rs:11:29\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:10:29\n    |\n LL | use self::outer_mod::await::await;\n    |                             ^^^^^ expected identifier, found reserved keyword\n@@ -39,7 +39,7 @@ LL | use self::outer_mod::await::r#await;\n    |                             ^^^^^^^\n \n error: expected identifier, found reserved keyword `await`\n-  --> $DIR/2018-edition-error-in-non-macro-position.rs:14:14\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:13:14\n    |\n LL | struct Foo { await: () }\n    |              ^^^^^ expected identifier, found reserved keyword\n@@ -49,7 +49,7 @@ LL | struct Foo { r#await: () }\n    |              ^^^^^^^\n \n error: expected identifier, found reserved keyword `await`\n-  --> $DIR/2018-edition-error-in-non-macro-position.rs:17:15\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:16:15\n    |\n LL | impl Foo { fn await() {} }\n    |               ^^^^^ expected identifier, found reserved keyword\n@@ -59,7 +59,7 @@ LL | impl Foo { fn r#await() {} }\n    |               ^^^^^^^\n \n error: expected identifier, found reserved keyword `await`\n-  --> $DIR/2018-edition-error-in-non-macro-position.rs:20:14\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:19:14\n    |\n LL | macro_rules! await {\n    |              ^^^^^ expected identifier, found reserved keyword"}, {"sha": "22bcbb1064dd744266b16cd3db205f5bac75debc", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,5 @@\n // edition:2018\n \n-#![feature(async_await)]\n-\n async fn bar() -> Result<(), ()> {\n     Ok(())\n }"}, {"sha": "7caa9f26bc2f848ab341347a45419b24a15d6e7d", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.stderr", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,133 +1,133 @@\n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:10:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:8:13\n    |\n LL |     let _ = await bar();\n    |             ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:14:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:12:13\n    |\n LL |     let _ = await? bar();\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await?`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:18:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:16:13\n    |\n LL |     let _ = await bar()?;\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar()?.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:23:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:21:13\n    |\n LL |     let _ = await { bar() };\n    |             ^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ bar() }.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:27:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:25:13\n    |\n LL |     let _ = await(bar());\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `(bar()).await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:31:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:29:13\n    |\n LL |     let _ = await { bar() }?;\n    |             ^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ bar() }.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:35:14\n+  --> $DIR/incorrect-syntax-suggestions.rs:33:14\n    |\n LL |     let _ = (await bar())?;\n    |              ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:39:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:37:24\n    |\n LL |     let _ = bar().await();\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:43:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:41:24\n    |\n LL |     let _ = bar().await()?;\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:55:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:53:13\n    |\n LL |     let _ = await bar();\n    |             ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:60:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:58:13\n    |\n LL |     let _ = await? bar();\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await?`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:65:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:63:13\n    |\n LL |     let _ = await bar()?;\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar()?.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:70:14\n+  --> $DIR/incorrect-syntax-suggestions.rs:68:14\n    |\n LL |     let _ = (await bar())?;\n    |              ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:75:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:73:24\n    |\n LL |     let _ = bar().await();\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:80:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:78:24\n    |\n LL |     let _ = bar().await()?;\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:108:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:106:13\n    |\n LL |     let _ = await!(bar());\n    |             ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:112:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:110:13\n    |\n LL |     let _ = await!(bar())?;\n    |             ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:117:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:115:17\n    |\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:125:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:123:17\n    |\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: expected expression, found `=>`\n-  --> $DIR/incorrect-syntax-suggestions.rs:133:25\n+  --> $DIR/incorrect-syntax-suggestions.rs:131:25\n    |\n LL |     match await { await => () }\n    |                   ----- ^^ expected expression\n    |                   |\n    |                   while parsing this incorrect await expression\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:133:11\n+  --> $DIR/incorrect-syntax-suggestions.rs:131:11\n    |\n LL |     match await { await => () }\n    |           ^^^^^^^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ await => () }.await`\n \n error: expected one of `.`, `?`, `{`, or an operator, found `}`\n-  --> $DIR/incorrect-syntax-suggestions.rs:136:1\n+  --> $DIR/incorrect-syntax-suggestions.rs:134:1\n    |\n LL |     match await { await => () }\n    |     -----                      - expected one of `.`, `?`, `{`, or an operator here\n@@ -138,103 +138,103 @@ LL | }\n    | ^ unexpected token\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:55:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:53:13\n    |\n LL | fn foo9() -> Result<(), ()> {\n    |    ---- this is not `async`\n LL |     let _ = await bar();\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:60:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:58:13\n    |\n LL | fn foo10() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = await? bar();\n    |             ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:65:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:63:13\n    |\n LL | fn foo11() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = await bar()?;\n    |             ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:70:14\n+  --> $DIR/incorrect-syntax-suggestions.rs:68:14\n    |\n LL | fn foo12() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = (await bar())?;\n    |              ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:75:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:73:13\n    |\n LL | fn foo13() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await();\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:80:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:78:13\n    |\n LL | fn foo14() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await()?;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:85:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:83:13\n    |\n LL | fn foo15() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:89:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:87:13\n    |\n LL | fn foo16() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await?;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:94:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:92:17\n    |\n LL |     fn foo() -> Result<(), ()> {\n    |        --- this is not `async`\n LL |         let _ = bar().await?;\n    |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:101:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:99:17\n    |\n LL |     let foo = || {\n    |               -- this is not `async`\n LL |         let _ = bar().await?;\n    |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:117:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:115:17\n    |\n LL |     fn foo() -> Result<(), ()> {\n    |        --- this is not `async`\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:125:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:123:17\n    |\n LL |     let foo = || {\n    |               -- this is not `async`\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n-  --> $DIR/incorrect-syntax-suggestions.rs:18:19\n+  --> $DIR/incorrect-syntax-suggestions.rs:16:19\n    |\n LL |     let _ = await bar()?;\n    |                   ^^^^^^ the `?` operator cannot be applied to type `impl std::future::Future`"}, {"sha": "aa09d4bdf088362190f5dbf901b48896def452ab", "filename": "src/test/ui/async-await/await-unsize.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-unsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fawait-unsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-unsize.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,8 +3,6 @@\n // check-pass\n // edition:2018\n \n-#![feature(async_await)]\n-\n async fn make_boxed_object() -> Box<dyn Send> {\n     Box::new(()) as _\n }"}, {"sha": "5d260682f1d8163ea34a9030e7ea041fcfc56fed", "filename": "src/test/ui/async-await/bound-normalization.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fbound-normalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fbound-normalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fbound-normalization.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // check-pass\n // edition:2018\n \n-#![feature(async_await)]\n-\n // See issue 60414\n \n trait Trait {"}, {"sha": "56f4cbbd190f8b9fbac993191d76251d053b4ff3", "filename": "src/test/ui/async-await/conditional-and-guaranteed-initialization.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fconditional-and-guaranteed-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fconditional-and-guaranteed-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fconditional-and-guaranteed-initialization.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-#![feature(async_await)]\n-\n async fn conditional_and_guaranteed_initialization(x: usize) -> usize {\n     let y;\n     if x > 5 {"}, {"sha": "68341a24c4e5d396e3bc52ffb84c3e4ca733831e", "filename": "src/test/ui/async-await/dont-print-desugared-async.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdont-print-desugared-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdont-print-desugared-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-print-desugared-async.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,6 @@\n // Test that we don't show variables with from async fn desugaring\n \n // edition:2018\n-#![feature(async_await)]\n \n async fn async_fn(&ref mut s: &[i32]) {}\n //~^ ERROR cannot borrow data in a `&` reference as mutable [E0596]"}, {"sha": "2bf1e77f09b3fb1bf0edcdc46a76906944281533", "filename": "src/test/ui/async-await/dont-print-desugared-async.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdont-print-desugared-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdont-print-desugared-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-print-desugared-async.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/dont-print-desugared-async.rs:6:20\n+  --> $DIR/dont-print-desugared-async.rs:5:20\n    |\n LL | async fn async_fn(&ref mut s: &[i32]) {}\n    |                   -^^^^^^^^^"}, {"sha": "a8e5b38ec1dd8f3ce36692a903aed0372f435d00", "filename": "src/test/ui/async-await/dont-suggest-missing-await.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n \n // This test ensures we don't make the suggestion in bodies that aren't `async`.\n \n-#![feature(async_await)]\n-\n fn take_u32(x: u32) {}\n \n async fn make_u32() -> u32 {"}, {"sha": "c87e0bc221de7a8a47dac3ff816f0640d0e8441d", "filename": "src/test/ui/async-await/dont-suggest-missing-await.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/dont-suggest-missing-await.rs:16:18\n+  --> $DIR/dont-suggest-missing-await.rs:14:18\n    |\n LL |         take_u32(x)\n    |                  ^ expected u32, found opaque type"}, {"sha": "9817d377a7886f76edfc8ed05c247d8c5d724b5e", "filename": "src/test/ui/async-await/drop-order/drop-order-for-async-fn-parameters-by-ref-binding.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-async-fn-parameters-by-ref-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-async-fn-parameters-by-ref-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-async-fn-parameters-by-ref-binding.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,7 +3,6 @@\n // run-pass\n \n #![allow(unused_variables)]\n-#![feature(async_await)]\n \n // Test that the drop order for parameters in a fn and async fn matches up. Also test that\n // parameters (used or unused) are not dropped until the async fn completes execution."}, {"sha": "00072786a50a7524997dc8d5cd8f5e16d2e1af8e", "filename": "src/test/ui/async-await/drop-order/drop-order-for-async-fn-parameters.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-async-fn-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-async-fn-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-async-fn-parameters.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,7 +3,6 @@\n // run-pass\n \n #![allow(unused_variables)]\n-#![feature(async_await)]\n \n // Test that the drop order for parameters in a fn and async fn matches up. Also test that\n // parameters (used or unused) are not dropped until the async fn completes execution."}, {"sha": "5d020c9a52601cf8373fc48a7d9a905e7a7baa07", "filename": "src/test/ui/async-await/drop-order/drop-order-for-locals-when-cancelled.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-locals-when-cancelled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-locals-when-cancelled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-locals-when-cancelled.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,9 +2,7 @@\n // edition:2018\n // run-pass\n \n-#![allow(unused_variables)]\n #![deny(dead_code)]\n-#![feature(async_await)]\n \n // Test that the drop order for locals in a fn and async fn matches up.\n extern crate arc_wake;"}, {"sha": "79dedb1ba285e9796d4ca528d2a99629d4d5fc3c", "filename": "src/test/ui/async-await/drop-order/drop-order-locals-are-hidden.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-locals-are-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-locals-are-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-locals-are-hidden.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,5 @@\n // edition:2018\n \n-#![allow(unused_variables)]\n-#![feature(async_await)]\n-\n async fn foobar_async(x: u32, (a, _, _c): (u32, u32, u32), _: u32, _y: u32) {\n     assert_eq!(__arg1, (1, 2, 3)); //~ ERROR cannot find value `__arg1` in this scope [E0425]\n     assert_eq!(__arg2, 4); //~ ERROR cannot find value `__arg2` in this scope [E0425]"}, {"sha": "aa04a613f47c1298318fbb9184620c0982fd449e", "filename": "src/test/ui/async-await/drop-order/drop-order-locals-are-hidden.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-locals-are-hidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-locals-are-hidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-locals-are-hidden.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,23 +1,23 @@\n error[E0425]: cannot find value `__arg1` in this scope\n-  --> $DIR/drop-order-locals-are-hidden.rs:7:16\n+  --> $DIR/drop-order-locals-are-hidden.rs:4:16\n    |\n LL |     assert_eq!(__arg1, (1, 2, 3));\n    |                ^^^^^^ not found in this scope\n \n error[E0425]: cannot find value `__arg2` in this scope\n-  --> $DIR/drop-order-locals-are-hidden.rs:8:16\n+  --> $DIR/drop-order-locals-are-hidden.rs:5:16\n    |\n LL |     assert_eq!(__arg2, 4);\n    |                ^^^^^^ not found in this scope\n \n error[E0425]: cannot find value `__arg0` in this scope\n-  --> $DIR/drop-order-locals-are-hidden.rs:12:16\n+  --> $DIR/drop-order-locals-are-hidden.rs:9:16\n    |\n LL |     assert_eq!(__arg0, 1);\n    |                ^^^^^^ not found in this scope\n \n error[E0425]: cannot find value `__arg1` in this scope\n-  --> $DIR/drop-order-locals-are-hidden.rs:13:16\n+  --> $DIR/drop-order-locals-are-hidden.rs:10:16\n    |\n LL |     assert_eq!(__arg1, 2);\n    |                ^^^^^^ not found in this scope"}, {"sha": "84fe79348c601e0654a67c13c98e4293ed5f140c", "filename": "src/test/ui/async-await/drop-order/drop-order-when-cancelled.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-when-cancelled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-when-cancelled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-when-cancelled.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,9 +2,6 @@\n // edition:2018\n // run-pass\n \n-#![allow(unused_variables)]\n-#![feature(async_await)]\n-\n // Test that the drop order for parameters in a fn and async fn matches up. Also test that\n // parameters (used or unused) are not dropped until the async fn is cancelled.\n // This file is mostly copy-pasted from drop-order-for-async-fn-parameters.rs"}, {"sha": "c85896150c29f430ef00bdae4b5ab933450bd647", "filename": "src/test/ui/async-await/edition-deny-async-fns-2015.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,5 @@\n // edition:2015\n \n-#![feature(async_await)]\n-\n async fn foo() {} //~ ERROR `async fn` is not permitted in the 2015 edition\n \n fn baz() { async fn foo() {} } //~ ERROR `async fn` is not permitted in the 2015 edition"}, {"sha": "d3f88af09d13434ad7ca987432f2ac66f6d1ac6e", "filename": "src/test/ui/async-await/edition-deny-async-fns-2015.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,59 +1,59 @@\n error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/edition-deny-async-fns-2015.rs:5:1\n+  --> $DIR/edition-deny-async-fns-2015.rs:3:1\n    |\n LL | async fn foo() {}\n    | ^^^^^\n \n error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/edition-deny-async-fns-2015.rs:7:12\n+  --> $DIR/edition-deny-async-fns-2015.rs:5:12\n    |\n LL | fn baz() { async fn foo() {} }\n    |            ^^^^^\n \n error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/edition-deny-async-fns-2015.rs:10:5\n+  --> $DIR/edition-deny-async-fns-2015.rs:8:5\n    |\n LL |     async fn bar() {}\n    |     ^^^^^\n \n error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/edition-deny-async-fns-2015.rs:9:1\n+  --> $DIR/edition-deny-async-fns-2015.rs:7:1\n    |\n LL | async fn async_baz() {\n    | ^^^^^\n \n error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/edition-deny-async-fns-2015.rs:16:5\n+  --> $DIR/edition-deny-async-fns-2015.rs:14:5\n    |\n LL |     async fn foo() {}\n    |     ^^^^^\n \n error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/edition-deny-async-fns-2015.rs:20:5\n+  --> $DIR/edition-deny-async-fns-2015.rs:18:5\n    |\n LL |     async fn foo() {}\n    |     ^^^^^\n \n error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/edition-deny-async-fns-2015.rs:38:9\n+  --> $DIR/edition-deny-async-fns-2015.rs:36:9\n    |\n LL |         async fn bar() {}\n    |         ^^^^^\n \n error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/edition-deny-async-fns-2015.rs:28:9\n+  --> $DIR/edition-deny-async-fns-2015.rs:26:9\n    |\n LL |         async fn foo() {}\n    |         ^^^^^\n \n error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/edition-deny-async-fns-2015.rs:33:13\n+  --> $DIR/edition-deny-async-fns-2015.rs:31:13\n    |\n LL |             async fn bar() {}\n    |             ^^^^^\n \n error[E0706]: trait fns cannot be declared `async`\n-  --> $DIR/edition-deny-async-fns-2015.rs:20:5\n+  --> $DIR/edition-deny-async-fns-2015.rs:18:5\n    |\n LL |     async fn foo() {}\n    |     ^^^^^^^^^^^^^^^^^"}, {"sha": "963b19b34a620b2edd13825211b1c1c6a75f79d9", "filename": "src/test/ui/async-await/generics-and-bounds.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-#![feature(async_await)]\n-\n use std::future::Future;\n \n pub async fn simple_generic<T>() {}"}, {"sha": "9ee419c4a56fb16c0d2058c50cc33d8ef2f7c49c", "filename": "src/test/ui/async-await/issue-60709.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-60709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-60709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-60709.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4,9 +4,6 @@\n \n // run-pass\n \n-#![feature(async_await)]\n-#![allow(unused)]\n-\n use std::future::Future;\n use std::task::Poll;\n use std::task::Context;"}, {"sha": "9381251ad69688e1db8019c422b2e85f038736e9", "filename": "src/test/ui/async-await/issue-61452.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,4 @@\n // edition:2018\n-#![feature(async_await)]\n \n pub async fn f(x: Option<usize>) {\n     x.take();"}, {"sha": "5eb4b548717371107b022ab0fb562d3b7bbb698b", "filename": "src/test/ui/async-await/issue-61452.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,13 +1,13 @@\n error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n-  --> $DIR/issue-61452.rs:5:5\n+  --> $DIR/issue-61452.rs:4:5\n    |\n LL | pub async fn f(x: Option<usize>) {\n    |                - help: consider changing this to be mutable: `mut x`\n LL |     x.take();\n    |     ^ cannot borrow as mutable\n \n error[E0384]: cannot assign twice to immutable variable `x`\n-  --> $DIR/issue-61452.rs:10:5\n+  --> $DIR/issue-61452.rs:9:5\n    |\n LL | pub async fn g(x: usize) {\n    |                -"}, {"sha": "f6084be91674519aac6b194f964c1a026332f795", "filename": "src/test/ui/async-await/issue-61793.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61793.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61793.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61793.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -6,9 +6,6 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n \n-#![feature(async_await)]\n-#![allow(unused)]\n-\n async fn foo<F>(_: &(), _: F) {}\n \n fn main() {"}, {"sha": "6a28c69193da0db42b3a3208ddb33f07e3b9c342", "filename": "src/test/ui/async-await/issue-61949-self-return-type.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,6 +1,5 @@\n // ignore-tidy-linelength\n // edition:2018\n-#![feature(async_await)]\n \n // This test checks that `Self` is prohibited as a return type. See #61949 for context.\n "}, {"sha": "12fb77d8dd637efccac6bfb1cc21701d142ab6c8", "filename": "src/test/ui/async-await/issue-61949-self-return-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error: `async fn` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n-  --> $DIR/issue-61949-self-return-type.rs:12:40\n+  --> $DIR/issue-61949-self-return-type.rs:11:40\n    |\n LL |     pub async fn new(_bar: &'a i32) -> Self {\n    |                                        ^^^^"}, {"sha": "d0af01e0c009f97f88f27af9224edbb76a7f0a6f", "filename": "src/test/ui/async-await/issue-62658.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-62658.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissue-62658.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-62658.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4,8 +4,6 @@\n // build-pass\n // edition:2018\n \n-#![feature(async_await)]\n-\n async fn noop() {}\n \n async fn foo() {"}, {"sha": "09241f982aa8a6685e7bf31e4b5acb5d615a87be", "filename": "src/test/ui/async-await/issues/issue-51719.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n //\n // Tests that the .await syntax can't be used to make a generator\n \n-#![feature(async_await)]\n-\n async fn foo() {}\n \n fn make_generator() {"}, {"sha": "6c3c8889da7cee629183bb3bb48a6d60a0cbe811", "filename": "src/test/ui/async-await/issues/issue-51719.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/issue-51719.rs:10:19\n+  --> $DIR/issue-51719.rs:8:19\n    |\n LL |     let _gen = || foo().await;\n    |                -- ^^^^^^^^^^^ only allowed inside `async` functions and blocks"}, {"sha": "bc85a96cea99e90bdcdcab74ffd6b2cd2593d8a2", "filename": "src/test/ui/async-await/issues/issue-51751.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51751.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51751.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51751.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,5 @@\n // edition:2018\n \n-#![feature(async_await)]\n-\n async fn inc(limit: i64) -> i64 {\n     limit + 1\n }"}, {"sha": "e50c78534f852caa846b526cea558a64feac3f30", "filename": "src/test/ui/async-await/issues/issue-51751.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51751.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51751.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51751.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/issue-51751.rs:11:20\n+  --> $DIR/issue-51751.rs:9:20\n    |\n LL | fn main() {\n    |    ---- this is not `async`"}, {"sha": "5cae07044446081435ef16b3b69b7dda63265514", "filename": "src/test/ui/async-await/issues/issue-53249.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-53249.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-53249.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-53249.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,7 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n \n-#![feature(arbitrary_self_types, async_await)]\n+#![feature(arbitrary_self_types)]\n \n use std::task::{self, Poll};\n use std::future::Future;"}, {"sha": "64f260cfe01b63fb30860f49dfcca949d79cc41d", "filename": "src/test/ui/async-await/issues/issue-54752-async-block.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-54752-async-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-54752-async-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-54752-async-block.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,7 +3,4 @@\n // edition:2018\n // pp-exact\n \n-#![feature(async_await)]\n-#![allow(unused_parens)]\n-\n fn main() { let _a = (async  { }); }"}, {"sha": "9adc0a8232388b0d983f25a49a8e8a713792cf7e", "filename": "src/test/ui/async-await/issues/issue-54974.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-54974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-54974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-54974.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n \n-#![feature(async_await)]\n-\n use std::sync::Arc;\n \n trait SomeTrait: Send + Sync + 'static {"}, {"sha": "1d77d420127a88d7e3acfb087be53c507245e255", "filename": "src/test/ui/async-await/issues/issue-55324.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-55324.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-55324.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-55324.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,11 +1,8 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n \n-#![feature(async_await)]\n-\n use std::future::Future;\n \n-#[allow(unused)]\n async fn foo<F: Future<Output = i32>>(x: &i32, future: F) -> i32 {\n     let y = future.await;\n     *x + y"}, {"sha": "3b271775a385175b544d67877472601f2a2afb18", "filename": "src/test/ui/async-await/issues/issue-55809.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-55809.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-55809.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-55809.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // edition:2018\n // run-pass\n \n-#![feature(async_await)]\n-\n trait Foo { }\n \n impl Foo for () { }"}, {"sha": "72a45b5007d7af21488d040c7a99b84990299b7c", "filename": "src/test/ui/async-await/issues/issue-58885.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-58885.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-58885.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-58885.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n \n-#![feature(async_await)]\n-\n struct Xyz {\n     a: u64,\n }"}, {"sha": "ea780d9f62214922d558ee6d054562c07d952d0a", "filename": "src/test/ui/async-await/issues/issue-59001.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-59001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-59001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-59001.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,11 +1,8 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n \n-#![feature(async_await)]\n-\n use std::future::Future;\n \n-#[allow(unused)]\n async fn enter<'a, F, R>(mut callback: F)\n where\n     F: FnMut(&'a mut i32) -> R,"}, {"sha": "154226e8bb88ffbf1639b54c5728208cb86bd345", "filename": "src/test/ui/async-await/issues/issue-59972.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-59972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-59972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-59972.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -6,8 +6,6 @@\n \n // compile-flags: --edition=2018\n \n-#![feature(async_await)]\n-\n pub enum Uninhabited { }\n \n fn uninhabited_async() -> Uninhabited {\n@@ -16,14 +14,12 @@ fn uninhabited_async() -> Uninhabited {\n \n async fn noop() { }\n \n-#[allow(unused)]\n async fn contains_never() {\n     let error = uninhabited_async();\n     noop().await;\n     let error2 = error;\n }\n \n-#[allow(unused)]\n async fn overlap_never() {\n     let error1 = uninhabited_async();\n     noop().await;\n@@ -35,6 +31,4 @@ async fn overlap_never() {\n \n #[allow(unused_must_use)]\n fn main() {\n-    contains_never();\n-    overlap_never();\n }"}, {"sha": "1ca051607518edd805903dba034cbeef99b81357", "filename": "src/test/ui/async-await/issues/issue-60518.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60518.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60518.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60518.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n \n-#![feature(async_await)]\n-\n // This is a regression test to ensure that simple bindings (where replacement arguments aren't\n // created during async fn lowering) that have their DefId used during HIR lowering (such as impl\n // trait) are visited during def collection and thus have a DefId."}, {"sha": "0d015e54f8b1c3913477fa2329b627f178f659f8", "filename": "src/test/ui/async-await/issues/issue-60655-latebound-regions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60655-latebound-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60655-latebound-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60655-latebound-regions.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,7 +3,6 @@\n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n \n-#![feature(async_await)]\n #![feature(type_alias_impl_trait)]\n \n use std::future::Future;"}, {"sha": "c0e34a8df77a4e82ef3798a8200efb90378a75ec", "filename": "src/test/ui/async-await/issues/issue-60674.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60674.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60674.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60674.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,6 @@\n // aux-build:issue-60674.rs\n // build-pass (FIXME(62277): could be check-pass?)\n // edition:2018\n-#![feature(async_await)]\n \n // This is a regression test that ensures that `mut` patterns are not lost when provided as input\n // to a proc macro."}, {"sha": "8585a42511104aa67b15e2c8dada687012e45cb0", "filename": "src/test/ui/async-await/issues/issue-61187.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // edition:2018\n-#![feature(async_await)]\n \n-fn main() {\n-}\n+fn main() {}\n \n async fn response(data: Vec<u8>) {\n     data.reverse(); //~ ERROR E0596"}, {"sha": "4d361c824dd6da8de946c3789dc1aa400d66646e", "filename": "src/test/ui/async-await/issues/issue-61187.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0596]: cannot borrow `data` as mutable, as it is not declared as mutable\n-  --> $DIR/issue-61187.rs:8:5\n+  --> $DIR/issue-61187.rs:6:5\n    |\n LL | async fn response(data: Vec<u8>) {\n    |                   ---- help: consider changing this to be mutable: `mut data`"}, {"sha": "879bc6912fce94364d890d85a190d41cd947b2eb", "filename": "src/test/ui/async-await/issues/issue-61986.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61986.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4,8 +4,6 @@\n // Tests that we properly handle StorageDead/StorageLives for temporaries\n // created in async loop bodies.\n \n-#![feature(async_await)]\n-\n async fn bar() -> Option<()> {\n     Some(())\n }"}, {"sha": "3ee7ab2e9d12f5ed37adf1d826bb8f5c0b5674d3", "filename": "src/test/ui/async-await/issues/issue-62009-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,5 @@\n // edition:2018\n \n-#![feature(async_await)]\n-\n async fn print_dur() {}\n \n fn main() {"}, {"sha": "cd155f0fc32b6c44f2a2557d339a4d3ae449a910", "filename": "src/test/ui/async-await/issues/issue-62009-1.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,13 +1,13 @@\n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/issue-62009-1.rs:8:5\n+  --> $DIR/issue-62009-1.rs:6:5\n    |\n LL | fn main() {\n    |    ---- this is not `async`\n LL |     async { let (); }.await;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/issue-62009-1.rs:10:5\n+  --> $DIR/issue-62009-1.rs:8:5\n    |\n LL |   fn main() {\n    |      ---- this is not `async`\n@@ -19,19 +19,19 @@ LL | |     }.await;\n    | |___________^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/issue-62009-1.rs:14:5\n+  --> $DIR/issue-62009-1.rs:12:5\n    |\n LL | fn main() {\n    |    ---- this is not `async`\n ...\n LL |     (|_| 2333).await;\n    |     ^^^^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n-error[E0277]: the trait bound `[closure@$DIR/issue-62009-1.rs:14:5: 14:15]: std::future::Future` is not satisfied\n-  --> $DIR/issue-62009-1.rs:14:5\n+error[E0277]: the trait bound `[closure@$DIR/issue-62009-1.rs:12:5: 12:15]: std::future::Future` is not satisfied\n+  --> $DIR/issue-62009-1.rs:12:5\n    |\n LL |     (|_| 2333).await;\n-   |     ^^^^^^^^^^^^^^^^ the trait `std::future::Future` is not implemented for `[closure@$DIR/issue-62009-1.rs:14:5: 14:15]`\n+   |     ^^^^^^^^^^^^^^^^ the trait `std::future::Future` is not implemented for `[closure@$DIR/issue-62009-1.rs:12:5: 12:15]`\n    |\n    = note: required by `std::future::poll_with_tls_context`\n "}, {"sha": "cb7336e6134225b8c6aa651a47f298880997a86a", "filename": "src/test/ui/async-await/issues/issue-62009-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-2.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,6 +1,6 @@\n // edition:2018\n \n-#![feature(async_await, async_closure)]\n+#![feature(async_closure)]\n \n async fn print_dur() {}\n "}, {"sha": "4689ce36a78c03721ad9cf34e1a6d1266a75df96", "filename": "src/test/ui/async-await/issues/issue-62517-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -5,8 +5,6 @@\n // edition:2018\n // check-pass\n \n-#![feature(async_await)]\n-\n trait FirstTrait {}\n trait SecondTrait {\n     type Item: ?Sized;"}, {"sha": "aaf28d6c132e3970193413b02b4f277557dbc4b9", "filename": "src/test/ui/async-await/issues/issue-62517-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -5,8 +5,6 @@\n // edition:2018\n // check-pass\n \n-#![feature(async_await)]\n-\n trait Object {}\n \n trait Alpha<Param: ?Sized> {}"}, {"sha": "22610fe54a4cb1d8ed2f4eedb0fcf166829bb034", "filename": "src/test/ui/async-await/issues/issue-63388-1.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,13 +1,13 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-63388-1.rs:14:10\n+  --> $DIR/issue-63388-1.rs:12:10\n    |\n LL |     ) -> &dyn Foo\n    |          ^^^^^^^^\n    |\n    = note: hidden type `impl std::future::Future` captures lifetime '_#22r\n \n error: lifetime may not live long enough\n-  --> $DIR/issue-63388-1.rs:15:5\n+  --> $DIR/issue-63388-1.rs:13:5\n    |\n LL |       async fn do_sth<'a>(\n    |                       -- lifetime `'a` defined here"}, {"sha": "3cde5de2198806617d56e74727a0ca4795f6d38f", "filename": "src/test/ui/async-await/issues/issue-63388-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,5 @@\n // edition:2018\n \n-#![feature(async_await)]\n-\n struct Xyz {\n     a: u64,\n }"}, {"sha": "a54cadb0cd2517abb6b15a82daf488f2f4d41cce", "filename": "src/test/ui/async-await/issues/issue-63388-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/issue-63388-1.rs:14:10\n+  --> $DIR/issue-63388-1.rs:12:10\n    |\n LL |         &'a self, foo: &dyn Foo\n    |         -------- this parameter and the return type are declared with different lifetimes..."}, {"sha": "7781af89deae2d5b9d80fb171e03cb629e9b1557", "filename": "src/test/ui/async-await/issues/issue-63388-2.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.nll.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-63388-2.rs:14:10\n+  --> $DIR/issue-63388-2.rs:12:10\n    |\n LL |     ) -> &dyn Foo\n    |          ^ help: consider using the named lifetime: `&'a`"}, {"sha": "73e7f25f97d0d82140a13bae39c93f3717587ccd", "filename": "src/test/ui/async-await/issues/issue-63388-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,5 @@\n // edition:2018\n \n-#![feature(async_await)]\n-\n struct Xyz {\n     a: u64,\n }"}, {"sha": "1edeb3d54938968b34816c88ecf5e2210989e390", "filename": "src/test/ui/async-await/issues/issue-63388-2.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,25 +1,25 @@\n error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-63388-2.rs:14:10\n+  --> $DIR/issue-63388-2.rs:12:10\n    |\n LL |     ) -> &dyn Foo\n    |          ^ help: consider using the named lifetime: `&'a`\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `foo` or `bar`\n \n error: cannot infer an appropriate lifetime\n-  --> $DIR/issue-63388-2.rs:13:9\n+  --> $DIR/issue-63388-2.rs:11:9\n    |\n LL |         foo: &dyn Foo, bar: &'a dyn Foo\n    |         ^^^ ...but this borrow...\n LL |     ) -> &dyn Foo\n    |          -------- this return type evaluates to the `'static` lifetime...\n    |\n-note: ...can't outlive the lifetime '_ as defined on the method body at 13:14\n-  --> $DIR/issue-63388-2.rs:13:14\n+note: ...can't outlive the lifetime '_ as defined on the method body at 11:14\n+  --> $DIR/issue-63388-2.rs:11:14\n    |\n LL |         foo: &dyn Foo, bar: &'a dyn Foo\n    |              ^\n-help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime '_ as defined on the method body at 13:14\n+help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime '_ as defined on the method body at 11:14\n    |\n LL |     ) -> &dyn Foo + '_\n    |          ^^^^^^^^^^^^^"}, {"sha": "1a9822e02fa0199c12eaec42e7e21a7fbf09e85d", "filename": "src/test/ui/async-await/issues/issue-63388-3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-3.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // edition:2018\n // check-pass\n \n-#![feature(async_await)]\n-\n struct Xyz {\n     a: u64,\n }"}, {"sha": "58f9dacb3bcfa26611aff7a5905dc876b0e78566", "filename": "src/test/ui/async-await/issues/issue-63388-4.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-4.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // check-pass\n // edition:2018\n \n-#![feature(async_await)]\n-\n struct A;\n \n impl A {"}, {"sha": "d47c2137725d61f6b9780ce57248de31e4be8e80", "filename": "src/test/ui/async-await/issues/non-async-enclosing-span.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,4 @@\n // edition:2018\n-#![feature(async_await)]\n \n async fn do_the_thing() -> u8 {\n     8"}, {"sha": "49ebf414c550bb4242f3182b6b35aca02bdf8fa1", "filename": "src/test/ui/async-await/issues/non-async-enclosing-span.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/non-async-enclosing-span.rs:10:13\n+  --> $DIR/non-async-enclosing-span.rs:9:13\n    |\n LL | fn main() {\n    |    ---- this is not `async`"}, {"sha": "39ea2aae563a4111b845405dad533c8f7dfb799c", "filename": "src/test/ui/async-await/move-part-await-return-rest-struct.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmove-part-await-return-rest-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmove-part-await-return-rest-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmove-part-await-return-rest-struct.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-#![feature(async_await)]\n-\n struct Small {\n     x: Vec<usize>,\n     y: Vec<usize>,"}, {"sha": "7b958b98b414f4d2f6b552619c1545fdcc7cf76c", "filename": "src/test/ui/async-await/move-part-await-return-rest-tuple.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmove-part-await-return-rest-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmove-part-await-return-rest-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmove-part-await-return-rest-tuple.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-#![feature(async_await)]\n-\n async fn move_part_await_return_rest_tuple() -> Vec<usize> {\n     let x = (vec![3], vec![4, 4]);\n     drop(x.1);"}, {"sha": "8258e2eff521bb012e65f950c0579caa4f5487f6", "filename": "src/test/ui/async-await/multiple-lifetimes/elided.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Felided.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Felided.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Felided.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,8 +3,6 @@\n \n // Test that we can use async fns with multiple arbitrary lifetimes.\n \n-#![feature(async_await)]\n-\n async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n \n fn main() {"}, {"sha": "3912b854747de903e3fa71f5a52600ea0bcf19c2", "filename": "src/test/ui/async-await/multiple-lifetimes/fn-ptr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Ffn-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Ffn-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Ffn-ptr.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,8 +3,6 @@\n \n // Test that we can use async fns with multiple arbitrary lifetimes.\n \n-#![feature(async_await)]\n-\n async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8, _: fn(&u8)) {}\n \n fn gimme(_: &u8) { }"}, {"sha": "31d0736ba63c845ca4d7a21943164e3964f8de9c", "filename": "src/test/ui/async-await/multiple-lifetimes/hrtb.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fhrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fhrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fhrtb.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,9 +3,6 @@\n \n // Test that we can use async fns with multiple arbitrary lifetimes.\n \n-#![feature(async_await)]\n-#![allow(dead_code)]\n-\n use std::ops::Add;\n \n async fn multiple_hrtb_and_single_named_lifetime_ok<'c>("}, {"sha": "e8eb98102f478fd58280aba4c13ec73397687bf7", "filename": "src/test/ui/async-await/multiple-lifetimes/named.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fnamed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fnamed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fnamed.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,8 +3,6 @@\n \n // Test that we can use async fns with multiple arbitrary lifetimes.\n \n-#![feature(async_await)]\n-\n async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n \n fn main() {"}, {"sha": "02b105999f5bb2e55d4b0e98fe60961a48349ee3", "filename": "src/test/ui/async-await/multiple-lifetimes/partial-relation.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fpartial-relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fpartial-relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fpartial-relation.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // edition:2018\n // run-pass\n \n-#![feature(async_await)]\n-\n async fn lotsa_lifetimes<'a, 'b, 'c>(a: &'a u32, b: &'b u32, c: &'c u32) -> (&'a u32, &'b u32)\n     where 'b: 'a\n {"}, {"sha": "b901b61aa1898315ae38e6a1f7041b11e64d8500", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-fg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-fg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-fg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-fg.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4,7 +4,7 @@\n // Test that a feature gate is needed to use `impl Trait` as the\n // return type of an async.\n \n-#![feature(async_await, member_constraints)]\n+#![feature(member_constraints)]\n \n trait Trait<'a, 'b> { }\n impl<T> Trait<'_, '_> for T { }"}, {"sha": "2c7a5cd378fc2d4e4723d32bcbb3d5811b8887e0", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-no-fg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,8 +3,6 @@\n // Test that a feature gate is needed to use `impl Trait` as the\n // return type of an async.\n \n-#![feature(async_await)]\n-\n trait Trait<'a, 'b> { }\n impl<T> Trait<'_, '_> for T { }\n "}, {"sha": "59d7728d41c4cfa2a67d27c3495a8aaa7611f8bf", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-no-fg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error: ambiguous lifetime bound in `impl Trait`\n-  --> $DIR/ret-impl-trait-no-fg.rs:11:64\n+  --> $DIR/ret-impl-trait-no-fg.rs:9:64\n    |\n LL | async fn async_ret_impl_trait<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n    |                                                                ^^^^^^^^^^^^^^^^^^ neither `'a` nor `'b` outlives the other"}, {"sha": "babc90a5e96ad395e3e14a9c68b2869a3b6e793f", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,7 +3,7 @@\n // Test that a feature gate is needed to use `impl Trait` as the\n // return type of an async.\n \n-#![feature(async_await, member_constraints)]\n+#![feature(member_constraints)]\n \n trait Trait<'a> { }\n impl<T> Trait<'_> for T { }"}, {"sha": "149c020f9cb9c7c24fa93423c8106b2c693c7a96", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-ref.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4,8 +4,6 @@\n // function (which takes multiple lifetimes) only returns data from\n // one of them.\n \n-#![feature(async_await)]\n-\n async fn multiple_named_lifetimes<'a, 'b>(a: &'a u8, _: &'b u8) -> &'a u8 {\n     a\n }"}, {"sha": "d86e84033b8cd688191c48f0926dc1ea2256da36", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-ref.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-ref.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0506]: cannot assign to `a` because it is borrowed\n-  --> $DIR/ret-ref.rs:18:5\n+  --> $DIR/ret-ref.rs:16:5\n    |\n LL |     let future = multiple_named_lifetimes(&a, &b);\n    |                                           -- borrow of `a` occurs here\n@@ -10,7 +10,7 @@ LL |     let p = future.await;\n    |             ------ borrow later used here\n \n error[E0506]: cannot assign to `b` because it is borrowed\n-  --> $DIR/ret-ref.rs:19:5\n+  --> $DIR/ret-ref.rs:17:5\n    |\n LL |     let future = multiple_named_lifetimes(&a, &b);\n    |                                               -- borrow of `b` occurs here\n@@ -21,7 +21,7 @@ LL |     let p = future.await;\n    |             ------ borrow later used here\n \n error[E0506]: cannot assign to `a` because it is borrowed\n-  --> $DIR/ret-ref.rs:30:5\n+  --> $DIR/ret-ref.rs:28:5\n    |\n LL |     let future = multiple_named_lifetimes(&a, &b);\n    |                                           -- borrow of `a` occurs here"}, {"sha": "6ed8bef956a52f1cae057dd5e70006b901572cb5", "filename": "src/test/ui/async-await/multiple-lifetimes/variance.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fvariance.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4,9 +4,6 @@\n // Test for async fn where the parameters have distinct lifetime\n // parameters that appear in all possible variances.\n \n-#![feature(async_await)]\n-\n-#[allow(dead_code)]\n async fn lotsa_lifetimes<'a, 'b, 'c>(_: fn(&'a u8), _: fn(&'b u8) -> &'b u8, _: fn() -> &'c u8) { }\n \n fn take_any(_: &u8) { }"}, {"sha": "76ed827d5973e4e9b4427840af9eda54a70c0a90", "filename": "src/test/ui/async-await/nested-in-impl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fnested-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fnested-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fnested-in-impl.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4,8 +4,6 @@\n // check-pass\n // edition:2018\n \n-#![feature(async_await)]\n-\n struct Foo<'a>(&'a ());\n \n impl<'a> Foo<'a> {"}, {"sha": "0ca50807f2626b3047bc230c46fc39f0cd747c84", "filename": "src/test/ui/async-await/no-args-non-move-async-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-args-non-move-async-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-args-non-move-async-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-args-non-move-async-closure.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,6 +1,6 @@\n // edition:2018\n \n-#![feature(async_await, async_closure)]\n+#![feature(async_closure)]\n \n fn main() {\n     let _ = async |x: u8| {};"}, {"sha": "7a6eb498b2ee0b3c0538a4102990d81da542a54f", "filename": "src/test/ui/async-await/no-async-const.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,7 +2,5 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-#![feature(async_await)]\n-\n pub async const fn x() {}\n //~^ ERROR expected one of `fn` or `unsafe`, found `const`"}, {"sha": "edbdfb5652281a02fd78a93e3e751ba54c7589fe", "filename": "src/test/ui/async-await/no-async-const.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error: expected one of `fn` or `unsafe`, found `const`\n-  --> $DIR/no-async-const.rs:7:11\n+  --> $DIR/no-async-const.rs:5:11\n    |\n LL | pub async const fn x() {}\n    |           ^^^^^ expected one of `fn` or `unsafe` here"}, {"sha": "bd78a18a40ed9e6ba527bf830693232f641fd769", "filename": "src/test/ui/async-await/no-const-async.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-#![feature(async_await)]\n-\n pub const async fn x() {}\n //~^ ERROR expected identifier, found reserved keyword `async`\n //~^^ expected `:`, found keyword `fn`"}, {"sha": "6d7df57e7b6afee01eddf591ca8877049caf834d", "filename": "src/test/ui/async-await/no-const-async.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error: expected identifier, found reserved keyword `async`\n-  --> $DIR/no-const-async.rs:7:11\n+  --> $DIR/no-const-async.rs:5:11\n    |\n LL | pub const async fn x() {}\n    |           ^^^^^ expected identifier, found reserved keyword\n@@ -9,7 +9,7 @@ LL | pub const r#async fn x() {}\n    |           ^^^^^^^\n \n error: expected `:`, found keyword `fn`\n-  --> $DIR/no-const-async.rs:7:17\n+  --> $DIR/no-const-async.rs:5:17\n    |\n LL | pub const async fn x() {}\n    |                 ^^ expected `:`"}, {"sha": "bef477bd256ec3a769c351ac03e8e12514becfe3", "filename": "src/test/ui/async-await/no-move-across-await-struct.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-struct.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-#![feature(async_await)]\n-\n async fn no_move_across_await_struct() -> Vec<usize> {\n     let s = Small { x: vec![31], y: vec![19, 1441] };\n     needs_vec(s.x).await;"}, {"sha": "88f147b8d9ddd10ec8fa1fea8261d3a6ac62b970", "filename": "src/test/ui/async-await/no-move-across-await-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-struct.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: use of moved value: `s.x`\n-  --> $DIR/no-move-across-await-struct.rs:10:5\n+  --> $DIR/no-move-across-await-struct.rs:8:5\n    |\n LL |     needs_vec(s.x).await;\n    |               --- value moved here"}, {"sha": "565cbd7d5f4aeaeb5452e968168fbfed99e5d418", "filename": "src/test/ui/async-await/no-move-across-await-tuple.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-tuple.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-#![feature(async_await)]\n-\n async fn no_move_across_await_tuple() -> Vec<usize> {\n     let x = (vec![3], vec![4, 4]);\n     drop(x.1);"}, {"sha": "fe98ecd599a2348b9c172c3c826e896f58021846", "filename": "src/test/ui/async-await/no-move-across-await-tuple.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-move-across-await-tuple.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: use of moved value: `x.1`\n-  --> $DIR/no-move-across-await-tuple.rs:11:5\n+  --> $DIR/no-move-across-await-tuple.rs:9:5\n    |\n LL |     drop(x.1);\n    |          --- value moved here"}, {"sha": "0afbf4cee1d3c881ada8d028fb25c71b51dbc0e7", "filename": "src/test/ui/async-await/no-non-guaranteed-initialization.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-non-guaranteed-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-non-guaranteed-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-non-guaranteed-initialization.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-#![feature(async_await)]\n-\n async fn no_non_guaranteed_initialization(x: usize) -> usize {\n     let y;\n     if x > 5 {"}, {"sha": "91d7994654f37448f5ed6f4c5e2f9f613f17ceec", "filename": "src/test/ui/async-await/no-non-guaranteed-initialization.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-non-guaranteed-initialization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fno-non-guaranteed-initialization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-non-guaranteed-initialization.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0381]: use of possibly uninitialized variable: `y`\n-  --> $DIR/no-non-guaranteed-initialization.rs:12:5\n+  --> $DIR/no-non-guaranteed-initialization.rs:10:5\n    |\n LL |     y\n    |     ^ use of possibly uninitialized `y`"}, {"sha": "1785fb7f29947757deddf633df07da57636b42bc", "filename": "src/test/ui/async-await/partial-initialization-across-await.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,8 +3,6 @@\n \n // edition:2018\n \n-#![feature(async_await)]\n-\n struct S { x: i32, y: i32 }\n struct T(i32, i32);\n "}, {"sha": "d9a2db985e54ddc4db7b55fd3b857b686507c604", "filename": "src/test/ui/async-await/partial-initialization-across-await.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,17 +1,17 @@\n error[E0381]: assign to part of possibly uninitialized variable: `t`\n-  --> $DIR/partial-initialization-across-await.rs:15:5\n+  --> $DIR/partial-initialization-across-await.rs:13:5\n    |\n LL |     t.0 = 42;\n    |     ^^^^^^^^ use of possibly uninitialized `t`\n \n error[E0381]: assign to part of possibly uninitialized variable: `t`\n-  --> $DIR/partial-initialization-across-await.rs:24:5\n+  --> $DIR/partial-initialization-across-await.rs:22:5\n    |\n LL |     t.0 = 42;\n    |     ^^^^^^^^ use of possibly uninitialized `t`\n \n error[E0381]: assign to part of possibly uninitialized variable: `t`\n-  --> $DIR/partial-initialization-across-await.rs:33:5\n+  --> $DIR/partial-initialization-across-await.rs:31:5\n    |\n LL |     t.x = 42;\n    |     ^^^^^^^^ use of possibly uninitialized `t`"}, {"sha": "aa7733194587da20ba4238a02da39f729f0445a0", "filename": "src/test/ui/async-await/recursive-async-impl-trait-type.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,8 +2,6 @@\n // Test that impl trait does not allow creating recursive types that are\n // otherwise forbidden when using `async` and `await`.\n \n-#![feature(async_await)]\n-\n async fn recursive_async_function() -> () { //~ ERROR\n     recursive_async_function().await;\n }"}, {"sha": "8781a9c444d0a5c50e97277614ffd3f06d0e9555", "filename": "src/test/ui/async-await/recursive-async-impl-trait-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0733]: recursion in an `async fn` requires boxing\n-  --> $DIR/recursive-async-impl-trait-type.rs:7:40\n+  --> $DIR/recursive-async-impl-trait-type.rs:5:40\n    |\n LL | async fn recursive_async_function() -> () {\n    |                                        ^^ an `async fn` cannot invoke itself directly"}, {"sha": "37b30ffe6800f7f6c2de77b970b3e6ada1d474f1", "filename": "src/test/ui/async-await/suggest-missing-await-closure.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.fixed?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n // run-rustfix\n \n-#![feature(async_await, async_closure)]\n+#![feature(async_closure)]\n \n fn take_u32(_x: u32) {}\n "}, {"sha": "18076a1516171cfa5346c45e9de63791bca7041e", "filename": "src/test/ui/async-await/suggest-missing-await-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n // run-rustfix\n \n-#![feature(async_await, async_closure)]\n+#![feature(async_closure)]\n \n fn take_u32(_x: u32) {}\n "}, {"sha": "7c02a907ce7ad03649175f63ad5ef81411b6f149", "filename": "src/test/ui/async-await/suggest-missing-await.fixed", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // edition:2018\n // run-rustfix\n \n-#![feature(async_await)]\n-\n fn take_u32(_x: u32) {}\n \n async fn make_u32() -> u32 {"}, {"sha": "91abd44e65caf3294d9b70b99043cacf3ebe1a5d", "filename": "src/test/ui/async-await/suggest-missing-await.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,6 @@\n // edition:2018\n // run-rustfix\n \n-#![feature(async_await)]\n-\n fn take_u32(_x: u32) {}\n \n async fn make_u32() -> u32 {"}, {"sha": "ccca97ec204b46c5f241cba5711cfea4ae9e6955", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:15:14\n+  --> $DIR/suggest-missing-await.rs:13:14\n    |\n LL |     take_u32(x)\n    |              ^"}, {"sha": "d8ea87d2775bdf7a624c620310daa9989d607c58", "filename": "src/test/ui/async-await/unresolved_type_param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,7 +2,7 @@\n // Error message should pinpoint the type parameter T as needing to be bound\n // (rather than give a general error message)\n // edition:2018\n-#![feature(async_await)]\n+\n async fn bar<T>() -> () {}\n \n async fn foo() {"}, {"sha": "c424c25c646bd34d61b7a7ae4d6fbe3f580ea735", "filename": "src/test/ui/break-outside-loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fbreak-outside-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fbreak-outside-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbreak-outside-loop.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -7,8 +7,8 @@ fn cond() -> bool { true }\n fn foo<F>(_: F) where F: FnOnce() {}\n \n fn main() {\n-    let pth = break; //~ ERROR: `break` outside of loop\n-    if cond() { continue } //~ ERROR: `continue` outside of loop\n+    let pth = break; //~ ERROR: `break` outside of a loop\n+    if cond() { continue } //~ ERROR: `continue` outside of a loop\n \n     while cond() {\n         if cond() { break }\n@@ -21,5 +21,5 @@ fn main() {\n \n     let rs: Foo = Foo{t: pth};\n \n-    let unconstrained = break; //~ ERROR: `break` outside of loop\n+    let unconstrained = break; //~ ERROR: `break` outside of a loop\n }"}, {"sha": "8b686356055a34bef3b4abad3ecad33e9af76a8c", "filename": "src/test/ui/break-outside-loop.stderr", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fbreak-outside-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fbreak-outside-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbreak-outside-loop.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,32 +1,37 @@\n-error[E0268]: `break` outside of loop\n+error[E0268]: `break` outside of a loop\n   --> $DIR/break-outside-loop.rs:10:15\n    |\n LL |     let pth = break;\n-   |               ^^^^^ cannot break outside of a loop\n+   |               ^^^^^ cannot `break` outside of a loop\n \n-error[E0268]: `continue` outside of loop\n+error[E0268]: `continue` outside of a loop\n   --> $DIR/break-outside-loop.rs:11:17\n    |\n LL |     if cond() { continue }\n-   |                 ^^^^^^^^ cannot break outside of a loop\n+   |                 ^^^^^^^^ cannot `continue` outside of a loop\n \n error[E0267]: `break` inside of a closure\n   --> $DIR/break-outside-loop.rs:17:25\n    |\n+LL |         foo(|| {\n+   |             -- enclosing closure\n LL |             if cond() { break }\n-   |                         ^^^^^ cannot break inside of a closure\n+   |                         ^^^^^ cannot `break` inside of a closure\n \n error[E0267]: `continue` inside of a closure\n   --> $DIR/break-outside-loop.rs:18:25\n    |\n+LL |         foo(|| {\n+   |             -- enclosing closure\n+LL |             if cond() { break }\n LL |             if cond() { continue }\n-   |                         ^^^^^^^^ cannot break inside of a closure\n+   |                         ^^^^^^^^ cannot `continue` inside of a closure\n \n-error[E0268]: `break` outside of loop\n+error[E0268]: `break` outside of a loop\n   --> $DIR/break-outside-loop.rs:24:25\n    |\n LL |     let unconstrained = break;\n-   |                         ^^^^^ cannot break outside of a loop\n+   |                         ^^^^^ cannot `break` outside of a loop\n \n error: aborting due to 5 previous errors\n "}, {"sha": "f3567db1fac9c964697e394ba9646d369a238417", "filename": "src/test/ui/closures/closure-array-break-length.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,9 +1,9 @@\n fn main() {\n-    |_: [_; continue]| {}; //~ ERROR: `continue` outside of loop\n+    |_: [_; continue]| {}; //~ ERROR: `continue` outside of a loop\n \n-    while |_: [_; continue]| {} {} //~ ERROR: `continue` outside of loop\n+    while |_: [_; continue]| {} {} //~ ERROR: `continue` outside of a loop\n     //~^ ERROR mismatched types\n \n-    while |_: [_; break]| {} {} //~ ERROR: `break` outside of loop\n+    while |_: [_; break]| {} {} //~ ERROR: `break` outside of a loop\n     //~^ ERROR mismatched types\n }"}, {"sha": "18da4a94e6f05853d794fe555adf6b88196c98c9", "filename": "src/test/ui/closures/closure-array-break-length.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,20 +1,20 @@\n-error[E0268]: `continue` outside of loop\n+error[E0268]: `continue` outside of a loop\n   --> $DIR/closure-array-break-length.rs:2:13\n    |\n LL |     |_: [_; continue]| {};\n-   |             ^^^^^^^^ cannot break outside of a loop\n+   |             ^^^^^^^^ cannot `continue` outside of a loop\n \n-error[E0268]: `continue` outside of loop\n+error[E0268]: `continue` outside of a loop\n   --> $DIR/closure-array-break-length.rs:4:19\n    |\n LL |     while |_: [_; continue]| {} {}\n-   |                   ^^^^^^^^ cannot break outside of a loop\n+   |                   ^^^^^^^^ cannot `continue` outside of a loop\n \n-error[E0268]: `break` outside of loop\n+error[E0268]: `break` outside of a loop\n   --> $DIR/closure-array-break-length.rs:7:19\n    |\n LL |     while |_: [_; break]| {} {}\n-   |                   ^^^^^ cannot break outside of a loop\n+   |                   ^^^^^ cannot `break` outside of a loop\n \n error[E0308]: mismatched types\n   --> $DIR/closure-array-break-length.rs:4:11"}, {"sha": "c070b0c2400d84bf703e9c647d2b988c60fca366", "filename": "src/test/ui/commandline-argfile-badutf8.args", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.args", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.args", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.args?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,2 @@\n+--cfg\n+unbroken\ufffd\n\\ No newline at end of file"}, {"sha": "161715685b57fa70d35e1ebc4467017c439273fd", "filename": "src/test/ui/commandline-argfile-badutf8.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,13 @@\n+// Check to see if we can get parameters from an @argsfile file\n+//\n+// build-fail\n+// compile-flags: --cfg cmdline_set @{{src-base}}/commandline-argfile-badutf8.args\n+\n+#[cfg(not(cmdline_set))]\n+compile_error!(\"cmdline_set not set\");\n+\n+#[cfg(not(unbroken))]\n+compile_error!(\"unbroken not set\");\n+\n+fn main() {\n+}"}, {"sha": "9af6fc0a518dfd05e76c56920bbd17ff3359e18e", "filename": "src/test/ui/commandline-argfile-badutf8.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,2 @@\n+error: Failed to load argument file: Utf8 error in $DIR/commandline-argfile-badutf8.args\n+"}, {"sha": "a29b4ab062de34c90ed2308687048590fece805e", "filename": "src/test/ui/commandline-argfile-missing.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommandline-argfile-missing.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,16 @@\n+// Check to see if we can get parameters from an @argsfile file\n+//\n+// ignore-tidy-linelength\n+// build-fail\n+// normalize-stderr-test: \"os error \\d+\" -> \"os error $$ERR\"\n+// normalize-stderr-test: \"commandline-argfile-missing.args:[^(]*\" -> \"commandline-argfile-missing.args: $$FILE_MISSING \"\n+// compile-flags: --cfg cmdline_set @{{src-base}}/commandline-argfile-missing.args\n+\n+#[cfg(not(cmdline_set))]\n+compile_error!(\"cmdline_set not set\");\n+\n+#[cfg(not(unbroken))]\n+compile_error!(\"unbroken not set\");\n+\n+fn main() {\n+}"}, {"sha": "179ad83100419591c92ae7f948be2255c2fcd193", "filename": "src/test/ui/commandline-argfile-missing.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile-missing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile-missing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommandline-argfile-missing.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,2 @@\n+error: Failed to load argument file: IO Error: $DIR/commandline-argfile-missing.args: $FILE_MISSING (os error $ERR)\n+"}, {"sha": "972938bf6c8dddf9a1a3a24d94e3fdc20f07fc29", "filename": "src/test/ui/commandline-argfile.args", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile.args", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile.args", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommandline-argfile.args?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,2 @@\n+--cfg\n+unbroken\n\\ No newline at end of file"}, {"sha": "fc1ba0c8d677d7a57d8d3eb9c1e415107449ccb6", "filename": "src/test/ui/commandline-argfile.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fcommandline-argfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommandline-argfile.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,13 @@\n+// Check to see if we can get parameters from an @argsfile file\n+//\n+// build-pass\n+// compile-flags: --cfg cmdline_set @{{src-base}}/commandline-argfile.args\n+\n+#[cfg(not(cmdline_set))]\n+compile_error!(\"cmdline_set not set\");\n+\n+#[cfg(not(unbroken))]\n+compile_error!(\"unbroken not set\");\n+\n+fn main() {\n+}"}, {"sha": "7dbeba53afcfe61739ffbb50f05d6821c8ed9a5a", "filename": "src/test/ui/conditional-compilation/cfg-attr-crate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -3,6 +3,6 @@\n // compile-flags: --cfg broken\n \n #![crate_type = \"lib\"]\n-#![cfg_attr(broken, no_core)] //~ ERROR no_core is experimental\n+#![cfg_attr(broken, no_core)] //~ ERROR the `#[no_core]` attribute is an experimental feature\n \n pub struct S {}"}, {"sha": "7b77701ee190f86885c13a581df3ec430be6c338", "filename": "src/test/ui/conditional-compilation/cfg-attr-crate-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: no_core is experimental\n+error[E0658]: the `#[no_core]` attribute is an experimental feature\n   --> $DIR/cfg-attr-crate-2.rs:6:21\n    |\n LL | #![cfg_attr(broken, no_core)]"}, {"sha": "42ffb71e3d7b92dc10fe7a28089747ab65b773a8", "filename": "src/test/ui/conditional-compilation/cfg-attr-multi-invalid-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,6 +1,7 @@\n // compile-flags: --cfg broken\n \n #![crate_type = \"lib\"]\n-#![cfg_attr(broken, no_core, no_std)] //~ ERROR no_core is experimental\n+#![cfg_attr(broken, no_core, no_std)]\n+//~^ ERROR the `#[no_core]` attribute is an experimental feature\n \n pub struct S {}"}, {"sha": "ab7e1eb96032d401685cc43cc7b13ce72662d04d", "filename": "src/test/ui/conditional-compilation/cfg-attr-multi-invalid-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: no_core is experimental\n+error[E0658]: the `#[no_core]` attribute is an experimental feature\n   --> $DIR/cfg-attr-multi-invalid-1.rs:4:21\n    |\n LL | #![cfg_attr(broken, no_core, no_std)]"}, {"sha": "29690e2848f2d7ba0901f67302bee6f535846c49", "filename": "src/test/ui/conditional-compilation/cfg-attr-multi-invalid-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,6 +1,7 @@\n // compile-flags: --cfg broken\n \n #![crate_type = \"lib\"]\n-#![cfg_attr(broken, no_std, no_core)] //~ ERROR no_core is experimental\n+#![cfg_attr(broken, no_std, no_core)]\n+//~^ ERROR the `#[no_core]` attribute is an experimental feature\n \n pub struct S {}"}, {"sha": "8126affbd36cd02c395b388dcd4df407ddfa8a62", "filename": "src/test/ui/conditional-compilation/cfg-attr-multi-invalid-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: no_core is experimental\n+error[E0658]: the `#[no_core]` attribute is an experimental feature\n   --> $DIR/cfg-attr-multi-invalid-2.rs:4:29\n    |\n LL | #![cfg_attr(broken, no_std, no_core)]"}, {"sha": "4281874a0314d700d9de6bf1775f28b53f38a6d1", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_bad.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,16 @@\n+const fn bad_const_fn_deref_raw(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n+//~^ dereferencing raw pointers in constant functions\n+\n+const unsafe fn bad_const_unsafe_deref_raw(x: *mut usize) -> usize { *x }\n+//~^ dereferencing raw pointers in constant functions\n+\n+const unsafe fn bad_const_unsafe_deref_raw_ref(x: *mut usize) -> &'static usize { &*x }\n+//~^ dereferencing raw pointers in constant functions\n+\n+fn main() {}\n+\n+const unsafe fn no_union() {\n+    union Foo { x: (), y: () }\n+    Foo { x: () }.y\n+    //~^ unions in const fn\n+}"}, {"sha": "9de0e732f33d242f9fe91791dfd6d02d629046c6", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_bad.stderr", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: dereferencing raw pointers in constant functions is unstable\n-  --> $DIR/min_const_fn_unsafe.rs:50:77\n+  --> $DIR/min_const_fn_unsafe_bad.rs:1:77\n    |\n LL | const fn bad_const_fn_deref_raw(x: *mut usize) -> &'static usize { unsafe { &*x } }\n    |                                                                             ^^^\n@@ -8,7 +8,7 @@ LL | const fn bad_const_fn_deref_raw(x: *mut usize) -> &'static usize { unsafe {\n    = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n \n error[E0658]: dereferencing raw pointers in constant functions is unstable\n-  --> $DIR/min_const_fn_unsafe.rs:53:70\n+  --> $DIR/min_const_fn_unsafe_bad.rs:4:70\n    |\n LL | const unsafe fn bad_const_unsafe_deref_raw(x: *mut usize) -> usize { *x }\n    |                                                                      ^^\n@@ -17,7 +17,7 @@ LL | const unsafe fn bad_const_unsafe_deref_raw(x: *mut usize) -> usize { *x }\n    = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n \n error[E0658]: dereferencing raw pointers in constant functions is unstable\n-  --> $DIR/min_const_fn_unsafe.rs:56:83\n+  --> $DIR/min_const_fn_unsafe_bad.rs:7:83\n    |\n LL | const unsafe fn bad_const_unsafe_deref_raw_ref(x: *mut usize) -> &'static usize { &*x }\n    |                                                                                   ^^^\n@@ -26,7 +26,7 @@ LL | const unsafe fn bad_const_unsafe_deref_raw_ref(x: *mut usize) -> &'static u\n    = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n \n error[E0658]: unions in const fn are unstable\n-  --> $DIR/min_const_fn_unsafe.rs:63:5\n+  --> $DIR/min_const_fn_unsafe_bad.rs:14:5\n    |\n LL |     Foo { x: () }.y\n    |     ^^^^^^^^^^^^^^^\n@@ -35,7 +35,7 @@ LL |     Foo { x: () }.y\n    = help: add `#![feature(const_fn_union)]` to the crate attributes to enable\n \n error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n-  --> $DIR/min_const_fn_unsafe.rs:50:77\n+  --> $DIR/min_const_fn_unsafe_bad.rs:1:77\n    |\n LL | const fn bad_const_fn_deref_raw(x: *mut usize) -> &'static usize { unsafe { &*x } }\n    |                                                                             ^^^ dereference of raw pointer", "previous_filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe.stderr"}, {"sha": "02c7970deca641d5b512c4f9e11aab7dac58e638", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_ok.rs", "status": "renamed", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_ok.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,6 +1,4 @@\n-//------------------------------------------------------------------------------\n-// OK\n-//------------------------------------------------------------------------------\n+// check-pass\n \n const unsafe fn ret_i32_no_unsafe() -> i32 { 42 }\n const unsafe fn ret_null_ptr_no_unsafe<T>() -> *const T { std::ptr::null() }\n@@ -43,23 +41,4 @@ const unsafe fn call_unsafe_generic_cell_const_unsafe_fn_immediate()\n     ret_null_mut_ptr_no_unsafe::<Vec<std::cell::Cell<u32>>>()\n }\n \n-//------------------------------------------------------------------------------\n-// NOT OK\n-//------------------------------------------------------------------------------\n-\n-const fn bad_const_fn_deref_raw(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n-//~^ dereferencing raw pointers in constant functions\n-\n-const unsafe fn bad_const_unsafe_deref_raw(x: *mut usize) -> usize { *x }\n-//~^ dereferencing raw pointers in constant functions\n-\n-const unsafe fn bad_const_unsafe_deref_raw_ref(x: *mut usize) -> &'static usize { &*x }\n-//~^ dereferencing raw pointers in constant functions\n-\n fn main() {}\n-\n-const unsafe fn no_union() {\n-    union Foo { x: (), y: () }\n-    Foo { x: () }.y\n-    //~^ unions in const fn\n-}", "previous_filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe.rs"}, {"sha": "79d09d1817601ea601ae6a484cc6827e4d000630", "filename": "src/test/ui/drop/dynamic-drop-async.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -7,10 +7,7 @@\n // edition:2018\n // ignore-wasm32-bare compiled with panic=abort by default\n \n-#![allow(unused_assignments)]\n-#![allow(unused_variables)]\n #![feature(slice_patterns)]\n-#![feature(async_await)]\n \n use std::{\n     cell::{Cell, RefCell},"}, {"sha": "1f8657373efecb36fc7933a8b70213b597e2be28", "filename": "src/test/ui/error-codes/E0267.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ferror-codes%2FE0267.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ferror-codes%2FE0267.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0267.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -2,7 +2,9 @@ error[E0267]: `break` inside of a closure\n   --> $DIR/E0267.rs:2:18\n    |\n LL |     let w = || { break; };\n-   |                  ^^^^^ cannot break inside of a closure\n+   |             --   ^^^^^ cannot `break` inside of a closure\n+   |             |\n+   |             enclosing closure\n \n error: aborting due to previous error\n "}, {"sha": "c926f9e4874944722b4a7a82a67c1206ef29ff01", "filename": "src/test/ui/error-codes/E0268.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ferror-codes%2FE0268.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ferror-codes%2FE0268.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0268.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,8 +1,8 @@\n-error[E0268]: `break` outside of loop\n+error[E0268]: `break` outside of a loop\n   --> $DIR/E0268.rs:2:5\n    |\n LL |     break;\n-   |     ^^^^^ cannot break outside of a loop\n+   |     ^^^^^ cannot `break` outside of a loop\n \n error: aborting due to previous error\n "}, {"sha": "15aa3a6af4ca9c2bf3fe48e0c9c437a4982d6486", "filename": "src/test/ui/feature-gate-optimize_attribute.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,17 +1,17 @@\n #![crate_type=\"rlib\"]\n-#![optimize(speed)] //~ ERROR `#[optimize]` attribute is an unstable feature\n+#![optimize(speed)] //~ ERROR the `#[optimize]` attribute is an experimental feature\n \n-#[optimize(size)] //~ ERROR `#[optimize]` attribute is an unstable feature\n+#[optimize(size)] //~ ERROR the `#[optimize]` attribute is an experimental feature\n mod module {\n \n-#[optimize(size)] //~ ERROR `#[optimize]` attribute is an unstable feature\n+#[optimize(size)] //~ ERROR the `#[optimize]` attribute is an experimental feature\n fn size() {}\n \n-#[optimize(speed)] //~ ERROR `#[optimize]` attribute is an unstable feature\n+#[optimize(speed)] //~ ERROR the `#[optimize]` attribute is an experimental feature\n fn speed() {}\n \n #[optimize(banana)]\n-//~^ ERROR `#[optimize]` attribute is an unstable feature\n+//~^ ERROR the `#[optimize]` attribute is an experimental feature\n //~| ERROR E0722\n fn not_known() {}\n "}, {"sha": "3e3ad71c344eec4ed52bc131cd0c532f71527f51", "filename": "src/test/ui/feature-gate-optimize_attribute.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: `#[optimize]` attribute is an unstable feature\n+error[E0658]: the `#[optimize]` attribute is an experimental feature\n   --> $DIR/feature-gate-optimize_attribute.rs:7:1\n    |\n LL | #[optimize(size)]\n@@ -7,7 +7,7 @@ LL | #[optimize(size)]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54882\n    = help: add `#![feature(optimize_attribute)]` to the crate attributes to enable\n \n-error[E0658]: `#[optimize]` attribute is an unstable feature\n+error[E0658]: the `#[optimize]` attribute is an experimental feature\n   --> $DIR/feature-gate-optimize_attribute.rs:10:1\n    |\n LL | #[optimize(speed)]\n@@ -16,7 +16,7 @@ LL | #[optimize(speed)]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54882\n    = help: add `#![feature(optimize_attribute)]` to the crate attributes to enable\n \n-error[E0658]: `#[optimize]` attribute is an unstable feature\n+error[E0658]: the `#[optimize]` attribute is an experimental feature\n   --> $DIR/feature-gate-optimize_attribute.rs:13:1\n    |\n LL | #[optimize(banana)]\n@@ -25,7 +25,7 @@ LL | #[optimize(banana)]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54882\n    = help: add `#![feature(optimize_attribute)]` to the crate attributes to enable\n \n-error[E0658]: `#[optimize]` attribute is an unstable feature\n+error[E0658]: the `#[optimize]` attribute is an experimental feature\n   --> $DIR/feature-gate-optimize_attribute.rs:4:1\n    |\n LL | #[optimize(size)]\n@@ -34,7 +34,7 @@ LL | #[optimize(size)]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54882\n    = help: add `#![feature(optimize_attribute)]` to the crate attributes to enable\n \n-error[E0658]: `#[optimize]` attribute is an unstable feature\n+error[E0658]: the `#[optimize]` attribute is an experimental feature\n   --> $DIR/feature-gate-optimize_attribute.rs:2:1\n    |\n LL | #![optimize(speed)]"}, {"sha": "ad890961830806ebc916763f5bccbd788d7617d4", "filename": "src/test/ui/feature-gates/feature-gate-alloc-error-handler.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -5,7 +5,7 @@\n \n use core::alloc::Layout;\n \n-#[alloc_error_handler] //~ ERROR `#[alloc_error_handler]` is an unstable feature\n+#[alloc_error_handler] //~ ERROR the `#[alloc_error_handler]` attribute is an experimental feature\n fn oom(info: Layout) -> ! {\n     loop {}\n }"}, {"sha": "79e44bf0d8ec134af2617abebc84724a348f0f0a", "filename": "src/test/ui/feature-gates/feature-gate-alloc-error-handler.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: `#[alloc_error_handler]` is an unstable feature\n+error[E0658]: the `#[alloc_error_handler]` attribute is an experimental feature\n   --> $DIR/feature-gate-alloc-error-handler.rs:8:1\n    |\n LL | #[alloc_error_handler]"}, {"sha": "287d4ccf18010a6e803c18fc14bc6935524e90b4", "filename": "src/test/ui/feature-gates/feature-gate-allow_fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,6 +1,6 @@\n // check that #[allow_fail] is feature-gated\n \n-#[allow_fail] //~ ERROR allow_fail attribute is currently unstable\n+#[allow_fail] //~ ERROR the `#[allow_fail]` attribute is an experimental feature\n fn ok_to_fail() {\n     assert!(false);\n }"}, {"sha": "0f60a2de3a4e5bca82bed75e7f71b4417e0e7cdb", "filename": "src/test/ui/feature-gates/feature-gate-allow_fail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: allow_fail attribute is currently unstable\n+error[E0658]: the `#[allow_fail]` attribute is an experimental feature\n   --> $DIR/feature-gate-allow_fail.rs:3:1\n    |\n LL | #[allow_fail]"}, {"sha": "801aeb82aa266dfed97da4d9d23b22532988b8cf", "filename": "src/test/ui/feature-gates/feature-gate-async-await-2015-edition.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/926f36400f1667edec92959d8b640dea5084674c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f36400f1667edec92959d8b640dea5084674c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.rs?ref=926f36400f1667edec92959d8b640dea5084674c", "patch": "@@ -1,9 +0,0 @@\n-// edition:2015\n-\n-async fn foo() {} //~ ERROR `async fn` is not permitted in the 2015 edition\n-                  //~^ ERROR async fn is unstable\n-\n-fn main() {\n-    let _ = async {}; //~ ERROR cannot find struct, variant or union type `async`\n-    let _ = async || { true }; //~ ERROR cannot find value `async` in this scope\n-}"}, {"sha": "0157ed5534423199adfe93650e20dfe4c82661fe", "filename": "src/test/ui/feature-gates/feature-gate-async-await-2015-edition.stderr", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/926f36400f1667edec92959d8b640dea5084674c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/926f36400f1667edec92959d8b640dea5084674c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.stderr?ref=926f36400f1667edec92959d8b640dea5084674c", "patch": "@@ -1,31 +0,0 @@\n-error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/feature-gate-async-await-2015-edition.rs:3:1\n-   |\n-LL | async fn foo() {}\n-   | ^^^^^\n-\n-error[E0422]: cannot find struct, variant or union type `async` in this scope\n-  --> $DIR/feature-gate-async-await-2015-edition.rs:7:13\n-   |\n-LL |     let _ = async {};\n-   |             ^^^^^ not found in this scope\n-\n-error[E0425]: cannot find value `async` in this scope\n-  --> $DIR/feature-gate-async-await-2015-edition.rs:8:13\n-   |\n-LL |     let _ = async || { true };\n-   |             ^^^^^ not found in this scope\n-\n-error[E0658]: async fn is unstable\n-  --> $DIR/feature-gate-async-await-2015-edition.rs:3:1\n-   |\n-LL | async fn foo() {}\n-   | ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/50547\n-   = help: add `#![feature(async_await)]` to the crate attributes to enable\n-\n-error: aborting due to 4 previous errors\n-\n-Some errors have detailed explanations: E0422, E0425, E0658, E0670.\n-For more information about an error, try `rustc --explain E0422`."}, {"sha": "78391c0e104cc3e26a441fb48491320524f2c2d3", "filename": "src/test/ui/feature-gates/feature-gate-async-await.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/926f36400f1667edec92959d8b640dea5084674c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f36400f1667edec92959d8b640dea5084674c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.rs?ref=926f36400f1667edec92959d8b640dea5084674c", "patch": "@@ -1,18 +0,0 @@\n-// edition:2018\n-\n-struct S;\n-\n-impl S {\n-    async fn foo() {} //~ ERROR async fn is unstable\n-}\n-\n-trait T {\n-    async fn foo(); //~ ERROR trait fns cannot be declared `async`\n-    //~^ ERROR async fn is unstable\n-}\n-\n-async fn foo() {} //~ ERROR async fn is unstable\n-\n-fn main() {\n-    let _ = async {}; //~ ERROR async blocks are unstable\n-}"}, {"sha": "9f4a90157a49548006fa2342bdb912c7d6dd7490", "filename": "src/test/ui/feature-gates/feature-gate-async-await.stderr", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/926f36400f1667edec92959d8b640dea5084674c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/926f36400f1667edec92959d8b640dea5084674c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.stderr?ref=926f36400f1667edec92959d8b640dea5084674c", "patch": "@@ -1,45 +0,0 @@\n-error[E0706]: trait fns cannot be declared `async`\n-  --> $DIR/feature-gate-async-await.rs:10:5\n-   |\n-LL |     async fn foo();\n-   |     ^^^^^^^^^^^^^^^\n-\n-error[E0658]: async fn is unstable\n-  --> $DIR/feature-gate-async-await.rs:6:5\n-   |\n-LL |     async fn foo() {}\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/50547\n-   = help: add `#![feature(async_await)]` to the crate attributes to enable\n-\n-error[E0658]: async fn is unstable\n-  --> $DIR/feature-gate-async-await.rs:10:5\n-   |\n-LL |     async fn foo();\n-   |     ^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/50547\n-   = help: add `#![feature(async_await)]` to the crate attributes to enable\n-\n-error[E0658]: async fn is unstable\n-  --> $DIR/feature-gate-async-await.rs:14:1\n-   |\n-LL | async fn foo() {}\n-   | ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/50547\n-   = help: add `#![feature(async_await)]` to the crate attributes to enable\n-\n-error[E0658]: async blocks are unstable\n-  --> $DIR/feature-gate-async-await.rs:17:13\n-   |\n-LL |     let _ = async {};\n-   |             ^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/50547\n-   = help: add `#![feature(async_await)]` to the crate attributes to enable\n-\n-error: aborting due to 5 previous errors\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "5050c4792b06499ac63321f64ed035922e99ad74", "filename": "src/test/ui/feature-gates/feature-gate-marker_trait_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,7 +1,7 @@\n use std::fmt::{Debug, Display};\n \n #[marker] trait ExplicitMarker {}\n-//~^ ERROR marker traits is an experimental feature\n+//~^ ERROR the `#[marker]` attribute is an experimental feature\n \n impl<T: Display> ExplicitMarker for T {}\n impl<T: Debug> ExplicitMarker for T {}"}, {"sha": "304c081c5aace38380df52741ae8d9ae77815de6", "filename": "src/test/ui/feature-gates/feature-gate-marker_trait_attr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: marker traits is an experimental feature\n+error[E0658]: the `#[marker]` attribute is an experimental feature\n   --> $DIR/feature-gate-marker_trait_attr.rs:3:1\n    |\n LL | #[marker] trait ExplicitMarker {}"}, {"sha": "706efd786721119b1c06149fa49d0be5c23af180", "filename": "src/test/ui/feature-gates/feature-gate-no_core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,5 +1,5 @@\n #![crate_type = \"rlib\"]\n \n-#![no_core] //~ ERROR no_core is experimental\n+#![no_core] //~ ERROR the `#[no_core]` attribute is an experimental feature\n \n pub struct S {}"}, {"sha": "a80b3cbba25b1dd27ea0742a36cf47fecd7d1515", "filename": "src/test/ui/feature-gates/feature-gate-no_core.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: no_core is experimental\n+error[E0658]: the `#[no_core]` attribute is an experimental feature\n   --> $DIR/feature-gate-no_core.rs:3:1\n    |\n LL | #![no_core]"}, {"sha": "950f170f4fd4168bb0cfdd6ba52e25623c21b153", "filename": "src/test/ui/feature-gates/feature-gate-non_exhaustive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,6 +1,6 @@\n //#![feature(non_exhaustive)]\n \n-#[non_exhaustive] //~ERROR non exhaustive is an experimental feature\n+#[non_exhaustive] //~ERROR the `#[non_exhaustive]` attribute is an experimental feature\n pub enum NonExhaustiveEnum {\n     Unit,\n     Tuple(u32),"}, {"sha": "482332b8d706c457e731ae7a7c831dc8ad0977d9", "filename": "src/test/ui/feature-gates/feature-gate-non_exhaustive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: non exhaustive is an experimental feature\n+error[E0658]: the `#[non_exhaustive]` attribute is an experimental feature\n   --> $DIR/feature-gate-non_exhaustive.rs:3:1\n    |\n LL | #[non_exhaustive]"}, {"sha": "4044fd2b895e49af2199828e9e4d46a7d25ce2ef", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -16,7 +16,7 @@ fn f() {}\n fn g() {}\n \n #[rustc_dummy]\n-//~^ ERROR used by the test suite\n+//~^ ERROR the `#[rustc_dummy]` attribute is just used for rustc unit tests\n #[rustc_unknown]\n //~^ ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n //~| ERROR cannot find attribute macro `rustc_unknown` in this scope"}, {"sha": "c1063027fa4445dcf8f3957c6da87f589c90bb93", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -43,7 +43,7 @@ error: cannot find attribute macro `rustc_unknown` in this scope\n LL | #[rustc_unknown]\n    |   ^^^^^^^^^^^^^\n \n-error[E0658]: used by the test suite\n+error[E0658]: the `#[rustc_dummy]` attribute is just used for rustc unit tests and will never be stable\n   --> $DIR/feature-gate-rustc-attrs.rs:18:1\n    |\n LL | #[rustc_dummy]"}, {"sha": "6d8ac7e8f2911f3e88ce41d64292cc82ac7a4869", "filename": "src/test/ui/feature-gates/feature-gate-unwind-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -8,7 +8,7 @@ extern {\n     fn extern_fn();\n // CHECK-NOT: Function Attrs: nounwind\n // CHECK: declare void @unwinding_extern_fn\n-    #[unwind(allowed)] //~ ERROR `#[unwind]` is experimental\n+    #[unwind(allowed)] //~ ERROR the `#[unwind]` attribute is an experimental feature\n     fn unwinding_extern_fn();\n }\n "}, {"sha": "10cc494213507fc27e9b487994264663fe361e6f", "filename": "src/test/ui/feature-gates/feature-gate-unwind-attributes.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.stderr?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: `#[unwind]` is experimental\n+error[E0658]: the `#[unwind]` attribute is an experimental feature\n   --> $DIR/feature-gate-unwind-attributes.rs:11:5\n    |\n LL |     #[unwind(allowed)]"}, {"sha": "e3d19029348a5619b08064253f272d18c040178c", "filename": "src/test/ui/generator/issue-61442-stmt-expr-with-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fgenerator%2Fissue-61442-stmt-expr-with-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fgenerator%2Fissue-61442-stmt-expr-with-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-61442-stmt-expr-with-drop.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4,7 +4,7 @@\n // check-pass\n // edition:2018\n \n-#![feature(async_await, generators, generator_trait)]\n+#![feature(generators, generator_trait)]\n \n use std::ops::Generator;\n "}, {"sha": "672e16b780d03729278f7e13a288f2c5f5e064fc", "filename": "src/test/ui/generator/issue-62506-two_awaits.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fgenerator%2Fissue-62506-two_awaits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fgenerator%2Fissue-62506-two_awaits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-62506-two_awaits.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -4,7 +4,6 @@\n // check-pass\n // edition:2018\n \n-#![feature(async_await)]\n use std::future::Future;\n \n pub trait T {"}, {"sha": "220e5526745c3a835a965829a41505cc2d2bb6ec", "filename": "src/test/ui/hygiene/eager-from-opaque-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fhygiene%2Feager-from-opaque-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fhygiene%2Feager-from-opaque-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Feager-from-opaque-2.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,22 @@\n+// Regression test for the issue #63460.\n+\n+// check-pass\n+\n+#[macro_export]\n+macro_rules! separator {\n+    () => { \"/\" };\n+}\n+\n+#[macro_export]\n+macro_rules! concat_separator {\n+    ( $e:literal, $($other:literal),+ ) => {\n+        concat!($e, $crate::separator!(), $crate::concat_separator!($($other),+))\n+    };\n+    ( $e:literal ) => {\n+        $e\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{}\", concat_separator!(2, 3, 4))\n+}"}, {"sha": "6f3215dd697f321cf279482cba388e45741c4936", "filename": "src/test/ui/hygiene/eager-from-opaque.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fhygiene%2Feager-from-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37721461d47d3840adc6d931b848a9db8e66ceaa/src%2Ftest%2Fui%2Fhygiene%2Feager-from-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Feager-from-opaque.rs?ref=37721461d47d3840adc6d931b848a9db8e66ceaa", "patch": "@@ -0,0 +1,20 @@\n+// Opaque macro can eagerly expand its input without breaking its resolution.\n+// Regression test for issue #63685.\n+\n+// check-pass\n+\n+macro_rules! foo {\n+    () => {\n+        \"foo\"\n+    };\n+}\n+\n+macro_rules! bar {\n+    () => {\n+        foo!()\n+    };\n+}\n+\n+fn main() {\n+    format_args!(bar!());\n+}"}]}