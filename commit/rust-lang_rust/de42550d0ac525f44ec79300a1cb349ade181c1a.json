{"sha": "de42550d0ac525f44ec79300a1cb349ade181c1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNDI1NTBkMGFjNTI1ZjQ0ZWM3OTMwMGExY2IzNDlhZGUxODFjMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-23T22:55:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-23T22:55:19Z"}, "message": "Auto merge of #83302 - camsteffen:write-piece-unchecked, r=dtolnay\n\nGet piece unchecked in `write`\n\nWe already use specialized `zip`, but it seems like we can do a little better by not checking `pieces` length at all.\n\n`Arguments` constructors are now unsafe. So the `format_args!` expansion now includes an `unsafe` block.\n\n<details>\n<summary>Local Bench Diff</summary>\n\n```text\n name                        before ns/iter  after ns/iter  diff ns/iter   diff %  speedup\n fmt::write_str_macro1       22,967          19,718               -3,249  -14.15%   x 1.16\n fmt::write_str_macro2       35,527          32,654               -2,873   -8.09%   x 1.09\n fmt::write_str_macro_debug  571,953         575,973               4,020    0.70%   x 0.99\n fmt::write_str_ref          9,579           9,459                  -120   -1.25%   x 1.01\n fmt::write_str_value        9,573           9,572                    -1   -0.01%   x 1.00\n fmt::write_u128_max         176             173                      -3   -1.70%   x 1.02\n fmt::write_u128_min         138             134                      -4   -2.90%   x 1.03\n fmt::write_u64_max          139             136                      -3   -2.16%   x 1.02\n fmt::write_u64_min          129             135                       6    4.65%   x 0.96\n fmt::write_vec_macro1       24,401          22,273               -2,128   -8.72%   x 1.10\n fmt::write_vec_macro2       37,096          35,602               -1,494   -4.03%   x 1.04\n fmt::write_vec_macro_debug  588,291         589,575               1,284    0.22%   x 1.00\n fmt::write_vec_ref          9,568           9,732                   164    1.71%   x 0.98\n fmt::write_vec_value        9,516           9,625                   109    1.15%   x 0.99\n```\n</details>", "tree": {"sha": "c72423991b9b5acba50cda1e82e8f88fa6d141d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c72423991b9b5acba50cda1e82e8f88fa6d141d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de42550d0ac525f44ec79300a1cb349ade181c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de42550d0ac525f44ec79300a1cb349ade181c1a", "html_url": "https://github.com/rust-lang/rust/commit/de42550d0ac525f44ec79300a1cb349ade181c1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de42550d0ac525f44ec79300a1cb349ade181c1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a49e38e672c60da788360e088f00ad12353e3913", "url": "https://api.github.com/repos/rust-lang/rust/commits/a49e38e672c60da788360e088f00ad12353e3913", "html_url": "https://github.com/rust-lang/rust/commit/a49e38e672c60da788360e088f00ad12353e3913"}, {"sha": "b1e07b82dcef6d31556a92cb75d825bce6032519", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1e07b82dcef6d31556a92cb75d825bce6032519", "html_url": "https://github.com/rust-lang/rust/commit/b1e07b82dcef6d31556a92cb75d825bce6032519"}], "stats": {"total": 230, "additions": 165, "deletions": 65}, "files": [{"sha": "1dbf7728421637343a84b9a9513ccf0cca2b4485", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -3,8 +3,8 @@ use Position::*;\n \n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n-use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n+use rustc_ast::{token, BlockCheckMode, UnsafeSource};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, Applicability, DiagnosticBuilder};\n use rustc_expand::base::{self, *};\n@@ -838,12 +838,15 @@ impl<'a, 'b> Context<'a, 'b> {\n         //\n         // But the nested match expression is proved to perform not as well\n         // as series of let's; the first approach does.\n-        let pat = self.ecx.pat_tuple(self.macsp, pats);\n-        let arm = self.ecx.arm(self.macsp, pat, args_array);\n-        let head = self.ecx.expr(self.macsp, ast::ExprKind::Tup(heads));\n-        let result = self.ecx.expr_match(self.macsp, head, vec![arm]);\n+        let args_match = {\n+            let pat = self.ecx.pat_tuple(self.macsp, pats);\n+            let arm = self.ecx.arm(self.macsp, pat, args_array);\n+            let head = self.ecx.expr(self.macsp, ast::ExprKind::Tup(heads));\n+            self.ecx.expr_match(self.macsp, head, vec![arm])\n+        };\n \n-        let args_slice = self.ecx.expr_addr_of(self.macsp, result);\n+        let ident = Ident::from_str_and_span(\"args\", self.macsp);\n+        let args_slice = self.ecx.expr_ident(self.macsp, ident);\n \n         // Now create the fmt::Arguments struct with all our locals we created.\n         let (fn_name, fn_args) = if self.all_pieces_simple {\n@@ -857,7 +860,20 @@ impl<'a, 'b> Context<'a, 'b> {\n         };\n \n         let path = self.ecx.std_path(&[sym::fmt, sym::Arguments, Symbol::intern(fn_name)]);\n-        self.ecx.expr_call_global(self.macsp, path, fn_args)\n+        let arguments = self.ecx.expr_call_global(self.macsp, path, fn_args);\n+        let body = self.ecx.expr_block(P(ast::Block {\n+            stmts: vec![self.ecx.stmt_expr(arguments)],\n+            id: ast::DUMMY_NODE_ID,\n+            rules: BlockCheckMode::Unsafe(UnsafeSource::CompilerGenerated),\n+            span: self.macsp,\n+            tokens: None,\n+        }));\n+\n+        let ident = Ident::from_str_and_span(\"args\", self.macsp);\n+        let binding_mode = ast::BindingMode::ByRef(ast::Mutability::Not);\n+        let pat = self.ecx.pat_ident_binding_mode(self.macsp, ident, binding_mode);\n+        let arm = self.ecx.arm(self.macsp, pat, body);\n+        self.ecx.expr_match(self.macsp, args_match, vec![arm])\n     }\n \n     fn format_arg("}, {"sha": "1d75ac3d254bd641ff9d4783b3de73219920de38", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -4,7 +4,6 @@\n \n use crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\n use crate::char::EscapeDebugExtArgs;\n-use crate::iter;\n use crate::marker::PhantomData;\n use crate::mem;\n use crate::num::fmt as numfmt;\n@@ -334,11 +333,29 @@ enum FlagV1 {\n impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n+    #[cfg(not(bootstrap))]\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n+    pub const unsafe fn new_v1(\n+        pieces: &'a [&'static str],\n+        args: &'a [ArgumentV1<'a>],\n+    ) -> Arguments<'a> {\n+        if pieces.len() < args.len() || pieces.len() > args.len() + 1 {\n+            panic!(\"invalid args\");\n+        }\n+        Arguments { pieces, fmt: None, args }\n+    }\n+    #[cfg(bootstrap)]\n     #[doc(hidden)]\n     #[inline]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n     pub const fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+        if pieces.len() < args.len() || pieces.len() > args.len() + 1 {\n+            panic!(\"invalid args\");\n+        }\n         Arguments { pieces, fmt: None, args }\n     }\n \n@@ -348,6 +365,19 @@ impl<'a> Arguments<'a> {\n     /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n     /// created with `argumentusize`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n+    #[cfg(not(bootstrap))]\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n+    pub const unsafe fn new_v1_formatted(\n+        pieces: &'a [&'static str],\n+        args: &'a [ArgumentV1<'a>],\n+        fmt: &'a [rt::v1::Argument],\n+    ) -> Arguments<'a> {\n+        Arguments { pieces, fmt: Some(fmt), args }\n+    }\n+    #[cfg(bootstrap)]\n     #[doc(hidden)]\n     #[inline]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n@@ -1110,7 +1140,10 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n     match args.fmt {\n         None => {\n             // We can use default formatting parameters for all arguments.\n-            for (arg, piece) in iter::zip(args.args, args.pieces) {\n+            for (i, arg) in args.args.iter().enumerate() {\n+                // SAFETY: args.args and args.pieces come from the same Arguments,\n+                // which guarantees the indexes are always within bounds.\n+                let piece = unsafe { args.pieces.get_unchecked(i) };\n                 if !piece.is_empty() {\n                     formatter.buf.write_str(*piece)?;\n                 }\n@@ -1121,7 +1154,10 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n         Some(fmt) => {\n             // Every spec has a corresponding argument that is preceded by\n             // a string piece.\n-            for (arg, piece) in iter::zip(fmt, args.pieces) {\n+            for (i, arg) in fmt.iter().enumerate() {\n+                // SAFETY: fmt and args.pieces come from the same Arguments,\n+                // which guarantees the indexes are always within bounds.\n+                let piece = unsafe { args.pieces.get_unchecked(i) };\n                 if !piece.is_empty() {\n                     formatter.buf.write_str(*piece)?;\n                 }"}, {"sha": "a4e57fd6a6db46232f1350ca1dbef706026c67dc", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -111,6 +111,7 @@\n //\n // Language features:\n #![feature(abi_unadjusted)]\n+#![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n #![feature(asm)]\n #![feature(associated_type_bounds)]"}, {"sha": "a3a074ac131af8d1ca95ce8f290bfa25743b9332", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -828,6 +828,7 @@ pub(crate) mod builtin {\n     /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unsafe]\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]"}, {"sha": "85728551f53ac4054823e54b6f9d7491b5771627", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -47,7 +47,15 @@ pub fn panic(expr: &'static str) -> ! {\n     // truncation and padding (even though none is used here). Using\n     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n     // output binary, saving up to a few kilobytes.\n-    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n+    panic_fmt(\n+        #[cfg(bootstrap)]\n+        fmt::Arguments::new_v1(&[expr], &[]),\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: Arguments::new_v1 is safe with exactly one str and zero args\n+        unsafe {\n+            fmt::Arguments::new_v1(&[expr], &[])\n+        },\n+    );\n }\n \n #[inline]"}, {"sha": "144a746062daaa74f29b328870a06a0c0cd56290", "filename": "src/test/debuginfo/rc_arc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fdebuginfo%2Frc_arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fdebuginfo%2Frc_arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frc_arc.rs?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -75,5 +75,7 @@ fn main() {\n     let a1 = Arc::clone(&a);\n     let w2 = Arc::downgrade(&a);\n \n-    print!(\"\"); // #break\n+    zzz(); // #break\n }\n+\n+fn zzz() { () }"}, {"sha": "4eccba06b134ffbaf011ac1d52ff8b89cf3fc946", "filename": "src/test/pretty/dollar-crate.pp", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdollar-crate.pp?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -10,9 +10,11 @@\n \n fn main() {\n     {\n-        ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"],\n-                                                         &match () {\n-                                                              () => [],\n-                                                          }));\n+        ::std::io::_print(match match () { () => [], } {\n+                              ref args => unsafe {\n+                                  ::core::fmt::Arguments::new_v1(&[\"rust\\n\"],\n+                                                                 args)\n+                              }\n+                          });\n     };\n }"}, {"sha": "a21ea520121e38f6c2c845328086e5840bfe79be", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -32,29 +32,39 @@\n                   ({\n                        let res =\n                            ((::alloc::fmt::format as\n-                                for<'r> fn(Arguments<'r>) -> String {format})(((::core::fmt::Arguments::new_v1\n-                                                                                   as\n-                                                                                   fn(&[&'static str], &[ArgumentV1]) -> Arguments {Arguments::new_v1})((&([(\"test\"\n-                                                                                                                                                                as\n-                                                                                                                                                                &str)]\n-                                                                                                                                                              as\n-                                                                                                                                                              [&str; 1])\n-                                                                                                                                                            as\n-                                                                                                                                                            &[&str; 1]),\n-                                                                                                                                                        (&(match (()\n-                                                                                                                                                                     as\n-                                                                                                                                                                     ())\n-                                                                                                                                                               {\n-                                                                                                                                                               ()\n-                                                                                                                                                               =>\n-                                                                                                                                                               ([]\n-                                                                                                                                                                   as\n-                                                                                                                                                                   [ArgumentV1; 0]),\n-                                                                                                                                                           }\n-                                                                                                                                                              as\n-                                                                                                                                                              [ArgumentV1; 0])\n-                                                                                                                                                            as\n-                                                                                                                                                            &[ArgumentV1; 0]))\n+                                for<'r> fn(Arguments<'r>) -> String {format})((match (match (()\n+                                                                                                as\n+                                                                                                ())\n+                                                                                          {\n+                                                                                          ()\n+                                                                                          =>\n+                                                                                          ([]\n+                                                                                              as\n+                                                                                              [ArgumentV1; 0]),\n+                                                                                      }\n+                                                                                         as\n+                                                                                         [ArgumentV1; 0])\n+                                                                                   {\n+                                                                                   ref args\n+                                                                                   =>\n+                                                                                   unsafe\n+                                                                                   {\n+                                                                                       ((::core::fmt::Arguments::new_v1\n+                                                                                            as\n+                                                                                            unsafe fn(&[&'static str], &[ArgumentV1]) -> Arguments {Arguments::new_v1})((&([(\"test\"\n+                                                                                                                                                                                as\n+                                                                                                                                                                                &str)]\n+                                                                                                                                                                              as\n+                                                                                                                                                                              [&str; 1])\n+                                                                                                                                                                            as\n+                                                                                                                                                                            &[&str; 1]),\n+                                                                                                                                                                        (args\n+                                                                                                                                                                            as\n+                                                                                                                                                                            &[ArgumentV1; 0]))\n+                                                                                           as\n+                                                                                           Arguments)\n+                                                                                   }\n+                                                                               }\n                                                                                   as\n                                                                                   Arguments))\n                                as String);"}, {"sha": "b35f3f54de9044671f3d7ffd2e429af5b421dde3", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.issue-84561.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -31,15 +31,15 @@\n    24|      1|    println!(\"{:?}\", Foo(1));\n    25|      1|\n    26|      1|    assert_ne!(Foo(0), Foo(5), \"{}\", if is_true { \"true message\" } else { \"false message\" });\n-                                             ^0                 ^0                      ^0\n+                                             ^0       ^0        ^0                      ^0\n    27|      1|    assert_ne!(\n    28|       |        Foo(0)\n    29|       |        ,\n    30|       |        Foo(5)\n    31|       |        ,\n    32|      0|        \"{}\"\n-   33|      0|        ,\n-   34|      0|        if\n+   33|       |        ,\n+   34|       |        if\n    35|      0|        is_true\n    36|       |        {\n    37|      0|            \"true message\""}, {"sha": "03ca515265cb0915684b0a4d40c7048046e37e38", "filename": "src/test/ui/attributes/key-value-expansion.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -17,12 +17,16 @@ LL | bug!();\n \n error: unexpected token: `{\n     let res =\n-        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[\"\"],\n-                                                            &match (&\"u8\",) {\n-                                                                 (arg0,) =>\n-                                                                 [::core::fmt::ArgumentV1::new(arg0,\n-                                                                                               ::core::fmt::Display::fmt)],\n-                                                             }));\n+        ::alloc::fmt::format(match match (&\"u8\",) {\n+                                       (arg0,) =>\n+                                       [::core::fmt::ArgumentV1::new(arg0,\n+                                                                     ::core::fmt::Display::fmt)],\n+                                   } {\n+                                 ref args => unsafe {\n+                                     ::core::fmt::Arguments::new_v1(&[\"\"],\n+                                                                    args)\n+                                 }\n+                             });\n     res\n }.as_str()`\n   --> $DIR/key-value-expansion.rs:48:23"}, {"sha": "62199e5a2ec0bdd8fbfdc07c67a158d9fefe15f2", "filename": "src/test/ui/unsafe/unsafe-around-compiler-generated-unsafe.mir.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fui%2Funsafe%2Funsafe-around-compiler-generated-unsafe.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fui%2Funsafe%2Funsafe-around-compiler-generated-unsafe.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-around-compiler-generated-unsafe.mir.stderr?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -10,5 +10,11 @@ note: the lint level is defined here\n LL | #![deny(unused_unsafe)]\n    |         ^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: unnecessary `unsafe` block\n+  --> $DIR/unsafe-around-compiler-generated-unsafe.rs:13:5\n+   |\n+LL |     unsafe { println!(\"foo\"); }\n+   |     ^^^^^^ unnecessary `unsafe` block\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "c1a327640398576ae42c8048cc04a6d06fd6ae89", "filename": "src/test/ui/unsafe/unsafe-around-compiler-generated-unsafe.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fui%2Funsafe%2Funsafe-around-compiler-generated-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fui%2Funsafe%2Funsafe-around-compiler-generated-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-around-compiler-generated-unsafe.rs?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -8,4 +8,7 @@ fn main() {\n     let _ = async {\n         unsafe { async {}.await; } //~ ERROR unnecessary `unsafe`\n     };\n+\n+    // `format_args!` expands with a compiler-generated unsafe block\n+    unsafe { println!(\"foo\"); } //~ ERROR unnecessary `unsafe`\n }"}, {"sha": "62199e5a2ec0bdd8fbfdc07c67a158d9fefe15f2", "filename": "src/test/ui/unsafe/unsafe-around-compiler-generated-unsafe.thir.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fui%2Funsafe%2Funsafe-around-compiler-generated-unsafe.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftest%2Fui%2Funsafe%2Funsafe-around-compiler-generated-unsafe.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-around-compiler-generated-unsafe.thir.stderr?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -10,5 +10,11 @@ note: the lint level is defined here\n LL | #![deny(unused_unsafe)]\n    |         ^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: unnecessary `unsafe` block\n+  --> $DIR/unsafe-around-compiler-generated-unsafe.rs:13:5\n+   |\n+LL |     unsafe { println!(\"foo\"); }\n+   |     ^^^^^^ unnecessary `unsafe` block\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "c06b894a73871e22b092b464ddb9c994d384cb17", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de42550d0ac525f44ec79300a1cb349ade181c1a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=de42550d0ac525f44ec79300a1cb349ade181c1a", "patch": "@@ -469,12 +469,28 @@ impl FormatArgsExpn<'tcx> {\n             if let ExpnKind::Macro(_, name) = expr.span.ctxt().outer_expn_data().kind;\n             let name = name.as_str();\n             if name.ends_with(\"format_args\") || name.ends_with(\"format_args_nl\");\n-            if let ExprKind::Call(_, args) = expr.kind;\n-            if let Some((strs_ref, args, fmt_expr)) = match args {\n+\n+            if let ExprKind::Match(inner_match, [arm], _) = expr.kind;\n+\n+            // `match match`, if you will\n+            if let ExprKind::Match(args, [inner_arm], _) = inner_match.kind;\n+            if let ExprKind::Tup(value_args) = args.kind;\n+            if let Some(value_args) = value_args\n+                .iter()\n+                .map(|e| match e.kind {\n+                    ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                })\n+                .collect();\n+            if let ExprKind::Array(args) = inner_arm.body.kind;\n+\n+            if let ExprKind::Block(Block { stmts: [], expr: Some(expr), .. }, _) = arm.body.kind;\n+            if let ExprKind::Call(_, call_args) = expr.kind;\n+            if let Some((strs_ref, fmt_expr)) = match call_args {\n                 // Arguments::new_v1\n-                [strs_ref, args] => Some((strs_ref, args, None)),\n+                [strs_ref, _] => Some((strs_ref, None)),\n                 // Arguments::new_v1_formatted\n-                [strs_ref, args, fmt_expr] => Some((strs_ref, args, Some(fmt_expr))),\n+                [strs_ref, _, fmt_expr] => Some((strs_ref, Some(fmt_expr))),\n                 _ => None,\n             };\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, strs_arr) = strs_ref.kind;\n@@ -490,17 +506,6 @@ impl FormatArgsExpn<'tcx> {\n                     None\n                 })\n                 .collect();\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, args) = args.kind;\n-            if let ExprKind::Match(args, [arm], _) = args.kind;\n-            if let ExprKind::Tup(value_args) = args.kind;\n-            if let Some(value_args) = value_args\n-                .iter()\n-                .map(|e| match e.kind {\n-                    ExprKind::AddrOf(_, _, e) => Some(e),\n-                    _ => None,\n-                })\n-                .collect();\n-            if let ExprKind::Array(args) = arm.body.kind;\n             then {\n                 Some(FormatArgsExpn {\n                     format_string_span: strs_ref.span,"}]}