{"sha": "85129e216948d0a7c83db7048ecf1cc997e09ab7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MTI5ZTIxNjk0OGQwYTdjODNkYjcwNDhlY2YxY2M5OTdlMDlhYjc=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-04-06T14:20:53Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-04-06T14:21:36Z"}, "message": "Remove use of block comments in src/libstd/cmp.rs", "tree": {"sha": "e443fae9d61d633dc6a73190e1c8aa846c5de38c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e443fae9d61d633dc6a73190e1c8aa846c5de38c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85129e216948d0a7c83db7048ecf1cc997e09ab7", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85129e216948d0a7c83db7048ecf1cc997e09ab7", "html_url": "https://github.com/rust-lang/rust/commit/85129e216948d0a7c83db7048ecf1cc997e09ab7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85129e216948d0a7c83db7048ecf1cc997e09ab7/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf83ff8959b2a385397e01e8974778e10799b464", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf83ff8959b2a385397e01e8974778e10799b464", "html_url": "https://github.com/rust-lang/rust/commit/cf83ff8959b2a385397e01e8974778e10799b464"}], "stats": {"total": 156, "additions": 72, "deletions": 84}, "files": [{"sha": "e39ab4144fd07a5d51051196fe0d9fce73b7f400", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 72, "deletions": 84, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/85129e216948d0a7c83db7048ecf1cc997e09ab7/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85129e216948d0a7c83db7048ecf1cc997e09ab7/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=85129e216948d0a7c83db7048ecf1cc997e09ab7", "patch": "@@ -8,50 +8,47 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Defines the `Ord` and `Eq` comparison traits.\n-\n-This module defines both `Ord` and `Eq` traits which are used by the compiler\n-to implement comparison operators.\n-Rust programs may implement `Ord` to overload the `<`, `<=`, `>`, and `>=` operators,\n-and may implement `Eq` to overload the `==` and `!=` operators.\n-\n-For example, to define a type with a customized definition for the Eq operators,\n-you could do the following:\n-\n-```rust\n-// Our type.\n-struct SketchyNum {\n-    num : int\n-}\n-\n-// Our implementation of `Eq` to support `==` and `!=`.\n-impl Eq for SketchyNum {\n-    // Our custom eq allows numbers which are near eachother to be equal! :D\n-    fn eq(&self, other: &SketchyNum) -> bool {\n-        (self.num - other.num).abs() < 5\n-    }\n-}\n-\n-// Now these binary operators will work when applied!\n-assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n-assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n-```\n-\n-*/\n-\n-/**\n-* Trait for values that can be compared for equality and inequality.\n-*\n-* This trait allows partial equality, where types can be unordered instead of strictly equal or\n-* unequal. For example, with the built-in floating-point types `a == b` and `a != b` will both\n-* evaluate to false if either `a` or `b` is NaN (cf. IEEE 754-2008 section 5.11).\n-*\n-* Eq only requires the `eq` method to be implemented; `ne` is its negation by default.\n-*\n-* Eventually, this will be implemented by default for types that implement `TotalEq`.\n-*/\n+//! Defines the `Ord` and `Eq` comparison traits.\n+//!\n+//! This module defines both `Ord` and `Eq` traits which are used by the\n+//! compiler to implement comparison operators. Rust programs may implement\n+//!`Ord` to overload the `<`, `<=`, `>`, and `>=` operators, and may implement\n+//! `Eq` to overload the `==` and `!=` operators.\n+//!\n+//! For example, to define a type with a customized definition for the Eq\n+//! operators, you could do the following:\n+//!\n+//! ```rust\n+//! // Our type.\n+//! struct SketchyNum {\n+//!     num : int\n+//! }\n+//!\n+//! // Our implementation of `Eq` to support `==` and `!=`.\n+//! impl Eq for SketchyNum {\n+//!     // Our custom eq allows numbers which are near eachother to be equal! :D\n+//!     fn eq(&self, other: &SketchyNum) -> bool {\n+//!         (self.num - other.num).abs() < 5\n+//!     }\n+//! }\n+//!\n+//! // Now these binary operators will work when applied!\n+//! assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n+//! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n+//! ```\n+\n+/// Trait for values that can be compared for equality and inequality.\n+///\n+/// This trait allows partial equality, where types can be unordered instead of\n+/// strictly equal or unequal. For example, with the built-in floating-point\n+/// types `a == b` and `a != b` will both evaluate to false if either `a` or\n+/// `b` is NaN (cf. IEEE 754-2008 section 5.11).\n+///\n+/// Eq only requires the `eq` method to be implemented; `ne` is its negation by\n+/// default.\n+///\n+/// Eventually, this will be implemented by default for types that implement\n+/// `TotalEq`.\n #[lang=\"eq\"]\n pub trait Eq {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n@@ -62,18 +59,15 @@ pub trait Eq {\n     fn ne(&self, other: &Self) -> bool { !self.eq(other) }\n }\n \n-/**\n- * Trait for equality comparisons which are [equivalence relations](\n- * https://en.wikipedia.org/wiki/Equivalence_relation).\n- *\n- * This means, that in addition to `a == b` and `a != b` being strict inverses,\n- * the equality must be (for all `a`, `b` and `c`):\n- *\n- * - reflexive: `a == a`;\n- * - symmetric: `a == b` implies `b == a`; and\n- * - transitive: `a == b` and `b == c` implies `a == c`.\n- */\n-\n+/// Trait for equality comparisons which are [equivalence relations](\n+/// https://en.wikipedia.org/wiki/Equivalence_relation).\n+///\n+/// This means, that in addition to `a == b` and `a != b` being strict\n+/// inverses, the equality must be (for all `a`, `b` and `c`):\n+///\n+/// - reflexive: `a == a`;\n+/// - symmetric: `a == b` implies `b == a`; and\n+/// - transitive: `a == b` and `b == c` implies `a == c`.\n pub trait TotalEq: Eq {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n@@ -122,17 +116,15 @@ pub enum Ordering {\n    Greater = 1\n }\n \n-/**\n- * Trait for types that form a [total order](\n- * https://en.wikipedia.org/wiki/Total_order).\n- *\n- * An order is a total order if it is (for all `a`, `b` and `c`):\n- *\n- * - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b`\n- *   is true; and\n- * - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n- *   both `==` and `>`.\n- */\n+/// Trait for types that form a [total order](\n+/// https://en.wikipedia.org/wiki/Total_order).\n+///\n+/// An order is a total order if it is (for all `a`, `b` and `c`):\n+///\n+/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is\n+///   true; and\n+/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n+///   both `==` and `>`.\n pub trait TotalOrd: TotalEq + Ord {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n@@ -189,13 +181,11 @@ totalord_impl!(uint)\n \n totalord_impl!(char)\n \n-/**\n- * Combine orderings, lexically.\n- *\n- * For example for a type `(int, int)`, two comparisons could be done.\n- * If the first ordering is different, the first ordering is all that must be returned.\n- * If the first ordering is equal, then second ordering is returned.\n-*/\n+/// Combine orderings, lexically.\n+///\n+/// For example for a type `(int, int)`, two comparisons could be done.\n+/// If the first ordering is different, the first ordering is all that must be returned.\n+/// If the first ordering is equal, then second ordering is returned.\n #[inline]\n pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n     match o1 {\n@@ -204,16 +194,14 @@ pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n     }\n }\n \n-/**\n-* Trait for values that can be compared for a sort-order.\n-*\n-* Ord only requires implementation of the `lt` method,\n-* with the others generated from default implementations.\n-*\n-* However it remains possible to implement the others separately,\n-* for compatibility with floating-point NaN semantics\n-* (cf. IEEE 754-2008 section 5.11).\n-*/\n+/// Trait for values that can be compared for a sort-order.\n+///\n+/// Ord only requires implementation of the `lt` method,\n+/// with the others generated from default implementations.\n+///\n+/// However it remains possible to implement the others separately,\n+/// for compatibility with floating-point NaN semantics\n+/// (cf. IEEE 754-2008 section 5.11).\n #[lang=\"ord\"]\n pub trait Ord: Eq {\n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator."}]}