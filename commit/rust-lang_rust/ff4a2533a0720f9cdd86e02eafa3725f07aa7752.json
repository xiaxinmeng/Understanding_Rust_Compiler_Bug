{"sha": "ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNGEyNTMzYTA3MjBmOWNkZDg2ZTAyZWFmYTM3MjVmMDdhYTc3NTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-15T11:39:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-15T11:39:23Z"}, "message": "Auto merge of #73369 - RalfJung:rollup-hl8g9zf, r=RalfJung\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #72707 (Use min_specialization in the remaining rustc crates)\n - #72740 (On recursive ADT, provide indirection structured suggestion)\n - #72879 (Miri: avoid tracking current location three times)\n - #72938 (Stabilize Option::zip)\n - #73086 (Rename \"cyclone\" to \"apple-a7\" per changes in upstream LLVM)\n - #73104 (Example about explicit mutex dropping)\n - #73139 (Add methods to go from a nul-terminated Vec<u8> to a CString)\n - #73296 (Remove vestigial CI job msvc-aux.)\n - #73304 (Revert heterogeneous SocketAddr PartialEq impls)\n - #73331 (extend network support for HermitCore)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3c45460d9f8f3c6f63bd2807bf0cc154e615db7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c45460d9f8f3c6f63bd2807bf0cc154e615db7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "html_url": "https://github.com/rust-lang/rust/commit/ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "html_url": "https://github.com/rust-lang/rust/commit/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d"}, {"sha": "54bd077cd6dc66456fdbaf7e455fb5259b4fc05e", "url": "https://api.github.com/repos/rust-lang/rust/commits/54bd077cd6dc66456fdbaf7e455fb5259b4fc05e", "html_url": "https://github.com/rust-lang/rust/commit/54bd077cd6dc66456fdbaf7e455fb5259b4fc05e"}], "stats": {"total": 1643, "additions": 1061, "deletions": 582}, "files": [{"sha": "bf3c22744f1650c1a8aa2ef06dee11e2be7a8652", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -428,11 +428,6 @@ jobs:\n               NO_DEBUG_ASSERTIONS: 1\n               NO_LLVM_ASSERTIONS: 1\n             os: windows-latest-xl\n-          - name: x86_64-msvc-aux\n-            env:\n-              RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc\"\n-            os: windows-latest-xl\n           - name: x86_64-msvc-cargo\n             env:\n               SCRIPT: python x.py test src/tools/cargotest src/tools/cargo"}, {"sha": "009767934d447c0853ceacf5d089f0ac3e7ef6a9", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1434,9 +1434,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.13\"\n+version = \"0.1.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"91780f809e750b0a89f5544be56617ff6b1227ee485bcb06ebe10cdf89bd3b71\"\n+checksum = \"b9586eedd4ce6b3c498bc3b4dd92fc9f11166aa908a914071953768066c67909\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\","}, {"sha": "ea5300bdfc04cbf26add156fe37a0793aef19198", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -373,7 +373,6 @@ impl<'a> Builder<'a> {\n                 test::UiFullDeps,\n                 test::Rustdoc,\n                 test::Pretty,\n-                test::RunPassValgrindPretty,\n                 test::Crate,\n                 test::CrateLibrustc,\n                 test::CrateRustdoc,"}, {"sha": "12a1734e21c7e165eea70f8ff3742cac2fe55889", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -6,12 +6,6 @@ Q := @\n BOOTSTRAP_ARGS :=\n endif\n \n-ifdef EXCLUDE_CARGO\n-AUX_ARGS :=\n-else\n-AUX_ARGS := src/tools/cargo src/tools/cargotest\n-endif\n-\n BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py\n \n all:\n@@ -48,8 +42,8 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/test/run-pass-valgrind/pretty \\\n-\t\t$(AUX_ARGS) \\\n+\t\tsrc/tools/cargo \\\n+\t\tsrc/tools/cargotest \\\n \t\t$(BOOTSTRAP_ARGS)\n check-bootstrap:\n \t$(Q)$(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap_test.py"}, {"sha": "b8c57515658383e1bcb16c60d8f52fb1e5d4855b", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -930,13 +930,6 @@ host_test!(UiFullDeps { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-ful\n host_test!(Rustdoc { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" });\n \n host_test!(Pretty { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" });\n-test!(RunPassValgrindPretty {\n-    path: \"src/test/run-pass-valgrind/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-pass-valgrind\",\n-    default: false,\n-    host: true\n-});\n \n default_test!(RunMake { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" });\n "}, {"sha": "3de27bc54c5c0b08b113b0587df78c5c851590da", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -142,10 +142,6 @@ jobs:\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n-      # MSVC aux tests\n-      x86_64-msvc-aux:\n-        RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n       x86_64-msvc-cargo:\n         SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n         INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-lld"}, {"sha": "a052d0879a3dbfe1c6aecf1f9077e2dcbfe1ea1a", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -492,12 +492,6 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n             <<: *job-windows-xl\n \n-          - name: x86_64-msvc-aux\n-            env:\n-              RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n-            <<: *job-windows-xl\n-\n           - name: x86_64-msvc-cargo\n             env:\n               SCRIPT: python x.py test src/tools/cargotest src/tools/cargo"}, {"sha": "fe05e914e6d440cccad3964011f5978c49655402", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -145,7 +145,6 @@\n #![feature(associated_type_bounds)]\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n-#![feature(option_zip)]\n #![feature(no_niche)] // rust-lang/rust#68303\n \n #[prelude_import]"}, {"sha": "5f0a12678ff432a00b501a0419670a2540ab1694", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -926,17 +926,19 @@ impl<T> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(option_zip)]\n     /// let x = Some(1);\n     /// let y = Some(\"hi\");\n     /// let z = None::<u8>;\n     ///\n     /// assert_eq!(x.zip(y), Some((1, \"hi\")));\n     /// assert_eq!(x.zip(z), None);\n     /// ```\n-    #[unstable(feature = \"option_zip\", issue = \"70086\")]\n+    #[stable(feature = \"option_zip_option\", since = \"1.46.0\")]\n     pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)> {\n-        self.zip_with(other, |a, b| (a, b))\n+        match (self, other) {\n+            (Some(a), Some(b)) => Some((a, b)),\n+            _ => None,\n+        }\n     }\n \n     /// Zips `self` and another `Option` with function `f`."}, {"sha": "4a2a0de0e211ffb7a544d4bc7292339eea5e84c4", "filename": "src/librustc_arena/lib.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_arena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_arena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_arena%2Flib.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -602,7 +602,7 @@ macro_rules! which_arena_for_type {\n \n #[macro_export]\n macro_rules! declare_arena {\n-    ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n+    ([], [$($a:tt $name:ident: $ty:ty, $gen_ty:ty;)*], $tcx:lifetime) => {\n         #[derive(Default)]\n         pub struct Arena<$tcx> {\n             pub dropless: $crate::DroplessArena,\n@@ -611,17 +611,17 @@ macro_rules! declare_arena {\n         }\n \n         #[marker]\n-        pub trait ArenaAllocatable {}\n+        pub trait ArenaAllocatable<'tcx> {}\n \n-        impl<T: Copy> ArenaAllocatable for T {}\n+        impl<'tcx, T: Copy> ArenaAllocatable<'tcx> for T {}\n \n-        unsafe trait ArenaField<'tcx>: Sized {\n+        unsafe trait ArenaField<'tcx>: Sized + ArenaAllocatable<'tcx> {\n             /// Returns a specific arena to allocate from.\n             /// If `None` is returned, the `DropArena` will be used.\n             fn arena<'a>(arena: &'a Arena<'tcx>) -> Option<&'a $crate::TypedArena<Self>>;\n         }\n \n-        unsafe impl<'tcx, T> ArenaField<'tcx> for T {\n+        unsafe impl<'tcx, T: ArenaAllocatable<'tcx>> ArenaField<'tcx> for T {\n             #[inline]\n             default fn arena<'a>(_: &'a Arena<'tcx>) -> Option<&'a $crate::TypedArena<Self>> {\n                 panic!()\n@@ -630,18 +630,27 @@ macro_rules! declare_arena {\n \n         $(\n             #[allow(unused_lifetimes)]\n-            impl<$tcx> ArenaAllocatable for $ty {}\n-            unsafe impl<$tcx> ArenaField<$tcx> for $ty {\n+            impl<$tcx> ArenaAllocatable<$tcx> for $ty {}\n+            unsafe impl<$tcx, '_x, '_y, '_z, '_w> ArenaField<$tcx> for $gen_ty where Self: ArenaAllocatable<$tcx> {\n                 #[inline]\n                 fn arena<'a>(_arena: &'a Arena<$tcx>) -> Option<&'a $crate::TypedArena<Self>> {\n-                    $crate::which_arena_for_type!($a[&_arena.$name])\n+                    // SAFETY: We only implement `ArenaAllocatable<$tcx>` for\n+                    // `$ty`, so `$ty` and Self are the same type\n+                    unsafe {\n+                        ::std::mem::transmute::<\n+                            Option<&'a $crate::TypedArena<$ty>>,\n+                            Option<&'a $crate::TypedArena<Self>>,\n+                        >(\n+                            $crate::which_arena_for_type!($a[&_arena.$name])\n+                        )\n+                    }\n                 }\n             }\n         )*\n \n         impl<'tcx> Arena<'tcx> {\n             #[inline]\n-            pub fn alloc<T: ArenaAllocatable>(&self, value: T) -> &mut T {\n+            pub fn alloc<T: ArenaAllocatable<'tcx>>(&self, value: T) -> &mut T {\n                 if !::std::mem::needs_drop::<T>() {\n                     return self.dropless.alloc(value);\n                 }\n@@ -659,7 +668,7 @@ macro_rules! declare_arena {\n                 self.dropless.alloc_slice(value)\n             }\n \n-            pub fn alloc_from_iter<'a, T: ArenaAllocatable>(\n+            pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx>>(\n                 &'a self,\n                 iter: impl ::std::iter::IntoIterator<Item = T>,\n             ) -> &'a mut [T] {"}, {"sha": "a722a88a7a1026a5a8cdfbbdfd9a06da24113869", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -33,7 +33,7 @@\n #![feature(array_value_iter)]\n #![feature(crate_visibility_modifier)]\n #![feature(marker_trait_attr)]\n-#![feature(specialization)] // FIXME: min_specialization does not work\n+#![feature(min_specialization)]\n #![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "acaa26c6ad2fc609b72adbc4c8f79761e3ab902e", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -296,6 +296,29 @@ impl Diagnostic {\n         self\n     }\n \n+    pub fn multipart_suggestions(\n+        &mut self,\n+        msg: &str,\n+        suggestions: Vec<Vec<(Span, String)>>,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n+        self.suggestions.push(CodeSuggestion {\n+            substitutions: suggestions\n+                .into_iter()\n+                .map(|suggestion| Substitution {\n+                    parts: suggestion\n+                        .into_iter()\n+                        .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+                        .collect(),\n+                })\n+                .collect(),\n+            msg: msg.to_owned(),\n+            style: SuggestionStyle::ShowCode,\n+            applicability,\n+        });\n+        self\n+    }\n+\n     /// Prints out a message with for a multipart suggestion without showing the suggested code.\n     ///\n     /// This is intended to be used for suggestions that are obvious in what the changes need to"}, {"sha": "22bf8fe34aa155543c72fa41ad11d746ec1c8ee3", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -260,6 +260,19 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    pub fn multipart_suggestions(\n+        &mut self,\n+        msg: &str,\n+        suggestions: Vec<Vec<(Span, String)>>,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n+        if !self.0.allow_suggestions {\n+            return self;\n+        }\n+        self.0.diagnostic.multipart_suggestions(msg, suggestions, applicability);\n+        self\n+    }\n+\n     pub fn tool_only_multipart_suggestion(\n         &mut self,\n         msg: &str,"}, {"sha": "f439db715310cc1ac204ffffd302786b81e53aaf", "filename": "src/librustc_hir/arena.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_hir%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_hir%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Farena.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -12,41 +12,41 @@ macro_rules! arena_types {\n     ($macro:path, $args:tt, $tcx:lifetime) => (\n         $macro!($args, [\n             // HIR types\n-            [few] hir_krate: rustc_hir::Crate<$tcx>,\n-            [] arm: rustc_hir::Arm<$tcx>,\n-            [] asm_operand: rustc_hir::InlineAsmOperand<$tcx>,\n-            [] asm_template: rustc_ast::ast::InlineAsmTemplatePiece,\n-            [] attribute: rustc_ast::ast::Attribute,\n-            [] block: rustc_hir::Block<$tcx>,\n-            [] bare_fn_ty: rustc_hir::BareFnTy<$tcx>,\n-            [few] global_asm: rustc_hir::GlobalAsm,\n-            [] generic_arg: rustc_hir::GenericArg<$tcx>,\n-            [] generic_args: rustc_hir::GenericArgs<$tcx>,\n-            [] generic_bound: rustc_hir::GenericBound<$tcx>,\n-            [] generic_param: rustc_hir::GenericParam<$tcx>,\n-            [] expr: rustc_hir::Expr<$tcx>,\n-            [] field: rustc_hir::Field<$tcx>,\n-            [] field_pat: rustc_hir::FieldPat<$tcx>,\n-            [] fn_decl: rustc_hir::FnDecl<$tcx>,\n-            [] foreign_item: rustc_hir::ForeignItem<$tcx>,\n-            [] impl_item_ref: rustc_hir::ImplItemRef<$tcx>,\n-            [few] inline_asm: rustc_hir::InlineAsm<$tcx>,\n-            [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,\n-            [] local: rustc_hir::Local<$tcx>,\n-            [few] macro_def: rustc_hir::MacroDef<$tcx>,\n-            [] param: rustc_hir::Param<$tcx>,\n-            [] pat: rustc_hir::Pat<$tcx>,\n-            [] path: rustc_hir::Path<$tcx>,\n-            [] path_segment: rustc_hir::PathSegment<$tcx>,\n-            [] poly_trait_ref: rustc_hir::PolyTraitRef<$tcx>,\n-            [] qpath: rustc_hir::QPath<$tcx>,\n-            [] stmt: rustc_hir::Stmt<$tcx>,\n-            [] struct_field: rustc_hir::StructField<$tcx>,\n-            [] trait_item_ref: rustc_hir::TraitItemRef,\n-            [] ty: rustc_hir::Ty<$tcx>,\n-            [] type_binding: rustc_hir::TypeBinding<$tcx>,\n-            [] variant: rustc_hir::Variant<$tcx>,\n-            [] where_predicate: rustc_hir::WherePredicate<$tcx>,\n+            [few] hir_krate: rustc_hir::Crate<$tcx>, rustc_hir::Crate<'_x>;\n+            [] arm: rustc_hir::Arm<$tcx>, rustc_hir::Arm<'_x>;\n+            [] asm_operand: rustc_hir::InlineAsmOperand<$tcx>, rustc_hir::InlineAsmOperand<'_x>;\n+            [] asm_template: rustc_ast::ast::InlineAsmTemplatePiece, rustc_ast::ast::InlineAsmTemplatePiece;\n+            [] attribute: rustc_ast::ast::Attribute, rustc_ast::ast::Attribute;\n+            [] block: rustc_hir::Block<$tcx>, rustc_hir::Block<'_x>;\n+            [] bare_fn_ty: rustc_hir::BareFnTy<$tcx>, rustc_hir::BareFnTy<'_x>;\n+            [few] global_asm: rustc_hir::GlobalAsm, rustc_hir::GlobalAsm;\n+            [] generic_arg: rustc_hir::GenericArg<$tcx>, rustc_hir::GenericArg<'_x>;\n+            [] generic_args: rustc_hir::GenericArgs<$tcx>, rustc_hir::GenericArgs<'_x>;\n+            [] generic_bound: rustc_hir::GenericBound<$tcx>, rustc_hir::GenericBound<'_x>;\n+            [] generic_param: rustc_hir::GenericParam<$tcx>, rustc_hir::GenericParam<'_x>;\n+            [] expr: rustc_hir::Expr<$tcx>, rustc_hir::Expr<'_x>;\n+            [] field: rustc_hir::Field<$tcx>, rustc_hir::Field<'_x>;\n+            [] field_pat: rustc_hir::FieldPat<$tcx>, rustc_hir::FieldPat<'_x>;\n+            [] fn_decl: rustc_hir::FnDecl<$tcx>, rustc_hir::FnDecl<'_x>;\n+            [] foreign_item: rustc_hir::ForeignItem<$tcx>, rustc_hir::ForeignItem<'_x>;\n+            [] impl_item_ref: rustc_hir::ImplItemRef<$tcx>, rustc_hir::ImplItemRef<'_x>;\n+            [few] inline_asm: rustc_hir::InlineAsm<$tcx>, rustc_hir::InlineAsm<'_x>;\n+            [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>, rustc_hir::LlvmInlineAsm<'_x>;\n+            [] local: rustc_hir::Local<$tcx>, rustc_hir::Local<'_x>;\n+            [few] macro_def: rustc_hir::MacroDef<$tcx>, rustc_hir::MacroDef<'_x>;\n+            [] param: rustc_hir::Param<$tcx>, rustc_hir::Param<'_x>;\n+            [] pat: rustc_hir::Pat<$tcx>, rustc_hir::Pat<'_x>;\n+            [] path: rustc_hir::Path<$tcx>, rustc_hir::Path<'_x>;\n+            [] path_segment: rustc_hir::PathSegment<$tcx>, rustc_hir::PathSegment<'_x>;\n+            [] poly_trait_ref: rustc_hir::PolyTraitRef<$tcx>, rustc_hir::PolyTraitRef<'_x>;\n+            [] qpath: rustc_hir::QPath<$tcx>, rustc_hir::QPath<'_x>;\n+            [] stmt: rustc_hir::Stmt<$tcx>, rustc_hir::Stmt<'_x>;\n+            [] struct_field: rustc_hir::StructField<$tcx>, rustc_hir::StructField<'_x>;\n+            [] trait_item_ref: rustc_hir::TraitItemRef, rustc_hir::TraitItemRef;\n+            [] ty: rustc_hir::Ty<$tcx>, rustc_hir::Ty<'_x>;\n+            [] type_binding: rustc_hir::TypeBinding<$tcx>, rustc_hir::TypeBinding<'_x>;\n+            [] variant: rustc_hir::Variant<$tcx>, rustc_hir::Variant<'_x>;\n+            [] where_predicate: rustc_hir::WherePredicate<$tcx>, rustc_hir::WherePredicate<'_x>;\n         ], $tcx);\n     )\n }"}, {"sha": "8af526e3ad31b31171753d27693d72764ac624d1", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -56,7 +56,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, T>>\n     where\n         T: Debug + TypeFoldable<'tcx>,\n-        Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable,\n+        Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,\n     {\n         let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n         let canonical_result = self.canonicalize_response(&query_response);"}, {"sha": "c17d5311e8fe6393d23de5e463abf7fc70588d13", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -433,7 +433,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n                 try_load_from_on_disk_cache_stream.extend(quote! {\n                     ::rustc_middle::dep_graph::DepKind::#name => {\n-                        if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n+                        if <#arg as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key() {\n                             debug_assert!($tcx.dep_graph\n                                             .node_color($dep_node)\n                                             .map(|c| c.is_green())\n@@ -490,7 +490,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             // Add a match arm to force the query given the dep node\n             dep_node_force_stream.extend(quote! {\n                 ::rustc_middle::dep_graph::DepKind::#name => {\n-                    if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n+                    if <#arg as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key() {\n                         if let Some(key) = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node) {\n                             force_query::<crate::ty::query::queries::#name<'_>, _>(\n                                 $tcx,"}, {"sha": "76e39a476c6d89f73507f29525a488c62a8e5e67", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -7,7 +7,7 @@\n #![feature(nll)]\n #![feature(or_patterns)]\n #![feature(proc_macro_internals)]\n-#![feature(specialization)] // FIXME: min_specialization ICEs\n+#![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "0335aa8358c3c9a6fb1adeffbbaf4e7bad7da7b2", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::mir::{self, interpret, Body, Promoted};\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util::common::record_time;\n-use rustc_serialize::{opaque, Decodable, Decoder, SpecializedDecoder};\n+use rustc_serialize::{opaque, Decodable, Decoder, SpecializedDecoder, UseSpecializedDecodable};\n use rustc_session::Session;\n use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -218,15 +218,15 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable> Lazy<T> {\n+impl<'a, 'tcx, T: Decodable> Lazy<T, ()> {\n     fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n         let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n-impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T], usize> {\n     fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         metadata: M,\n@@ -321,20 +321,20 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T, ()>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n         self.read_lazy_with_meta(())\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T], usize>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<[T]>, Self::Error> {\n         let len = self.read_usize()?;\n         if len == 0 { Ok(Lazy::empty()) } else { self.read_lazy_with_meta(len) }\n     }\n }\n \n-impl<'a, 'tcx, I: Idx, T> SpecializedDecoder<Lazy<Table<I, T>>> for DecodeContext<'a, 'tcx>\n+impl<'a, 'tcx, I: Idx, T> SpecializedDecoder<Lazy<Table<I, T>, usize>> for DecodeContext<'a, 'tcx>\n where\n     Option<T>: FixedSizeEncoding,\n {\n@@ -515,8 +515,9 @@ impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n-    for DecodeContext<'a, 'tcx>\n+impl<'a, 'tcx, T> SpecializedDecoder<mir::ClearCrossCrate<T>> for DecodeContext<'a, 'tcx>\n+where\n+    mir::ClearCrossCrate<T>: UseSpecializedDecodable,\n {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<mir::ClearCrossCrate<T>, Self::Error> {"}, {"sha": "d797e6d4a34af6d0ed57c7948997657b3bd45d1e", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::mir::{self, interpret};\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::{self as ty_codec, TyEncoder};\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n-use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n+use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder, UseSpecializedEncodable};\n use rustc_session::config::CrateType;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -93,13 +93,13 @@ impl<'tcx> Encoder for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n+impl<'tcx, T> SpecializedEncoder<Lazy<T, ()>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n         self.emit_lazy_distance(*lazy)\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n+impl<'tcx, T> SpecializedEncoder<Lazy<[T], usize>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<[T]>) -> Result<(), Self::Error> {\n         self.emit_usize(lazy.meta)?;\n         if lazy.meta == 0 {\n@@ -109,7 +109,7 @@ impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, I: Idx, T> SpecializedEncoder<Lazy<Table<I, T>>> for EncodeContext<'tcx>\n+impl<'tcx, I: Idx, T> SpecializedEncoder<Lazy<Table<I, T>, usize>> for EncodeContext<'tcx>\n where\n     Option<T>: FixedSizeEncoding,\n {\n@@ -228,8 +228,13 @@ impl<'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'tcx> {\n-    fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n+impl<'a, 'b, 'tcx> SpecializedEncoder<&'a ty::TyS<'b>> for EncodeContext<'tcx>\n+where\n+    &'a ty::TyS<'b>: UseSpecializedEncodable,\n+{\n+    fn specialized_encode(&mut self, ty: &&'a ty::TyS<'b>) -> Result<(), Self::Error> {\n+        debug_assert!(self.tcx.lift(ty).is_some());\n+        let ty = unsafe { std::mem::transmute::<&&'a ty::TyS<'b>, &&'tcx ty::TyS<'tcx>>(ty) };\n         ty_codec::encode_with_shorthand(self, ty, |ecx| &mut ecx.type_shorthands)\n     }\n }\n@@ -251,12 +256,19 @@ impl<'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx> SpecializedEncoder<&'tcx [(ty::Predicate<'tcx>, Span)]> for EncodeContext<'tcx> {\n+impl<'a, 'b, 'tcx> SpecializedEncoder<&'a [(ty::Predicate<'b>, Span)]> for EncodeContext<'tcx> {\n     fn specialized_encode(\n         &mut self,\n-        predicates: &&'tcx [(ty::Predicate<'tcx>, Span)],\n+        predicates: &&'a [(ty::Predicate<'b>, Span)],\n     ) -> Result<(), Self::Error> {\n-        ty_codec::encode_spanned_predicates(self, predicates, |ecx| &mut ecx.predicate_shorthands)\n+        debug_assert!(self.tcx.lift(*predicates).is_some());\n+        let predicates = unsafe {\n+            std::mem::transmute::<\n+                &&'a [(ty::Predicate<'b>, Span)],\n+                &&'tcx [(ty::Predicate<'tcx>, Span)],\n+            >(predicates)\n+        };\n+        ty_codec::encode_spanned_predicates(self, &predicates, |ecx| &mut ecx.predicate_shorthands)\n     }\n }\n \n@@ -266,7 +278,10 @@ impl<'tcx> SpecializedEncoder<Fingerprint> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, T: Encodable> SpecializedEncoder<mir::ClearCrossCrate<T>> for EncodeContext<'tcx> {\n+impl<'tcx, T> SpecializedEncoder<mir::ClearCrossCrate<T>> for EncodeContext<'tcx>\n+where\n+    mir::ClearCrossCrate<T>: UseSpecializedEncodable,\n+{\n     fn specialized_encode(&mut self, _: &mir::ClearCrossCrate<T>) -> Result<(), Self::Error> {\n         Ok(())\n     }"}, {"sha": "f861d63aba0f3c4f77cf6927c732b0bb3624ef61", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -11,79 +11,109 @@\n macro_rules! arena_types {\n     ($macro:path, $args:tt, $tcx:lifetime) => (\n         $macro!($args, [\n-            [] layouts: rustc_target::abi::Layout,\n+            [] layouts: rustc_target::abi::Layout, rustc_target::abi::Layout;\n             // AdtDef are interned and compared by address\n-            [] adt_def: rustc_middle::ty::AdtDef,\n-            [decode] tables: rustc_middle::ty::TypeckTables<$tcx>,\n-            [] const_allocs: rustc_middle::mir::interpret::Allocation,\n+            [] adt_def: rustc_middle::ty::AdtDef, rustc_middle::ty::AdtDef;\n+            [decode] tables: rustc_middle::ty::TypeckTables<$tcx>, rustc_middle::ty::TypeckTables<'_x>;\n+            [] const_allocs: rustc_middle::mir::interpret::Allocation, rustc_middle::mir::interpret::Allocation;\n             // Required for the incremental on-disk cache\n-            [few, decode] mir_keys: rustc_hir::def_id::DefIdSet,\n-            [] region_scope_tree: rustc_middle::middle::region::ScopeTree,\n+            [few, decode] mir_keys: rustc_hir::def_id::DefIdSet, rustc_hir::def_id::DefIdSet;\n+            [] region_scope_tree: rustc_middle::middle::region::ScopeTree, rustc_middle::middle::region::ScopeTree;\n             [] dropck_outlives:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx,\n                         rustc_middle::traits::query::DropckOutlivesResult<'tcx>\n                     >\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y,\n+                        rustc_middle::traits::query::DropckOutlivesResult<'_z>\n+                    >\n+                >;\n             [] normalize_projection_ty:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx,\n                         rustc_middle::traits::query::NormalizationResult<'tcx>\n                     >\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y,\n+                        rustc_middle::traits::query::NormalizationResult<'_z>\n+                    >\n+                >;\n             [] implied_outlives_bounds:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx,\n                         Vec<rustc_middle::traits::query::OutlivesBound<'tcx>>\n                     >\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y,\n+                        Vec<rustc_middle::traits::query::OutlivesBound<'_z>>\n+                    >\n+                >;\n             [] type_op_subtype:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, ()>\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y, ()>\n+                >;\n             [] type_op_normalize_poly_fn_sig:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::PolyFnSig<'tcx>>\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y, rustc_middle::ty::PolyFnSig<'_z>>\n+                >;\n             [] type_op_normalize_fn_sig:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::FnSig<'tcx>>\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y, rustc_middle::ty::FnSig<'_z>>\n+                >;\n             [] type_op_normalize_predicate:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::Predicate<'tcx>>\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y, rustc_middle::ty::Predicate<'_z>>\n+                >;\n             [] type_op_normalize_ty:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::Ty<'tcx>>\n                 >,\n-            [few] all_traits: Vec<rustc_hir::def_id::DefId>,\n-            [few] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels,\n-            [few] foreign_module: rustc_middle::middle::cstore::ForeignModule,\n-            [few] foreign_modules: Vec<rustc_middle::middle::cstore::ForeignModule>,\n-            [] upvars_mentioned: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n-            [] object_safety_violations: rustc_middle::traits::ObjectSafetyViolation,\n-            [] codegen_unit: rustc_middle::mir::mono::CodegenUnit<$tcx>,\n-            [] attribute: rustc_ast::ast::Attribute,\n-            [] name_set: rustc_data_structures::fx::FxHashSet<rustc_span::symbol::Symbol>,\n-            [] hir_id_set: rustc_hir::HirIdSet,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y, &'_z rustc_middle::ty::TyS<'_w>>\n+                >;\n+            [few] all_traits: Vec<rustc_hir::def_id::DefId>, Vec<rustc_hir::def_id::DefId>;\n+            [few] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels, rustc_middle::middle::privacy::AccessLevels;\n+            [few] foreign_module: rustc_middle::middle::cstore::ForeignModule, rustc_middle::middle::cstore::ForeignModule;\n+            [few] foreign_modules: Vec<rustc_middle::middle::cstore::ForeignModule>, Vec<rustc_middle::middle::cstore::ForeignModule>;\n+            [] upvars_mentioned: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>, rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>;\n+            [] object_safety_violations: rustc_middle::traits::ObjectSafetyViolation, rustc_middle::traits::ObjectSafetyViolation;\n+            [] codegen_unit: rustc_middle::mir::mono::CodegenUnit<$tcx>, rustc_middle::mir::mono::CodegenUnit<'_x>;\n+            [] attribute: rustc_ast::ast::Attribute, rustc_ast::ast::Attribute;\n+            [] name_set: rustc_data_structures::fx::FxHashSet<rustc_span::symbol::Symbol>, rustc_data_structures::fx::FxHashSet<rustc_span::symbol::Symbol>;\n+            [] hir_id_set: rustc_hir::HirIdSet, rustc_hir::HirIdSet;\n \n             // Interned types\n-            [] tys: rustc_middle::ty::TyS<$tcx>,\n+            [] tys: rustc_middle::ty::TyS<$tcx>, rustc_middle::ty::TyS<'_x>;\n \n             // HIR query types\n-            [few] indexed_hir: rustc_middle::hir::map::IndexedHir<$tcx>,\n-            [few] hir_definitions: rustc_hir::definitions::Definitions,\n-            [] hir_owner: rustc_middle::hir::Owner<$tcx>,\n-            [] hir_owner_nodes: rustc_middle::hir::OwnerNodes<$tcx>,\n+            [few] indexed_hir: rustc_middle::hir::map::IndexedHir<$tcx>, rustc_middle::hir::map::IndexedHir<'_x>;\n+            [few] hir_definitions: rustc_hir::definitions::Definitions, rustc_hir::definitions::Definitions;\n+            [] hir_owner: rustc_middle::hir::Owner<$tcx>, rustc_middle::hir::Owner<'_x>;\n+            [] hir_owner_nodes: rustc_middle::hir::OwnerNodes<$tcx>, rustc_middle::hir::OwnerNodes<'_x>;\n \n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,\n             // since we need to allocate this type on both the `rustc_hir` arena\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)\n-            [decode] asm_template: rustc_ast::ast::InlineAsmTemplatePiece,\n+            [decode] asm_template: rustc_ast::ast::InlineAsmTemplatePiece, rustc_ast::ast::InlineAsmTemplatePiece;\n \n             // This is used to decode the &'tcx [Span] for InlineAsm's line_spans.\n-            [decode] span: rustc_span::Span,\n+            [decode] span: rustc_span::Span, rustc_span::Span;\n         ], $tcx);\n     )\n }"}, {"sha": "b14f17dee60603f4340116a64edd286038525ef7", "filename": "src/librustc_middle/dep_graph/dep_node.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -128,7 +128,7 @@ macro_rules! define_dep_nodes {\n                             // tuple args\n                             $({\n                                 return <$tuple_arg_ty as DepNodeParams<TyCtxt<'_>>>\n-                                    ::CAN_RECONSTRUCT_QUERY_KEY;\n+                                    ::can_reconstruct_query_key();\n                             })*\n \n                             true\n@@ -304,7 +304,10 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n ]);\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+    #[inline]\n+    fn can_reconstruct_query_key() -> bool {\n+        true\n+    }\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         tcx.def_path_hash(*self).0\n@@ -320,7 +323,10 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+    #[inline]\n+    fn can_reconstruct_query_key() -> bool {\n+        true\n+    }\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         self.to_def_id().to_fingerprint(tcx)\n@@ -336,7 +342,10 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+    #[inline]\n+    fn can_reconstruct_query_key() -> bool {\n+        true\n+    }\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n@@ -353,7 +362,10 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+    #[inline]\n+    fn can_reconstruct_query_key() -> bool {\n+        false\n+    }\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n@@ -375,7 +387,10 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for HirId {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+    #[inline]\n+    fn can_reconstruct_query_key() -> bool {\n+        false\n+    }\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full"}, {"sha": "62c92e988ba60b12c18ab26996d91dea103d58be", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -42,7 +42,7 @@\n #![feature(option_expect_none)]\n #![feature(or_patterns)]\n #![feature(range_is_empty)]\n-#![feature(specialization)] // FIXME: min_specialization does not work\n+#![feature(min_specialization)]\n #![feature(track_caller)]\n #![feature(trusted_len)]\n #![feature(vec_remove_item)]"}, {"sha": "27848684706d6d824e34e6f8debb769d95f32769", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -458,8 +458,39 @@ impl<T> ClearCrossCrate<T> {\n     }\n }\n \n-impl<T: Encodable> rustc_serialize::UseSpecializedEncodable for ClearCrossCrate<T> {}\n-impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<T> {}\n+const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n+const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n+\n+impl<T: Encodable> rustc_serialize::UseSpecializedEncodable for ClearCrossCrate<T> {\n+    #[inline]\n+    fn default_encode<E: rustc_serialize::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+        match *self {\n+            ClearCrossCrate::Clear => TAG_CLEAR_CROSS_CRATE_CLEAR.encode(e),\n+            ClearCrossCrate::Set(ref val) => {\n+                TAG_CLEAR_CROSS_CRATE_SET.encode(e)?;\n+                val.encode(e)\n+            }\n+        }\n+    }\n+}\n+impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<T> {\n+    #[inline]\n+    fn default_decode<D>(d: &mut D) -> Result<ClearCrossCrate<T>, D::Error>\n+    where\n+        D: rustc_serialize::Decoder,\n+    {\n+        let discr = u8::decode(d)?;\n+\n+        match discr {\n+            TAG_CLEAR_CROSS_CRATE_CLEAR => Ok(ClearCrossCrate::Clear),\n+            TAG_CLEAR_CROSS_CRATE_SET => {\n+                let val = T::decode(d)?;\n+                Ok(ClearCrossCrate::Set(val))\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n \n /// Grouped information about the source code origin of a MIR entity.\n /// Intended to be inspected by diagnostics and debuginfo.\n@@ -1958,8 +1989,6 @@ impl<V, T> ProjectionElem<V, T> {\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n \n-impl<'tcx> Copy for PlaceElem<'tcx> {}\n-\n // At least on 64 bit systems, `PlaceElem` should not be larger than two pointers.\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PlaceElem<'_>, 16);"}, {"sha": "1a8e5c45dd2f7f6a16a0a946c49f236005f26414", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 85, "deletions": 57, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -97,7 +97,7 @@ where\n \n pub fn encode_spanned_predicates<'tcx, E, C>(\n     encoder: &mut E,\n-    predicates: &'tcx [(ty::Predicate<'tcx>, Span)],\n+    predicates: &[(ty::Predicate<'tcx>, Span)],\n     cache: C,\n ) -> Result<(), E::Error>\n where\n@@ -139,7 +139,7 @@ pub trait TyDecoder<'tcx>: Decoder {\n }\n \n #[inline]\n-pub fn decode_arena_allocable<D, T: ArenaAllocatable + Decodable>(\n+pub fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable>(\n     decoder: &mut D,\n ) -> Result<&'tcx T, D::Error>\n where\n@@ -149,7 +149,7 @@ where\n }\n \n #[inline]\n-pub fn decode_arena_allocable_slice<D, T: ArenaAllocatable + Decodable>(\n+pub fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable>(\n     decoder: &mut D,\n ) -> Result<&'tcx [T], D::Error>\n where\n@@ -318,18 +318,38 @@ macro_rules! __impl_decoder_methods {\n macro_rules! impl_arena_allocatable_decoder {\n     ([]$args:tt) => {};\n     ([decode $(, $attrs:ident)*]\n-     [[$DecoderName:ident [$($typaram:tt),*]], [$name:ident: $ty:ty], $tcx:lifetime]) => {\n-        impl<$($typaram),*> SpecializedDecoder<&$tcx $ty> for $DecoderName<$($typaram),*> {\n+     [[$DecoderName:ident [$($typaram:tt),*]], [$name:ident: $ty:ty, $gen_ty:ty], $tcx:lifetime]) => {\n+         // FIXME(#36588): These impls are horribly unsound as they allow\n+         // the caller to pick any lifetime for `'tcx`, including `'static`.\n+        #[allow(unused_lifetimes)]\n+        impl<'_x, '_y, '_z, '_w, '_a, $($typaram),*> SpecializedDecoder<&'_a $gen_ty>\n+        for $DecoderName<$($typaram),*>\n+        where &'_a $gen_ty: UseSpecializedDecodable\n+        {\n             #[inline]\n-            fn specialized_decode(&mut self) -> Result<&$tcx $ty, Self::Error> {\n-                decode_arena_allocable(self)\n+            fn specialized_decode(&mut self) -> Result<&'_a $gen_ty, Self::Error> {\n+                unsafe {\n+                    std::mem::transmute::<\n+                        Result<&$tcx $ty, Self::Error>,\n+                        Result<&'_a $gen_ty, Self::Error>,\n+                    >(decode_arena_allocable(self))\n+                }\n             }\n         }\n \n-        impl<$($typaram),*> SpecializedDecoder<&$tcx [$ty]> for $DecoderName<$($typaram),*> {\n+        #[allow(unused_lifetimes)]\n+        impl<'_x, '_y, '_z, '_w, '_a, $($typaram),*> SpecializedDecoder<&'_a [$gen_ty]>\n+        for $DecoderName<$($typaram),*>\n+        where &'_a [$gen_ty]: UseSpecializedDecodable\n+        {\n             #[inline]\n-            fn specialized_decode(&mut self) -> Result<&$tcx [$ty], Self::Error> {\n-                decode_arena_allocable_slice(self)\n+            fn specialized_decode(&mut self) -> Result<&'_a [$gen_ty], Self::Error> {\n+                unsafe {\n+                    std::mem::transmute::<\n+                        Result<&$tcx [$ty], Self::Error>,\n+                        Result<&'_a [$gen_ty], Self::Error>,\n+                    >(decode_arena_allocable_slice(self))\n+                }\n             }\n         }\n     };\n@@ -340,9 +360,9 @@ macro_rules! impl_arena_allocatable_decoder {\n \n #[macro_export]\n macro_rules! impl_arena_allocatable_decoders {\n-    ($args:tt, [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n+    ($args:tt, [$($a:tt $name:ident: $ty:ty, $gen_ty:ty;)*], $tcx:lifetime) => {\n         $(\n-            impl_arena_allocatable_decoder!($a [$args, [$name: $ty], $tcx]);\n+            impl_arena_allocatable_decoder!($a [$args, [$name: $ty, $gen_ty], $tcx]);\n         )*\n     }\n }\n@@ -352,14 +372,15 @@ macro_rules! implement_ty_decoder {\n     ($DecoderName:ident <$($typaram:tt),*>) => {\n         mod __ty_decoder_impl {\n             use std::borrow::Cow;\n+            use std::mem::transmute;\n \n-            use rustc_serialize::{Decoder, SpecializedDecoder};\n+            use rustc_serialize::{Decoder, SpecializedDecoder, UseSpecializedDecodable};\n \n             use $crate::infer::canonical::CanonicalVarInfos;\n             use $crate::ty;\n             use $crate::ty::codec::*;\n-            use $crate::ty::subst::SubstsRef;\n-            use rustc_hir::def_id::{CrateNum};\n+            use $crate::ty::subst::InternalSubsts;\n+            use rustc_hir::def_id::CrateNum;\n \n             use rustc_span::Span;\n \n@@ -398,8 +419,7 @@ macro_rules! implement_ty_decoder {\n             }\n \n             // FIXME(#36588): These impls are horribly unsound as they allow\n-            // the caller to pick any lifetime for `'tcx`, including `'static`,\n-            // by using the unspecialized proxies to them.\n+            // the caller to pick any lifetime for `'tcx`, including `'static`.\n \n             rustc_hir::arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);\n             arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);\n@@ -411,90 +431,98 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<ty::Ty<'tcx>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<ty::Ty<'tcx>, Self::Error> {\n-                    decode_ty(self)\n+            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x ty::TyS<'_y>>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x ty::TyS<'_y>: UseSpecializedDecodable\n+            {\n+                fn specialized_decode(&mut self) -> Result<&'_x ty::TyS<'_y>, Self::Error> {\n+                    unsafe { transmute::<Result<ty::Ty<'tcx>, Self::Error>, Result<&'_x ty::TyS<'_y>, Self::Error>>(decode_ty(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx [(ty::Predicate<'tcx>, Span)]>\n-            for $DecoderName<$($typaram),*> {\n+            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x [(ty::Predicate<'_y>, Span)]>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x [(ty::Predicate<'_y>, Span)]: UseSpecializedDecodable {\n                 fn specialized_decode(&mut self)\n-                                      -> Result<&'tcx [(ty::Predicate<'tcx>, Span)], Self::Error> {\n-                    decode_spanned_predicates(self)\n+                                      -> Result<&'_x [(ty::Predicate<'_y>, Span)], Self::Error>\n+                {\n+                    unsafe { transmute(decode_spanned_predicates(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<SubstsRef<'tcx>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<SubstsRef<'tcx>, Self::Error> {\n-                    decode_substs(self)\n+            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x InternalSubsts<'_y>>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x InternalSubsts<'_y>: UseSpecializedDecodable {\n+                fn specialized_decode(&mut self) -> Result<&'_x InternalSubsts<'_y>, Self::Error> {\n+                    unsafe { transmute(decode_substs(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<$crate::mir::Place<'tcx>>\n+            impl<'_x, $($typaram),*> SpecializedDecoder<$crate::mir::Place<'_x>>\n             for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(\n                     &mut self\n-                ) -> Result<$crate::mir::Place<'tcx>, Self::Error> {\n-                    decode_place(self)\n+                ) -> Result<$crate::mir::Place<'_x>, Self::Error> {\n+                    unsafe { transmute(decode_place(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<ty::Region<'tcx>>\n+            impl<'_x, $($typaram),*> SpecializedDecoder<ty::Region<'_x>>\n             for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<ty::Region<'tcx>, Self::Error> {\n-                    decode_region(self)\n+                fn specialized_decode(&mut self) -> Result<ty::Region<'_x>, Self::Error> {\n+                    unsafe { transmute(decode_region(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::List<ty::Ty<'tcx>>>\n-            for $DecoderName<$($typaram),*> {\n+            impl<'_x, '_y, '_z, $($typaram),*> SpecializedDecoder<&'_x ty::List<&'_y ty::TyS<'_z>>>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x ty::List<&'_y ty::TyS<'_z>>: UseSpecializedDecodable {\n                 fn specialized_decode(&mut self)\n-                                      -> Result<&'tcx ty::List<ty::Ty<'tcx>>, Self::Error> {\n-                    decode_ty_slice(self)\n+                                      -> Result<&'_x ty::List<&'_y ty::TyS<'_z>>, Self::Error> {\n+                    unsafe { transmute(decode_ty_slice(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::AdtDef>\n+            impl<'_x, $($typaram),*> SpecializedDecoder<&'_x ty::AdtDef>\n             for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<&'tcx ty::AdtDef, Self::Error> {\n-                    decode_adt_def(self)\n+                fn specialized_decode(&mut self) -> Result<&'_x ty::AdtDef, Self::Error> {\n+                    unsafe { transmute(decode_adt_def(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>\n-                for $DecoderName<$($typaram),*> {\n+            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x ty::List<ty::ExistentialPredicate<'_y>>>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x ty::List<ty::ExistentialPredicate<'_y>>: UseSpecializedDecodable {\n                 fn specialized_decode(&mut self)\n-                    -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n-                    decode_existential_predicate_slice(self)\n+                    -> Result<&'_x ty::List<ty::ExistentialPredicate<'_y>>, Self::Error> {\n+                        unsafe { transmute(decode_existential_predicate_slice(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<CanonicalVarInfos<'tcx>>\n+            impl<'_x, $($typaram),*> SpecializedDecoder<CanonicalVarInfos<'_x>>\n                 for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(&mut self)\n-                    -> Result<CanonicalVarInfos<'tcx>, Self::Error> {\n-                    decode_canonical_var_infos(self)\n+                    -> Result<CanonicalVarInfos<'_x>, Self::Error> {\n+                        unsafe { transmute(decode_canonical_var_infos(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::ty::Const<'tcx>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-                    decode_const(self)\n+            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x $crate::ty::Const<'_y>>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x $crate::ty::Const<'_y>: UseSpecializedDecodable {\n+                fn specialized_decode(&mut self) -> Result<&'_x ty::Const<'_y>, Self::Error> {\n+                    unsafe { transmute(decode_const(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::mir::interpret::Allocation>\n+            impl<'_x, $($typaram),*> SpecializedDecoder<&'_x $crate::mir::interpret::Allocation>\n             for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(\n                     &mut self\n-                ) -> Result<&'tcx $crate::mir::interpret::Allocation, Self::Error> {\n-                    decode_allocation(self)\n+                ) -> Result<&'_x $crate::mir::interpret::Allocation, Self::Error> {\n+                    unsafe { transmute(decode_allocation(self)) }\n                 }\n             }\n         }\n-    }\n+    };\n }"}, {"sha": "5374dff422425e938e066c8628616d68a59cb9f4", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 16, "deletions": 44, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1,6 +1,6 @@\n use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n+use crate::mir::interpret;\n use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use crate::mir::{self, interpret};\n use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n@@ -26,9 +26,6 @@ use std::mem;\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n-const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n-const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n-\n const TAG_NO_EXPN_DATA: u8 = 0;\n const TAG_EXPN_DATA_SHORTHAND: u8 = 1;\n const TAG_EXPN_DATA_INLINE: u8 = 2;\n@@ -667,24 +664,6 @@ impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n-    for CacheDecoder<'a, 'tcx>\n-{\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<mir::ClearCrossCrate<T>, Self::Error> {\n-        let discr = u8::decode(self)?;\n-\n-        match discr {\n-            TAG_CLEAR_CROSS_CRATE_CLEAR => Ok(mir::ClearCrossCrate::Clear),\n-            TAG_CLEAR_CROSS_CRATE_SET => {\n-                let val = T::decode(self)?;\n-                Ok(mir::ClearCrossCrate::Set(val))\n-            }\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n //- ENCODING -------------------------------------------------------------------\n \n /// An encoder that can write the incr. comp. cache.\n@@ -828,26 +807,36 @@ where\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'b, 'c, 'tcx, E> SpecializedEncoder<&'b ty::TyS<'c>> for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + TyEncoder,\n+    &'b ty::TyS<'c>: UseSpecializedEncodable,\n {\n     #[inline]\n-    fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n+    fn specialized_encode(&mut self, ty: &&'b ty::TyS<'c>) -> Result<(), Self::Error> {\n+        debug_assert!(self.tcx.lift(ty).is_some());\n+        let ty = unsafe { std::mem::transmute::<&&'b ty::TyS<'c>, &&'tcx ty::TyS<'tcx>>(ty) };\n         ty_codec::encode_with_shorthand(self, ty, |encoder| &mut encoder.type_shorthands)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<&'tcx [(ty::Predicate<'tcx>, Span)]>\n+impl<'a, 'b, 'c, 'tcx, E> SpecializedEncoder<&'b [(ty::Predicate<'c>, Span)]>\n     for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(\n         &mut self,\n-        predicates: &&'tcx [(ty::Predicate<'tcx>, Span)],\n+        predicates: &&'b [(ty::Predicate<'c>, Span)],\n     ) -> Result<(), Self::Error> {\n+        debug_assert!(self.tcx.lift(*predicates).is_some());\n+        let predicates = unsafe {\n+            std::mem::transmute::<\n+                &&'b [(ty::Predicate<'c>, Span)],\n+                &&'tcx [(ty::Predicate<'tcx>, Span)],\n+            >(predicates)\n+        };\n         ty_codec::encode_spanned_predicates(self, predicates, |encoder| {\n             &mut encoder.predicate_shorthands\n         })\n@@ -890,23 +879,6 @@ impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for CacheEncoder<'a, 'tcx, opaque\n     }\n }\n \n-impl<'a, 'tcx, E, T> SpecializedEncoder<mir::ClearCrossCrate<T>> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-    T: Encodable,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, val: &mir::ClearCrossCrate<T>) -> Result<(), Self::Error> {\n-        match *val {\n-            mir::ClearCrossCrate::Clear => TAG_CLEAR_CROSS_CRATE_CLEAR.encode(self),\n-            mir::ClearCrossCrate::Set(ref val) => {\n-                TAG_CLEAR_CROSS_CRATE_SET.encode(self)?;\n-                val.encode(self)\n-            }\n-        }\n-    }\n-}\n-\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         #[inline]\n@@ -995,7 +967,7 @@ fn encode_query_results<'a, 'tcx, Q, E>(\n     query_result_index: &mut EncodedQueryResultIndex,\n ) -> Result<(), E::Error>\n where\n-    Q: super::QueryDescription<TyCtxt<'tcx>>,\n+    Q: super::QueryDescription<TyCtxt<'tcx>> + super::QueryAccessors<TyCtxt<'tcx>>,\n     Q::Value: Encodable,\n     E: 'a + TyEncoder,\n {"}, {"sha": "3c44662441890431f15e70a74d318aa4f4015759", "filename": "src/librustc_middle/ty/query/profiling_support.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -112,30 +112,53 @@ impl<T: Debug> IntoSelfProfilingString for T {\n     }\n }\n \n-impl IntoSelfProfilingString for DefId {\n+impl<T: SpecIntoSelfProfilingString> IntoSelfProfilingString for T {\n     fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_, '_>) -> StringId {\n+        self.spec_to_self_profile_string(builder)\n+    }\n+}\n+\n+#[rustc_specialization_trait]\n+pub trait SpecIntoSelfProfilingString: Debug {\n+    fn spec_to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+    ) -> StringId;\n+}\n+\n+impl SpecIntoSelfProfilingString for DefId {\n+    fn spec_to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+    ) -> StringId {\n         builder.def_id_to_string_id(*self)\n     }\n }\n \n-impl IntoSelfProfilingString for CrateNum {\n-    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_, '_>) -> StringId {\n+impl SpecIntoSelfProfilingString for CrateNum {\n+    fn spec_to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+    ) -> StringId {\n         builder.def_id_to_string_id(DefId { krate: *self, index: CRATE_DEF_INDEX })\n     }\n }\n \n-impl IntoSelfProfilingString for DefIndex {\n-    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_, '_>) -> StringId {\n+impl SpecIntoSelfProfilingString for DefIndex {\n+    fn spec_to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+    ) -> StringId {\n         builder.def_id_to_string_id(DefId { krate: LOCAL_CRATE, index: *self })\n     }\n }\n \n-impl<T0, T1> IntoSelfProfilingString for (T0, T1)\n+impl<T0, T1> SpecIntoSelfProfilingString for (T0, T1)\n where\n-    T0: IntoSelfProfilingString + Debug,\n-    T1: IntoSelfProfilingString + Debug,\n+    T0: SpecIntoSelfProfilingString,\n+    T1: SpecIntoSelfProfilingString,\n {\n-    default fn to_self_profile_string(\n+    fn spec_to_self_profile_string(\n         &self,\n         builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n     ) -> StringId {"}, {"sha": "b1f76ff6a03bd2ad6a26f526e24c1e005a7fc6fd", "filename": "src/librustc_middle/ty/query/values.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1,4 +1,4 @@\n-use crate::ty::{self, AdtSizedConstraint, Ty, TyCtxt};\n+use crate::ty::{self, AdtSizedConstraint, Ty, TyCtxt, TyS};\n \n use rustc_span::symbol::Symbol;\n \n@@ -13,9 +13,11 @@ impl<'tcx, T> Value<'tcx> for T {\n     }\n }\n \n-impl<'tcx> Value<'tcx> for Ty<'tcx> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        tcx.types.err\n+impl<'tcx> Value<'tcx> for &'_ TyS<'_> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n+        // SAFETY: This is never called when `Self` is not `Ty<'tcx>`.\n+        // FIXME: Represent the above fact in the trait system somehow.\n+        unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.types.err) }\n     }\n }\n \n@@ -25,8 +27,14 @@ impl<'tcx> Value<'tcx> for ty::SymbolName {\n     }\n }\n \n-impl<'tcx> Value<'tcx> for AdtSizedConstraint<'tcx> {\n+impl<'tcx> Value<'tcx> for AdtSizedConstraint<'_> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n-        AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err]))\n+        // SAFETY: This is never called when `Self` is not `AdtSizedConstraint<'tcx>`.\n+        // FIXME: Represent the above fact in the trait system somehow.\n+        unsafe {\n+            std::mem::transmute::<AdtSizedConstraint<'tcx>, AdtSizedConstraint<'_>>(\n+                AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err])),\n+            )\n+        }\n     }\n }"}, {"sha": "fad96aa86cc0afc27eaac0dc629fe0f04ed1f0a9", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -2409,8 +2409,6 @@ impl<'tcx> Const<'tcx> {\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx Const<'tcx> {}\n-\n /// Represents a constant in Rust.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n #[derive(HashStable)]"}, {"sha": "ff284b709c2cfeee5c3170353719f1e9962c26b5", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -705,6 +705,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n+    // FIXME: use `TyCtxtAt` instead of separate `Span`.\n     pub fn is_freeze(\n         &'tcx self,\n         tcx: TyCtxt<'tcx>,\n@@ -878,7 +879,15 @@ impl<'tcx> ty::TyS<'tcx> {\n                     // Find non representable fields with their spans\n                     fold_repr(def.all_fields().map(|field| {\n                         let ty = field.ty(tcx, substs);\n-                        let span = tcx.hir().span_if_local(field.did).unwrap_or(sp);\n+                        let span = match field\n+                            .did\n+                            .as_local()\n+                            .map(|id| tcx.hir().as_local_hir_id(id))\n+                            .and_then(|id| tcx.hir().find(id))\n+                        {\n+                            Some(hir::Node::Field(field)) => field.ty.span,\n+                            _ => sp,\n+                        };\n                         match is_type_structurally_recursive(\n                             tcx,\n                             span,"}, {"sha": "5deae94fe0c8e785086b005f72b626051e1e9d43", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -2,7 +2,7 @@ use std::error::Error;\n use std::fmt;\n \n use rustc_middle::mir::AssertKind;\n-use rustc_span::Symbol;\n+use rustc_span::{Span, Symbol};\n \n use super::InterpCx;\n use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n@@ -53,8 +53,9 @@ impl Error for ConstEvalErrKind {}\n pub fn error_to_const_error<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>(\n     ecx: &InterpCx<'mir, 'tcx, M>,\n     error: InterpErrorInfo<'tcx>,\n+    span: Option<Span>,\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();\n     let stacktrace = ecx.generate_stacktrace();\n-    ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n+    ConstEvalErr { error: error.kind, stacktrace, span: span.unwrap_or_else(|| ecx.cur_span()) }\n }"}, {"sha": "d62300b3f55414b198bfce5da10eede285c61366", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -27,7 +27,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     body: &'mir mir::Body<'tcx>,\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n-    let tcx = ecx.tcx.tcx;\n+    let tcx = *ecx.tcx;\n     let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack);\n@@ -81,13 +81,14 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n pub(super) fn mk_eval_cx<'mir, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    span: Span,\n+    root_span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n     can_access_statics: bool,\n ) -> CompileTimeEvalContext<'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n     InterpCx::new(\n-        tcx.at(span),\n+        tcx,\n+        root_span,\n         param_env,\n         CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics },\n@@ -163,7 +164,7 @@ pub(super) fn op_to_const<'tcx>(\n                         0,\n                     ),\n                 };\n-                let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n+                let len = b.to_machine_usize(ecx).unwrap();\n                 let start = start.try_into().unwrap();\n                 let len: usize = len.try_into().unwrap();\n                 ConstValue::Slice { data, start, end: start + len }\n@@ -212,7 +213,7 @@ fn validate_and_turn_into_const<'tcx>(\n     })();\n \n     val.map_err(|error| {\n-        let err = error_to_const_error(&ecx, error);\n+        let err = error_to_const_error(&ecx, error, None);\n         err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n             diag.note(note_on_undefined_behavior_error());\n             diag.emit();\n@@ -299,9 +300,9 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let is_static = tcx.is_static(def_id);\n \n-    let span = tcx.def_span(cid.instance.def_id());\n     let mut ecx = InterpCx::new(\n-        tcx.at(span),\n+        tcx,\n+        tcx.def_span(cid.instance.def_id()),\n         key.param_env,\n         CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics: is_static },\n@@ -311,12 +312,15 @@ pub fn const_eval_raw_provider<'tcx>(\n     res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body))\n         .map(|place| RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n         .map_err(|error| {\n-            let err = error_to_const_error(&ecx, error);\n+            let err = error_to_const_error(&ecx, error, None);\n             // errors in statics are always emitted as fatal errors\n             if is_static {\n                 // Ensure that if the above error was either `TooGeneric` or `Reported`\n                 // an error must be reported.\n-                let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n+                let v = err.report_as_error(\n+                    ecx.tcx.at(ecx.cur_span()),\n+                    \"could not evaluate static initializer\",\n+                );\n \n                 // If this is `Reveal:All`, then we need to make sure an error is reported but if\n                 // this is `Reveal::UserFacing`, then it's expected that we could get a\n@@ -372,13 +376,16 @@ pub fn const_eval_raw_provider<'tcx>(\n                         // anything else (array lengths, enum initializers, constant patterns) are\n                         // reported as hard errors\n                         } else {\n-                            err.report_as_error(ecx.tcx, \"evaluation of constant value failed\")\n+                            err.report_as_error(\n+                                ecx.tcx.at(ecx.cur_span()),\n+                                \"evaluation of constant value failed\",\n+                            )\n                         }\n                     }\n                 }\n             } else {\n                 // use of broken constant from other crate\n-                err.report_as_error(ecx.tcx, \"could not evaluate constant\")\n+                err.report_as_error(ecx.tcx.at(ecx.cur_span()), \"could not evaluate constant\")\n             }\n         })\n }"}, {"sha": "cfe856abe36dda2ca6c6c073417d1c864c711138", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -268,11 +268,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n                 let ptr = self.read_immediate(src)?.to_scalar()?;\n                 // u64 cast is from usize to u64, which is always good\n-                let val = Immediate::new_slice(\n-                    ptr,\n-                    length.eval_usize(self.tcx.tcx, self.param_env),\n-                    self,\n-                );\n+                let val =\n+                    Immediate::new_slice(ptr, length.eval_usize(*self.tcx, self.param_env), self);\n                 self.write_immediate(val, dest)\n             }\n             (&ty::Dynamic(..), &ty::Dynamic(..)) => {"}, {"sha": "22f4691c22b3de81226fe406c8fafd6c427c04bd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -33,6 +33,8 @@ pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n+    /// The span in this is the \"root\" of the evaluation, i.e., the const\n+    /// we are evaluating (if this is CTFE).\n     pub tcx: TyCtxtAt<'tcx>,\n \n     /// Bounds in scope for polymorphic evaluations.\n@@ -202,7 +204,7 @@ where\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = InterpResult<'tcx, TyAndLayout<'tcx>>;\n \n@@ -285,24 +287,28 @@ pub(super) fn from_known_layout<'tcx>(\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn new(\n-        tcx: TyCtxtAt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+        root_span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n         memory_extra: M::MemoryExtra,\n     ) -> Self {\n         InterpCx {\n             machine,\n-            tcx,\n+            tcx: tcx.at(root_span),\n             param_env,\n             memory: Memory::new(tcx, memory_extra),\n             vtables: FxHashMap::default(),\n         }\n     }\n \n     #[inline(always)]\n-    pub fn set_span(&mut self, span: Span) {\n-        self.tcx.span = span;\n-        self.memory.tcx.span = span;\n+    pub fn cur_span(&self) -> Span {\n+        self.stack()\n+            .last()\n+            .and_then(|f| f.current_source_info())\n+            .map(|si| si.span)\n+            .unwrap_or(self.tcx.span)\n     }\n \n     #[inline(always)]\n@@ -385,7 +391,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n+        ty.is_freeze(*self.tcx, self.param_env, self.tcx.span)\n     }\n \n     pub fn load_mir(\n@@ -554,7 +560,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let size = size.align_to(align);\n \n                 // Check if this brought us over the size limit.\n-                if size.bytes() >= self.tcx.data_layout().obj_size_bound() {\n+                if size.bytes() >= self.tcx.data_layout.obj_size_bound() {\n                     throw_ub!(InvalidMeta(\"total size is bigger than largest supported object\"));\n                 }\n                 Ok(Some((size, align)))\n@@ -570,7 +576,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let elem = layout.field(self, 0)?;\n \n                 // Make sure the slice is not too big.\n-                let size = elem.size.checked_mul(len, &*self.tcx).ok_or_else(|| {\n+                let size = elem.size.checked_mul(len, self).ok_or_else(|| {\n                     err_ub!(InvalidMeta(\"slice is bigger than largest supported object\"))\n                 })?;\n                 Ok(Some((size, elem.align.abi)))"}, {"sha": "3c724c79b4082448860d9fc256c272537a8342e6", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -111,7 +111,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     if let InternMode::Static(mutability) = mode {\n         // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n         // no interior mutability.\n-        let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx.tcx, ecx.param_env, ecx.tcx.span));\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(*ecx.tcx, ecx.param_env, ecx.tcx.span));\n         // For statics, allocation mutability is the combination of the place mutability and\n         // the type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n@@ -253,8 +253,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                         // caused (by somehow getting a mutable reference in a `const`).\n                         if ref_mutability == Mutability::Mut {\n                             match referenced_ty.kind {\n-                                ty::Array(_, n)\n-                                    if n.eval_usize(tcx.tcx, self.ecx.param_env) == 0 => {}\n+                                ty::Array(_, n) if n.eval_usize(*tcx, self.ecx.param_env) == 0 => {}\n                                 ty::Slice(_)\n                                     if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?\n                                         == 0 => {}"}, {"sha": "47e5b8b4fcec453a7be7951569878d52c76fa863", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -347,7 +347,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n                 let elem = args[2];\n                 let input = args[0];\n-                let (len, e_ty) = input.layout.ty.simd_size_and_type(self.tcx.tcx);\n+                let (len, e_ty) = input.layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n                     \"Index `{}` must be in bounds of vector type `{}`: `[0, {})`\",\n@@ -374,7 +374,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             sym::simd_extract => {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n-                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(self.tcx.tcx);\n+                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n                     \"index `{}` is out-of-bounds of vector type `{}` with length `{}`\","}, {"sha": "8af1a8ac608ac8f2a56f4bb61d0c4d455a2a037b", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -14,7 +14,7 @@ use std::ptr;\n \n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_middle::ty::{self, query::TyCtxtAt, Instance, ParamEnv};\n+use rustc_middle::ty::{self, Instance, ParamEnv, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n@@ -115,7 +115,7 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub extra: M::MemoryExtra,\n \n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n-    pub tcx: TyCtxtAt<'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n@@ -126,7 +126,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M>\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxtAt<'tcx>, extra: M::MemoryExtra) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, extra: M::MemoryExtra) -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n             extra_fn_ptr_map: FxHashMap::default(),\n@@ -425,7 +425,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// `M::tag_allocation`.\n     fn get_global_alloc(\n         memory_extra: &M::MemoryExtra,\n-        tcx: TyCtxtAt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n@@ -455,7 +455,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     throw_unsup!(ReadForeignStatic(def_id))\n                 }\n                 trace!(\"get_global_alloc: Need to compute {:?}\", def_id);\n-                let instance = Instance::mono(tcx.tcx, def_id);\n+                let instance = Instance::mono(tcx, def_id);\n                 let gid = GlobalId { instance, promoted: None };\n                 // Use the raw query here to break validation cycles. Later uses of the static\n                 // will call the full query anyway.\n@@ -664,14 +664,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n         // Cannot be a closure because it is generic in `Tag`, `Extra`.\n         fn write_allocation_track_relocs<'tcx, Tag: Copy + fmt::Debug, Extra>(\n-            tcx: TyCtxtAt<'tcx>,\n+            tcx: TyCtxt<'tcx>,\n             allocs_to_print: &mut VecDeque<AllocId>,\n             alloc: &Allocation<Tag, Extra>,\n         ) {\n             for &(_, target_id) in alloc.relocations().values() {\n                 allocs_to_print.push_back(target_id);\n             }\n-            pretty::write_allocation(tcx.tcx, alloc, &mut std::io::stderr()).unwrap();\n+            pretty::write_allocation(tcx, alloc, &mut std::io::stderr()).unwrap();\n         }\n \n         allocs.sort();\n@@ -820,7 +820,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 return Ok(());\n             }\n         };\n-        let tcx = self.tcx.tcx;\n+        let tcx = self.tcx;\n         self.get_raw_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n     }\n \n@@ -846,7 +846,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 return Ok(());\n             }\n         };\n-        let tcx = self.tcx.tcx;\n+        let tcx = self.tcx;\n         let allocation = self.get_raw_mut(ptr.alloc_id)?;\n \n         for idx in 0..len {\n@@ -888,7 +888,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let relocations =\n             self.get_raw(src.alloc_id)?.prepare_relocation_copy(self, src, size, dest, length);\n \n-        let tcx = self.tcx.tcx;\n+        let tcx = self.tcx;\n \n         // This checks relocation edges on the src.\n         let src_bytes ="}, {"sha": "38f5988d0eb3fd82eb27768994647d9c219f1d72", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -651,12 +651,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Convert discriminant to variant index, and catch invalid discriminants.\n                 let index = match op.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n-                        adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == discr_bits)\n+                        adt.discriminants(*self.tcx).find(|(_, var)| var.val == discr_bits)\n                     }\n                     ty::Generator(def_id, substs, _) => {\n                         let substs = substs.as_generator();\n                         substs\n-                            .discriminants(def_id, self.tcx.tcx)\n+                            .discriminants(def_id, *self.tcx)\n                             .find(|(_, var)| var.val == discr_bits)\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),"}, {"sha": "24b191e9b535ab6c2daf9f56db6813b69186dc5b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -404,7 +404,10 @@ where\n                     // to get some code to work that probably ought to work.\n                     field_layout.align.abi\n                 }\n-                None => bug!(\"Cannot compute offset for extern type field at non-0 offset\"),\n+                None => span_bug!(\n+                    self.cur_span(),\n+                    \"cannot compute offset for extern type field at non-0 offset\"\n+                ),\n             };\n             (base.meta, offset.align_to(align))\n         } else {\n@@ -440,7 +443,11 @@ where\n                 assert!(!field_layout.is_unsized());\n                 base.offset(offset, MemPlaceMeta::None, field_layout, self)\n             }\n-            _ => bug!(\"`mplace_index` called on non-array type {:?}\", base.layout.ty),\n+            _ => span_bug!(\n+                self.cur_span(),\n+                \"`mplace_index` called on non-array type {:?}\",\n+                base.layout.ty\n+            ),\n         }\n     }\n \n@@ -454,7 +461,7 @@ where\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n             FieldsShape::Array { stride, .. } => stride,\n-            _ => bug!(\"mplace_array_fields: expected an array layout\"),\n+            _ => span_bug!(self.cur_span(), \"mplace_array_fields: expected an array layout\"),\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n@@ -484,7 +491,9 @@ where\n         // (that have count 0 in their layout).\n         let from_offset = match base.layout.fields {\n             FieldsShape::Array { stride, .. } => stride * from, // `Size` multiplication is checked\n-            _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n+            _ => {\n+                span_bug!(self.cur_span(), \"unexpected layout of index access: {:#?}\", base.layout)\n+            }\n         };\n \n         // Compute meta and new layout\n@@ -497,7 +506,9 @@ where\n                 let len = Scalar::from_machine_usize(inner_len, self);\n                 (MemPlaceMeta::Meta(len), base.layout.ty)\n             }\n-            _ => bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n+            _ => {\n+                span_bug!(self.cur_span(), \"cannot subslice non-array type: `{:?}`\", base.layout.ty)\n+            }\n         };\n         let layout = self.layout_of(ty)?;\n         base.offset(from_offset, meta, layout, self)\n@@ -768,20 +779,22 @@ where\n             None => return Ok(()), // zero-sized access\n         };\n \n-        let tcx = &*self.tcx;\n+        let tcx = *self.tcx;\n         // FIXME: We should check that there are dest.layout.size many bytes available in\n         // memory.  The code below is not sufficient, with enough padding it might not\n         // cover all the bytes!\n         match value {\n             Immediate::Scalar(scalar) => {\n                 match dest.layout.abi {\n                     Abi::Scalar(_) => {} // fine\n-                    _ => {\n-                        bug!(\"write_immediate_to_mplace: invalid Scalar layout: {:#?}\", dest.layout)\n-                    }\n+                    _ => span_bug!(\n+                        self.cur_span(),\n+                        \"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n+                        dest.layout\n+                    ),\n                 }\n                 self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(\n-                    tcx,\n+                    &tcx,\n                     ptr,\n                     scalar,\n                     dest.layout.size,\n@@ -793,7 +806,8 @@ where\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n                 let (a, b) = match dest.layout.abi {\n                     Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\n+                    _ => span_bug!(\n+                        self.cur_span(),\n                         \"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n                         dest.layout\n                     ),\n@@ -806,8 +820,8 @@ where\n                 // but that does not work: We could be a newtype around a pair, then the\n                 // fields do not match the `ScalarPair` components.\n \n-                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(tcx, ptr, a_val, a_size)?;\n-                self.memory.get_raw_mut(b_ptr.alloc_id)?.write_scalar(tcx, b_ptr, b_val, b_size)\n+                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(&tcx, ptr, a_val, a_size)?;\n+                self.memory.get_raw_mut(b_ptr.alloc_id)?.write_scalar(&tcx, b_ptr, b_val, b_size)\n             }\n         }\n     }\n@@ -841,9 +855,9 @@ where\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n-        if !mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout) {\n+        if !mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n             span_bug!(\n-                self.tcx.span,\n+                self.cur_span(),\n                 \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n                 src.layout.ty,\n                 dest.layout.ty,\n@@ -898,7 +912,7 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout) {\n+        if mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }\n@@ -910,7 +924,7 @@ where\n             // on `typeck_tables().has_errors` at all const eval entry points.\n             debug!(\"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n             self.tcx.sess.delay_span_bug(\n-                self.tcx.span,\n+                self.cur_span(),\n                 \"size-changing transmute, should have been caught by transmute checking\",\n             );\n             throw_inval!(TransmuteSizeDiff(src.layout.ty, dest.layout.ty));"}, {"sha": "16c6396799e634eedbb067b7409966875ccb2208", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -76,7 +76,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", stmt);\n-        self.set_span(stmt.source_info.span);\n \n         use rustc_middle::mir::StatementKind::*;\n \n@@ -279,7 +278,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", terminator.kind);\n-        self.set_span(terminator.source_info.span);\n \n         self.eval_terminator(terminator)?;\n         if !self.stack().is_empty() {"}, {"sha": "a1d124bb7602ebb1408107d5840e90e073e56fbb", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -2,7 +2,7 @@ use std::convert::TryFrom;\n \n use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n-use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size};\n+use rustc_target::abi::{Align, LayoutOf, Size};\n \n use super::{FnVal, InterpCx, Machine, MemoryKind};\n \n@@ -49,8 +49,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let size = layout.size.bytes();\n         let align = layout.align.abi.bytes();\n \n+        let tcx = *self.tcx;\n         let ptr_size = self.pointer_size();\n-        let ptr_align = self.tcx.data_layout.pointer_align.abi;\n+        let ptr_align = tcx.data_layout.pointer_align.abi;\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         // If you touch this code, be sure to also make the corresponding changes to\n         // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n@@ -60,33 +61,32 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ptr_align,\n             MemoryKind::Vtable,\n         );\n-        let tcx = &*self.tcx;\n \n-        let drop = Instance::resolve_drop_in_place(*tcx, ty);\n+        let drop = Instance::resolve_drop_in_place(tcx, ty);\n         let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n \n         // No need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n         // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n         let vtable_alloc = self.memory.get_raw_mut(vtable.alloc_id)?;\n-        vtable_alloc.write_ptr_sized(tcx, vtable, drop.into())?;\n+        vtable_alloc.write_ptr_sized(&tcx, vtable, drop.into())?;\n \n-        let size_ptr = vtable.offset(ptr_size, tcx)?;\n-        vtable_alloc.write_ptr_sized(tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n-        let align_ptr = vtable.offset(ptr_size * 2, tcx)?;\n-        vtable_alloc.write_ptr_sized(tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n+        let size_ptr = vtable.offset(ptr_size, &tcx)?;\n+        vtable_alloc.write_ptr_sized(&tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n+        let align_ptr = vtable.offset(ptr_size * 2, &tcx)?;\n+        vtable_alloc.write_ptr_sized(&tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 // resolve for vtable: insert shims where needed\n                 let instance =\n-                    ty::Instance::resolve_for_vtable(*tcx, self.param_env, def_id, substs)\n+                    ty::Instance::resolve_for_vtable(tcx, self.param_env, def_id, substs)\n                         .ok_or_else(|| err_inval!(TooGeneric))?;\n                 let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                 // We cannot use `vtable_allic` as we are creating fn ptrs in this loop.\n-                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), tcx)?;\n+                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &tcx)?;\n                 self.memory.get_raw_mut(vtable.alloc_id)?.write_ptr_sized(\n-                    tcx,\n+                    &tcx,\n                     method_ptr,\n                     fn_ptr.into(),\n                 )?;\n@@ -171,7 +171,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.not_undef()?;\n         let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n \n-        if size >= self.tcx.data_layout().obj_size_bound() {\n+        if size >= self.tcx.data_layout.obj_size_bound() {\n             throw_ub_format!(\n                 \"invalid vtable: \\\n                 size is bigger than largest supported object\""}, {"sha": "83ed2fc2d439bf8a838a57ed1c58b33f9a48f37e", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -313,7 +313,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id).with_reveal_all();\n \n         let span = tcx.def_span(def_id);\n-        let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine::new(), ());\n+        let mut ecx = InterpCx::new(tcx, span, param_env, ConstPropMachine::new(), ());\n         let can_const_prop = CanConstProp::check(body);\n \n         let ret = ecx\n@@ -404,9 +404,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         match self.ecx.eval_const_to_op(c.literal, None) {\n             Ok(op) => Some(op),\n             Err(error) => {\n-                // Make sure errors point at the constant.\n-                self.ecx.set_span(c.span);\n-                let err = error_to_const_error(&self.ecx, error);\n+                let tcx = self.ecx.tcx.at(c.span);\n+                let err = error_to_const_error(&self.ecx, error, Some(c.span));\n                 if let Some(lint_root) = self.lint_root(source_info) {\n                     let lint_only = match c.literal.val {\n                         // Promoteds must lint and not error as the user didn't ask for them\n@@ -418,17 +417,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     if lint_only {\n                         // Out of backwards compatibility we cannot report hard errors in unused\n                         // generic functions using associated constants of the generic parameters.\n-                        err.report_as_lint(\n-                            self.ecx.tcx,\n-                            \"erroneous constant used\",\n-                            lint_root,\n-                            Some(c.span),\n-                        );\n+                        err.report_as_lint(tcx, \"erroneous constant used\", lint_root, Some(c.span));\n                     } else {\n-                        err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                        err.report_as_error(tcx, \"erroneous constant used\");\n                     }\n                 } else {\n-                    err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                    err.report_as_error(tcx, \"erroneous constant used\");\n                 }\n                 None\n             }\n@@ -852,7 +846,6 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n     fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n-        self.ecx.set_span(source_info.span);\n         self.source_info = Some(source_info);\n         if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n             let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n@@ -865,7 +858,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                         if let Some(value) = self.get_const(place) {\n                             if self.should_const_prop(value) {\n                                 trace!(\"replacing {:?} with {:?}\", rval, value);\n-                                self.replace_with_const(rval, value, statement.source_info);\n+                                self.replace_with_const(rval, value, source_info);\n                                 if can_const_prop == ConstPropMode::FullConstProp\n                                     || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n                                 {\n@@ -928,7 +921,6 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n \n     fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n         let source_info = terminator.source_info;\n-        self.ecx.set_span(source_info.span);\n         self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n         match &mut terminator.kind {"}, {"sha": "002b0f9c165dde4f3a967699dc1d72a659dc4773", "filename": "src/librustc_query_system/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -91,7 +91,7 @@ impl<K: DepKind> fmt::Debug for DepNode<K> {\n }\n \n pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool;\n+    fn can_reconstruct_query_key() -> bool;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n     /// Fingerprint to be used in DepNode.\n@@ -108,7 +108,7 @@ pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n     /// This method tries to recover the query key from the given `DepNode`,\n     /// something which is needed when forcing `DepNode`s during red-green\n     /// evaluation. The query system will only call this method if\n-    /// `CAN_RECONSTRUCT_QUERY_KEY` is `true`.\n+    /// `can_reconstruct_query_key()` is `true`.\n     /// It is always valid to return `None` here, in which case incremental\n     /// compilation will treat the query as having changed instead of forcing it.\n     fn recover(tcx: Ctxt, dep_node: &DepNode<Ctxt::DepKind>) -> Option<Self>;\n@@ -118,7 +118,10 @@ impl<Ctxt: DepContext, T> DepNodeParams<Ctxt> for T\n where\n     T: HashStable<Ctxt::StableHashingContext> + fmt::Debug,\n {\n-    default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+    #[inline]\n+    default fn can_reconstruct_query_key() -> bool {\n+        false\n+    }\n \n     default fn to_fingerprint(&self, tcx: Ctxt) -> Fingerprint {\n         let mut hcx = tcx.create_stable_hashing_context();"}, {"sha": "12450a4ccd3ebc3937871f5b8cb3527644ece231", "filename": "src/librustc_query_system/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -4,7 +4,7 @@\n #![feature(const_panic)]\n #![feature(core_intrinsics)]\n #![feature(hash_raw_entry)]\n-#![feature(specialization)] // FIXME: min_specialization rejects `default const`\n+#![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n #![feature(vec_remove_item)]\n "}, {"sha": "3dc3e783820963e4e0dc417c8c44380f92ab0b7a", "filename": "src/librustc_serialize/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_serialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_serialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Flib.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -10,7 +10,7 @@ Core encoding and decoding interfaces.\n     test(attr(allow(unused_variables), deny(warnings)))\n )]\n #![feature(box_syntax)]\n-#![feature(specialization)] // FIXME: min_specialization does not work\n+#![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(associated_type_bounds)]"}, {"sha": "29c5737ad895abc8b834394fcb6f328ddefb1ee4", "filename": "src/librustc_serialize/serialize.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_serialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_serialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fserialize.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -635,24 +635,6 @@ impl<T> Decodable for PhantomData<T> {\n     }\n }\n \n-impl<'a, T: ?Sized + Encodable> Encodable for &'a T {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<T: ?Sized + Encodable> Encodable for Box<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<T: Decodable> Decodable for Box<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Box<T>, D::Error> {\n-        Ok(box Decodable::decode(d)?)\n-    }\n-}\n-\n impl<T: Decodable> Decodable for Box<[T]> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Box<[T]>, D::Error> {\n         let v: Vec<T> = Decodable::decode(d)?;\n@@ -1008,8 +990,20 @@ impl<T: UseSpecializedDecodable> Decodable for T {\n // for this exact reason.\n // May be fixable in a simpler fashion via the\n // more complex lattice model for specialization.\n-impl<'a, T: ?Sized + Encodable> UseSpecializedEncodable for &'a T {}\n-impl<T: ?Sized + Encodable> UseSpecializedEncodable for Box<T> {}\n-impl<T: Decodable> UseSpecializedDecodable for Box<T> {}\n+impl<'a, T: ?Sized + Encodable> UseSpecializedEncodable for &'a T {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+impl<T: ?Sized + Encodable> UseSpecializedEncodable for Box<T> {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+impl<T: Decodable> UseSpecializedDecodable for Box<T> {\n+    fn default_decode<D: Decoder>(d: &mut D) -> Result<Box<T>, D::Error> {\n+        Ok(box Decodable::decode(d)?)\n+    }\n+}\n impl<'a, T: Decodable> UseSpecializedDecodable for &'a T {}\n impl<'a, T: Decodable> UseSpecializedDecodable for &'a [T] {}"}, {"sha": "1447716ca84841834fa80c41e71a6ac8af7fdd81", "filename": "src/librustc_target/spec/aarch64_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> TargetResult {\n         target_vendor: \"apple\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions {\n-            features: \"+neon,+fp-armv8,+cyclone\".to_string(),\n+            features: \"+neon,+fp-armv8,+apple-a7\".to_string(),\n             eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             abi_blacklist: super::arm_base::abi_blacklist(),"}, {"sha": "21f660ac8b8391da35d9492fcbb7206a4cb0142d", "filename": "src/librustc_target/spec/aarch64_apple_tvos.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> TargetResult {\n         target_vendor: \"apple\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions {\n-            features: \"+neon,+fp-armv8,+cyclone\".to_string(),\n+            features: \"+neon,+fp-armv8,+apple-a7\".to_string(),\n             eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             abi_blacklist: super::arm_base::abi_blacklist(),"}, {"sha": "b07c2aef1caca004bbc07a3844652ad43157070f", "filename": "src/librustc_target/spec/apple_sdk_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -122,7 +122,7 @@ fn target_cpu(arch: Arch) -> String {\n     match arch {\n         Armv7 => \"cortex-a8\", // iOS7 is supported on iPhone 4 and higher\n         Armv7s => \"cortex-a9\",\n-        Arm64 => \"cyclone\",\n+        Arm64 => \"apple-a7\",\n         I386 => \"yonah\",\n         X86_64 => \"core2\",\n         X86_64_macabi => \"core2\","}, {"sha": "f244785b49d2fdf3dd5e4050543217b5549171e5", "filename": "src/librustc_trait_selection/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_trait_selection%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_trait_selection%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Finfer.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -90,7 +90,7 @@ pub trait InferCtxtBuilderExt<'tcx> {\n     where\n         K: TypeFoldable<'tcx>,\n         R: Debug + TypeFoldable<'tcx>,\n-        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable;\n+        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable<'tcx>;\n }\n \n impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n@@ -118,7 +118,7 @@ impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n     where\n         K: TypeFoldable<'tcx>,\n         R: Debug + TypeFoldable<'tcx>,\n-        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable,\n+        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable<'tcx>,\n     {\n         self.enter_with_canonical(\n             DUMMY_SP,"}, {"sha": "ea886cd1f9e9b38c394184ed4f0eb0bbc9279bc9", "filename": "src/librustc_trait_selection/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_trait_selection%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_trait_selection%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Flib.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -16,7 +16,6 @@\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]\n #![feature(or_patterns)]\n-#![feature(option_zip)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "d31e04cffd55f57cbb03e39c75268960b50f5b95", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1747,24 +1747,41 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n pub fn recursive_type_with_infinite_size_error(\n     tcx: TyCtxt<'tcx>,\n     type_def_id: DefId,\n-) -> DiagnosticBuilder<'tcx> {\n+    spans: Vec<Span>,\n+) {\n     assert!(type_def_id.is_local());\n     let span = tcx.hir().span_if_local(type_def_id).unwrap();\n     let span = tcx.sess.source_map().guess_head_span(span);\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0072,\n-        \"recursive type `{}` has infinite size\",\n-        tcx.def_path_str(type_def_id)\n-    );\n+    let path = tcx.def_path_str(type_def_id);\n+    let mut err =\n+        struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\", path);\n     err.span_label(span, \"recursive type has infinite size\");\n-    err.help(&format!(\n-        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n-                           at some point to make `{}` representable\",\n-        tcx.def_path_str(type_def_id)\n-    ));\n-    err\n+    for &span in &spans {\n+        err.span_label(span, \"recursive without indirection\");\n+    }\n+    let msg = format!(\n+        \"insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `{}` representable\",\n+        path,\n+    );\n+    if spans.len() <= 4 {\n+        err.multipart_suggestion(\n+            &msg,\n+            spans\n+                .iter()\n+                .flat_map(|&span| {\n+                    vec![\n+                        (span.shrink_to_lo(), \"Box<\".to_string()),\n+                        (span.shrink_to_hi(), \">\".to_string()),\n+                    ]\n+                    .into_iter()\n+                })\n+                .collect(),\n+            Applicability::HasPlaceholders,\n+        );\n+    } else {\n+        err.help(&msg);\n+    }\n+    err.emit();\n }\n \n /// Summarizes information"}, {"sha": "a409e20953da144c53067fdcfcf3c9631ffde9d9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -2387,11 +2387,7 @@ fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalDefId) -> bo\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive(spans) => {\n-            let mut err = recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id());\n-            for span in spans {\n-                err.span_label(span, \"recursive without indirection\");\n-            }\n-            err.emit();\n+            recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id(), spans);\n             return false;\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),"}, {"sha": "83029a8642097e107b7223322e99ff838e9469b7", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -41,7 +41,7 @@ dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n [target.'cfg(all(any(target_arch = \"x86_64\", target_arch = \"aarch64\"), target_os = \"hermit\"))'.dependencies]\n-hermit-abi = { version = \"0.1.13\", features = ['rustc-dep-of-std'] }\n+hermit-abi = { version = \"0.1.14\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.9.0\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "dca1fdde4824295f72cd1539d5fa124ca96b3d9e", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 181, "deletions": 6, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -234,15 +234,14 @@ pub struct NulError(usize, Vec<u8>);\n \n /// An error indicating that a nul byte was not in the expected position.\n ///\n-/// The slice used to create a [`CStr`] must have one and only one nul\n-/// byte at the end of the slice.\n+/// The slice used to create a [`CStr`] must have one and only one nul byte,\n+/// positioned at the end.\n ///\n-/// This error is created by the\n-/// [`from_bytes_with_nul`][`CStr::from_bytes_with_nul`] method on\n-/// [`CStr`]. See its documentation for more.\n+/// This error is created by the [`from_bytes_with_nul`] method on [`CStr`].\n+/// See its documentation for more.\n ///\n /// [`CStr`]: struct.CStr.html\n-/// [`CStr::from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n+/// [`from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n ///\n /// # Examples\n ///\n@@ -257,6 +256,32 @@ pub struct FromBytesWithNulError {\n     kind: FromBytesWithNulErrorKind,\n }\n \n+/// An error indicating that a nul byte was not in the expected position.\n+///\n+/// The vector used to create a [`CString`] must have one and only one nul byte,\n+/// positioned at the end.\n+///\n+/// This error is created by the [`from_vec_with_nul`] method on [`CString`].\n+/// See its documentation for more.\n+///\n+/// [`CString`]: struct.CString.html\n+/// [`from_vec_with_nul`]: struct.CString.html#method.from_vec_with_nul\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(cstring_from_vec_with_nul)]\n+/// use std::ffi::{CString, FromVecWithNulError};\n+///\n+/// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"f\\0oo\".to_vec()).unwrap_err();\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+pub struct FromVecWithNulError {\n+    error_kind: FromBytesWithNulErrorKind,\n+    bytes: Vec<u8>,\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n enum FromBytesWithNulErrorKind {\n     InteriorNul(usize),\n@@ -272,6 +297,59 @@ impl FromBytesWithNulError {\n     }\n }\n \n+#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+impl FromVecWithNulError {\n+    /// Returns a slice of [`u8`]s bytes that were attempted to convert to a [`CString`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(cstring_from_vec_with_nul)]\n+    /// use std::ffi::CString;\n+    ///\n+    /// // Some invalid bytes in a vector\n+    /// let bytes = b\"f\\0oo\".to_vec();\n+    ///\n+    /// let value = CString::from_vec_with_nul(bytes.clone());\n+    ///\n+    /// assert_eq!(&bytes[..], value.unwrap_err().as_bytes());\n+    /// ```\n+    ///\n+    /// [`CString`]: struct.CString.html\n+    pub fn as_bytes(&self) -> &[u8] {\n+        &self.bytes[..]\n+    }\n+\n+    /// Returns the bytes that were attempted to convert to a [`CString`].\n+    ///\n+    /// This method is carefully constructed to avoid allocation. It will\n+    /// consume the error, moving out the bytes, so that a copy of the bytes\n+    /// does not need to be made.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(cstring_from_vec_with_nul)]\n+    /// use std::ffi::CString;\n+    ///\n+    /// // Some invalid bytes in a vector\n+    /// let bytes = b\"f\\0oo\".to_vec();\n+    ///\n+    /// let value = CString::from_vec_with_nul(bytes.clone());\n+    ///\n+    /// assert_eq!(bytes, value.unwrap_err().into_bytes());\n+    /// ```\n+    ///\n+    /// [`CString`]: struct.CString.html\n+    pub fn into_bytes(self) -> Vec<u8> {\n+        self.bytes\n+    }\n+}\n+\n /// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n ///\n /// `CString` is just a wrapper over a buffer of bytes with a nul\n@@ -643,6 +721,86 @@ impl CString {\n         let this = mem::ManuallyDrop::new(self);\n         unsafe { ptr::read(&this.inner) }\n     }\n+\n+    /// Converts a `Vec` of `u8` to a `CString` without checking the invariants\n+    /// on the given `Vec`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The given `Vec` **must** have one nul byte as its last element.\n+    /// This means it cannot be empty nor have any other nul byte anywhere else.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(cstring_from_vec_with_nul)]\n+    /// use std::ffi::CString;\n+    /// assert_eq!(\n+    ///     unsafe { CString::from_vec_with_nul_unchecked(b\"abc\\0\".to_vec()) },\n+    ///     unsafe { CString::from_vec_unchecked(b\"abc\".to_vec()) }\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+    pub unsafe fn from_vec_with_nul_unchecked(v: Vec<u8>) -> Self {\n+        Self { inner: v.into_boxed_slice() }\n+    }\n+\n+    /// Attempts to converts a `Vec` of `u8` to a `CString`.\n+    ///\n+    /// Runtime checks are present to ensure there is only one nul byte in the\n+    /// `Vec`, its last element.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If a nul byte is present and not the last element or no nul bytes\n+    /// is present, an error will be returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A successful conversion will produce the same result as [`new`] when\n+    /// called without the ending nul byte.\n+    ///\n+    /// ```\n+    /// #![feature(cstring_from_vec_with_nul)]\n+    /// use std::ffi::CString;\n+    /// assert_eq!(\n+    ///     CString::from_vec_with_nul(b\"abc\\0\".to_vec())\n+    ///         .expect(\"CString::from_vec_with_nul failed\"),\n+    ///     CString::new(b\"abc\".to_vec()).expect(\"CString::new failed\")\n+    /// );\n+    /// ```\n+    ///\n+    /// A incorrectly formatted vector will produce an error.\n+    ///\n+    /// ```\n+    /// #![feature(cstring_from_vec_with_nul)]\n+    /// use std::ffi::{CString, FromVecWithNulError};\n+    /// // Interior nul byte\n+    /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"a\\0bc\".to_vec()).unwrap_err();\n+    /// // No nul byte\n+    /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"abc\".to_vec()).unwrap_err();\n+    /// ```\n+    ///\n+    /// [`new`]: #method.new\n+    #[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+    pub fn from_vec_with_nul(v: Vec<u8>) -> Result<Self, FromVecWithNulError> {\n+        let nul_pos = memchr::memchr(0, &v);\n+        match nul_pos {\n+            Some(nul_pos) if nul_pos + 1 == v.len() => {\n+                // SAFETY: We know there is only one nul byte, at the end\n+                // of the vec.\n+                Ok(unsafe { Self::from_vec_with_nul_unchecked(v) })\n+            }\n+            Some(nul_pos) => Err(FromVecWithNulError {\n+                error_kind: FromBytesWithNulErrorKind::InteriorNul(nul_pos),\n+                bytes: v,\n+            }),\n+            None => Err(FromVecWithNulError {\n+                error_kind: FromBytesWithNulErrorKind::NotNulTerminated,\n+                bytes: v,\n+            }),\n+        }\n+    }\n }\n \n // Turns this `CString` into an empty string to prevent\n@@ -976,6 +1134,23 @@ impl fmt::Display for FromBytesWithNulError {\n     }\n }\n \n+#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+impl Error for FromVecWithNulError {}\n+\n+#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+impl fmt::Display for FromVecWithNulError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.error_kind {\n+            FromBytesWithNulErrorKind::InteriorNul(pos) => {\n+                write!(f, \"data provided contains an interior nul byte at pos {}\", pos)\n+            }\n+            FromBytesWithNulErrorKind::NotNulTerminated => {\n+                write!(f, \"data provided is not nul terminated\")\n+            }\n+        }\n+    }\n+}\n+\n impl IntoStringError {\n     /// Consumes this error, returning original [`CString`] which generated the\n     /// error."}, {"sha": "f442d7fde1a5e9464fe0e6116e2dc204930cce39", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -157,6 +157,8 @@\n \n #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n pub use self::c_str::FromBytesWithNulError;\n+#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+pub use self::c_str::FromVecWithNulError;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::c_str::{CStr, CString, IntoStringError, NulError};\n "}, {"sha": "b8fa1a7f744d3ca432d5338cb80ad31bf77569ce", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 5, "deletions": 40, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -694,42 +694,6 @@ impl PartialEq for SocketAddrV6 {\n             && self.inner.sin6_scope_id == other.inner.sin6_scope_id\n     }\n }\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialEq<SocketAddrV4> for SocketAddr {\n-    fn eq(&self, other: &SocketAddrV4) -> bool {\n-        match self {\n-            SocketAddr::V4(v4) => v4 == other,\n-            SocketAddr::V6(_) => false,\n-        }\n-    }\n-}\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialEq<SocketAddrV6> for SocketAddr {\n-    fn eq(&self, other: &SocketAddrV6) -> bool {\n-        match self {\n-            SocketAddr::V4(_) => false,\n-            SocketAddr::V6(v6) => v6 == other,\n-        }\n-    }\n-}\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialEq<SocketAddr> for SocketAddrV4 {\n-    fn eq(&self, other: &SocketAddr) -> bool {\n-        match other {\n-            SocketAddr::V4(v4) => self == v4,\n-            SocketAddr::V6(_) => false,\n-        }\n-    }\n-}\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialEq<SocketAddr> for SocketAddrV6 {\n-    fn eq(&self, other: &SocketAddr) -> bool {\n-        match other {\n-            SocketAddr::V4(_) => false,\n-            SocketAddr::V6(v6) => self == v6,\n-        }\n-    }\n-}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Eq for SocketAddrV4 {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1242,12 +1206,8 @@ mod tests {\n         // equality\n         assert_eq!(v4_1, v4_1);\n         assert_eq!(v6_1, v6_1);\n-        assert_eq!(v4_1, SocketAddr::V4(v4_1));\n-        assert_eq!(v6_1, SocketAddr::V6(v6_1));\n         assert_eq!(SocketAddr::V4(v4_1), SocketAddr::V4(v4_1));\n         assert_eq!(SocketAddr::V6(v6_1), SocketAddr::V6(v6_1));\n-        assert!(v4_1 != SocketAddr::V6(v6_1));\n-        assert!(v6_1 != SocketAddr::V4(v4_1));\n         assert!(v4_1 != v4_2);\n         assert!(v6_1 != v6_2);\n \n@@ -1268,5 +1228,10 @@ mod tests {\n         assert!(v6_1 < v6_3);\n         assert!(v4_3 > v4_1);\n         assert!(v6_3 > v6_1);\n+\n+        // compare with an inferred right-hand side\n+        assert_eq!(v4_1, \"224.120.45.1:23456\".parse().unwrap());\n+        assert_eq!(v6_1, \"[2001:db8:f00::1002]:23456\".parse().unwrap());\n+        assert_eq!(SocketAddr::V4(v4_1), \"224.120.45.1:23456\".parse().unwrap());\n     }\n }"}, {"sha": "8478457eabfc2e8d0d5e68eeea7ba273e1f0f6bc", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -107,6 +107,60 @@ use crate::sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n ///\n /// *guard += 1;\n /// ```\n+///\n+/// It is sometimes necessary to manually drop the mutex guard to unlock it\n+/// sooner than the end of the enclosing scope.\n+///\n+/// ```\n+/// use std::sync::{Arc, Mutex};\n+/// use std::thread;\n+///\n+/// const N: usize = 3;\n+///\n+/// let data_mutex = Arc::new(Mutex::new(vec![1, 2, 3, 4]));\n+/// let res_mutex = Arc::new(Mutex::new(0));\n+///\n+/// let mut threads = Vec::with_capacity(N);\n+/// (0..N).for_each(|_| {\n+///     let data_mutex_clone = Arc::clone(&data_mutex);\n+///     let res_mutex_clone = Arc::clone(&res_mutex);\n+///\n+///     threads.push(thread::spawn(move || {\n+///         let mut data = data_mutex_clone.lock().unwrap();\n+///         // This is the result of some important and long-ish work.\n+///         let result = data.iter().fold(0, |acc, x| acc + x * 2);\n+///         data.push(result);\n+///         drop(data);\n+///         *res_mutex_clone.lock().unwrap() += result;\n+///     }));\n+/// });\n+///\n+/// let mut data = data_mutex.lock().unwrap();\n+/// // This is the result of some important and long-ish work.\n+/// let result = data.iter().fold(0, |acc, x| acc + x * 2);\n+/// data.push(result);\n+/// // We drop the `data` explicitly because it's not necessary anymore and the\n+/// // thread still has work to do. This allow other threads to start working on\n+/// // the data immediately, without waiting for the rest of the unrelated work\n+/// // to be done here.\n+/// //\n+/// // It's even more important here than in the threads because we `.join` the\n+/// // threads after that. If we had not dropped the mutex guard, a thread could\n+/// // be waiting forever for it, causing a deadlock.\n+/// drop(data);\n+/// // Here the mutex guard is not assigned to a variable and so, even if the\n+/// // scope does not end after this line, the mutex is still released: there is\n+/// // no deadlock.\n+/// *res_mutex.lock().unwrap() += result;\n+///\n+/// threads.into_iter().for_each(|thread| {\n+///     thread\n+///         .join()\n+///         .expect(\"The thread creating or execution failed !\")\n+/// });\n+///\n+/// assert_eq!(*res_mutex.lock().unwrap(), 800);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"mutex_type\")]\n pub struct Mutex<T: ?Sized> {"}, {"sha": "9e588c4265ac2199784ba0393e8a43c850904ca0", "filename": "src/libstd/sys/hermit/net.rs", "status": "modified", "additions": 85, "deletions": 46, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1,10 +1,13 @@\n use crate::convert::TryFrom;\n use crate::fmt;\n use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n-use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n+use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::str;\n+use crate::sync::Arc;\n use crate::sys::hermit::abi;\n+use crate::sys::hermit::abi::IpAddress::{Ipv4, Ipv6};\n use crate::sys::{unsupported, Void};\n+use crate::sys_common::AsInner;\n use crate::time::Duration;\n \n /// Checks whether the HermitCore's socket interface has been started already, and\n@@ -17,14 +20,33 @@ pub fn init() -> io::Result<()> {\n     Ok(())\n }\n \n-pub struct TcpStream(abi::Handle);\n+#[derive(Debug, Clone)]\n+pub struct Socket(abi::Handle);\n+\n+impl AsInner<abi::Handle> for Socket {\n+    fn as_inner(&self) -> &abi::Handle {\n+        &self.0\n+    }\n+}\n+\n+impl Drop for Socket {\n+    fn drop(&mut self) {\n+        let _ = abi::tcpstream::close(self.0);\n+    }\n+}\n+\n+// Arc is used to count the number of used sockets.\n+// Only if all sockets are released, the drop\n+// method will close the socket.\n+#[derive(Clone)]\n+pub struct TcpStream(Arc<Socket>);\n \n impl TcpStream {\n     pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n         let addr = addr?;\n \n         match abi::tcpstream::connect(addr.ip().to_string().as_bytes(), addr.port(), None) {\n-            Ok(handle) => Ok(TcpStream(handle)),\n+            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n             _ => {\n                 Err(io::Error::new(ErrorKind::Other, \"Unable to initiate a connection on a socket\"))\n             }\n@@ -37,39 +59,42 @@ impl TcpStream {\n             saddr.port(),\n             Some(duration.as_millis() as u64),\n         ) {\n-            Ok(handle) => Ok(TcpStream(handle)),\n+            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n             _ => {\n                 Err(io::Error::new(ErrorKind::Other, \"Unable to initiate a connection on a socket\"))\n             }\n         }\n     }\n \n     pub fn set_read_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n-        abi::tcpstream::set_read_timeout(self.0, duration.map(|d| d.as_millis() as u64))\n+        abi::tcpstream::set_read_timeout(*self.0.as_inner(), duration.map(|d| d.as_millis() as u64))\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n     }\n \n     pub fn set_write_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n-        abi::tcpstream::set_write_timeout(self.0, duration.map(|d| d.as_millis() as u64))\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n+        abi::tcpstream::set_write_timeout(\n+            *self.0.as_inner(),\n+            duration.map(|d| d.as_millis() as u64),\n+        )\n+        .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        let duration = abi::tcpstream::get_read_timeout(self.0)\n+        let duration = abi::tcpstream::get_read_timeout(*self.0.as_inner())\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to determine timeout value\"))?;\n \n         Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        let duration = abi::tcpstream::get_write_timeout(self.0)\n+        let duration = abi::tcpstream::get_write_timeout(*self.0.as_inner())\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to determine timeout value\"))?;\n \n         Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        abi::tcpstream::peek(self.0, buf)\n+        abi::tcpstream::peek(*self.0.as_inner(), buf)\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"set_nodelay failed\"))\n     }\n \n@@ -81,18 +106,11 @@ impl TcpStream {\n         let mut size: usize = 0;\n \n         for i in ioslice.iter_mut() {\n-            let mut pos: usize = 0;\n-\n-            while pos < i.len() {\n-                let ret = abi::tcpstream::read(self.0, &mut i[pos..])\n-                    .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to read on socket\"))?;\n-\n-                if ret == 0 {\n-                    return Ok(size);\n-                } else {\n-                    size += ret;\n-                    pos += ret;\n-                }\n+            let ret = abi::tcpstream::read(*self.0.as_inner(), &mut i[0..])\n+                .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to read on socket\"))?;\n+\n+            if ret != 0 {\n+                size += ret;\n             }\n         }\n \n@@ -112,7 +130,7 @@ impl TcpStream {\n         let mut size: usize = 0;\n \n         for i in ioslice.iter() {\n-            size += abi::tcpstream::write(self.0, i)\n+            size += abi::tcpstream::write(*self.0.as_inner(), i)\n                 .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to write on socket\"))?;\n         }\n \n@@ -125,42 +143,53 @@ impl TcpStream {\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        Err(io::Error::new(ErrorKind::Other, \"peer_addr isn't supported\"))\n+        let (ipaddr, port) = abi::tcpstream::peer_addr(*self.0.as_inner())\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"peer_addr failed\"))?;\n+\n+        let saddr = match ipaddr {\n+            Ipv4(ref addr) => SocketAddr::new(\n+                IpAddr::V4(Ipv4Addr::new(addr.0[0], addr.0[1], addr.0[2], addr.0[3])),\n+                port,\n+            ),\n+            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n+            _ => {\n+                return Err(io::Error::new(ErrorKind::Other, \"peer_addr failed\"));\n+            }\n+        };\n+\n+        Ok(saddr)\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n         Err(io::Error::new(ErrorKind::Other, \"socket_addr isn't supported\"))\n     }\n \n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        abi::tcpstream::shutdown(self.0, how as i32)\n+        abi::tcpstream::shutdown(*self.0.as_inner(), how as i32)\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to shutdown socket\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpStream> {\n-        let handle = abi::tcpstream::duplicate(self.0)\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to duplicate stream\"))?;\n-\n-        Ok(TcpStream(handle))\n+        Ok(self.clone())\n     }\n \n     pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n-        abi::tcpstream::set_nodelay(self.0, mode)\n+        abi::tcpstream::set_nodelay(*self.0.as_inner(), mode)\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"set_nodelay failed\"))\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n-        abi::tcpstream::nodelay(self.0)\n+        abi::tcpstream::nodelay(*self.0.as_inner())\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"nodelay failed\"))\n     }\n \n     pub fn set_ttl(&self, tll: u32) -> io::Result<()> {\n-        abi::tcpstream::set_tll(self.0, tll)\n+        abi::tcpstream::set_tll(*self.0.as_inner(), tll)\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to set TTL\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        abi::tcpstream::get_tll(self.0)\n+        abi::tcpstream::get_tll(*self.0.as_inner())\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to get TTL\"))\n     }\n \n@@ -169,40 +198,50 @@ impl TcpStream {\n     }\n \n     pub fn set_nonblocking(&self, mode: bool) -> io::Result<()> {\n-        abi::tcpstream::set_nonblocking(self.0, mode)\n+        abi::tcpstream::set_nonblocking(*self.0.as_inner(), mode)\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to set blocking mode\"))\n     }\n }\n \n-impl Drop for TcpStream {\n-    fn drop(&mut self) {\n-        let _ = abi::tcpstream::close(self.0);\n-    }\n-}\n-\n impl fmt::Debug for TcpStream {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         Ok(())\n     }\n }\n \n-pub struct TcpListener(abi::Handle);\n+#[derive(Clone)]\n+pub struct TcpListener(SocketAddr);\n \n impl TcpListener {\n-    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n+        let addr = addr?;\n+\n+        Ok(TcpListener(*addr))\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Ok(self.0)\n     }\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        let (handle, ipaddr, port) = abi::tcplistener::accept(self.0.port())\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"accept failed\"))?;\n+        let saddr = match ipaddr {\n+            Ipv4(ref addr) => SocketAddr::new(\n+                IpAddr::V4(Ipv4Addr::new(addr.0[0], addr.0[1], addr.0[2], addr.0[3])),\n+                port,\n+            ),\n+            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n+            _ => {\n+                return Err(io::Error::new(ErrorKind::Other, \"accept failed\"));\n+            }\n+        };\n+\n+        Ok((TcpStream(Arc::new(Socket(handle))), saddr))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpListener> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Ok(self.clone())\n     }\n \n     pub fn set_ttl(&self, _: u32) -> io::Result<()> {"}, {"sha": "3386e6e588e7120105e272edf2fb7131ec97c52e", "filename": "src/test/ui/consts/const-eval/infinite_loop.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -23,10 +23,10 @@ LL |             n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/infinite_loop.rs:8:20\n+  --> $DIR/infinite_loop.rs:8:17\n    |\n LL |             n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n-   |                    ^^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "0aa30665f590769d70e73c7f09e30b043c3be9fc", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -17,8 +17,8 @@ LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n note: ...which requires const-evaluating `std::mem::size_of`...\n   --> $SRC_DIR/libcore/mem/mod.rs:LL:COL\n    |\n-LL |     intrinsics::size_of::<T>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | pub const fn size_of<T>() -> usize {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `std::intrinsics::size_of`...\n   --> $SRC_DIR/libcore/intrinsics.rs:LL:COL\n    |"}, {"sha": "8c2190b4e591f87624bbed87cd95288ffe9bfba9", "filename": "src/test/ui/consts/const_limit/const_eval_limit_reached.stderr", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1,15 +1,18 @@\n error: any use of this value will cause an error\n-  --> $DIR/const_eval_limit_reached.rs:8:11\n+  --> $DIR/const_eval_limit_reached.rs:8:5\n    |\n-LL | / const X: usize = {\n-LL | |     let mut x = 0;\n-LL | |     while x != 1000 {\n-   | |           ^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n-LL | |\n-...  |\n-LL | |     x\n-LL | | };\n-   | |__-\n+LL |  / const X: usize = {\n+LL |  |     let mut x = 0;\n+LL |  |     while x != 1000 {\n+   |  |_____^\n+LL | ||\n+LL | ||         x += 1;\n+LL | ||     }\n+   | ||_____^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n+LL |  |\n+LL |  |     x\n+LL |  | };\n+   |  |__-\n    |\n    = note: `#[deny(const_err)]` on by default\n "}, {"sha": "9042c6f6be1912c0d85a60db229eddbff965230f", "filename": "src/test/ui/consts/recursive-zst-static.default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.default.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1,8 +1,8 @@\n error[E0391]: cycle detected when const-evaluating `FOO`\n-  --> $DIR/recursive-zst-static.rs:10:18\n+  --> $DIR/recursive-zst-static.rs:10:1\n    |\n LL | static FOO: () = FOO;\n-   |                  ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating `FOO`...\n   --> $DIR/recursive-zst-static.rs:10:1"}, {"sha": "9042c6f6be1912c0d85a60db229eddbff965230f", "filename": "src/test/ui/consts/recursive-zst-static.unleash.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.unleash.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.unleash.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.unleash.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1,8 +1,8 @@\n error[E0391]: cycle detected when const-evaluating `FOO`\n-  --> $DIR/recursive-zst-static.rs:10:18\n+  --> $DIR/recursive-zst-static.rs:10:1\n    |\n LL | static FOO: () = FOO;\n-   |                  ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating `FOO`...\n   --> $DIR/recursive-zst-static.rs:10:1"}, {"sha": "55f42d84f9cb032ca28e49be253c6c0ecbae6a7a", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1,11 +1,11 @@\n // build-fail\n \n pub const unsafe fn fake_type<T>() -> T {\n-    hint_unreachable()\n+    hint_unreachable() //~ ERROR evaluation of constant value failed\n }\n \n pub const unsafe fn hint_unreachable() -> ! {\n-    fake_type() //~ ERROR evaluation of constant value failed\n+    fake_type()\n }\n \n trait Const {"}, {"sha": "fc908b2b2225f130de39aba07c194bc2f67b5443", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1,9 +1,10 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/uninhabited-const-issue-61744.rs:8:5\n+  --> $DIR/uninhabited-const-issue-61744.rs:4:5\n    |\n LL |     hint_unreachable()\n-   |     ------------------\n+   |     ^^^^^^^^^^^^^^^^^^\n    |     |\n+   |     reached the configured maximum number of stack frames\n    |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n    |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n    |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n@@ -71,9 +72,8 @@ LL |     hint_unreachable()\n    |     inside `fake_type::<i32>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n ...\n LL |     fake_type()\n-   |     ^^^^^^^^^^^\n+   |     -----------\n    |     |\n-   |     reached the configured maximum number of stack frames\n    |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n    |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n    |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5"}, {"sha": "de0c579f6308990f401fd99c5c1180267c993814", "filename": "src/test/ui/infinite/infinite-recursion-const-fn.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Finfinite%2Finfinite-recursion-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Finfinite%2Finfinite-recursion-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-recursion-const-fn.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1,14 +1,14 @@\n error[E0391]: cycle detected when const-evaluating `a`\n-  --> $DIR/infinite-recursion-const-fn.rs:3:25\n+  --> $DIR/infinite-recursion-const-fn.rs:3:1\n    |\n LL | const fn a() -> usize { b() }\n-   |                         ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating `b`...\n-  --> $DIR/infinite-recursion-const-fn.rs:4:25\n+  --> $DIR/infinite-recursion-const-fn.rs:4:1\n    |\n LL | const fn b() -> usize { a() }\n-   |                         ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which again requires const-evaluating `a`, completing the cycle\n note: cycle used when const-evaluating `ARR::{{constant}}#0`\n   --> $DIR/infinite-recursion-const-fn.rs:5:18"}, {"sha": "6d1df4fda2eb052db05b8c94464eac0b2d1fb247", "filename": "src/test/ui/infinite/infinite-tag-type-recursion.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -6,7 +6,10 @@ LL | enum MList { Cons(isize, MList), Nil }\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `MList` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `MList` representable\n+   |\n+LL | enum MList { Cons(isize, Box<MList>), Nil }\n+   |                          ^^^^     ^\n \n error[E0391]: cycle detected when computing drop-check constraints for `MList`\n   --> $DIR/infinite-tag-type-recursion.rs:1:1"}, {"sha": "58d087ca1998b7900e35b094e94b7d5f9841a5fd", "filename": "src/test/ui/issues/issue-17431-1.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -2,11 +2,14 @@ error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-17431-1.rs:1:1\n    |\n LL | struct Foo { foo: Option<Option<Foo>> }\n-   | ^^^^^^^^^^   ------------------------ recursive without indirection\n+   | ^^^^^^^^^^        ------------------- recursive without indirection\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+   |\n+LL | struct Foo { foo: Box<Option<Option<Foo>>> }\n+   |                   ^^^^                   ^\n \n error: aborting due to previous error\n "}, {"sha": "eba4bf6d1d5eaf2ab9a408bc1e0359fd6801b339", "filename": "src/test/ui/issues/issue-17431-2.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -2,21 +2,27 @@ error[E0072]: recursive type `Baz` has infinite size\n   --> $DIR/issue-17431-2.rs:1:1\n    |\n LL | struct Baz { q: Option<Foo> }\n-   | ^^^^^^^^^^   -------------- recursive without indirection\n+   | ^^^^^^^^^^      ----------- recursive without indirection\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Baz` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Baz` representable\n+   |\n+LL | struct Baz { q: Box<Option<Foo>> }\n+   |                 ^^^^           ^\n \n error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-17431-2.rs:4:1\n    |\n LL | struct Foo { q: Option<Baz> }\n-   | ^^^^^^^^^^   -------------- recursive without indirection\n+   | ^^^^^^^^^^      ----------- recursive without indirection\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+   |\n+LL | struct Foo { q: Box<Option<Baz>> }\n+   |                 ^^^^           ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f6b15d0528ae8ab605e8ace07f8502461ba27d38", "filename": "src/test/ui/issues/issue-17431-3.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-3.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -2,11 +2,14 @@ error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-17431-3.rs:3:1\n    |\n LL | struct Foo { foo: Mutex<Option<Foo>> }\n-   | ^^^^^^^^^^   ----------------------- recursive without indirection\n+   | ^^^^^^^^^^        ------------------ recursive without indirection\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+   |\n+LL | struct Foo { foo: Box<Mutex<Option<Foo>>> }\n+   |                   ^^^^                  ^\n \n error: aborting due to previous error\n "}, {"sha": "aa709e1ad518350eb0ac815ae67f8dba787c8e81", "filename": "src/test/ui/issues/issue-17431-4.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -2,11 +2,14 @@ error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-17431-4.rs:3:1\n    |\n LL | struct Foo<T> { foo: Option<Option<Foo<T>>>, marker: marker::PhantomData<T> }\n-   | ^^^^^^^^^^^^^   --------------------------- recursive without indirection\n+   | ^^^^^^^^^^^^^        ---------------------- recursive without indirection\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+   |\n+LL | struct Foo<T> { foo: Box<Option<Option<Foo<T>>>>, marker: marker::PhantomData<T> }\n+   |                      ^^^^                      ^\n \n error: aborting due to previous error\n "}, {"sha": "1558cffb036b3490fac5b9487a6bc6cbdf77c7dd", "filename": "src/test/ui/issues/issue-17431-5.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-5.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -2,11 +2,14 @@ error[E0072]: recursive type `Bar` has infinite size\n   --> $DIR/issue-17431-5.rs:5:1\n    |\n LL | struct Bar<T> { x: Bar<Foo> , marker: marker::PhantomData<T> }\n-   | ^^^^^^^^^^^^^   ----------- recursive without indirection\n+   | ^^^^^^^^^^^^^      -------- recursive without indirection\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Bar` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Bar` representable\n+   |\n+LL | struct Bar<T> { x: Box<Bar<Foo>> , marker: marker::PhantomData<T> }\n+   |                    ^^^^        ^\n \n error: aborting due to previous error\n "}, {"sha": "f2aa2a79c820030141750f658c73b90df23cc798", "filename": "src/test/ui/issues/issue-17431-6.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-6.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -6,7 +6,10 @@ LL | enum Foo { X(Mutex<Option<Foo>>) }\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+   |\n+LL | enum Foo { X(Box<Mutex<Option<Foo>>>) }\n+   |              ^^^^                  ^\n \n error: aborting due to previous error\n "}, {"sha": "684c3089e85ec872695fb5da4845861780b599a3", "filename": "src/test/ui/issues/issue-17431-7.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -6,7 +6,10 @@ LL | enum Foo { Voo(Option<Option<Foo>>) }\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+   |\n+LL | enum Foo { Voo(Box<Option<Option<Foo>>>) }\n+   |                ^^^^                   ^\n \n error: aborting due to previous error\n "}, {"sha": "d152ffde4e57d28e7dea5533d787cf8f3b3f41c8", "filename": "src/test/ui/issues/issue-2718-a.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-2718-a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-2718-a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2718-a.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -7,7 +7,10 @@ LL |     pub struct Pong(SendPacket<Ping>);\n    |     |               recursive without indirection\n    |     recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `pingpong::Pong` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `pingpong::Pong` representable\n+   |\n+LL |     pub struct Pong(Box<SendPacket<Ping>>);\n+   |                     ^^^^                ^\n \n error: aborting due to previous error\n "}, {"sha": "87ee36df21696e3b51fa3b18db910ed106b7f89e", "filename": "src/test/ui/issues/issue-3008-1.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-3008-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-3008-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3008-1.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -7,7 +7,10 @@ LL | enum Bar {\n LL |     BarSome(Bar)\n    |             --- recursive without indirection\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Bar` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Bar` representable\n+   |\n+LL |     BarSome(Box<Bar>)\n+   |             ^^^^   ^\n \n error: aborting due to previous error\n "}, {"sha": "369a19d37e6f6450679ba38e959871a709b6eb11", "filename": "src/test/ui/issues/issue-3008-2.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-3008-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-3008-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3008-2.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -2,11 +2,14 @@ error[E0072]: recursive type `Bar` has infinite size\n   --> $DIR/issue-3008-2.rs:2:1\n    |\n LL | struct Bar { x: Bar }\n-   | ^^^^^^^^^^   ------ recursive without indirection\n+   | ^^^^^^^^^^      --- recursive without indirection\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Bar` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Bar` representable\n+   |\n+LL | struct Bar { x: Box<Bar> }\n+   |                 ^^^^   ^\n \n error: aborting due to previous error\n "}, {"sha": "0b162eff94a7cb251fe529dc44c105387e7107d9", "filename": "src/test/ui/issues/issue-3008-3.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-3008-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-3008-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3008-3.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -6,7 +6,10 @@ LL | enum E2<T> { V2(E2<E1>, marker::PhantomData<T>), }\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `E2` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `E2` representable\n+   |\n+LL | enum E2<T> { V2(Box<E2<E1>>, marker::PhantomData<T>), }\n+   |                 ^^^^      ^\n \n error: aborting due to previous error\n "}, {"sha": "0f3d3690b732ea1bf1d3660b2bd441f02caae636", "filename": "src/test/ui/issues/issue-32326.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-32326.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-32326.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32326.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -8,7 +8,10 @@ LL |     Plus(Expr, Expr),\n    |          |\n    |          recursive without indirection\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Expr` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Expr` representable\n+   |\n+LL |     Plus(Box<Expr>, Box<Expr>),\n+   |          ^^^^    ^  ^^^^    ^\n \n error: aborting due to previous error\n "}, {"sha": "7b17e91421660f4a31d83ec28692b8394a7da156", "filename": "src/test/ui/issues/issue-3779.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -5,9 +5,12 @@ LL | struct S {\n    | ^^^^^^^^ recursive type has infinite size\n LL |\n LL |     element: Option<S>\n-   |     ------------------ recursive without indirection\n+   |              --------- recursive without indirection\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `S` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `S` representable\n+   |\n+LL |     element: Box<Option<S>>\n+   |              ^^^^         ^\n \n error: aborting due to previous error\n "}, {"sha": "b7c799e163cee7474a99e9781995aaf55f06774c", "filename": "src/test/ui/issues/issue-57271.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-57271.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-57271.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57271.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -7,7 +7,10 @@ LL |     Class(ClassTypeSignature),\n LL |     Array(TypeSignature),\n    |           ------------- recursive without indirection\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `ObjectType` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ObjectType` representable\n+   |\n+LL |     Array(Box<TypeSignature>),\n+   |           ^^^^             ^\n \n error[E0072]: recursive type `TypeSignature` has infinite size\n   --> $DIR/issue-57271.rs:19:1\n@@ -18,7 +21,10 @@ LL |     Base(BaseType),\n LL |     Object(ObjectType),\n    |            ---------- recursive without indirection\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `TypeSignature` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `TypeSignature` representable\n+   |\n+LL |     Object(Box<ObjectType>),\n+   |            ^^^^          ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9de94c393a7113508b79bb92868efba6a463b9ee", "filename": "src/test/ui/issues/issue-72554.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -6,7 +6,10 @@ LL | pub enum ElemDerived {\n LL |     A(ElemDerived)\n    |       ----------- recursive without indirection\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `ElemDerived` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ElemDerived` representable\n+   |\n+LL |     A(Box<ElemDerived>)\n+   |       ^^^^           ^\n \n error: aborting due to previous error\n "}, {"sha": "ab4709d8e709e0bd5c5f5b7bc389cce36dc7eb37", "filename": "src/test/ui/recursion/recursive-enum.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Frecursion%2Frecursive-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Frecursion%2Frecursive-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-enum.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -6,7 +6,10 @@ LL | enum List<T> { Cons(T, List<T>), Nil }\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `List` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable\n+   |\n+LL | enum List<T> { Cons(T, Box<List<T>>), Nil }\n+   |                        ^^^^       ^\n \n error: aborting due to previous error\n "}, {"sha": "093606e100cb3fa300003ba5799a603837ea05f9", "filename": "src/test/ui/recursion/recursive-static-definition.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Frecursion%2Frecursive-static-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Frecursion%2Frecursive-static-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-static-definition.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -1,8 +1,8 @@\n error[E0391]: cycle detected when const-evaluating `FOO`\n-  --> $DIR/recursive-static-definition.rs:1:23\n+  --> $DIR/recursive-static-definition.rs:1:1\n    |\n LL | pub static FOO: u32 = FOO;\n-   |                       ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating `FOO`...\n   --> $DIR/recursive-static-definition.rs:1:1"}, {"sha": "45062c2ea6c7239fa0a847f9a06d36a8223daf55", "filename": "src/test/ui/sized-cycle-note.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fsized-cycle-note.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fsized-cycle-note.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsized-cycle-note.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -2,21 +2,27 @@ error[E0072]: recursive type `Baz` has infinite size\n   --> $DIR/sized-cycle-note.rs:9:1\n    |\n LL | struct Baz { q: Option<Foo> }\n-   | ^^^^^^^^^^   -------------- recursive without indirection\n+   | ^^^^^^^^^^      ----------- recursive without indirection\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Baz` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Baz` representable\n+   |\n+LL | struct Baz { q: Box<Option<Foo>> }\n+   |                 ^^^^           ^\n \n error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/sized-cycle-note.rs:11:1\n    |\n LL | struct Foo { q: Option<Baz> }\n-   | ^^^^^^^^^^   -------------- recursive without indirection\n+   | ^^^^^^^^^^      ----------- recursive without indirection\n    | |\n    | recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+   |\n+LL | struct Foo { q: Box<Option<Baz>> }\n+   |                 ^^^^           ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "06493f05142e6d2a59fa7e2ab6ba4a17d4253e40", "filename": "src/test/ui/span/E0072.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0072.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -5,9 +5,12 @@ LL | struct ListNode {\n    | ^^^^^^^^^^^^^^^ recursive type has infinite size\n LL |     head: u8,\n LL |     tail: Option<ListNode>,\n-   |     ---------------------- recursive without indirection\n+   |           ---------------- recursive without indirection\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `ListNode` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ListNode` representable\n+   |\n+LL |     tail: Box<Option<ListNode>>,\n+   |           ^^^^                ^\n \n error: aborting due to previous error\n "}, {"sha": "55128347f7404f26f091e4e1a240047a6f2bbcb2", "filename": "src/test/ui/span/multiline-span-E0072.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -6,11 +6,14 @@ LL | | ListNode\n LL | | {\n LL | |     head: u8,\n LL | |     tail: Option<ListNode>,\n-   | |     ---------------------- recursive without indirection\n+   | |           ---------------- recursive without indirection\n LL | | }\n    | |_^ recursive type has infinite size\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `ListNode` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ListNode` representable\n+   |\n+LL |     tail: Box<Option<ListNode>>,\n+   |           ^^^^                ^\n \n error: aborting due to previous error\n "}, {"sha": "fb1d98b58dfbe3cd433767b8b19e9de241ad2b48", "filename": "src/test/ui/span/recursive-type-field.stderr", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -4,28 +4,31 @@ error[E0072]: recursive type `Foo` has infinite size\n LL | struct Foo<'a> {\n    | ^^^^^^^^^^^^^^ recursive type has infinite size\n LL |     bar: Bar<'a>,\n-   |     ------------ recursive without indirection\n+   |          ------- recursive without indirection\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+   |\n+LL |     bar: Box<Bar<'a>>,\n+   |          ^^^^       ^\n \n error[E0072]: recursive type `Bar` has infinite size\n   --> $DIR/recursive-type-field.rs:8:1\n    |\n LL | struct Bar<'a> {\n    | ^^^^^^^^^^^^^^ recursive type has infinite size\n LL |     y: (Foo<'a>, Foo<'a>),\n-   |     --------------------- recursive without indirection\n+   |        ------------------ recursive without indirection\n LL |     z: Option<Bar<'a>>,\n-   |     ------------------ recursive without indirection\n+   |        --------------- recursive without indirection\n ...\n LL |     d: [Bar<'a>; 1],\n-   |     --------------- recursive without indirection\n+   |        ------------ recursive without indirection\n LL |     e: Foo<'a>,\n-   |     ---------- recursive without indirection\n+   |        ------- recursive without indirection\n LL |     x: Bar<'a>,\n-   |     ---------- recursive without indirection\n+   |        ------- recursive without indirection\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Bar` representable\n+   = help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Bar` representable\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d6d32cc5d6f395ffa9c2b4e4f239287fe5e0a548", "filename": "src/test/ui/type/type-recursive.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -5,9 +5,12 @@ LL | struct T1 {\n    | ^^^^^^^^^ recursive type has infinite size\n LL |     foo: isize,\n LL |     foolish: T1\n-   |     ----------- recursive without indirection\n+   |              -- recursive without indirection\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `T1` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T1` representable\n+   |\n+LL |     foolish: Box<T1>\n+   |              ^^^^  ^\n \n error: aborting due to previous error\n "}, {"sha": "c54d04de12c509043382130f57522fff7d5f9e7c", "filename": "src/test/ui/union/union-nonrepresentable.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Funion%2Funion-nonrepresentable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Funion%2Funion-nonrepresentable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-nonrepresentable.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -5,9 +5,12 @@ LL | union U {\n    | ^^^^^^^ recursive type has infinite size\n LL |     a: u8,\n LL |     b: U,\n-   |     ---- recursive without indirection\n+   |        - recursive without indirection\n    |\n-   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `U` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `U` representable\n+   |\n+LL |     b: Box<U>,\n+   |        ^^^^ ^\n \n error: aborting due to previous error\n "}, {"sha": "50dfce3448c341e7caee2515d367803ced13bdbd", "filename": "src/test/ui/write-to-static-mut-in-static.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -5,10 +5,10 @@ LL | pub static mut B: () = unsafe { A = 1; };\n    |                                 ^^^^^ modifying a static's initial value from another static's initializer\n \n error[E0391]: cycle detected when const-evaluating `C`\n-  --> $DIR/write-to-static-mut-in-static.rs:5:34\n+  --> $DIR/write-to-static-mut-in-static.rs:5:1\n    |\n LL | pub static mut C: u32 = unsafe { C = 1; 0 };\n-   |                                  ^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating `C`...\n   --> $DIR/write-to-static-mut-in-static.rs:5:1"}, {"sha": "88145015ba8bd529490705891d4fce901e481aaf", "filename": "src/tools/clippy/clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4a2533a0720f9cdd86e02eafa3725f07aa7752/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "patch": "@@ -88,7 +88,7 @@ fn double_check<'a>(cx: &LateContext<'_, '_>, left: &'a Expr<'_>, right: &'a Exp\n         let upper = check_upper_bound(l);\n         let lower = check_lower_bound(r);\n \n-        transpose(upper, lower).and_then(|(l, r)| l.combine(r, cx))\n+        upper.zip(lower).and_then(|(l, r)| l.combine(r, cx))\n     };\n \n     upper_lower(left, right).or_else(|| upper_lower(right, left))\n@@ -131,7 +131,10 @@ impl<'a> Conversion<'a> {\n \n     /// Checks if the to-type is the same (if there is a type constraint)\n     fn has_compatible_to_type(&self, other: &Self) -> bool {\n-        transpose(self.to_type.as_ref(), other.to_type.as_ref()).map_or(true, |(l, r)| l == r)\n+        match (self.to_type, other.to_type) {\n+            (Some(l), Some(r)) => l == r,\n+            _ => true,\n+        }\n     }\n \n     /// Try to construct a new conversion if the conversion type is valid\n@@ -322,14 +325,6 @@ fn int_ty_to_sym<'tcx>(path: &QPath<'_>) -> Option<&'tcx str> {\n     }\n }\n \n-/// (Option<T>, Option<U>) -> Option<(T, U)>\n-fn transpose<T, U>(lhs: Option<T>, rhs: Option<U>) -> Option<(T, U)> {\n-    match (lhs, rhs) {\n-        (Some(l), Some(r)) => Some((l, r)),\n-        _ => None,\n-    }\n-}\n-\n /// Will return the expressions as if they were expr1 <= expr2\n fn normalize_le_ge<'a>(op: &BinOp, left: &'a Expr<'a>, right: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n     match op.node {"}]}