{"sha": "5fa6e857c9f43a69661ebca278c99155ee7d5db7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYTZlODU3YzlmNDNhNjk2NjFlYmNhMjc4Yzk5MTU1ZWU3ZDVkYjc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-10T19:46:52Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-18T12:26:08Z"}, "message": "Implement empty struct with braces (RFC 218)", "tree": {"sha": "f10c986188ac45cbd1e7b9789f9f2ddedeb6e16d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f10c986188ac45cbd1e7b9789f9f2ddedeb6e16d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fa6e857c9f43a69661ebca278c99155ee7d5db7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa6e857c9f43a69661ebca278c99155ee7d5db7", "html_url": "https://github.com/rust-lang/rust/commit/5fa6e857c9f43a69661ebca278c99155ee7d5db7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fa6e857c9f43a69661ebca278c99155ee7d5db7/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cff04117064ddee95f425c49f22c8aa5a3a665d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cff04117064ddee95f425c49f22c8aa5a3a665d4", "html_url": "https://github.com/rust-lang/rust/commit/cff04117064ddee95f425c49f22c8aa5a3a665d4"}], "stats": {"total": 247, "additions": 114, "deletions": 133}, "files": [{"sha": "940145aa4173b26c6812314163508fc7254fadfe", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=5fa6e857c9f43a69661ebca278c99155ee7d5db7", "patch": "@@ -1218,34 +1218,34 @@ impl<'a> State<'a> {\n                          fields: &[hir::Field],\n                          wth: &Option<P<hir::Expr>>) -> io::Result<()> {\n         try!(self.print_path(path, true, 0));\n-        if !(fields.is_empty() && wth.is_none()) {\n-            try!(word(&mut self.s, \"{\"));\n-            try!(self.commasep_cmnt(\n-                Consistent,\n-                &fields[..],\n-                |s, field| {\n-                    try!(s.ibox(indent_unit));\n-                    try!(s.print_ident(field.ident.node));\n-                    try!(s.word_space(\":\"));\n-                    try!(s.print_expr(&*field.expr));\n-                    s.end()\n-                },\n-                |f| f.span));\n-            match *wth {\n-                Some(ref expr) => {\n-                    try!(self.ibox(indent_unit));\n-                    if !fields.is_empty() {\n-                        try!(word(&mut self.s, \",\"));\n-                        try!(space(&mut self.s));\n-                    }\n-                    try!(word(&mut self.s, \"..\"));\n-                    try!(self.print_expr(&**expr));\n-                    try!(self.end());\n+        try!(word(&mut self.s, \"{\"));\n+        try!(self.commasep_cmnt(\n+            Consistent,\n+            &fields[..],\n+            |s, field| {\n+                try!(s.ibox(indent_unit));\n+                try!(s.print_ident(field.ident.node));\n+                try!(s.word_space(\":\"));\n+                try!(s.print_expr(&*field.expr));\n+                s.end()\n+            },\n+            |f| f.span));\n+        match *wth {\n+            Some(ref expr) => {\n+                try!(self.ibox(indent_unit));\n+                if !fields.is_empty() {\n+                    try!(word(&mut self.s, \",\"));\n+                    try!(space(&mut self.s));\n                 }\n-                _ => try!(word(&mut self.s, \",\")),\n+                try!(word(&mut self.s, \"..\"));\n+                try!(self.print_expr(&**expr));\n+                try!(self.end());\n+            }\n+            _ => if !fields.is_empty() {\n+                try!(word(&mut self.s, \",\"))\n             }\n-            try!(word(&mut self.s, \"}\"));\n         }\n+        try!(word(&mut self.s, \"}\"));\n         Ok(())\n     }\n "}, {"sha": "6f1e2e283e7a2a95ee74b2ba2c2b3695129ccb7d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5fa6e857c9f43a69661ebca278c99155ee7d5db7", "patch": "@@ -1473,14 +1473,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return None\n         };\n \n-        if let ty::VariantKind::Dict = variant.kind() {\n+        let var_kind = variant.kind();\n+        if var_kind == ty::VariantKind::Dict || var_kind == ty::VariantKind::Unit {\n             Some((adt, variant))\n         } else {\n             None\n         }\n     }\n \n-\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx().mk_nil());\n     }"}, {"sha": "a7978babcb7e1c000d7b96a21a1e22bc2274c417", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5fa6e857c9f43a69661ebca278c99155ee7d5db7", "patch": "@@ -2231,14 +2231,6 @@ impl<'a> Parser<'a> {\n                                                  &[token::CloseDelim(token::Brace)]));\n                             }\n \n-                            if fields.is_empty() && base.is_none() {\n-                                let last_span = self.last_span;\n-                                self.span_err(last_span,\n-                                              \"structure literal must either \\\n-                                              have at least one field or use \\\n-                                              structure update syntax\");\n-                            }\n-\n                             hi = self.span.hi;\n                             try!(self.expect(&token::CloseDelim(token::Brace)));\n                             ex = ExprStruct(pth, fields, base);\n@@ -4713,14 +4705,14 @@ impl<'a> Parser<'a> {\n                 (Vec::new(), Some(ast::DUMMY_NODE_ID))\n             } else {\n                 // If we see: `struct Foo<T> where T: Copy { ... }`\n-                (try!(self.parse_record_struct_body(&class_name)), None)\n+                (try!(self.parse_record_struct_body()), None)\n             }\n         // No `where` so: `struct Foo<T>;`\n         } else if try!(self.eat(&token::Semi) ){\n             (Vec::new(), Some(ast::DUMMY_NODE_ID))\n         // Record-style struct definition\n         } else if self.token == token::OpenDelim(token::Brace) {\n-            let fields = try!(self.parse_record_struct_body(&class_name));\n+            let fields = try!(self.parse_record_struct_body());\n             (fields, None)\n         // Tuple-style struct definition with optional where-clause.\n         } else if self.token == token::OpenDelim(token::Paren) {\n@@ -4740,20 +4732,13 @@ impl<'a> Parser<'a> {\n          None))\n     }\n \n-    pub fn parse_record_struct_body(&mut self,\n-                                    class_name: &ast::Ident) -> PResult<Vec<StructField>> {\n+    pub fn parse_record_struct_body(&mut self) -> PResult<Vec<StructField>> {\n         let mut fields = Vec::new();\n         if try!(self.eat(&token::OpenDelim(token::Brace)) ){\n             while self.token != token::CloseDelim(token::Brace) {\n                 fields.push(try!(self.parse_struct_decl_field(true)));\n             }\n \n-            if fields.is_empty() {\n-                return Err(self.fatal(&format!(\"unit-like struct definition should be \\\n-                    written as `struct {};`\",\n-                    class_name)));\n-            }\n-\n             try!(self.bump());\n         } else {\n             let token_str = self.this_token_to_string();"}, {"sha": "1d22c83122e51a2b0dfcf297c806bb4b140e76f4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5fa6e857c9f43a69661ebca278c99155ee7d5db7", "patch": "@@ -1855,34 +1855,34 @@ impl<'a> State<'a> {\n                          fields: &[ast::Field],\n                          wth: &Option<P<ast::Expr>>) -> io::Result<()> {\n         try!(self.print_path(path, true, 0));\n-        if !(fields.is_empty() && wth.is_none()) {\n-            try!(word(&mut self.s, \"{\"));\n-            try!(self.commasep_cmnt(\n-                Consistent,\n-                &fields[..],\n-                |s, field| {\n-                    try!(s.ibox(indent_unit));\n-                    try!(s.print_ident(field.ident.node));\n-                    try!(s.word_space(\":\"));\n-                    try!(s.print_expr(&*field.expr));\n-                    s.end()\n-                },\n-                |f| f.span));\n-            match *wth {\n-                Some(ref expr) => {\n-                    try!(self.ibox(indent_unit));\n-                    if !fields.is_empty() {\n-                        try!(word(&mut self.s, \",\"));\n-                        try!(space(&mut self.s));\n-                    }\n-                    try!(word(&mut self.s, \"..\"));\n-                    try!(self.print_expr(&**expr));\n-                    try!(self.end());\n+        try!(word(&mut self.s, \"{\"));\n+        try!(self.commasep_cmnt(\n+            Consistent,\n+            &fields[..],\n+            |s, field| {\n+                try!(s.ibox(indent_unit));\n+                try!(s.print_ident(field.ident.node));\n+                try!(s.word_space(\":\"));\n+                try!(s.print_expr(&*field.expr));\n+                s.end()\n+            },\n+            |f| f.span));\n+        match *wth {\n+            Some(ref expr) => {\n+                try!(self.ibox(indent_unit));\n+                if !fields.is_empty() {\n+                    try!(word(&mut self.s, \",\"));\n+                    try!(space(&mut self.s));\n                 }\n-                _ => try!(word(&mut self.s, \",\")),\n+                try!(word(&mut self.s, \"..\"));\n+                try!(self.print_expr(&**expr));\n+                try!(self.end());\n+            }\n+            _ => if !fields.is_empty() {\n+                try!(word(&mut self.s, \",\"))\n             }\n-            try!(word(&mut self.s, \"}\"));\n         }\n+        try!(word(&mut self.s, \"}\"));\n         Ok(())\n     }\n "}, {"sha": "bfe72856a2e1780e1a354a4d330dfd8c8acdce48", "filename": "src/test/compile-fail/empty-struct-with-braces-1.rs", "status": "renamed", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-1.rs?ref=5fa6e857c9f43a69661ebca278c99155ee7d5db7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// Empty struct defined with braces shouldn't add names into value namespace\n \n-struct Foo;\n+struct Empty {}\n \n-fn f2() {\n-    let _end_stmt     = Foo { };\n-    //~^ ERROR: structure literal must either have at least one field\n+fn main() {\n+    let e = Empty; //~ ERROR `Empty` is the name of a struct or struct variant\n }\n-\n-fn main() {}", "previous_filename": "src/test/parse-fail/struct-no-fields-2.rs"}, {"sha": "7e5a87fe1a44e331f999bda67ef15a9ebd410f17", "filename": "src/test/compile-fail/empty-struct-with-braces-2.rs", "status": "renamed", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-2.rs?ref=5fa6e857c9f43a69661ebca278c99155ee7d5db7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// Empty struct defined with braces shouldn't add names into value namespace\n \n-struct Foo;\n+#![deny(warnings)]\n \n-fn g3() {\n-    let _mid_tuple    = (Foo { }, 2);\n-    //~^ ERROR: structure literal must either have at least one field\n-}\n+struct Empty {}\n+\n+fn main() {\n+    let e = Empty {};\n \n-fn main() {}\n+    match e {\n+        Empty => () //~ ERROR unused variable: `Empty`\n+        //~^ ERROR variable `Empty` should have a snake case name such as `empty`\n+    }\n+}", "previous_filename": "src/test/parse-fail/struct-no-fields-3.rs"}, {"sha": "533387c576008c5d3e0f73e77cfd44b0ada09f11", "filename": "src/test/compile-fail/issue-27831.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs?ref=5fa6e857c9f43a69661ebca278c99155ee7d5db7", "patch": "@@ -22,8 +22,8 @@ fn main() {\n     let Foo { .. } = x; //~ ERROR `Foo` does not name a struct\n \n     let x = Bar;\n-    Bar { ..x }; //~ ERROR `Bar` does not name a structure\n-    let Bar { .. } = x; //~ ERROR `Bar` does not name a struct\n+    Bar { ..x };\n+    let Bar { .. } = x;\n \n     match Enum::Bar {\n         Enum::Bar { .. } //~ ERROR `Enum::Bar` does not name a struct"}, {"sha": "6e55baf06cedf90397e0effa814283d4571601cd", "filename": "src/test/parse-fail/struct-no-fields-4.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cff04117064ddee95f425c49f22c8aa5a3a665d4/src%2Ftest%2Fparse-fail%2Fstruct-no-fields-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff04117064ddee95f425c49f22c8aa5a3a665d4/src%2Ftest%2Fparse-fail%2Fstruct-no-fields-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-no-fields-4.rs?ref=cff04117064ddee95f425c49f22c8aa5a3a665d4", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-struct Foo;\n-\n-fn h4() {\n-    let _end_of_tuple = (3, Foo { });\n-    //~^ ERROR: structure literal must either have at least one field\n-}\n-\n-fn main() {}"}, {"sha": "5f92d98606693215bee452db483f88af5899c362", "filename": "src/test/parse-fail/struct-no-fields-5.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cff04117064ddee95f425c49f22c8aa5a3a665d4/src%2Ftest%2Fparse-fail%2Fstruct-no-fields-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff04117064ddee95f425c49f22c8aa5a3a665d4/src%2Ftest%2Fparse-fail%2Fstruct-no-fields-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-no-fields-5.rs?ref=cff04117064ddee95f425c49f22c8aa5a3a665d4", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-struct Foo;\n-\n-fn i5() {\n-    let _end_of_block = { Foo { } };\n-    //~^ ERROR: structure literal must either have at least one field\n-}\n-\n-fn main() {}"}, {"sha": "a96c1e5b10c4b70e1a0bc55514305a88cfd223c2", "filename": "src/test/run-pass/empty-struct-with-braces.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Ftest%2Frun-pass%2Fempty-struct-with-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Ftest%2Frun-pass%2Fempty-struct-with-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-struct-with-braces.rs?ref=5fa6e857c9f43a69661ebca278c99155ee7d5db7", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Empty struct defined with braces add names into type namespace\n+// Empty struct defined without braces add names into both type and value namespaces\n+\n+struct Empty1 {}\n+struct Empty2;\n+\n+fn main() {\n+    let e1: Empty1 = Empty1 {};\n+    let e2: Empty2 = Empty2 {};\n+    let e2: Empty2 = Empty2;\n+\n+    match e1 {\n+        Empty1 {} => ()\n+    }\n+    match e2 {\n+        Empty2 {} => ()\n+    }\n+    match e2 {\n+        Empty2 => ()\n+    }\n+}"}, {"sha": "fb35ce33157d6ffcbbca6016373c1d839be0434f", "filename": "src/test/run-pass/issue-16819.rs", "status": "renamed", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Ftest%2Frun-pass%2Fissue-16819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa6e857c9f43a69661ebca278c99155ee7d5db7/src%2Ftest%2Frun-pass%2Fissue-16819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16819.rs?ref=5fa6e857c9f43a69661ebca278c99155ee7d5db7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+//`#[cfg]` on struct field permits empty unusable struct\n \n-struct Foo {}\n-//~^ ERROR: unit-like struct definition should be written as `struct Foo;`\n+struct S {\n+    #[cfg(untrue)]\n+    a: int,\n+}\n \n-fn main() {}\n+fn main() {\n+    let s = S {};\n+}", "previous_filename": "src/test/parse-fail/struct-no-fields.rs"}]}