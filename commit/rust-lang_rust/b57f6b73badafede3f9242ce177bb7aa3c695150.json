{"sha": "b57f6b73badafede3f9242ce177bb7aa3c695150", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1N2Y2YjczYmFkYWZlZGUzZjkyNDJjZTE3N2JiN2FhM2M2OTUxNTA=", "commit": {"author": {"name": "Daniel Patterson", "email": "dbp@riseup.net", "date": "2012-08-01T02:44:37Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-03T18:28:19Z"}, "message": "std::net::url - making parsing of authority give error messages if in encounters invalid stuff; support for ipv6, more tests.", "tree": {"sha": "c9693696bbd1de7686d484798d8683a0647cb7bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9693696bbd1de7686d484798d8683a0647cb7bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b57f6b73badafede3f9242ce177bb7aa3c695150", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b57f6b73badafede3f9242ce177bb7aa3c695150", "html_url": "https://github.com/rust-lang/rust/commit/b57f6b73badafede3f9242ce177bb7aa3c695150", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b57f6b73badafede3f9242ce177bb7aa3c695150/comments", "author": null, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d60dd6be87a1647db5434e9bf94994e4c1a8a68d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d60dd6be87a1647db5434e9bf94994e4c1a8a68d", "html_url": "https://github.com/rust-lang/rust/commit/d60dd6be87a1647db5434e9bf94994e4c1a8a68d"}], "stats": {"total": 361, "additions": 331, "deletions": 30}, "files": [{"sha": "dfaab399bb2adc7b1adc6242e2571564a118a013", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 331, "deletions": 30, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/b57f6b73badafede3f9242ce177bb7aa3c695150/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b57f6b73badafede3f9242ce177bb7aa3c695150/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=b57f6b73badafede3f9242ce177bb7aa3c695150", "patch": "@@ -17,6 +17,7 @@ type url = {\n     scheme: ~str,\n     user: option<userinfo>,\n     host: ~str,\n+    port: option<~str>,\n     path: ~str,\n     query: query,\n     fragment: option<~str>\n@@ -29,9 +30,9 @@ type userinfo = {\n \n type query = ~[(~str, ~str)];\n \n-fn url(-scheme: ~str, -user: option<userinfo>, -host: ~str,\n+fn url(-scheme: ~str, -user: option<userinfo>, -host: ~str, -port: option<~str>,\n        -path: ~str, -query: query, -fragment: option<~str>) -> url {\n-    { scheme: scheme, user: user, host: host,\n+    { scheme: scheme, user: user, host: host, port: port,\n      path: path, query: query, fragment: fragment }\n }\n \n@@ -319,12 +320,13 @@ fn query_from_str(rawquery: ~str) -> query {\n fn query_to_str(query: query) -> ~str {\n     let mut strvec = ~[];\n     for query.each |kv| {\n-        let (k, v) = kv;\n+        let (k, v) = copy kv;\n         strvec += ~[#fmt(\"%s=%s\", encode_component(k), encode_component(v))];\n     };\n     return str::connect(strvec, ~\"&\");\n }\n \n+// returns the scheme and the rest of the url, or a parsing error\n fn get_scheme(rawurl: ~str) -> result::result<(~str, ~str), @~str> {\n     for str::each_chari(rawurl) |i,c| {\n         alt c {\n@@ -340,7 +342,7 @@ fn get_scheme(rawurl: ~str) -> result::result<(~str, ~str), @~str> {\n                 return result::err(@~\"url: Scheme cannot be empty.\");\n             } else {\n                 return result::ok((rawurl.slice(0,i),\n-                                rawurl.slice(i+3,str::len(rawurl))));\n+                                rawurl.slice(i+1,str::len(rawurl))));\n             }\n           }\n           _  {\n@@ -351,6 +353,226 @@ fn get_scheme(rawurl: ~str) -> result::result<(~str, ~str), @~str> {\n     return result::ok((copy rawurl, ~\"\"));\n }\n \n+// returns userinfo, host, port, and unparsed part, or an error\n+// currently doesn't handle IPv6 addresses.\n+fn get_authority(rawurl: ~str) -> \n+    result::result<(option<userinfo>, ~str, option<~str>, ~str), @~str> {\n+    if !str::starts_with(rawurl, ~\"//\") {\n+        // there is no authority.\n+        return result::ok((option::none, ~\"\", option::none, copy rawurl));\n+    }\n+\n+    enum state {\n+        start, // starting state\n+        pass_host_port, // could be in user or port\n+        ip6_port, // either in ipv6 host or port\n+        ip6_host, // are in an ipv6 host\n+        in_host, // are in a host - may be ipv6, but don't know yet\n+        in_port // are in port\n+    }\n+    enum input {\n+        digit, // all digits\n+        hex, // digits and letters a-f\n+        unreserved // all other legal characters in usernames, passwords, hosts\n+    }\n+    let len = str::len(rawurl);\n+    let mut st : state = start;\n+    let mut in : input = digit; // most restricted, start here.\n+\n+    let mut userinfo : option<userinfo> = option::none;\n+    let mut host : ~str = ~\"\";\n+    let mut port : option::option<~str> = option::none;\n+\n+    let mut colon_count = 0;\n+    let mut pos : uint = 0, begin : uint = 2;\n+    let mut i : uint = 0;\n+\n+    let rdr = io::str_reader(rawurl);\n+    let mut c : char;\n+    while !rdr.eof() {\n+        c = rdr.read_byte() as char;\n+        i = rdr.tell() - 1; // we want base 0\n+\n+        if i < 2 { again; } // ignore the leading //\n+\n+        // deal with input class first\n+        alt c {\n+          '0' to '9' { }\n+          'A' to 'F' | 'a' to 'f' {\n+            if in == digit { \n+                in = hex; \n+            }\n+          }\n+          'G' to 'Z' | 'g' to 'z' | '-' | '.' | '_' | '~' | '%' |\n+          '&' |'\\'' | '(' | ')' | '+' | '!' | '*' | ',' | ';' | '=' {\n+            in = unreserved;\n+          }\n+          ':' | '@' | '?' | '#' | '/' {\n+            // separators, don't change anything\n+          }\n+          _ {\n+            return result::err(@~\"Illegal character in authority\");\n+          }\n+        }\n+\n+        // now state machine        \n+        alt c {\n+          ':' {\n+            colon_count += 1;\n+            alt st {\n+              start {\n+                pos = i;\n+                st = pass_host_port;\n+              }\n+              pass_host_port {\n+                // multiple colons means ipv6 address.\n+                if in == unreserved {\n+                    return result::err(@~\"Illegal characters in IPv6 address.\");\n+                }\n+                st = ip6_host;\n+              }\n+              in_host {\n+                pos = i;\n+                // can't be sure whether this is an ipv6 address or a port\n+                if in == unreserved {\n+                    return result::err(@~\"Illegal characters in authority.\");\n+                }\n+                st = ip6_port;\n+              }\n+              ip6_port {\n+                if in == unreserved {\n+                    return result::err(@~\"Illegal characters in authority.\");\n+                }\n+                st = ip6_host;\n+              }\n+              ip6_host {\n+                if colon_count > 7 {\n+                    host = str::slice(rawurl, begin, i);\n+                    pos = i;\n+                    st = in_port;\n+                }\n+              }\n+              _ {\n+                return result::err(@~\"Invalid ':' in authority.\");\n+              }\n+            }\n+            in = digit; // reset input class\n+          }\n+\n+          '@' {\n+            in = digit; // reset input class\n+            colon_count = 0; // reset count\n+            alt st {\n+              start {\n+                let user = str::slice(rawurl, begin, i);\n+                userinfo = option::some({user : user, \n+                                         pass: option::none});\n+                st = in_host;\n+              }\n+              pass_host_port {\n+                let user = str::slice(rawurl, begin, pos);\n+                let pass = str::slice(rawurl, pos+1, i);\n+                userinfo = option::some({user: user, \n+                                         pass: option::some(pass)});\n+                st = in_host;\n+              }\n+              _ {\n+                return result::err(@~\"Invalid '@' in authority.\");\n+              }\n+            }\n+            begin = i+1;\n+          }\n+          \n+          '?' | '#' | '/' {\n+            break;\n+          }\n+          _ { }\n+        }\n+    }\n+\n+    // finish up\n+    alt st {\n+      start {\n+        if i+1 == len {\n+            host = str::slice(rawurl, begin, i+1);\n+        } else {\n+            host = str::slice(rawurl, begin, i);\n+        }\n+      }\n+      pass_host_port | ip6_port {\n+        if in != digit {\n+            return result::err(@~\"Non-digit characters in port.\");\n+        }\n+        host = str::slice(rawurl, begin, pos);\n+        port = option::some(str::slice(rawurl, pos+1, i));\n+      }\n+      ip6_host | in_host {\n+        host = str::slice(rawurl, begin, i);\n+      }\n+      in_port {\n+        if in != digit {\n+            return result::err(@~\"Non-digit characters in port.\");\n+        }\n+        port = option::some(str::slice(rawurl, pos+1, i));\n+      }\n+    }\n+\n+    let rest = if i+1 == len { ~\"\" } \n+    else { str::slice(rawurl, i, len) };\n+    return result::ok((userinfo, host, port, rest));\n+}\n+\n+\n+// returns the path and unparsed part of url, or an error\n+fn get_path(rawurl: ~str, authority : bool) -> \n+    result::result<(~str, ~str), @~str> {\n+    let len = str::len(rawurl);\n+    let mut end = len;\n+    for str::each_chari(rawurl) |i,c| {\n+        alt c {\n+          'A' to 'Z' | 'a' to 'z' | '0' to '9' | '&' |'\\'' | '(' | ')' | '.'\n+          | '@' | ':' | '%' | '/' | '+' | '!' | '*' | ',' | ';' | '=' {\n+            again;\n+          }\n+          '?' | '#' {\n+            end = i;\n+            break;\n+          }\n+          _ { return result::err(@~\"Invalid character in path.\") }\n+        }\n+    }\n+\n+    if authority {\n+        if end != 0 && !str::starts_with(rawurl, ~\"/\") {\n+            return result::err(@~\"Non-empty path must begin with\\\n+                               '/' in presence of authority.\");\n+        }\n+    }\n+    \n+    return result::ok((decode_component(str::slice(rawurl, 0, end)), \n+                    str::slice(rawurl, end, len)));\n+}\n+\n+// returns the parsed query and the fragment, if present\n+fn get_query_fragment(rawurl: ~str) -> \n+    result::result<(query, option<~str>), @~str> {\n+    if !str::starts_with(rawurl, ~\"?\") {\n+        if str::starts_with(rawurl, ~\"#\") {\n+            let f = decode_component(str::slice(rawurl, \n+                                                1, \n+                                                str::len(rawurl)));\n+            return result::ok((~[], option::some(f)));\n+        } else {\n+            return result::ok((~[], option::none));\n+        }\n+    }\n+    let (q, r) = split_char_first(str::slice(rawurl, 1, \n+                                             str::len(rawurl)), '#');\n+    let f = if str::len(r) != 0 { \n+        option::some(decode_component(r)) } else { option::none };\n+    return result::ok((query_from_str(q), f));\n+}\n+\n /**\n  * Parse a `str` to a `url`\n  *\n@@ -365,37 +587,37 @@ fn get_scheme(rawurl: ~str) -> result::result<(~str, ~str), @~str> {\n  */\n \n fn from_str(rawurl: ~str) -> result::result<url, ~str> {\n+    // scheme\n     let mut schm = get_scheme(rawurl);\n     if result::is_err(schm) {\n         return result::err(copy *result::get_err(schm));\n     }\n     let (scheme, rest) = result::unwrap(schm);\n-    let (u, rest) = split_char_first(rest, '@');\n-    let user = if str::len(rest) == 0 {\n-        option::none\n-    } else {\n-        option::some(userinfo_from_str(u))\n-    };\n-    let rest = if str::len(rest) == 0 {\n-         u\n-    } else {\n-        rest\n-    };\n-    let (rest, frag) = split_char_first(rest, '#');\n-    let fragment = if str::len(frag) == 0 {\n-        option::none\n-    } else {\n-        option::some(frag)\n-    };\n-    let (rest, query) = split_char_first(rest, '?');\n-    let query = query_from_str(query);\n-    let (host, pth) = split_char_first(rest, '/');\n-    let mut path = decode_component(pth);\n-    if str::len(path) != 0 {\n-        str::unshift_char(path, '/');\n+\n+    // authority\n+    let mut auth = get_authority(rest);\n+    if result::is_err(auth) {\n+        return result::err(copy *result::get_err(auth));\n+    }\n+    let (userinfo, host, port, rest) = result::unwrap(auth);\n+\n+    // path\n+    let has_authority = if host == ~\"\" { false } else { true };\n+    let mut pth = get_path(rest, has_authority);\n+    if result::is_err(pth) {\n+        return result::err(copy *result::get_err(pth));\n+    } \n+    let (path, rest) = result::unwrap(pth);\n+\n+    // query and fragment\n+    let mut qry = get_query_fragment(rest);\n+    if result::is_err(qry) {\n+        return result::err(copy *result::get_err(qry));\n     }\n+    let (query, fragment) = result::unwrap(qry);\n \n-    return result::ok(url(scheme, user, host, path, query, fragment));\n+    return result::ok(url(scheme, userinfo, host, \n+                       port, path, query, fragment));\n }\n \n /**\n@@ -425,7 +647,7 @@ fn to_str(url: url) -> ~str {\n         str::concat(~[~\"?\", query_to_str(url.query)])\n     };\n     let fragment = if option::is_some(url.fragment) {\n-        str::concat(~[~\"#\", option::unwrap(copy url.fragment)])\n+        str::concat(~[~\"#\", encode_component(option::unwrap(copy url.fragment))])\n     } else {\n         ~\"\"\n     };\n@@ -452,12 +674,91 @@ mod tests {\n         let (u,v) = split_char_first(~\"hello, sweet world\", ',');\n         assert u == ~\"hello\";\n         assert v == ~\" sweet world\";\n+        \n+        let (u,v) = split_char_first(~\"hello sweet world\", ',');\n+        assert u == ~\"hello sweet world\";\n+        assert v == ~\"\";\n+    }\n+\n+    #[test]\n+    fn test_get_authority() {\n+        let (u, h, p, r) = result::unwrap(get_authority(\n+            ~\"//user:pass@rust-lang.org/something\"));\n+        assert u == option::some({user: ~\"user\", \n+                                  pass: option::some(~\"pass\")});\n+        assert h == ~\"rust-lang.org\";\n+        assert option::is_none(p);\n+        assert r == ~\"/something\";\n+\n+        let (u, h, p, r) = result::unwrap(get_authority(\n+            ~\"//rust-lang.org:8000?something\"));\n+        assert option::is_none(u);\n+        assert h == ~\"rust-lang.org\";\n+        assert p == option::some(~\"8000\");\n+        assert r == ~\"?something\";\n+        \n+        let (u, h, p, r) = result::unwrap(get_authority(\n+            ~\"//rust-lang.org#blah\"));\n+        assert option::is_none(u);\n+        assert h == ~\"rust-lang.org\";\n+        assert option::is_none(p);\n+        assert r == ~\"#blah\";\n+\n+        // ipv6 tests\n+        let (_, h, _, _) = result::unwrap(get_authority(\n+            ~\"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\"));\n+        assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n+\n+        let (_, h, p, _) = result::unwrap(get_authority(\n+            ~\"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"));\n+        assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n+        assert p == option::some(~\"8000\");\n+\n+        let (u, h, p, _) = result::unwrap(get_authority(\n+            ~\"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"));\n+        assert u == option::some({user: ~\"us\", pass : option::some(~\"p\")});\n+        assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n+        assert p == option::some(~\"8000\");        \n+\n+        // invalid authorities; \n+        assert result::is_err(get_authority(~\"//user:pass@rust-lang:something\"));        \n+        assert result::is_err(get_authority(~\"//user@rust-lang:something:/path\"));\n+        assert result::is_err(get_authority(\n+            ~\"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\"));\n+        assert result::is_err(get_authority(\n+            ~\"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\"));\n+\n+        // these parse as empty, because they don't start with '//'\n+        let (_, h, _, _) = result::unwrap(get_authority(~\"user:pass@rust-lang\"));\n+        assert h == ~\"\";\n+        let (_, h, _, _) = result::unwrap(get_authority(~\"rust-lang.org\"));\n+        assert h == ~\"\";\n+\n+    }\n+\n+    #[test]\n+    fn test_get_path() {\n+        let (p, r) = result::unwrap(get_path(~\"/something+%20orother\", true));\n+        assert p == ~\"/something+ orother\";\n+        assert r == ~\"\";\n+        let (p, r) = result::unwrap(get_path(~\"test@email.com#fragment\", false));\n+        assert p == ~\"test@email.com\";\n+        assert r == ~\"#fragment\";\n+        let (p, r) = result::unwrap(get_path(~\"/gen/:addr=?q=v\", false));\n+        assert p == ~\"/gen/:addr=\";\n+        assert r == ~\"?q=v\";\n+        \n+        //failure cases\n+        assert result::is_err(get_path(~\"something?q\", true));\n+        \n     }\n \n     #[test]\n     fn test_url_parse() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n-        let u = result::unwrap(from_str(url));\n+        \n+        let up = from_str(url);\n+        let u = result::unwrap(up);\n         assert u.scheme == ~\"http\";\n         assert option::unwrap(copy u.user).user == ~\"user\";\n         assert option::unwrap(copy option::unwrap(copy u.user).pass) == ~\"pass\";"}]}