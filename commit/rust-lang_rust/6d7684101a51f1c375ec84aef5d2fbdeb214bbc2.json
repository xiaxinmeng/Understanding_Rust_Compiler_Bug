{"sha": "6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "node_id": "C_kwDOAAsO6NoAKDZkNzY4NDEwMWE1MWYxYzM3NWVjODRhZWY1ZDJmYmRlYjIxNGJiYzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-04T00:27:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-04T00:27:23Z"}, "message": "Auto merge of #94009 - compiler-errors:gat-rustdoc, r=GuillaumeGomez\n\nSupport GATs in Rustdoc\n\nImplements:\n1. Rendering GATs in trait definitions and impl blocks\n2. Rendering GATs in types (e.g. in the return type of a function)\n\nFixes #92341\n\nThis is my first rustdoc PR, so I have absolutely no idea how to produce tests for this. Advice from the rustdoc team would be wonderful!\n\nI tested locally and things looked correct:\n![image](https://user-images.githubusercontent.com/3674314/153988325-9732cbf3-0645-4e1a-9e64-ddfd93877b55.png)", "tree": {"sha": "d86722eb5dda8ae7ef9980dd4a19deebb9f37cf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d86722eb5dda8ae7ef9980dd4a19deebb9f37cf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "html_url": "https://github.com/rust-lang/rust/commit/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee", "html_url": "https://github.com/rust-lang/rust/commit/40d3040ae19b8c43c0027bc6d3e9805e5ee5e0ee"}, {"sha": "0e57a16c88cbb042bf4d19934e0ccdd3838645ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e57a16c88cbb042bf4d19934e0ccdd3838645ec", "html_url": "https://github.com/rust-lang/rust/commit/0e57a16c88cbb042bf4d19934e0ccdd3838645ec"}], "stats": {"total": 539, "additions": 363, "deletions": 176}, "files": [{"sha": "62f3527525e0e49bf2bbf32841683d6e2bb2028a", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -546,11 +546,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 }\n                 WherePredicate::EqPredicate { lhs, rhs } => {\n                     match lhs {\n-                        Type::QPath { name: left_name, ref self_type, ref trait_, .. } => {\n+                        Type::QPath { ref assoc, ref self_type, ref trait_, .. } => {\n                             let ty = &*self_type;\n                             let mut new_trait = trait_.clone();\n \n-                            if self.is_fn_trait(trait_) && left_name == sym::Output {\n+                            if self.is_fn_trait(trait_) && assoc.name == sym::Output {\n                                 ty_to_fn\n                                     .entry(*ty.clone())\n                                     .and_modify(|e| {\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                 // to 'T: Iterator<Item=u8>'\n                                 GenericArgs::AngleBracketed { ref mut bindings, .. } => {\n                                     bindings.push(TypeBinding {\n-                                        name: left_name,\n+                                        assoc: *assoc.clone(),\n                                         kind: TypeBindingKind::Equality { term: rhs },\n                                     });\n                                 }"}, {"sha": "2e66db425d611298ac38ef5291e4d6d3fd5ddb9f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -636,7 +636,7 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n \n     g.where_predicates.retain(|pred| match pred {\n         clean::WherePredicate::BoundPredicate {\n-            ty: clean::QPath { self_type: box clean::Generic(ref s), trait_, name: _, .. },\n+            ty: clean::QPath { self_type: box clean::Generic(ref s), trait_, .. },\n             bounds,\n             ..\n         } => !(bounds.is_empty() || *s == kw::SelfUpper && trait_.def_id() == trait_did),"}, {"sha": "0d1482ce47017313c89346a5cbc2d12d0bb96b66", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 117, "deletions": 44, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -388,14 +388,35 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n         let trait_ = lifted.trait_ref(cx.tcx).clean(cx);\n         let self_type = self.self_ty().clean(cx);\n         Type::QPath {\n-            name: cx.tcx.associated_item(self.item_def_id).name,\n+            assoc: Box::new(projection_to_path_segment(*self, cx)),\n             self_def_id: self_type.def_id(&cx.cache),\n             self_type: box self_type,\n             trait_,\n         }\n     }\n }\n \n+fn projection_to_path_segment(ty: ty::ProjectionTy<'_>, cx: &mut DocContext<'_>) -> PathSegment {\n+    let item = cx.tcx.associated_item(ty.item_def_id);\n+    let generics = cx.tcx.generics_of(ty.item_def_id);\n+    PathSegment {\n+        name: item.name,\n+        args: GenericArgs::AngleBracketed {\n+            args: ty.substs[generics.parent_count..]\n+                .iter()\n+                .map(|ty| match ty.unpack() {\n+                    ty::subst::GenericArgKind::Lifetime(lt) => {\n+                        GenericArg::Lifetime(lt.clean(cx).unwrap())\n+                    }\n+                    ty::subst::GenericArgKind::Type(ty) => GenericArg::Type(ty.clean(cx)),\n+                    ty::subst::GenericArgKind::Const(c) => GenericArg::Const(Box::new(c.clean(cx))),\n+                })\n+                .collect(),\n+            bindings: Default::default(),\n+        },\n+    }\n+}\n+\n impl Clean<GenericParamDef> for ty::GenericParamDef {\n     fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n@@ -601,8 +622,8 @@ fn clean_ty_generics(\n         })\n         .collect::<Vec<GenericParamDef>>();\n \n-    // param index -> [(DefId of trait, associated type name, type)]\n-    let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, Symbol, Ty<'_>)>>::default();\n+    // param index -> [(DefId of trait, associated type name and generics, type)]\n+    let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, PathSegment, Ty<'_>)>>::default();\n \n     let where_predicates = preds\n         .predicates\n@@ -648,8 +669,9 @@ fn clean_ty_generics(\n \n                     let proj = projection\n                         .map(|p| (p.skip_binder().projection_ty.clean(cx), p.skip_binder().term));\n-                    if let Some(((_, trait_did, name), rhs)) =\n-                        proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n+                    if let Some(((_, trait_did, name), rhs)) = proj\n+                        .as_ref()\n+                        .and_then(|(lhs, rhs): &(Type, _)| Some((lhs.projection()?, rhs)))\n                     {\n                         // FIXME(...): Remove this unwrap()\n                         impl_trait_proj.entry(param_idx).or_default().push((\n@@ -992,9 +1014,10 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     TyMethodItem(t)\n                 }\n                 hir::TraitItemKind::Type(bounds, ref default) => {\n+                    let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n                     let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n                     let default = default.map(|t| t.clean(cx));\n-                    AssocTypeItem(bounds, default)\n+                    AssocTypeItem(Box::new(generics), bounds, default)\n                 }\n             };\n             let what_rustc_thinks =\n@@ -1026,15 +1049,9 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                 }\n                 hir::ImplItemKind::TyAlias(ref hir_ty) => {\n                     let type_ = hir_ty.clean(cx);\n+                    let generics = self.generics.clean(cx);\n                     let item_type = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n-                    TypedefItem(\n-                        Typedef {\n-                            type_,\n-                            generics: Generics::default(),\n-                            item_type: Some(item_type),\n-                        },\n-                        true,\n-                    )\n+                    TypedefItem(Typedef { type_, generics, item_type: Some(item_type) }, true)\n                 }\n             };\n \n@@ -1140,35 +1157,79 @@ impl Clean<Item> for ty::AssocItem {\n             ty::AssocKind::Type => {\n                 let my_name = self.name;\n \n+                fn param_eq_arg(param: &GenericParamDef, arg: &GenericArg) -> bool {\n+                    match (&param.kind, arg) {\n+                        (GenericParamDefKind::Type { .. }, GenericArg::Type(Type::Generic(ty)))\n+                            if *ty == param.name =>\n+                        {\n+                            true\n+                        }\n+                        (\n+                            GenericParamDefKind::Lifetime { .. },\n+                            GenericArg::Lifetime(Lifetime(lt)),\n+                        ) if *lt == param.name => true,\n+                        (GenericParamDefKind::Const { .. }, GenericArg::Const(c)) => {\n+                            match &c.kind {\n+                                ConstantKind::TyConst { expr } => expr == param.name.as_str(),\n+                                _ => false,\n+                            }\n+                        }\n+                        _ => false,\n+                    }\n+                }\n+\n                 if let ty::TraitContainer(_) = self.container {\n                     let bounds = tcx.explicit_item_bounds(self.def_id);\n                     let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n-                    let generics = clean_ty_generics(cx, tcx.generics_of(self.def_id), predicates);\n+                    let mut generics =\n+                        clean_ty_generics(cx, tcx.generics_of(self.def_id), predicates);\n+                    // Filter out the bounds that are (likely?) directly attached to the associated type,\n+                    // as opposed to being located in the where clause.\n                     let mut bounds = generics\n                         .where_predicates\n-                        .iter()\n-                        .filter_map(|pred| {\n-                            let (name, self_type, trait_, bounds) = match *pred {\n-                                WherePredicate::BoundPredicate {\n-                                    ty: QPath { ref name, ref self_type, ref trait_, .. },\n-                                    ref bounds,\n-                                    ..\n-                                } => (name, self_type, trait_, bounds),\n-                                _ => return None,\n-                            };\n-                            if *name != my_name {\n-                                return None;\n-                            }\n-                            if trait_.def_id() != self.container.id() {\n-                                return None;\n+                        .drain_filter(|pred| match *pred {\n+                            WherePredicate::BoundPredicate {\n+                                ty: QPath { ref assoc, ref self_type, ref trait_, .. },\n+                                ..\n+                            } => {\n+                                if assoc.name != my_name {\n+                                    return false;\n+                                }\n+                                if trait_.def_id() != self.container.id() {\n+                                    return false;\n+                                }\n+                                match **self_type {\n+                                    Generic(ref s) if *s == kw::SelfUpper => {}\n+                                    _ => return false,\n+                                }\n+                                match &assoc.args {\n+                                    GenericArgs::AngleBracketed { args, bindings } => {\n+                                        if !bindings.is_empty()\n+                                            || generics\n+                                                .params\n+                                                .iter()\n+                                                .zip(args)\n+                                                .any(|(param, arg)| !param_eq_arg(param, arg))\n+                                        {\n+                                            return false;\n+                                        }\n+                                    }\n+                                    GenericArgs::Parenthesized { .. } => {\n+                                        // The only time this happens is if we're inside the rustdoc for Fn(),\n+                                        // which only has one associated type, which is not a GAT, so whatever.\n+                                    }\n+                                }\n+                                true\n                             }\n-                            match **self_type {\n-                                Generic(ref s) if *s == kw::SelfUpper => {}\n-                                _ => return None,\n+                            _ => false,\n+                        })\n+                        .flat_map(|pred| {\n+                            if let WherePredicate::BoundPredicate { bounds, .. } = pred {\n+                                bounds\n+                            } else {\n+                                unreachable!()\n                             }\n-                            Some(bounds)\n                         })\n-                        .flat_map(|i| i.iter().cloned())\n                         .collect::<Vec<_>>();\n                     // Our Sized/?Sized bound didn't get handled when creating the generics\n                     // because we didn't actually get our whole set of bounds until just now\n@@ -1188,7 +1249,7 @@ impl Clean<Item> for ty::AssocItem {\n                         None\n                     };\n \n-                    AssocTypeItem(bounds, ty.map(|t| t.clean(cx)))\n+                    AssocTypeItem(Box::new(generics), bounds, ty.map(|t| t.clean(cx)))\n                 } else {\n                     // FIXME: when could this happen? Associated items in inherent impls?\n                     let type_ = tcx.type_of(self.def_id).clean(cx);\n@@ -1259,7 +1320,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n             };\n             register_res(cx, trait_.res);\n             Type::QPath {\n-                name: p.segments.last().expect(\"segments were empty\").ident.name,\n+                assoc: Box::new(p.segments.last().expect(\"segments were empty\").clean(cx)),\n                 self_def_id: Some(DefId::local(qself.hir_id.owner.local_def_index)),\n                 self_type: box qself.clean(cx),\n                 trait_,\n@@ -1276,7 +1337,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n             let trait_ = hir::Path { span, res, segments: &[] }.clean(cx);\n             register_res(cx, trait_.res);\n             Type::QPath {\n-                name: segment.ident.name,\n+                assoc: Box::new(segment.clean(cx)),\n                 self_def_id: res.opt_def_id(),\n                 self_type: box qself.clean(cx),\n                 trait_,\n@@ -1548,7 +1609,16 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let mut bindings = vec![];\n                 for pb in obj.projection_bounds() {\n                     bindings.push(TypeBinding {\n-                        name: cx.tcx.associated_item(pb.item_def_id()).name,\n+                        assoc: projection_to_path_segment(\n+                            pb.skip_binder()\n+                                .lift_to_tcx(cx.tcx)\n+                                .unwrap()\n+                                // HACK(compiler-errors): Doesn't actually matter what self\n+                                // type we put here, because we're only using the GAT's substs.\n+                                .with_self_ty(cx.tcx, cx.tcx.types.self_param)\n+                                .projection_ty,\n+                            cx,\n+                        ),\n                         kind: TypeBindingKind::Equality { term: pb.skip_binder().term.clean(cx) },\n                     });\n                 }\n@@ -1614,10 +1684,10 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                         == trait_ref.skip_binder()\n                                     {\n                                         Some(TypeBinding {\n-                                            name: cx\n-                                                .tcx\n-                                                .associated_item(proj.projection_ty.item_def_id)\n-                                                .name,\n+                                            assoc: projection_to_path_segment(\n+                                                proj.projection_ty,\n+                                                cx,\n+                                            ),\n                                             kind: TypeBindingKind::Equality {\n                                                 term: proj.term.clean(cx),\n                                             },\n@@ -2160,7 +2230,10 @@ fn clean_maybe_renamed_foreign_item(\n \n impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> TypeBinding {\n-        TypeBinding { name: self.ident.name, kind: self.kind.clean(cx) }\n+        TypeBinding {\n+            assoc: PathSegment { name: self.ident.name, args: self.gen_args.clean(cx) },\n+            kind: self.kind.clean(cx),\n+        }\n     }\n }\n "}, {"sha": "dd8e1132572fc6a1c728fd430fafafe08a35d6b9", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -89,7 +89,7 @@ crate fn merge_bounds(\n     cx: &clean::DocContext<'_>,\n     bounds: &mut Vec<clean::GenericBound>,\n     trait_did: DefId,\n-    name: Symbol,\n+    assoc: clean::PathSegment,\n     rhs: &clean::Term,\n ) -> bool {\n     !bounds.iter_mut().any(|b| {\n@@ -107,7 +107,7 @@ crate fn merge_bounds(\n         match last.args {\n             PP::AngleBracketed { ref mut bindings, .. } => {\n                 bindings.push(clean::TypeBinding {\n-                    name,\n+                    assoc: assoc.clone(),\n                     kind: clean::TypeBindingKind::Equality { term: rhs.clone() },\n                 });\n             }"}, {"sha": "78928fb4059bad35a3a9fa8a0f60cab4088e0e9c", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -683,7 +683,7 @@ crate enum ItemKind {\n     ///\n     /// The bounds may be non-empty if there is a `where` clause.\n     /// The `Option<Type>` is the default concrete type (e.g. `trait Trait { type Target = usize; }`)\n-    AssocTypeItem(Vec<GenericBound>, Option<Type>),\n+    AssocTypeItem(Box<Generics>, Vec<GenericBound>, Option<Type>),\n     /// An item that has been stripped by a rustdoc pass\n     StrippedItem(Box<ItemKind>),\n     KeywordItem(Symbol),\n@@ -721,7 +721,7 @@ impl ItemKind {\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n             | AssocConstItem(_, _)\n-            | AssocTypeItem(_, _)\n+            | AssocTypeItem(..)\n             | StrippedItem(_)\n             | KeywordItem(_) => [].iter(),\n         }\n@@ -1397,7 +1397,7 @@ crate enum Type {\n \n     /// A qualified path to an associated item: `<Type as Trait>::Name`\n     QPath {\n-        name: Symbol,\n+        assoc: Box<PathSegment>,\n         self_type: Box<Type>,\n         /// FIXME: This is a hack that should be removed; see [this discussion][1].\n         ///\n@@ -1415,7 +1415,7 @@ crate enum Type {\n \n // `Type` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Type, 72);\n+rustc_data_structures::static_assert_size!(Type, 80);\n \n impl Type {\n     /// When comparing types for equality, it can help to ignore `&` wrapping.\n@@ -1505,12 +1505,12 @@ impl Type {\n         self.primitive_type().is_some()\n     }\n \n-    crate fn projection(&self) -> Option<(&Type, DefId, Symbol)> {\n-        let (self_, trait_, name) = match self {\n-            QPath { self_type, trait_, name, .. } => (self_type, trait_, name),\n+    crate fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n+        let (self_, trait_, assoc) = match self {\n+            QPath { self_type, trait_, assoc, .. } => (self_type, trait_, assoc),\n             _ => return None,\n         };\n-        Some((&self_, trait_.def_id(), *name))\n+        Some((&self_, trait_.def_id(), *assoc.clone()))\n     }\n \n     fn inner_def_id(&self, cache: Option<&Cache>) -> Option<DefId> {\n@@ -2018,7 +2018,7 @@ crate enum GenericArg {\n // `GenericArg` can occur many times in a single `Path`, so make sure it\n // doesn't increase in size unexpectedly.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(GenericArg, 80);\n+rustc_data_structures::static_assert_size!(GenericArg, 88);\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate enum GenericArgs {\n@@ -2256,7 +2256,7 @@ crate struct ProcMacro {\n /// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate struct TypeBinding {\n-    crate name: Symbol,\n+    crate assoc: PathSegment,\n     crate kind: TypeBindingKind,\n }\n "}, {"sha": "fbb8b572ea43025a54fba2e5a71debace19f275f", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -86,7 +86,7 @@ crate trait DocFolder: Sized {\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n             | AssocConstItem(_, _)\n-            | AssocTypeItem(_, _)\n+            | AssocTypeItem(..)\n             | KeywordItem(_) => kind,\n         }\n     }"}, {"sha": "78965712dfa1843f98f5cc91534b4e04e7a3a92f", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -961,7 +961,7 @@ fn fmt_type<'cx>(\n                 write!(f, \"impl {}\", print_generic_bounds(bounds, cx))\n             }\n         }\n-        clean::QPath { ref name, ref self_type, ref trait_, ref self_def_id } => {\n+        clean::QPath { ref assoc, ref self_type, ref trait_, ref self_def_id } => {\n             let should_show_cast = !trait_.segments.is_empty()\n                 && self_def_id\n                     .zip(Some(trait_.def_id()))\n@@ -994,14 +994,15 @@ fn fmt_type<'cx>(\n                     write!(\n                         f,\n                         \"<a class=\\\"associatedtype\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n-                                    title=\\\"type {path}::{name}\\\">{name}</a>\",\n+                                    title=\\\"type {path}::{name}\\\">{name}</a>{args}\",\n                         url = url,\n                         shortty = ItemType::AssocType,\n-                        name = name,\n+                        name = assoc.name,\n                         path = join_with_double_colon(path),\n+                        args = assoc.args.print(cx),\n                     )?;\n                 }\n-                _ => write!(f, \"{}\", name)?,\n+                _ => write!(f, \"{}{:#}\", assoc.name, assoc.args.print(cx))?,\n             }\n             Ok(())\n         }\n@@ -1457,7 +1458,12 @@ impl clean::TypeBinding {\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n-            f.write_str(self.name.as_str())?;\n+            f.write_str(self.assoc.name.as_str())?;\n+            if f.alternate() {\n+                write!(f, \"{:#}\", self.assoc.args.print(cx))?;\n+            } else {\n+                write!(f, \"{}\", self.assoc.args.print(cx))?;\n+            }\n             match self.kind {\n                 clean::TypeBindingKind::Equality { ref term } => {\n                     if f.alternate() {"}, {"sha": "558dbb3b3965a5e6dd4b968e39c7e36f17cb65bd", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 124, "deletions": 102, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -773,27 +773,115 @@ fn assoc_const(\n fn assoc_type(\n     w: &mut Buffer,\n     it: &clean::Item,\n+    generics: &clean::Generics,\n     bounds: &[clean::GenericBound],\n     default: Option<&clean::Type>,\n     link: AssocItemLink<'_>,\n-    extra: &str,\n+    indent: usize,\n     cx: &Context<'_>,\n ) {\n     write!(\n         w,\n-        \"{}type <a href=\\\"{}\\\" class=\\\"associatedtype\\\">{}</a>\",\n-        extra,\n-        naive_assoc_href(it, link, cx),\n-        it.name.as_ref().unwrap()\n+        \"{indent}type <a href=\\\"{href}\\\" class=\\\"associatedtype\\\">{name}</a>{generics}\",\n+        indent = \" \".repeat(indent),\n+        href = naive_assoc_href(it, link, cx),\n+        name = it.name.as_ref().unwrap(),\n+        generics = generics.print(cx),\n     );\n     if !bounds.is_empty() {\n         write!(w, \": {}\", print_generic_bounds(bounds, cx))\n     }\n+    write!(w, \"{}\", print_where_clause(generics, cx, indent, false));\n     if let Some(default) = default {\n         write!(w, \" = {}\", default.print(cx))\n     }\n }\n \n+fn assoc_method(\n+    w: &mut Buffer,\n+    meth: &clean::Item,\n+    header: hir::FnHeader,\n+    g: &clean::Generics,\n+    d: &clean::FnDecl,\n+    link: AssocItemLink<'_>,\n+    parent: ItemType,\n+    cx: &Context<'_>,\n+    render_mode: RenderMode,\n+) {\n+    let name = meth.name.as_ref().unwrap();\n+    let href = match link {\n+        AssocItemLink::Anchor(Some(ref id)) => Some(format!(\"#{}\", id)),\n+        AssocItemLink::Anchor(None) => Some(format!(\"#{}.{}\", meth.type_(), name)),\n+        AssocItemLink::GotoSource(did, provided_methods) => {\n+            // We're creating a link from an impl-item to the corresponding\n+            // trait-item and need to map the anchored type accordingly.\n+            let ty =\n+                if provided_methods.contains(name) { ItemType::Method } else { ItemType::TyMethod };\n+\n+            match (href(did.expect_def_id(), cx), ty) {\n+                (Ok(p), ty) => Some(format!(\"{}#{}.{}\", p.0, ty, name)),\n+                (Err(HrefError::DocumentationNotBuilt), ItemType::TyMethod) => None,\n+                (Err(_), ty) => Some(format!(\"#{}.{}\", ty, name)),\n+            }\n+        }\n+    };\n+    let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n+    // FIXME: Once https://github.com/rust-lang/rust/issues/67792 is implemented, we can remove\n+    // this condition.\n+    let constness = match render_mode {\n+        RenderMode::Normal => {\n+            print_constness_with_space(&header.constness, meth.const_stability(cx.tcx()))\n+        }\n+        RenderMode::ForDeref { .. } => \"\",\n+    };\n+    let asyncness = header.asyncness.print_with_space();\n+    let unsafety = header.unsafety.print_with_space();\n+    let defaultness = print_default_space(meth.is_default());\n+    let abi = print_abi_with_space(header.abi).to_string();\n+\n+    // NOTE: `{:#}` does not print HTML formatting, `{}` does. So `g.print` can't be reused between the length calculation and `write!`.\n+    let generics_len = format!(\"{:#}\", g.print(cx)).len();\n+    let mut header_len = \"fn \".len()\n+        + vis.len()\n+        + constness.len()\n+        + asyncness.len()\n+        + unsafety.len()\n+        + defaultness.len()\n+        + abi.len()\n+        + name.as_str().len()\n+        + generics_len;\n+\n+    let (indent, indent_str, end_newline) = if parent == ItemType::Trait {\n+        header_len += 4;\n+        let indent_str = \"    \";\n+        render_attributes_in_pre(w, meth, indent_str);\n+        (4, indent_str, false)\n+    } else {\n+        render_attributes_in_code(w, meth);\n+        (0, \"\", true)\n+    };\n+    w.reserve(header_len + \"<a href=\\\"\\\" class=\\\"fnname\\\">{\".len() + \"</a>\".len());\n+    write!(\n+        w,\n+        \"{indent}{vis}{constness}{asyncness}{unsafety}{defaultness}{abi}fn <a {href} class=\\\"fnname\\\">{name}</a>\\\n+         {generics}{decl}{notable_traits}{where_clause}\",\n+        indent = indent_str,\n+        vis = vis,\n+        constness = constness,\n+        asyncness = asyncness,\n+        unsafety = unsafety,\n+        defaultness = defaultness,\n+        abi = abi,\n+        // links without a href are valid - https://www.w3schools.com/tags/att_a_href.asp\n+        href = href.map(|href| format!(\"href=\\\"{}\\\"\", href)).unwrap_or_else(|| \"\".to_string()),\n+        name = name,\n+        generics = g.print(cx),\n+        decl = d.full_print(header_len, indent, header.asyncness, cx),\n+        notable_traits = notable_traits_decl(d, cx),\n+        where_clause = print_where_clause(g, cx, indent, end_newline),\n+    )\n+}\n+\n /// Writes a span containing the versions at which an item became stable and/or const-stable. For\n /// example, if the item became stable at 1.0.0, and const-stable at 1.45.0, this function would\n /// write a span containing \"1.0.0 (const: 1.45.0)\".\n@@ -875,111 +963,25 @@ fn render_assoc_item(\n     cx: &Context<'_>,\n     render_mode: RenderMode,\n ) {\n-    fn method(\n-        w: &mut Buffer,\n-        meth: &clean::Item,\n-        header: hir::FnHeader,\n-        g: &clean::Generics,\n-        d: &clean::FnDecl,\n-        link: AssocItemLink<'_>,\n-        parent: ItemType,\n-        cx: &Context<'_>,\n-        render_mode: RenderMode,\n-    ) {\n-        let name = meth.name.as_ref().unwrap();\n-        let href = match link {\n-            AssocItemLink::Anchor(Some(ref id)) => Some(format!(\"#{}\", id)),\n-            AssocItemLink::Anchor(None) => Some(format!(\"#{}.{}\", meth.type_(), name)),\n-            AssocItemLink::GotoSource(did, provided_methods) => {\n-                // We're creating a link from an impl-item to the corresponding\n-                // trait-item and need to map the anchored type accordingly.\n-                let ty = if provided_methods.contains(name) {\n-                    ItemType::Method\n-                } else {\n-                    ItemType::TyMethod\n-                };\n-\n-                match (href(did.expect_def_id(), cx), ty) {\n-                    (Ok(p), ty) => Some(format!(\"{}#{}.{}\", p.0, ty, name)),\n-                    (Err(HrefError::DocumentationNotBuilt), ItemType::TyMethod) => None,\n-                    (Err(_), ty) => Some(format!(\"#{}.{}\", ty, name)),\n-                }\n-            }\n-        };\n-        let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n-        // FIXME: Once https://github.com/rust-lang/rust/issues/67792 is implemented, we can remove\n-        // this condition.\n-        let constness = match render_mode {\n-            RenderMode::Normal => {\n-                print_constness_with_space(&header.constness, meth.const_stability(cx.tcx()))\n-            }\n-            RenderMode::ForDeref { .. } => \"\",\n-        };\n-        let asyncness = header.asyncness.print_with_space();\n-        let unsafety = header.unsafety.print_with_space();\n-        let defaultness = print_default_space(meth.is_default());\n-        let abi = print_abi_with_space(header.abi).to_string();\n-\n-        // NOTE: `{:#}` does not print HTML formatting, `{}` does. So `g.print` can't be reused between the length calculation and `write!`.\n-        let generics_len = format!(\"{:#}\", g.print(cx)).len();\n-        let mut header_len = \"fn \".len()\n-            + vis.len()\n-            + constness.len()\n-            + asyncness.len()\n-            + unsafety.len()\n-            + defaultness.len()\n-            + abi.len()\n-            + name.as_str().len()\n-            + generics_len;\n-\n-        let (indent, indent_str, end_newline) = if parent == ItemType::Trait {\n-            header_len += 4;\n-            let indent_str = \"    \";\n-            render_attributes_in_pre(w, meth, indent_str);\n-            (4, indent_str, false)\n-        } else {\n-            render_attributes_in_code(w, meth);\n-            (0, \"\", true)\n-        };\n-        w.reserve(header_len + \"<a href=\\\"\\\" class=\\\"fnname\\\">{\".len() + \"</a>\".len());\n-        write!(\n-            w,\n-            \"{indent}{vis}{constness}{asyncness}{unsafety}{defaultness}{abi}fn <a {href} class=\\\"fnname\\\">{name}</a>\\\n-             {generics}{decl}{notable_traits}{where_clause}\",\n-            indent = indent_str,\n-            vis = vis,\n-            constness = constness,\n-            asyncness = asyncness,\n-            unsafety = unsafety,\n-            defaultness = defaultness,\n-            abi = abi,\n-            // links without a href are valid - https://www.w3schools.com/tags/att_a_href.asp\n-            href = href.map(|href| format!(\"href=\\\"{}\\\"\", href)).unwrap_or_else(|| \"\".to_string()),\n-            name = name,\n-            generics = g.print(cx),\n-            decl = d.full_print(header_len, indent, header.asyncness, cx),\n-            notable_traits = notable_traits_decl(d, cx),\n-            where_clause = print_where_clause(g, cx, indent, end_newline),\n-        )\n-    }\n     match *item.kind {\n         clean::StrippedItem(..) => {}\n         clean::TyMethodItem(ref m) => {\n-            method(w, item, m.header, &m.generics, &m.decl, link, parent, cx, render_mode)\n+            assoc_method(w, item, m.header, &m.generics, &m.decl, link, parent, cx, render_mode)\n         }\n         clean::MethodItem(ref m, _) => {\n-            method(w, item, m.header, &m.generics, &m.decl, link, parent, cx, render_mode)\n+            assoc_method(w, item, m.header, &m.generics, &m.decl, link, parent, cx, render_mode)\n         }\n         clean::AssocConstItem(ref ty, _) => {\n             assoc_const(w, item, ty, link, if parent == ItemType::Trait { \"    \" } else { \"\" }, cx)\n         }\n-        clean::AssocTypeItem(ref bounds, ref default) => assoc_type(\n+        clean::AssocTypeItem(ref generics, ref bounds, ref default) => assoc_type(\n             w,\n             item,\n+            generics,\n             bounds,\n             default.as_ref(),\n             link,\n-            if parent == ItemType::Trait { \"    \" } else { \"\" },\n+            if parent == ItemType::Trait { 4 } else { 0 },\n             cx,\n         ),\n         _ => panic!(\"render_assoc_item called on non-associated-item\"),\n@@ -1283,7 +1285,16 @@ fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n                                 let empty_set = FxHashSet::default();\n                                 let src_link =\n                                     AssocItemLink::GotoSource(trait_did.into(), &empty_set);\n-                                assoc_type(&mut out, it, &[], Some(&tydef.type_), src_link, \"\", cx);\n+                                assoc_type(\n+                                    &mut out,\n+                                    it,\n+                                    &tydef.generics,\n+                                    &[],\n+                                    Some(&tydef.type_),\n+                                    src_link,\n+                                    0,\n+                                    cx,\n+                                );\n                                 out.push_str(\";</span>\");\n                             }\n                         }\n@@ -1462,10 +1473,11 @@ fn render_impl(\n                 assoc_type(\n                     w,\n                     item,\n-                    &Vec::new(),\n+                    &tydef.generics,\n+                    &[],\n                     Some(&tydef.type_),\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n-                    \"\",\n+                    0,\n                     cx,\n                 );\n                 w.write_str(\"</h4>\");\n@@ -1493,7 +1505,7 @@ fn render_impl(\n                 w.write_str(\"</h4>\");\n                 w.write_str(\"</section>\");\n             }\n-            clean::AssocTypeItem(ref bounds, ref default) => {\n+            clean::AssocTypeItem(ref generics, ref bounds, ref default) => {\n                 let source_id = format!(\"{}.{}\", item_type, name);\n                 let id = cx.derive_id(source_id.clone());\n                 write!(w, \"<section id=\\\"{}\\\" class=\\\"{}{}\\\">\", id, item_type, in_trait_class,);\n@@ -1502,10 +1514,11 @@ fn render_impl(\n                 assoc_type(\n                     w,\n                     item,\n+                    generics,\n                     bounds,\n                     default.as_ref(),\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n-                    \"\",\n+                    0,\n                     cx,\n                 );\n                 w.write_str(\"</h4>\");\n@@ -1726,7 +1739,16 @@ pub(crate) fn render_impl_summary(\n             for it in &i.inner_impl().items {\n                 if let clean::TypedefItem(ref tydef, _) = *it.kind {\n                     w.write_str(\"<span class=\\\"where fmt-newline\\\">  \");\n-                    assoc_type(w, it, &[], Some(&tydef.type_), AssocItemLink::Anchor(None), \"\", cx);\n+                    assoc_type(\n+                        w,\n+                        it,\n+                        &tydef.generics,\n+                        &[],\n+                        Some(&tydef.type_),\n+                        AssocItemLink::Anchor(None),\n+                        0,\n+                        cx,\n+                    );\n                     w.write_str(\";</span>\");\n                 }\n             }"}, {"sha": "4358dc8980f2f6b322903d99a5bb7faf40f240b1", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -154,7 +154,11 @@ impl FromWithTcx<clean::Constant> for Constant {\n \n impl FromWithTcx<clean::TypeBinding> for TypeBinding {\n     fn from_tcx(binding: clean::TypeBinding, tcx: TyCtxt<'_>) -> Self {\n-        TypeBinding { name: binding.name.to_string(), binding: binding.kind.into_tcx(tcx) }\n+        TypeBinding {\n+            name: binding.assoc.name.to_string(),\n+            args: binding.assoc.args.into_tcx(tcx),\n+            binding: binding.kind.into_tcx(tcx),\n+        }\n     }\n }\n \n@@ -222,8 +226,9 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n         AssocConstItem(ty, default) => {\n             ItemEnum::AssocConst { type_: ty.into_tcx(tcx), default: default.map(|c| c.expr(tcx)) }\n         }\n-        AssocTypeItem(g, t) => ItemEnum::AssocType {\n-            bounds: g.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+        AssocTypeItem(g, b, t) => ItemEnum::AssocType {\n+            generics: (*g).into_tcx(tcx),\n+            bounds: b.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n             default: t.map(|x| x.into_tcx(tcx)),\n         },\n         // `convert_item` early returns `None` for striped items\n@@ -444,11 +449,12 @@ impl FromWithTcx<clean::Type> for Type {\n                 mutable: mutability == ast::Mutability::Mut,\n                 type_: Box::new((*type_).into_tcx(tcx)),\n             },\n-            QPath { name, self_type, trait_, .. } => {\n+            QPath { assoc, self_type, trait_, .. } => {\n                 // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n                 let trait_ = clean::Type::Path { path: trait_ }.into_tcx(tcx);\n                 Type::QualifiedPath {\n-                    name: name.to_string(),\n+                    name: assoc.name.to_string(),\n+                    args: Box::new(assoc.args.clone().into_tcx(tcx)),\n                     self_type: Box::new((*self_type).into_tcx(tcx)),\n                     trait_: Box::new(trait_),\n                 }"}, {"sha": "f378915172a699ed1e14c659d58b6f6cb9356f97", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -9,6 +9,7 @@\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(box_syntax)]\n+#![feature(drain_filter)]\n #![feature(let_else)]\n #![feature(nll)]\n #![feature(test)]"}, {"sha": "6cffb52bb875f794929c7570a52703a98e8b1546", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -62,7 +62,7 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n             clean::StructFieldItem(_)\n                 | clean::VariantItem(_)\n                 | clean::AssocConstItem(_, _)\n-                | clean::AssocTypeItem(_, _)\n+                | clean::AssocTypeItem(..)\n                 | clean::TypedefItem(_, _)\n                 | clean::StaticItem(_)\n                 | clean::ConstantItem(_)"}, {"sha": "b16cab1c646f13f6d642d661a92be507f34b606f", "filename": "src/librustdoc/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Flibrustdoc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -41,7 +41,7 @@ crate trait DocVisitor: Sized {\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n             | AssocConstItem(_, _)\n-            | AssocTypeItem(_, _)\n+            | AssocTypeItem(..)\n             | KeywordItem(_) => {}\n         }\n     }"}, {"sha": "40b0de448293ac5fada8edd894b74104a65cf5c9", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -9,7 +9,7 @@ use std::path::PathBuf;\n use serde::{Deserialize, Serialize};\n \n /// rustdoc format-version.\n-pub const FORMAT_VERSION: u32 = 11;\n+pub const FORMAT_VERSION: u32 = 12;\n \n /// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n /// about the language items in the local crate, as well as info about external items to allow\n@@ -145,6 +145,7 @@ pub struct Constant {\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n pub struct TypeBinding {\n     pub name: String,\n+    pub args: GenericArgs,\n     pub binding: TypeBindingKind,\n }\n \n@@ -233,6 +234,7 @@ pub enum ItemEnum {\n         default: Option<String>,\n     },\n     AssocType {\n+        generics: Generics,\n         bounds: Vec<GenericBound>,\n         /// e.g. `type X = usize;`\n         default: Option<Type>,\n@@ -432,6 +434,7 @@ pub enum Type {\n     /// `<Type as Trait>::Name` or associated types like `T::Item` where `T: Iterator`\n     QualifiedPath {\n         name: String,\n+        args: Box<GenericArgs>,\n         self_type: Box<Type>,\n         #[serde(rename = \"trait\")]\n         trait_: Box<Type>,"}, {"sha": "7adcd712ba6ab6f4bc33edeb1e4040d9e18675c9", "filename": "src/test/rustdoc-json/generic-associated-types/gats.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Frustdoc-json%2Fgeneric-associated-types%2Fgats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Frustdoc-json%2Fgeneric-associated-types%2Fgats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fgeneric-associated-types%2Fgats.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -0,0 +1,42 @@\n+// ignore-tidy-linelength\n+\n+#![no_core]\n+#![feature(generic_associated_types, lang_items, no_core)]\n+\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+pub trait Display {}\n+\n+// @has gats.json\n+pub trait LendingIterator {\n+    // @count - \"$.index[*][?(@.name=='LendingItem')].inner.generics.params[*]\" 1\n+    // @is - \"$.index[*][?(@.name=='LendingItem')].inner.generics.params[*].name\" \\\"\\'a\\\"\n+    // @count - \"$.index[*][?(@.name=='LendingItem')].inner.generics.where_predicates[*]\" 1\n+    // @is - \"$.index[*][?(@.name=='LendingItem')].inner.generics.where_predicates[*].bound_predicate.ty.inner\" \\\"Self\\\"\n+    // @is - \"$.index[*][?(@.name=='LendingItem')].inner.generics.where_predicates[*].bound_predicate.bounds[*].outlives\" \\\"\\'a\\\"\n+    // @count - \"$.index[*][?(@.name=='LendingItem')].inner.bounds[*]\" 1\n+    type LendingItem<'a>: Display where Self: 'a;\n+\n+    // @is - \"$.index[*][?(@.name=='lending_next')].inner.decl.output.kind\" \\\"qualified_path\\\"\n+    // @count - \"$.index[*][?(@.name=='lending_next')].inner.decl.output.inner.args.angle_bracketed.args[*]\" 1\n+    // @count - \"$.index[*][?(@.name=='lending_next')].inner.decl.output.inner.args.angle_bracketed.bindings[*]\" 0\n+    // @is - \"$.index[*][?(@.name=='lending_next')].inner.decl.output.inner.self_type.inner\" \\\"Self\\\"\n+    // @is - \"$.index[*][?(@.name=='lending_next')].inner.decl.output.inner.name\" \\\"LendingItem\\\"\n+    fn lending_next<'a>(&'a self) -> Self::LendingItem<'a>;\n+}\n+\n+// @has gats.json\n+pub trait Iterator {\n+    // @count - \"$.index[*][?(@.name=='Item')].inner.generics.params[*]\" 0\n+    // @count - \"$.index[*][?(@.name=='Item')].inner.generics.where_predicates[*]\" 0\n+    // @count - \"$.index[*][?(@.name=='Item')].inner.bounds[*]\" 1\n+    type Item: Display;\n+\n+    // @is - \"$.index[*][?(@.name=='next')].inner.decl.output.kind\" \\\"qualified_path\\\"\n+    // @count - \"$.index[*][?(@.name=='next')].inner.decl.output.inner.args.angle_bracketed.args[*]\" 0\n+    // @count - \"$.index[*][?(@.name=='next')].inner.decl.output.inner.args.angle_bracketed.bindings[*]\" 0\n+    // @is - \"$.index[*][?(@.name=='next')].inner.decl.output.inner.self_type.inner\" \\\"Self\\\"\n+    // @is - \"$.index[*][?(@.name=='next')].inner.decl.output.inner.name\" \\\"Item\\\"\n+    fn next<'a>(&'a self) -> Self::Item;\n+}"}, {"sha": "ae981b9499a67cb20d131528639b836c2196ae34", "filename": "src/test/rustdoc/generic-associated-types/gats.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Frustdoc%2Fgeneric-associated-types%2Fgats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Frustdoc%2Fgeneric-associated-types%2Fgats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fgeneric-associated-types%2Fgats.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -0,0 +1,34 @@\n+#![crate_name = \"foo\"]\n+#![feature(generic_associated_types)]\n+\n+// @has foo/trait.LendingIterator.html\n+pub trait LendingIterator {\n+    // @has - '//*[@id=\"associatedtype.Item\"]//h4[@class=\"code-header\"]' \"type Item<'a> where Self: 'a\"\n+    type Item<'a> where Self: 'a;\n+\n+    // @has - '//*[@id=\"tymethod.next\"]//h4[@class=\"code-header\"]' \\\n+    //      \"fn next<'a>(&'a self) -> Self::Item<'a>\"\n+    // @has - '//*[@id=\"tymethod.next\"]//h4[@class=\"code-header\"]//a[@href=\"trait.LendingIterator.html#associatedtype.Item\"]' \\\n+    //      \"Item\"\n+    fn next<'a>(&'a self) -> Self::Item<'a>;\n+}\n+\n+// @has foo/trait.LendingIterator.html\n+// @has - '//*[@id=\"associatedtype.Item-1\"]//h4[@class=\"code-header\"]' \"type Item<'a> = ()\"\n+impl LendingIterator for () {\n+    type Item<'a> = ();\n+\n+    fn next<'a>(&self) -> () {}\n+}\n+\n+pub struct Infinite<T>(T);\n+\n+// @has foo/trait.LendingIterator.html\n+// @has - '//*[@id=\"associatedtype.Item-2\"]//h4[@class=\"code-header\"]' \"type Item<'a> where Self: 'a = &'a T\"\n+impl<T> LendingIterator for Infinite<T> {\n+    type Item<'a> where Self: 'a = &'a T;\n+\n+    fn next<'a>(&'a self) -> Self::Item<'a> {\n+        &self.0\n+    }\n+}"}]}