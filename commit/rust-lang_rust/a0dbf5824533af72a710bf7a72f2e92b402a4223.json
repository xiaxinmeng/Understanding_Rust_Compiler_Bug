{"sha": "a0dbf5824533af72a710bf7a72f2e92b402a4223", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZGJmNTgyNDUzM2FmNzJhNzEwYmY3YTcyZjJlOTJiNDAyYTQyMjM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-05T22:59:13Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-05T23:11:51Z"}, "message": "Remove duplicate, un-used copy of astencode", "tree": {"sha": "4a4dd3226e87fa28a037e381dd524980756964a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a4dd3226e87fa28a037e381dd524980756964a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0dbf5824533af72a710bf7a72f2e92b402a4223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0dbf5824533af72a710bf7a72f2e92b402a4223", "html_url": "https://github.com/rust-lang/rust/commit/a0dbf5824533af72a710bf7a72f2e92b402a4223", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0dbf5824533af72a710bf7a72f2e92b402a4223/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "663b3fc89c7f8cd0568720f5c0acf6ee6818b0d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/663b3fc89c7f8cd0568720f5c0acf6ee6818b0d9", "html_url": "https://github.com/rust-lang/rust/commit/663b3fc89c7f8cd0568720f5c0acf6ee6818b0d9"}], "stats": {"total": 940, "additions": 0, "deletions": 940}, "files": [{"sha": "8d2bfad04c9a506afaaf921a275616d823c48407", "filename": "src/rustc/metadata/astencode.rs", "status": "removed", "additions": 0, "deletions": 940, "changes": 940, "blob_url": "https://github.com/rust-lang/rust/blob/663b3fc89c7f8cd0568720f5c0acf6ee6818b0d9/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/663b3fc89c7f8cd0568720f5c0acf6ee6818b0d9/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=663b3fc89c7f8cd0568720f5c0acf6ee6818b0d9", "patch": "@@ -1,940 +0,0 @@\n-import util::ppaux::ty_to_str;\n-\n-import syntax::ast;\n-import syntax::ast_util::{id_range, compute_id_range_for_inlined_item,\n-                          visit_ids_for_inlined_item, serialize_id_range,\n-                          deserialize_id_range};\n-import syntax::fold;\n-import syntax::visit;\n-import syntax::ast_util;\n-import syntax::ast_util::inlined_item_methods;\n-import syntax::codemap::span;\n-import std::ebml;\n-import std::ebml::writer;\n-import std::ebml::serializer;\n-import std::ebml::deserializer;\n-import std::map::hashmap;\n-import std::serialization::serializer;\n-import std::serialization::deserializer;\n-import std::serialization::serializer_helpers;\n-import std::serialization::deserializer_helpers;\n-import std::prettyprint::serializer;\n-import std::smallintmap::map;\n-import middle::trans::common::maps;\n-import middle::{ty, typeck, last_use, ast_map};\n-import middle::typeck::{method_origin,\n-                        serialize_method_origin,\n-                        deserialize_method_origin,\n-                        vtable_res,\n-                        vtable_origin};\n-import driver::session::session;\n-import middle::freevars::{freevar_entry,\n-                          serialize_freevar_entry,\n-                          deserialize_freevar_entry};\n-import c = common;\n-import e = encoder;\n-\n-// used in testing:\n-import driver::diagnostic;\n-import syntax::codemap;\n-import syntax::parse;\n-import syntax::print::pprust;\n-\n-export encode_inlined_item;\n-export decode_inlined_item;\n-\n-type decode_ctxt = @{\n-    cdata: cstore::crate_metadata,\n-    tcx: ty::ctxt,\n-    maps: maps\n-};\n-\n-type extended_decode_ctxt = @{\n-    dcx: decode_ctxt,\n-    from_id_range: id_range,\n-    to_id_range: id_range\n-};\n-\n-iface tr {\n-    fn tr(xcx: extended_decode_ctxt) -> self;\n-}\n-\n-// ______________________________________________________________________\n-// Top-level methods.\n-\n-fn encode_inlined_item(ecx: @e::encode_ctxt,\n-                       ebml_w: ebml::writer,\n-                       path: ast_map::path,\n-                       ii: ast::inlined_item) {\n-    #debug~[\"> Encoding inlined item: %s::%s (%u)\",\n-           ast_map::path_to_str(path), ii.ident(),\n-           ebml_w.writer.tell()];\n-\n-    let id_range = compute_id_range_for_inlined_item(ii);\n-    ebml_w.wr_tag(c::tag_ast as uint) {||\n-        encode_id_range(ebml_w, id_range);\n-        encode_ast(ebml_w, simplify_ast(ii));\n-        encode_side_tables_for_ii(ecx, ebml_w, ii);\n-    }\n-\n-    #debug~[\"< Encoded inlined fn: %s::%s (%u)\",\n-           ast_map::path_to_str(path), ii.ident(),\n-           ebml_w.writer.tell()];\n-}\n-\n-fn decode_inlined_item(cdata: cstore::crate_metadata,\n-                       tcx: ty::ctxt,\n-                       maps: maps,\n-                       path: ast_map::path,\n-                       par_doc: ebml::doc) -> option<ast::inlined_item> {\n-    let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n-    alt par_doc.opt_child(c::tag_ast) {\n-      none { none }\n-      some(ast_doc) {\n-        #debug[\"> Decoding inlined fn: %s::?\", ast_map::path_to_str(path)];\n-        let from_id_range = decode_id_range(ast_doc);\n-        let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n-        let xcx = @{dcx: dcx,\n-                    from_id_range: from_id_range,\n-                    to_id_range: to_id_range};\n-        let raw_ii = decode_ast(ast_doc);\n-        let ii = renumber_ast(xcx, raw_ii);\n-        ast_map::map_decoded_item(tcx.sess, dcx.tcx.items, path, ii);\n-        #debug[\"Fn named: %s\", ii.ident()];\n-        decode_side_tables(xcx, ast_doc);\n-        #debug~[\"< Decoded inlined fn: %s::%s\",\n-               ast_map::path_to_str(path), ii.ident()];\n-        alt ii {\n-          ast::ii_item(i) {\n-            #debug(\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_str(i));\n-          }\n-          _ { }\n-        }\n-        some(ii)\n-      }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Enumerating the IDs which appear in an AST\n-\n-fn encode_id_range(ebml_w: ebml::writer, id_range: id_range) {\n-    serialize_id_range(ebml_w, id_range);\n-}\n-\n-fn decode_id_range(par_doc: ebml::doc) -> id_range {\n-    let range_doc = par_doc[c::tag_id_range];\n-    let dsr = ebml::ebml_deserializer(range_doc);\n-    deserialize_id_range(dsr)\n-}\n-\n-fn reserve_id_range(sess: session, from_id_range: id_range) -> id_range {\n-    // Handle the case of an empty range:\n-    if empty(from_id_range) { ret from_id_range; }\n-    let cnt = from_id_range.max - from_id_range.min;\n-    let to_id_min = sess.parse_sess.next_id;\n-    let to_id_max = sess.parse_sess.next_id + cnt;\n-    sess.parse_sess.next_id = to_id_max;\n-    ret {min: to_id_min, max: to_id_min};\n-}\n-\n-impl translation_routines for extended_decode_ctxt {\n-    fn tr_id(id: ast::node_id) -> ast::node_id {\n-        // from_id_range should be non-empty\n-        assert !empty(self.from_id_range);\n-        (id - self.from_id_range.min + self.to_id_range.min)\n-    }\n-    fn tr_def_id(did: ast::def_id) -> ast::def_id {\n-        decoder::translate_def_id(self.dcx.cdata, did)\n-    }\n-    fn tr_intern_def_id(did: ast::def_id) -> ast::def_id {\n-        assert did.crate == ast::local_crate;\n-        {crate: ast::local_crate, node: self.tr_id(did.node)}\n-    }\n-    fn tr_span(_span: span) -> span {\n-        ast_util::dummy_sp() // TODO...\n-    }\n-}\n-\n-impl of tr for ast::def_id {\n-    fn tr(xcx: extended_decode_ctxt) -> ast::def_id {\n-        xcx.tr_def_id(self)\n-    }\n-    fn tr_intern(xcx: extended_decode_ctxt) -> ast::def_id {\n-        xcx.tr_intern_def_id(self)\n-    }\n-}\n-\n-impl of tr for span {\n-    fn tr(xcx: extended_decode_ctxt) -> span {\n-        xcx.tr_span(self)\n-    }\n-}\n-\n-impl serializer_helpers<S: serializer> for S {\n-    fn emit_def_id(did: ast::def_id) {\n-        ast::serialize_def_id(self, did)\n-    }\n-}\n-\n-impl deserializer_helpers<D: deserializer> for D {\n-    fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id {\n-        let did = ast::deserialize_def_id(self);\n-        did.tr(xcx)\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding the AST itself\n-//\n-// The hard work is done by an autogenerated module astencode_gen.  To\n-// regenerate astencode_gen, run src/etc/gen-astencode.  It will\n-// replace astencode_gen with a dummy file and regenerate its\n-// contents.  If you get compile errors, the dummy file\n-// remains---resolve the errors and then rerun astencode_gen.\n-// Annoying, I know, but hopefully only temporary.\n-//\n-// When decoding, we have to renumber the AST so that the node ids that\n-// appear within are disjoint from the node ids in our existing ASTs.\n-// We also have to adjust the spans: for now we just insert a dummy span,\n-// but eventually we should add entries to the local codemap as required.\n-\n-fn encode_ast(ebml_w: ebml::writer, item: ast::inlined_item) {\n-    ebml_w.wr_tag(c::tag_tree as uint) {||\n-        ast::serialize_inlined_item(ebml_w, item)\n-    }\n-}\n-\n-// Produces a simplified copy of the AST which does not include things\n-// that we do not need to or do not want to export.  For example, we\n-// do not include any nested items: if these nested items are to be\n-// inlined, their AST will be exported separately (this only makes\n-// sense because, in Rust, nested items are independent except for\n-// their visibility).\n-//\n-// As it happens, trans relies on the fact that we do not export\n-// nested items, as otherwise it would get confused when translating\n-// inlined items.\n-fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n-    fn drop_nested_items(blk: ast::blk_, fld: fold::ast_fold) -> ast::blk_ {\n-        let stmts_sans_items = vec::filter(blk.stmts) {|stmt|\n-            alt stmt.node {\n-              ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n-              ast::stmt_decl(@{node: ast::decl_local(_), span: _}, _) { true }\n-              ast::stmt_decl(@{node: ast::decl_item(_), span: _}, _) { false }\n-            }\n-        };\n-        let blk_sans_items = { stmts: stmts_sans_items with blk };\n-        fold::noop_fold_block(blk_sans_items, fld)\n-    }\n-\n-    let fld = fold::make_fold({\n-        fold_block: fold::wrap(drop_nested_items)\n-        with *fold::default_ast_fold()\n-    });\n-\n-    alt ii {\n-      ast::ii_item(i) {\n-        ast::ii_item(fld.fold_item(i))\n-      }\n-      ast::ii_method(d, m) {\n-        ast::ii_method(d, fld.fold_method(m))\n-      }\n-      ast::ii_foreign(i) {\n-        ast::ii_foreign(fld.fold_foreign_item(i))\n-      }\n-      ast::ii_ctor(ctor, nm, tps, parent_id) {\n-        let ctor_body = fld.fold_block(ctor.node.body);\n-        let ctor_decl = fold::fold_fn_decl(ctor.node.dec, fld);\n-        ast::ii_ctor({node: {body: ctor_body, dec: ctor_decl\n-                              with ctor.node}\n-            with ctor}, nm, tps, parent_id)\n-      }\n-    }\n-}\n-\n-fn decode_ast(par_doc: ebml::doc) -> ast::inlined_item {\n-    let chi_doc = par_doc[c::tag_tree];\n-    let d = ebml::ebml_deserializer(chi_doc);\n-    ast::deserialize_inlined_item(d)\n-}\n-\n-fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n-    -> ast::inlined_item {\n-    let fld = fold::make_fold({\n-        new_id: xcx.tr_id(_),\n-        new_span: xcx.tr_span(_)\n-        with *fold::default_ast_fold()\n-    });\n-\n-    alt ii {\n-      ast::ii_item(i) {\n-        ast::ii_item(fld.fold_item(i))\n-      }\n-      ast::ii_method(d, m) {\n-        ast::ii_method(xcx.tr_def_id(d), fld.fold_method(m))\n-      }\n-      ast::ii_foreign(i) {\n-        ast::ii_foreign(fld.fold_foreign_item(i))\n-      }\n-      ast::ii_ctor(ctor, nm, tps, parent_id) {\n-        let ctor_body = fld.fold_block(ctor.node.body);\n-        let ctor_decl = fold::fold_fn_decl(ctor.node.dec, fld);\n-        let new_params = fold::fold_ty_params(tps, fld);\n-        let ctor_id = fld.new_id(ctor.node.id);\n-        let new_parent = xcx.tr_def_id(parent_id);\n-        ast::ii_ctor({node: {body: ctor_body, dec: ctor_decl, id: ctor_id\n-                              with ctor.node}\n-            with ctor}, nm, new_params, new_parent)\n-      }\n-     }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding of ast::def\n-\n-fn encode_def(ebml_w: ebml::writer, def: ast::def) {\n-    ast::serialize_def(ebml_w, def)\n-}\n-\n-fn decode_def(xcx: extended_decode_ctxt, doc: ebml::doc) -> ast::def {\n-    let dsr = ebml::ebml_deserializer(doc);\n-    let def = ast::deserialize_def(dsr);\n-    def.tr(xcx)\n-}\n-\n-impl of tr for ast::def {\n-    fn tr(xcx: extended_decode_ctxt) -> ast::def {\n-        alt self {\n-          ast::def_fn(did, p) { ast::def_fn(did.tr(xcx), p) }\n-          ast::def_self(nid) { ast::def_self(xcx.tr_id(nid)) }\n-          ast::def_mod(did) { ast::def_mod(did.tr(xcx)) }\n-          ast::def_foreign_mod(did) { ast::def_foreign_mod(did.tr(xcx)) }\n-          ast::def_const(did) { ast::def_const(did.tr(xcx)) }\n-          ast::def_arg(nid, m) { ast::def_arg(xcx.tr_id(nid), m) }\n-          ast::def_local(nid, b) { ast::def_local(xcx.tr_id(nid), b) }\n-          ast::def_variant(e_did, v_did) {\n-            ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n-          }\n-          ast::def_ty(did) { ast::def_ty(did.tr(xcx)) }\n-          ast::def_prim_ty(p) { ast::def_prim_ty(p) }\n-          ast::def_ty_param(did, v) { ast::def_ty_param(did.tr(xcx), v) }\n-          ast::def_binding(nid) { ast::def_binding(xcx.tr_id(nid)) }\n-          ast::def_use(did) { ast::def_use(did.tr(xcx)) }\n-          ast::def_upvar(nid1, def, nid2) {\n-            ast::def_upvar(xcx.tr_id(nid1), @(*def).tr(xcx), xcx.tr_id(nid2))\n-          }\n-          ast::def_class(did) {\n-            ast::def_class(did.tr(xcx))\n-          }\n-          ast::def_region(nid) { ast::def_region(xcx.tr_id(nid)) }\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding of freevar information\n-\n-fn encode_freevar_entry(ebml_w: ebml::writer, fv: freevar_entry) {\n-    serialize_freevar_entry(ebml_w, fv)\n-}\n-\n-impl helper for ebml::ebml_deserializer {\n-    fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n-        let fv = deserialize_freevar_entry(self);\n-        fv.tr(xcx)\n-    }\n-}\n-\n-impl of tr for freevar_entry {\n-    fn tr(xcx: extended_decode_ctxt) -> freevar_entry {\n-        {def: self.def.tr(xcx), span: self.span.tr(xcx)}\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding of method_origin\n-\n-fn encode_method_origin(ebml_w: ebml::writer, mo: method_origin) {\n-    serialize_method_origin(ebml_w, mo)\n-}\n-\n-impl helper for ebml::ebml_deserializer {\n-    fn read_method_origin(xcx: extended_decode_ctxt) -> method_origin {\n-        let fv = deserialize_method_origin(self);\n-        fv.tr(xcx)\n-    }\n-    fn read_is_last_use(xcx: extended_decode_ctxt) -> last_use::is_last_use {\n-        let lu = last_use::deserialize_is_last_use(self);\n-        lu.tr(xcx)\n-    }\n-}\n-\n-impl of tr for method_origin {\n-    fn tr(xcx: extended_decode_ctxt) -> method_origin {\n-        alt self {\n-          typeck::method_static(did) {\n-            typeck::method_static(did.tr(xcx))\n-          }\n-          typeck::method_param(did, m, p, b) {\n-            typeck::method_param(did.tr(xcx), m, p, b)\n-          }\n-          typeck::method_trait(did, m) {\n-            typeck::method_trait(did.tr(xcx), m)\n-          }\n-        }\n-    }\n-}\n-\n-impl of tr for last_use::is_last_use {\n-    fn tr(xcx: extended_decode_ctxt) -> last_use::is_last_use {\n-        alt self {\n-          last_use::is_last_use { self }\n-          last_use::closes_over(ids) {\n-            last_use::closes_over(vec::map(ids, {|id| xcx.tr_id(id)}))\n-          }\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding vtable_res\n-\n-fn encode_vtable_res(ecx: @e::encode_ctxt,\n-                   ebml_w: ebml::writer,\n-                   dr: typeck::vtable_res) {\n-    // can't autogenerate this code because automatic serialization of\n-    // ty::t doesn't work, and there is no way (atm) to have\n-    // hand-written serialization routines combine with auto-generated\n-    // ones.  perhaps we should fix this.\n-    ebml_w.emit_from_vec(*dr) {|vtable_origin|\n-        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n-    }\n-}\n-\n-fn encode_vtable_origin(ecx: @e::encode_ctxt,\n-                      ebml_w: ebml::writer,\n-                      vtable_origin: typeck::vtable_origin) {\n-    ebml_w.emit_enum(\"vtable_origin\") {||\n-        alt vtable_origin {\n-          typeck::vtable_static(def_id, tys, vtable_res) {\n-            ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u) {||\n-                ebml_w.emit_enum_variant_arg(0u) {||\n-                    ebml_w.emit_def_id(def_id)\n-                }\n-                ebml_w.emit_enum_variant_arg(1u) {||\n-                    ebml_w.emit_tys(ecx, tys);\n-                }\n-                ebml_w.emit_enum_variant_arg(2u) {||\n-                    encode_vtable_res(ecx, ebml_w, vtable_res);\n-                }\n-            }\n-          }\n-          typeck::vtable_param(pn, bn) {\n-            ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u) {||\n-                ebml_w.emit_enum_variant_arg(0u) {||\n-                    ebml_w.emit_uint(pn);\n-                }\n-                ebml_w.emit_enum_variant_arg(1u) {||\n-                    ebml_w.emit_uint(bn);\n-                }\n-            }\n-          }\n-          typeck::vtable_trait(def_id, tys) {\n-            ebml_w.emit_enum_variant(\"vtable_trait\", 1u, 3u) {||\n-                ebml_w.emit_enum_variant_arg(0u) {||\n-                    ebml_w.emit_def_id(def_id)\n-                }\n-                ebml_w.emit_enum_variant_arg(1u) {||\n-                    ebml_w.emit_tys(ecx, tys);\n-                }\n-            }\n-          }\n-        }\n-    }\n-\n-}\n-\n-impl helpers for ebml::ebml_deserializer {\n-    fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n-        @self.read_to_vec {|| self.read_vtable_origin(xcx) }\n-    }\n-\n-    fn read_vtable_origin(xcx: extended_decode_ctxt)\n-        -> typeck::vtable_origin {\n-        self.read_enum(\"vtable_origin\") {||\n-            self.read_enum_variant {|i|\n-                alt check i {\n-                  0u {\n-                    typeck::vtable_static(\n-                        self.read_enum_variant_arg(0u) {||\n-                            self.read_def_id(xcx)\n-                        },\n-                        self.read_enum_variant_arg(1u) {||\n-                            self.read_tys(xcx)\n-                        },\n-                        self.read_enum_variant_arg(2u) {||\n-                            self.read_vtable_res(xcx)\n-                        }\n-                    )\n-                  }\n-                  1u {\n-                    typeck::vtable_param(\n-                        self.read_enum_variant_arg(0u) {||\n-                            self.read_uint()\n-                        },\n-                        self.read_enum_variant_arg(1u) {||\n-                            self.read_uint()\n-                        }\n-                    )\n-                  }\n-                  2u {\n-                    typeck::vtable_trait(\n-                        self.read_enum_variant_arg(0u) {||\n-                            self.read_def_id(xcx)\n-                        },\n-                        self.read_enum_variant_arg(1u) {||\n-                            self.read_tys(xcx)\n-                        }\n-                    )\n-                  }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding the side tables\n-\n-impl helpers for @e::encode_ctxt {\n-    fn ty_str_ctxt() -> @tyencode::ctxt {\n-        @{ds: e::def_to_str,\n-          tcx: self.ccx.tcx,\n-          reachable: encoder::reachable(self, _),\n-          abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n-    }\n-}\n-\n-impl helpers for ebml::writer {\n-    fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t) {\n-        e::write_type(ecx, self, ty)\n-    }\n-\n-    fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]) {\n-        self.emit_from_vec(tys) {|ty|\n-            e::write_type(ecx, self, ty)\n-        }\n-    }\n-\n-    fn emit_bounds(ecx: @e::encode_ctxt, bs: ty::param_bounds) {\n-        tyencode::enc_bounds(self.writer, ecx.ty_str_ctxt(), bs)\n-    }\n-\n-    fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty) {\n-        self.emit_rec {||\n-            self.emit_rec_field(\"bounds\", 0u) {||\n-                self.emit_from_vec(*tpbt.bounds) {|bs|\n-                    self.emit_bounds(ecx, bs)\n-                }\n-            }\n-            self.emit_rec_field(\"rp\", 1u) {||\n-                ast::serialize_region_param(self, tpbt.rp)\n-            }\n-            self.emit_rec_field(\"ty\", 2u) {||\n-                self.emit_ty(ecx, tpbt.ty);\n-            }\n-        }\n-    }\n-}\n-\n-impl writer for ebml::writer {\n-    fn tag(tag_id: c::astencode_tag, f: fn()) {\n-        self.wr_tag(tag_id as uint) {|| f() }\n-    }\n-\n-    fn id(id: ast::node_id) {\n-        self.wr_tagged_u64(c::tag_table_id as uint, id as u64)\n-    }\n-}\n-\n-fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n-                             ebml_w: ebml::writer,\n-                             ii: ast::inlined_item) {\n-    ebml_w.wr_tag(c::tag_table as uint) {||\n-        visit_ids_for_inlined_item(ii, fn@(id: ast::node_id) {\n-            // Note: this will cause a copy of ebml_w, which is bad as\n-            // it has mut fields.  But I believe it's harmless since\n-            // we generate balanced EBML.\n-            encode_side_tables_for_id(ecx, ebml_w, id)\n-        });\n-    }\n-}\n-\n-fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n-                             ebml_w: ebml::writer,\n-                             id: ast::node_id) {\n-    let ccx = ecx.ccx;\n-    let tcx = ccx.tcx;\n-\n-    #debug[\"Encoding side tables for id %d\", id];\n-\n-    option::iter(tcx.def_map.find(id)) {|def|\n-        ebml_w.tag(c::tag_table_def) {||\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n-                ast::serialize_def(ebml_w, def)\n-            }\n-        }\n-    }\n-    option::iter((*tcx.node_types).find(id as uint)) {|ty|\n-        ebml_w.tag(c::tag_table_node_type) {||\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n-                e::write_type(ecx, ebml_w, ty)\n-            }\n-        }\n-    }\n-\n-    option::iter(tcx.node_type_substs.find(id)) {|tys|\n-        ebml_w.tag(c::tag_table_node_type_subst) {||\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n-                ebml_w.emit_tys(ecx, tys)\n-            }\n-        }\n-    }\n-\n-    option::iter(tcx.freevars.find(id)) {|fv|\n-        ebml_w.tag(c::tag_table_freevars) {||\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n-                ebml_w.emit_from_vec(*fv) {|fv_entry|\n-                    encode_freevar_entry(ebml_w, *fv_entry)\n-                }\n-            }\n-        }\n-    }\n-\n-    let lid = {crate: ast::local_crate, node: id};\n-    option::iter(tcx.tcache.find(lid)) {|tpbt|\n-        ebml_w.tag(c::tag_table_tcache) {||\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n-                ebml_w.emit_tpbt(ecx, tpbt);\n-            }\n-        }\n-    }\n-\n-    option::iter(tcx.ty_param_bounds.find(id)) {|pbs|\n-        ebml_w.tag(c::tag_table_param_bounds) {||\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n-                ebml_w.emit_bounds(ecx, pbs)\n-            }\n-        }\n-    }\n-\n-    // I believe it is not necessary to encode this information.  The\n-    // ids will appear in the AST but in the *type* information, which\n-    // is what we actually use in trans, all modes will have been\n-    // resolved.\n-    //\n-    //option::iter(tcx.inferred_modes.find(id)) {|m|\n-    //    ebml_w.tag(c::tag_table_inferred_modes) {||\n-    //        ebml_w.id(id);\n-    //        ebml_w.tag(c::tag_table_val) {||\n-    //            tyencode::enc_mode(ebml_w.writer, ty_str_ctxt(), m);\n-    //        }\n-    //    }\n-    //}\n-\n-    option::iter(ccx.maps.mutbl_map.find(id)) {|_m|\n-        ebml_w.tag(c::tag_table_mutbl) {||\n-            ebml_w.id(id);\n-        }\n-    }\n-\n-    option::iter(ccx.maps.copy_map.find(id)) {|_m|\n-        ebml_w.tag(c::tag_table_copy) {||\n-            ebml_w.id(id);\n-        }\n-    }\n-\n-    option::iter(ccx.maps.spill_map.find(id)) {|_m|\n-        ebml_w.tag(c::tag_table_spill) {||\n-            ebml_w.id(id);\n-        }\n-    }\n-\n-    option::iter(ccx.maps.last_uses.find(id)) {|m|\n-        ebml_w.tag(c::tag_table_last_use) {||\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n-                last_use::serialize_is_last_use(ebml_w, m)\n-            }\n-        }\n-    }\n-\n-    // impl_map is not used except when emitting metadata,\n-    // don't need to keep it.\n-\n-    option::iter(ccx.maps.method_map.find(id)) {|mo|\n-        ebml_w.tag(c::tag_table_method_map) {||\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n-                serialize_method_origin(ebml_w, mo)\n-            }\n-        }\n-    }\n-\n-    option::iter(ccx.maps.vtable_map.find(id)) {|dr|\n-        ebml_w.tag(c::tag_table_vtable_map) {||\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n-                encode_vtable_res(ecx, ebml_w, dr);\n-            }\n-        }\n-    }\n-\n-    option::iter(tcx.borrowings.find(id)) {|_i|\n-        ebml_w.tag(c::tag_table_borrowings) {||\n-            ebml_w.id(id);\n-        }\n-    }\n-}\n-\n-impl decoder for ebml::doc {\n-    fn as_int() -> int { ebml::doc_as_u64(self) as int }\n-    fn ~[](tag: c::astencode_tag) -> ebml::doc {\n-        ebml::get_doc(self, tag as uint)\n-    }\n-    fn opt_child(tag: c::astencode_tag) -> option<ebml::doc> {\n-        ebml::maybe_get_doc(self, tag as uint)\n-    }\n-}\n-\n-impl decoder for ebml::ebml_deserializer {\n-    fn read_ty(xcx: extended_decode_ctxt) -> ty::t {\n-        // Note: regions types embed local node ids.  In principle, we\n-        // should translate these node ids into the new decode\n-        // context.  However, we do not bother, because region types\n-        // are not used during trans.\n-\n-        tydecode::parse_ty_data(\n-            self.parent.data, xcx.dcx.cdata.cnum, self.pos, xcx.dcx.tcx,\n-            xcx.tr_def_id(_))\n-    }\n-\n-    fn read_tys(xcx: extended_decode_ctxt) -> ~[ty::t] {\n-        self.read_to_vec {|| self.read_ty(xcx) }\n-    }\n-\n-    fn read_bounds(xcx: extended_decode_ctxt) -> @~[ty::param_bound] {\n-        tydecode::parse_bounds_data(\n-            self.parent.data, self.pos, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n-            xcx.tr_def_id(_))\n-    }\n-\n-    fn read_ty_param_bounds_and_ty(xcx: extended_decode_ctxt)\n-        -> ty::ty_param_bounds_and_ty {\n-        self.read_rec {||\n-            {\n-                bounds: self.read_rec_field(\"bounds\", 0u) {||\n-                    @self.read_to_vec {|| self.read_bounds(xcx) }\n-                },\n-                rp: self.read_rec_field(\"rp\", 1u) {||\n-                    ast::deserialize_region_param(self)\n-                },\n-                ty: self.read_rec_field(\"ty\", 2u) {||\n-                    self.read_ty(xcx)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn decode_side_tables(xcx: extended_decode_ctxt,\n-                      ast_doc: ebml::doc) {\n-    let dcx = xcx.dcx;\n-    let tbl_doc = ast_doc[c::tag_table];\n-    ebml::docs(tbl_doc) {|tag, entry_doc|\n-        let id0 = entry_doc[c::tag_table_id].as_int();\n-        let id = xcx.tr_id(id0);\n-\n-        #debug~[\">> Side table document with tag 0x%x \\\n-                found for id %d (orig %d)\",\n-               tag, id, id0];\n-\n-        if tag == (c::tag_table_mutbl as uint) {\n-            dcx.maps.mutbl_map.insert(id, ());\n-        } else if tag == (c::tag_table_copy as uint) {\n-            dcx.maps.copy_map.insert(id, ());\n-        } else if tag == (c::tag_table_spill as uint) {\n-            dcx.maps.spill_map.insert(id, ());\n-        } else if tag == (c::tag_table_borrowings as uint) {\n-            dcx.tcx.borrowings.insert(id, ());\n-        } else {\n-            let val_doc = entry_doc[c::tag_table_val];\n-            let val_dsr = ebml::ebml_deserializer(val_doc);\n-            if tag == (c::tag_table_def as uint) {\n-                let def = decode_def(xcx, val_doc);\n-                dcx.tcx.def_map.insert(id, def);\n-            } else if tag == (c::tag_table_node_type as uint) {\n-                let ty = val_dsr.read_ty(xcx);\n-                (*dcx.tcx.node_types).insert(id as uint, ty);\n-            } else if tag == (c::tag_table_node_type_subst as uint) {\n-                let tys = val_dsr.read_tys(xcx);\n-                dcx.tcx.node_type_substs.insert(id, tys);\n-            } else if tag == (c::tag_table_freevars as uint) {\n-                let fv_info = @val_dsr.read_to_vec {||\n-                    @val_dsr.read_freevar_entry(xcx)\n-                };\n-                dcx.tcx.freevars.insert(id, fv_info);\n-            } else if tag == (c::tag_table_tcache as uint) {\n-                let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n-                let lid = {crate: ast::local_crate, node: id};\n-                dcx.tcx.tcache.insert(lid, tpbt);\n-            } else if tag == (c::tag_table_param_bounds as uint) {\n-                let bounds = val_dsr.read_bounds(xcx);\n-                dcx.tcx.ty_param_bounds.insert(id, bounds);\n-            } else if tag == (c::tag_table_last_use as uint) {\n-                dcx.maps.last_uses.insert(id, val_dsr.read_is_last_use(xcx));\n-            } else if tag == (c::tag_table_method_map as uint) {\n-                dcx.maps.method_map.insert(id,\n-                                           val_dsr.read_method_origin(xcx));\n-            } else if tag == (c::tag_table_vtable_map as uint) {\n-                dcx.maps.vtable_map.insert(id,\n-                                         val_dsr.read_vtable_res(xcx));\n-            } else {\n-                xcx.dcx.tcx.sess.bug(\n-                    #fmt[\"unknown tag found in side tables: %x\", tag]);\n-            }\n-        }\n-\n-        #debug[\">< Side table doc loaded\"];\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Testing of astencode_gen\n-\n-#[cfg(test)]\n-fn encode_item_ast(ebml_w: ebml::writer, item: @ast::item) {\n-    ebml_w.wr_tag(c::tag_tree as uint) {||\n-        ast::serialize_item(ebml_w, *item);\n-    }\n-}\n-\n-#[cfg(test)]\n-fn decode_item_ast(par_doc: ebml::doc) -> @ast::item {\n-    let chi_doc = par_doc[c::tag_tree];\n-    let d = ebml::ebml_deserializer(chi_doc);\n-    @ast::deserialize_item(d)\n-}\n-\n-#[cfg(test)]\n-fn new_parse_sess() -> parse::parse_sess {\n-    let cm = codemap::new_codemap();\n-    let handler = diagnostic::mk_handler(option::none);\n-    let sess = @{\n-        cm: cm,\n-        mut next_id: 1,\n-        span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n-        mut chpos: 0u,\n-        mut byte_pos: 0u\n-    };\n-    ret sess;\n-}\n-\n-#[cfg(test)]\n-iface fake_ext_ctxt {\n-    fn cfg() -> ast::crate_cfg;\n-    fn parse_sess() -> parse::parse_sess;\n-}\n-\n-#[cfg(test)]\n-type fake_session = ();\n-\n-#[cfg(test)]\n-impl of fake_ext_ctxt for fake_session {\n-    fn cfg() -> ast::crate_cfg { ~[] }\n-    fn parse_sess() -> parse::parse_sess { new_parse_sess() }\n-}\n-\n-#[cfg(test)]\n-fn mk_ctxt() -> fake_ext_ctxt {\n-    () as fake_ext_ctxt\n-}\n-\n-#[cfg(test)]\n-fn roundtrip(in_item: @ast::item) {\n-    #debug[\"in_item = %s\", pprust::item_to_str(in_item)];\n-    let mbuf = io::mem_buffer();\n-    let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n-    encode_item_ast(ebml_w, in_item);\n-    let ebml_doc = ebml::doc(@io::mem_buffer_buf(mbuf));\n-    let out_item = decode_item_ast(ebml_doc);\n-    #debug[\"out_item = %s\", pprust::item_to_str(out_item)];\n-\n-    let exp_str =\n-        io::with_str_writer {|w| ast::serialize_item(w, *in_item) };\n-    let out_str =\n-        io::with_str_writer {|w| ast::serialize_item(w, *out_item) };\n-\n-    #debug[\"expected string: %s\", exp_str];\n-    #debug[\"actual string  : %s\", out_str];\n-\n-    assert exp_str == out_str;\n-}\n-\n-#[test]\n-fn test_basic() {\n-    let ext_cx = mk_ctxt();\n-    roundtrip(#ast(item){\n-        fn foo() {}\n-    });\n-}\n-\n-#[test]\n-fn test_smalltalk() {\n-    let ext_cx = mk_ctxt();\n-    roundtrip(#ast(item){\n-        fn foo() -> int { 3 + 4 } // first smalltalk program ever executed.\n-    });\n-}\n-\n-#[test]\n-fn test_more() {\n-    let ext_cx = mk_ctxt();\n-    roundtrip(#ast(item){\n-        fn foo(x: uint, y: uint) -> uint {\n-            let z = x + y;\n-            ret z;\n-        }\n-    });\n-}\n-\n-#[test]\n-fn test_simplification() {\n-    let ext_cx = mk_ctxt();\n-    let item_in = ast::ii_item(#ast(item) {\n-        fn new_int_alist<B: copy>() -> alist<int, B> {\n-            fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n-            ret {eq_fn: eq_int, mut data: ~[]};\n-        }\n-    });\n-    let item_out = simplify_ast(item_in);\n-    let item_exp = ast::ii_item(#ast(item) {\n-        fn new_int_alist<B: copy>() -> alist<int, B> {\n-            ret {eq_fn: eq_int, mut data: ~[]};\n-        }\n-    });\n-    alt (item_out, item_exp) {\n-      (ast::ii_item(item_out), ast::ii_item(item_exp)) {\n-        assert pprust::item_to_str(item_out) == pprust::item_to_str(item_exp);\n-      }\n-      _ { fail; }\n-    }\n-}"}]}