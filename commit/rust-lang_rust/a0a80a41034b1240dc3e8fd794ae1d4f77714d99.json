{"sha": "a0a80a41034b1240dc3e8fd794ae1d4f77714d99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwYTgwYTQxMDM0YjEyNDBkYzNlOGZkNzk0YWUxZDRmNzc3MTRkOTk=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-03-27T17:56:18Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-04-10T13:04:06Z"}, "message": "Implement Chalk's debug methods using TLS\n\nChalk now panics if we don't implement these methods and run with CHALK_DEBUG,\nso I thought I'd try to implement them 'properly'. Sadly, it seems impossible to\ndo without transmuting lifetimes somewhere. The problem is that we need a `&dyn\nHirDatabase` to get names etc., which we can't just put into TLS. I thought I\ncould just use `scoped-tls`, but that doesn't support references to unsized\ntypes. So I put the `&dyn` into another struct and put the reference to *that*\ninto the TLS, but I have to transmute the lifetime to 'static for that to work.", "tree": {"sha": "1daf136828992006de9e21784a89b2d14be61b74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1daf136828992006de9e21784a89b2d14be61b74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0a80a41034b1240dc3e8fd794ae1d4f77714d99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0a80a41034b1240dc3e8fd794ae1d4f77714d99", "html_url": "https://github.com/rust-lang/rust/commit/a0a80a41034b1240dc3e8fd794ae1d4f77714d99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "176f7f61175bc433c56083a758bd7a28a8ae31f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/176f7f61175bc433c56083a758bd7a28a8ae31f8", "html_url": "https://github.com/rust-lang/rust/commit/176f7f61175bc433c56083a758bd7a28a8ae31f8"}], "stats": {"total": 360, "additions": 304, "deletions": 56}, "files": [{"sha": "20e7e745be7a7d4c96d8ec2aebe9fcbf0a076f9e", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a0a80a41034b1240dc3e8fd794ae1d4f77714d99", "patch": "@@ -995,6 +995,7 @@ dependencies = [\n  \"ra_prof\",\n  \"ra_syntax\",\n  \"rustc-hash\",\n+ \"scoped-tls\",\n  \"smallvec\",\n  \"stdx\",\n  \"test_utils\",\n@@ -1390,6 +1391,12 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"scoped-tls\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ea6a9290e3c9cf0f18145ef7ffa62d68ee0bf5fcd651017e586dc7fd5da448c2\"\n+\n [[package]]\n name = \"scopeguard\"\n version = \"1.1.0\""}, {"sha": "59efc1c31d8c33c10de7a6536d435a3de8d16536", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=a0a80a41034b1240dc3e8fd794ae1d4f77714d99", "patch": "@@ -24,6 +24,8 @@ ra_prof = { path = \"../ra_prof\" }\n ra_syntax = { path = \"../ra_syntax\" }\n test_utils = { path = \"../test_utils\" }\n \n+scoped-tls = \"1\"\n+\n chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"039fc904a05f8cb3d0c682c9a57a63dda7a35356\" }\n chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"039fc904a05f8cb3d0c682c9a57a63dda7a35356\" }\n chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"039fc904a05f8cb3d0c682c9a57a63dda7a35356\" }"}, {"sha": "d03bbd5a7b5c72e8277d8b946a9e5cc422c0ea9d", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=a0a80a41034b1240dc3e8fd794ae1d4f77714d99", "patch": "@@ -247,19 +247,21 @@ impl HirDisplay for ApplicationTy {\n                 }\n             }\n             TypeCtor::Closure { .. } => {\n-                let sig = self.parameters[0]\n-                    .callable_sig(f.db)\n-                    .expect(\"first closure parameter should contain signature\");\n-                if sig.params().is_empty() {\n-                    write!(f, \"||\")?;\n-                } else if f.omit_verbose_types() {\n-                    write!(f, \"|{}|\", TYPE_HINT_TRUNCATION)?;\n+                let sig = self.parameters[0].callable_sig(f.db);\n+                if let Some(sig) = sig {\n+                    if sig.params().is_empty() {\n+                        write!(f, \"||\")?;\n+                    } else if f.omit_verbose_types() {\n+                        write!(f, \"|{}|\", TYPE_HINT_TRUNCATION)?;\n+                    } else {\n+                        write!(f, \"|\")?;\n+                        f.write_joined(sig.params(), \", \")?;\n+                        write!(f, \"|\")?;\n+                    };\n+                    write!(f, \" -> {}\", sig.ret().display(f.db))?;\n                 } else {\n-                    write!(f, \"|\")?;\n-                    f.write_joined(sig.params(), \", \")?;\n-                    write!(f, \"|\")?;\n-                };\n-                write!(f, \" -> {}\", sig.ret().display(f.db))?;\n+                    write!(f, \"{{closure}}\")?;\n+                }\n             }\n         }\n         Ok(())"}, {"sha": "21e2333799d2ab84ae574c885e61436b796021e2", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=a0a80a41034b1240dc3e8fd794ae1d4f77714d99", "patch": "@@ -177,20 +177,29 @@ fn solve(\n \n     let fuel = std::cell::Cell::new(CHALK_SOLVER_FUEL);\n \n-    let solution = solver.solve_limited(&context, goal, || {\n+    let should_continue = || {\n         context.db.check_canceled();\n         let remaining = fuel.get();\n         fuel.set(remaining - 1);\n         if remaining == 0 {\n             log::debug!(\"fuel exhausted\");\n         }\n         remaining > 0\n-    });\n+    };\n+    let mut solve = || solver.solve_limited(&context, goal, should_continue);\n+    // don't set the TLS for Chalk unless Chalk debugging is active, to make\n+    // extra sure we only use it for debugging\n+    let solution =\n+        if is_chalk_debug() { chalk::tls::set_current_program(db, solve) } else { solve() };\n \n     log::debug!(\"solve({:?}) => {:?}\", goal, solution);\n     solution\n }\n \n+fn is_chalk_debug() -> bool {\n+    std::env::var(\"CHALK_DEBUG\").is_ok()\n+}\n+\n fn solution_from_chalk(\n     db: &dyn HirDatabase,\n     solution: chalk_solve::Solution<Interner>,"}, {"sha": "c5f1b52324240d2c184b78096933adf1e86f59d7", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=a0a80a41034b1240dc3e8fd794ae1d4f77714d99", "patch": "@@ -20,6 +20,8 @@ use crate::{\n     ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n \n+pub(super) mod tls;\n+\n #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]\n pub struct Interner;\n \n@@ -33,90 +35,85 @@ impl chalk_ir::interner::Interner for Interner {\n     type Identifier = TypeAliasId;\n     type DefId = InternId;\n \n-    // FIXME: implement these\n     fn debug_struct_id(\n-        _type_kind_id: chalk_ir::StructId<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n+        type_kind_id: StructId,\n+        fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        None\n+        tls::with_current_program(|prog| Some(prog?.debug_struct_id(type_kind_id, fmt)))\n     }\n \n-    fn debug_trait_id(\n-        _type_kind_id: chalk_ir::TraitId<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        None\n+    fn debug_trait_id(type_kind_id: TraitId, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_trait_id(type_kind_id, fmt)))\n     }\n \n-    fn debug_assoc_type_id(\n-        _id: chalk_ir::AssocTypeId<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        None\n+    fn debug_assoc_type_id(id: AssocTypeId, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_assoc_type_id(id, fmt)))\n     }\n \n     fn debug_alias(\n-        _projection: &chalk_ir::AliasTy<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n+        alias: &chalk_ir::AliasTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        None\n+        tls::with_current_program(|prog| Some(prog?.debug_alias(alias, fmt)))\n     }\n \n-    fn debug_ty(_ty: &chalk_ir::Ty<Self>, _fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        None\n+    fn debug_ty(ty: &chalk_ir::Ty<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_ty(ty, fmt)))\n     }\n \n     fn debug_lifetime(\n-        _lifetime: &chalk_ir::Lifetime<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n+        lifetime: &chalk_ir::Lifetime<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        None\n+        tls::with_current_program(|prog| Some(prog?.debug_lifetime(lifetime, fmt)))\n     }\n \n     fn debug_parameter(\n-        _parameter: &Parameter<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n+        parameter: &Parameter<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        None\n+        tls::with_current_program(|prog| Some(prog?.debug_parameter(parameter, fmt)))\n     }\n \n-    fn debug_goal(_goal: &Goal<Self>, _fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        None\n+    fn debug_goal(goal: &Goal<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_goal(goal, fmt)))\n     }\n \n     fn debug_goals(\n-        _goals: &chalk_ir::Goals<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n+        goals: &chalk_ir::Goals<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        None\n+        tls::with_current_program(|prog| Some(prog?.debug_goals(goals, fmt)))\n     }\n \n     fn debug_program_clause_implication(\n-        _pci: &chalk_ir::ProgramClauseImplication<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n+        pci: &chalk_ir::ProgramClauseImplication<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        None\n+        tls::with_current_program(|prog| Some(prog?.debug_program_clause_implication(pci, fmt)))\n     }\n \n     fn debug_application_ty(\n-        _application_ty: &chalk_ir::ApplicationTy<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n+        application_ty: &chalk_ir::ApplicationTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        None\n+        tls::with_current_program(|prog| Some(prog?.debug_application_ty(application_ty, fmt)))\n     }\n \n     fn debug_substitution(\n-        _substitution: &chalk_ir::Substitution<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n+        substitution: &chalk_ir::Substitution<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        None\n+        tls::with_current_program(|prog| Some(prog?.debug_substitution(substitution, fmt)))\n     }\n \n     fn debug_separator_trait_ref(\n-        _separator_trait_ref: &chalk_ir::SeparatorTraitRef<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n+        separator_trait_ref: &chalk_ir::SeparatorTraitRef<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        None\n+        tls::with_current_program(|prog| {\n+            Some(prog?.debug_separator_trait_ref(separator_trait_ref, fmt))\n+        })\n     }\n \n     fn intern_ty(&self, ty: chalk_ir::TyData<Self>) -> Box<chalk_ir::TyData<Self>> {"}, {"sha": "d9bbb54a5bc5b1c8573968378a316ade61029d1b", "filename": "crates/ra_hir_ty/src/traits/chalk/tls.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0a80a41034b1240dc3e8fd794ae1d4f77714d99/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=a0a80a41034b1240dc3e8fd794ae1d4f77714d99", "patch": "@@ -0,0 +1,231 @@\n+//! Implementation of Chalk debug helper functions using TLS.\n+use std::fmt;\n+\n+use chalk_ir::{AliasTy, Goal, Goals, Lifetime, Parameter, ProgramClauseImplication, TypeName};\n+\n+use super::{from_chalk, Interner};\n+use crate::{db::HirDatabase, CallableDef, TypeCtor};\n+use hir_def::{AdtId, AssocContainerId, Lookup, TypeAliasId};\n+\n+pub use unsafe_tls::{set_current_program, with_current_program};\n+\n+pub struct DebugContext<'a>(&'a (dyn HirDatabase + 'a));\n+\n+impl DebugContext<'_> {\n+    pub fn debug_struct_id(\n+        &self,\n+        id: super::StructId,\n+        f: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        let type_ctor: TypeCtor = from_chalk(self.0, TypeName::Struct(id));\n+        match type_ctor {\n+            TypeCtor::Bool => write!(f, \"bool\")?,\n+            TypeCtor::Char => write!(f, \"char\")?,\n+            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Str => write!(f, \"str\")?,\n+            TypeCtor::Slice => write!(f, \"slice\")?,\n+            TypeCtor::Array => write!(f, \"array\")?,\n+            TypeCtor::RawPtr(m) => write!(f, \"*{}\", m.as_keyword_for_ptr())?,\n+            TypeCtor::Ref(m) => write!(f, \"&{}\", m.as_keyword_for_ref())?,\n+            TypeCtor::Never => write!(f, \"!\")?,\n+            TypeCtor::Tuple { .. } => {\n+                write!(f, \"()\")?;\n+            }\n+            TypeCtor::FnPtr { .. } => {\n+                write!(f, \"fn\")?;\n+            }\n+            TypeCtor::FnDef(def) => {\n+                let name = match def {\n+                    CallableDef::FunctionId(ff) => self.0.function_data(ff).name.clone(),\n+                    CallableDef::StructId(s) => self.0.struct_data(s).name.clone(),\n+                    CallableDef::EnumVariantId(e) => {\n+                        let enum_data = self.0.enum_data(e.parent);\n+                        enum_data.variants[e.local_id].name.clone()\n+                    }\n+                };\n+                match def {\n+                    CallableDef::FunctionId(_) => write!(f, \"{{fn {}}}\", name)?,\n+                    CallableDef::StructId(_) | CallableDef::EnumVariantId(_) => {\n+                        write!(f, \"{{ctor {}}}\", name)?\n+                    }\n+                }\n+            }\n+            TypeCtor::Adt(def_id) => {\n+                let name = match def_id {\n+                    AdtId::StructId(it) => self.0.struct_data(it).name.clone(),\n+                    AdtId::UnionId(it) => self.0.union_data(it).name.clone(),\n+                    AdtId::EnumId(it) => self.0.enum_data(it).name.clone(),\n+                };\n+                write!(f, \"{}\", name)?;\n+            }\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let trait_ = match type_alias.lookup(self.0.upcast()).container {\n+                    AssocContainerId::TraitId(it) => it,\n+                    _ => panic!(\"not an associated type\"),\n+                };\n+                let trait_name = self.0.trait_data(trait_).name.clone();\n+                let name = self.0.type_alias_data(type_alias).name.clone();\n+                write!(f, \"{}::{}\", trait_name, name)?;\n+            }\n+            TypeCtor::Closure { def, expr } => {\n+                write!(f, \"{{closure {:?} in {:?}}}\", expr.into_raw(), def)?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn debug_trait_id(\n+        &self,\n+        id: super::TraitId,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        let trait_: hir_def::TraitId = from_chalk(self.0, id);\n+        let trait_data = self.0.trait_data(trait_);\n+        write!(fmt, \"{}\", trait_data.name)\n+    }\n+\n+    pub fn debug_assoc_type_id(\n+        &self,\n+        id: super::AssocTypeId,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        let type_alias: TypeAliasId = from_chalk(self.0, id);\n+        let type_alias_data = self.0.type_alias_data(type_alias);\n+        let trait_ = match type_alias.lookup(self.0.upcast()).container {\n+            AssocContainerId::TraitId(t) => t,\n+            _ => panic!(\"associated type not in trait\"),\n+        };\n+        let trait_data = self.0.trait_data(trait_);\n+        write!(fmt, \"{}::{}\", trait_data.name, type_alias_data.name)\n+    }\n+\n+    pub fn debug_alias(\n+        &self,\n+        alias: &AliasTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        let type_alias: TypeAliasId = from_chalk(self.0, alias.associated_ty_id);\n+        let type_alias_data = self.0.type_alias_data(type_alias);\n+        let trait_ = match type_alias.lookup(self.0.upcast()).container {\n+            AssocContainerId::TraitId(t) => t,\n+            _ => panic!(\"associated type not in trait\"),\n+        };\n+        let trait_data = self.0.trait_data(trait_);\n+        let params = alias.substitution.parameters(&Interner);\n+        write!(\n+            fmt,\n+            \"<{:?} as {}<{:?}>>::{}\",\n+            &params[0],\n+            trait_data.name,\n+            &params[1..],\n+            type_alias_data.name\n+        )\n+    }\n+\n+    pub fn debug_ty(\n+        &self,\n+        ty: &chalk_ir::Ty<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        write!(fmt, \"{:?}\", ty.data(&Interner))\n+    }\n+\n+    pub fn debug_lifetime(\n+        &self,\n+        lifetime: &Lifetime<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        write!(fmt, \"{:?}\", lifetime.data(&Interner))\n+    }\n+\n+    pub fn debug_parameter(\n+        &self,\n+        parameter: &Parameter<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        write!(fmt, \"{:?}\", parameter.data(&Interner).inner_debug())\n+    }\n+\n+    pub fn debug_goal(\n+        &self,\n+        goal: &Goal<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        let goal_data = goal.data(&Interner);\n+        write!(fmt, \"{:?}\", goal_data)\n+    }\n+\n+    pub fn debug_goals(\n+        &self,\n+        goals: &Goals<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        write!(fmt, \"{:?}\", goals.debug(&Interner))\n+    }\n+\n+    pub fn debug_program_clause_implication(\n+        &self,\n+        pci: &ProgramClauseImplication<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        write!(fmt, \"{:?}\", pci.debug(&Interner))\n+    }\n+\n+    pub fn debug_application_ty(\n+        &self,\n+        application_ty: &chalk_ir::ApplicationTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        write!(fmt, \"{:?}\", application_ty.debug(&Interner))\n+    }\n+\n+    pub fn debug_substitution(\n+        &self,\n+        substitution: &chalk_ir::Substitution<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        write!(fmt, \"{:?}\", substitution.debug(&Interner))\n+    }\n+\n+    pub fn debug_separator_trait_ref(\n+        &self,\n+        separator_trait_ref: &chalk_ir::SeparatorTraitRef<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        write!(fmt, \"{:?}\", separator_trait_ref.debug(&Interner))\n+    }\n+}\n+\n+mod unsafe_tls {\n+    use super::DebugContext;\n+    use crate::db::HirDatabase;\n+    use scoped_tls::scoped_thread_local;\n+\n+    scoped_thread_local!(static PROGRAM: DebugContext);\n+\n+    pub fn with_current_program<R>(\n+        op: impl for<'a> FnOnce(Option<&'a DebugContext<'a>>) -> R,\n+    ) -> R {\n+        if PROGRAM.is_set() {\n+            PROGRAM.with(|prog| op(Some(prog)))\n+        } else {\n+            op(None)\n+        }\n+    }\n+\n+    pub fn set_current_program<OP, R>(p: &dyn HirDatabase, op: OP) -> R\n+    where\n+        OP: FnOnce() -> R,\n+    {\n+        let ctx = DebugContext(p);\n+        // we're transmuting the lifetime in the DebugContext to static. This is\n+        // fine because we only keep the reference for the lifetime of this\n+        // function, *and* the only way to access the context is through\n+        // `with_current_program`, which hides the lifetime through the `for`\n+        // type.\n+        let static_p: &DebugContext<'static> =\n+            unsafe { std::mem::transmute::<&DebugContext, &DebugContext<'static>>(&ctx) };\n+        PROGRAM.set(static_p, || op())\n+    }\n+}"}]}