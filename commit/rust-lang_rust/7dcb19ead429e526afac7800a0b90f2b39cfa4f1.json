{"sha": "7dcb19ead429e526afac7800a0b90f2b39cfa4f1", "node_id": "C_kwDOAAsO6NoAKDdkY2IxOWVhZDQyOWU1MjZhZmFjNzgwMGEwYjkwZjJiMzljZmE0ZjE", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-23T21:05:16Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:57Z"}, "message": "Add rust-only operation tests", "tree": {"sha": "3c54dad0c8969127310aa978f16b879c09625782", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c54dad0c8969127310aa978f16b879c09625782"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dcb19ead429e526afac7800a0b90f2b39cfa4f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRF0ACgkQGBtJ+fOP\nM3Qt8wwAmtLJiVW1muAYWfHunDpQE3MNL2M+B7b4HSV7Kyq7OUZk5tSbe8vfxDQb\n4e0LpfmiwkIrdya/+lCWoRRyanVhLAf1TbCc6ExM0TnOFStmqN9tUetE5IPlZQrC\n5cn+LnA5GJT5oYu1IF9omnz89Zr9unctaeg62tSIZkyZ7Wfi463/XLmC2WqFl2uf\nWMEUQf34vg2ZNlE1u5xnUowGA116jbahsprHNXIYI2yO3QJwCS41sl5pjsLI/hec\nMGVW37uUdlB7xXttIiCb+YFIZh+K0eucBbWsGDhqsgPFegBigzs/jyAiuaQt68ck\nYKQQm2dm8KHU4E2Wbj0F8C71lbTMecaEqJunzftqoAtTih03RInqbpHBj0dYP+T8\ngyE5PzhT9Cm04DM45pkLWzHUICKm0AT/Uy+Ow/5KwAiM2I321BGDLuLEviv64Gv+\nZ3LpiuSt/O4f2uTz4ViWvD12hBn3gnFF6vtpUvfiIVEdCUuTBUrqL9TSWmNCyvES\nOleXhTNB\n=rDUv\n-----END PGP SIGNATURE-----", "payload": "tree 3c54dad0c8969127310aa978f16b879c09625782\nparent dafd813c16231834d3bce7875a8c616d1e49a8c1\nauthor Andy Wang <cbeuw.andy@gmail.com> 1653339916 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539357 +0100\n\nAdd rust-only operation tests\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dcb19ead429e526afac7800a0b90f2b39cfa4f1", "html_url": "https://github.com/rust-lang/rust/commit/7dcb19ead429e526afac7800a0b90f2b39cfa4f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dcb19ead429e526afac7800a0b90f2b39cfa4f1/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dafd813c16231834d3bce7875a8c616d1e49a8c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/dafd813c16231834d3bce7875a8c616d1e49a8c1", "html_url": "https://github.com/rust-lang/rust/commit/dafd813c16231834d3bce7875a8c616d1e49a8c1"}], "stats": {"total": 116, "additions": 81, "deletions": 35}, "files": [{"sha": "6f91e147fa8340f32de1ecca2214c7d75c2734c0", "filename": "tests/compile-fail/weak_memory/imperfectly_overlapping.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dafd813c16231834d3bce7875a8c616d1e49a8c1/tests%2Fcompile-fail%2Fweak_memory%2Fimperfectly_overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafd813c16231834d3bce7875a8c616d1e49a8c1/tests%2Fcompile-fail%2Fweak_memory%2Fimperfectly_overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fweak_memory%2Fimperfectly_overlapping.rs?ref=dafd813c16231834d3bce7875a8c616d1e49a8c1", "patch": "@@ -1,35 +0,0 @@\n-// ignore-windows: Concurrency on Windows is not supported yet.\n-#![feature(atomic_from_mut)]\n-#![feature(core_intrinsics)]\n-\n-use std::intrinsics::atomic_load;\n-use std::sync::atomic::Ordering::*;\n-use std::sync::atomic::{AtomicU16, AtomicU32};\n-\n-fn split_u32(dword: &mut u32) -> &mut [u16; 2] {\n-    unsafe { std::mem::transmute::<&mut u32, &mut [u16; 2]>(dword) }\n-}\n-\n-fn test_same_thread() {\n-    let mut dword = AtomicU32::new(42);\n-    assert_eq!(dword.load(Relaxed), 42);\n-    dword.store(0xabbafafa, Relaxed);\n-\n-    let dword_mut = dword.get_mut();\n-\n-    let words_mut = split_u32(dword_mut);\n-\n-    let (hi_mut, lo_mut) = words_mut.split_at_mut(1);\n-\n-    let (hi, _) = (AtomicU16::from_mut(&mut hi_mut[0]), AtomicU16::from_mut(&mut lo_mut[0]));\n-\n-    unsafe {\n-        // Equivalent to: hi.load(Ordering::SeqCst)\n-        // We need to use intrisics to for precise error location\n-        atomic_load(hi.get_mut() as *mut u16); //~ ERROR: mixed-size access on an existing atomic object\n-    }\n-}\n-\n-pub fn main() {\n-    test_same_thread();\n-}"}, {"sha": "b20ec583499093f614806c1bee243f36d3ba3037", "filename": "tests/run-pass/weak_memory/extra_cpp.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7dcb19ead429e526afac7800a0b90f2b39cfa4f1/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dcb19ead429e526afac7800a0b90f2b39cfa4f1/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp.rs?ref=7dcb19ead429e526afac7800a0b90f2b39cfa4f1", "patch": "@@ -0,0 +1,79 @@\n+// compile-flags: -Zmiri-ignore-leaks\n+\n+// Tests operations not perfomable through C++'s atomic API\n+// but doable in safe (at least sound) Rust.\n+\n+#![feature(atomic_from_mut)]\n+\n+use std::sync::atomic::Ordering::*;\n+use std::sync::atomic::{AtomicU16, AtomicU32, AtomicUsize};\n+use std::thread::spawn;\n+\n+fn static_atomic_mut(val: usize) -> &'static mut AtomicUsize {\n+    let ret = Box::leak(Box::new(AtomicUsize::new(val)));\n+    ret\n+}\n+\n+fn split_u32(dword: &mut u32) -> &mut [u16; 2] {\n+    unsafe { std::mem::transmute::<&mut u32, &mut [u16; 2]>(dword) }\n+}\n+\n+fn mem_replace() {\n+    let mut x = AtomicU32::new(0);\n+\n+    let old_x = std::mem::replace(&mut x, AtomicU32::new(42));\n+\n+    assert_eq!(x.load(Relaxed), 42);\n+    assert_eq!(old_x.load(Relaxed), 0);\n+}\n+\n+fn assign_to_mut() {\n+    let x = static_atomic_mut(0);\n+    x.store(1, Relaxed);\n+\n+    *x = AtomicUsize::new(2);\n+\n+    assert_eq!(x.load(Relaxed), 2);\n+}\n+\n+fn get_mut_write() {\n+    let x = static_atomic_mut(0);\n+    x.store(1, Relaxed);\n+    {\n+        let x_mut = x.get_mut();\n+        *x_mut = 2;\n+    }\n+\n+    let j1 = spawn(move || x.load(Relaxed));\n+\n+    let r1 = j1.join().unwrap();\n+    assert_eq!(r1, 2);\n+}\n+\n+// This is technically doable in C++ with atomic_ref\n+// but little literature exists atm on its involvement\n+// in mixed size/atomicity accesses\n+fn from_mut_split() {\n+    let mut x: u32 = 0;\n+\n+    {\n+        let x_atomic = AtomicU32::from_mut(&mut x);\n+        x_atomic.store(u32::from_be(0xabbafafa), Relaxed);\n+    }\n+\n+    let (x_hi, x_lo) = split_u32(&mut x).split_at_mut(1);\n+\n+    let x_hi_atomic = AtomicU16::from_mut(&mut x_hi[0]);\n+    let x_lo_atomic = AtomicU16::from_mut(&mut x_lo[0]);\n+\n+    assert_eq!(x_hi_atomic.load(Relaxed), u16::from_be(0xabba));\n+    assert_eq!(x_lo_atomic.load(Relaxed), u16::from_be(0xfafa));\n+}\n+\n+\n+pub fn main() {\n+    get_mut_write();\n+    from_mut_split();\n+    assign_to_mut();\n+    mem_replace();\n+}"}, {"sha": "1d0ce4b3853dacd1621931ea3bf13724cf6fee68", "filename": "tests/run-pass/weak_memory/extra_cpp.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7dcb19ead429e526afac7800a0b90f2b39cfa4f1/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7dcb19ead429e526afac7800a0b90f2b39cfa4f1/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fextra_cpp.stderr?ref=7dcb19ead429e526afac7800a0b90f2b39cfa4f1", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental: weak memory effects are not fully compatible with the Rust atomics memory model.\n+"}]}