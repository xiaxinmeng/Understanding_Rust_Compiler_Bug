{"sha": "696a7a5a410f419cf7f6638d9f4894802640adf8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NmE3YTVhNDEwZjQxOWNmN2Y2NjM4ZDlmNDg5NDgwMjY0MGFkZjg=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-12T11:58:02Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T14:52:37Z"}, "message": "lower traits", "tree": {"sha": "0a2a708397589b4fa088457e6f3db942effe7de8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a2a708397589b4fa088457e6f3db942effe7de8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/696a7a5a410f419cf7f6638d9f4894802640adf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/696a7a5a410f419cf7f6638d9f4894802640adf8", "html_url": "https://github.com/rust-lang/rust/commit/696a7a5a410f419cf7f6638d9f4894802640adf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/696a7a5a410f419cf7f6638d9f4894802640adf8/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34bc80650b93bf422039af31844898f427cc375c", "url": "https://api.github.com/repos/rust-lang/rust/commits/34bc80650b93bf422039af31844898f427cc375c", "html_url": "https://github.com/rust-lang/rust/commit/34bc80650b93bf422039af31844898f427cc375c"}], "stats": {"total": 237, "additions": 208, "deletions": 29}, "files": [{"sha": "c2d00adebc58d231bc71652801b71786802adbb3", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/696a7a5a410f419cf7f6638d9f4894802640adf8/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/696a7a5a410f419cf7f6638d9f4894802640adf8/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=696a7a5a410f419cf7f6638d9f4894802640adf8", "patch": "@@ -1018,6 +1018,7 @@ dependencies = [\n  \"ra_syntax\",\n  \"ra_tt\",\n  \"rustc-hash\",\n+ \"smallvec\",\n  \"stdx\",\n  \"test_utils\",\n ]"}, {"sha": "6d43924e3007c947970de0705475c944fba73df5", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/696a7a5a410f419cf7f6638d9f4894802640adf8/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/696a7a5a410f419cf7f6638d9f4894802640adf8/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=696a7a5a410f419cf7f6638d9f4894802640adf8", "patch": "@@ -17,6 +17,7 @@ drop_bomb = \"0.1.4\"\n fst = { version = \"0.4\", default-features = false }\n itertools = \"0.9.0\"\n indexmap = \"1.4.0\"\n+smallvec = \"1.4.0\"\n \n stdx = { path = \"../stdx\" }\n "}, {"sha": "3ea6e10c9805974af23cd08f5546acadebcf205b", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "modified", "additions": 206, "deletions": 29, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/696a7a5a410f419cf7f6638d9f4894802640adf8/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696a7a5a410f419cf7f6638d9f4894802640adf8/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=696a7a5a410f419cf7f6638d9f4894802640adf8", "patch": "@@ -4,25 +4,28 @@ use hir_expand::{\n     ast_id_map::{AstIdMap, FileAstId},\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    HirFileId,\n+    HirFileId, InFile,\n };\n use ra_arena::{Arena, Idx, RawId};\n use ra_syntax::{ast, match_ast};\n \n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    generics::GenericParams,\n+    generics,\n     path::{path, AssociatedTypeBinding, GenericArgs, ImportAlias, ModPath, Path},\n     type_ref::{Mutability, TypeBound, TypeRef},\n     visibility::RawVisibility,\n };\n-use ast::{AstNode, ModuleItemOwner, NameOwner, StructKind, TypeAscriptionOwner};\n+use ast::{AstNode, AttrsOwner, ModuleItemOwner, NameOwner, StructKind, TypeAscriptionOwner};\n+use either::Either;\n+use smallvec::SmallVec;\n use std::{\n     ops::{Index, Range},\n     sync::Arc,\n };\n \n+/// The item tree of a source file.\n #[derive(Debug, Default, Eq, PartialEq)]\n pub struct ItemTree {\n     top_level: Vec<ModItem>,\n@@ -70,6 +73,7 @@ impl ItemTree {\n         let ctx = Ctx {\n             tree: ItemTree::default(),\n             hygiene: Hygiene::new(db.upcast(), file_id),\n+            file: file_id,\n             source_ast_id_map: map,\n             body_ctx: crate::body::LowerCtx::new(db, file_id),\n         };\n@@ -115,6 +119,7 @@ impl_index!(\n     exprs: Expr,\n );\n \n+/// A desugared `extern crate` or `use` import.\n #[derive(Debug, Eq, PartialEq)]\n pub struct Import {\n     pub path: ModPath,\n@@ -131,19 +136,20 @@ pub struct Function {\n     pub name: Name,\n     pub attrs: Attrs,\n     pub visibility: RawVisibility,\n-    pub generic_params: GenericParams,\n+    pub generic_params: generics::GenericParams,\n     pub has_self_param: bool,\n     pub params: Vec<TypeRef>,\n     pub ret_type: TypeRef,\n     pub ast: FileAstId<ast::FnDef>,\n+    // FIXME inner items\n }\n \n #[derive(Debug, Eq, PartialEq)]\n pub struct Struct {\n     pub name: Name,\n     pub attrs: Attrs,\n     pub visibility: RawVisibility,\n-    pub generic_params: GenericParams,\n+    pub generic_params: generics::GenericParams,\n     pub fields: Fields,\n     pub ast: FileAstId<ast::StructDef>,\n }\n@@ -153,7 +159,7 @@ pub struct Union {\n     pub name: Name,\n     pub attrs: Attrs,\n     pub visibility: RawVisibility,\n-    pub generic_params: GenericParams,\n+    pub generic_params: generics::GenericParams,\n     pub fields: Fields,\n }\n \n@@ -162,7 +168,7 @@ pub struct Enum {\n     pub name: Name,\n     pub attrs: Attrs,\n     pub visibility: RawVisibility,\n-    pub generic_params: GenericParams,\n+    pub generic_params: generics::GenericParams,\n     pub variants: Range<Idx<Variant>>,\n }\n \n@@ -185,14 +191,14 @@ pub struct Static {\n pub struct Trait {\n     pub name: Name,\n     pub visibility: RawVisibility,\n-    pub generic_params: GenericParams,\n+    pub generic_params: generics::GenericParams,\n     pub auto: bool,\n     pub items: Vec<AssocItem>,\n }\n \n #[derive(Debug, Eq, PartialEq)]\n pub struct Impl {\n-    pub generic_params: GenericParams,\n+    pub generic_params: generics::GenericParams,\n     pub target_trait: Option<TypeRef>,\n     pub target_type: TypeRef,\n     pub is_negative: bool,\n@@ -203,7 +209,7 @@ pub struct Impl {\n pub struct TypeAlias {\n     pub name: Name,\n     pub visibility: RawVisibility,\n-    pub generic_params: GenericParams,\n+    pub generic_params: generics::GenericParams,\n     pub type_ref: Option<TypeRef>,\n }\n \n@@ -218,8 +224,12 @@ pub struct Mod {\n pub struct MacroCall {\n     pub name: Option<Name>,\n     pub path: ModPath,\n-    pub export: bool,\n-    pub builtin: bool,\n+    /// Has `#[macro_export]`.\n+    pub is_export: bool,\n+    /// Has `#[macro_export(local_inner_macros)]`.\n+    pub is_local_inner: bool,\n+    /// Has `#[rustc_builtin_macro]`.\n+    pub is_builtin: bool,\n     pub ast_id: FileAstId<ast::MacroCall>,\n }\n \n@@ -307,20 +317,36 @@ pub struct Field {\n     pub visibility: RawVisibility,\n }\n \n+struct ModItems(SmallVec<[ModItem; 1]>);\n+\n+impl<T> From<T> for ModItems\n+where\n+    T: Into<ModItem>,\n+{\n+    fn from(t: T) -> Self {\n+        ModItems(SmallVec::from_buf([t.into(); 1]))\n+    }\n+}\n+\n struct Ctx {\n     tree: ItemTree,\n     hygiene: Hygiene,\n+    file: HirFileId,\n     source_ast_id_map: Arc<AstIdMap>,\n     body_ctx: crate::body::LowerCtx,\n }\n \n impl Ctx {\n     fn lower(mut self, item_owner: &dyn ModuleItemOwner) -> ItemTree {\n-        self.tree.top_level = item_owner.items().flat_map(|item| self.lower_item(&item)).collect();\n+        self.tree.top_level = item_owner\n+            .items()\n+            .flat_map(|item| self.lower_mod_item(&item))\n+            .flat_map(|items| items.0)\n+            .collect();\n         self.tree\n     }\n \n-    fn lower_item(&mut self, item: &ast::ModuleItem) -> Option<ModItem> {\n+    fn lower_mod_item(&mut self, item: &ast::ModuleItem) -> Option<ModItems> {\n         match item {\n             ast::ModuleItem::StructDef(ast) => {\n                 self.lower_struct(ast).map(|data| self.tree.structs.alloc(data).into())\n@@ -347,12 +373,48 @@ impl Ctx {\n             ast::ModuleItem::Module(ast) => {\n                 self.lower_module(ast).map(|data| self.tree.mods.alloc(data).into())\n             }\n-            ast::ModuleItem::TraitDef(_) => todo!(),\n-            ast::ModuleItem::ImplDef(_) => todo!(),\n-            ast::ModuleItem::UseItem(_) => todo!(),\n-            ast::ModuleItem::ExternCrateItem(_) => todo!(),\n-            ast::ModuleItem::MacroCall(_) => todo!(),\n-            ast::ModuleItem::ExternBlock(_) => todo!(),\n+            ast::ModuleItem::TraitDef(ast) => {\n+                self.lower_trait(ast).map(|data| self.tree.traits.alloc(data).into())\n+            }\n+            ast::ModuleItem::ImplDef(ast) => {\n+                self.lower_impl(ast).map(|data| self.tree.impls.alloc(data).into())\n+            }\n+            ast::ModuleItem::UseItem(ast) => Some(ModItems(\n+                self.lower_use(ast)\n+                    .into_iter()\n+                    .map(|data| self.tree.imports.alloc(data).into())\n+                    .collect::<SmallVec<_>>(),\n+            )),\n+            ast::ModuleItem::ExternCrateItem(ast) => {\n+                self.lower_extern_crate(ast).map(|data| self.tree.imports.alloc(data).into())\n+            }\n+            ast::ModuleItem::MacroCall(ast) => {\n+                self.lower_macro_call(ast).map(|data| self.tree.macro_calls.alloc(data).into())\n+            }\n+            ast::ModuleItem::ExternBlock(ast) => Some(ModItems(\n+                self.lower_extern_block(ast)\n+                    .into_iter()\n+                    .map(|item| match item {\n+                        Either::Left(func) => self.tree.functions.alloc(func).into(),\n+                        Either::Right(statik) => self.tree.statics.alloc(statik).into(),\n+                    })\n+                    .collect::<SmallVec<_>>(),\n+            )),\n+        }\n+    }\n+\n+    fn lower_assoc_item(&mut self, item: &ast::AssocItem) -> Option<AssocItem> {\n+        match item {\n+            ast::AssocItem::FnDef(ast) => {\n+                self.lower_function(ast).map(|data| self.tree.functions.alloc(data).into())\n+            }\n+            ast::AssocItem::TypeAliasDef(ast) => {\n+                self.lower_type_alias(ast).map(|data| self.tree.type_aliases.alloc(data).into())\n+            }\n+            ast::AssocItem::ConstDef(ast) => {\n+                let data = self.lower_const(ast);\n+                Some(self.tree.consts.alloc(data).into())\n+            }\n         }\n     }\n \n@@ -385,7 +447,7 @@ impl Ctx {\n         let start = self.next_field_idx();\n         for field in fields.fields() {\n             if let Some(data) = self.lower_record_field(&field) {\n-                let idx = self.tree.fields.alloc(data);\n+                self.tree.fields.alloc(data);\n             }\n         }\n         let end = self.next_field_idx();\n@@ -404,7 +466,7 @@ impl Ctx {\n         let start = self.next_field_idx();\n         for (i, field) in fields.fields().enumerate() {\n             if let Some(data) = self.lower_tuple_field(i, &field) {\n-                let idx = self.tree.fields.alloc(data);\n+                self.tree.fields.alloc(data);\n             }\n         }\n         let end = self.next_field_idx();\n@@ -451,7 +513,7 @@ impl Ctx {\n         let start = self.next_variant_idx();\n         for variant in variants.variants() {\n             if let Some(data) = self.lower_variant(&variant) {\n-                let idx = self.tree.variants.alloc(data);\n+                self.tree.variants.alloc(data);\n             }\n         }\n         let end = self.next_variant_idx();\n@@ -551,14 +613,129 @@ impl Ctx {\n     fn lower_module(&mut self, module: &ast::Module) -> Option<Mod> {\n         let name = module.name()?.as_name();\n         let visibility = self.lower_visibility(module);\n-        let items = module\n-            .item_list()\n-            .map(move |list| list.items().flat_map(move |item| self.lower_item(&item)).collect());\n+        let items = module.item_list().map(move |list| {\n+            list.items()\n+                .flat_map(move |item| self.lower_mod_item(&item))\n+                .flat_map(|items| items.0)\n+                .collect()\n+        });\n         Some(Mod { name, visibility, items: items.unwrap_or_default() })\n     }\n \n-    fn lower_generic_params(&mut self, _item: &impl ast::TypeParamsOwner) -> GenericParams {\n-        None.unwrap()\n+    fn lower_trait(&mut self, trait_def: &ast::TraitDef) -> Option<Trait> {\n+        let name = trait_def.name()?.as_name();\n+        let visibility = self.lower_visibility(trait_def);\n+        let generic_params = self.lower_generic_params(trait_def);\n+        let auto = trait_def.auto_token().is_some();\n+        let items = trait_def.item_list().map(move |list| {\n+            // FIXME: Does not handle macros\n+            list.assoc_items().flat_map(move |item| self.lower_assoc_item(&item)).collect()\n+        });\n+        Some(Trait { name, visibility, generic_params, auto, items: items.unwrap_or_default() })\n+    }\n+\n+    fn lower_impl(&mut self, impl_def: &ast::ImplDef) -> Option<Impl> {\n+        let generic_params = self.lower_generic_params(impl_def);\n+        let target_trait = impl_def.target_trait().map(|tr| self.lower_type_ref(&tr));\n+        let target_type = self.lower_type_ref(&impl_def.target_type()?);\n+        let is_negative = impl_def.excl_token().is_some();\n+        let items = impl_def\n+            .item_list()?\n+            .assoc_items()\n+            .filter_map(|item| self.lower_assoc_item(&item))\n+            .collect();\n+        Some(Impl { generic_params, target_trait, target_type, is_negative, items })\n+    }\n+\n+    fn lower_use(&mut self, use_item: &ast::UseItem) -> Vec<Import> {\n+        // FIXME: cfg_attr\n+        let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n+        let visibility = self.lower_visibility(use_item);\n+\n+        // Every use item can expand to many `Import`s.\n+        let mut imports = Vec::new();\n+        ModPath::expand_use_item(\n+            InFile::new(self.file, use_item.clone()),\n+            &self.hygiene,\n+            |path, _tree, is_glob, alias| {\n+                imports.push(Import {\n+                    path,\n+                    alias,\n+                    visibility: visibility.clone(),\n+                    is_glob,\n+                    is_prelude,\n+                    is_extern_crate: false,\n+                    is_macro_use: false,\n+                });\n+            },\n+        );\n+\n+        imports\n+    }\n+\n+    fn lower_extern_crate(&mut self, extern_crate: &ast::ExternCrateItem) -> Option<Import> {\n+        let path = ModPath::from_name_ref(&extern_crate.name_ref()?);\n+        let alias = extern_crate.alias().map(|a| {\n+            a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n+        });\n+        let visibility = self.lower_visibility(extern_crate);\n+        // FIXME: cfg_attr\n+        let is_macro_use = extern_crate.has_atom_attr(\"macro_use\");\n+\n+        Some(Import {\n+            path,\n+            alias,\n+            visibility,\n+            is_glob: false,\n+            is_prelude: false,\n+            is_extern_crate: true,\n+            is_macro_use,\n+        })\n+    }\n+\n+    fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<MacroCall> {\n+        let name = m.name().map(|it| it.as_name());\n+        let attrs = Attrs::new(m, &self.hygiene);\n+        let path = ModPath::from_src(m.path()?, &self.hygiene)?;\n+\n+        let ast_id = self.source_ast_id_map.ast_id(m);\n+\n+        // FIXME: cfg_attr\n+        let export_attr = attrs.by_key(\"macro_export\");\n+\n+        let is_export = export_attr.exists();\n+        let is_local_inner = if is_export {\n+            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                    ident.text.contains(\"local_inner_macros\")\n+                }\n+                _ => false,\n+            })\n+        } else {\n+            false\n+        };\n+\n+        let is_builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n+        Some(MacroCall { name, path, is_export, is_builtin, is_local_inner, ast_id })\n+    }\n+\n+    fn lower_extern_block(&mut self, block: &ast::ExternBlock) -> Vec<Either<Function, Static>> {\n+        block.extern_item_list().map_or(Vec::new(), |list| {\n+            list.extern_items()\n+                .filter_map(|item| match item {\n+                    ast::ExternItem::FnDef(ast) => self.lower_function(&ast).map(Either::Left),\n+                    ast::ExternItem::StaticDef(ast) => self.lower_static(&ast).map(Either::Right),\n+                })\n+                .collect()\n+        })\n+    }\n+\n+    fn lower_generic_params(\n+        &mut self,\n+        _item: &impl ast::TypeParamsOwner,\n+    ) -> generics::GenericParams {\n+        // TODO\n+        generics::GenericParams { types: Arena::new(), where_predicates: Vec::new() }\n     }\n \n     fn lower_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n@@ -583,7 +760,7 @@ impl Ctx {\n }\n \n fn desugar_future_path(orig: TypeRef) -> Path {\n-    let path = path![std::future::Future];\n+    let path = path![core::future::Future];\n     let mut generic_args: Vec<_> = std::iter::repeat(None).take(path.segments.len() - 1).collect();\n     let mut last = GenericArgs::empty();\n     let binding ="}]}