{"sha": "df71d0874a09610ad7fd8f44cde2ad8df83d6182", "node_id": "C_kwDOAAsO6NoAKGRmNzFkMDg3NGEwOTYxMGFkN2ZkOGY0NGNkZTJhZDhkZjgzZDYxODI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-11T18:08:17Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-20T16:41:28Z"}, "message": "Compute query vtable manually.", "tree": {"sha": "097eb9bb6ca04b891a95c4a3f687bee833d2cf64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/097eb9bb6ca04b891a95c4a3f687bee833d2cf64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df71d0874a09610ad7fd8f44cde2ad8df83d6182", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df71d0874a09610ad7fd8f44cde2ad8df83d6182", "html_url": "https://github.com/rust-lang/rust/commit/df71d0874a09610ad7fd8f44cde2ad8df83d6182", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df71d0874a09610ad7fd8f44cde2ad8df83d6182/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69a35946351ff5a2a3e25aea3f1b69abf0959aad", "url": "https://api.github.com/repos/rust-lang/rust/commits/69a35946351ff5a2a3e25aea3f1b69abf0959aad", "html_url": "https://github.com/rust-lang/rust/commit/69a35946351ff5a2a3e25aea3f1b69abf0959aad"}], "stats": {"total": 56, "additions": 29, "deletions": 27}, "files": [{"sha": "fc3b7980dfb17f4584f92975e15222d6a04355de", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df71d0874a09610ad7fd8f44cde2ad8df83d6182/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df71d0874a09610ad7fd8f44cde2ad8df83d6182/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=df71d0874a09610ad7fd8f44cde2ad8df83d6182", "patch": "@@ -24,6 +24,7 @@ pub(crate) struct QueryVtable<CTX: QueryContext, K, V> {\n     pub dep_kind: CTX::DepKind,\n     pub eval_always: bool,\n \n+    pub compute: fn(CTX::DepContext, K) -> V,\n     pub hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n     pub handle_cycle_error: fn(CTX, DiagnosticBuilder<'_>) -> V,\n     pub cache_on_disk: fn(CTX, &K, Option<&V>) -> bool,\n@@ -38,6 +39,10 @@ impl<CTX: QueryContext, K, V> QueryVtable<CTX, K, V> {\n         DepNode::construct(tcx, self.dep_kind, key)\n     }\n \n+    pub(crate) fn compute(&self, tcx: CTX::DepContext, key: K) -> V {\n+        (self.compute)(tcx, key)\n+    }\n+\n     pub(crate) fn cache_on_disk(&self, tcx: CTX, key: &K, value: Option<&V>) -> bool {\n         (self.cache_on_disk)(tcx, key, value)\n     }\n@@ -87,21 +92,24 @@ pub trait QueryDescription<CTX: QueryContext>: QueryAccessors<CTX> {\n }\n \n pub(crate) trait QueryVtableExt<CTX: QueryContext, K, V> {\n-    const VTABLE: QueryVtable<CTX, K, V>;\n+    fn make_vtable(tcx: CTX, key: &K) -> QueryVtable<CTX, K, V>;\n }\n \n impl<CTX, Q> QueryVtableExt<CTX, Q::Key, Q::Value> for Q\n where\n     CTX: QueryContext,\n     Q: QueryDescription<CTX>,\n {\n-    const VTABLE: QueryVtable<CTX, Q::Key, Q::Value> = QueryVtable {\n-        anon: Q::ANON,\n-        dep_kind: Q::DEP_KIND,\n-        eval_always: Q::EVAL_ALWAYS,\n-        hash_result: Q::HASH_RESULT,\n-        handle_cycle_error: Q::handle_cycle_error,\n-        cache_on_disk: Q::cache_on_disk,\n-        try_load_from_disk: Q::try_load_from_disk,\n-    };\n+    fn make_vtable(tcx: CTX, key: &Q::Key) -> QueryVtable<CTX, Q::Key, Q::Value> {\n+        QueryVtable {\n+            anon: Q::ANON,\n+            dep_kind: Q::DEP_KIND,\n+            eval_always: Q::EVAL_ALWAYS,\n+            hash_result: Q::HASH_RESULT,\n+            compute: Q::compute_fn(tcx, key),\n+            handle_cycle_error: Q::handle_cycle_error,\n+            cache_on_disk: Q::cache_on_disk,\n+            try_load_from_disk: Q::try_load_from_disk,\n+        }\n+    }\n }"}, {"sha": "1326ad4f6c1c0c6739a2debfe3cc8fd00fcbe078", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df71d0874a09610ad7fd8f44cde2ad8df83d6182/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df71d0874a09610ad7fd8f44cde2ad8df83d6182/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=df71d0874a09610ad7fd8f44cde2ad8df83d6182", "patch": "@@ -382,7 +382,6 @@ fn try_execute_query<CTX, C>(\n     lookup: QueryLookup,\n     dep_node: Option<DepNode<CTX::DepKind>>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n-    compute: fn(CTX::DepContext, C::Key) -> C::Value,\n ) -> (C::Stored, Option<DepNodeIndex>)\n where\n     C: QueryCache,\n@@ -398,7 +397,7 @@ where\n         query.dep_kind,\n     ) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(tcx, key, dep_node, query, job.id, compute);\n+            let (result, dep_node_index) = execute_job(tcx, key, dep_node, query, job.id);\n             let result = job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n@@ -429,7 +428,6 @@ fn execute_job<CTX, K, V>(\n     mut dep_node_opt: Option<DepNode<CTX::DepKind>>,\n     query: &QueryVtable<CTX, K, V>,\n     job_id: QueryJobId<CTX::DepKind>,\n-    compute: fn(CTX::DepContext, K) -> V,\n ) -> (V, DepNodeIndex)\n where\n     K: Clone + DepNodeParams<CTX::DepContext>,\n@@ -441,7 +439,7 @@ where\n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n         let prof_timer = tcx.dep_context().profiler().query_provider();\n-        let result = tcx.start_query(job_id, None, || compute(*tcx.dep_context(), key));\n+        let result = tcx.start_query(job_id, None, || query.compute(*tcx.dep_context(), key));\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n         return (result, dep_node_index);\n@@ -455,7 +453,7 @@ where\n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         if let Some(ret) = tcx.start_query(job_id, None, || {\n-            try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query, compute)\n+            try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query)\n         }) {\n             return ret;\n         }\n@@ -467,14 +465,14 @@ where\n     let (result, dep_node_index) = tcx.start_query(job_id, Some(&diagnostics), || {\n         if query.anon {\n             return dep_graph.with_anon_task(*tcx.dep_context(), query.dep_kind, || {\n-                compute(*tcx.dep_context(), key)\n+                query.compute(*tcx.dep_context(), key)\n             });\n         }\n \n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node = dep_node_opt.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n \n-        dep_graph.with_task(dep_node, *tcx.dep_context(), key, compute, query.hash_result)\n+        dep_graph.with_task(dep_node, *tcx.dep_context(), key, query.compute, query.hash_result)\n     });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -498,7 +496,6 @@ fn try_load_from_disk_and_cache_in_memory<CTX, K, V>(\n     key: &K,\n     dep_node: &DepNode<CTX::DepKind>,\n     query: &QueryVtable<CTX, K, V>,\n-    compute: fn(CTX::DepContext, K) -> V,\n ) -> Option<(V, DepNodeIndex)>\n where\n     K: Clone,\n@@ -544,7 +541,7 @@ where\n     let prof_timer = tcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| compute(*tcx.dep_context(), key.clone()));\n+    let result = dep_graph.with_ignore(|| query.compute(*tcx.dep_context(), key.clone()));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -682,9 +679,9 @@ where\n     Q::Key: DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n-    let query = &Q::VTABLE;\n+    let query = Q::make_vtable(tcx, &key);\n     let dep_node = if let QueryMode::Ensure = mode {\n-        let (must_run, dep_node) = ensure_must_run(tcx, &key, query);\n+        let (must_run, dep_node) = ensure_must_run(tcx, &key, &query);\n         if !must_run {\n             return None;\n         }\n@@ -694,7 +691,6 @@ where\n     };\n \n     debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n-    let compute = Q::compute_fn(tcx, &key);\n     let (result, dep_node_index) = try_execute_query(\n         tcx,\n         Q::query_state(tcx),\n@@ -703,8 +699,7 @@ where\n         key,\n         lookup,\n         dep_node,\n-        query,\n-        compute,\n+        &query,\n     );\n     if let Some(dep_node_index) = dep_node_index {\n         tcx.dep_context().dep_graph().read_index(dep_node_index)\n@@ -718,7 +713,6 @@ where\n     Q::Key: DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n-    let query = &Q::VTABLE;\n     debug_assert!(!Q::ANON);\n \n     // We may be concurrently trying both execute and force a query.\n@@ -735,7 +729,7 @@ where\n         Err(lookup) => lookup,\n     };\n \n-    let compute = Q::compute_fn(tcx, &key);\n+    let query = Q::make_vtable(tcx, &key);\n     let state = Q::query_state(tcx);\n-    try_execute_query(tcx, state, cache, DUMMY_SP, key, lookup, Some(dep_node), query, compute);\n+    try_execute_query(tcx, state, cache, DUMMY_SP, key, lookup, Some(dep_node), &query);\n }"}]}