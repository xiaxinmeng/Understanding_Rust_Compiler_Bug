{"sha": "3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZGMzZmExZWMwOTFkNGJlYzAwNmUwMjAxZDI5Y2U1NGRjYmY0MzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-15T10:52:49Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-07-28T13:46:27Z"}, "message": "change how we report `err_out_of_scope` borrowck errors\n\nAlso, remove the explicit code detecting borrows over a yield.  It\nturns out not to be necessary -- any such borrow winds up with a\nlifetime that is part of the generator type, and therefore which will\noutlive the generator expression itself, which yields an\n`err_out_of_scope`. So instead we intercept those errors and display\nthem in a nicer way.", "tree": {"sha": "cf460785b62304b47839e132e5614caf3e2bac03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf460785b62304b47839e132e5614caf3e2bac03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "html_url": "https://github.com/rust-lang/rust/commit/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "188cdf499f5fd6fdce0382367944e0f2a56026f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/188cdf499f5fd6fdce0382367944e0f2a56026f8", "html_url": "https://github.com/rust-lang/rust/commit/188cdf499f5fd6fdce0382367944e0f2a56026f8"}], "stats": {"total": 582, "additions": 450, "deletions": 132}, "files": [{"sha": "ce9f9f1444f2403633558bf5a8cc9f2eec057e4e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -1143,7 +1143,7 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     Rc::new(maps)\n }\n \n-struct YieldFinder(bool);\n+struct YieldFinder(Option<Span>);\n \n impl<'tcx> Visitor<'tcx> for YieldFinder {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n@@ -1156,52 +1156,57 @@ impl<'tcx> Visitor<'tcx> for YieldFinder {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if let hir::ExprYield(..) = expr.node {\n-            self.0 = true;\n+            if self.0.is_none() {\n+                self.0 = Some(expr.span);\n+            }\n         }\n \n         intravisit::walk_expr(self, expr);\n     }\n }\n \n-pub fn extent_has_yield<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                     extent: CodeExtent) -> bool {\n-    let mut finder = YieldFinder(false);\n-\n-    match extent {\n-        CodeExtent::DestructionScope(node_id) |\n-        CodeExtent::Misc(node_id) => {\n-            match tcx.hir.get(node_id) {\n-                Node::NodeItem(_) |\n-                Node::NodeTraitItem(_) |\n-                Node::NodeImplItem(_) => {\n-                    let body = tcx.hir.body(tcx.hir.body_owned_by(node_id));\n-                    intravisit::walk_body(&mut finder, body);\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    /// Checks whether the given code extent contains a `yield`. If so,\n+    /// returns `Some(span)` with the span of the \"first\" yield we find.\n+    pub fn yield_in_extent(self, extent: CodeExtent) -> Option<Span> {\n+        let mut finder = YieldFinder(None);\n+\n+        match extent {\n+            CodeExtent::DestructionScope(node_id) |\n+            CodeExtent::Misc(node_id) => {\n+                match self.hir.get(node_id) {\n+                    Node::NodeItem(_) |\n+                    Node::NodeTraitItem(_) |\n+                    Node::NodeImplItem(_) => {\n+                        let body = self.hir.body(self.hir.body_owned_by(node_id));\n+                        intravisit::walk_body(&mut finder, body);\n+                    }\n+                    Node::NodeExpr(expr) => intravisit::walk_expr(&mut finder, expr),\n+                    Node::NodeStmt(stmt) => intravisit::walk_stmt(&mut finder, stmt),\n+                    Node::NodeBlock(block) => intravisit::walk_block(&mut finder, block),\n+                    _ => bug!(),\n                 }\n-                Node::NodeExpr(expr) => intravisit::walk_expr(&mut finder, expr),\n-                Node::NodeStmt(stmt) => intravisit::walk_stmt(&mut finder, stmt),\n-                Node::NodeBlock(block) => intravisit::walk_block(&mut finder, block),\n-                _ => bug!(),\n             }\n-        }\n \n-        CodeExtent::CallSiteScope(body_id) |\n-        CodeExtent::ParameterScope(body_id) => {\n-            intravisit::walk_body(&mut finder, tcx.hir.body(body_id))\n-        }\n+            CodeExtent::CallSiteScope(body_id) |\n+            CodeExtent::ParameterScope(body_id) => {\n+                intravisit::walk_body(&mut finder, self.hir.body(body_id))\n+            }\n \n-        CodeExtent::Remainder(r) => {\n-            if let Node::NodeBlock(block) = tcx.hir.get(r.block) {\n-                for stmt in &block.stmts[(r.first_statement_index as usize + 1)..] {\n-                    intravisit::walk_stmt(&mut finder, stmt);\n+            CodeExtent::Remainder(r) => {\n+                if let Node::NodeBlock(block) = self.hir.get(r.block) {\n+                    for stmt in &block.stmts[(r.first_statement_index as usize + 1)..] {\n+                        intravisit::walk_stmt(&mut finder, stmt);\n+                    }\n+                    block.expr.as_ref().map(|e| intravisit::walk_expr(&mut finder, e));\n+                } else {\n+                    bug!()\n                 }\n-                block.expr.as_ref().map(|e| intravisit::walk_expr(&mut finder, e));\n-            } else {\n-                bug!()\n             }\n         }\n-    }\n \n-    finder.0\n+        finder.0\n+    }\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "212ddb9a15cd4c35fd93d779824110ded56690a2", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -48,9 +48,8 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n-    let body = glcx.bccx.tcx.hir.body(body);\n     euv::ExprUseVisitor::new(&mut glcx, bccx.tcx, param_env, &bccx.region_maps, bccx.tables)\n-        .consume_body(body);\n+        .consume_body(bccx.body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;"}, {"sha": "79dff50022802b3a28a7c9789e6d7672ff6c082d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 88, "deletions": 11, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -98,9 +98,8 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     let body_id = tcx.hir.body_owned_by(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_maps = tcx.region_maps(owner_def_id);\n-    let mut bccx = &mut BorrowckCtxt { tcx, tables, region_maps, owner_def_id };\n-\n-    let body = bccx.tcx.hir.body(body_id);\n+    let body = tcx.hir.body(body_id);\n+    let mut bccx = &mut BorrowckCtxt { tcx, tables, region_maps, owner_def_id, body };\n \n     // Eventually, borrowck will always read the MIR, but at the\n     // moment we do not. So, for now, we always force MIR to be\n@@ -128,10 +127,9 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n-    let body = tcx.hir.body(body_id);\n     let id_range = {\n         let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.hir);\n-        visitor.visit_body(body);\n+        visitor.visit_body(this.body);\n         visitor.result()\n     };\n     let (all_loans, move_data) =\n@@ -140,7 +138,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n                              \"borrowck\",\n-                             Some(body),\n+                             Some(this.body),\n                              cfg,\n                              LoanDataFlowOperator,\n                              id_range,\n@@ -151,13 +149,13 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                            loan.kill_scope.node_id(), loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n-    loan_dfcx.propagate(cfg, body);\n+    loan_dfcx.propagate(cfg, this.body);\n \n     let flowed_moves = move_data::FlowedMoveData::new(move_data,\n                                                       this,\n                                                       cfg,\n                                                       id_range,\n-                                                      body);\n+                                                      this.body);\n \n     AnalysisData { all_loans: all_loans,\n                    loans: loan_dfcx,\n@@ -176,7 +174,8 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     let owner_def_id = tcx.hir.local_def_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_maps = tcx.region_maps(owner_def_id);\n-    let mut bccx = BorrowckCtxt { tcx, tables, region_maps, owner_def_id };\n+    let body = tcx.hir.body(body_id);\n+    let mut bccx = BorrowckCtxt { tcx, tables, region_maps, owner_def_id, body };\n \n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx, cfg, body_id);\n     (bccx, dataflow_data)\n@@ -195,6 +194,8 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     region_maps: Rc<RegionMaps>,\n \n     owner_def_id: DefId,\n+\n+    body: &'tcx hir::Body,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -751,9 +752,85 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         format!(\"`{}`\", self.loan_path_to_string(&lp))\n                     }\n                 };\n-                let mut db = struct_span_err!(self.tcx.sess, error_span, E0597, \"{} does not live long enough\", msg);\n \n-                                let (value_kind, value_msg) = match err.cmt.cat {\n+                // When you have a borrow that lives across a yield,\n+                // that reference winds up captured in the generator\n+                // type. Regionck then constraints it to live as long\n+                // as the generator itself. If that borrow is borrowing\n+                // data owned by the generator, this winds up resulting in\n+                // an `err_out_of_scope` error:\n+                //\n+                // ```\n+                // {\n+                //     let g = || {\n+                //         let a = &3; // this borrow is forced to ... -+\n+                //         yield ();          //                        |\n+                //         println!(\"{}\", a); //                        |\n+                //     };                     //                        |\n+                // } <----------------------... live until here --------+\n+                // ```\n+                //\n+                // To detect this case, we look for cases where the\n+                // `super_scope` (lifetime of the value) is within the\n+                // body, but the `sub_scope` is not.\n+                debug!(\"err_out_of_scope: self.body.is_generator = {:?}\",\n+                       self.body.is_generator);\n+                let maybe_borrow_across_yield = if self.body.is_generator {\n+                    let body_extent = region::CodeExtent::Misc(self.body.id().node_id);\n+                    debug!(\"err_out_of_scope: body_extent = {:?}\", body_extent);\n+                    debug!(\"err_out_of_scope: super_scope = {:?}\", super_scope);\n+                    debug!(\"err_out_of_scope: sub_scope = {:?}\", sub_scope);\n+                    match (super_scope, sub_scope) {\n+                        (&ty::RegionKind::ReScope(value_extent),\n+                         &ty::RegionKind::ReScope(loan_extent)) => {\n+                            if {\n+                                // value_extent <= body_extent &&\n+                                self.region_maps.is_subscope_of(value_extent, body_extent) &&\n+                                    // body_extent <= loan_extent\n+                                    self.region_maps.is_subscope_of(body_extent, loan_extent)\n+                            } {\n+                                // We now know that this is a case\n+                                // that fits the bill described above:\n+                                // a borrow of something whose scope\n+                                // is within the generator, but the\n+                                // borrow is for a scope outside the\n+                                // generator.\n+                                //\n+                                // Now look within the scope of the of\n+                                // the value being borrowed (in the\n+                                // example above, that would be the\n+                                // block remainder that starts with\n+                                // `let a`) for a yield. We can cite\n+                                // that for the user.\n+                                self.tcx.yield_in_extent(value_extent)\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                        _ => None,\n+                    }\n+                } else {\n+                    None\n+                };\n+\n+                if let Some(yield_span) = maybe_borrow_across_yield {\n+                    debug!(\"err_out_of_scope: opt_yield_span = {:?}\", yield_span);\n+                    struct_span_err!(self.tcx.sess,\n+                                     error_span,\n+                                     E0624,\n+                                     \"borrow may still be in use when generator yields\")\n+                        .span_label(yield_span, \"possible yield occurs here\")\n+                        .emit();\n+                    return;\n+                }\n+\n+                let mut db = struct_span_err!(self.tcx.sess,\n+                                              error_span,\n+                                              E0597,\n+                                              \"{} does not live long enough\",\n+                                              msg);\n+\n+                let (value_kind, value_msg) = match err.cmt.cat {\n                     mc::Categorization::Rvalue(..) =>\n                         (\"temporary value\", \"temporary value created here\"),\n                     _ =>"}, {"sha": "14454267c99cc60f9a0c5440ccac1fb2912e34b6", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -1183,6 +1183,82 @@ x.x = Some(&y);\n ```\n \"##,\n \n+E0624: r##\"\n+This error occurs because a borrow in a generator persists across a\n+yield point.\n+\n+```compile_fail,E0624\n+let mut b = || {\n+    let a = &3; // <-- This borrow...\n+    yield (); // ...is still in scope here, when the yield occurs.\n+    println!(\"{}\", a);\n+};\n+b.resume();\n+```\n+\n+At present, it is not permitted to have a yield that occurs while a\n+borrow is still in scope. To resolve this error, the borrow must\n+either be \"contained\" to a smaller scope that does not overlap the\n+yield or else eliminated in another way. So, for example, we might\n+resolve the previous example by removing the borrow and just storing\n+the integer by value:\n+\n+```\n+let mut b = || {\n+    let a = 3;\n+    yield ();\n+    println!(\"{}\", a);\n+};\n+b.resume();\n+```\n+\n+This is a very simple case, of course. In more complex cases, we may\n+wish to have more than one reference to the value that was borrowed --\n+in those cases, something like the `Rc` or `Arc` types may be useful.\n+\n+This error also frequently arises with iteration:\n+\n+```compile_fail,E0624\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  for &x in &v { // <-- borrow of `v` is still in scope...\n+    yield x; // ...when this yield occurs.\n+  }\n+};\n+b.resume();\n+```\n+\n+Such cases can sometimes be resolved by iterating \"by value\" (or using\n+`into_iter()`) to avoid borrowing:\n+\n+```\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  for x in v { // <-- Take ownership of the values instead!\n+    yield x; // <-- Now yield is OK.\n+  }\n+};\n+b.resume();\n+```\n+\n+If taking ownership is not an option, using indices can work too:\n+\n+```\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  let len = v.len(); // (*)\n+  for i in 0..len {\n+    let x = v[i]; // (*)\n+    yield x; // <-- Now yield is OK.\n+  }\n+};\n+b.resume();\n+\n+// (*) -- Unfortunately, these temporaries are currently required.\n+// See <https://github.com/rust-lang/rust/issues/43122>.\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "148cf0ddbffcd607990461485a97921d6efa6c7f", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Body, Pat, PatKind, Expr};\n use rustc::hir::def_id::DefId;\n use rustc::ty::Ty;\n-use rustc::middle::region::{RegionMaps, CodeExtent, extent_has_yield};\n+use rustc::middle::region::{RegionMaps, CodeExtent};\n use util::nodemap::FxHashSet;\n use std::rc::Rc;\n use super::FnCtxt;\n@@ -27,7 +27,7 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n     fn record(&mut self, ty: Ty<'tcx>, scope: Option<CodeExtent>, expr: Option<&'tcx Expr>) {\n         use syntax_pos::DUMMY_SP;\n \n-        if scope.map(|s| extent_has_yield(self.fcx.tcx, s)).unwrap_or(true) {\n+        if scope.map(|s| self.fcx.tcx.yield_in_extent(s).is_some()).unwrap_or(true) {\n             if self.fcx.tcx.sess.verbose() {\n                 if let Some(s) = scope {\n                     self.fcx.tcx.sess.span_warn(s.span(&self.fcx.tcx.hir).unwrap_or(DUMMY_SP),"}, {"sha": "8d77eb92a63f19169953d1117143e3108a82fb12", "filename": "src/test/ui/generator/ref-escapes-but-not-over-yield.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.rs?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{State, Generator};\n+use std::cell::Cell;\n+\n+fn foo(x: &i32) {\n+    // In this case, a reference to `b` escapes the generator, but not\n+    // because of a yield. We see that there is no yield in the scope of\n+    // `b` and give the more generic error message.\n+    let mut a = &3;\n+    let mut b = move || {\n+        yield();\n+        let b = 5;\n+        a = &b; //~ ERROR\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "e30d28c2db83bcc7d40b346edb73084fb952a663", "filename": "src/test/ui/generator/ref-escapes-but-not-over-yield.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.stderr?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -0,0 +1,12 @@\n+error[E0597]: `b` does not live long enough\n+  --> $DIR/ref-escapes-but-not-over-yield.rs:25:5\n+   |\n+24 |         a = &b; //~ ERROR\n+   |              - borrow occurs here\n+25 |     };\n+   |     ^ `b` dropped here while still borrowed\n+26 | }\n+   | - borrowed value needs to live until here\n+\n+error: aborting due to previous error\n+"}, {"sha": "0d2e9a85de1e672c2b4d214742170c2cedb9c043", "filename": "src/test/ui/generator/yield-in-args-rev.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.rs?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -15,10 +15,10 @@ fn foo(_a: (), _b: &bool) {}\n // Some examples that probably *could* be accepted, but which we reject for now.\n \n fn bar() {\n-    || {\n-        let b = true;\n-        foo(yield, &b);\n-    }; //~ ERROR `b` does not live long enough\n+\t|| {\n+\t\tlet b = true;\n+\t\tfoo(yield, &b); //~ ERROR\n+\t};\n }\n \n fn main() { }", "previous_filename": "src/test/compile-fail/generator/yield-in-args-rev.rs"}, {"sha": "8f30089fc71bf11087e1f52a0583cc185dfea70b", "filename": "src/test/ui/generator/yield-in-args-rev.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -0,0 +1,10 @@\n+error[E0624]: borrow may still be in use when generator yields\n+  --> $DIR/yield-in-args-rev.rs:20:15\n+   |\n+20 | \\t\\tfoo(yield, &b); //~ ERROR\n+   | \\t\\t    -----   ^\n+   | \\t\\t    |\n+   | \\t\\t    possible yield occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "c2fcfa5cdc20762350a8459c5e9bcf2a7c3b2585", "filename": "src/test/ui/generator/yield-in-args.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.rs?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -13,8 +13,8 @@\n fn foo(_b: &bool, _a: ()) {}\n \n fn main() {\n-    || {\n-        let b = true;\n-        foo(&b, yield);\n-    }; //~ ERROR `b` does not live long enough\n+\t|| {\n+\t\tlet b = true;\n+\t\tfoo(&b, yield); //~ ERROR\n+\t};\n }", "previous_filename": "src/test/compile-fail/generator/yield-in-args.rs"}, {"sha": "e4c31ef36c969ff16117f0ce833c91650a4e5fbd", "filename": "src/test/ui/generator/yield-in-args.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args.stderr?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -0,0 +1,8 @@\n+error[E0624]: borrow may still be in use when generator yields\n+  --> $DIR/yield-in-args.rs:18:8\n+   |\n+18 | \\t\\tfoo(&b, yield); //~ ERROR\n+   | \\t\\t     ^  ----- possible yield occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "fd260339efb1b5db8bc6412ffa74c776009e01e2", "filename": "src/test/ui/generator/yield-while-iterating.rs", "status": "renamed", "additions": 16, "deletions": 76, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -13,89 +13,16 @@\n use std::ops::{State, Generator};\n use std::cell::Cell;\n \n-fn borrow_local_inline() {\n-    // Not OK to yield with a borrow of a temporary.\n-    //\n-    // (This error occurs because the region shows up in the type of\n-    // `b` and gets extended by region inference.)\n-    let mut b = move || {\n-        let a = &3;\n-        yield();\n-        println!(\"{}\", a);\n-    }; //~ ERROR E0597\n-    b.resume();\n-}\n-\n-fn borrow_local_inline_done() {\n-    // No error here -- `a` is not in scope at the point of `yield`.\n-    let mut b = move || {\n-        {\n-            let a = &3;\n-        }\n-        yield();\n-    };\n-    b.resume();\n-}\n-\n-fn borrow_local() {\n-    // Not OK to yield with a borrow of a temporary.\n-    //\n-    // (This error occurs because the region shows up in the type of\n-    // `b` and gets extended by region inference.)\n-    let mut b = move || {\n-        let a = 3;\n-        {\n-            let b = &a;\n-            yield();\n-            println!(\"{}\", b);\n-        }\n-    }; //~ ERROR E0597\n-    b.resume();\n-}\n-\n-fn reborrow_shared_ref(x: &i32) {\n-    // This is OK -- we have a borrow live over the yield, but it's of\n-    // data that outlives the generator.\n-    let mut b = move || {\n-        let a = &*x;\n-        yield();\n-        println!(\"{}\", a);\n-    };\n-    b.resume();\n-}\n-\n-fn reborrow_mutable_ref(x: &mut i32) {\n-    // This is OK -- we have a borrow live over the yield, but it's of\n-    // data that outlives the generator.\n-    let mut b = move || {\n-        let a = &mut *x;\n-        yield();\n-        println!(\"{}\", a);\n-    };\n-    b.resume();\n-}\n-\n-fn reborrow_mutable_ref_2(x: &mut i32) {\n-    // ...but not OK to go on using `x`.\n-    let mut b = || {\n-        let a = &mut *x;\n-        yield();\n-        println!(\"{}\", a);\n-    };\n-    println!(\"{}\", x); //~ ERROR E0501\n-    b.resume();\n-}\n-\n fn yield_during_iter_owned_data(x: Vec<i32>) {\n     // The generator owns `x`, so we error out when yielding with a\n     // reference to it.  This winds up becoming a rather confusing\n     // regionck error -- in particular, we would freeze with the\n     // reference in scope, and it doesn't live long enough.\n     let _b = move || {\n-        for p in &x {\n+        for p in &x { //~ ERROR\n             yield();\n         }\n-    }; //~ ERROR E0597\n+    };\n }\n \n fn yield_during_iter_borrowed_slice(x: &[i32]) {\n@@ -137,7 +64,20 @@ fn yield_during_iter_borrowed_slice_4() {\n             yield p;\n         }\n     };\n-    println!(\"{}\", x[0]); //~ ERROR cannot borrow `x` as immutable\n+    println!(\"{}\", x[0]); //~ ERROR\n+    b.resume();\n+}\n+\n+fn yield_during_range_iter() {\n+    // Should be OK.\n+    let mut b = || {\n+        let v = vec![1,2,3];\n+        let len = v.len();\n+        for i in 0..len {\n+            let x = v[i];\n+            yield x;\n+        }\n+    };\n     b.resume();\n }\n ", "previous_filename": "src/test/compile-fail/generator/yield-during-borrow.rs"}, {"sha": "775c36a3df4067d9f6ac42af69219742719dec2d", "filename": "src/test/ui/generator/yield-while-iterating.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.stderr?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -0,0 +1,24 @@\n+error[E0624]: borrow may still be in use when generator yields\n+  --> $DIR/yield-while-iterating.rs:22:19\n+   |\n+22 |         for p in &x { //~ ERROR\n+   |                   ^\n+23 |             yield();\n+   |             ------- possible yield occurs here\n+\n+error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n+  --> $DIR/yield-while-iterating.rs:67:20\n+   |\n+62 |     let mut b = || {\n+   |                 -- mutable borrow occurs here\n+63 |         for p in &mut x {\n+   |                       - previous borrow occurs due to use of `x` in closure\n+...\n+67 |     println!(\"{}\", x[0]); //~ ERROR\n+   |                    ^ immutable borrow occurs here\n+68 |     b.resume();\n+69 | }\n+   | - mutable borrow ends here\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "b3e6dedf29199f2a5ccada56a111c230bcc75f42", "filename": "src/test/ui/generator/yield-while-local-borrowed.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{State, Generator};\n+use std::cell::Cell;\n+\n+fn borrow_local_inline() {\n+    // Not OK to yield with a borrow of a temporary.\n+    //\n+    // (This error occurs because the region shows up in the type of\n+    // `b` and gets extended by region inference.)\n+    let mut b = move || {\n+        let a = &3; //~ ERROR\n+        yield();\n+        println!(\"{}\", a);\n+    };\n+    b.resume();\n+}\n+\n+fn borrow_local_inline_done() {\n+    // No error here -- `a` is not in scope at the point of `yield`.\n+    let mut b = move || {\n+        {\n+            let a = &3;\n+        }\n+        yield();\n+    };\n+    b.resume();\n+}\n+\n+fn borrow_local() {\n+    // Not OK to yield with a borrow of a temporary.\n+    //\n+    // (This error occurs because the region shows up in the type of\n+    // `b` and gets extended by region inference.)\n+    let mut b = move || {\n+        let a = 3;\n+        {\n+            let b = &a; //~ ERROR\n+            yield();\n+            println!(\"{}\", b);\n+        }\n+    };\n+    b.resume();\n+}\n+\n+fn main() { }"}, {"sha": "1e333a33db62aef7f9a07c966e1afd036c600711", "filename": "src/test/ui/generator/yield-while-local-borrowed.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.stderr?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -0,0 +1,18 @@\n+error[E0624]: borrow may still be in use when generator yields\n+  --> $DIR/yield-while-local-borrowed.rs:22:18\n+   |\n+22 |         let a = &3; //~ ERROR\n+   |                  ^\n+23 |         yield();\n+   |         ------- possible yield occurs here\n+\n+error[E0624]: borrow may still be in use when generator yields\n+  --> $DIR/yield-while-local-borrowed.rs:48:22\n+   |\n+48 |             let b = &a; //~ ERROR\n+   |                      ^\n+49 |             yield();\n+   |             ------- possible yield occurs here\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7b6246b1578ed142a4f6760dff4c6e2509ebd50c", "filename": "src/test/ui/generator/yield-while-ref-reborrowed.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{State, Generator};\n+use std::cell::Cell;\n+\n+fn reborrow_shared_ref(x: &i32) {\n+    // This is OK -- we have a borrow live over the yield, but it's of\n+    // data that outlives the generator.\n+    let mut b = move || {\n+        let a = &*x;\n+        yield();\n+        println!(\"{}\", a);\n+    };\n+    b.resume();\n+}\n+\n+fn reborrow_mutable_ref(x: &mut i32) {\n+    // This is OK -- we have a borrow live over the yield, but it's of\n+    // data that outlives the generator.\n+    let mut b = move || {\n+        let a = &mut *x;\n+        yield();\n+        println!(\"{}\", a);\n+    };\n+    b.resume();\n+}\n+\n+fn reborrow_mutable_ref_2(x: &mut i32) {\n+    // ...but not OK to go on using `x`.\n+    let mut b = || {\n+        let a = &mut *x;\n+        yield();\n+        println!(\"{}\", a);\n+    };\n+    println!(\"{}\", x); //~ ERROR\n+    b.resume();\n+}\n+\n+fn main() { }"}, {"sha": "7269f72973701004734c26b94408d435db728dd1", "filename": "src/test/ui/generator/yield-while-ref-reborrowed.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdc3fa1ec091d4bec006e0201d29ce54dcbf430/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.stderr?ref=3fdc3fa1ec091d4bec006e0201d29ce54dcbf430", "patch": "@@ -0,0 +1,16 @@\n+error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n+  --> $DIR/yield-while-ref-reborrowed.rs:45:20\n+   |\n+40 |     let mut b = || {\n+   |                 -- closure construction occurs here\n+41 |         let a = &mut *x;\n+   |                       - previous borrow occurs due to use of `x` in closure\n+...\n+45 |     println!(\"{}\", x); //~ ERROR\n+   |                    ^ borrow occurs here\n+46 |     b.resume();\n+47 | }\n+   | - borrow from closure ends here\n+\n+error: aborting due to previous error\n+"}]}