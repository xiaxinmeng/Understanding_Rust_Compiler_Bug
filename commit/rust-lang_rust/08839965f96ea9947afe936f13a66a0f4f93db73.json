{"sha": "08839965f96ea9947afe936f13a66a0f4f93db73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ODM5OTY1Zjk2ZWE5OTQ3YWZlOTM2ZjEzYTY2YTBmNGY5M2RiNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-05T08:10:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-05T08:10:57Z"}, "message": "Auto merge of #37427 - nnethercote:opt-IchHasher, r=michaelwoerister\n\nReduce the number of bytes hashed by IchHasher.\n\nIchHasher uses blake2b hashing, which is expensive, so the fewer bytes hashed\nthe better. There are two big ways to reduce the number of bytes hashed.\n- Filenames in spans account for ~66% of all bytes (for builds with debuginfo).\n  The vast majority of spans have the same filename for the start of the span\n  and the end of the span, so hashing the filename just once in those cases is\n  a big win.\n- u32 and u64 and usize values account for ~25%--33% of all bytes (for builds\n  with debuginfo). The vast majority of these are small, i.e. fit in a u8, so\n  shrinking them down before hashing is also a big win.\n\nThis PR implements these two optimizations. I'm certain the first one is safe.\nI'm about 90% sure that the second one is safe.\n\nHere are measurements of the number of bytes hashed when doing\ndebuginfo-enabled builds of stdlib and\nrustc-benchmarks/syntex-0.42.2-incr-clean.\n\n```\n                    stdlib   syntex-incr\n                    ------   -----------\noriginal       156,781,386   255,095,596\nhalf-SawSpan   106,744,403   176,345,419\nshort-ints      45,890,534   118,014,227\nno-SawSpan[*]    6,831,874    45,875,714\n\n[*] don't hash the SawSpan at all. Not part of this PR, just implemented for\n    comparison's sake.\n```\n\nFor debug builds of syntex-0.42.2-incr-clean, the two changes give a 1--2%\nspeed-up.", "tree": {"sha": "06e3ec079876527a8c6ddfff5f44482cc2022000", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06e3ec079876527a8c6ddfff5f44482cc2022000"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08839965f96ea9947afe936f13a66a0f4f93db73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08839965f96ea9947afe936f13a66a0f4f93db73", "html_url": "https://github.com/rust-lang/rust/commit/08839965f96ea9947afe936f13a66a0f4f93db73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08839965f96ea9947afe936f13a66a0f4f93db73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e96b9d2bb48b7a886a4d2b9df716265af5d15646", "url": "https://api.github.com/repos/rust-lang/rust/commits/e96b9d2bb48b7a886a4d2b9df716265af5d15646", "html_url": "https://github.com/rust-lang/rust/commit/e96b9d2bb48b7a886a4d2b9df716265af5d15646"}, {"sha": "d73c68ceef6984b8e762a173b96279c42d1fe851", "url": "https://api.github.com/repos/rust-lang/rust/commits/d73c68ceef6984b8e762a173b96279c42d1fe851", "html_url": "https://github.com/rust-lang/rust/commit/d73c68ceef6984b8e762a173b96279c42d1fe851"}], "stats": {"total": 80, "additions": 68, "deletions": 12}, "files": [{"sha": "d7d9c231a91f48ea772b72585da7cd23dcfd316b", "filename": "src/librustc_incremental/calculate_svh/hasher.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/08839965f96ea9947afe936f13a66a0f4f93db73/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08839965f96ea9947afe936f13a66a0f4f93db73/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs?ref=08839965f96ea9947afe936f13a66a0f4f93db73", "patch": "@@ -9,13 +9,16 @@\n // except according to those terms.\n \n use std::mem;\n+use std::hash::Hasher;\n use rustc_data_structures::blake2b::Blake2bHasher;\n use rustc::ty::util::ArchIndependentHasher;\n use ich::Fingerprint;\n+use rustc_serialize::leb128::write_unsigned_leb128;\n \n #[derive(Debug)]\n pub struct IchHasher {\n     state: ArchIndependentHasher<Blake2bHasher>,\n+    leb128_helper: Vec<u8>,\n     bytes_hashed: u64,\n }\n \n@@ -24,6 +27,7 @@ impl IchHasher {\n         let hash_size = mem::size_of::<Fingerprint>();\n         IchHasher {\n             state: ArchIndependentHasher::new(Blake2bHasher::new(hash_size, &[])),\n+            leb128_helper: vec![],\n             bytes_hashed: 0\n         }\n     }\n@@ -37,9 +41,19 @@ impl IchHasher {\n         fingerprint.0.copy_from_slice(self.state.into_inner().finalize());\n         fingerprint\n     }\n+\n+    #[inline]\n+    fn write_uleb128(&mut self, value: u64) {\n+        let len = write_unsigned_leb128(&mut self.leb128_helper, 0, value);\n+        self.state.write(&self.leb128_helper[0..len]);\n+        self.bytes_hashed += len as u64;\n+    }\n }\n \n-impl ::std::hash::Hasher for IchHasher {\n+// For the non-u8 integer cases we leb128 encode them first. Because small\n+// integers dominate, this significantly and cheaply reduces the number of\n+// bytes hashed, which is good because blake2b is expensive.\n+impl Hasher for IchHasher {\n     fn finish(&self) -> u64 {\n         bug!(\"Use other finish() implementation to get the full 128-bit hash.\");\n     }\n@@ -49,4 +63,26 @@ impl ::std::hash::Hasher for IchHasher {\n         self.state.write(bytes);\n         self.bytes_hashed += bytes.len() as u64;\n     }\n+\n+    // There is no need to leb128-encode u8 values.\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.write_uleb128(i);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.write_uleb128(i as u64);\n+    }\n }"}, {"sha": "2358d60d0de215fd20a17581e15e2bac11d42367", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/08839965f96ea9947afe936f13a66a0f4f93db73/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08839965f96ea9947afe936f13a66a0f4f93db73/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=08839965f96ea9947afe936f13a66a0f4f93db73", "patch": "@@ -88,6 +88,8 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     // within the CodeMap.\n     // Also note that we are hashing byte offsets for the column, not unicode\n     // codepoint offsets. For the purpose of the hash that's sufficient.\n+    // Also, hashing filenames is expensive so we avoid doing it twice when the\n+    // span starts and ends in the same file, which is almost always the case.\n     fn hash_span(&mut self, span: Span) {\n         debug!(\"hash_span: st={:?}\", self.st);\n \n@@ -103,21 +105,35 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             span.hi\n         };\n \n-        let loc1 = self.codemap.byte_pos_to_line_and_col(span.lo);\n-        let loc2 = self.codemap.byte_pos_to_line_and_col(span_hi);\n-\n-        let expansion_kind = match span.expn_id {\n+        let expn_kind = match span.expn_id {\n             NO_EXPANSION => SawSpanExpnKind::NoExpansion,\n             COMMAND_LINE_EXPN => SawSpanExpnKind::CommandLine,\n             _ => SawSpanExpnKind::SomeExpansion,\n         };\n \n-        SawSpan(loc1.as_ref().map(|&(ref fm, line, col)| (&fm.name[..], line, col)),\n-                loc2.as_ref().map(|&(ref fm, line, col)| (&fm.name[..], line, col)),\n-                expansion_kind)\n-            .hash(self.st);\n+        let loc1 = self.codemap.byte_pos_to_line_and_col(span.lo);\n+        let loc1 = loc1.as_ref()\n+                       .map(|&(ref fm, line, col)| (&fm.name[..], line, col))\n+                       .unwrap_or((\"???\", 0, BytePos(0)));\n+\n+        let loc2 = self.codemap.byte_pos_to_line_and_col(span_hi);\n+        let loc2 = loc2.as_ref()\n+                       .map(|&(ref fm, line, col)| (&fm.name[..], line, col))\n+                       .unwrap_or((\"???\", 0, BytePos(0)));\n+\n+        let saw = if loc1.0 == loc2.0 {\n+            SawSpan(loc1.0,\n+                    loc1.1, loc1.2,\n+                    loc2.1, loc2.2,\n+                    expn_kind)\n+        } else {\n+            SawSpanTwoFiles(loc1.0, loc1.1, loc1.2,\n+                            loc2.0, loc2.1, loc2.2,\n+                            expn_kind)\n+        };\n+        saw.hash(self.st);\n \n-        if expansion_kind == SawSpanExpnKind::SomeExpansion {\n+        if expn_kind == SawSpanExpnKind::SomeExpansion {\n             let call_site = self.codemap.codemap().source_callsite(span);\n             self.hash_span(call_site);\n         }\n@@ -189,9 +205,13 @@ enum SawAbiComponent<'a> {\n     SawAssocTypeBinding,\n     SawAttribute(ast::AttrStyle),\n     SawMacroDef,\n-    SawSpan(Option<(&'a str, usize, BytePos)>,\n-            Option<(&'a str, usize, BytePos)>,\n+    SawSpan(&'a str,\n+            usize, BytePos,\n+            usize, BytePos,\n             SawSpanExpnKind),\n+    SawSpanTwoFiles(&'a str, usize, BytePos,\n+                    &'a str, usize, BytePos,\n+                    SawSpanExpnKind),\n }\n \n /// SawExprComponent carries all of the information that we want"}]}