{"sha": "4faf701d2028dd6031a3c772ae4b3e844d51c3c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmYWY3MDFkMjAyOGRkNjAzMWEzYzc3MmFlNGIzZTg0NGQ1MWMzYzM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-27T06:35:32Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-27T06:35:32Z"}, "message": "Remove the QueryGetter trait.", "tree": {"sha": "e28e2c32c9f4c1611e7f77fb9beea89151377c4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e28e2c32c9f4c1611e7f77fb9beea89151377c4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4faf701d2028dd6031a3c772ae4b3e844d51c3c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4faf701d2028dd6031a3c772ae4b3e844d51c3c3", "html_url": "https://github.com/rust-lang/rust/commit/4faf701d2028dd6031a3c772ae4b3e844d51c3c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4faf701d2028dd6031a3c772ae4b3e844d51c3c3/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "260cfaba1259e8551aec02ef4b846900517be8e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/260cfaba1259e8551aec02ef4b846900517be8e5", "html_url": "https://github.com/rust-lang/rust/commit/260cfaba1259e8551aec02ef4b846900517be8e5"}], "stats": {"total": 165, "additions": 74, "deletions": 91}, "files": [{"sha": "0fabacb5f69fd5abf6f6ca698933ea842d24360c", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4faf701d2028dd6031a3c772ae4b3e844d51c3c3/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4faf701d2028dd6031a3c772ae4b3e844d51c3c3/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=4faf701d2028dd6031a3c772ae4b3e844d51c3c3", "patch": "@@ -381,7 +381,7 @@ macro_rules! define_queries_inner {\n             $($(#[$attr])*\n             #[inline(always)]\n             pub fn $name(self, key: $K) {\n-                self.tcx.ensure_query::<queries::$name<'_>>(key)\n+                ensure_query::<queries::$name<'_>, _>(self.tcx, key)\n             })*\n         }\n \n@@ -459,7 +459,7 @@ macro_rules! define_queries_inner {\n             $($(#[$attr])*\n             #[inline(always)]\n             pub fn $name(self, key: $K) -> $V {\n-                self.tcx.get_query::<queries::$name<'_>>(self.span, key)\n+                get_query::<queries::$name<'_>, _>(self.tcx, self.span, key)\n             })*\n         }\n "}, {"sha": "26c3bce4a9a02afec3d88a235c3e55991e795593", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4faf701d2028dd6031a3c772ae4b3e844d51c3c3/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4faf701d2028dd6031a3c772ae4b3e844d51c3c3/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=4faf701d2028dd6031a3c772ae4b3e844d51c3c3", "patch": "@@ -489,7 +489,8 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 ::rustc::dep_graph::DepKind::#name => {\n                     if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n                         if let Some(key) = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node) {\n-                            $tcx.force_query::<crate::ty::query::queries::#name<'_>>(\n+                            force_query::<crate::ty::query::queries::#name<'_>, _>(\n+                                $tcx,\n                                 key,\n                                 DUMMY_SP,\n                                 *$dep_node"}, {"sha": "bec45b29d308e10f48f220e1232f3e0b768bdb12", "filename": "src/librustc_query_system/query/plumbing.rs", "status": "modified", "additions": 70, "deletions": 88, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/4faf701d2028dd6031a3c772ae4b3e844d51c3c3/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4faf701d2028dd6031a3c772ae4b3e844d51c3c3/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs?ref=4faf701d2028dd6031a3c772ae4b3e844d51c3c3", "patch": "@@ -606,105 +606,87 @@ where\n     (result, dep_node_index)\n }\n \n-pub trait QueryGetter: QueryContext {\n-    fn get_query<Q: QueryDescription<Self>>(self, span: Span, key: Q::Key) -> Q::Value;\n-\n-    /// Ensure that either this query has all green inputs or been executed.\n-    /// Executing `query::ensure(D)` is considered a read of the dep-node `D`.\n-    ///\n-    /// This function is particularly useful when executing passes for their\n-    /// side-effects -- e.g., in order to report errors for erroneous programs.\n-    ///\n-    /// Note: The optimization is only available during incr. comp.\n-    fn ensure_query<Q: QueryDescription<Self>>(self, key: Q::Key);\n+#[inline(never)]\n+pub fn get_query<Q, CTX>(tcx: CTX, span: Span, key: Q::Key) -> Q::Value\n+where\n+    Q: QueryDescription<CTX>,\n+    CTX: QueryContext,\n+{\n+    debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n \n-    fn force_query<Q: QueryDescription<Self>>(\n-        self,\n-        key: Q::Key,\n-        span: Span,\n-        dep_node: DepNode<Self::DepKind>,\n-    );\n+    try_get_cached(\n+        tcx,\n+        Q::query_state(tcx),\n+        key,\n+        |value, index| {\n+            tcx.dep_graph().read_index(index);\n+            value.clone()\n+        },\n+        |key, lookup| try_execute_query::<Q, _>(tcx, span, key, lookup),\n+    )\n }\n \n-impl<CTX> QueryGetter for CTX\n+/// Ensure that either this query has all green inputs or been executed.\n+/// Executing `query::ensure(D)` is considered a read of the dep-node `D`.\n+///\n+/// This function is particularly useful when executing passes for their\n+/// side-effects -- e.g., in order to report errors for erroneous programs.\n+///\n+/// Note: The optimization is only available during incr. comp.\n+pub fn ensure_query<Q, CTX>(tcx: CTX, key: Q::Key)\n where\n+    Q: QueryDescription<CTX>,\n     CTX: QueryContext,\n {\n-    #[inline(never)]\n-    fn get_query<Q: QueryDescription<Self>>(self, span: Span, key: Q::Key) -> Q::Value {\n-        debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n-\n-        try_get_cached(\n-            self,\n-            Q::query_state(self),\n-            key,\n-            |value, index| {\n-                self.dep_graph().read_index(index);\n-                value.clone()\n-            },\n-            |key, lookup| try_execute_query::<Q, _>(self, span, key, lookup),\n-        )\n+    if Q::EVAL_ALWAYS {\n+        let _ = get_query::<Q, _>(tcx, DUMMY_SP, key);\n+        return;\n     }\n \n-    /// Ensure that either this query has all green inputs or been executed.\n-    /// Executing `query::ensure(D)` is considered a read of the dep-node `D`.\n-    ///\n-    /// This function is particularly useful when executing passes for their\n-    /// side-effects -- e.g., in order to report errors for erroneous programs.\n-    ///\n-    /// Note: The optimization is only available during incr. comp.\n-    fn ensure_query<Q: QueryDescription<Self>>(self, key: Q::Key) {\n-        if Q::EVAL_ALWAYS {\n-            let _ = self.get_query::<Q>(DUMMY_SP, key);\n-            return;\n-        }\n+    // Ensuring an anonymous query makes no sense\n+    assert!(!Q::ANON);\n \n-        // Ensuring an anonymous query makes no sense\n-        assert!(!Q::ANON);\n-\n-        let dep_node = Q::to_dep_node(self, &key);\n+    let dep_node = Q::to_dep_node(tcx, &key);\n \n-        match self.dep_graph().try_mark_green_and_read(self, &dep_node) {\n-            None => {\n-                // A None return from `try_mark_green_and_read` means that this is either\n-                // a new dep node or that the dep node has already been marked red.\n-                // Either way, we can't call `dep_graph.read()` as we don't have the\n-                // DepNodeIndex. We must invoke the query itself. The performance cost\n-                // this introduces should be negligible as we'll immediately hit the\n-                // in-memory cache, or another query down the line will.\n-                let _ = self.get_query::<Q>(DUMMY_SP, key);\n-            }\n-            Some((_, dep_node_index)) => {\n-                self.profiler().query_cache_hit(dep_node_index.into());\n-            }\n+    match tcx.dep_graph().try_mark_green_and_read(tcx, &dep_node) {\n+        None => {\n+            // A None return from `try_mark_green_and_read` means that this is either\n+            // a new dep node or that the dep node has already been marked red.\n+            // Either way, we can't call `dep_graph.read()` as we don't have the\n+            // DepNodeIndex. We must invoke the query itself. The performance cost\n+            // this introduces should be negligible as we'll immediately hit the\n+            // in-memory cache, or another query down the line will.\n+            let _ = get_query::<Q, _>(tcx, DUMMY_SP, key);\n+        }\n+        Some((_, dep_node_index)) => {\n+            tcx.profiler().query_cache_hit(dep_node_index.into());\n         }\n     }\n+}\n \n-    fn force_query<Q: QueryDescription<Self>>(\n-        self,\n-        key: Q::Key,\n-        span: Span,\n-        dep_node: DepNode<Self::DepKind>,\n-    ) {\n-        // We may be concurrently trying both execute and force a query.\n-        // Ensure that only one of them runs the query.\n-\n-        try_get_cached(\n-            self,\n-            Q::query_state(self),\n-            key,\n-            |_, _| {\n-                // Cache hit, do nothing\n-            },\n-            |key, lookup| {\n-                let job = match JobOwner::try_start::<Q>(self, span, &key, lookup) {\n-                    TryGetJob::NotYetStarted(job) => job,\n-                    TryGetJob::Cycle(_) => return,\n-                    #[cfg(parallel_compiler)]\n-                    TryGetJob::JobCompleted(_) => return,\n-                };\n-                force_query_with_job::<Q, _>(self, key, job, dep_node);\n-            },\n-        );\n-    }\n+pub fn force_query<Q, CTX>(tcx: CTX, key: Q::Key, span: Span, dep_node: DepNode<CTX::DepKind>)\n+where\n+    Q: QueryDescription<CTX>,\n+    CTX: QueryContext,\n+{\n+    // We may be concurrently trying both execute and force a query.\n+    // Ensure that only one of them runs the query.\n+\n+    try_get_cached(\n+        tcx,\n+        Q::query_state(tcx),\n+        key,\n+        |_, _| {\n+            // Cache hit, do nothing\n+        },\n+        |key, lookup| {\n+            let job = match JobOwner::try_start::<Q>(tcx, span, &key, lookup) {\n+                TryGetJob::NotYetStarted(job) => job,\n+                TryGetJob::Cycle(_) => return,\n+                #[cfg(parallel_compiler)]\n+                TryGetJob::JobCompleted(_) => return,\n+            };\n+            force_query_with_job::<Q, _>(tcx, key, job, dep_node);\n+        },\n+    );\n }"}]}