{"sha": "020655b90da83b0a037a9d3c987be17f04eedbc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMDY1NWI5MGRhODNiMGEwMzdhOWQzYzk4N2JlMTdmMDRlZWRiYzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-11-21T20:33:36Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-08-20T21:27:50Z"}, "message": "move the `sub-unify` check and extend the documentation a bit\n\nI didn't like the sub-unify code executing when a predicate was\nENQUEUED, that felt fragile. I would have preferred to move the\nsub-unify code so that it only occurred during generalization, but\nthat impacted diagnostics, so having it also occur when we process\nsubtype predicates felt pretty reasonable. (I guess we only need one\nor the other, but I kind of prefer both, since the generalizer\nultimately feels like the *right* place to guarantee the properties we\nwant.)", "tree": {"sha": "d95687930d34ac721c648b647c257b046ab8f9b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d95687930d34ac721c648b647c257b046ab8f9b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/020655b90da83b0a037a9d3c987be17f04eedbc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/020655b90da83b0a037a9d3c987be17f04eedbc4", "html_url": "https://github.com/rust-lang/rust/commit/020655b90da83b0a037a9d3c987be17f04eedbc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/020655b90da83b0a037a9d3c987be17f04eedbc4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "947c0de028a01be4edd9c10173956c32226595c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/947c0de028a01be4edd9c10173956c32226595c2", "html_url": "https://github.com/rust-lang/rust/commit/947c0de028a01be4edd9c10173956c32226595c2"}], "stats": {"total": 71, "additions": 46, "deletions": 25}, "files": [{"sha": "01d84e287bc9fbf788446269c646562b3cf8086a", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/020655b90da83b0a037a9d3c987be17f04eedbc4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020655b90da83b0a037a9d3c987be17f04eedbc4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=020655b90da83b0a037a9d3c987be17f04eedbc4", "patch": "@@ -645,6 +645,11 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                                 .type_variables()\n                                 .new_var(self.for_universe, Diverging::NotDiverging, origin);\n                             let u = self.tcx().mk_ty_var(new_var_id);\n+\n+                            // Record that we replaced `vid` with `new_var_id` as part of a generalization\n+                            // operation. This is needed to detect cyclic types. To see why, see the\n+                            // docs in the `type_variables` module.\n+                            self.infcx.inner.borrow_mut().type_variables().sub(vid, new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n                             Ok(u)\n                         }"}, {"sha": "b3d6e44d80eb66729dea1e6b8e403b46603abae3", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/020655b90da83b0a037a9d3c987be17f04eedbc4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020655b90da83b0a037a9d3c987be17f04eedbc4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=020655b90da83b0a037a9d3c987be17f04eedbc4", "patch": "@@ -1004,23 +1004,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         predicate: ty::PolySubtypePredicate<'tcx>,\n     ) -> Option<InferResult<'tcx, ()>> {\n-        // Subtle: it's ok to skip the binder here and resolve because\n-        // `shallow_resolve` just ignores anything that is not a type\n-        // variable, and because type variable's can't (at present, at\n+        // Check for two unresolved inference variables, in which case we can\n+        // make no progress. This is partly a micro-optimization, but it's\n+        // also an opportunity to \"sub-unify\" the variables. This isn't\n+        // *necessary* to prevent cycles, because they would eventually be sub-unified\n+        // anyhow during generalization, but it helps with diagnostics (we can detect\n+        // earlier that they are sub-unified).\n+        //\n+        // Note that we can just skip the binders here because\n+        // type variables can't (at present, at\n         // least) capture any of the things bound by this binder.\n         //\n-        // NOTE(nmatsakis): really, there is no *particular* reason to do this\n-        // `shallow_resolve` here except as a micro-optimization.\n-        // Naturally I could not resist.\n-        let two_unbound_type_vars = {\n-            let a = self.shallow_resolve(predicate.skip_binder().a);\n-            let b = self.shallow_resolve(predicate.skip_binder().b);\n-            a.is_ty_var() && b.is_ty_var()\n-        };\n-\n-        if two_unbound_type_vars {\n-            // Two unbound type variables? Can't make progress.\n-            return None;\n+        // Note that this sub here is not just for diagnostics - it has semantic\n+        // effects as well.\n+        let r_a = self.shallow_resolve(predicate.skip_binder().a);\n+        let r_b = self.shallow_resolve(predicate.skip_binder().b);\n+        match (r_a.kind(), r_b.kind()) {\n+            (&ty::Infer(ty::TyVar(a_vid)), &ty::Infer(ty::TyVar(b_vid))) => {\n+                self.inner.borrow_mut().type_variables().sub(a_vid, b_vid);\n+                return None;\n+            }\n+            _ => {}\n         }\n \n         Some(self.commit_if_ok(|_snapshot| {"}, {"sha": "1692d8ee526d0519474eed4c1016d6715a30130b", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/020655b90da83b0a037a9d3c987be17f04eedbc4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020655b90da83b0a037a9d3c987be17f04eedbc4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=020655b90da83b0a037a9d3c987be17f04eedbc4", "patch": "@@ -85,19 +85,15 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n         let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n         match (a.kind(), b.kind()) {\n-            (&ty::Infer(TyVar(a_vid)), &ty::Infer(TyVar(b_vid))) => {\n+            (&ty::Infer(TyVar(_)), &ty::Infer(TyVar(_))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n                 // this under a binder below without fear of accidental\n                 // capture.\n                 assert!(!a.has_escaping_bound_vars());\n                 assert!(!b.has_escaping_bound_vars());\n \n                 // can't make progress on `A <: B` if both A and B are\n-                // type variables, so record an obligation. We also\n-                // have to record in the `type_variables` tracker that\n-                // the two variables are equal modulo subtyping, which\n-                // is important to the occurs check later on.\n-                infcx.inner.borrow_mut().type_variables().sub(a_vid, b_vid);\n+                // type variables, so record an obligation.\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,"}, {"sha": "d2b0bdaf9780292ae613391470556199ca775968", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/020655b90da83b0a037a9d3c987be17f04eedbc4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020655b90da83b0a037a9d3c987be17f04eedbc4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=020655b90da83b0a037a9d3c987be17f04eedbc4", "patch": "@@ -75,14 +75,30 @@ pub struct TypeVariableStorage<'tcx> {\n     ///     ?1 <: ?3\n     ///     Box<?3> <: ?1\n     ///\n-    /// This works because `?1` and `?3` are unified in the\n-    /// `sub_relations` relation (not in `eq_relations`). Then when we\n-    /// process the `Box<?3> <: ?1` constraint, we do an occurs check\n-    /// on `Box<?3>` and find a potential cycle.\n+    /// Without this second table, what would happen in a case like\n+    /// this is that we would instantiate `?1` with a generalized\n+    /// type like `Box<?6>`. We would then relate `Box<?3> <: Box<?6>`\n+    /// and infer that `?3 <: ?6`. Next, since `?1` was instantiated,\n+    /// we would process `?1 <: ?3`, generalize `?1 = Box<?6>` to `Box<?9>`,\n+    /// and instantiate `?3` with `Box<?9>`. Finally, we would relate\n+    /// `?6 <: ?9`. But now that we instantiated `?3`, we can process\n+    /// `?3 <: ?6`, which gives us `Box<?9> <: ?6`... and the cycle\n+    /// continues. (This is `occurs-check-2.rs`.)\n+    ///\n+    /// What prevents this cycle is that when we generalize\n+    /// `Box<?3>` to `Box<?6>`, we also sub-unify `?3` and `?6`\n+    /// (in the generalizer). When we then process `Box<?6> <: ?3`,\n+    /// the occurs check then fails because `?6` and `?3` are sub-unified,\n+    /// and hence generalization fails.\n     ///\n     /// This is reasonable because, in Rust, subtypes have the same\n     /// \"skeleton\" and hence there is no possible type such that\n     /// (e.g.)  `Box<?3> <: ?3` for any `?3`.\n+    ///\n+    /// In practice, we sometimes sub-unify variables in other spots, such\n+    /// as when processing subtype predicates. This is not necessary but is\n+    /// done to aid diagnostics, as it allows us to be more effective when\n+    /// we guide the user towards where they should insert type hints.\n     sub_relations: ut::UnificationTableStorage<ty::TyVid>,\n }\n "}]}