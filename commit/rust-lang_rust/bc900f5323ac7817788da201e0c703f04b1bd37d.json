{"sha": "bc900f5323ac7817788da201e0c703f04b1bd37d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjOTAwZjUzMjNhYzc4MTc3ODhkYTIwMWUwYzcwM2YwNGIxYmQzN2Q=", "commit": {"author": {"name": "BurntPizza", "email": "xburntpizza@gmail.com", "date": "2018-08-15T06:54:21Z"}, "committer": {"name": "BurntPizza", "email": "xburntpizza@gmail.com", "date": "2018-08-15T16:37:08Z"}, "message": "Mark libserialize functions as inline", "tree": {"sha": "5c79b09e156f76e2ee3aeb98d6871876fbc80ffd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c79b09e156f76e2ee3aeb98d6871876fbc80ffd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc900f5323ac7817788da201e0c703f04b1bd37d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc900f5323ac7817788da201e0c703f04b1bd37d", "html_url": "https://github.com/rust-lang/rust/commit/bc900f5323ac7817788da201e0c703f04b1bd37d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc900f5323ac7817788da201e0c703f04b1bd37d/comments", "author": {"login": "BurntPizza", "id": 4973668, "node_id": "MDQ6VXNlcjQ5NzM2Njg=", "avatar_url": "https://avatars.githubusercontent.com/u/4973668?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BurntPizza", "html_url": "https://github.com/BurntPizza", "followers_url": "https://api.github.com/users/BurntPizza/followers", "following_url": "https://api.github.com/users/BurntPizza/following{/other_user}", "gists_url": "https://api.github.com/users/BurntPizza/gists{/gist_id}", "starred_url": "https://api.github.com/users/BurntPizza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BurntPizza/subscriptions", "organizations_url": "https://api.github.com/users/BurntPizza/orgs", "repos_url": "https://api.github.com/users/BurntPizza/repos", "events_url": "https://api.github.com/users/BurntPizza/events{/privacy}", "received_events_url": "https://api.github.com/users/BurntPizza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BurntPizza", "id": 4973668, "node_id": "MDQ6VXNlcjQ5NzM2Njg=", "avatar_url": "https://avatars.githubusercontent.com/u/4973668?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BurntPizza", "html_url": "https://github.com/BurntPizza", "followers_url": "https://api.github.com/users/BurntPizza/followers", "following_url": "https://api.github.com/users/BurntPizza/following{/other_user}", "gists_url": "https://api.github.com/users/BurntPizza/gists{/gist_id}", "starred_url": "https://api.github.com/users/BurntPizza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BurntPizza/subscriptions", "organizations_url": "https://api.github.com/users/BurntPizza/orgs", "repos_url": "https://api.github.com/users/BurntPizza/repos", "events_url": "https://api.github.com/users/BurntPizza/events{/privacy}", "received_events_url": "https://api.github.com/users/BurntPizza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5db71dbae8c9cd0e6ac0558c54f2e2a6b1147d17", "url": "https://api.github.com/repos/rust-lang/rust/commits/5db71dbae8c9cd0e6ac0558c54f2e2a6b1147d17", "html_url": "https://github.com/rust-lang/rust/commit/5db71dbae8c9cd0e6ac0558c54f2e2a6b1147d17"}], "stats": {"total": 123, "additions": 123, "deletions": 0}, "files": [{"sha": "7103e1c7919960c1516a487d130be7635c0b0ff3", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc900f5323ac7817788da201e0c703f04b1bd37d/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc900f5323ac7817788da201e0c703f04b1bd37d/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=bc900f5323ac7817788da201e0c703f04b1bd37d", "patch": "@@ -20,6 +20,7 @@ use std::sync::Arc;\n impl<\n     T: Encodable\n > Encodable for LinkedList<T> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -31,6 +32,7 @@ impl<\n }\n \n impl<T:Decodable> Decodable for LinkedList<T> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut list = LinkedList::new();\n@@ -43,6 +45,7 @@ impl<T:Decodable> Decodable for LinkedList<T> {\n }\n \n impl<T: Encodable> Encodable for VecDeque<T> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -54,6 +57,7 @@ impl<T: Encodable> Encodable for VecDeque<T> {\n }\n \n impl<T:Decodable> Decodable for VecDeque<T> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut deque: VecDeque<T> = VecDeque::new();\n@@ -69,6 +73,7 @@ impl<\n     K: Encodable + PartialEq + Ord,\n     V: Encodable\n > Encodable for BTreeMap<K, V> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n@@ -86,6 +91,7 @@ impl<\n     K: Decodable + PartialEq + Ord,\n     V: Decodable\n > Decodable for BTreeMap<K, V> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = BTreeMap::new();\n@@ -102,6 +108,7 @@ impl<\n impl<\n     T: Encodable + PartialEq + Ord\n > Encodable for BTreeSet<T> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n@@ -117,6 +124,7 @@ impl<\n impl<\n     T: Decodable + PartialEq + Ord\n > Decodable for BTreeSet<T> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut set = BTreeSet::new();\n@@ -133,6 +141,7 @@ impl<K, V, S> Encodable for HashMap<K, V, S>\n           V: Encodable,\n           S: BuildHasher,\n {\n+    #[inline]\n     fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n@@ -151,6 +160,7 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n           V: Decodable,\n           S: BuildHasher + Default,\n {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n         d.read_map(|d, len| {\n             let state = Default::default();\n@@ -169,6 +179,7 @@ impl<T, S> Encodable for HashSet<T, S>\n     where T: Encodable + Hash + Eq,\n           S: BuildHasher,\n {\n+    #[inline]\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n@@ -185,6 +196,7 @@ impl<T, S> Decodable for HashSet<T, S>\n     where T: Decodable + Hash + Eq,\n           S: BuildHasher + Default,\n {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n         d.read_seq(|d, len| {\n             let state = Default::default();\n@@ -198,6 +210,7 @@ impl<T, S> Decodable for HashSet<T, S>\n }\n \n impl<T: Encodable> Encodable for Rc<[T]> {\n+    #[inline]\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (index, e) in self.iter().enumerate() {\n@@ -209,6 +222,7 @@ impl<T: Encodable> Encodable for Rc<[T]> {\n }\n \n impl<T: Decodable> Decodable for Rc<[T]> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Rc<[T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut vec = Vec::with_capacity(len);\n@@ -221,6 +235,7 @@ impl<T: Decodable> Decodable for Rc<[T]> {\n }\n \n impl<T: Encodable> Encodable for Arc<[T]> {\n+    #[inline]\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (index, e) in self.iter().enumerate() {\n@@ -232,6 +247,7 @@ impl<T: Encodable> Encodable for Arc<[T]> {\n }\n \n impl<T: Decodable> Decodable for Arc<[T]> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Arc<[T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut vec = Vec::with_capacity(len);"}, {"sha": "e02bc5e1025fd6d9ceffaaff3aaa4d0101ea27b3", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc900f5323ac7817788da201e0c703f04b1bd37d/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc900f5323ac7817788da201e0c703f04b1bd37d/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=bc900f5323ac7817788da201e0c703f04b1bd37d", "patch": "@@ -118,6 +118,7 @@ pub fn write_signed_leb128_to<W>(mut value: i128, mut write: W)\n     }\n }\n \n+#[inline]\n pub fn write_signed_leb128(out: &mut Vec<u8>, value: i128) {\n     write_signed_leb128_to(value, |v| write_to_vec(out, v))\n }"}, {"sha": "c71f474891131dede6617e443b15b3efd4da1e17", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc900f5323ac7817788da201e0c703f04b1bd37d/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc900f5323ac7817788da201e0c703f04b1bd37d/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=bc900f5323ac7817788da201e0c703f04b1bd37d", "patch": "@@ -31,6 +31,7 @@ impl Encoder {\n         self.data\n     }\n \n+    #[inline]\n     pub fn emit_raw_bytes(&mut self, s: &[u8]) {\n         self.data.extend_from_slice(s);\n     }\n@@ -193,6 +194,7 @@ impl<'a> Decoder<'a> {\n         self.position += bytes;\n     }\n \n+    #[inline]\n     pub fn read_raw_bytes(&mut self, s: &mut [u8]) -> Result<(), String> {\n         let start = self.position;\n         let end = start + s.len();\n@@ -326,6 +328,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         Ok(Cow::Borrowed(s))\n     }\n \n+    #[inline]\n     fn error(&mut self, err: &str) -> Self::Error {\n         err.to_string()\n     }"}, {"sha": "b2073f6d0a3722660ae1f74c49064299aedf721b", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/bc900f5323ac7817788da201e0c703f04b1bd37d/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc900f5323ac7817788da201e0c703f04b1bd37d/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=bc900f5323ac7817788da201e0c703f04b1bd37d", "patch": "@@ -45,116 +45,135 @@ pub trait Encoder {\n     fn emit_str(&mut self, v: &str) -> Result<(), Self::Error>;\n \n     // Compound types:\n+    #[inline]\n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn emit_enum_variant<F>(&mut self, _v_name: &str, v_id: usize, _len: usize, f: F)\n         -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_usize(v_id)?;\n         f(self)\n     }\n \n+    #[inline]\n     fn emit_enum_variant_arg<F>(&mut self, _a_idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn emit_enum_struct_variant<F>(&mut self, v_name: &str, v_id: usize, len: usize, f: F)\n         -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_enum_variant(v_name, v_id, len, f)\n     }\n \n+    #[inline]\n     fn emit_enum_struct_variant_field<F>(&mut self, _f_name: &str, f_idx: usize, f: F)\n         -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_enum_variant_arg(f_idx, f)\n     }\n \n+    #[inline]\n     fn emit_struct<F>(&mut self, _name: &str, _len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn emit_struct_field<F>(&mut self, _f_name: &str, _f_idx: usize, f: F)\n         -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn emit_tuple<F>(&mut self, _len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn emit_tuple_arg<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_tuple(len, f)\n     }\n \n+    #[inline]\n     fn emit_tuple_struct_arg<F>(&mut self, f_idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_tuple_arg(f_idx, f)\n     }\n \n     // Specialized types:\n+    #[inline]\n     fn emit_option<F>(&mut self, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_enum(\"Option\", f)\n     }\n \n+    #[inline]\n     fn emit_option_none(&mut self) -> Result<(), Self::Error> {\n         self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n     }\n \n+    #[inline]\n     fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_enum_variant(\"Some\", 1, 1, f)\n     }\n \n+    #[inline]\n     fn emit_seq<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_usize(len)?;\n         f(self)\n     }\n \n+    #[inline]\n     fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn emit_map<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_usize(len)?;\n         f(self)\n     }\n \n+    #[inline]\n     fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n@@ -186,74 +205,86 @@ pub trait Decoder {\n     fn read_str(&mut self) -> Result<Cow<str>, Self::Error>;\n \n     // Compound types:\n+    #[inline]\n     fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn read_enum_variant<T, F>(&mut self, _names: &[&str], mut f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>\n     {\n         let disr = self.read_usize()?;\n         f(self, disr)\n     }\n \n+    #[inline]\n     fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>\n     {\n         self.read_enum_variant(names, f)\n     }\n \n+    #[inline]\n     fn read_enum_struct_variant_field<T, F>(&mut self, _f_name: &str, f_idx: usize, f: F)\n         -> Result<T, Self::Error> where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         self.read_enum_variant_arg(f_idx, f)\n     }\n \n+    #[inline]\n     fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn read_struct_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, f: F)\n         -> Result<T, Self::Error> where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn read_tuple<T, F>(&mut self, _len: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn read_tuple_struct<T, F>(&mut self, _s_name: &str, len: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         self.read_tuple(len, f)\n     }\n \n+    #[inline]\n     fn read_tuple_struct_arg<T, F>(&mut self, a_idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         self.read_tuple_arg(a_idx, f)\n     }\n \n     // Specialized types:\n+    #[inline]\n     fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Self, bool) -> Result<T, Self::Error>\n     {\n@@ -268,32 +299,37 @@ pub trait Decoder {\n         })\n     }\n \n+    #[inline]\n     fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>\n     {\n         let len = self.read_usize()?;\n         f(self, len)\n     }\n \n+    #[inline]\n     fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>\n     {\n         let len = self.read_usize()?;\n         f(self, len)\n     }\n \n+    #[inline]\n     fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n+    #[inline]\n     fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n@@ -313,246 +349,287 @@ pub trait Decodable: Sized {\n }\n \n impl Encodable for usize {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_usize(*self)\n     }\n }\n \n impl Decodable for usize {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<usize, D::Error> {\n         d.read_usize()\n     }\n }\n \n impl Encodable for u8 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u8(*self)\n     }\n }\n \n impl Decodable for u8 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<u8, D::Error> {\n         d.read_u8()\n     }\n }\n \n impl Encodable for u16 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u16(*self)\n     }\n }\n \n impl Decodable for u16 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<u16, D::Error> {\n         d.read_u16()\n     }\n }\n \n impl Encodable for u32 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u32(*self)\n     }\n }\n \n impl Decodable for u32 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<u32, D::Error> {\n         d.read_u32()\n     }\n }\n \n impl Encodable for u64 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u64(*self)\n     }\n }\n \n impl Decodable for u64 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<u64, D::Error> {\n         d.read_u64()\n     }\n }\n \n impl Encodable for u128 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u128(*self)\n     }\n }\n \n impl Decodable for u128 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<u128, D::Error> {\n         d.read_u128()\n     }\n }\n \n impl Encodable for isize {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_isize(*self)\n     }\n }\n \n impl Decodable for isize {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<isize, D::Error> {\n         d.read_isize()\n     }\n }\n \n impl Encodable for i8 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i8(*self)\n     }\n }\n \n impl Decodable for i8 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<i8, D::Error> {\n         d.read_i8()\n     }\n }\n \n impl Encodable for i16 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i16(*self)\n     }\n }\n \n impl Decodable for i16 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<i16, D::Error> {\n         d.read_i16()\n     }\n }\n \n impl Encodable for i32 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i32(*self)\n     }\n }\n \n impl Decodable for i32 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<i32, D::Error> {\n         d.read_i32()\n     }\n }\n \n impl Encodable for i64 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i64(*self)\n     }\n }\n \n impl Decodable for i64 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<i64, D::Error> {\n         d.read_i64()\n     }\n }\n \n impl Encodable for i128 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i128(*self)\n     }\n }\n \n impl Decodable for i128 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<i128, D::Error> {\n         d.read_i128()\n     }\n }\n \n impl Encodable for str {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(self)\n     }\n }\n \n impl Encodable for String {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(&self[..])\n     }\n }\n \n impl Decodable for String {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<String, D::Error> {\n         Ok(d.read_str()?.into_owned())\n     }\n }\n \n impl Encodable for f32 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_f32(*self)\n     }\n }\n \n impl Decodable for f32 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<f32, D::Error> {\n         d.read_f32()\n     }\n }\n \n impl Encodable for f64 {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_f64(*self)\n     }\n }\n \n impl Decodable for f64 {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<f64, D::Error> {\n         d.read_f64()\n     }\n }\n \n impl Encodable for bool {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_bool(*self)\n     }\n }\n \n impl Decodable for bool {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<bool, D::Error> {\n         d.read_bool()\n     }\n }\n \n impl Encodable for char {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_char(*self)\n     }\n }\n \n impl Decodable for char {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<char, D::Error> {\n         d.read_char()\n     }\n }\n \n impl Encodable for () {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_nil()\n     }\n }\n \n impl Decodable for () {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<(), D::Error> {\n         d.read_nil()\n     }\n }\n \n impl<'a, T: ?Sized + Encodable> Encodable for &'a T {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n impl<T: ?Sized + Encodable> Encodable for Box<T> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n impl< T: Decodable> Decodable for Box<T> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Box<T>, D::Error> {\n         Ok(box Decodable::decode(d)?)\n     }\n }\n \n impl< T: Decodable> Decodable for Box<[T]> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Box<[T]>, D::Error> {\n         let v: Vec<T> = Decodable::decode(d)?;\n         Ok(v.into_boxed_slice())\n@@ -574,6 +651,7 @@ impl<T:Decodable> Decodable for Rc<T> {\n }\n \n impl<T:Encodable> Encodable for [T] {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -585,6 +663,7 @@ impl<T:Encodable> Encodable for [T] {\n }\n \n impl<T:Encodable> Encodable for Vec<T> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -596,6 +675,7 @@ impl<T:Encodable> Encodable for Vec<T> {\n }\n \n impl<T:Decodable> Decodable for Vec<T> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Vec<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n@@ -608,6 +688,7 @@ impl<T:Decodable> Decodable for Vec<T> {\n }\n \n impl<'a, T:Encodable> Encodable for Cow<'a, [T]> where [T]: ToOwned<Owned = Vec<T>> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -619,6 +700,7 @@ impl<'a, T:Encodable> Encodable for Cow<'a, [T]> where [T]: ToOwned<Owned = Vec<\n }\n \n impl<T:Decodable+ToOwned> Decodable for Cow<'static, [T]> where [T]: ToOwned<Owned = Vec<T>> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Cow<'static, [T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n@@ -632,6 +714,7 @@ impl<T:Decodable+ToOwned> Decodable for Cow<'static, [T]> where [T]: ToOwned<Own\n \n \n impl<T:Encodable> Encodable for Option<T> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_option(|s| {\n             match *self {\n@@ -643,6 +726,7 @@ impl<T:Encodable> Encodable for Option<T> {\n }\n \n impl<T:Decodable> Decodable for Option<T> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Option<T>, D::Error> {\n         d.read_option(|d, b| {\n             if b {\n@@ -655,6 +739,7 @@ impl<T:Decodable> Decodable for Option<T> {\n }\n \n impl<T1: Encodable, T2: Encodable> Encodable for Result<T1, T2> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_enum(\"Result\", |s| {\n             match *self {\n@@ -678,6 +763,7 @@ impl<T1: Encodable, T2: Encodable> Encodable for Result<T1, T2> {\n }\n \n impl<T1:Decodable, T2:Decodable> Decodable for Result<T1, T2> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Result<T1, T2>, D::Error> {\n         d.read_enum(\"Result\", |d| {\n             d.read_enum_variant(&[\"Ok\", \"Err\"], |d, disr| {\n@@ -717,6 +803,7 @@ macro_rules! tuple {\n     ( $($name:ident,)+ ) => (\n         impl<$($name:Decodable),*> Decodable for ($($name,)*) {\n             #[allow(non_snake_case)]\n+            #[inline]\n             fn decode<D: Decoder>(d: &mut D) -> Result<($($name,)*), D::Error> {\n                 let len: usize = count_idents!($($name,)*);\n                 d.read_tuple(len, |d| {\n@@ -730,6 +817,7 @@ macro_rules! tuple {\n         }\n         impl<$($name:Encodable),*> Encodable for ($($name,)*) {\n             #[allow(non_snake_case)]\n+            #[inline]\n             fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n                 let ($(ref $name,)*) = *self;\n                 let mut n = 0;\n@@ -748,25 +836,29 @@ macro_rules! tuple {\n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n impl Encodable for path::PathBuf {\n+    #[inline]\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         self.to_str().unwrap().encode(e)\n     }\n }\n \n impl Decodable for path::PathBuf {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<path::PathBuf, D::Error> {\n         let bytes: String = Decodable::decode(d)?;\n         Ok(path::PathBuf::from(bytes))\n     }\n }\n \n impl<T: Encodable + Copy> Encodable for Cell<T> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.get().encode(s)\n     }\n }\n \n impl<T: Decodable + Copy> Decodable for Cell<T> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Cell<T>, D::Error> {\n         Ok(Cell::new(Decodable::decode(d)?))\n     }\n@@ -778,24 +870,28 @@ impl<T: Decodable + Copy> Decodable for Cell<T> {\n // from `encode` when `try_borrow` returns `None`.\n \n impl<T: Encodable> Encodable for RefCell<T> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.borrow().encode(s)\n     }\n }\n \n impl<T: Decodable> Decodable for RefCell<T> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<RefCell<T>, D::Error> {\n         Ok(RefCell::new(Decodable::decode(d)?))\n     }\n }\n \n impl<T:Encodable> Encodable for Arc<T> {\n+    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n impl<T:Decodable> Decodable for Arc<T> {\n+    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Arc<T>, D::Error> {\n         Ok(Arc::new(Decodable::decode(d)?))\n     }\n@@ -817,6 +913,7 @@ pub trait SpecializationError {\n }\n \n impl<E> SpecializationError for E {\n+    #[inline]\n     default fn not_found<S, T: ?Sized>(trait_name: &'static str, method_name: &'static str) -> E {\n         panic!(\"missing specialization: `<{} as {}<{}>>::{}` not overridden\",\n                unsafe { intrinsics::type_name::<S>() },\n@@ -835,6 +932,7 @@ pub trait SpecializedEncoder<T: ?Sized + UseSpecializedEncodable>: Encoder {\n }\n \n impl<E: Encoder, T: ?Sized + UseSpecializedEncodable> SpecializedEncoder<T> for E {\n+    #[inline]\n     default fn specialized_encode(&mut self, value: &T) -> Result<(), E::Error> {\n         value.default_encode(self)\n     }\n@@ -849,6 +947,7 @@ pub trait SpecializedDecoder<T: UseSpecializedDecodable>: Decoder {\n }\n \n impl<D: Decoder, T: UseSpecializedDecodable> SpecializedDecoder<T> for D {\n+    #[inline]\n     default fn specialized_decode(&mut self) -> Result<T, D::Error> {\n         T::default_decode(self)\n     }\n@@ -858,12 +957,14 @@ impl<D: Decoder, T: UseSpecializedDecodable> SpecializedDecoder<T> for D {\n /// implementation which goes through `SpecializedEncoder`.\n pub trait UseSpecializedEncodable {\n     /// Defaults to returning an error (see `SpecializationError`).\n+    #[inline]\n     fn default_encode<E: Encoder>(&self, _: &mut E) -> Result<(), E::Error> {\n         Err(E::Error::not_found::<E, Self>(\"SpecializedEncoder\", \"specialized_encode\"))\n     }\n }\n \n impl<T: ?Sized + UseSpecializedEncodable> Encodable for T {\n+    #[inline]\n     default fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         E::specialized_encode(e, self)\n     }\n@@ -873,12 +974,14 @@ impl<T: ?Sized + UseSpecializedEncodable> Encodable for T {\n /// implementation which goes through `SpecializedDecoder`.\n pub trait UseSpecializedDecodable: Sized {\n     /// Defaults to returning an error (see `SpecializationError`).\n+    #[inline]\n     fn default_decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n         Err(D::Error::not_found::<D, Self>(\"SpecializedDecoder\", \"specialized_decode\"))\n     }\n }\n \n impl<T: UseSpecializedDecodable> Decodable for T {\n+    #[inline]\n     default fn decode<D: Decoder>(d: &mut D) -> Result<T, D::Error> {\n         D::specialized_decode(d)\n     }"}]}