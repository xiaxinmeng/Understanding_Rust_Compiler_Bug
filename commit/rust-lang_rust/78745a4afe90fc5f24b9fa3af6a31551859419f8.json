{"sha": "78745a4afe90fc5f24b9fa3af6a31551859419f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NzQ1YTRhZmU5MGZjNWYyNGI5ZmEzYWY2YTMxNTUxODU5NDE5Zjg=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-04-15T18:14:54Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-04-18T16:32:14Z"}, "message": "Emit correct alignment information for loads/store of small aggregates\n\nLoading from and storing to small aggregates happens by casting the\naggregate pointer to an appropriately sized integer pointer to avoid\nthe usage of first class aggregates which would lead to less optimized\ncode.\n\nBut this means that, for example, a tuple of type (i16, i16) will be\nloading through an i32 pointer and because we currently don't provide\nalignment information LLVM assumes that the load should use the ABI\nalignment for i32 which would usually be 4 byte alignment. But the\nalignment requirement for the (i16, i16) tuple will usually be just 2\nbytes, so we're overestimating alignment, which invokes undefined\nbehaviour.\n\nTherefore we must emit appropriate alignment information for\nstores/loads through such casted pointers.\n\nFixes #23431", "tree": {"sha": "48bd308ab7f04a46b62217c3f0067cc10e07cd8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48bd308ab7f04a46b62217c3f0067cc10e07cd8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78745a4afe90fc5f24b9fa3af6a31551859419f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78745a4afe90fc5f24b9fa3af6a31551859419f8", "html_url": "https://github.com/rust-lang/rust/commit/78745a4afe90fc5f24b9fa3af6a31551859419f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78745a4afe90fc5f24b9fa3af6a31551859419f8/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcf637b19f1a94dcf1748b8b29fca100f150eb0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcf637b19f1a94dcf1748b8b29fca100f150eb0a", "html_url": "https://github.com/rust-lang/rust/commit/fcf637b19f1a94dcf1748b8b29fca100f150eb0a"}], "stats": {"total": 58, "additions": 42, "deletions": 16}, "files": [{"sha": "ffa068a2ae44b80f39001abe1370605964416ec7", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=78745a4afe90fc5f24b9fa3af6a31551859419f8", "patch": "@@ -880,7 +880,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n-                  val)\n+                  val);\n         }\n         General(ity, ref cases, dtor) => {\n             if dtor_active(dtor) {\n@@ -889,7 +889,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                 Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED as usize), ptr);\n             }\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n-                  GEPi(bcx, val, &[0, 0]))\n+                  GEPi(bcx, val, &[0, 0]));\n         }\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n@@ -901,14 +901,14 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         RawNullablePointer { nndiscr, nnty, ..} => {\n             if discr != nndiscr {\n                 let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n-                Store(bcx, C_null(llptrty), val)\n+                Store(bcx, C_null(llptrty), val);\n             }\n         }\n         StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             if discr != nndiscr {\n                 let llptrptr = GEPi(bcx, val, &discrfield[..]);\n                 let llptrty = val_ty(llptrptr).element_type();\n-                Store(bcx, C_null(llptrty), llptrptr)\n+                Store(bcx, C_null(llptrty), llptrptr);\n             }\n         }\n     }"}, {"sha": "59f3ff72602616f0dfe246234a55fd94f501b385", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=78745a4afe90fc5f24b9fa3af6a31551859419f8", "patch": "@@ -765,9 +765,14 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n \n     let ptr = to_arg_ty_ptr(cx, ptr, t);\n+    let align = type_of::align_of(cx.ccx(), t);\n \n     if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n-        return Load(cx, ptr);\n+        let load = Load(cx, ptr);\n+        unsafe {\n+            llvm::LLVMSetAlignment(load, align);\n+        }\n+        return load;\n     }\n \n     unsafe {\n@@ -793,13 +798,24 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         Load(cx, ptr)\n     };\n \n+    unsafe {\n+        llvm::LLVMSetAlignment(val, align);\n+    }\n+\n     from_arg_ty(cx, val, t)\n }\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n-    Store(cx, to_arg_ty(cx, v, t), to_arg_ty_ptr(cx, dst, t));\n+    if cx.unreachable.get() {\n+        return;\n+    }\n+\n+    let store = Store(cx, to_arg_ty(cx, v, t), to_arg_ty_ptr(cx, dst, t));\n+    unsafe {\n+        llvm::LLVMSetAlignment(store, type_of::align_of(cx.ccx(), t));\n+    }\n }\n \n pub fn to_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {"}, {"sha": "32d73e50e6b6bf1b3cef7a46f21c907be169a5fc", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=78745a4afe90fc5f24b9fa3af6a31551859419f8", "patch": "@@ -646,13 +646,13 @@ pub fn LoadNonNull(cx: Block, ptr: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn Store(cx: Block, val: ValueRef, ptr: ValueRef) {\n-    if cx.unreachable.get() { return; }\n+pub fn Store(cx: Block, val: ValueRef, ptr: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return C_nil(cx.ccx()); }\n     B(cx).store(val, ptr)\n }\n \n-pub fn VolatileStore(cx: Block, val: ValueRef, ptr: ValueRef) {\n-    if cx.unreachable.get() { return; }\n+pub fn VolatileStore(cx: Block, val: ValueRef, ptr: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return C_nil(cx.ccx()); }\n     B(cx).volatile_store(val, ptr)\n }\n "}, {"sha": "3febd41bdce2eccbdccf71ff79947fa68e48639c", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=78745a4afe90fc5f24b9fa3af6a31551859419f8", "patch": "@@ -509,18 +509,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         value\n     }\n \n-    pub fn store(&self, val: ValueRef, ptr: ValueRef) {\n+    pub fn store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n         debug!(\"Store {} -> {}\",\n                self.ccx.tn().val_to_string(val),\n                self.ccx.tn().val_to_string(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         unsafe {\n-            llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n+            llvm::LLVMBuildStore(self.llbuilder, val, ptr)\n         }\n     }\n \n-    pub fn volatile_store(&self, val: ValueRef, ptr: ValueRef) {\n+    pub fn volatile_store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n         debug!(\"Store {} -> {}\",\n                self.ccx.tn().val_to_string(val),\n                self.ccx.tn().val_to_string(ptr));\n@@ -529,6 +529,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         unsafe {\n             let insn = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n             llvm::LLVMSetVolatile(insn, llvm::True);\n+            insn\n         }\n     }\n "}, {"sha": "c025be2ee98772eb7241dd565501c90a77bbe757", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=78745a4afe90fc5f24b9fa3af6a31551859419f8", "patch": "@@ -802,7 +802,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     // appropriately sized integer and we have to convert it\n                     let tmp = builder.bitcast(llforeign_arg,\n                                               type_of::arg_type_of(ccx, rust_ty).ptr_to());\n-                    builder.load(tmp)\n+                    let load = builder.load(tmp);\n+                    llvm::LLVMSetAlignment(load, type_of::align_of(ccx, rust_ty));\n+                    load\n                 } else {\n                     builder.load(llforeign_arg)\n                 }"}, {"sha": "1e67212871a1e10e3b765e417f51f936afe29a3d", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78745a4afe90fc5f24b9fa3af6a31551859419f8/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=78745a4afe90fc5f24b9fa3af6a31551859419f8", "patch": "@@ -456,13 +456,20 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"volatile_load\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-            from_arg_ty(bcx, VolatileLoad(bcx, ptr), tp_ty)\n+            let load = VolatileLoad(bcx, ptr);\n+            unsafe {\n+                llvm::LLVMSetAlignment(load, type_of::align_of(ccx, tp_ty));\n+            }\n+            from_arg_ty(bcx, load, tp_ty)\n         },\n         (_, \"volatile_store\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n             let val = to_arg_ty(bcx, llargs[1], tp_ty);\n-            VolatileStore(bcx, val, ptr);\n+            let store = VolatileStore(bcx, val, ptr);\n+            unsafe {\n+                llvm::LLVMSetAlignment(store, type_of::align_of(ccx, tp_ty));\n+            }\n             C_nil(ccx)\n         },\n "}]}