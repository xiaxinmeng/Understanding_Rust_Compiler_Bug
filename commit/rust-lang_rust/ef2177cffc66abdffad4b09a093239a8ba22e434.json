{"sha": "ef2177cffc66abdffad4b09a093239a8ba22e434", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMjE3N2NmZmM2NmFiZGZmYWQ0YjA5YTA5MzIzOWE4YmEyMmU0MzQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-20T21:46:30Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-24T18:47:35Z"}, "message": "Rename ByVal(Pair) to Scalar(Pair)", "tree": {"sha": "7b6a44abd1c8d91dae2f9fee28052f78f69a21b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b6a44abd1c8d91dae2f9fee28052f78f69a21b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef2177cffc66abdffad4b09a093239a8ba22e434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef2177cffc66abdffad4b09a093239a8ba22e434", "html_url": "https://github.com/rust-lang/rust/commit/ef2177cffc66abdffad4b09a093239a8ba22e434", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef2177cffc66abdffad4b09a093239a8ba22e434/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1606e137e7de642d7994e201ed54389a4e808e24", "url": "https://api.github.com/repos/rust-lang/rust/commits/1606e137e7de642d7994e201ed54389a4e808e24", "html_url": "https://github.com/rust-lang/rust/commit/1606e137e7de642d7994e201ed54389a4e808e24"}], "stats": {"total": 238, "additions": 119, "deletions": 119}, "files": [{"sha": "b83b77136c84a5ccf5a2618ee76aca0f05f2ef1d", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -394,10 +394,10 @@ for ::mir::interpret::ConstValue<'gcx> {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            ByVal(val) => {\n+            Scalar(val) => {\n                 val.hash_stable(hcx, hasher);\n             }\n-            ByValPair(a, b) => {\n+            ScalarPair(a, b) => {\n                 a.hash_stable(hcx, hasher);\n                 b.hash_stable(hcx, hasher);\n             }\n@@ -410,8 +410,8 @@ for ::mir::interpret::ConstValue<'gcx> {\n }\n \n impl_stable_hash_for!(enum mir::interpret::Value {\n-    ByVal(v),\n-    ByValPair(a, b),\n+    Scalar(v),\n+    ScalarPair(a, b),\n     ByRef(ptr, align)\n });\n "}, {"sha": "497f539718947edbd869c881950a1a60e807ecc5", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -5,14 +5,14 @@ use ty;\n \n use super::{EvalResult, MemoryPointer, PointerArithmetic, Allocation};\n \n-/// Represents a constant value in Rust. ByVal and ByValPair are optimizations which\n+/// Represents a constant value in Rust. ByVal and ScalarPair are optimizations which\n /// matches Value's optimizations for easy conversions between these two types\n #[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n     /// Used only for types with layout::abi::Scalar ABI and ZSTs which use Scalar::Undef\n-    ByVal(Scalar),\n+    Scalar(Scalar),\n     /// Used only for types with layout::abi::ScalarPair\n-    ByValPair(Scalar, Scalar),\n+    ScalarPair(Scalar, Scalar),\n     /// Used only for the remaining cases. An allocation + offset into the allocation\n     ByRef(&'tcx Allocation, Size),\n }\n@@ -22,31 +22,31 @@ impl<'tcx> ConstValue<'tcx> {\n     pub fn from_byval_value(val: Value) -> Self {\n         match val {\n             Value::ByRef(..) => bug!(),\n-            Value::ByValPair(a, b) => ConstValue::ByValPair(a, b),\n-            Value::ByVal(val) => ConstValue::ByVal(val),\n+            Value::ScalarPair(a, b) => ConstValue::ScalarPair(a, b),\n+            Value::Scalar(val) => ConstValue::Scalar(val),\n         }\n     }\n \n     #[inline]\n     pub fn to_byval_value(&self) -> Option<Value> {\n         match *self {\n             ConstValue::ByRef(..) => None,\n-            ConstValue::ByValPair(a, b) => Some(Value::ByValPair(a, b)),\n-            ConstValue::ByVal(val) => Some(Value::ByVal(val)),\n+            ConstValue::ScalarPair(a, b) => Some(Value::ScalarPair(a, b)),\n+            ConstValue::Scalar(val) => Some(Value::Scalar(val)),\n         }\n     }\n \n     #[inline]\n     pub fn from_primval(val: Scalar) -> Self {\n-        ConstValue::ByVal(val)\n+        ConstValue::Scalar(val)\n     }\n \n     #[inline]\n     pub fn to_primval(&self) -> Option<Scalar> {\n         match *self {\n             ConstValue::ByRef(..) => None,\n-            ConstValue::ByValPair(..) => None,\n-            ConstValue::ByVal(val) => Some(val),\n+            ConstValue::ScalarPair(..) => None,\n+            ConstValue::Scalar(val) => Some(val),\n         }\n     }\n \n@@ -74,13 +74,13 @@ impl<'tcx> ConstValue<'tcx> {\n /// whether the pointer is supposed to be aligned or not (also see Place).\n ///\n /// For optimization of a few very common cases, there is also a representation for a pair of\n-/// primitive values (`ByValPair`). It allows Miri to avoid making allocations for checked binary\n+/// primitive values (`ScalarPair`). It allows Miri to avoid making allocations for checked binary\n /// operations and fat pointers. This idea was taken from rustc's codegen.\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n pub enum Value {\n     ByRef(Pointer, Align),\n-    ByVal(Scalar),\n-    ByValPair(Scalar, Scalar),\n+    Scalar(Scalar),\n+    ScalarPair(Scalar, Scalar),\n }\n \n impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n@@ -166,15 +166,15 @@ impl<'tcx> Pointer {\n     }\n \n     pub fn to_value_with_len(self, len: u64) -> Value {\n-        Value::ByValPair(self.primval, Scalar::from_u128(len as u128))\n+        Value::ScalarPair(self.primval, Scalar::from_u128(len as u128))\n     }\n \n     pub fn to_value_with_vtable(self, vtable: MemoryPointer) -> Value {\n-        Value::ByValPair(self.primval, Scalar::Ptr(vtable))\n+        Value::ScalarPair(self.primval, Scalar::Ptr(vtable))\n     }\n \n     pub fn to_value(self) -> Value {\n-        Value::ByVal(self.primval)\n+        Value::Scalar(self.primval)\n     }\n }\n "}, {"sha": "0dc860d360fcf1c841a36de0cad9af6e0957abc1", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -1153,7 +1153,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                       .map(|&u| {\n                           let mut s = String::new();\n                           print_miri_value(\n-                              Value::ByVal(Scalar::Bytes(u)),\n+                              Value::Scalar(Scalar::Bytes(u)),\n                               switch_ty,\n                               &mut s,\n                           ).unwrap();\n@@ -1893,19 +1893,19 @@ pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Resul\n pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n     use ty::TypeVariants::*;\n     match (value, &ty.sty) {\n-        (Value::ByVal(Scalar::Bytes(0)), &TyBool) => write!(f, \"false\"),\n-        (Value::ByVal(Scalar::Bytes(1)), &TyBool) => write!(f, \"true\"),\n-        (Value::ByVal(Scalar::Bytes(bits)), &TyFloat(ast::FloatTy::F32)) =>\n+        (Value::Scalar(Scalar::Bytes(0)), &TyBool) => write!(f, \"false\"),\n+        (Value::Scalar(Scalar::Bytes(1)), &TyBool) => write!(f, \"true\"),\n+        (Value::Scalar(Scalar::Bytes(bits)), &TyFloat(ast::FloatTy::F32)) =>\n             write!(f, \"{}f32\", Single::from_bits(bits)),\n-        (Value::ByVal(Scalar::Bytes(bits)), &TyFloat(ast::FloatTy::F64)) =>\n+        (Value::Scalar(Scalar::Bytes(bits)), &TyFloat(ast::FloatTy::F64)) =>\n             write!(f, \"{}f64\", Double::from_bits(bits)),\n-        (Value::ByVal(Scalar::Bytes(n)), &TyUint(ui)) => write!(f, \"{:?}{}\", n, ui),\n-        (Value::ByVal(Scalar::Bytes(n)), &TyInt(i)) => write!(f, \"{:?}{}\", n as i128, i),\n-        (Value::ByVal(Scalar::Bytes(n)), &TyChar) =>\n+        (Value::Scalar(Scalar::Bytes(n)), &TyUint(ui)) => write!(f, \"{:?}{}\", n, ui),\n+        (Value::Scalar(Scalar::Bytes(n)), &TyInt(i)) => write!(f, \"{:?}{}\", n as i128, i),\n+        (Value::Scalar(Scalar::Bytes(n)), &TyChar) =>\n             write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n-        (Value::ByVal(Scalar::Undef), &TyFnDef(did, _)) =>\n+        (Value::Scalar(Scalar::Undef), &TyFnDef(did, _)) =>\n             write!(f, \"{}\", item_path_str(did)),\n-        (Value::ByValPair(Scalar::Ptr(ptr), Scalar::Bytes(len)),\n+        (Value::ScalarPair(Scalar::Ptr(ptr), Scalar::Bytes(len)),\n          &TyRef(_, &ty::TyS { sty: TyStr, .. }, _)) => {\n             ty::tls::with(|tcx| {\n                 match tcx.alloc_map.lock().get(ptr.alloc_id) {"}, {"sha": "606b07d8095c757630ee556b92b3813f0a19a02d", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n \n         let val = match val {\n-            ConstValue::ByVal(x) => {\n+            ConstValue::Scalar(x) => {\n                 let scalar = match layout.abi {\n                     layout::Abi::Scalar(ref x) => x,\n                     _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n@@ -118,10 +118,10 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 );\n                 OperandValue::Immediate(llval)\n             },\n-            ConstValue::ByValPair(a, b) => {\n+            ConstValue::ScalarPair(a, b) => {\n                 let (a_scalar, b_scalar) = match layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n-                    _ => bug!(\"from_const: invalid ByValPair layout: {:#?}\", layout)\n+                    _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n                 let a_llval = primval_to_llvm(\n                     bx.cx,"}, {"sha": "00884d14d33743cb8406c37a18689db44e96436b", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -183,24 +183,24 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 let s = s.as_str();\n                 let id = self.tcx.allocate_bytes(s.as_bytes());\n                 let ptr = MemoryPointer::zero(id);\n-                ConstValue::ByValPair(\n+                ConstValue::ScalarPair(\n                     Scalar::Ptr(ptr),\n                     Scalar::from_u128(s.len() as u128),\n                 )\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_bytes(data);\n                 let ptr = MemoryPointer::zero(id);\n-                ConstValue::ByVal(Scalar::Ptr(ptr))\n+                ConstValue::Scalar(Scalar::Ptr(ptr))\n             },\n-            LitKind::Byte(n) => ConstValue::ByVal(Scalar::Bytes(n as u128)),\n+            LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bytes(n as u128)),\n             LitKind::Int(n, _) if neg => {\n                 let n = n as i128;\n                 let n = n.overflowing_neg().0;\n                 let n = clamp(n as u128);\n-                ConstValue::ByVal(Scalar::Bytes(n))\n+                ConstValue::Scalar(Scalar::Bytes(n))\n             },\n-            LitKind::Int(n, _) => ConstValue::ByVal(Scalar::Bytes(clamp(n))),\n+            LitKind::Int(n, _) => ConstValue::Scalar(Scalar::Bytes(clamp(n))),\n             LitKind::Float(n, fty) => {\n                 parse_float(n, fty)\n             }\n@@ -211,8 +211,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 };\n                 parse_float(n, fty)\n             }\n-            LitKind::Bool(b) => ConstValue::ByVal(Scalar::Bytes(b as u128)),\n-            LitKind::Char(c) => ConstValue::ByVal(Scalar::Bytes(c as u128)),\n+            LitKind::Bool(b) => ConstValue::Scalar(Scalar::Bytes(b as u128)),\n+            LitKind::Char(c) => ConstValue::Scalar(Scalar::Bytes(c as u128)),\n         };\n         Literal::Value {\n             value: ty::Const::from_const_value(self.tcx, lit, ty)"}, {"sha": "96cfd1ccfc4b97214fa752ec9196e7f40eaf7296", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -1083,14 +1083,14 @@ pub fn compare_const_vals<'a, 'tcx>(\n         if let ty::TyStr = rty.sty {\n             match (a.to_byval_value(), b.to_byval_value()) {\n                 (\n-                    Some(Value::ByValPair(\n+                    Some(Value::ScalarPair(\n                         Scalar::Ptr(ptr_a),\n                         Scalar::Bits {\n                             bits: size_a,\n                             defined: tcx.data_layout.pointer_size.bits() as u8,\n                         },\n                     )),\n-                    Some(Value::ByValPair(\n+                    Some(Value::ScalarPair(\n                         Scalar::Ptr(ptr_b),\n                         Scalar::Bits {\n                             bits: size_b,\n@@ -1129,17 +1129,17 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             let s = s.as_str();\n             let id = tcx.allocate_bytes(s.as_bytes());\n             let ptr = MemoryPointer::zero(id);\n-            ConstValue::ByValPair(\n+            ConstValue::ScalarPair(\n                 Scalar::Ptr(ptr),\n                 Scalar::from_u128(s.len() as u128),\n             )\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);\n             let ptr = MemoryPointer::zero(id);\n-            ConstValue::ByVal(Scalar::Ptr(ptr))\n+            ConstValue::Scalar(Scalar::Ptr(ptr))\n         },\n-        LitKind::Byte(n) => ConstValue::ByVal(Scalar::Bytes(n as u128)),\n+        LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bytes(n as u128)),\n         LitKind::Int(n, _) => {\n             enum Int {\n                 Signed(IntTy),\n@@ -1173,7 +1173,7 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 Int::Signed(IntTy::I128)| Int::Unsigned(UintTy::U128) => n,\n                 _ => bug!(),\n             };\n-            ConstValue::ByVal(Scalar::Bytes(n))\n+            ConstValue::Scalar(Scalar::Bytes(n))\n         },\n         LitKind::Float(n, fty) => {\n             parse_float(n, fty, neg)?\n@@ -1185,8 +1185,8 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             };\n             parse_float(n, fty, neg)?\n         }\n-        LitKind::Bool(b) => ConstValue::ByVal(Scalar::Bytes(b as u128)),\n-        LitKind::Char(c) => ConstValue::ByVal(Scalar::Bytes(c as u128)),\n+        LitKind::Bool(b) => ConstValue::Scalar(Scalar::Bytes(b as u128)),\n+        LitKind::Char(c) => ConstValue::Scalar(Scalar::Bytes(c as u128)),\n     };\n     Ok(ty::Const::from_const_value(tcx, lit, ty))\n }\n@@ -1222,5 +1222,5 @@ pub fn parse_float<'tcx>(\n         }\n     };\n \n-    Ok(ConstValue::ByVal(Scalar::Bytes(bits)))\n+    Ok(ConstValue::Scalar(Scalar::Bytes(bits)))\n }"}, {"sha": "a2171eeccdd8f9c512a470911443327a33154eab", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -100,16 +100,16 @@ pub fn value_to_const_value<'tcx>(\n ) -> &'tcx ty::Const<'tcx> {\n     let layout = ecx.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap();\n     match (val, &layout.abi) {\n-        (Value::ByVal(Scalar::Undef), _) if layout.is_zst() => {},\n+        (Value::Scalar(Scalar::Undef), _) if layout.is_zst() => {},\n         (Value::ByRef(..), _) |\n-        (Value::ByVal(_), &layout::Abi::Scalar(_)) |\n-        (Value::ByValPair(..), &layout::Abi::ScalarPair(..)) => {},\n+        (Value::Scalar(_), &layout::Abi::Scalar(_)) |\n+        (Value::ScalarPair(..), &layout::Abi::ScalarPair(..)) => {},\n         _ => bug!(\"bad value/layout combo: {:#?}, {:#?}\", val, layout),\n     }\n     let val = (|| {\n         match val {\n-            Value::ByVal(val) => Ok(ConstValue::ByVal(val)),\n-            Value::ByValPair(a, b) => Ok(ConstValue::ByValPair(a, b)),\n+            Value::Scalar(val) => Ok(ConstValue::Scalar(val)),\n+            Value::ScalarPair(a, b) => Ok(ConstValue::ScalarPair(a, b)),\n             Value::ByRef(ptr, align) => {\n                 let ptr = ptr.primval.to_ptr().unwrap();\n                 let alloc = ecx.memory.get(ptr.alloc_id)?;\n@@ -419,7 +419,7 @@ pub fn const_val_field<'a, 'tcx>(\n         let layout = ecx.layout_of(ty)?;\n         let (ptr, align) = match value {\n             Value::ByRef(ptr, align) => (ptr, align),\n-            Value::ByValPair(..) | Value::ByVal(_) => {\n+            Value::ScalarPair(..) | Value::Scalar(_) => {\n                 let ptr = ecx.alloc_ptr(ty)?.into();\n                 ecx.write_value_to_ptr(value, ptr, layout.align, ty)?;\n                 (ptr, layout.align)\n@@ -436,9 +436,9 @@ pub fn const_val_field<'a, 'tcx>(\n         new_value = ecx.try_read_by_ref(new_value, layout.ty)?;\n         use rustc_data_structures::indexed_vec::Idx;\n         match (value, new_value) {\n-            (Value::ByVal(_), Value::ByRef(..)) |\n-            (Value::ByValPair(..), Value::ByRef(..)) |\n-            (Value::ByVal(_), Value::ByValPair(..)) => bug!(\n+            (Value::Scalar(_), Value::ByRef(..)) |\n+            (Value::ScalarPair(..), Value::ByRef(..)) |\n+            (Value::Scalar(_), Value::ScalarPair(..)) => bug!(\n                 \"field {} of {:?} yielded {:?}\",\n                 field.index(),\n                 value,\n@@ -469,7 +469,7 @@ pub fn const_variant_index<'a, 'tcx>(\n     let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let value = ecx.const_value_to_value(val, ty)?;\n     let (ptr, align) = match value {\n-        Value::ByValPair(..) | Value::ByVal(_) => {\n+        Value::ScalarPair(..) | Value::Scalar(_) => {\n             let layout = ecx.layout_of(ty)?;\n             let ptr = ecx.memory.allocate(layout.size, layout.align, Some(MemoryKind::Stack))?;\n             let ptr: Pointer = ptr.into();"}, {"sha": "acfa8d0dca3ecfb30cd7401e7c47107b8be216b1", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -76,7 +76,7 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n     ///\n-    /// Before being initialized, arguments are `Value::ByVal(Scalar::Undef)` and other locals are `None`.\n+    /// Before being initialized, arguments are `Value::Scalar(Scalar::Undef)` and other locals are `None`.\n     pub locals: IndexVec<mir::Local, Option<Value>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n@@ -230,7 +230,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         let ptr = self.memory.allocate_bytes(s.as_bytes());\n-        Ok(Value::ByValPair(\n+        Ok(Value::ScalarPair(\n             Scalar::Ptr(ptr),\n             Scalar::from_u128(s.len() as u128),\n         ))\n@@ -247,8 +247,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let id = self.memory.allocate_value(alloc.clone(), Some(MemoryKind::Stack))?;\n                 Ok(Value::ByRef(MemoryPointer::new(id, offset).into(), alloc.align))\n             },\n-            ConstValue::ByValPair(a, b) => Ok(Value::ByValPair(a, b)),\n-            ConstValue::ByVal(val) => Ok(Value::ByVal(val)),\n+            ConstValue::ScalarPair(a, b) => Ok(Value::ScalarPair(a, b)),\n+            ConstValue::Scalar(val) => Ok(Value::Scalar(val)),\n         }\n     }\n \n@@ -408,7 +408,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         ::log_settings::settings().indentation += 1;\n \n         let locals = if mir.local_decls.len() > 1 {\n-            let mut locals = IndexVec::from_elem(Some(Value::ByVal(Scalar::Undef)), &mir.local_decls);\n+            let mut locals = IndexVec::from_elem(Some(Value::Scalar(Scalar::Undef)), &mir.local_decls);\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n                 Some(Def::Static(..)) | Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {},\n@@ -668,19 +668,19 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             match (src.value, self.type_is_fat_ptr(dest_ty)) {\n                                 (Value::ByRef { .. }, _) |\n                                 // pointers to extern types\n-                                (Value::ByVal(_),_) |\n+                                (Value::Scalar(_),_) |\n                                 // slices and trait objects to other slices/trait objects\n-                                (Value::ByValPair(..), true) => {\n+                                (Value::ScalarPair(..), true) => {\n                                     let valty = ValTy {\n                                         value: src.value,\n                                         ty: dest_ty,\n                                     };\n                                     self.write_value(valty, dest)?;\n                                 }\n                                 // slices and trait objects to thin pointers (dropping the metadata)\n-                                (Value::ByValPair(data, _), false) => {\n+                                (Value::ScalarPair(data, _), false) => {\n                                     let valty = ValTy {\n-                                        value: Value::ByVal(data),\n+                                        value: Value::Scalar(data),\n                                         ty: dest_ty,\n                                     };\n                                     self.write_value(valty, dest)?;\n@@ -707,7 +707,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             let src_val = self.value_to_primval(src)?;\n                             let dest_val = self.cast_primval(src_val, src.ty, dest_ty)?;\n                             let valty = ValTy {\n-                                value: Value::ByVal(dest_val),\n+                                value: Value::Scalar(dest_val),\n                                 ty: dest_ty,\n                             };\n                             self.write_value(valty, dest)?;\n@@ -729,7 +729,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                 ).ok_or_else(|| EvalErrorKind::TypeckError.into());\n                                 let fn_ptr = self.memory.create_fn_alloc(instance?);\n                                 let valty = ValTy {\n-                                    value: Value::ByVal(Scalar::Ptr(fn_ptr)),\n+                                    value: Value::Scalar(Scalar::Ptr(fn_ptr)),\n                                     ty: dest_ty,\n                                 };\n                                 self.write_value(valty, dest)?;\n@@ -765,7 +765,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                 );\n                                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                                 let valty = ValTy {\n-                                    value: Value::ByVal(Scalar::Ptr(fn_ptr)),\n+                                    value: Value::Scalar(Scalar::Ptr(fn_ptr)),\n                                     ty: dest_ty,\n                                 };\n                                 self.write_value(valty, dest)?;\n@@ -1094,13 +1094,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         match self.follow_by_ref_value(value, ty)? {\n             Value::ByRef { .. } => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n-            Value::ByVal(primval) => {\n+            Value::Scalar(primval) => {\n                 // TODO: Do we really want insta-UB here?\n                 self.ensure_valid_value(primval, ty)?;\n                 Ok(primval)\n             }\n \n-            Value::ByValPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n+            Value::ScalarPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n         }\n     }\n \n@@ -1119,7 +1119,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let valty = ValTy {\n-            value: Value::ByVal(val),\n+            value: Value::Scalar(val),\n             ty: dest_ty,\n         };\n         self.write_value(valty, dest)\n@@ -1132,7 +1132,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx> {\n         //trace!(\"Writing {:?} to {:?} at type {:?}\", src_val, dest, dest_ty);\n         // Note that it is really important that the type here is the right one, and matches the type things are read at.\n-        // In case `src_val` is a `ByValPair`, we don't do any magic here to handle padding properly, which is only\n+        // In case `src_val` is a `ScalarPair`, we don't do any magic here to handle padding properly, which is only\n         // correct if we never look at this data with the wrong type.\n \n         match dest {\n@@ -1211,7 +1211,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             Value::ByRef(ptr, align) => {\n                 self.memory.copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size, false)\n             }\n-            Value::ByVal(primval) => {\n+            Value::Scalar(primval) => {\n                 let signed = match layout.abi {\n                     layout::Abi::Scalar(ref scal) => match scal.value {\n                         layout::Primitive::Int(_, signed) => signed,\n@@ -1222,11 +1222,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 };\n                 self.memory.write_primval(dest, dest_align, primval, layout.size, signed)\n             }\n-            Value::ByValPair(a_val, b_val) => {\n+            Value::ScalarPair(a_val, b_val) => {\n                 trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n                 let (a, b) = match layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\"write_value_to_ptr: invalid ByValPair layout: {:#?}\", layout)\n+                    _ => bug!(\"write_value_to_ptr: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n                 let (a_size, b_size) = (a.size(&self), b.size(&self));\n                 let a_ptr = dest;\n@@ -1405,7 +1405,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n \n     pub fn try_read_by_ref(&self, mut val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        // Convert to ByVal or ByValPair if possible\n+        // Convert to ByVal or ScalarPair if possible\n         if let Value::ByRef(ptr, align) = val {\n             if let Some(read_val) = self.try_read_value(ptr, align, ty)? {\n                 val = read_val;\n@@ -1419,7 +1419,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         self.memory.check_align(ptr, ptr_align)?;\n \n         if layout.size.bytes() == 0 {\n-            return Ok(Some(Value::ByVal(Scalar::Undef)));\n+            return Ok(Some(Value::Scalar(Scalar::Undef)));\n         }\n \n         let ptr = ptr.to_ptr()?;\n@@ -1430,7 +1430,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         match layout.abi {\n             layout::Abi::Scalar(..) => {\n                 let primval = self.memory.read_primval(ptr, ptr_align, layout.size)?;\n-                Ok(Some(Value::ByVal(primval)))\n+                Ok(Some(Value::Scalar(primval)))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n                 let (a, b) = (&a.value, &b.value);\n@@ -1440,7 +1440,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let b_ptr = ptr.offset(b_offset, self)?.into();\n                 let a_val = self.memory.read_primval(a_ptr, ptr_align, a_size)?;\n                 let b_val = self.memory.read_primval(b_ptr, ptr_align, b_size)?;\n-                Ok(Some(Value::ByValPair(a_val, b_val)))\n+                Ok(Some(Value::ScalarPair(a_val, b_val)))\n             }\n             _ => Ok(None),\n         }\n@@ -1563,7 +1563,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                 self.place_field(src_place, mir::Field::new(i), src_layout)?;\n                             (self.read_place(src_f_place)?, src_field)\n                         }\n-                        Value::ByVal(_) | Value::ByValPair(..) => {\n+                        Value::Scalar(_) | Value::ScalarPair(..) => {\n                             let src_field = src_layout.field(&self, i)?;\n                             assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n                             assert_eq!(src_field.size, src_layout.size);\n@@ -1622,13 +1622,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n                         }\n                     }\n-                    Ok(Value::ByVal(val)) => {\n+                    Ok(Value::Scalar(val)) => {\n                         write!(msg, \" {:?}\", val).unwrap();\n                         if let Scalar::Ptr(ptr) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n-                    Ok(Value::ByValPair(val1, val2)) => {\n+                    Ok(Value::ScalarPair(val1, val2)) => {\n                         write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n                         if let Scalar::Ptr(ptr) = val1 {\n                             allocs.push(ptr.alloc_id);\n@@ -1797,7 +1797,7 @@ impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n         trace!(\"{:?} is now live\", local);\n \n         // StorageLive *always* kills the value that's currently stored\n-        mem::replace(&mut self.locals[local], Some(Value::ByVal(Scalar::Undef)))\n+        mem::replace(&mut self.locals[local], Some(Value::Scalar(Scalar::Undef)))\n     }\n \n     /// Returns the old value of the local"}, {"sha": "275a3057ed470e82f7c35d6ad941284517889e62", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -932,8 +932,8 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n             Value::ByRef(ptr, align) => {\n                 self.memory().read_ptr_sized(ptr.to_ptr()?, align)?\n             }\n-            Value::ByVal(ptr) |\n-            Value::ByValPair(ptr, _) => ptr,\n+            Value::Scalar(ptr) |\n+            Value::ScalarPair(ptr, _) => ptr,\n         }.into())\n     }\n \n@@ -952,9 +952,9 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n                 Ok((ptr, vtable))\n             }\n \n-            Value::ByValPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n+            Value::ScalarPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n \n-            Value::ByVal(Scalar::Undef) => err!(ReadUndefBytes),\n+            Value::Scalar(Scalar::Undef) => err!(ReadUndefBytes),\n             _ => bug!(\"expected ptr and vtable, got {:?}\", value),\n         }\n     }\n@@ -973,13 +973,13 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n                 )?.to_bytes()? as u64;\n                 Ok((ptr, len))\n             }\n-            Value::ByValPair(ptr, val) => {\n+            Value::ScalarPair(ptr, val) => {\n                 let len = val.to_u128()?;\n                 assert_eq!(len as u64 as u128, len);\n                 Ok((ptr.into(), len as u64))\n             }\n-            Value::ByVal(Scalar::Undef) => err!(ReadUndefBytes),\n-            Value::ByVal(_) => bug!(\"expected ptr and length, got {:?}\", value),\n+            Value::Scalar(Scalar::Undef) => err!(ReadUndefBytes),\n+            Value::Scalar(_) => bug!(\"expected ptr and length, got {:?}\", value),\n         }\n     }\n }"}, {"sha": "8e8b9466596d5d5175c1f0a759801f71c2dbc917", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n-        let val = Value::ByValPair(val, Scalar::from_bool(overflowed));\n+        let val = Value::ScalarPair(val, Scalar::from_bool(overflowed));\n         let valty = ValTy {\n             value: val,\n             ty: dest_ty,"}, {"sha": "9562463e74ae2bd929b975cd585e71d9c591dec1", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -128,17 +128,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let field_index = field.index();\n         let field = base_layout.field(self, field_index)?;\n         if field.size.bytes() == 0 {\n-            return Ok(Some((Value::ByVal(Scalar::Undef), field.ty)))\n+            return Ok(Some((Value::Scalar(Scalar::Undef), field.ty)))\n         }\n         let offset = base_layout.fields.offset(field_index);\n         match base {\n             // the field covers the entire type\n-            Value::ByValPair(..) |\n-            Value::ByVal(_) if offset.bytes() == 0 && field.size == base_layout.size => Ok(Some((base, field.ty))),\n+            Value::ScalarPair(..) |\n+            Value::Scalar(_) if offset.bytes() == 0 && field.size == base_layout.size => Ok(Some((base, field.ty))),\n             // split fat pointers, 2 element tuples, ...\n-            Value::ByValPair(a, b) if base_layout.fields.count() == 2 => {\n+            Value::ScalarPair(a, b) if base_layout.fields.count() == 2 => {\n                 let val = [a, b][field_index];\n-                Ok(Some((Value::ByVal(val), field.ty)))\n+                Ok(Some((Value::Scalar(val), field.ty)))\n             },\n             // FIXME(oli-obk): figure out whether we should be calling `try_read_value` here\n             _ => Ok(None),\n@@ -173,7 +173,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         place: &mir::Place<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n         // Shortcut for things like accessing a fat pointer's field,\n-        // which would otherwise (in the `eval_place` path) require moving a `ByValPair` to memory\n+        // which would otherwise (in the `eval_place` path) require moving a `ScalarPair` to memory\n         // and returning an `Place::Ptr` to it\n         if let Some(val) = self.try_read_place(place)? {\n             return Ok(val);\n@@ -250,8 +250,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Place::Local { frame, local } => {\n                 match (&self.stack[frame].get_local(local)?, &base_layout.abi) {\n                     // in case the field covers the entire type, just return the value\n-                    (&Value::ByVal(_), &layout::Abi::Scalar(_)) |\n-                    (&Value::ByValPair(..), &layout::Abi::ScalarPair(..))\n+                    (&Value::Scalar(_), &layout::Abi::Scalar(_)) |\n+                    (&Value::ScalarPair(..), &layout::Abi::ScalarPair(..))\n                         if offset.bytes() == 0 && field.size == base_layout.size =>\n                     {\n                         return Ok((base, field));"}, {"sha": "d68cc7d10dc1e0a442603ce6924bee66c79f5513", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let instance = match ty.sty {\n             ty::TyDynamic(..) => {\n                 let vtable = match arg {\n-                    Value::ByValPair(_, Scalar::Ptr(vtable)) => vtable,\n+                    Value::ScalarPair(_, Scalar::Ptr(vtable)) => vtable,\n                     _ => bug!(\"expected fat ptr, got {:?}\", arg),\n                 };\n                 match self.read_drop_type_from_vtable(vtable)? {"}, {"sha": "ecaaa3035d7f46540a1ed43e68d91f2201cd77e2", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -359,7 +359,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                             self.write_value(valty, dest)?;\n                                         }\n                                     }\n-                                    Value::ByVal(Scalar::Undef) => {}\n+                                    Value::Scalar(Scalar::Undef) => {}\n                                     other => {\n                                         trace!(\"{:#?}, {:#?}\", other, layout);\n                                         let mut layout = layout;"}, {"sha": "ee29accd1f7025333c73fa566a9af5f98201c621", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -67,8 +67,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let pointer_align = self.tcx.data_layout.pointer_align;\n         match self.read_ptr(vtable, pointer_align, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n-            Value::ByVal(Scalar::Bytes(0)) => Ok(None),\n-            Value::ByVal(Scalar::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n+            Value::Scalar(Scalar::Bytes(0)) => Ok(None),\n+            Value::Scalar(Scalar::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n             _ => err!(ReadBytesAsPointer),\n         }\n     }"}, {"sha": "a8a50e14c68225788edd9876d45513015c9ee4f4", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -1245,13 +1245,13 @@ fn collect_const<'a, 'tcx>(\n     };\n     match val {\n         ConstVal::Unevaluated(..) => bug!(\"const eval yielded unevaluated const\"),\n-        ConstVal::Value(ConstValue::ByValPair(Scalar::Ptr(a), Scalar::Ptr(b))) => {\n+        ConstVal::Value(ConstValue::ScalarPair(Scalar::Ptr(a), Scalar::Ptr(b))) => {\n             collect_miri(tcx, a.alloc_id, output);\n             collect_miri(tcx, b.alloc_id, output);\n         }\n-        ConstVal::Value(ConstValue::ByValPair(_, Scalar::Ptr(ptr))) |\n-        ConstVal::Value(ConstValue::ByValPair(Scalar::Ptr(ptr), _)) |\n-        ConstVal::Value(ConstValue::ByVal(Scalar::Ptr(ptr))) =>\n+        ConstVal::Value(ConstValue::ScalarPair(_, Scalar::Ptr(ptr))) |\n+        ConstVal::Value(ConstValue::ScalarPair(Scalar::Ptr(ptr), _)) |\n+        ConstVal::Value(ConstValue::Scalar(Scalar::Ptr(ptr))) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n         ConstVal::Value(ConstValue::ByRef(alloc, _offset)) => {\n             for &id in alloc.relocations.values() {"}, {"sha": "82979284b11df76a88e9efe0c706bc982ba29beb", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2177cffc66abdffad4b09a093239a8ba22e434/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ef2177cffc66abdffad4b09a093239a8ba22e434", "patch": "@@ -215,7 +215,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     trace!(\"field proj on {:?}\", proj.base);\n                     let (base, ty, span) = self.eval_place(&proj.base)?;\n                     match base {\n-                        Value::ByValPair(a, b) => {\n+                        Value::ScalarPair(a, b) => {\n                             trace!(\"by val pair: {:?}, {:?}\", a, b);\n                             let base_layout = self.tcx.layout_of(self.param_env.and(ty)).ok()?;\n                             trace!(\"layout computed\");\n@@ -228,7 +228,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                             };\n                             let field = base_layout.field(cx, field_index).ok()?;\n                             trace!(\"projection resulted in: {:?}\", val);\n-                            Some((Value::ByVal(val), field.ty, span))\n+                            Some((Value::Scalar(val), field.ty, span))\n                         },\n                         _ => None,\n                     }\n@@ -283,7 +283,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 let param_env = self.tcx.param_env(self.source.def_id);\n                 type_size_of(self.tcx, param_env, ty).map(|n| (\n-                    Value::ByVal(Scalar::Bytes(n as u128)),\n+                    Value::Scalar(Scalar::Bytes(n as u128)),\n                     self.tcx.types.usize,\n                     span,\n                 ))\n@@ -305,7 +305,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     this.ecx.value_to_primval(ValTy { value: val.0, ty: val.1 })\n                 })?;\n                 let val = self.use_ecx(span, |this| this.ecx.unary_op(op, prim, val.1))?;\n-                Some((Value::ByVal(val), place_ty, span))\n+                Some((Value::Scalar(val), place_ty, span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -357,7 +357,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     this.ecx.binary_op(op, l, left.1, r, right.1)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n-                    Value::ByValPair(\n+                    Value::ScalarPair(\n                         val,\n                         Scalar::from_bool(overflow),\n                     )\n@@ -371,7 +371,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                         });\n                         return None;\n                     }\n-                    Value::ByVal(val)\n+                    Value::Scalar(val)\n                 };\n                 Some((val, place_ty, span))\n             },\n@@ -485,7 +485,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n             if let Some(value) = self.eval_operand(cond) {\n                 trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                if Value::ByVal(Scalar::from_bool(*expected)) != value.0 {\n+                if Value::Scalar(Scalar::from_bool(*expected)) != value.0 {\n                     // poison all places this operand references so that further code\n                     // doesn't use the invalid value\n                     match cond {\n@@ -520,14 +520,14 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         BoundsCheck { ref len, ref index } => {\n                             let len = self.eval_operand(len).expect(\"len must be const\");\n                             let len = match len.0 {\n-                                Value::ByVal(Scalar::Bytes(n)) => n,\n+                                Value::Scalar(Scalar::Bytes(n)) => n,\n                                 _ => bug!(\"const len not primitive: {:?}\", len),\n                             };\n                             let index = self\n                                 .eval_operand(index)\n                                 .expect(\"index must be const\");\n                             let index = match index.0 {\n-                                Value::ByVal(Scalar::Bytes(n)) => n,\n+                                Value::Scalar(Scalar::Bytes(n)) => n,\n                                 _ => bug!(\"const index not primitive: {:?}\", index),\n                             };\n                             format!("}]}