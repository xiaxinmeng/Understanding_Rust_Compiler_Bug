{"sha": "df9342aa6f426bd786cf390110321338a6624e40", "node_id": "C_kwDOAAsO6NoAKGRmOTM0MmFhNmY0MjZiZDc4NmNmMzkwMTEwMzIxMzM4YTY2MjRlNDA", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-11T17:41:20Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-14T16:26:11Z"}, "message": "Remove from cranelift too.", "tree": {"sha": "b3fdddb6174745b6a27de5d61a67be445cb99bf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3fdddb6174745b6a27de5d61a67be445cb99bf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df9342aa6f426bd786cf390110321338a6624e40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df9342aa6f426bd786cf390110321338a6624e40", "html_url": "https://github.com/rust-lang/rust/commit/df9342aa6f426bd786cf390110321338a6624e40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df9342aa6f426bd786cf390110321338a6624e40/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "194497a1a1b7dcf663aa86e385598afe2662ddb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/194497a1a1b7dcf663aa86e385598afe2662ddb7", "html_url": "https://github.com/rust-lang/rust/commit/194497a1a1b7dcf663aa86e385598afe2662ddb7"}], "stats": {"total": 89, "additions": 0, "deletions": 89}, "files": [{"sha": "670384663e83faba8801495a6bf76d49fe8af9d1", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/df9342aa6f426bd786cf390110321338a6624e40/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9342aa6f426bd786cf390110321338a6624e40/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=df9342aa6f426bd786cf390110321338a6624e40", "patch": "@@ -103,7 +103,6 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n         }\n     };\n \n-    let cast_to_size = dest_layout.layout.size();\n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n \n     // Read the tag/niche-encoded discriminant from memory.\n@@ -122,21 +121,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             dest.write_cvalue(fx, res);\n         }\n         TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-            let tag_size = tag_scalar.size(fx);\n-            let max_unsigned = tag_size.unsigned_int_max();\n-            let max_signed = tag_size.signed_int_max() as u128;\n-            let min_signed = max_signed + 1;\n             let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-            let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n-            let range = tag_scalar.valid_range(fx);\n-\n-            let sle = |lhs: u128, rhs: u128| -> bool {\n-                // Signed and unsigned comparisons give the same results,\n-                // except that in signed comparisons an integer with the\n-                // sign bit set is less than one with the sign bit clear.\n-                // Toggle the sign bit to do a signed comparison.\n-                (lhs ^ min_signed) <= (rhs ^ min_signed)\n-            };\n \n             // We have a subrange `niche_start..=niche_end` inside `range`.\n             // If the value of the tag is inside this subrange, it's a\n@@ -153,45 +138,6 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             // }\n             // However, we will likely be able to emit simpler code.\n \n-            // Find the least and greatest values in `range`, considered\n-            // both as signed and unsigned.\n-            let (low_unsigned, high_unsigned) =\n-                if range.start <= range.end { (range.start, range.end) } else { (0, max_unsigned) };\n-            let (low_signed, high_signed) = if sle(range.start, range.end) {\n-                (range.start, range.end)\n-            } else {\n-                (min_signed, max_signed)\n-            };\n-\n-            let niches_ule = niche_start <= niche_end;\n-            let niches_sle = sle(niche_start, niche_end);\n-            let cast_smaller = cast_to_size <= tag_size;\n-\n-            // In the algorithm above, we can change\n-            // cast(relative_tag) + niche_variants.start()\n-            // into\n-            // cast(tag + (niche_variants.start() - niche_start))\n-            // if either the casted type is no larger than the original\n-            // type, or if the niche values are contiguous (in either the\n-            // signed or unsigned sense).\n-            let can_incr = cast_smaller || niches_ule || niches_sle;\n-\n-            let data_for_boundary_niche = || -> Option<(IntCC, u128)> {\n-                if !can_incr {\n-                    None\n-                } else if niche_start == low_unsigned {\n-                    Some((IntCC::UnsignedLessThanOrEqual, niche_end))\n-                } else if niche_end == high_unsigned {\n-                    Some((IntCC::UnsignedGreaterThanOrEqual, niche_start))\n-                } else if niche_start == low_signed {\n-                    Some((IntCC::SignedLessThanOrEqual, niche_end))\n-                } else if niche_end == high_signed {\n-                    Some((IntCC::SignedGreaterThanOrEqual, niche_start))\n-                } else {\n-                    None\n-                }\n-            };\n-\n             let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n                 // Best case scenario: only one tagged variant. This will\n                 // likely become just a comparison and a jump.\n@@ -206,41 +152,6 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 let tagged_discr =\n                     fx.bcx.ins().iconst(cast_to, niche_variants.start().as_u32() as i64);\n                 (is_niche, tagged_discr, 0)\n-            } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n-                // The niche values are either the lowest or the highest in\n-                // `range`. We can avoid the first subtraction in the\n-                // algorithm.\n-                // The algorithm is now this:\n-                // is_niche = tag <= niche_end\n-                // discr = if is_niche {\n-                //     cast(tag + (niche_variants.start() - niche_start))\n-                // } else {\n-                //     untagged_variant\n-                // }\n-                // (the first line may instead be tag >= niche_start,\n-                // and may be a signed or unsigned comparison)\n-                // The arithmetic must be done before the cast, so we can\n-                // have the correct wrapping behavior. See issue #104519 for\n-                // the consequences of getting this wrong.\n-                let is_niche = codegen_icmp_imm(fx, predicate, tag, constant as i128);\n-                let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n-                let incr_tag = if delta == 0 {\n-                    tag\n-                } else {\n-                    let delta = match fx.bcx.func.dfg.value_type(tag) {\n-                        types::I128 => {\n-                            let lsb = fx.bcx.ins().iconst(types::I64, delta as u64 as i64);\n-                            let msb = fx.bcx.ins().iconst(types::I64, (delta >> 64) as u64 as i64);\n-                            fx.bcx.ins().iconcat(lsb, msb)\n-                        }\n-                        ty => fx.bcx.ins().iconst(ty, delta as i64),\n-                    };\n-                    fx.bcx.ins().iadd(tag, delta)\n-                };\n-\n-                let cast_tag = clif_intcast(fx, incr_tag, cast_to, !niches_ule);\n-\n-                (is_niche, cast_tag, 0)\n             } else {\n                 // The special cases don't apply, so we'll have to go with\n                 // the general algorithm."}]}