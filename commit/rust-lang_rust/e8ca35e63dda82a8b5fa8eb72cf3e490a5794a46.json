{"sha": "e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4Y2EzNWU2M2RkYTgyYThiNWZhOGViNzJjZjNlNDkwYTU3OTRhNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-28T02:54:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-28T02:54:14Z"}, "message": "Auto merge of #57155 - petrochenkov:dcrate3, r=dtolnay\n\nResolve `$crate`s for pretty-printing at more appropriate time\n\nDoing it in `BuildReducedGraphVisitor` wasn't a good idea, identifiers wasn't actually visited half of the time.\nAs a result some `$crate`s weren't resolved and were therefore pretty-printed as `$crate` literally, which turns into two tokens during re-parsing of the pretty-printed text.\n\nNow we are visiting and resolving `$crate` identifiers in an item right before sending that item to a proc macro attribute or derive.\n\nFixes https://github.com/rust-lang/rust/issues/57089", "tree": {"sha": "190e1b7ce725d1fdfaf44e49c34a9465d558ac0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/190e1b7ce725d1fdfaf44e49c34a9465d558ac0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46", "html_url": "https://github.com/rust-lang/rust/commit/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8caa321c7c7214a6c5415e4b3694e65b4ff73a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8caa321c7c7214a6c5415e4b3694e65b4ff73a7", "html_url": "https://github.com/rust-lang/rust/commit/f8caa321c7c7214a6c5415e4b3694e65b4ff73a7"}, {"sha": "e40d7d9643b810b2bc62f279e1d6f4ad68a35bc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e40d7d9643b810b2bc62f279e1d6f4ad68a35bc2", "html_url": "https://github.com/rust-lang/rust/commit/e40d7d9643b810b2bc62f279e1d6f4ad68a35bc2"}], "stats": {"total": 167, "additions": 154, "deletions": 13}, "files": [{"sha": "21fb29974c8800b7f7e0c7f84adb0ef431fb6416", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46", "patch": "@@ -1025,15 +1025,4 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         }\n         visit::walk_attribute(self, attr);\n     }\n-\n-    fn visit_ident(&mut self, ident: Ident) {\n-        if ident.name == keywords::DollarCrate.name() {\n-            let name = match self.resolver.resolve_crate_root(ident).kind {\n-                ModuleKind::Def(_, name) if name != keywords::Invalid.name() => name,\n-                _ => keywords::Crate.name(),\n-            };\n-            ident.span.ctxt().set_dollar_crate_name(name);\n-        }\n-        visit::walk_ident(self, ident);\n-    }\n }"}, {"sha": "5f6ef934c1aa340f8ae555f1bad2345027ff1e30", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46", "patch": "@@ -1,6 +1,6 @@\n use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n use {CrateLint, Resolver, ResolutionError, ScopeSet, Weak};\n-use {Module, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n use {is_known_tool, resolve_error};\n use ModuleOrUniformRoot;\n use Namespace::*;\n@@ -15,12 +15,13 @@ use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy};\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::ext::base::{Annotatable, MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, Mark};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{feature_err, is_builtin_attr_name, GateIssue};\n use syntax::symbol::{Symbol, keywords};\n+use syntax::visit::Visitor;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n use errors::Applicability;\n@@ -126,6 +127,26 @@ impl<'a> base::Resolver for Resolver<'a> {\n         mark\n     }\n \n+    fn resolve_dollar_crates(&mut self, annotatable: &Annotatable) {\n+        pub struct ResolveDollarCrates<'a, 'b: 'a> {\n+            pub resolver: &'a mut Resolver<'b>,\n+        }\n+        impl<'a> Visitor<'a> for ResolveDollarCrates<'a, '_> {\n+            fn visit_ident(&mut self, ident: Ident) {\n+                if ident.name == keywords::DollarCrate.name() {\n+                    let name = match self.resolver.resolve_crate_root(ident).kind {\n+                        ModuleKind::Def(_, name) if name != keywords::Invalid.name() => name,\n+                        _ => keywords::Crate.name(),\n+                    };\n+                    ident.span.ctxt().set_dollar_crate_name(name);\n+                }\n+            }\n+            fn visit_mac(&mut self, _: &ast::Mac) {}\n+        }\n+\n+        annotatable.visit_with(&mut ResolveDollarCrates { resolver: self });\n+    }\n+\n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n                                             derives: &[Mark]) {\n         let invocation = self.invocations[&mark];"}, {"sha": "7e8b7007b22895d65dbf053ad3c5dac3fa1ee8ae", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46", "patch": "@@ -14,6 +14,7 @@ use parse::token;\n use ptr::P;\n use smallvec::SmallVec;\n use symbol::{keywords, Ident, Symbol};\n+use visit::Visitor;\n use ThinVec;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -135,6 +136,17 @@ impl Annotatable {\n             _ => false,\n         }\n     }\n+\n+    pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n+        match self {\n+            Annotatable::Item(item) => visitor.visit_item(item),\n+            Annotatable::TraitItem(trait_item) => visitor.visit_trait_item(trait_item),\n+            Annotatable::ImplItem(impl_item) => visitor.visit_impl_item(impl_item),\n+            Annotatable::ForeignItem(foreign_item) => visitor.visit_foreign_item(foreign_item),\n+            Annotatable::Stmt(stmt) => visitor.visit_stmt(stmt),\n+            Annotatable::Expr(expr) => visitor.visit_expr(expr),\n+        }\n+    }\n }\n \n // A more flexible ItemDecorator.\n@@ -730,6 +742,7 @@ pub trait Resolver {\n     fn next_node_id(&mut self) -> ast::NodeId;\n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark;\n \n+    fn resolve_dollar_crates(&mut self, annotatable: &Annotatable);\n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n                                             derives: &[Mark]);\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n@@ -763,6 +776,7 @@ impl Resolver for DummyResolver {\n     fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n     fn get_module_scope(&mut self, _id: ast::NodeId) -> Mark { Mark::root() }\n \n+    fn resolve_dollar_crates(&mut self, _annotatable: &Annotatable) {}\n     fn visit_ast_fragment_with_placeholders(&mut self, _invoc: Mark, _fragment: &AstFragment,\n                                             _derives: &[Mark]) {}\n     fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}"}, {"sha": "9369e66cf83da7368010c9a576da19a2f3d75835", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46", "patch": "@@ -574,6 +574,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             AttrProcMacro(ref mac, ..) => {\n+                // Resolve `$crate`s in case we have to go though stringification.\n+                self.cx.resolver.resolve_dollar_crates(&item);\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n                 let item_tok = TokenTree::Token(DUMMY_SP, Token::interpolated(match item {\n                     Annotatable::Item(item) => token::NtItem(item),\n@@ -915,6 +917,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         match *ext {\n             ProcMacroDerive(ref ext, ..) => {\n+                // Resolve `$crate`s in case we have to go though stringification.\n+                self.cx.resolver.resolve_dollar_crates(&item);\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this"}, {"sha": "c5347d2e81a6b3401df6cc795cd91978f27755b2", "filename": "src/test/ui/proc-macro/auxiliary/dollar-crate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate.rs?ref=e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46", "patch": "@@ -6,6 +6,13 @@\n extern crate proc_macro;\n use proc_macro::TokenStream;\n \n+#[proc_macro]\n+pub fn m_empty(input: TokenStream) -> TokenStream {\n+    println!(\"PROC MACRO INPUT (PRETTY-PRINTED): {}\", input);\n+    println!(\"PROC MACRO INPUT: {:#?}\", input);\n+    TokenStream::new()\n+}\n+\n #[proc_macro]\n pub fn m(input: TokenStream) -> TokenStream {\n     println!(\"PROC MACRO INPUT (PRETTY-PRINTED): {}\", input);"}, {"sha": "2d54c07ff95309fba007bd0cbbc68c3649befb9f", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.rs?ref=e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46", "patch": "@@ -0,0 +1,26 @@\n+// compile-pass\n+// edition:2018\n+// aux-build:dollar-crate.rs\n+\n+// Anonymize unstable non-dummy spans while still showing dummy spans `0..0`.\n+// normalize-stdout-test \"bytes\\([^0]\\w*\\.\\.(\\w+)\\)\" -> \"bytes(LO..$1)\"\n+// normalize-stdout-test \"bytes\\((\\w+)\\.\\.[^0]\\w*\\)\" -> \"bytes($1..HI)\"\n+\n+extern crate dollar_crate;\n+\n+type S = u8;\n+\n+macro_rules! m {\n+    () => {\n+        dollar_crate::m_empty! {\n+            struct M($crate::S);\n+        }\n+\n+        #[dollar_crate::a]\n+        struct A($crate::S);\n+    };\n+}\n+\n+m!();\n+\n+fn main() {}"}, {"sha": "09340988c8968875bae40ec80e63221e592a89e4", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.stdout", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout?ref=e8ca35e63dda82a8b5fa8eb72cf3e490a5794a46", "patch": "@@ -0,0 +1,80 @@\n+PROC MACRO INPUT (PRETTY-PRINTED): struct M ( $crate :: S ) ;\n+PROC MACRO INPUT: TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: #2 bytes(LO..HI)\n+    },\n+    Ident {\n+        ident: \"M\",\n+        span: #2 bytes(LO..HI)\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"$crate\",\n+                span: #2 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Joint,\n+                span: #2 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: #2 bytes(LO..HI)\n+            },\n+            Ident {\n+                ident: \"S\",\n+                span: #2 bytes(LO..HI)\n+            }\n+        ],\n+        span: #2 bytes(LO..HI)\n+    },\n+    Punct {\n+        ch: ';',\n+        spacing: Alone,\n+        span: #2 bytes(LO..HI)\n+    }\n+]\n+ATTRIBUTE INPUT (PRETTY-PRINTED): struct A(crate::S);\n+ATTRIBUTE INPUT: TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: #2 bytes(LO..HI)\n+    },\n+    Ident {\n+        ident: \"A\",\n+        span: #2 bytes(LO..HI)\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"$crate\",\n+                span: #2 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Joint,\n+                span: #2 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: #2 bytes(LO..HI)\n+            },\n+            Ident {\n+                ident: \"S\",\n+                span: #2 bytes(LO..HI)\n+            }\n+        ],\n+        span: #2 bytes(LO..HI)\n+    },\n+    Punct {\n+        ch: ';',\n+        spacing: Alone,\n+        span: #2 bytes(LO..HI)\n+    }\n+]"}]}