{"sha": "704210ef7c691a797a11cc4be20fb72ccc69108c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNDIxMGVmN2M2OTFhNzk3YTExY2M0YmUyMGZiNzJjY2M2OTEwOGM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-20T00:31:42Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-20T00:31:42Z"}, "message": "Typos, section 5", "tree": {"sha": "f7d7b233c3bd5336ba71fbf449ede4a8261a59b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7d7b233c3bd5336ba71fbf449ede4a8261a59b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/704210ef7c691a797a11cc4be20fb72ccc69108c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/704210ef7c691a797a11cc4be20fb72ccc69108c", "html_url": "https://github.com/rust-lang/rust/commit/704210ef7c691a797a11cc4be20fb72ccc69108c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/704210ef7c691a797a11cc4be20fb72ccc69108c/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb54979b39cf143879ee68917c6ddbae7448ba4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb54979b39cf143879ee68917c6ddbae7448ba4b", "html_url": "https://github.com/rust-lang/rust/commit/bb54979b39cf143879ee68917c6ddbae7448ba4b"}], "stats": {"total": 39, "additions": 20, "deletions": 19}, "files": [{"sha": "d694f266125a0da88007ae0245b4f69973fb1368", "filename": "doc/rust.md", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/704210ef7c691a797a11cc4be20fb72ccc69108c/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/704210ef7c691a797a11cc4be20fb72ccc69108c/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=704210ef7c691a797a11cc4be20fb72ccc69108c", "patch": "@@ -589,7 +589,7 @@ item : mod_item | fn_item | type_item | enum_item\n ~~~~~~~~\n \n An _item_ is a component of a crate; some module items can be defined in\n-[crate files](#crate-files) but most are defined in [source\n+[crate files](#crate-files), but most are defined in [source\n files](#source-files). Items are organized within a crate by a nested set of\n [modules](#modules). Every crate has a single \"outermost\" anonymous module;\n all further items within the crate have [paths](#paths) within the module tree\n@@ -603,7 +603,7 @@ There are several kinds of item:\n   * [modules](#modules)\n   * [functions](#functions)\n   * [type definitions](#type-definitions)\n-  * [eunmerations](#enumerations)\n+  * [enumerations](#enumerations)\n   * [resources](#resources)\n   * [interfaces](#interfaces)\n   * [implementations](#implementations)\n@@ -724,9 +724,9 @@ An _import declaration_ creates one or more local name bindings synonymous\n with some other [path](#paths). Usually an import declaration is used to\n shorten the path required to refer to a module item.\n \n-*Note*: unlike many languages, Rust's `import` declarations do not* declare\n-*linkage-dependency with external crates. Linkage dependencies are\n-*independently declared with [`use` declarations](#use -eclarations).\n+*Note*: unlike many languages, Rust's `import` declarations do *not* declare\n+linkage-dependency with external crates. Linkage dependencies are\n+independently declared with [`use` declarations](#use-declarations).\n \n Imports support a number of \"convenience\" notations:\n \n@@ -826,7 +826,7 @@ function passes results back to the caller.\n A function may also be copied into a first class *value*, in which case the\n value has the corresponding [*function type*](#function-types), and can be\n used otherwise exactly as a function item (with a minor additional cost of\n-calling the function, as such a call is indirect).\n+calling the function indirectly).\n \n Every control path in a function logically ends with a `ret` expression or a\n diverging expression. If the outermost block of a function has a\n@@ -914,7 +914,7 @@ pure fn nonempty_list<T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n ~~~~\n \n In this example, `nonempty_list` is a predicate---it can be used in a\n-typestate constraint---but the auxiliary function `pure_length`@ is\n+typestate constraint---but the auxiliary function `pure_length` is\n not.\n \n *ToDo:* should actually define referential transparency.\n@@ -1011,7 +1011,7 @@ specific type; the type-specified aspects of a value include:\n * The sequence of memory operations required to access the value.\n * The *kind* of the type (pinned, unique or shared).\n \n-For example, the type `{x: u8, y: u8@`} defines the set of immutable values\n+For example, the type `{x: u8, y: u8`} defines the set of immutable values\n that are composite records, each containing two unsigned 8-bit integers\n accessed through the components `x` and `y`, and laid out in memory with the\n `x` component preceding the `y` component.\n@@ -1033,7 +1033,7 @@ type the constructor is a member of. Such recursion has restrictions:\n   values](#box-types) (in order to bound the in-memory size of the\n   constructor).\n * Recursive type definitions can cross module boundaries, but not module\n-  *visibility* boundaries, nor crate boundaries (in order to simplify the\n+  *visibility* boundaries or crate boundaries (in order to simplify the\n   module system).\n \n \n@@ -1073,11 +1073,11 @@ resource file_descriptor(fd: int) {\n \n Calling the `file_descriptor` constructor function on an integer will\n produce a value with the `file_descriptor` type. Resource types have a\n-noncopyable [type kind](#type-kinds), and thus may not be copied. It\n-is guaranteed, barring drastic program termination that somehow\n-prevents unwinding from taking place, that for each constucted\n-resource value, the destructor will run once, when the value is\n-disposed of. For stack-allocated values, this happens when the value\n+noncopyable [type kind](#type-kinds), and thus may not be copied. The\n+semantics guarantee that for each constructed resources value, the\n+destructor will run once: when the value is disposed of (barring\n+drastic program termination that somehow prevents unwinding from taking\n+place). For stack-allocated values, disposal happens when the value\n goes out of scope. For values in shared boxes, it happens when the\n reference count of the box reaches zero.\n \n@@ -1165,9 +1165,9 @@ impl circle_shape of shape for circle {\n This defines an implementation named `circle_shape` of interface\n `shape` for type `circle`. The name of the implementation is the name\n by which it is imported and exported, but has no further significance.\n-It may be left off to default to the name of the interface that was\n+It may be omitted to default to the name of the interface that was\n implemented. Implementation names do not conflict the way other names\n-do\u2014multiple implementations with the same name may exist in a scope at\n+do: multiple implementations with the same name may exist in a scope at\n the same time.\n \n It is possible to define an implementation without referencing an\n@@ -1250,13 +1250,14 @@ fn add(x: int, y: int) { x + y }\n ~~~~~~~~\n \n In future versions of Rust, user-provided extensions to the compiler will be\n-able to interpret attributes. When this facility is provided, a distinction\n-will be made between language-reserved and user-available attributes.\n+able to interpret attributes. When this facility is provided, the compiler\n+will distinguish will be made between language-reserved and user-available\n+attributes.\n \n At present, only the Rust compiler interprets attributes, so all attribute\n names are effectively reserved. Some significant attributes include:\n \n-* The `doc` attribute, for documenting code where it's written.\n+* The `doc` attribute, for documenting code in-place.\n * The `cfg` attribute, for conditional-compilation by build-configuration.\n * The `link` attribute, for describing linkage metadata for a crate.\n * The `test` attribute, for marking functions as unit tests."}]}