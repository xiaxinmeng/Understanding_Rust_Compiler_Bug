{"sha": "31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "node_id": "C_kwDOAAsO6NoAKDMxNjU2ZTcyOTVlYmQ1ZjJmNjU5N2YxMGMwMTFlMmFjNGJhM2VmMzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-17T16:39:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-17T16:39:01Z"}, "message": "Auto merge of #110458 - matthiaskrgr:rollup-1xcxmgc, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #104055 (Migrate diagnostics in `rustc_borrowck`)\n - #110257 (fix false positives for `unused_parens` around unary and binary operations)\n - #110313 (allow `repr(align = x)` on inherent methods)\n - #110337 (Correct default value for default-linker-libraries)\n - #110386 (Clean up traversal macros)\n - #110394 (Various minor Idx-related tweaks)\n - #110425 (Encode def span for `ConstParam`)\n - #110434 (Check freeze with right param-env in `deduced_param_attrs`)\n - #110455 (tests: adapt for LLVM change 5b386b864c7619897c51a1da97d78f1cf6f3eff6)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "71b777fef0884cdd3f05a9b9188fafe427f8cabe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71b777fef0884cdd3f05a9b9188fafe427f8cabe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "html_url": "https://github.com/rust-lang/rust/commit/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e49122fb1ca87a6c3e3c22abb315fc75cfe8daed", "url": "https://api.github.com/repos/rust-lang/rust/commits/e49122fb1ca87a6c3e3c22abb315fc75cfe8daed", "html_url": "https://github.com/rust-lang/rust/commit/e49122fb1ca87a6c3e3c22abb315fc75cfe8daed"}, {"sha": "c81e8b8e18253881334e4f4ca7a707c8eccbb905", "url": "https://api.github.com/repos/rust-lang/rust/commits/c81e8b8e18253881334e4f4ca7a707c8eccbb905", "html_url": "https://github.com/rust-lang/rust/commit/c81e8b8e18253881334e4f4ca7a707c8eccbb905"}], "stats": {"total": 1542, "additions": 973, "deletions": 569}, "files": [{"sha": "2b01aca2ee4824a6d1599a96d3ed186ae0f82096", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -461,8 +461,8 @@ pub trait LayoutCalculator {\n             let all_indices = variants.indices();\n             let needs_disc =\n                 |index: VariantIdx| index != largest_variant_index && !absent(&variants[index]);\n-            let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap().index()\n-                ..=all_indices.rev().find(|v| needs_disc(*v)).unwrap().index();\n+            let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap()\n+                ..=all_indices.rev().find(|v| needs_disc(*v)).unwrap();\n \n             let count = niche_variants.size_hint().1.unwrap() as u128;\n \n@@ -560,8 +560,7 @@ pub trait LayoutCalculator {\n                     tag: niche_scalar,\n                     tag_encoding: TagEncoding::Niche {\n                         untagged_variant: largest_variant_index,\n-                        niche_variants: (VariantIdx::new(*niche_variants.start())\n-                            ..=VariantIdx::new(*niche_variants.end())),\n+                        niche_variants,\n                         niche_start,\n                     },\n                     tag_field: 0,"}, {"sha": "402ea6ff48ffdd52db004a2bb8df587ba738f3d9", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -11,7 +11,7 @@ use bitflags::bitflags;\n use rustc_data_structures::intern::Interned;\n #[cfg(feature = \"nightly\")]\n use rustc_data_structures::stable_hasher::StableOrd;\n-use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n+use rustc_index::vec::{IndexSlice, IndexVec};\n #[cfg(feature = \"nightly\")]\n use rustc_macros::HashStable_Generic;\n #[cfg(feature = \"nightly\")]"}, {"sha": "d16741757d1f1e03f8882021f36c4aef39ba2ece", "filename": "compiler/rustc_ast/src/node_id.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -9,14 +9,14 @@ rustc_index::newtype_index! {\n     ///\n     /// [`DefId`]: rustc_span::def_id::DefId\n     #[debug_format = \"NodeId({})\"]\n-    pub struct NodeId {}\n+    pub struct NodeId {\n+        /// The [`NodeId`] used to represent the root of the crate.\n+        const CRATE_NODE_ID = 0;\n+    }\n }\n \n rustc_data_structures::define_id_collections!(NodeMap, NodeSet, NodeMapEntry, NodeId);\n \n-/// The [`NodeId`] used to represent the root of the crate.\n-pub const CRATE_NODE_ID: NodeId = NodeId::from_u32(0);\n-\n /// When parsing and at the beginning of doing expansions, we initially give all AST nodes\n /// this dummy AST [`NodeId`]. Then, during a later phase of expansion, we renumber them\n /// to have small, positive IDs."}, {"sha": "0b8123c970360abd9b10b51c6cec907d23e46f15", "filename": "compiler/rustc_borrowck/messages.ftl", "status": "modified", "additions": 138, "deletions": 12, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fmessages.ftl?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -56,18 +56,6 @@ borrowck_returned_lifetime_short =\n borrowck_used_impl_require_static =\n     the used `impl` has a `'static` requirement\n \n-borrowck_capture_kind_label =\n-    capture is {$kind_desc} because of use here\n-\n-borrowck_var_borrow_by_use_place_in_generator =\n-    borrow occurs due to use of {$place} in closure in generator\n-\n-borrowck_var_borrow_by_use_place_in_closure =\n-    borrow occurs due to use of {$place} in closure\n-\n-borrowck_var_borrow_by_use_place =\n-    borrow occurs due to use of {$place}\n-\n borrowck_borrow_due_to_use_generator =\n     borrow occurs due to use in generator\n \n@@ -101,12 +89,63 @@ borrowck_capture_mut =\n borrowck_capture_move =\n     capture is moved because of use here\n \n+borrowck_var_borrow_by_use_place_in_generator =\n+    {$is_single_var ->\n+        *[true] borrow occurs\n+        [false] borrows occur\n+    } due to use of {$place} in generator\n+\n+borrowck_var_borrow_by_use_place_in_closure =\n+    {$is_single_var ->\n+        *[true] borrow occurs\n+        [false] borrows occur\n+    } due to use of {$place} in closure\n+\n+borrowck_var_borrow_by_use_in_generator =\n+    borrow occurs due to use in generator\n+\n+borrowck_var_borrow_by_use_in_closure =\n+    borrow occurs due to use in closure\n+\n borrowck_var_move_by_use_place_in_generator =\n     move occurs due to use of {$place} in generator\n \n borrowck_var_move_by_use_place_in_closure =\n     move occurs due to use of {$place} in closure\n \n+borrowck_var_move_by_use_in_generator =\n+    move occurs due to use in generator\n+\n+borrowck_var_move_by_use_in_closure =\n+    move occurs due to use in closure\n+\n+borrowck_partial_var_move_by_use_in_generator =\n+    variable {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to use in generator\n+\n+borrowck_partial_var_move_by_use_in_closure =\n+    variable {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to use in closure\n+\n+borrowck_var_first_borrow_by_use_place_in_generator =\n+    first borrow occurs due to use of {$place} in generator\n+\n+borrowck_var_first_borrow_by_use_place_in_closure =\n+    first borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_second_borrow_by_use_place_in_generator =\n+    second borrow occurs due to use of {$place} in generator\n+\n+borrowck_var_second_borrow_by_use_place_in_closure =\n+    second borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_mutable_borrow_by_use_place_in_closure =\n+    mutable borrow occurs due to use of {$place} in closure\n+\n borrowck_cannot_move_when_borrowed =\n     cannot move out of {$place ->\n         [value] value\n@@ -127,3 +166,90 @@ borrowck_opaque_type_non_generic_param =\n         [true] cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n         *[other] this generic parameter must be used with a generic {$kind} parameter\n     }\n+\n+borrowck_moved_due_to_call =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to this {$is_loop_message ->\n+        [true] call, in previous iteration of loop\n+        *[false] call\n+    }\n+\n+borrowck_moved_due_to_usage_in_operator =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to usage in {$is_loop_message ->\n+        [true] operator, in previous iteration of loop\n+        *[false] operator\n+    }\n+\n+borrowck_moved_due_to_implicit_into_iter_call =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to this implicit call to {$is_loop_message ->\n+        [true] `.into_iter()`, in previous iteration of loop\n+        *[false] `.into_iter()`\n+    }\n+\n+borrowck_moved_due_to_method_call =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to this method {$is_loop_message ->\n+        [true] call, in previous iteration of loop\n+        *[false] call\n+    }\n+\n+borrowck_value_moved_here =\n+    value {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } {$is_move_msg ->\n+        [true] into closure here\n+        *[false] here\n+    }{$is_loop_message ->\n+        [true] , in previous iteration of loop\n+        *[false] {\"\"}\n+    }\n+\n+borrowck_consider_borrow_type_contents =\n+    help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\n+\n+borrowck_moved_a_fn_once_in_call =\n+    this value implements `FnOnce`, which causes it to be moved when called\n+\n+borrowck_calling_operator_moves_lhs =\n+    calling this operator moves the left-hand side\n+\n+borrowck_func_take_self_moved_place =\n+    `{$func}` takes ownership of the receiver `self`, which moves {$place_name}\n+\n+borrowck_suggest_iterate_over_slice =\n+    consider iterating over a slice of the `{$ty}`'s content to avoid moving into the `for` loop\n+\n+borrowck_suggest_create_freash_reborrow =\n+    consider reborrowing the `Pin` instead of moving it\n+\n+borrowck_value_capture_here =\n+    value captured {$is_within ->\n+        [true] here by generator\n+        *[false] here\n+    }\n+\n+borrowck_move_out_place_here =\n+    {$place} is moved here\n+\n+borrowck_closure_invoked_twice =\n+    closure cannot be invoked more than once because it moves the variable `{$place_name}` out of its environment\n+\n+borrowck_closure_moved_twice =\n+    closure cannot be moved more than once as it is not `Copy` due to moving the variable `{$place_name}` out of its environment\n+\n+borrowck_ty_no_impl_copy =\n+    {$is_partial_move ->\n+        [true] partial move\n+        *[false] move\n+    } occurs because {$place} has type `{$ty}`, which does not implement the `Copy` trait"}, {"sha": "a4a3c738f475a003d6d680ec9cbf35ba2f1081ba", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 119, "deletions": 69, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -30,8 +30,8 @@ use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n \n use crate::diagnostics::conflict_errors::StorageDeadOrDrop::LocalStorageDead;\n-use crate::diagnostics::find_all_local_uses;\n use crate::diagnostics::mutability_errors::mut_borrow_of_mutable_ref;\n+use crate::diagnostics::{find_all_local_uses, CapturedMessageOpt};\n use crate::{\n     borrow_set::BorrowData, diagnostics::Instance, prefixes::IsPrefixOf,\n     InitializationRequiringAction, MirBorrowckCtxt, PrefixSet, WriteKind,\n@@ -183,13 +183,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let move_spans = self.move_spans(moved_place.as_ref(), move_out.source);\n                 let move_span = move_spans.args_or_use();\n \n-                let move_msg = if move_spans.for_closure() { \" into closure\" } else { \"\" };\n+                let is_move_msg = move_spans.for_closure();\n \n-                let loop_message = if location == move_out.source || move_site.traversed_back_edge {\n-                    \", in previous iteration of loop\"\n-                } else {\n-                    \"\"\n-                };\n+                let is_loop_message = location == move_out.source || move_site.traversed_back_edge;\n \n                 if location == move_out.source {\n                     is_loop_move = true;\n@@ -206,17 +202,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         );\n                     }\n \n+                    let msg_opt = CapturedMessageOpt {\n+                        is_partial_move,\n+                        is_loop_message,\n+                        is_move_msg,\n+                        is_loop_move,\n+                        maybe_reinitialized_locations_is_empty: maybe_reinitialized_locations\n+                            .is_empty(),\n+                    };\n                     self.explain_captures(\n                         &mut err,\n                         span,\n                         move_span,\n                         move_spans,\n                         *moved_place,\n-                        partially_str,\n-                        loop_message,\n-                        move_msg,\n-                        is_loop_move,\n-                        maybe_reinitialized_locations.is_empty(),\n+                        msg_opt,\n                     );\n                 }\n                 seen_spans.insert(move_span);\n@@ -282,12 +282,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             if needs_note {\n-                let span = if let Some(local) = place.as_local() {\n-                    Some(self.body.local_decls[local].source_info.span)\n+                if let Some(local) = place.as_local() {\n+                    let span = self.body.local_decls[local].source_info.span;\n+                    err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                        is_partial_move,\n+                        ty,\n+                        place: &note_msg,\n+                        span,\n+                    });\n                 } else {\n-                    None\n+                    err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Note {\n+                        is_partial_move,\n+                        ty,\n+                        place: &note_msg,\n+                    });\n                 };\n-                self.note_type_does_not_implement_copy(&mut err, &note_msg, ty, span, partial_str);\n             }\n \n             if let UseSpans::FnSelfUse {\n@@ -827,11 +836,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         borrow_spans.var_path_only_subdiag(&mut err, crate::InitializationRequiringAction::Borrow);\n \n-        move_spans.var_span_label(\n-            &mut err,\n-            format!(\"move occurs due to use{}\", move_spans.describe()),\n-            \"moved\",\n-        );\n+        move_spans.var_subdiag(None, &mut err, None, |kind, var_span| {\n+            use crate::session_diagnostics::CaptureVarCause::*;\n+            match kind {\n+                Some(_) => MoveUseInGenerator { var_span },\n+                None => MoveUseInClosure { var_span },\n+            }\n+        });\n \n         self.explain_why_borrow_contains_point(location, borrow, None)\n             .add_explanation_to_diagnostic(\n@@ -868,13 +879,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             borrow_span,\n             &self.describe_any_place(borrow.borrowed_place.as_ref()),\n         );\n-        borrow_spans.var_subdiag(&mut err, Some(borrow.kind), |kind, var_span| {\n+        borrow_spans.var_subdiag(None, &mut err, Some(borrow.kind), |kind, var_span| {\n             use crate::session_diagnostics::CaptureVarCause::*;\n             let place = &borrow.borrowed_place;\n             let desc_place = self.describe_any_place(place.as_ref());\n             match kind {\n-                Some(_) => BorrowUsePlaceGenerator { place: desc_place, var_span },\n-                None => BorrowUsePlaceClosure { place: desc_place, var_span },\n+                Some(_) => {\n+                    BorrowUsePlaceGenerator { place: desc_place, var_span, is_single_var: true }\n+                }\n+                None => BorrowUsePlaceClosure { place: desc_place, var_span, is_single_var: true },\n             }\n         });\n \n@@ -988,16 +1001,26 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         immutable_section_description,\n                         \"mutably borrow\",\n                     );\n-                    borrow_spans.var_span_label(\n+                    borrow_spans.var_subdiag(\n+                        None,\n                         &mut err,\n-                        format!(\n-                            \"borrow occurs due to use of {}{}\",\n-                            desc_place,\n-                            borrow_spans.describe(),\n-                        ),\n-                        \"immutable\",\n+                        Some(BorrowKind::Unique),\n+                        |kind, var_span| {\n+                            use crate::session_diagnostics::CaptureVarCause::*;\n+                            match kind {\n+                                Some(_) => BorrowUsePlaceGenerator {\n+                                    place: desc_place,\n+                                    var_span,\n+                                    is_single_var: true,\n+                                },\n+                                None => BorrowUsePlaceClosure {\n+                                    place: desc_place,\n+                                    var_span,\n+                                    is_single_var: true,\n+                                },\n+                            }\n+                        },\n                     );\n-\n                     return err;\n                 } else {\n                     first_borrow_desc = \"immutable \";\n@@ -1070,32 +1093,48 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         if issued_spans == borrow_spans {\n-            borrow_spans.var_span_label(\n-                &mut err,\n-                format!(\"borrows occur due to use of {}{}\", desc_place, borrow_spans.describe(),),\n-                gen_borrow_kind.describe_mutability(),\n-            );\n+            borrow_spans.var_subdiag(None, &mut err, Some(gen_borrow_kind), |kind, var_span| {\n+                use crate::session_diagnostics::CaptureVarCause::*;\n+                match kind {\n+                    Some(_) => BorrowUsePlaceGenerator {\n+                        place: desc_place,\n+                        var_span,\n+                        is_single_var: false,\n+                    },\n+                    None => {\n+                        BorrowUsePlaceClosure { place: desc_place, var_span, is_single_var: false }\n+                    }\n+                }\n+            });\n         } else {\n-            let borrow_place = &issued_borrow.borrowed_place;\n-            let borrow_place_desc = self.describe_any_place(borrow_place.as_ref());\n-            issued_spans.var_span_label(\n+            issued_spans.var_subdiag(\n+                Some(&self.infcx.tcx.sess.parse_sess.span_diagnostic),\n                 &mut err,\n-                format!(\n-                    \"first borrow occurs due to use of {}{}\",\n-                    borrow_place_desc,\n-                    issued_spans.describe(),\n-                ),\n-                issued_borrow.kind.describe_mutability(),\n+                Some(issued_borrow.kind),\n+                |kind, var_span| {\n+                    use crate::session_diagnostics::CaptureVarCause::*;\n+                    let borrow_place = &issued_borrow.borrowed_place;\n+                    let borrow_place_desc = self.describe_any_place(borrow_place.as_ref());\n+                    match kind {\n+                        Some(_) => {\n+                            FirstBorrowUsePlaceGenerator { place: borrow_place_desc, var_span }\n+                        }\n+                        None => FirstBorrowUsePlaceClosure { place: borrow_place_desc, var_span },\n+                    }\n+                },\n             );\n \n-            borrow_spans.var_span_label(\n+            borrow_spans.var_subdiag(\n+                Some(&self.infcx.tcx.sess.parse_sess.span_diagnostic),\n                 &mut err,\n-                format!(\n-                    \"second borrow occurs due to use of {}{}\",\n-                    desc_place,\n-                    borrow_spans.describe(),\n-                ),\n-                gen_borrow_kind.describe_mutability(),\n+                Some(gen_borrow_kind),\n+                |kind, var_span| {\n+                    use crate::session_diagnostics::CaptureVarCause::*;\n+                    match kind {\n+                        Some(_) => SecondBorrowUsePlaceGenerator { place: desc_place, var_span },\n+                        None => SecondBorrowUsePlaceClosure { place: desc_place, var_span },\n+                    }\n+                },\n             );\n         }\n \n@@ -1731,9 +1770,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             err.span_label(borrow_span, \"borrowed value does not live long enough\");\n             err.span_label(drop_span, format!(\"`{}` dropped here while still borrowed\", name));\n \n-            let within = if borrow_spans.for_generator() { \" by generator\" } else { \"\" };\n-\n-            borrow_spans.args_span_label(&mut err, format!(\"value captured here{}\", within));\n+            borrow_spans.args_subdiag(&mut err, |args_span| {\n+                crate::session_diagnostics::CaptureArgLabel::Capture {\n+                    is_within: borrow_spans.for_generator(),\n+                    args_span,\n+                }\n+            });\n \n             explanation.add_explanation_to_diagnostic(\n                 self.infcx.tcx,\n@@ -1947,9 +1989,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             None,\n         );\n \n-        let within = if borrow_spans.for_generator() { \" by generator\" } else { \"\" };\n-\n-        borrow_spans.args_span_label(&mut err, format!(\"value captured here{}\", within));\n+        borrow_spans.args_subdiag(&mut err, |args_span| {\n+            crate::session_diagnostics::CaptureArgLabel::Capture {\n+                is_within: borrow_spans.for_generator(),\n+                args_span,\n+            }\n+        });\n \n         err\n     }\n@@ -2382,11 +2427,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     section,\n                     \"assign\",\n                 );\n-                loan_spans.var_span_label(\n-                    &mut err,\n-                    format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n-                    loan.kind.describe_mutability(),\n-                );\n+\n+                loan_spans.var_subdiag(None, &mut err, Some(loan.kind), |kind, var_span| {\n+                    use crate::session_diagnostics::CaptureVarCause::*;\n+                    match kind {\n+                        Some(_) => BorrowUseInGenerator { var_span },\n+                        None => BorrowUseInClosure { var_span },\n+                    }\n+                });\n \n                 self.buffer_error(err);\n \n@@ -2396,11 +2444,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let mut err = self.cannot_assign_to_borrowed(span, loan_span, &descr_place);\n \n-        loan_spans.var_span_label(\n-            &mut err,\n-            format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n-            loan.kind.describe_mutability(),\n-        );\n+        loan_spans.var_subdiag(None, &mut err, Some(loan.kind), |kind, var_span| {\n+            use crate::session_diagnostics::CaptureVarCause::*;\n+            match kind {\n+                Some(_) => BorrowUseInGenerator { var_span },\n+                None => BorrowUseInClosure { var_span },\n+            }\n+        });\n \n         self.explain_why_borrow_contains_point(location, loan, None).add_explanation_to_diagnostic(\n             self.infcx.tcx,"}, {"sha": "4a85df9f8c09e5c57dc6adb3cfb323b4a76868c6", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 103, "deletions": 143, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -1,5 +1,9 @@\n //! Borrow checker diagnostics.\n \n+use crate::session_diagnostics::{\n+    CaptureArgLabel, CaptureReasonLabel, CaptureReasonNote, CaptureReasonSuggest, CaptureVarCause,\n+    CaptureVarKind, CaptureVarPathUseCause, OnClosureNote,\n+};\n use itertools::Itertools;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n@@ -117,13 +121,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind() {\n                         let did = did.expect_local();\n                         if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n-                            diag.span_note(\n-                                *span,\n-                                &format!(\n-                                    \"closure cannot be invoked more than once because it moves the \\\n-                                    variable `{}` out of its environment\",\n-                                    ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n-                                ),\n+                            diag.eager_subdiagnostic(\n+                                &self.infcx.tcx.sess.parse_sess.span_diagnostic,\n+                                OnClosureNote::InvokedTwice {\n+                                    place_name: &ty::place_to_string_for_capture(\n+                                        self.infcx.tcx,\n+                                        hir_place,\n+                                    ),\n+                                    span: *span,\n+                                },\n                             );\n                             return true;\n                         }\n@@ -137,13 +143,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind() {\n                 let did = did.expect_local();\n                 if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n-                    diag.span_note(\n-                        *span,\n-                        &format!(\n-                            \"closure cannot be moved more than once as it is not `Copy` due to \\\n-                             moving the variable `{}` out of its environment\",\n-                            ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n-                        ),\n+                    diag.eager_subdiagnostic(\n+                        &self.infcx.tcx.sess.parse_sess.span_diagnostic,\n+                        OnClosureNote::MovedTwice {\n+                            place_name: &ty::place_to_string_for_capture(self.infcx.tcx, hir_place),\n+                            span: *span,\n+                        },\n                     );\n                     return true;\n                 }\n@@ -380,25 +385,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    /// Add a note that a type does not implement `Copy`\n-    pub(super) fn note_type_does_not_implement_copy(\n-        &self,\n-        err: &mut Diagnostic,\n-        place_desc: &str,\n-        ty: Ty<'tcx>,\n-        span: Option<Span>,\n-        move_prefix: &str,\n-    ) {\n-        let message = format!(\n-            \"{move_prefix}move occurs because {place_desc} has type `{ty}`, which does not implement the `Copy` trait\",\n-        );\n-        if let Some(span) = span {\n-            err.span_label(span, message);\n-        } else {\n-            err.note(&message);\n-        }\n-    }\n-\n     pub(super) fn borrowed_content_source(\n         &self,\n         deref_base: PlaceRef<'tcx>,\n@@ -582,9 +568,13 @@ impl UseSpans<'_> {\n     }\n \n     /// Add a span label to the arguments of the closure, if it exists.\n-    pub(super) fn args_span_label(self, err: &mut Diagnostic, message: impl Into<String>) {\n+    pub(super) fn args_subdiag(\n+        self,\n+        err: &mut Diagnostic,\n+        f: impl FnOnce(Span) -> CaptureArgLabel,\n+    ) {\n         if let UseSpans::ClosureUse { args_span, .. } = self {\n-            err.span_label(args_span, message);\n+            err.subdiagnostic(f(args_span));\n         }\n     }\n \n@@ -595,8 +585,8 @@ impl UseSpans<'_> {\n         err: &mut Diagnostic,\n         action: crate::InitializationRequiringAction,\n     ) {\n-        use crate::session_diagnostics::CaptureVarPathUseCause::*;\n         use crate::InitializationRequiringAction::*;\n+        use CaptureVarPathUseCause::*;\n         if let UseSpans::ClosureUse { generator_kind, path_span, .. } = self {\n             match generator_kind {\n                 Some(_) => {\n@@ -619,52 +609,36 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    /// Add a span label to the use of the captured variable, if it exists.\n-    pub(super) fn var_span_label(\n-        self,\n-        err: &mut Diagnostic,\n-        message: impl Into<String>,\n-        kind_desc: impl Into<String>,\n-    ) {\n-        if let UseSpans::ClosureUse { capture_kind_span, path_span, .. } = self {\n-            if capture_kind_span == path_span {\n-                err.span_label(capture_kind_span, message);\n-            } else {\n-                let capture_kind_label =\n-                    format!(\"capture is {} because of use here\", kind_desc.into());\n-                let path_label = message;\n-                err.span_label(capture_kind_span, capture_kind_label);\n-                err.span_label(path_span, path_label);\n-            }\n-        }\n-    }\n-\n     /// Add a subdiagnostic to the use of the captured variable, if it exists.\n     pub(super) fn var_subdiag(\n         self,\n+        handler: Option<&rustc_errors::Handler>,\n         err: &mut Diagnostic,\n         kind: Option<rustc_middle::mir::BorrowKind>,\n-        f: impl Fn(Option<GeneratorKind>, Span) -> crate::session_diagnostics::CaptureVarCause,\n+        f: impl FnOnce(Option<GeneratorKind>, Span) -> CaptureVarCause,\n     ) {\n-        use crate::session_diagnostics::CaptureVarKind::*;\n         if let UseSpans::ClosureUse { generator_kind, capture_kind_span, path_span, .. } = self {\n             if capture_kind_span != path_span {\n                 err.subdiagnostic(match kind {\n                     Some(kd) => match kd {\n                         rustc_middle::mir::BorrowKind::Shared\n                         | rustc_middle::mir::BorrowKind::Shallow\n                         | rustc_middle::mir::BorrowKind::Unique => {\n-                            Immute { kind_span: capture_kind_span }\n+                            CaptureVarKind::Immut { kind_span: capture_kind_span }\n                         }\n \n                         rustc_middle::mir::BorrowKind::Mut { .. } => {\n-                            Mut { kind_span: capture_kind_span }\n+                            CaptureVarKind::Mut { kind_span: capture_kind_span }\n                         }\n                     },\n-                    None => Move { kind_span: capture_kind_span },\n+                    None => CaptureVarKind::Move { kind_span: capture_kind_span },\n                 });\n             };\n-            err.subdiagnostic(f(generator_kind, path_span));\n+            let diag = f(generator_kind, path_span);\n+            match handler {\n+                Some(hd) => err.eager_subdiagnostic(hd, diag),\n+                None => err.subdiagnostic(diag),\n+            };\n         }\n     }\n \n@@ -684,20 +658,6 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    /// Describe the span associated with a use of a place.\n-    pub(super) fn describe(&self) -> &str {\n-        match *self {\n-            UseSpans::ClosureUse { generator_kind, .. } => {\n-                if generator_kind.is_some() {\n-                    \" in generator\"\n-                } else {\n-                    \" in closure\"\n-                }\n-            }\n-            _ => \"\",\n-        }\n-    }\n-\n     pub(super) fn or_else<F>(self, if_other: F) -> Self\n     where\n         F: FnOnce() -> Self,\n@@ -788,6 +748,15 @@ impl<'tcx> BorrowedContentSource<'tcx> {\n     }\n }\n \n+///helper struct for explain_captures()\n+struct CapturedMessageOpt {\n+    is_partial_move: bool,\n+    is_loop_message: bool,\n+    is_move_msg: bool,\n+    is_loop_move: bool,\n+    maybe_reinitialized_locations_is_empty: bool,\n+}\n+\n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Finds the spans associated to a move or copy of move_place at location.\n     pub(super) fn move_spans(\n@@ -1027,12 +996,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         move_span: Span,\n         move_spans: UseSpans<'tcx>,\n         moved_place: Place<'tcx>,\n-        partially_str: &str,\n-        loop_message: &str,\n-        move_msg: &str,\n-        is_loop_move: bool,\n-        maybe_reinitialized_locations_is_empty: bool,\n+        msg_opt: CapturedMessageOpt,\n     ) {\n+        let CapturedMessageOpt {\n+            is_partial_move: is_partial,\n+            is_loop_message,\n+            is_move_msg,\n+            is_loop_move,\n+            maybe_reinitialized_locations_is_empty,\n+        } = msg_opt;\n         if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } = move_spans {\n             let place_name = self\n                 .describe_place(moved_place.as_ref())\n@@ -1042,30 +1014,26 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 CallKind::FnCall { fn_trait_id, .. }\n                     if Some(fn_trait_id) == self.infcx.tcx.lang_items().fn_once_trait() =>\n                 {\n-                    err.span_label(\n+                    err.subdiagnostic(CaptureReasonLabel::Call {\n                         fn_call_span,\n-                        &format!(\n-                            \"{place_name} {partially_str}moved due to this call{loop_message}\",\n-                        ),\n-                    );\n-                    err.span_note(\n-                        var_span,\n-                        \"this value implements `FnOnce`, which causes it to be moved when called\",\n-                    );\n+                        place_name: &place_name,\n+                        is_partial,\n+                        is_loop_message,\n+                    });\n+                    err.subdiagnostic(CaptureReasonNote::FnOnceMoveInCall { var_span });\n                 }\n                 CallKind::Operator { self_arg, .. } => {\n                     let self_arg = self_arg.unwrap();\n-                    err.span_label(\n+                    err.subdiagnostic(CaptureReasonLabel::OperatorUse {\n                         fn_call_span,\n-                        &format!(\n-                            \"{place_name} {partially_str}moved due to usage in operator{loop_message}\",\n-                        ),\n-                    );\n+                        place_name: &place_name,\n+                        is_partial,\n+                        is_loop_message,\n+                    });\n                     if self.fn_self_span_reported.insert(fn_span) {\n-                        err.span_note(\n-                            self_arg.span,\n-                            \"calling this operator moves the left-hand side\",\n-                        );\n+                        err.subdiagnostic(CaptureReasonNote::LhsMoveByOperator {\n+                            span: self_arg.span,\n+                        });\n                     }\n                 }\n                 CallKind::Normal { self_arg, desugaring, method_did, method_substs } => {\n@@ -1086,23 +1054,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             _ => false,\n                         };\n                         if suggest {\n-                            err.span_suggestion_verbose(\n-                                move_span.shrink_to_lo(),\n-                                &format!(\n-                                    \"consider iterating over a slice of the `{ty}`'s content to \\\n-                                     avoid moving into the `for` loop\",\n-                                ),\n-                                \"&\",\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            err.subdiagnostic(CaptureReasonSuggest::IterateSlice {\n+                                ty,\n+                                span: move_span.shrink_to_lo(),\n+                            });\n                         }\n \n-                        err.span_label(\n+                        err.subdiagnostic(CaptureReasonLabel::ImplicitCall {\n                             fn_call_span,\n-                            &format!(\n-                                \"{place_name} {partially_str}moved due to this implicit call to `.into_iter()`{loop_message}\",\n-                            ),\n-                        );\n+                            place_name: &place_name,\n+                            is_partial,\n+                            is_loop_message,\n+                        });\n                         // If the moved place was a `&mut` ref, then we can\n                         // suggest to reborrow it where it was moved, so it\n                         // will still be valid by the time we get to the usage.\n@@ -1125,13 +1088,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                         }\n                     } else {\n-                        err.span_label(\n+                        err.subdiagnostic(CaptureReasonLabel::MethodCall {\n                             fn_call_span,\n-                            &format!(\n-                                \"{place_name} {partially_str}moved due to this method call{loop_message}\",\n-                            ),\n-                        );\n-\n+                            place_name: &place_name,\n+                            is_partial,\n+                            is_loop_message,\n+                        });\n                         let infcx = tcx.infer_ctxt().build();\n                         // Erase and shadow everything that could be passed to the new infcx.\n                         let ty = tcx.erase_regions(moved_place.ty(self.body, tcx).ty);\n@@ -1147,12 +1109,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             )\n                             && infcx.can_eq(self.param_env, ty, self_ty)\n                         {\n-                            err.span_suggestion_verbose(\n-                                fn_call_span.shrink_to_lo(),\n-                                \"consider reborrowing the `Pin` instead of moving it\",\n-                                \"as_mut().\".to_string(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            err.eager_subdiagnostic(\n+                                &self.infcx.tcx.sess.parse_sess.span_diagnostic,\n+                                CaptureReasonSuggest::FreshReborrow {\n+                                    span: fn_call_span.shrink_to_lo(),\n+                                });\n                         }\n                         if let Some(clone_trait) = tcx.lang_items().clone_trait()\n                             && let trait_ref = tcx.mk_trait_ref(clone_trait, [ty])\n@@ -1177,10 +1138,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // error messages.\n                     if span != DUMMY_SP && self.fn_self_span_reported.insert(self_arg.span) {\n                         let func = tcx.def_path_str(method_did);\n-                        err.span_note(\n-                            self_arg.span,\n-                            &format!(\"`{func}` takes ownership of the receiver `self`, which moves {place_name}\")\n-                        );\n+                        err.subdiagnostic(CaptureReasonNote::FuncTakeSelf {\n+                            func,\n+                            place_name,\n+                            span: self_arg.span,\n+                        });\n                     }\n                     let parent_did = tcx.parent(method_did);\n                     let parent_self_ty =\n@@ -1194,30 +1156,28 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n                     });\n                     if is_option_or_result && maybe_reinitialized_locations_is_empty {\n-                        err.span_label(\n-                            var_span,\n-                            \"help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\",\n-                        );\n+                        err.subdiagnostic(CaptureReasonLabel::BorrowContent { var_span });\n                     }\n                 }\n                 // Other desugarings takes &self, which cannot cause a move\n                 _ => {}\n             }\n         } else {\n-            if move_span != span || !loop_message.is_empty() {\n-                err.span_label(\n+            if move_span != span || is_loop_message {\n+                err.subdiagnostic(CaptureReasonLabel::MovedHere {\n                     move_span,\n-                    format!(\"value {partially_str}moved{move_msg} here{loop_message}\"),\n-                );\n+                    is_partial,\n+                    is_move_msg,\n+                    is_loop_message,\n+                });\n             }\n             // If the move error occurs due to a loop, don't show\n             // another message for the same span\n-            if loop_message.is_empty() {\n-                move_spans.var_span_label(\n-                    err,\n-                    format!(\"variable {partially_str}moved due to use{}\", move_spans.describe()),\n-                    \"moved\",\n-                );\n+            if !is_loop_message {\n+                move_spans.var_subdiag(None, err, None, |kind, var_span| match kind {\n+                    Some(_) => CaptureVarCause::PartialMoveUseInGenerator { var_span, is_partial },\n+                    None => CaptureVarCause::PartialMoveUseInClosure { var_span, is_partial },\n+                })\n             }\n         }\n     }"}, {"sha": "67af96a71e30d715a83115a26155241d4cf5d0ab", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -6,6 +6,7 @@ use rustc_mir_dataflow::move_paths::{\n };\n use rustc_span::{BytePos, Span};\n \n+use crate::diagnostics::CapturedMessageOpt;\n use crate::diagnostics::{DescribePlaceOpt, UseSpans};\n use crate::prefixes::PrefixSet;\n use crate::MirBorrowckCtxt;\n@@ -397,10 +398,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n         };\n+        let msg_opt = CapturedMessageOpt {\n+            is_partial_move: false,\n+            is_loop_message: false,\n+            is_move_msg: false,\n+            is_loop_move: false,\n+            maybe_reinitialized_locations_is_empty: true,\n+        };\n         if let Some(use_spans) = use_spans {\n-            self.explain_captures(\n-                &mut err, span, span, use_spans, move_place, \"\", \"\", \"\", false, true,\n-            );\n+            self.explain_captures(&mut err, span, span, use_spans, move_place, msg_opt);\n         }\n         err\n     }\n@@ -416,13 +422,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         None => \"value\".to_string(),\n                     };\n \n-                    self.note_type_does_not_implement_copy(\n-                        err,\n-                        &place_desc,\n-                        place_ty,\n-                        Some(span),\n-                        \"\",\n-                    );\n+                    err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                        is_partial_move: false,\n+                        ty: place_ty,\n+                        place: &place_desc,\n+                        span,\n+                    });\n                 } else {\n                     binds_to.sort();\n                     binds_to.dedup();\n@@ -444,9 +449,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Some(desc) => format!(\"`{desc}`\"),\n                     None => \"value\".to_string(),\n                 };\n-                self.note_type_does_not_implement_copy(err, &place_desc, place_ty, Some(span), \"\");\n+                err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                    is_partial_move: false,\n+                    ty: place_ty,\n+                    place: &place_desc,\n+                    span,\n+                });\n \n-                use_spans.args_span_label(err, format!(\"{place_desc} is moved here\"));\n+                use_spans.args_subdiag(err, |args_span| {\n+                    crate::session_diagnostics::CaptureArgLabel::MoveOutPlace {\n+                        place: place_desc,\n+                        args_span,\n+                    }\n+                });\n             }\n         }\n     }\n@@ -534,13 +549,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             if binds_to.len() == 1 {\n-                self.note_type_does_not_implement_copy(\n-                    err,\n-                    &format!(\"`{}`\", self.local_names[*local].unwrap()),\n-                    bind_to.ty,\n-                    Some(binding_span),\n-                    \"\",\n-                );\n+                let place_desc = &format!(\"`{}`\", self.local_names[*local].unwrap());\n+                err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                    is_partial_move: false,\n+                    ty: bind_to.ty,\n+                    place: &place_desc,\n+                    span: binding_span,\n+                });\n             }\n         }\n "}, {"sha": "eb5f166548d9cf9d311a7bd16ad739fe8a8b9784", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -231,14 +231,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n                 if suggest {\n-                    borrow_spans.var_span_label(\n-                        &mut err,\n-                        format!(\n-                            \"mutable borrow occurs due to use of {} in closure\",\n-                            self.describe_any_place(access_place.as_ref()),\n-                        ),\n-                        \"mutable\",\n-                    );\n+                    borrow_spans.var_subdiag(\n+                    None,\n+                    &mut err,\n+                    Some(mir::BorrowKind::Mut { allow_two_phase_borrow: false }),\n+                    |_kind, var_span| {\n+                        let place = self.describe_any_place(access_place.as_ref());\n+                        crate::session_diagnostics::CaptureVarCause::MutableBorrowUsePlaceClosure {\n+                            place,\n+                            var_span,\n+                        }\n+                    },\n+                );\n                 }\n                 borrow_span\n             }"}, {"sha": "aa7cf3578ea829431cf1af737130a65a9e4f7880", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -3,7 +3,7 @@\n \n use crate::region_infer::RegionInferenceContext;\n use crate::Upvar;\n-use rustc_index::vec::{Idx, IndexSlice};\n+use rustc_index::vec::IndexSlice;\n use rustc_middle::mir::{Body, Local};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n use rustc_span::source_map::Span;\n@@ -117,7 +117,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_index: usize,\n     ) -> (Option<Symbol>, Span) {\n         let implicit_inputs = self.universal_regions().defining_ty.implicit_inputs();\n-        let argument_local = Local::new(implicit_inputs + argument_index + 1);\n+        let argument_local = Local::from_usize(implicit_inputs + argument_index + 1);\n         debug!(\"get_argument_name_and_span_for_region: argument_local={argument_local:?}\");\n \n         let argument_name = local_names[argument_local];"}, {"sha": "87fad9a355d3d69dc0d69ca770fcfdbdc3fa899d", "filename": "compiler/rustc_borrowck/src/facts.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -4,7 +4,6 @@ use crate::location::{LocationIndex, LocationTable};\n use crate::BorrowIndex;\n use polonius_engine::AllFacts as PoloniusFacts;\n use polonius_engine::Atom;\n-use rustc_index::vec::Idx;\n use rustc_middle::mir::Local;\n use rustc_middle::ty::{RegionVid, TyCtxt};\n use rustc_mir_dataflow::move_paths::MovePathIndex;\n@@ -93,13 +92,13 @@ impl AllFactsExt for AllFacts {\n \n impl Atom for BorrowIndex {\n     fn index(self) -> usize {\n-        Idx::index(self)\n+        self.as_usize()\n     }\n }\n \n impl Atom for LocationIndex {\n     fn index(self) -> usize {\n-        Idx::index(self)\n+        self.as_usize()\n     }\n }\n "}, {"sha": "08fa912f3682a7cfeee991b5f6cba692075b5741", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -1,6 +1,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_middle::mir::{BasicBlock, Body, Location};\n \n /// Maps between a MIR Location, which identifies a particular\n@@ -50,19 +50,19 @@ impl LocationTable {\n     }\n \n     pub fn all_points(&self) -> impl Iterator<Item = LocationIndex> {\n-        (0..self.num_points).map(LocationIndex::new)\n+        (0..self.num_points).map(LocationIndex::from_usize)\n     }\n \n     pub fn start_index(&self, location: Location) -> LocationIndex {\n         let Location { block, statement_index } = location;\n         let start_index = self.statements_before_block[block];\n-        LocationIndex::new(start_index + statement_index * 2)\n+        LocationIndex::from_usize(start_index + statement_index * 2)\n     }\n \n     pub fn mid_index(&self, location: Location) -> LocationIndex {\n         let Location { block, statement_index } = location;\n         let start_index = self.statements_before_block[block];\n-        LocationIndex::new(start_index + statement_index * 2 + 1)\n+        LocationIndex::from_usize(start_index + statement_index * 2 + 1)\n     }\n \n     pub fn to_location(&self, index: LocationIndex) -> RichLocation {"}, {"sha": "73b8765e57d1abc58e1aacc40e7d02f286ae855e", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -7,8 +7,8 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::IndexSlice;\n use rustc_middle::mir::{create_dump_file, dump_enabled, dump_mir, PassWhere};\n use rustc_middle::mir::{\n-    BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n-    Promoted,\n+    Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location, Promoted,\n+    START_BLOCK,\n };\n use rustc_middle::ty::{self, OpaqueHiddenType, TyCtxt};\n use rustc_span::symbol::sym;\n@@ -94,8 +94,8 @@ fn populate_polonius_move_facts(\n         }\n     }\n \n-    let fn_entry_start = location_table\n-        .start_index(Location { block: BasicBlock::from_u32(0u32), statement_index: 0 });\n+    let fn_entry_start =\n+        location_table.start_index(Location { block: START_BLOCK, statement_index: 0 });\n \n     // initialized_at\n     for init in move_data.inits.iter() {"}, {"sha": "bb95101845f3e0eead5e28c24224b18ba3b4e3d6", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 206, "deletions": 1, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -184,7 +184,7 @@ pub(crate) enum CaptureVarPathUseCause {\n #[derive(Subdiagnostic)]\n pub(crate) enum CaptureVarKind {\n     #[label(borrowck_capture_immute)]\n-    Immute {\n+    Immut {\n         #[primary_span]\n         kind_span: Span,\n     },\n@@ -204,16 +204,80 @@ pub(crate) enum CaptureVarKind {\n pub(crate) enum CaptureVarCause {\n     #[label(borrowck_var_borrow_by_use_place_in_generator)]\n     BorrowUsePlaceGenerator {\n+        is_single_var: bool,\n         place: String,\n         #[primary_span]\n         var_span: Span,\n     },\n     #[label(borrowck_var_borrow_by_use_place_in_closure)]\n     BorrowUsePlaceClosure {\n+        is_single_var: bool,\n         place: String,\n         #[primary_span]\n         var_span: Span,\n     },\n+    #[label(borrowck_var_borrow_by_use_in_generator)]\n+    BorrowUseInGenerator {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_borrow_by_use_in_closure)]\n+    BorrowUseInClosure {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_move_by_use_in_generator)]\n+    MoveUseInGenerator {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_move_by_use_in_closure)]\n+    MoveUseInClosure {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_first_borrow_by_use_place_in_generator)]\n+    FirstBorrowUsePlaceGenerator {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_first_borrow_by_use_place_in_closure)]\n+    FirstBorrowUsePlaceClosure {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_second_borrow_by_use_place_in_generator)]\n+    SecondBorrowUsePlaceGenerator {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_second_borrow_by_use_place_in_closure)]\n+    SecondBorrowUsePlaceClosure {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_mutable_borrow_by_use_place_in_closure)]\n+    MutableBorrowUsePlaceClosure {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_partial_var_move_by_use_in_generator)]\n+    PartialMoveUseInGenerator {\n+        #[primary_span]\n+        var_span: Span,\n+        is_partial: bool,\n+    },\n+    #[label(borrowck_partial_var_move_by_use_in_closure)]\n+    PartialMoveUseInClosure {\n+        #[primary_span]\n+        var_span: Span,\n+        is_partial: bool,\n+    },\n }\n \n #[derive(Diagnostic)]\n@@ -239,3 +303,144 @@ pub(crate) struct NonGenericOpaqueTypeParam<'a, 'tcx> {\n     #[label]\n     pub param_span: Span,\n }\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureReasonLabel<'a> {\n+    #[label(borrowck_moved_due_to_call)]\n+    Call {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_moved_due_to_usage_in_operator)]\n+    OperatorUse {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_moved_due_to_implicit_into_iter_call)]\n+    ImplicitCall {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_moved_due_to_method_call)]\n+    MethodCall {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_value_moved_here)]\n+    MovedHere {\n+        #[primary_span]\n+        move_span: Span,\n+        is_partial: bool,\n+        is_move_msg: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_consider_borrow_type_contents)]\n+    BorrowContent {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureReasonNote {\n+    #[note(borrowck_moved_a_fn_once_in_call)]\n+    FnOnceMoveInCall {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[note(borrowck_calling_operator_moves_lhs)]\n+    LhsMoveByOperator {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(borrowck_func_take_self_moved_place)]\n+    FuncTakeSelf {\n+        func: String,\n+        place_name: String,\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureReasonSuggest<'tcx> {\n+    #[suggestion(\n+        borrowck_suggest_iterate_over_slice,\n+        applicability = \"maybe-incorrect\",\n+        code = \"&\",\n+        style = \"verbose\"\n+    )]\n+    IterateSlice {\n+        ty: Ty<'tcx>,\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(\n+        borrowck_suggest_create_freash_reborrow,\n+        applicability = \"maybe-incorrect\",\n+        code = \"as_mut().\",\n+        style = \"verbose\"\n+    )]\n+    FreshReborrow {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureArgLabel {\n+    #[label(borrowck_value_capture_here)]\n+    Capture {\n+        is_within: bool,\n+        #[primary_span]\n+        args_span: Span,\n+    },\n+    #[label(borrowck_move_out_place_here)]\n+    MoveOutPlace {\n+        place: String,\n+        #[primary_span]\n+        args_span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum OnClosureNote<'a> {\n+    #[note(borrowck_closure_invoked_twice)]\n+    InvokedTwice {\n+        place_name: &'a str,\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(borrowck_closure_moved_twice)]\n+    MovedTwice {\n+        place_name: &'a str,\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum TypeNoCopy<'a, 'tcx> {\n+    #[label(borrowck_ty_no_impl_copy)]\n+    Label {\n+        is_partial_move: bool,\n+        ty: Ty<'tcx>,\n+        place: &'a str,\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(borrowck_ty_no_impl_copy)]\n+    Note { is_partial_move: bool, ty: Ty<'tcx>, place: &'a str },\n+}"}, {"sha": "9250b8d3eaf2a31ec3bc9dafbd97aef678c1ccf7", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -7,7 +7,6 @@\n //! `RETURN_PLACE` the MIR arguments) are always fully normalized (and\n //! contain revealed `impl Trait` values).\n \n-use rustc_index::vec::Idx;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty};\n@@ -83,7 +82,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             // In MIR, argument N is stored in local N+1.\n-            let local = Local::new(argument_index + 1);\n+            let local = Local::from_usize(argument_index + 1);\n \n             let mir_input_ty = body.local_decls[local].ty;\n "}, {"sha": "74241f722a67ed9138a335c00af9d736adc565c1", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -19,7 +19,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::BodyOwnerKind;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt};\n@@ -289,7 +289,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// Returns an iterator over all the RegionVids corresponding to\n     /// universally quantified free regions.\n     pub fn universal_regions(&self) -> impl Iterator<Item = RegionVid> {\n-        (FIRST_GLOBAL_INDEX..self.num_universals).map(RegionVid::new)\n+        (FIRST_GLOBAL_INDEX..self.num_universals).map(RegionVid::from_usize)\n     }\n \n     /// Returns `true` if `r` is classified as an local region."}, {"sha": "a0a8246be15248fdb82a7b437ea220d9e034cb6d", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -12,7 +12,6 @@ use crate::MemFlags;\n use rustc_ast as ast;\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, AssertKind, SwitchTargets};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, ValidityRequirement};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n@@ -369,7 +368,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if self.fn_abi.c_variadic {\n             // The `VaList` \"spoofed\" argument is just after all the real arguments.\n             let va_list_arg_idx = self.fn_abi.args.len();\n-            match self.locals[mir::Local::new(1 + va_list_arg_idx)] {\n+            match self.locals[mir::Local::from_usize(1 + va_list_arg_idx)] {\n                 LocalRef::Place(va_list) => {\n                     bx.va_end(va_list.llval);\n                 }"}, {"sha": "015a9beab832d2d388bf90cb2f9752efbeb1f886", "filename": "compiler/rustc_const_eval/src/interpret/discriminant.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -211,18 +211,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             let variant_index_relative = u32::try_from(variant_index_relative)\n                                 .expect(\"we checked that this fits into a u32\");\n                             // Then computing the absolute variant idx should not overflow any more.\n-                            let variant_index = variants_start\n-                                .checked_add(variant_index_relative)\n-                                .expect(\"overflow computing absolute variant idx\");\n-                            let variants_len = op\n+                            let variant_index = VariantIdx::from_u32(\n+                                variants_start\n+                                    .checked_add(variant_index_relative)\n+                                    .expect(\"overflow computing absolute variant idx\"),\n+                            );\n+                            let variants = op\n                                 .layout\n                                 .ty\n                                 .ty_adt_def()\n                                 .expect(\"tagged layout for non adt\")\n-                                .variants()\n-                                .len();\n-                            assert!(usize::try_from(variant_index).unwrap() < variants_len);\n-                            VariantIdx::from_u32(variant_index)\n+                                .variants();\n+                            assert!(variant_index < variants.next_index());\n+                            variant_index\n                         } else {\n                             untagged_variant\n                         }"}, {"sha": "525acfdaa81247746a09c7a105beefa24eb0a2d2", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -17,7 +17,6 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeFoldable};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span, DUMMY_SP};\n-use rustc_target::abi::FieldIdx;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::ObligationCause;\n \n@@ -875,7 +874,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     variant.fields.len() == 1\n                 })\n                 .filter_map(|variant| {\n-                    let sole_field = &variant.fields[FieldIdx::from_u32(0)];\n+                    let sole_field = &variant.single_field();\n \n                     let field_is_local = sole_field.did.is_local();\n                     let field_is_accessible ="}, {"sha": "0fdb29a5e48466d8f4ed9473f36bf8212b678bd3", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -4,7 +4,7 @@ use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n-use rustc_target::abi::{FieldIdx, Pointer, VariantIdx};\n+use rustc_target::abi::{Pointer, VariantIdx};\n \n use super::FnCtxt;\n \n@@ -28,7 +28,7 @@ fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         }\n \n         if def.variant(data_idx).fields.len() == 1 {\n-            return def.variant(data_idx).fields[FieldIdx::from_u32(0)].ty(tcx, substs);\n+            return def.variant(data_idx).single_field().ty(tcx, substs);\n         }\n     }\n "}, {"sha": "d885d040707e4a20b69b58c8ceaec304f7d62019", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -10,7 +10,6 @@ use rustc_middle::traits::{\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self as ty, GenericArgKind, IsSuggestable, Ty, TypeVisitableExt};\n use rustc_span::{sym, BytePos, Span};\n-use rustc_target::abi::FieldIdx;\n \n use crate::errors::{\n     ConsiderAddingAwait, FnConsiderCasting, FnItemsAreDistinct, FnUniqTypes,\n@@ -114,7 +113,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         variant.fields.len() == 1 && variant.ctor_kind() == Some(CtorKind::Fn)\n                     })\n                     .filter_map(|variant| {\n-                        let sole_field = &variant.fields[FieldIdx::from_u32(0)];\n+                        let sole_field = &variant.single_field();\n                         let sole_field_ty = sole_field.ty(self.tcx, substs);\n                         if self.same_type_modulo_infer(sole_field_ty, exp_found.found) {\n                             let variant_path ="}, {"sha": "d677d51881e0e9025c321bee7ed12f024ef70832", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -569,36 +569,50 @@ trait UnusedDelimLint {\n             }\n         }\n \n-        // Prevent false-positives in cases like `fn x() -> u8 { ({ 0 } + 1) }`\n-        let lhs_needs_parens = {\n+        // Check if LHS needs parens to prevent false-positives in cases like `fn x() -> u8 { ({ 0 } + 1) }`.\n+        {\n             let mut innermost = inner;\n             loop {\n                 innermost = match &innermost.kind {\n-                    ExprKind::Binary(_, lhs, _rhs) => lhs,\n+                    ExprKind::Binary(_op, lhs, _rhs) => lhs,\n                     ExprKind::Call(fn_, _params) => fn_,\n                     ExprKind::Cast(expr, _ty) => expr,\n                     ExprKind::Type(expr, _ty) => expr,\n                     ExprKind::Index(base, _subscript) => base,\n-                    _ => break false,\n+                    _ => break,\n                 };\n                 if !classify::expr_requires_semi_to_be_stmt(innermost) {\n-                    break true;\n+                    return true;\n                 }\n             }\n-        };\n+        }\n \n-        lhs_needs_parens\n-            || (followed_by_block\n-                && match &inner.kind {\n-                    ExprKind::Ret(_)\n-                    | ExprKind::Break(..)\n-                    | ExprKind::Yield(..)\n-                    | ExprKind::Yeet(..) => true,\n-                    ExprKind::Range(_lhs, Some(rhs), _limits) => {\n-                        matches!(rhs.kind, ExprKind::Block(..))\n-                    }\n-                    _ => parser::contains_exterior_struct_lit(&inner),\n-                })\n+        // Check if RHS needs parens to prevent false-positives in cases like `if (() == return) {}`.\n+        if !followed_by_block {\n+            return false;\n+        }\n+        let mut innermost = inner;\n+        loop {\n+            innermost = match &innermost.kind {\n+                ExprKind::Unary(_op, expr) => expr,\n+                ExprKind::Binary(_op, _lhs, rhs) => rhs,\n+                ExprKind::AssignOp(_op, _lhs, rhs) => rhs,\n+                ExprKind::Assign(_lhs, rhs, _span) => rhs,\n+\n+                ExprKind::Ret(_) | ExprKind::Yield(..) | ExprKind::Yeet(..) => return true,\n+\n+                ExprKind::Break(_label, None) => return false,\n+                ExprKind::Break(_label, Some(break_expr)) => {\n+                    return matches!(break_expr.kind, ExprKind::Block(..));\n+                }\n+\n+                ExprKind::Range(_lhs, Some(rhs), _limits) => {\n+                    return matches!(rhs.kind, ExprKind::Block(..));\n+                }\n+\n+                _ => return parser::contains_exterior_struct_lit(&inner),\n+            }\n+        }\n     }\n \n     fn emit_unused_delims_expr("}, {"sha": "1109e308cf0bfd35d906aec4c10e82407f260450", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -823,6 +823,7 @@ fn should_encode_span(def_kind: DefKind) -> bool {\n         | DefKind::TraitAlias\n         | DefKind::AssocTy\n         | DefKind::TyParam\n+        | DefKind::ConstParam\n         | DefKind::Fn\n         | DefKind::Const\n         | DefKind::Static(_)\n@@ -837,8 +838,7 @@ fn should_encode_span(def_kind: DefKind) -> bool {\n         | DefKind::Impl { .. }\n         | DefKind::Closure\n         | DefKind::Generator => true,\n-        DefKind::ConstParam\n-        | DefKind::ExternCrate\n+        DefKind::ExternCrate\n         | DefKind::Use\n         | DefKind::ForeignMod\n         | DefKind::ImplTraitPlaceholder"}, {"sha": "c4e41e00520e66332241e96bea588cbaf3044b4c", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -392,10 +392,8 @@ pub type QueryOutlivesConstraint<'tcx> =\n     (ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>, ConstraintCategory<'tcx>);\n \n TrivialTypeTraversalAndLiftImpls! {\n-    for <'tcx> {\n-        crate::infer::canonical::Certainty,\n-        crate::infer::canonical::CanonicalTyVarKind,\n-    }\n+    crate::infer::canonical::Certainty,\n+    crate::infer::canonical::CanonicalTyVarKind,\n }\n \n impl<'tcx> CanonicalVarValues<'tcx> {"}, {"sha": "cd1c6c330bc1e239ca46c5f23535e002210ca959", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -43,52 +43,44 @@ macro_rules! span_bug {\n \n #[macro_export]\n macro_rules! CloneLiftImpls {\n-    (for <$tcx:lifetime> { $($ty:ty,)+ }) => {\n+    ($($ty:ty,)+) => {\n         $(\n-            impl<$tcx> $crate::ty::Lift<$tcx> for $ty {\n+            impl<'tcx> $crate::ty::Lift<'tcx> for $ty {\n                 type Lifted = Self;\n-                fn lift_to_tcx(self, _: $crate::ty::TyCtxt<$tcx>) -> Option<Self> {\n+                fn lift_to_tcx(self, _: $crate::ty::TyCtxt<'tcx>) -> Option<Self> {\n                     Some(self)\n                 }\n             }\n         )+\n     };\n-\n-    ($($ty:ty,)+) => {\n-        CloneLiftImpls! {\n-            for <'tcx> {\n-                $($ty,)+\n-            }\n-        }\n-    };\n }\n \n /// Used for types that are `Copy` and which **do not care arena\n /// allocated data** (i.e., don't need to be folded).\n #[macro_export]\n macro_rules! TrivialTypeTraversalImpls {\n-    (for <$tcx:lifetime> { $($ty:ty,)+ }) => {\n+    ($($ty:ty,)+) => {\n         $(\n-            impl<$tcx> $crate::ty::fold::TypeFoldable<$crate::ty::TyCtxt<$tcx>> for $ty {\n-                fn try_fold_with<F: $crate::ty::fold::FallibleTypeFolder<$crate::ty::TyCtxt<$tcx>>>(\n+            impl<'tcx> $crate::ty::fold::TypeFoldable<$crate::ty::TyCtxt<'tcx>> for $ty {\n+                fn try_fold_with<F: $crate::ty::fold::FallibleTypeFolder<$crate::ty::TyCtxt<'tcx>>>(\n                     self,\n                     _: &mut F,\n                 ) -> ::std::result::Result<Self, F::Error> {\n                     Ok(self)\n                 }\n \n                 #[inline]\n-                fn fold_with<F: $crate::ty::fold::TypeFolder<$crate::ty::TyCtxt<$tcx>>>(\n+                fn fold_with<F: $crate::ty::fold::TypeFolder<$crate::ty::TyCtxt<'tcx>>>(\n                     self,\n                     _: &mut F,\n                 ) -> Self {\n                     self\n                 }\n             }\n \n-            impl<$tcx> $crate::ty::visit::TypeVisitable<$crate::ty::TyCtxt<$tcx>> for $ty {\n+            impl<'tcx> $crate::ty::visit::TypeVisitable<$crate::ty::TyCtxt<'tcx>> for $ty {\n                 #[inline]\n-                fn visit_with<F: $crate::ty::visit::TypeVisitor<$crate::ty::TyCtxt<$tcx>>>(\n+                fn visit_with<F: $crate::ty::visit::TypeVisitor<$crate::ty::TyCtxt<'tcx>>>(\n                     &self,\n                     _: &mut F)\n                     -> ::std::ops::ControlFlow<F::BreakTy>\n@@ -98,14 +90,6 @@ macro_rules! TrivialTypeTraversalImpls {\n             }\n         )+\n     };\n-\n-    ($($ty:ty,)+) => {\n-        TrivialTypeTraversalImpls! {\n-            for<'tcx> {\n-                $($ty,)+\n-            }\n-        }\n-    };\n }\n \n #[macro_export]"}, {"sha": "f985aae9a2255ad3f1f9db5bff1f407773304e23", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -714,9 +714,7 @@ pub enum BindingForm<'tcx> {\n }\n \n TrivialTypeTraversalAndLiftImpls! {\n-    for<'tcx> {\n-        BindingForm<'tcx>,\n-    }\n+    BindingForm<'tcx>,\n }\n \n mod binding_form_impl {"}, {"sha": "ace856b9f95e021b703ba3993b0c37ccbe6a60a8", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -25,9 +25,7 @@ TrivialTypeTraversalAndLiftImpls! {\n }\n \n TrivialTypeTraversalImpls! {\n-    for <'tcx> {\n-        ConstValue<'tcx>,\n-    }\n+    ConstValue<'tcx>,\n }\n \n impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for &'tcx [InlineAsmTemplatePiece] {"}, {"sha": "e5356581e6e1de8b5a9192c0f2df26fb3a08c9fa", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -1329,9 +1329,12 @@ nop_list_lift! {bound_variable_kinds; ty::BoundVariableKind => ty::BoundVariable\n // This is the impl for `&'a InternalSubsts<'a>`.\n nop_list_lift! {substs; GenericArg<'a> => GenericArg<'tcx>}\n \n-CloneLiftImpls! { for<'tcx> {\n-    Constness, traits::WellFormedLoc, ImplPolarity, crate::mir::ReturnConstraint,\n-} }\n+CloneLiftImpls! {\n+    Constness,\n+    traits::WellFormedLoc,\n+    ImplPolarity,\n+    crate::mir::ReturnConstraint,\n+}\n \n macro_rules! sty_debug_print {\n     ($fmt: expr, $ctxt: expr, $($variant: ident),*) => {{"}, {"sha": "5501763d66fcc4f3391088069c9b352017edd4b6", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -1963,6 +1963,16 @@ impl VariantDef {\n     pub fn ctor_def_id(&self) -> Option<DefId> {\n         self.ctor.map(|(_, def_id)| def_id)\n     }\n+\n+    /// Returns the one field in this variant.\n+    ///\n+    /// `panic!`s if there are no fields or multiple fields.\n+    #[inline]\n+    pub fn single_field(&self) -> &FieldDef {\n+        assert!(self.fields.len() == 1);\n+\n+        &self.fields[FieldIdx::from_u32(0)]\n+    }\n }\n \n impl PartialEq for VariantDef {"}, {"sha": "7706fdddeb833609833e663fac2cff34ce4f18ce", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -276,9 +276,7 @@ TrivialTypeTraversalAndLiftImpls! {\n }\n \n TrivialTypeTraversalAndLiftImpls! {\n-    for<'tcx> {\n-        ty::ValTree<'tcx>,\n-    }\n+    ty::ValTree<'tcx>,\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "8ee08c5be3419b085febe0ed8a4b1d4a2071a101", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location, Operand, Terminator, TerminatorKind, RETURN_PLACE};\n-use rustc_middle::ty::{self, DeducedParamAttrs, ParamEnv, Ty, TyCtxt};\n+use rustc_middle::ty::{self, DeducedParamAttrs, Ty, TyCtxt};\n use rustc_session::config::OptLevel;\n \n /// A visitor that determines which arguments have been mutated. We can't use the mutability field\n@@ -198,11 +198,12 @@ pub fn deduced_param_attrs<'tcx>(\n     // see [1].\n     //\n     // [1]: https://github.com/rust-lang/rust/pull/103172#discussion_r999139997\n+    let param_env = tcx.param_env_reveal_all_normalized(def_id);\n     let mut deduced_param_attrs = tcx.arena.alloc_from_iter(\n         body.local_decls.iter().skip(1).take(body.arg_count).enumerate().map(\n             |(arg_index, local_decl)| DeducedParamAttrs {\n                 read_only: !deduce_read_only.mutable_args.contains(arg_index)\n-                    && local_decl.ty.is_freeze(tcx, ParamEnv::reveal_all()),\n+                    && local_decl.ty.is_freeze(tcx, param_env),\n             },\n         ),\n     );"}, {"sha": "055682a1509ef14efb3b85641e775871fa78f762", "filename": "compiler/rustc_passes/messages.ftl", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fmessages.ftl?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -627,9 +627,9 @@ passes_attr_application_struct_enum_union =\n     attribute should be applied to a struct, enum, or union\n     .label = not a struct, enum, or union\n \n-passes_attr_application_struct_enum_function_union =\n-    attribute should be applied to a struct, enum, function, or union\n-    .label = not a struct, enum, function, or union\n+passes_attr_application_struct_enum_function_method_union =\n+    attribute should be applied to a struct, enum, function, associated function, or union\n+    .label = not a struct, enum, function, associated function, or union\n \n passes_transparent_incompatible =\n     transparent {$target} cannot have other repr hints"}, {"sha": "085a28626ea003105546441c2eb80ab6b18b745b", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -1728,7 +1728,9 @@ impl CheckAttrVisitor<'_> {\n                     }\n                 }\n                 sym::align => {\n-                    if let (Target::Fn, false) = (target, self.tcx.features().fn_align) {\n+                    if let (Target::Fn | Target::Method(MethodKind::Inherent), false) =\n+                        (target, self.tcx.features().fn_align)\n+                    {\n                         feature_err(\n                             &self.tcx.sess.parse_sess,\n                             sym::fn_align,\n@@ -1739,10 +1741,14 @@ impl CheckAttrVisitor<'_> {\n                     }\n \n                     match target {\n-                        Target::Struct | Target::Union | Target::Enum | Target::Fn => continue,\n+                        Target::Struct\n+                        | Target::Union\n+                        | Target::Enum\n+                        | Target::Fn\n+                        | Target::Method(_) => continue,\n                         _ => {\n                             self.tcx.sess.emit_err(\n-                                errors::AttrApplication::StructEnumFunctionUnion {\n+                                errors::AttrApplication::StructEnumFunctionMethodUnion {\n                                     hint_span: hint.span(),\n                                     span,\n                                 },"}, {"sha": "e8603b3a2f1732688f036838a0625fe4b47f9f47", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -1355,8 +1355,8 @@ pub enum AttrApplication {\n         #[label]\n         span: Span,\n     },\n-    #[diag(passes_attr_application_struct_enum_function_union, code = \"E0517\")]\n-    StructEnumFunctionUnion {\n+    #[diag(passes_attr_application_struct_enum_function_method_union, code = \"E0517\")]\n+    StructEnumFunctionMethodUnion {\n         #[primary_span]\n         hint_span: Span,\n         #[label]"}, {"sha": "9dcc41e27269f56ad3f560a54841afb838b1a553", "filename": "compiler/rustc_query_system/src/dep_graph/query.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -24,10 +24,7 @@ impl<K: DepKind> DepGraphQuery<K> {\n \n     pub fn push(&mut self, index: DepNodeIndex, node: DepNode<K>, edges: &[DepNodeIndex]) {\n         let source = self.graph.add_node(node);\n-        if index.index() >= self.dep_index_to_index.len() {\n-            self.dep_index_to_index.resize(index.index() + 1, None);\n-        }\n-        self.dep_index_to_index[index] = Some(source);\n+        self.dep_index_to_index.insert(index, source);\n         self.indices.insert(node, source);\n \n         for &target in edges.iter() {"}, {"sha": "dfdd52720a05224117f4523459a2200564559036", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -11,12 +11,13 @@\n use super::{CanonicalGoal, Certainty, EvalCtxt, Goal};\n use crate::solve::canonicalize::{CanonicalizeMode, Canonicalizer};\n use crate::solve::{CanonicalResponse, QueryResult, Response};\n+use rustc_index::vec::IndexVec;\n use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n use rustc_middle::traits::query::NoSolution;\n use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n-use rustc_middle::ty::{self, GenericArgKind};\n+use rustc_middle::ty::{self, BoundVar, GenericArgKind};\n use rustc_span::DUMMY_SP;\n use std::iter;\n use std::ops::Deref;\n@@ -139,25 +140,25 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         //\n         // We therefore instantiate the existential variable in the canonical response with the\n         // inference variable of the input right away, which is more performant.\n-        let mut opt_values = vec![None; response.variables.len()];\n+        let mut opt_values = IndexVec::from_elem_n(None, response.variables.len());\n         for (original_value, result_value) in iter::zip(original_values, var_values.var_values) {\n             match result_value.unpack() {\n                 GenericArgKind::Type(t) => {\n                     if let &ty::Bound(debruijn, b) = t.kind() {\n                         assert_eq!(debruijn, ty::INNERMOST);\n-                        opt_values[b.var.index()] = Some(*original_value);\n+                        opt_values[b.var] = Some(*original_value);\n                     }\n                 }\n                 GenericArgKind::Lifetime(r) => {\n                     if let ty::ReLateBound(debruijn, br) = *r {\n                         assert_eq!(debruijn, ty::INNERMOST);\n-                        opt_values[br.var.index()] = Some(*original_value);\n+                        opt_values[br.var] = Some(*original_value);\n                     }\n                 }\n                 GenericArgKind::Const(c) => {\n                     if let ty::ConstKind::Bound(debrujin, b) = c.kind() {\n                         assert_eq!(debrujin, ty::INNERMOST);\n-                        opt_values[b.index()] = Some(*original_value);\n+                        opt_values[b] = Some(*original_value);\n                     }\n                 }\n             }\n@@ -180,7 +181,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                     // more placeholders then they should be able to. However the inference variables have\n                     // to \"come from somewhere\", so by equating them with the original values of the caller\n                     // later on, we pull them down into their correct universe again.\n-                    if let Some(v) = opt_values[index] {\n+                    if let Some(v) = opt_values[BoundVar::from_usize(index)] {\n                         v\n                     } else {\n                         self.infcx.instantiate_canonical_var(DUMMY_SP, info, |_| prev_universe)"}, {"sha": "8c3cb22832299947df31222eff25ba1fe49302cd", "filename": "compiler/rustc_type_ir/src/macros.rs", "status": "modified", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_type_ir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_type_ir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fmacros.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -33,144 +33,3 @@ macro_rules! TrivialTypeTraversalImpls {\n         )+\n     };\n }\n-\n-macro_rules! EnumTypeTraversalImpl {\n-    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n-        $($variants:tt)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::fold::TypeFoldable<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            fn try_fold_with<V: $crate::fold::FallibleTypeFolder<$tcx>>(\n-                self,\n-                folder: &mut V,\n-            ) -> ::std::result::Result<Self, V::Error> {\n-                EnumTypeTraversalImpl!(@FoldVariants(self, folder) input($($variants)*) output())\n-            }\n-        }\n-    };\n-\n-    (impl<$($p:tt),*> TypeVisitable<$tcx:tt> for $s:path {\n-        $($variants:tt)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::visit::TypeVisitable<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            fn visit_with<V: $crate::visit::TypeVisitor<$tcx>>(\n-                &self,\n-                visitor: &mut V,\n-            ) -> ::std::ops::ControlFlow<V::BreakTy> {\n-                EnumTypeTraversalImpl!(@VisitVariants(self, visitor) input($($variants)*) output())\n-            }\n-        }\n-    };\n-\n-    (@FoldVariants($this:expr, $folder:expr) input() output($($output:tt)*)) => {\n-        Ok(match $this {\n-            $($output)*\n-        })\n-    };\n-\n-    (@FoldVariants($this:expr, $folder:expr)\n-     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @FoldVariants($this, $folder)\n-                input($($input)*)\n-                output(\n-                    $variant ( $($variant_arg),* ) => {\n-                        $variant (\n-                            $($crate::fold::TypeFoldable::try_fold_with($variant_arg, $folder)?),*\n-                        )\n-                    }\n-                    $($output)*\n-                )\n-        )\n-    };\n-\n-    (@FoldVariants($this:expr, $folder:expr)\n-     input( ($variant:path) { $($variant_arg:ident),* $(,)? } , $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @FoldVariants($this, $folder)\n-                input($($input)*)\n-                output(\n-                    $variant { $($variant_arg),* } => {\n-                        $variant {\n-                            $($variant_arg: $crate::fold::TypeFoldable::fold_with(\n-                                $variant_arg, $folder\n-                            )?),* }\n-                    }\n-                    $($output)*\n-                )\n-        )\n-    };\n-\n-    (@FoldVariants($this:expr, $folder:expr)\n-     input( ($variant:path), $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @FoldVariants($this, $folder)\n-                input($($input)*)\n-                output(\n-                    $variant => { $variant }\n-                    $($output)*\n-                )\n-        )\n-    };\n-\n-    (@VisitVariants($this:expr, $visitor:expr) input() output($($output:tt)*)) => {\n-        match $this {\n-            $($output)*\n-        }\n-    };\n-\n-    (@VisitVariants($this:expr, $visitor:expr)\n-     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @VisitVariants($this, $visitor)\n-                input($($input)*)\n-                output(\n-                    $variant ( $($variant_arg),* ) => {\n-                        $($crate::visit::TypeVisitable::visit_with(\n-                            $variant_arg, $visitor\n-                        )?;)*\n-                        ::std::ops::ControlFlow::Continue(())\n-                    }\n-                    $($output)*\n-                )\n-        )\n-    };\n-\n-    (@VisitVariants($this:expr, $visitor:expr)\n-     input( ($variant:path) { $($variant_arg:ident),* $(,)? } , $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @VisitVariants($this, $visitor)\n-                input($($input)*)\n-                output(\n-                    $variant { $($variant_arg),* } => {\n-                        $($crate::visit::TypeVisitable::visit_with(\n-                            $variant_arg, $visitor\n-                        )?;)*\n-                        ::std::ops::ControlFlow::Continue(())\n-                    }\n-                    $($output)*\n-                )\n-        )\n-    };\n-\n-    (@VisitVariants($this:expr, $visitor:expr)\n-     input( ($variant:path), $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @VisitVariants($this, $visitor)\n-                input($($input)*)\n-                output(\n-                    $variant => { ::std::ops::ControlFlow::Continue(()) }\n-                    $($output)*\n-                )\n-        )\n-    };\n-}"}, {"sha": "c90c86b7690deb6e02f98bf78ef617c44fbd705f", "filename": "compiler/rustc_type_ir/src/structural_impls.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -70,30 +70,40 @@ impl<I: Interner, A: TypeVisitable<I>, B: TypeVisitable<I>, C: TypeVisitable<I>>\n     }\n }\n \n-EnumTypeTraversalImpl! {\n-    impl<I, T> TypeFoldable<I> for Option<T> {\n-        (Some)(a),\n-        (None),\n-    } where I: Interner, T: TypeFoldable<I>\n-}\n-EnumTypeTraversalImpl! {\n-    impl<I, T> TypeVisitable<I> for Option<T> {\n-        (Some)(a),\n-        (None),\n-    } where I: Interner, T: TypeVisitable<I>\n-}\n-\n-EnumTypeTraversalImpl! {\n-    impl<I, T, E> TypeFoldable<I> for Result<T, E> {\n-        (Ok)(a),\n-        (Err)(a),\n-    } where I: Interner, T: TypeFoldable<I>, E: TypeFoldable<I>,\n-}\n-EnumTypeTraversalImpl! {\n-    impl<I, T, E> TypeVisitable<I> for Result<T, E> {\n-        (Ok)(a),\n-        (Err)(a),\n-    } where I: Interner, T: TypeVisitable<I>, E: TypeVisitable<I>,\n+impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Option<T> {\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(match self {\n+            Some(v) => Some(v.try_fold_with(folder)?),\n+            None => None,\n+        })\n+    }\n+}\n+\n+impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Option<T> {\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        match self {\n+            Some(v) => v.visit_with(visitor),\n+            None => ControlFlow::Continue(()),\n+        }\n+    }\n+}\n+\n+impl<I: Interner, T: TypeFoldable<I>, E: TypeFoldable<I>> TypeFoldable<I> for Result<T, E> {\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(match self {\n+            Ok(v) => Ok(v.try_fold_with(folder)?),\n+            Err(e) => Err(e.try_fold_with(folder)?),\n+        })\n+    }\n+}\n+\n+impl<I: Interner, T: TypeVisitable<I>, E: TypeVisitable<I>> TypeVisitable<I> for Result<T, E> {\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        match self {\n+            Ok(v) => v.visit_with(visitor),\n+            Err(e) => e.visit_with(visitor),\n+        }\n+    }\n }\n \n impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Rc<T> {"}, {"sha": "d7c6a884fc8fb32de51c44b303263224dd117e81", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -84,8 +84,8 @@ Note: The [`-g` flag][option-g-debug] is an alias for `-C debuginfo=2`.\n This flag controls whether or not the linker includes its default libraries.\n It takes one of the following values:\n \n-* `y`, `yes`, `on`, `true` or no value: include default libraries (the default).\n-* `n`, `no`, `off` or `false`: exclude default libraries.\n+* `y`, `yes`, `on`, `true`: include default libraries.\n+* `n`, `no`, `off` or `false` or no value: exclude default libraries (the default).\n \n For example, for gcc flavor linkers, this issues the `-nodefaultlibs` flag to\n the linker."}, {"sha": "f3cf614e185c9d5f1df27828c42786561c47a561", "filename": "tests/codegen/align-fn.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fcodegen%2Falign-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fcodegen%2Falign-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Falign-fn.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -7,3 +7,43 @@\n #[no_mangle]\n #[repr(align(16))]\n pub fn fn_align() {}\n+\n+pub struct A;\n+\n+impl A {\n+    // CHECK: align 16\n+    #[no_mangle]\n+    #[repr(align(16))]\n+    pub fn method_align(self) {}\n+\n+    // CHECK: align 16\n+    #[no_mangle]\n+    #[repr(align(16))]\n+    pub fn associated_fn() {}\n+}\n+\n+trait T: Sized {\n+    fn trait_fn() {}\n+\n+    // CHECK: align 32\n+    #[repr(align(32))]\n+    fn trait_method(self) {}\n+}\n+\n+impl T for A {\n+    // CHECK: align 16\n+    #[no_mangle]\n+    #[repr(align(16))]\n+    fn trait_fn() {}\n+\n+    // CHECK: align 16\n+    #[no_mangle]\n+    #[repr(align(16))]\n+    fn trait_method(self) {}\n+}\n+\n+impl T for () {}\n+\n+pub fn foo() {\n+    ().trait_method();\n+}"}, {"sha": "caf0366d2c144a9fc8df88f10a55ecc44673bc32", "filename": "tests/codegen/thread-local.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fcodegen%2Fthread-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fcodegen%2Fthread-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fthread-local.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -20,8 +20,8 @@ thread_local!(static A: Cell<u32> = const { Cell::new(1) });\n // CHECK-LABEL: @get\n #[no_mangle]\n fn get() -> u32 {\n-    // CHECK: %0 = load i32, {{.*}}[[TLS]]{{.*}}\n-    // CHECK-NEXT: ret i32 %0\n+    // CHECK: [[RET_0:%.+]] = load i32, {{.*}}[[TLS]]{{.*}}\n+    // CHECK-NEXT: ret i32 [[RET_0]]\n     A.with(|a| a.get())\n }\n \n@@ -36,8 +36,8 @@ fn set(v: u32) {\n // CHECK-LABEL: @get_aux\n #[no_mangle]\n fn get_aux() -> u64 {\n-    // CHECK: %0 = load i64, {{.*}}[[TLS_AUX]]\n-    // CHECK-NEXT: ret i64 %0\n+    // CHECK: [[RET_1:%.+]] = load i64, {{.*}}[[TLS_AUX]]\n+    // CHECK-NEXT: ret i64 [[RET_1]]\n     aux::A.with(|a| a.get())\n }\n "}, {"sha": "10a487c127ec8e64aa7ccad9d7cf60da08efc51a", "filename": "tests/ui/attributes/invalid-repr.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fattributes%2Finvalid-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fattributes%2Finvalid-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Finvalid-repr.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -0,0 +1,5 @@\n+#[repr(align(16))]\n+//~^ ERROR attribute should be applied to a struct, enum, function, associated function, or union\n+pub type Foo = i32;\n+\n+fn main() {}"}, {"sha": "98a6a24b3c42cbf76e8f9a1753d630b08e978c37", "filename": "tests/ui/attributes/invalid-repr.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fattributes%2Finvalid-repr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fattributes%2Finvalid-repr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Finvalid-repr.stderr?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -0,0 +1,12 @@\n+error[E0517]: attribute should be applied to a struct, enum, function, associated function, or union\n+  --> $DIR/invalid-repr.rs:1:8\n+   |\n+LL | #[repr(align(16))]\n+   |        ^^^^^^^^^\n+LL |\n+LL | pub type Foo = i32;\n+   | ------------------- not a struct, enum, function, associated function, or union\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0517`."}, {"sha": "edc79f8fd94bd61ed525f7ea23aee41941eb4226", "filename": "tests/ui/codegen/freeze-on-polymorphic-projection.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fcodegen%2Ffreeze-on-polymorphic-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fcodegen%2Ffreeze-on-polymorphic-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcodegen%2Ffreeze-on-polymorphic-projection.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -0,0 +1,19 @@\n+// build-pass\n+// compile-flags: -Copt-level=1 --crate-type=lib\n+\n+#![feature(specialization)]\n+//~^ WARN the feature `specialization` is incomplete\n+\n+pub unsafe trait Storage {\n+    type Handle;\n+}\n+\n+pub unsafe trait MultipleStorage: Storage {}\n+\n+default unsafe impl<S> Storage for S where S: MultipleStorage {}\n+\n+// Make sure that we call is_freeze on `(S::Handle,)` in the param-env of `ice`,\n+// instead of in an empty, reveal-all param-env.\n+pub fn ice<S: Storage>(boxed: (S::Handle,)) -> (S::Handle,) {\n+    boxed\n+}"}, {"sha": "903cb2ff6aa9874d0e24f1637fe1939bcf3e86e9", "filename": "tests/ui/codegen/freeze-on-polymorphic-projection.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fcodegen%2Ffreeze-on-polymorphic-projection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fcodegen%2Ffreeze-on-polymorphic-projection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcodegen%2Ffreeze-on-polymorphic-projection.stderr?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -0,0 +1,12 @@\n+warning: the feature `specialization` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/freeze-on-polymorphic-projection.rs:4:12\n+   |\n+LL | #![feature(specialization)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #31844 <https://github.com/rust-lang/rust/issues/31844> for more information\n+   = help: consider using `min_specialization` instead, which is more stable and complete\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "85b0c6c9df8b16a96a6e803a380ac58efd97788c", "filename": "tests/ui/consts/auxiliary/foreign-generic-mismatch-with-const-arg.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fconsts%2Fauxiliary%2Fforeign-generic-mismatch-with-const-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fconsts%2Fauxiliary%2Fforeign-generic-mismatch-with-const-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fauxiliary%2Fforeign-generic-mismatch-with-const-arg.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -0,0 +1 @@\n+pub fn test<const N: usize, T>() {}"}, {"sha": "7590abbd827b1d1b9b3e1cee637dfd8cc9c7b833", "filename": "tests/ui/consts/foreign-generic-mismatch-with-const-arg.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fconsts%2Fforeign-generic-mismatch-with-const-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fconsts%2Fforeign-generic-mismatch-with-const-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fforeign-generic-mismatch-with-const-arg.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -0,0 +1,8 @@\n+// aux-build: foreign-generic-mismatch-with-const-arg.rs\n+\n+extern crate foreign_generic_mismatch_with_const_arg;\n+\n+fn main() {\n+    foreign_generic_mismatch_with_const_arg::test::<1>();\n+    //~^ ERROR function takes 2 generic arguments but 1 generic argument was supplied\n+}"}, {"sha": "4cc03a20514aa186fb27ae37becea3037aedcf68", "filename": "tests/ui/consts/foreign-generic-mismatch-with-const-arg.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fconsts%2Fforeign-generic-mismatch-with-const-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Fconsts%2Fforeign-generic-mismatch-with-const-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fforeign-generic-mismatch-with-const-arg.stderr?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -0,0 +1,21 @@\n+error[E0107]: function takes 2 generic arguments but 1 generic argument was supplied\n+  --> $DIR/foreign-generic-mismatch-with-const-arg.rs:6:46\n+   |\n+LL |     foreign_generic_mismatch_with_const_arg::test::<1>();\n+   |                                              ^^^^   - supplied 1 generic argument\n+   |                                              |\n+   |                                              expected 2 generic arguments\n+   |\n+note: function defined here, with 2 generic parameters: `N`, `T`\n+  --> $DIR/auxiliary/foreign-generic-mismatch-with-const-arg.rs:1:8\n+   |\n+LL | pub fn test<const N: usize, T>() {}\n+   |        ^^^^ --------------  -\n+help: add missing generic argument\n+   |\n+LL |     foreign_generic_mismatch_with_const_arg::test::<1, T>();\n+   |                                                      +++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "9c52ca5577e4a705883cfd194b7f09d4472f91fb", "filename": "tests/ui/lint/unused/issue-54538-unused-parens-lint.fixed", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.fixed?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -21,17 +21,32 @@ fn lint_on_top_level() {\n     let _ = |a: u8| 0; //~ ERROR unnecessary parentheses around pattern\n }\n \n-fn _no_lint_attr() {\n+fn no_lint_attr() {\n     let _x = #[allow(dead_code)] (1 + 2);\n }\n \n-fn _no_lint_yeet() -> Result<(), ()> {\n+fn no_lint_yeet() -> Result<(), ()> {\n     #[allow(unreachable_code)]\n     if (do yeet) {}\n \n     Ok(())\n }\n \n+fn no_lint_ops() {\n+    #![allow(unreachable_code, irrefutable_let_patterns)]\n+    if ((..{}) == ..{}) {}\n+    if (!return) {}\n+    loop { match (() = () = () = break {}) {} }\n+    while let () = (*&mut false |= true && return) {}\n+}\n+\n+fn lint_break_if_not_followed_by_block() {\n+    #![allow(unreachable_code)]\n+    loop { if break {} } //~ ERROR unnecessary parentheses\n+    loop { if break ({ println!(\"hello\") }) {} } //~ ERROR unnecessary parentheses\n+    loop { if (break { println!(\"hello\") }) {} }\n+}\n+\n // Don't lint in these cases (#64106).\n fn or_patterns_no_lint() {\n     match Box::new(0) {"}, {"sha": "196ecf0c1bb8512f5450b58ab97328459bbe1f2c", "filename": "tests/ui/lint/unused/issue-54538-unused-parens-lint.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.rs?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -21,17 +21,32 @@ fn lint_on_top_level() {\n     let _ = |(a): u8| 0; //~ ERROR unnecessary parentheses around pattern\n }\n \n-fn _no_lint_attr() {\n+fn no_lint_attr() {\n     let _x = #[allow(dead_code)] (1 + 2);\n }\n \n-fn _no_lint_yeet() -> Result<(), ()> {\n+fn no_lint_yeet() -> Result<(), ()> {\n     #[allow(unreachable_code)]\n     if (do yeet) {}\n \n     Ok(())\n }\n \n+fn no_lint_ops() {\n+    #![allow(unreachable_code, irrefutable_let_patterns)]\n+    if ((..{}) == ..{}) {}\n+    if (!return) {}\n+    loop { match (() = () = () = break {}) {} }\n+    while let () = (*&mut false |= true && return) {}\n+}\n+\n+fn lint_break_if_not_followed_by_block() {\n+    #![allow(unreachable_code)]\n+    loop { if (break) {} } //~ ERROR unnecessary parentheses\n+    loop { if (break ({ println!(\"hello\") })) {} } //~ ERROR unnecessary parentheses\n+    loop { if (break { println!(\"hello\") }) {} }\n+}\n+\n // Don't lint in these cases (#64106).\n fn or_patterns_no_lint() {\n     match Box::new(0) {"}, {"sha": "f916bba8194ff30b7124a815b739ee739aa30726", "filename": "tests/ui/lint/unused/issue-54538-unused-parens-lint.stderr", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31656e7295ebd5f2f6597f10c011e2ac4ba3ef39/tests%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.stderr?ref=31656e7295ebd5f2f6597f10c011e2ac4ba3ef39", "patch": "@@ -75,8 +75,32 @@ LL -     let _ = |(a): u8| 0;\n LL +     let _ = |a: u8| 0;\n    |\n \n+error: unnecessary parentheses around `if` condition\n+  --> $DIR/issue-54538-unused-parens-lint.rs:45:15\n+   |\n+LL |     loop { if (break) {} }\n+   |               ^     ^\n+   |\n+help: remove these parentheses\n+   |\n+LL -     loop { if (break) {} }\n+LL +     loop { if break {} }\n+   |\n+\n+error: unnecessary parentheses around `if` condition\n+  --> $DIR/issue-54538-unused-parens-lint.rs:46:15\n+   |\n+LL |     loop { if (break ({ println!(\"hello\") })) {} }\n+   |               ^                             ^\n+   |\n+help: remove these parentheses\n+   |\n+LL -     loop { if (break ({ println!(\"hello\") })) {} }\n+LL +     loop { if break ({ println!(\"hello\") }) {} }\n+   |\n+\n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:56:12\n+  --> $DIR/issue-54538-unused-parens-lint.rs:71:12\n    |\n LL |     if let (0 | 1) = 0 {}\n    |            ^     ^\n@@ -88,7 +112,7 @@ LL +     if let 0 | 1 = 0 {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:57:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:72:13\n    |\n LL |     if let ((0 | 1),) = (0,) {}\n    |             ^     ^\n@@ -100,7 +124,7 @@ LL +     if let (0 | 1,) = (0,) {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:58:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:73:13\n    |\n LL |     if let [(0 | 1)] = [0] {}\n    |             ^     ^\n@@ -112,7 +136,7 @@ LL +     if let [0 | 1] = [0] {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:59:16\n+  --> $DIR/issue-54538-unused-parens-lint.rs:74:16\n    |\n LL |     if let 0 | (1 | 2) = 0 {}\n    |                ^     ^\n@@ -124,7 +148,7 @@ LL +     if let 0 | 1 | 2 = 0 {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:61:15\n+  --> $DIR/issue-54538-unused-parens-lint.rs:76:15\n    |\n LL |     if let TS((0 | 1)) = TS(0) {}\n    |               ^     ^\n@@ -136,7 +160,7 @@ LL +     if let TS(0 | 1) = TS(0) {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:63:20\n+  --> $DIR/issue-54538-unused-parens-lint.rs:78:20\n    |\n LL |     if let NS { f: (0 | 1) } = (NS { f: 0 }) {}\n    |                    ^     ^\n@@ -148,7 +172,7 @@ LL +     if let NS { f: 0 | 1 } = (NS { f: 0 }) {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:73:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:88:9\n    |\n LL |         (_) => {}\n    |         ^ ^\n@@ -160,7 +184,7 @@ LL +         _ => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:74:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:89:9\n    |\n LL |         (y) => {}\n    |         ^ ^\n@@ -172,7 +196,7 @@ LL +         y => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:75:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:90:9\n    |\n LL |         (ref r) => {}\n    |         ^     ^\n@@ -184,7 +208,7 @@ LL +         ref r => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:76:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:91:9\n    |\n LL |         (e @ 1...2) => {}\n    |         ^         ^\n@@ -196,7 +220,7 @@ LL +         e @ 1...2 => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:82:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:97:9\n    |\n LL |         (e @ &(1...2)) => {}\n    |         ^            ^\n@@ -208,7 +232,7 @@ LL +         e @ &(1...2) => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:83:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:98:10\n    |\n LL |         &(_) => {}\n    |          ^ ^\n@@ -220,7 +244,7 @@ LL +         &_ => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:94:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:109:9\n    |\n LL |         (_) => {}\n    |         ^ ^\n@@ -232,7 +256,7 @@ LL +         _ => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:95:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:110:9\n    |\n LL |         (y) => {}\n    |         ^ ^\n@@ -244,7 +268,7 @@ LL +         y => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:96:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:111:9\n    |\n LL |         (ref r) => {}\n    |         ^     ^\n@@ -256,7 +280,7 @@ LL +         ref r => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:97:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:112:9\n    |\n LL |         (e @ 1..=2) => {}\n    |         ^         ^\n@@ -268,7 +292,7 @@ LL +         e @ 1..=2 => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:103:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:118:9\n    |\n LL |         (e @ &(1..=2)) => {}\n    |         ^            ^\n@@ -280,7 +304,7 @@ LL +         e @ &(1..=2) => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:104:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:119:10\n    |\n LL |         &(_) => {}\n    |          ^ ^\n@@ -291,5 +315,5 @@ LL -         &(_) => {}\n LL +         &_ => {}\n    |\n \n-error: aborting due to 24 previous errors\n+error: aborting due to 26 previous errors\n "}]}