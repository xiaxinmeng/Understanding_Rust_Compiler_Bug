{"sha": "26e0c57dde7ea664457e3bf1340f832c722bd349", "node_id": "C_kwDOAAsO6NoAKDI2ZTBjNTdkZGU3ZWE2NjQ0NTdlM2JmMTM0MGY4MzJjNzIyYmQzNDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-12T02:05:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-12T02:05:05Z"}, "message": "Auto merge of #111475 - workingjubilee:sync-simd-2023-may-10, r=workingjubilee\n\n Sync portable-simd to 2023 May 10\n\nTake 2.\n\nr? `@ghost`", "tree": {"sha": "b3358aac2d6ba88fe1cf49cef05c6ccba5d59f57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3358aac2d6ba88fe1cf49cef05c6ccba5d59f57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26e0c57dde7ea664457e3bf1340f832c722bd349", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26e0c57dde7ea664457e3bf1340f832c722bd349", "html_url": "https://github.com/rust-lang/rust/commit/26e0c57dde7ea664457e3bf1340f832c722bd349", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26e0c57dde7ea664457e3bf1340f832c722bd349/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "html_url": "https://github.com/rust-lang/rust/commit/5b24e12785e6a6bacb69953fb389bcd2fc11ae87"}, {"sha": "e4cecc1ab73d0422f6a5f63b6a01eb8b1be303ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4cecc1ab73d0422f6a5f63b6a01eb8b1be303ad", "html_url": "https://github.com/rust-lang/rust/commit/e4cecc1ab73d0422f6a5f63b6a01eb8b1be303ad"}], "stats": {"total": 2962, "additions": 2199, "deletions": 763}, "files": [{"sha": "acd47a3da72b2cc0f910755b2b0573dbbb09e662", "filename": "library/portable-simd/.github/workflows/ci.yml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2F.github%2Fworkflows%2Fci.yml?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -241,6 +241,10 @@ jobs:\n           - \"--features std\"\n           - \"--features generic_const_exprs\"\n           - \"--features std --features generic_const_exprs\"\n+          - \"--features all_lane_counts\"\n+          - \"--features all_lane_counts --features std\"\n+          - \"--features all_lane_counts --features generic_const_exprs\"\n+          - \"--features all_lane_counts --features std --features generic_const_exprs\"\n \n     steps:\n       - uses: actions/checkout@v2"}, {"sha": "e8ac600debe67881c33b1301aceb4945eb56206f", "filename": "library/portable-simd/README.md", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2FREADME.md?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -24,44 +24,34 @@ or by setting up `rustup default nightly` or else with `cargo +nightly {build,te\n ```bash\n cargo new hellosimd\n ```\n-to create a new crate. Edit `hellosimd/Cargo.toml` to be \n-```toml\n-[package]\n-name = \"hellosimd\"\n-version = \"0.1.0\"\n-edition = \"2018\"\n-[dependencies]\n-core_simd = { git = \"https://github.com/rust-lang/portable-simd\" }\n-```\n-\n-and finally write this in `src/main.rs`:\n+to create a new crate. Finally write this in `src/main.rs`:\n ```rust\n-use core_simd::*;\n+#![feature(portable_simd)]\n+use std::simd::f32x4;\n fn main() {\n     let a = f32x4::splat(10.0);\n     let b = f32x4::from_array([1.0, 2.0, 3.0, 4.0]);\n     println!(\"{:?}\", a + b);\n }\n ```\n \n-Explanation: We import all the bindings from the crate with the first line. Then, we construct our SIMD vectors with methods like `splat` or `from_array`. Finally, we can use operators on them like `+` and the appropriate SIMD instructions will be carried out. When we run `cargo run` you should get `[11.0, 12.0, 13.0, 14.0]`.\n-\n-## Code Organization\n+Explanation: We construct our SIMD vectors with methods like `splat` or `from_array`. Next, we can use operators like `+` on them, and the appropriate SIMD instructions will be carried out. When we run `cargo run` you should get `[11.0, 12.0, 13.0, 14.0]`.\n \n-Currently the crate is organized so that each element type is a file, and then the 64-bit, 128-bit, 256-bit, and 512-bit vectors using those types are contained in said file.\n+## Supported vectors\n \n-All types are then exported as a single, flat module.\n+Currently, vectors may have up to 64 elements, but aliases are provided only up to 512-bit vectors.\n \n Depending on the size of the primitive type, the number of lanes the vector will have varies. For example, 128-bit vectors have four `f32` lanes and two `f64` lanes.\n \n The supported element types are as follows:\n * **Floating Point:** `f32`, `f64`\n-* **Signed Integers:** `i8`, `i16`, `i32`, `i64`, `i128`, `isize`\n-* **Unsigned Integers:** `u8`, `u16`, `u32`, `u64`, `u128`, `usize`\n-* **Masks:** `mask8`, `mask16`, `mask32`, `mask64`, `mask128`, `masksize`\n+* **Signed Integers:** `i8`, `i16`, `i32`, `i64`, `isize` (`i128` excluded)\n+* **Unsigned Integers:** `u8`, `u16`, `u32`, `u64`, `usize` (`u128` excluded)\n+* **Pointers:** `*const T` and `*mut T` (zero-sized metadata only)\n+* **Masks:** 8-bit, 16-bit, 32-bit, 64-bit, and `usize`-sized masks\n \n-Floating point, signed integers, and unsigned integers are the [primitive types](https://doc.rust-lang.org/core/primitive/index.html) you're already used to.\n-The `mask` types are \"truthy\" values, but they use the number of bits in their name instead of just 1 bit like a normal `bool` uses.\n+Floating point, signed integers, unsigned integers, and pointers are the [primitive types](https://doc.rust-lang.org/core/primitive/index.html) you're already used to.\n+The mask types have elements that are \"truthy\" values, like `bool`, but have an unspecified layout because different architectures prefer different layouts for mask types.\n \n [simd-guide]: ./beginners-guide.md\n [zulip-project-portable-simd]: https://rust-lang.zulipchat.com/#narrow/stream/257879-project-portable-simd"}, {"sha": "d1a3a515a7e81ff25c2750863d92f2cfc06b60e2", "filename": "library/portable-simd/crates/core_simd/Cargo.toml", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -13,12 +13,11 @@ default = [\"as_crate\"]\n as_crate = []\n std = []\n generic_const_exprs = []\n+all_lane_counts = []\n \n-[target.'cfg(target_arch = \"wasm32\")'.dev-dependencies.wasm-bindgen]\n-version = \"0.2\"\n-\n-[dev-dependencies.wasm-bindgen-test]\n-version = \"0.3\"\n+[target.'cfg(target_arch = \"wasm32\")'.dev-dependencies]\n+wasm-bindgen = \"0.2\"\n+wasm-bindgen-test = \"0.3\"\n \n [dev-dependencies.proptest]\n version = \"0.10\""}, {"sha": "82747f1b5a6f9c7091f7d3e1ad13d357d9619efb", "filename": "library/portable-simd/crates/core_simd/examples/README.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2FREADME.md?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -0,0 +1,13 @@\n+### `stdsimd` examples\n+\n+This crate is a port of example uses of `stdsimd`, mostly taken from the `packed_simd` crate.\n+\n+The examples contain, as in the case of `dot_product.rs`, multiple ways of solving the problem, in order to show idiomatic uses of SIMD and iteration of performance designs.\n+\n+Run the tests with the command \n+\n+```\n+cargo run --example dot_product\n+```\n+\n+and verify the code for `dot_product.rs` on your machine."}, {"sha": "391f08f55a07a37d54c33414cc7c0ea0449781b3", "filename": "library/portable-simd/crates/core_simd/examples/dot_product.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fdot_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fdot_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fdot_product.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -0,0 +1,169 @@\n+// Code taken from the `packed_simd` crate\n+// Run this code with `cargo test --example dot_product`\n+//use std::iter::zip;\n+\n+#![feature(array_chunks)]\n+#![feature(slice_as_chunks)]\n+// Add these imports to use the stdsimd library\n+#![feature(portable_simd)]\n+use core_simd::simd::*;\n+\n+// This is your barebones dot product implementation:\n+// Take 2 vectors, multiply them element wise and *then*\n+// go along the resulting array and add up the result.\n+// In the next example we will see if there\n+//  is any difference to adding and multiplying in tandem.\n+pub fn dot_prod_scalar_0(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+\n+    a.iter().zip(b.iter()).map(|(a, b)| a * b).sum()\n+}\n+\n+// When dealing with SIMD, it is very important to think about the amount\n+// of data movement and when it happens. We're going over simple computation examples here, and yet\n+// it is not trivial to understand what may or may not contribute to performance\n+// changes. Eventually, you will need tools to inspect the generated assembly and confirm your\n+// hypothesis and benchmarks - we will mention them later on.\n+// With the use of `fold`, we're doing a multiplication,\n+// and then adding it to the sum, one element from both vectors at a time.\n+pub fn dot_prod_scalar_1(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+    a.iter()\n+        .zip(b.iter())\n+        .fold(0.0, |a, zipped| a + zipped.0 * zipped.1)\n+}\n+\n+// We now move on to the SIMD implementations: notice the following constructs:\n+// `array_chunks::<4>`: mapping this over the vector will let use construct SIMD vectors\n+// `f32x4::from_array`: construct the SIMD vector from a slice\n+// `(a * b).reduce_sum()`: Multiply both f32x4 vectors together, and then reduce them.\n+// This approach essentially uses SIMD to produce a vector of length N/4 of all the products,\n+// and then add those with `sum()`. This is suboptimal.\n+// TODO: ASCII diagrams\n+pub fn dot_prod_simd_0(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+    // TODO handle remainder when a.len() % 4 != 0\n+    a.array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .map(|(a, b)| (a * b).reduce_sum())\n+        .sum()\n+}\n+\n+// There's some simple ways to improve the previous code:\n+// 1. Make a `zero` `f32x4` SIMD vector that we will be accumulating into\n+// So that there is only one `sum()` reduction when the last `f32x4` has been processed\n+// 2. Exploit Fused Multiply Add so that the multiplication, addition and sinking into the reduciton\n+// happen in the same step.\n+// If the arrays are large, minimizing the data shuffling will lead to great perf.\n+// If the arrays are small, handling the remainder elements when the length isn't a multiple of 4\n+// Can become a problem.\n+pub fn dot_prod_simd_1(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+    // TODO handle remainder when a.len() % 4 != 0\n+    a.array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .fold(f32x4::splat(0.0), |acc, zipped| acc + zipped.0 * zipped.1)\n+        .reduce_sum()\n+}\n+\n+// A lot of knowledgeable use of SIMD comes from knowing specific instructions that are\n+// available - let's try to use the `mul_add` instruction, which is the fused-multiply-add we were looking for.\n+use std_float::StdFloat;\n+pub fn dot_prod_simd_2(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+    // TODO handle remainder when a.len() % 4 != 0\n+    let mut res = f32x4::splat(0.0);\n+    a.array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .for_each(|(a, b)| {\n+            res = a.mul_add(b, res);\n+        });\n+    res.reduce_sum()\n+}\n+\n+// Finally, we will write the same operation but handling the loop remainder.\n+const LANES: usize = 4;\n+pub fn dot_prod_simd_3(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+\n+    let (a_extra, a_chunks) = a.as_rchunks();\n+    let (b_extra, b_chunks) = b.as_rchunks();\n+\n+    // These are always true, but for emphasis:\n+    assert_eq!(a_chunks.len(), b_chunks.len());\n+    assert_eq!(a_extra.len(), b_extra.len());\n+\n+    let mut sums = [0.0; LANES];\n+    for ((x, y), d) in std::iter::zip(a_extra, b_extra).zip(&mut sums) {\n+        *d = x * y;\n+    }\n+\n+    let mut sums = f32x4::from_array(sums);\n+    std::iter::zip(a_chunks, b_chunks).for_each(|(x, y)| {\n+        sums += f32x4::from_array(*x) * f32x4::from_array(*y);\n+    });\n+\n+    sums.reduce_sum()\n+}\n+\n+// Finally, we present an iterator version for handling remainders in a scalar fashion at the end of the loop.\n+// Unfortunately, this is allocating 1 `XMM` register on the order of `~len(a)` - we'll see how we can get around it in the\n+// next example.\n+pub fn dot_prod_simd_4(a: &[f32], b: &[f32]) -> f32 {\n+    let mut sum = a\n+        .array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .map(|(a, b)| a * b)\n+        .fold(f32x4::splat(0.0), std::ops::Add::add)\n+        .reduce_sum();\n+    let remain = a.len() - (a.len() % 4);\n+    sum += a[remain..]\n+        .iter()\n+        .zip(&b[remain..])\n+        .map(|(a, b)| a * b)\n+        .sum::<f32>();\n+    sum\n+}\n+\n+// This version allocates a single `XMM` register for accumulation, and the folds don't allocate on top of that.\n+// Notice the the use of `mul_add`, which can do a multiply and an add operation ber iteration.\n+pub fn dot_prod_simd_5(a: &[f32], b: &[f32]) -> f32 {\n+    a.array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .fold(f32x4::splat(0.), |acc, (a, b)| a.mul_add(b, acc))\n+        .reduce_sum()\n+}\n+\n+fn main() {\n+    // Empty main to make cargo happy\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn smoke_test() {\n+        use super::*;\n+        let a: Vec<f32> = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];\n+        let b: Vec<f32> = vec![-8.0, -7.0, -6.0, -5.0, 4.0, 3.0, 2.0, 1.0];\n+        let x: Vec<f32> = [0.5; 1003].to_vec();\n+        let y: Vec<f32> = [2.0; 1003].to_vec();\n+\n+        // Basic check\n+        assert_eq!(0.0, dot_prod_scalar_0(&a, &b));\n+        assert_eq!(0.0, dot_prod_scalar_1(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_0(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_1(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_2(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_3(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_4(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_5(&a, &b));\n+\n+        // We can handle vectors that are non-multiples of 4\n+        assert_eq!(1003.0, dot_prod_simd_3(&x, &y));\n+    }\n+}"}, {"sha": "23f121c46197c58d39b851015256112469943253", "filename": "library/portable-simd/crates/core_simd/src/alias.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Falias.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -0,0 +1,227 @@\n+macro_rules! number {\n+    { 1 } => { \"one\" };\n+    { 2 } => { \"two\" };\n+    { 4 } => { \"four\" };\n+    { 8 } => { \"eight\" };\n+    { $x:literal } => { stringify!($x) };\n+}\n+\n+macro_rules! plural {\n+    { 1 } => { \"\" };\n+    { $x:literal } => { \"s\" };\n+}\n+\n+macro_rules! alias {\n+    {\n+        $(\n+            $element_ty:ty = {\n+                $($alias:ident $num_elements:tt)*\n+            }\n+        )*\n+    } => {\n+        $(\n+            $(\n+            #[doc = concat!(\"A SIMD vector with \", number!($num_elements), \" element\", plural!($num_elements), \" of type [`\", stringify!($element_ty), \"`].\")]\n+            #[allow(non_camel_case_types)]\n+            pub type $alias = $crate::simd::Simd<$element_ty, $num_elements>;\n+            )*\n+        )*\n+    }\n+}\n+\n+macro_rules! mask_alias {\n+    {\n+        $(\n+            $element_ty:ty : $size:literal = {\n+                $($alias:ident $num_elements:tt)*\n+            }\n+        )*\n+    } => {\n+        $(\n+            $(\n+            #[doc = concat!(\"A SIMD mask with \", number!($num_elements), \" element\", plural!($num_elements), \" for vectors with \", $size, \" element types.\")]\n+            ///\n+            #[doc = concat!(\n+                \"The layout of this type is unspecified, and may change between platforms and/or Rust versions, and code should not assume that it is equivalent to `[\",\n+                stringify!($element_ty), \"; \", $num_elements, \"]`.\"\n+            )]\n+            #[allow(non_camel_case_types)]\n+            pub type $alias = $crate::simd::Mask<$element_ty, $num_elements>;\n+            )*\n+        )*\n+    }\n+}\n+\n+alias! {\n+    i8 = {\n+        i8x1 1\n+        i8x2 2\n+        i8x4 4\n+        i8x8 8\n+        i8x16 16\n+        i8x32 32\n+        i8x64 64\n+    }\n+\n+    i16 = {\n+        i16x1 1\n+        i16x2 2\n+        i16x4 4\n+        i16x8 8\n+        i16x16 16\n+        i16x32 32\n+        i16x64 64\n+    }\n+\n+    i32 = {\n+        i32x1 1\n+        i32x2 2\n+        i32x4 4\n+        i32x8 8\n+        i32x16 16\n+        i32x32 32\n+        i32x64 64\n+    }\n+\n+    i64 = {\n+        i64x1 1\n+        i64x2 2\n+        i64x4 4\n+        i64x8 8\n+        i64x16 16\n+        i64x32 32\n+        i64x64 64\n+    }\n+\n+    isize = {\n+        isizex1 1\n+        isizex2 2\n+        isizex4 4\n+        isizex8 8\n+        isizex16 16\n+        isizex32 32\n+        isizex64 64\n+    }\n+\n+    u8 = {\n+        u8x1 1\n+        u8x2 2\n+        u8x4 4\n+        u8x8 8\n+        u8x16 16\n+        u8x32 32\n+        u8x64 64\n+    }\n+\n+    u16 = {\n+        u16x1 1\n+        u16x2 2\n+        u16x4 4\n+        u16x8 8\n+        u16x16 16\n+        u16x32 32\n+        u16x64 64\n+    }\n+\n+    u32 = {\n+        u32x1 1\n+        u32x2 2\n+        u32x4 4\n+        u32x8 8\n+        u32x16 16\n+        u32x32 32\n+        u32x64 64\n+    }\n+\n+    u64 = {\n+        u64x1 1\n+        u64x2 2\n+        u64x4 4\n+        u64x8 8\n+        u64x16 16\n+        u64x32 32\n+        u64x64 64\n+    }\n+\n+    usize = {\n+        usizex1 1\n+        usizex2 2\n+        usizex4 4\n+        usizex8 8\n+        usizex16 16\n+        usizex32 32\n+        usizex64 64\n+    }\n+\n+    f32 = {\n+        f32x1 1\n+        f32x2 2\n+        f32x4 4\n+        f32x8 8\n+        f32x16 16\n+        f32x32 32\n+        f32x64 64\n+    }\n+\n+    f64 = {\n+        f64x1 1\n+        f64x2 2\n+        f64x4 4\n+        f64x8 8\n+        f64x16 16\n+        f64x32 32\n+        f64x64 64\n+    }\n+}\n+\n+mask_alias! {\n+    i8 : \"8-bit\" = {\n+        mask8x1 1\n+        mask8x2 2\n+        mask8x4 4\n+        mask8x8 8\n+        mask8x16 16\n+        mask8x32 32\n+        mask8x64 64\n+    }\n+\n+    i16 : \"16-bit\" = {\n+        mask16x1 1\n+        mask16x2 2\n+        mask16x4 4\n+        mask16x8 8\n+        mask16x16 16\n+        mask16x32 32\n+        mask16x64 64\n+    }\n+\n+    i32 : \"32-bit\" = {\n+        mask32x1 1\n+        mask32x2 2\n+        mask32x4 4\n+        mask32x8 8\n+        mask32x16 16\n+        mask32x32 32\n+        mask32x64 64\n+    }\n+\n+    i64 : \"64-bit\" = {\n+        mask64x1 1\n+        mask64x2 2\n+        mask64x4 4\n+        mask64x8 8\n+        mask64x16 16\n+        mask64x32 32\n+        mask64x64 64\n+    }\n+\n+    isize : \"pointer-sized\" = {\n+        masksizex1 1\n+        masksizex2 2\n+        masksizex4 4\n+        masksizex8 8\n+        masksizex16 16\n+        masksizex32 32\n+        masksizex64 64\n+    }\n+}"}, {"sha": "65a3f845ffca74022127bf319ffccf5c77bacf38", "filename": "library/portable-simd/crates/core_simd/src/cast.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcast.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -0,0 +1,55 @@\n+use crate::simd::SimdElement;\n+\n+/// Supporting trait for `Simd::cast`.  Typically doesn't need to be used directly.\n+///\n+/// # Safety\n+/// Implementing this trait asserts that the type is a valid vector element for the `simd_cast` or\n+/// `simd_as` intrinsics.\n+pub unsafe trait SimdCast: SimdElement {}\n+\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i8 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i16 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i32 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i64 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for isize {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u8 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u16 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u32 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u64 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for usize {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for f32 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for f64 {}\n+\n+/// Supporting trait for `Simd::cast_ptr`.  Typically doesn't need to be used directly.\n+///\n+/// # Safety\n+/// Implementing this trait asserts that the type is a valid vector element for the `simd_cast_ptr`\n+/// intrinsic.\n+pub unsafe trait SimdCastPtr<T> {}\n+\n+// Safety: pointers can be cast to other pointer types\n+unsafe impl<T, U> SimdCastPtr<T> for *const U\n+where\n+    U: core::ptr::Pointee,\n+    T: core::ptr::Pointee<Metadata = U::Metadata>,\n+{\n+}\n+// Safety: pointers can be cast to other pointer types\n+unsafe impl<T, U> SimdCastPtr<T> for *mut U\n+where\n+    U: core::ptr::Pointee,\n+    T: core::ptr::Pointee<Metadata = U::Metadata>,\n+{\n+}"}, {"sha": "dc7f52a4d576cf1d31f4841c60c974791cf1bff8", "filename": "library/portable-simd/crates/core_simd/src/elements.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,11 +1,15 @@\n+mod const_ptr;\n mod float;\n mod int;\n+mod mut_ptr;\n mod uint;\n \n mod sealed {\n     pub trait Sealed {}\n }\n \n+pub use const_ptr::*;\n pub use float::*;\n pub use int::*;\n+pub use mut_ptr::*;\n pub use uint::*;"}, {"sha": "0ef9802b5e219c43294157dee2752adb29279e94", "filename": "library/portable-simd/crates/core_simd/src/elements/const_ptr.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -0,0 +1,141 @@\n+use super::sealed::Sealed;\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+\n+/// Operations on SIMD vectors of constant pointers.\n+pub trait SimdConstPtr: Copy + Sealed {\n+    /// Vector of `usize` with the same number of lanes.\n+    type Usize;\n+\n+    /// Vector of `isize` with the same number of lanes.\n+    type Isize;\n+\n+    /// Vector of mutable pointers to the same type.\n+    type MutPtr;\n+\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Returns `true` for each lane that is null.\n+    fn is_null(self) -> Self::Mask;\n+\n+    /// Changes constness without changing the type.\n+    ///\n+    /// Equivalent to calling [`pointer::cast_mut`] on each lane.\n+    fn cast_mut(self) -> Self::MutPtr;\n+\n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This method discards pointer semantic metadata, so the result cannot be\n+    /// directly cast into a valid pointer.\n+    ///\n+    /// This method semantically discards *provenance* and\n+    /// *address-space* information. To properly restore that information, use [`Self::with_addr`].\n+    ///\n+    /// Equivalent to calling [`pointer::addr`] on each lane.\n+    fn addr(self) -> Self::Usize;\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as a cast, but copies the *address-space* and\n+    /// *provenance* of `self` to the new pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::with_addr`] on each lane.\n+    fn with_addr(self, addr: Self::Usize) -> Self;\n+\n+    /// Gets the \"address\" portion of the pointer, and \"exposes\" the provenance part for future use\n+    /// in [`Self::from_exposed_addr`].\n+    fn expose_addr(self) -> Self::Usize;\n+\n+    /// Convert an address back to a pointer, picking up a previously \"exposed\" provenance.\n+    ///\n+    /// Equivalent to calling [`core::ptr::from_exposed_addr`] on each lane.\n+    fn from_exposed_addr(addr: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_offset`] on each lane.\n+    fn wrapping_offset(self, offset: Self::Isize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_add`] on each lane.\n+    fn wrapping_add(self, count: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_sub`] on each lane.\n+    fn wrapping_sub(self, count: Self::Usize) -> Self;\n+}\n+\n+impl<T, const LANES: usize> Sealed for Simd<*const T, LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+\n+impl<T, const LANES: usize> SimdConstPtr for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Usize = Simd<usize, LANES>;\n+    type Isize = Simd<isize, LANES>;\n+    type MutPtr = Simd<*mut T, LANES>;\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn is_null(self) -> Self::Mask {\n+        Simd::splat(core::ptr::null()).simd_eq(self)\n+    }\n+\n+    #[inline]\n+    fn cast_mut(self) -> Self::MutPtr {\n+        self.cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn addr(self) -> Self::Usize {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n+        // provenance).\n+        unsafe { core::mem::transmute_copy(&self) }\n+    }\n+\n+    #[inline]\n+    fn with_addr(self, addr: Self::Usize) -> Self {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        //\n+        // In the mean-time, this operation is defined to be \"as if\" it was\n+        // a wrapping_offset, so we can emulate it as such. This should properly\n+        // restore pointer provenance even under today's compiler.\n+        self.cast_ptr::<*const u8>()\n+            .wrapping_offset(addr.cast::<isize>() - self.addr().cast::<isize>())\n+            .cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn expose_addr(self) -> Self::Usize {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_expose_addr(self) }\n+    }\n+\n+    #[inline]\n+    fn from_exposed_addr(addr: Self::Usize) -> Self {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_from_exposed_addr(addr) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_offset(self, count: Self::Isize) -> Self {\n+        // Safety: simd_arith_offset takes a vector of pointers and a vector of offsets\n+        unsafe { intrinsics::simd_arith_offset(self, count) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_add(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(count.cast())\n+    }\n+\n+    #[inline]\n+    fn wrapping_sub(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(-count.cast::<isize>())\n+    }\n+}"}, {"sha": "d87986b4a091cea9be41e186582725fc98465500", "filename": "library/portable-simd/crates/core_simd/src/elements/mut_ptr.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -0,0 +1,136 @@\n+use super::sealed::Sealed;\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+\n+/// Operations on SIMD vectors of mutable pointers.\n+pub trait SimdMutPtr: Copy + Sealed {\n+    /// Vector of `usize` with the same number of lanes.\n+    type Usize;\n+\n+    /// Vector of `isize` with the same number of lanes.\n+    type Isize;\n+\n+    /// Vector of constant pointers to the same type.\n+    type ConstPtr;\n+\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Returns `true` for each lane that is null.\n+    fn is_null(self) -> Self::Mask;\n+\n+    /// Changes constness without changing the type.\n+    ///\n+    /// Equivalent to calling [`pointer::cast_const`] on each lane.\n+    fn cast_const(self) -> Self::ConstPtr;\n+\n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This method discards pointer semantic metadata, so the result cannot be\n+    /// directly cast into a valid pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::addr`] on each lane.\n+    fn addr(self) -> Self::Usize;\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as a cast, but copies the *address-space* and\n+    /// *provenance* of `self` to the new pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::with_addr`] on each lane.\n+    fn with_addr(self, addr: Self::Usize) -> Self;\n+\n+    /// Gets the \"address\" portion of the pointer, and \"exposes\" the provenance part for future use\n+    /// in [`Self::from_exposed_addr`].\n+    fn expose_addr(self) -> Self::Usize;\n+\n+    /// Convert an address back to a pointer, picking up a previously \"exposed\" provenance.\n+    ///\n+    /// Equivalent to calling [`core::ptr::from_exposed_addr_mut`] on each lane.\n+    fn from_exposed_addr(addr: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_offset`] on each lane.\n+    fn wrapping_offset(self, offset: Self::Isize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_add`] on each lane.\n+    fn wrapping_add(self, count: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_sub`] on each lane.\n+    fn wrapping_sub(self, count: Self::Usize) -> Self;\n+}\n+\n+impl<T, const LANES: usize> Sealed for Simd<*mut T, LANES> where LaneCount<LANES>: SupportedLaneCount\n+{}\n+\n+impl<T, const LANES: usize> SimdMutPtr for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Usize = Simd<usize, LANES>;\n+    type Isize = Simd<isize, LANES>;\n+    type ConstPtr = Simd<*const T, LANES>;\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn is_null(self) -> Self::Mask {\n+        Simd::splat(core::ptr::null_mut()).simd_eq(self)\n+    }\n+\n+    #[inline]\n+    fn cast_const(self) -> Self::ConstPtr {\n+        self.cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn addr(self) -> Self::Usize {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n+        // provenance).\n+        unsafe { core::mem::transmute_copy(&self) }\n+    }\n+\n+    #[inline]\n+    fn with_addr(self, addr: Self::Usize) -> Self {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        //\n+        // In the mean-time, this operation is defined to be \"as if\" it was\n+        // a wrapping_offset, so we can emulate it as such. This should properly\n+        // restore pointer provenance even under today's compiler.\n+        self.cast_ptr::<*mut u8>()\n+            .wrapping_offset(addr.cast::<isize>() - self.addr().cast::<isize>())\n+            .cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn expose_addr(self) -> Self::Usize {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_expose_addr(self) }\n+    }\n+\n+    #[inline]\n+    fn from_exposed_addr(addr: Self::Usize) -> Self {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_from_exposed_addr(addr) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_offset(self, count: Self::Isize) -> Self {\n+        // Safety: simd_arith_offset takes a vector of pointers and a vector of offsets\n+        unsafe { intrinsics::simd_arith_offset(self, count) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_add(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(count.cast())\n+    }\n+\n+    #[inline]\n+    fn wrapping_sub(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(-count.cast::<isize>())\n+    }\n+}"}, {"sha": "80763c07272781d7e370fa788249e0b26382dded", "filename": "library/portable-simd/crates/core_simd/src/eq.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Feq.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,4 +1,6 @@\n-use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdConstPtr, SimdElement, SimdMutPtr, SupportedLaneCount,\n+};\n \n /// Parallel `PartialEq`.\n pub trait SimdPartialEq {\n@@ -71,3 +73,37 @@ macro_rules! impl_mask {\n }\n \n impl_mask! { i8, i16, i32, i64, isize }\n+\n+impl<T, const LANES: usize> SimdPartialEq for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn simd_eq(self, other: Self) -> Self::Mask {\n+        self.addr().simd_eq(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ne(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ne(other.addr())\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdPartialEq for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn simd_eq(self, other: Self) -> Self::Mask {\n+        self.addr().simd_eq(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ne(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ne(other.addr())\n+    }\n+}"}, {"sha": "b7317969cbb49ad994408227a5d8cdeadda3618e", "filename": "library/portable-simd/crates/core_simd/src/fmt.rs", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ffmt.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,39 +1,21 @@\n use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n use core::fmt;\n \n-macro_rules! impl_fmt_trait {\n-    { $($trait:ident,)* } => {\n-        $(\n-            impl<T, const LANES: usize> fmt::$trait for Simd<T, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-                T: SimdElement + fmt::$trait,\n-            {\n-                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                    #[repr(transparent)]\n-                    struct Wrapper<'a, T: fmt::$trait>(&'a T);\n-\n-                    impl<T: fmt::$trait> fmt::Debug for Wrapper<'_, T> {\n-                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                            self.0.fmt(f)\n-                        }\n-                    }\n-\n-                    f.debug_list()\n-                        .entries(self.as_array().iter().map(|x| Wrapper(x)))\n-                        .finish()\n-                }\n-            }\n-        )*\n+impl<T, const LANES: usize> fmt::Debug for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + fmt::Debug,\n+{\n+    /// A `Simd<T, N>` has a debug format like the one for `[T]`:\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd::Simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd::Simd;\n+    /// let floats = Simd::<f32, 4>::splat(-1.0);\n+    /// assert_eq!(format!(\"{:?}\", [-1.0; 4]), format!(\"{:?}\", floats));\n+    /// ```\n+    #[inline]\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        <[T] as fmt::Debug>::fmt(self.as_array(), f)\n     }\n }\n-\n-impl_fmt_trait! {\n-    Debug,\n-    Binary,\n-    LowerExp,\n-    UpperExp,\n-    Octal,\n-    LowerHex,\n-    UpperHex,\n-}"}, {"sha": "dd6698e2ba56cac6796ebf8d9598aaf453e34bfb", "filename": "library/portable-simd/crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -61,9 +61,6 @@ extern \"platform-intrinsic\" {\n     /// xor\n     pub(crate) fn simd_xor<T>(x: T, y: T) -> T;\n \n-    /// getelementptr (without inbounds)\n-    pub(crate) fn simd_arith_offset<T, U>(ptrs: T, offsets: U) -> T;\n-\n     /// fptoui/fptosi/uitofp/sitofp\n     /// casting floats to integers is truncating, so it is safe to convert values like e.g. 1.5\n     /// but the truncated value must fit in the target type or the result is poison.\n@@ -150,4 +147,17 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_select<M, T>(m: M, yes: T, no: T) -> T;\n     #[allow(unused)]\n     pub(crate) fn simd_select_bitmask<M, T>(m: M, yes: T, no: T) -> T;\n+\n+    /// getelementptr (without inbounds)\n+    /// equivalent to wrapping_offset\n+    pub(crate) fn simd_arith_offset<T, U>(ptr: T, offset: U) -> T;\n+\n+    /// equivalent to `T as U` semantics, specifically for pointers\n+    pub(crate) fn simd_cast_ptr<T, U>(ptr: T) -> U;\n+\n+    /// expose a pointer as an address\n+    pub(crate) fn simd_expose_addr<T, U>(ptr: T) -> U;\n+\n+    /// convert an exposed address back to a pointer\n+    pub(crate) fn simd_from_exposed_addr<T, U>(addr: T) -> U;\n }"}, {"sha": "2b91eb9e80047d313421dd79c7b8908ddebc6e37", "filename": "library/portable-simd/crates/core_simd/src/lane_count.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -23,24 +23,20 @@ pub trait SupportedLaneCount: Sealed {\n \n impl<const LANES: usize> Sealed for LaneCount<LANES> {}\n \n-impl SupportedLaneCount for LaneCount<1> {\n-    type BitMask = [u8; 1];\n-}\n-impl SupportedLaneCount for LaneCount<2> {\n-    type BitMask = [u8; 1];\n-}\n-impl SupportedLaneCount for LaneCount<4> {\n-    type BitMask = [u8; 1];\n-}\n-impl SupportedLaneCount for LaneCount<8> {\n-    type BitMask = [u8; 1];\n-}\n-impl SupportedLaneCount for LaneCount<16> {\n-    type BitMask = [u8; 2];\n-}\n-impl SupportedLaneCount for LaneCount<32> {\n-    type BitMask = [u8; 4];\n-}\n-impl SupportedLaneCount for LaneCount<64> {\n-    type BitMask = [u8; 8];\n+macro_rules! supported_lane_count {\n+    ($($lanes:literal),+) => {\n+        $(\n+            impl SupportedLaneCount for LaneCount<$lanes> {\n+                type BitMask = [u8; ($lanes + 7) / 8];\n+            }\n+        )+\n+    };\n }\n+\n+supported_lane_count!(1, 2, 4, 8, 16, 32, 64);\n+#[cfg(feature = \"all_lane_counts\")]\n+supported_lane_count!(\n+    3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+    31, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,\n+    56, 57, 58, 59, 60, 61, 62, 63\n+);"}, {"sha": "e5307de2155209e4b4bd58f6dfe70cee1c55daae", "filename": "library/portable-simd/crates/core_simd/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,13 +1,18 @@\n #![no_std]\n #![feature(\n+    const_refs_to_cell,\n+    const_maybe_uninit_as_mut_ptr,\n+    const_mut_refs,\n     convert_float_to_int,\n     decl_macro,\n     intra_doc_pointers,\n     platform_intrinsics,\n     repr_simd,\n     simd_ffi,\n     staged_api,\n-    stdsimd\n+    stdsimd,\n+    strict_provenance,\n+    ptr_metadata\n )]\n #![cfg_attr(feature = \"generic_const_exprs\", feature(generic_const_exprs))]\n #![cfg_attr(feature = \"generic_const_exprs\", allow(incomplete_features))]\n@@ -19,4 +24,3 @@\n #[path = \"mod.rs\"]\n mod core_simd;\n pub use self::core_simd::simd;\n-pub use simd::*;"}, {"sha": "e58df80fca8b54c87e0bbbf65ffc4c363dfac352", "filename": "library/portable-simd/crates/core_simd/src/masks.rs", "status": "modified", "additions": 12, "deletions": 55, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -55,13 +55,15 @@ pub unsafe trait MaskElement: SimdElement + Sealed {}\n macro_rules! impl_element {\n     { $ty:ty } => {\n         impl Sealed for $ty {\n+            #[inline]\n             fn valid<const LANES: usize>(value: Simd<Self, LANES>) -> bool\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n                 (value.simd_eq(Simd::splat(0 as _)) | value.simd_eq(Simd::splat(-1 as _))).all()\n             }\n \n+            #[inline]\n             fn eq(self, other: Self) -> bool { self == other }\n \n             const TRUE: Self = -1;\n@@ -83,7 +85,9 @@ impl_element! { isize }\n ///\n /// Masks represent boolean inclusion/exclusion on a per-lane basis.\n ///\n-/// The layout of this type is unspecified.\n+/// The layout of this type is unspecified, and may change between platforms\n+/// and/or Rust versions, and code should not assume that it is equivalent to\n+/// `[T; LANES]`.\n #[repr(transparent)]\n pub struct Mask<T, const LANES: usize>(mask_impl::Mask<T, LANES>)\n where\n@@ -102,6 +106,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn clone(&self) -> Self {\n         *self\n     }\n@@ -113,11 +118,13 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     /// Construct a mask by setting all lanes to the given value.\n+    #[inline]\n     pub fn splat(value: bool) -> Self {\n         Self(mask_impl::Mask::splat(value))\n     }\n \n     /// Converts an array of bools to a SIMD mask.\n+    #[inline]\n     pub fn from_array(array: [bool; LANES]) -> Self {\n         // SAFETY: Rust's bool has a layout of 1 byte (u8) with a value of\n         //     true:    0b_0000_0001\n@@ -134,6 +141,7 @@ where\n     }\n \n     /// Converts a SIMD mask to an array of bools.\n+    #[inline]\n     pub fn to_array(self) -> [bool; LANES] {\n         // This follows mostly the same logic as from_array.\n         // SAFETY: Rust's bool has a layout of 1 byte (u8) with a value of\n@@ -261,6 +269,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn from(array: [bool; LANES]) -> Self {\n         Self::from_array(array)\n     }\n@@ -271,6 +280,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn from(vector: Mask<T, LANES>) -> Self {\n         vector.to_array()\n     }\n@@ -520,67 +530,14 @@ where\n     }\n }\n \n-/// A mask for SIMD vectors with eight elements of 8 bits.\n-pub type mask8x8 = Mask<i8, 8>;\n-\n-/// A mask for SIMD vectors with 16 elements of 8 bits.\n-pub type mask8x16 = Mask<i8, 16>;\n-\n-/// A mask for SIMD vectors with 32 elements of 8 bits.\n-pub type mask8x32 = Mask<i8, 32>;\n-\n-/// A mask for SIMD vectors with 64 elements of 8 bits.\n-pub type mask8x64 = Mask<i8, 64>;\n-\n-/// A mask for SIMD vectors with four elements of 16 bits.\n-pub type mask16x4 = Mask<i16, 4>;\n-\n-/// A mask for SIMD vectors with eight elements of 16 bits.\n-pub type mask16x8 = Mask<i16, 8>;\n-\n-/// A mask for SIMD vectors with 16 elements of 16 bits.\n-pub type mask16x16 = Mask<i16, 16>;\n-\n-/// A mask for SIMD vectors with 32 elements of 16 bits.\n-pub type mask16x32 = Mask<i16, 32>;\n-\n-/// A mask for SIMD vectors with two elements of 32 bits.\n-pub type mask32x2 = Mask<i32, 2>;\n-\n-/// A mask for SIMD vectors with four elements of 32 bits.\n-pub type mask32x4 = Mask<i32, 4>;\n-\n-/// A mask for SIMD vectors with eight elements of 32 bits.\n-pub type mask32x8 = Mask<i32, 8>;\n-\n-/// A mask for SIMD vectors with 16 elements of 32 bits.\n-pub type mask32x16 = Mask<i32, 16>;\n-\n-/// A mask for SIMD vectors with two elements of 64 bits.\n-pub type mask64x2 = Mask<i64, 2>;\n-\n-/// A mask for SIMD vectors with four elements of 64 bits.\n-pub type mask64x4 = Mask<i64, 4>;\n-\n-/// A mask for SIMD vectors with eight elements of 64 bits.\n-pub type mask64x8 = Mask<i64, 8>;\n-\n-/// A mask for SIMD vectors with two elements of pointer width.\n-pub type masksizex2 = Mask<isize, 2>;\n-\n-/// A mask for SIMD vectors with four elements of pointer width.\n-pub type masksizex4 = Mask<isize, 4>;\n-\n-/// A mask for SIMD vectors with eight elements of pointer width.\n-pub type masksizex8 = Mask<isize, 8>;\n-\n macro_rules! impl_from {\n     { $from:ty  => $($to:ty),* } => {\n         $(\n         impl<const LANES: usize> From<Mask<$from, LANES>> for Mask<$to, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n+            #[inline]\n             fn from(value: Mask<$from, LANES>) -> Self {\n                 value.cast()\n             }"}, {"sha": "20465ba9b07ec72381c89fbfff087f94d0ec2069", "filename": "library/portable-simd/crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -26,6 +26,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn clone(&self) -> Self {\n         *self\n     }\n@@ -36,6 +37,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.0.as_ref() == other.0.as_ref()\n     }\n@@ -46,6 +48,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n         self.0.as_ref().partial_cmp(other.0.as_ref())\n     }\n@@ -63,6 +66,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n         self.0.as_ref().cmp(other.0.as_ref())\n     }"}, {"sha": "1d13c45b8e70bb26f7c8b2dc8336015a323bcbbb", "filename": "library/portable-simd/crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -37,6 +37,7 @@ where\n     T: MaskElement + PartialEq,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.0.eq(&other.0)\n     }\n@@ -47,6 +48,7 @@ where\n     T: MaskElement + PartialOrd,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n         self.0.partial_cmp(&other.0)\n     }\n@@ -64,6 +66,7 @@ where\n     T: MaskElement + Ord,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n         self.0.cmp(&other.0)\n     }\n@@ -262,6 +265,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn from(value: Mask<T, LANES>) -> Self {\n         value.0\n     }"}, {"sha": "fc7d6b781f2f5f50bc3abbc7ff73702e5e3bc774", "filename": "library/portable-simd/crates/core_simd/src/masks/to_bitmask.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -48,10 +48,12 @@ macro_rules! impl_integer_intrinsic {\n         impl<T: MaskElement> ToBitMask for Mask<T, $lanes> {\n             type BitMask = $int;\n \n+            #[inline]\n             fn to_bitmask(self) -> $int {\n                 self.0.to_bitmask_integer()\n             }\n \n+            #[inline]\n             fn from_bitmask(bitmask: $int) -> Self {\n                 Self(mask_impl::Mask::from_bitmask_integer(bitmask))\n             }\n@@ -83,10 +85,12 @@ where\n {\n     const BYTES: usize = bitmask_len(LANES);\n \n+    #[inline]\n     fn to_bitmask_array(self) -> [u8; Self::BYTES] {\n         self.0.to_bitmask_array()\n     }\n \n+    #[inline]\n     fn from_bitmask_array(bitmask: [u8; Self::BYTES]) -> Self {\n         Mask(mask_impl::Mask::from_bitmask_array(bitmask))\n     }"}, {"sha": "35c659b7a429a6b151220f262dd1cc2072dcca41", "filename": "library/portable-simd/crates/core_simd/src/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -6,6 +6,8 @@ pub(crate) mod intrinsics;\n #[cfg(feature = \"generic_const_exprs\")]\n mod to_bytes;\n \n+mod alias;\n+mod cast;\n mod elements;\n mod eq;\n mod fmt;\n@@ -15,18 +17,22 @@ mod masks;\n mod ops;\n mod ord;\n mod select;\n+mod swizzle_dyn;\n mod vector;\n mod vendor;\n \n #[doc = include_str!(\"core_simd_docs.md\")]\n pub mod simd {\n     pub(crate) use crate::core_simd::intrinsics;\n \n+    pub use crate::core_simd::alias::*;\n+    pub use crate::core_simd::cast::*;\n     pub use crate::core_simd::elements::*;\n     pub use crate::core_simd::eq::*;\n     pub use crate::core_simd::lane_count::{LaneCount, SupportedLaneCount};\n     pub use crate::core_simd::masks::*;\n     pub use crate::core_simd::ord::*;\n     pub use crate::core_simd::swizzle::*;\n+    pub use crate::core_simd::swizzle_dyn::*;\n     pub use crate::core_simd::vector::*;\n }"}, {"sha": "1ae9cd061fb2d23f731655bfc82e736cdbe20ec9", "filename": "library/portable-simd/crates/core_simd/src/ord.rs", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ford.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,4 +1,6 @@\n-use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdConstPtr, SimdMutPtr, SimdPartialEq, SupportedLaneCount,\n+};\n \n /// Parallel `PartialOrd`.\n pub trait SimdPartialOrd: SimdPartialEq {\n@@ -211,3 +213,101 @@ macro_rules! impl_mask {\n }\n \n impl_mask! { i8, i16, i32, i64, isize }\n+\n+impl<T, const LANES: usize> SimdPartialOrd for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_lt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_lt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_le(self, other: Self) -> Self::Mask {\n+        self.addr().simd_le(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_gt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_gt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ge(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ge(other.addr())\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdOrd for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_max(self, other: Self) -> Self {\n+        self.simd_lt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_min(self, other: Self) -> Self {\n+        self.simd_gt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self {\n+        assert!(\n+            min.simd_le(max).all(),\n+            \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+        );\n+        self.simd_max(min).simd_min(max)\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdPartialOrd for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_lt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_lt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_le(self, other: Self) -> Self::Mask {\n+        self.addr().simd_le(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_gt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_gt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ge(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ge(other.addr())\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdOrd for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_max(self, other: Self) -> Self {\n+        self.simd_lt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_min(self, other: Self) -> Self {\n+        self.simd_gt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self {\n+        assert!(\n+            min.simd_le(max).all(),\n+            \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+        );\n+        self.simd_max(min).simd_min(max)\n+    }\n+}"}, {"sha": "68f20516cf5bca46e4dccbe363fa538ed0dc53a3", "filename": "library/portable-simd/crates/core_simd/src/swizzle.rs", "status": "modified", "additions": 27, "deletions": 45, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -265,16 +265,13 @@ where\n \n     /// Interleave two vectors.\n     ///\n-    /// Produces two vectors with lanes taken alternately from `self` and `other`.\n+    /// The resulting vectors contain lanes taken alternatively from `self` and `other`, first\n+    /// filling the first result, and then the second.\n     ///\n-    /// The first result contains the first `LANES / 2` lanes from `self` and `other`,\n-    /// alternating, starting with the first lane of `self`.\n-    ///\n-    /// The second result contains the last `LANES / 2` lanes from `self` and `other`,\n-    /// alternating, starting with the lane `LANES / 2` from the start of `self`.\n+    /// The reverse of this operation is [`Simd::deinterleave`].\n     ///\n     /// ```\n-    /// #![feature(portable_simd)]\n+    /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let a = Simd::from_array([0, 1, 2, 3]);\n     /// let b = Simd::from_array([4, 5, 6, 7]);\n@@ -285,29 +282,17 @@ where\n     #[inline]\n     #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn interleave(self, other: Self) -> (Self, Self) {\n-        const fn lo<const LANES: usize>() -> [Which; LANES] {\n-            let mut idx = [Which::First(0); LANES];\n-            let mut i = 0;\n-            while i < LANES {\n-                let offset = i / 2;\n-                idx[i] = if i % 2 == 0 {\n-                    Which::First(offset)\n-                } else {\n-                    Which::Second(offset)\n-                };\n-                i += 1;\n-            }\n-            idx\n-        }\n-        const fn hi<const LANES: usize>() -> [Which; LANES] {\n+        const fn interleave<const LANES: usize>(high: bool) -> [Which; LANES] {\n             let mut idx = [Which::First(0); LANES];\n             let mut i = 0;\n             while i < LANES {\n-                let offset = (LANES + i) / 2;\n-                idx[i] = if i % 2 == 0 {\n-                    Which::First(offset)\n+                // Treat the source as a concatenated vector\n+                let dst_index = if high { i + LANES } else { i };\n+                let src_index = dst_index / 2 + (dst_index % 2) * LANES;\n+                idx[i] = if src_index < LANES {\n+                    Which::First(src_index)\n                 } else {\n-                    Which::Second(offset)\n+                    Which::Second(src_index % LANES)\n                 };\n                 i += 1;\n             }\n@@ -318,11 +303,11 @@ where\n         struct Hi;\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Lo {\n-            const INDEX: [Which; LANES] = lo::<LANES>();\n+            const INDEX: [Which; LANES] = interleave::<LANES>(false);\n         }\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Hi {\n-            const INDEX: [Which; LANES] = hi::<LANES>();\n+            const INDEX: [Which; LANES] = interleave::<LANES>(true);\n         }\n \n         (Lo::swizzle2(self, other), Hi::swizzle2(self, other))\n@@ -336,8 +321,10 @@ where\n     /// The second result takes every other lane of `self` and then `other`, starting with\n     /// the second lane.\n     ///\n+    /// The reverse of this operation is [`Simd::interleave`].\n+    ///\n     /// ```\n-    /// #![feature(portable_simd)]\n+    /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let a = Simd::from_array([0, 4, 1, 5]);\n     /// let b = Simd::from_array([2, 6, 3, 7]);\n@@ -348,22 +335,17 @@ where\n     #[inline]\n     #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn deinterleave(self, other: Self) -> (Self, Self) {\n-        const fn even<const LANES: usize>() -> [Which; LANES] {\n-            let mut idx = [Which::First(0); LANES];\n-            let mut i = 0;\n-            while i < LANES / 2 {\n-                idx[i] = Which::First(2 * i);\n-                idx[i + LANES / 2] = Which::Second(2 * i);\n-                i += 1;\n-            }\n-            idx\n-        }\n-        const fn odd<const LANES: usize>() -> [Which; LANES] {\n+        const fn deinterleave<const LANES: usize>(second: bool) -> [Which; LANES] {\n             let mut idx = [Which::First(0); LANES];\n             let mut i = 0;\n-            while i < LANES / 2 {\n-                idx[i] = Which::First(2 * i + 1);\n-                idx[i + LANES / 2] = Which::Second(2 * i + 1);\n+            while i < LANES {\n+                // Treat the source as a concatenated vector\n+                let src_index = i * 2 + second as usize;\n+                idx[i] = if src_index < LANES {\n+                    Which::First(src_index)\n+                } else {\n+                    Which::Second(src_index % LANES)\n+                };\n                 i += 1;\n             }\n             idx\n@@ -373,11 +355,11 @@ where\n         struct Odd;\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Even {\n-            const INDEX: [Which; LANES] = even::<LANES>();\n+            const INDEX: [Which; LANES] = deinterleave::<LANES>(false);\n         }\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Odd {\n-            const INDEX: [Which; LANES] = odd::<LANES>();\n+            const INDEX: [Which; LANES] = deinterleave::<LANES>(true);\n         }\n \n         (Even::swizzle2(self, other), Odd::swizzle2(self, other))"}, {"sha": "6065d6459378e9fab7b2f05cfa0b8741d2dd994c", "filename": "library/portable-simd/crates/core_simd/src/swizzle_dyn.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle_dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle_dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle_dyn.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -0,0 +1,157 @@\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use core::mem;\n+\n+impl<const N: usize> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    /// Swizzle a vector of bytes according to the index vector.\n+    /// Indices within range select the appropriate byte.\n+    /// Indices \"out of bounds\" instead select 0.\n+    ///\n+    /// Note that the current implementation is selected during build-time\n+    /// of the standard library, so `cargo build -Zbuild-std` may be necessary\n+    /// to unlock better performance, especially for larger vectors.\n+    /// A planned compiler improvement will enable using `#[target_feature]` instead.\n+    #[inline]\n+    pub fn swizzle_dyn(self, idxs: Simd<u8, N>) -> Self {\n+        #![allow(unused_imports, unused_unsafe)]\n+        #[cfg(target_arch = \"aarch64\")]\n+        use core::arch::aarch64::{uint8x8_t, vqtbl1q_u8, vtbl1_u8};\n+        #[cfg(all(target_arch = \"arm\", target_feature = \"v7\", target_feature = \"neon\"))]\n+        use core::arch::arm::{uint8x8_t, vtbl1_u8};\n+        #[cfg(target_arch = \"wasm32\")]\n+        use core::arch::wasm32 as wasm;\n+        #[cfg(target_arch = \"x86\")]\n+        use core::arch::x86;\n+        #[cfg(target_arch = \"x86_64\")]\n+        use core::arch::x86_64 as x86;\n+        // SAFETY: Intrinsics covered by cfg\n+        unsafe {\n+            match N {\n+                #[cfg(target_feature = \"neon\")]\n+                8 => transize(vtbl1_u8, self, idxs),\n+                #[cfg(target_feature = \"ssse3\")]\n+                16 => transize(x86::_mm_shuffle_epi8, self, idxs),\n+                #[cfg(target_feature = \"simd128\")]\n+                16 => transize(wasm::i8x16_swizzle, self, idxs),\n+                #[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\n+                16 => transize(vqtbl1q_u8, self, idxs),\n+                #[cfg(all(target_feature = \"avx2\", not(target_feature = \"avx512vbmi\")))]\n+                32 => transize_raw(avx2_pshufb, self, idxs),\n+                #[cfg(target_feature = \"avx512vl,avx512vbmi\")]\n+                32 => transize(x86::_mm256_permutexvar_epi8, self, idxs),\n+                // Notable absence: avx512bw shuffle\n+                // If avx512bw is available, odds of avx512vbmi are good\n+                // FIXME: initial AVX512VBMI variant didn't actually pass muster\n+                // #[cfg(target_feature = \"avx512vbmi\")]\n+                // 64 => transize(x86::_mm512_permutexvar_epi8, self, idxs),\n+                _ => {\n+                    let mut array = [0; N];\n+                    for (i, k) in idxs.to_array().into_iter().enumerate() {\n+                        if (k as usize) < N {\n+                            array[i] = self[k as usize];\n+                        };\n+                    }\n+                    array.into()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// \"vpshufb like it was meant to be\" on AVX2\n+///\n+/// # Safety\n+/// This requires AVX2 to work\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+#[target_feature(enable = \"avx2\")]\n+#[allow(unused)]\n+#[inline]\n+#[allow(clippy::let_and_return)]\n+unsafe fn avx2_pshufb(bytes: Simd<u8, 32>, idxs: Simd<u8, 32>) -> Simd<u8, 32> {\n+    use crate::simd::SimdPartialOrd;\n+    #[cfg(target_arch = \"x86\")]\n+    use core::arch::x86;\n+    #[cfg(target_arch = \"x86_64\")]\n+    use core::arch::x86_64 as x86;\n+    use x86::_mm256_permute2x128_si256 as avx2_cross_shuffle;\n+    use x86::_mm256_shuffle_epi8 as avx2_half_pshufb;\n+    let mid = Simd::splat(16u8);\n+    let high = mid + mid;\n+    // SAFETY: Caller promised AVX2\n+    unsafe {\n+        // This is ordering sensitive, and LLVM will order these how you put them.\n+        // Most AVX2 impls use ~5 \"ports\", and only 1 or 2 are capable of permutes.\n+        // But the \"compose\" step will lower to ops that can also use at least 1 other port.\n+        // So this tries to break up permutes so composition flows through \"open\" ports.\n+        // Comparative benches should be done on multiple AVX2 CPUs before reordering this\n+\n+        let hihi = avx2_cross_shuffle::<0x11>(bytes.into(), bytes.into());\n+        let hi_shuf = Simd::from(avx2_half_pshufb(\n+            hihi,        // duplicate the vector's top half\n+            idxs.into(), // so that using only 4 bits of an index still picks bytes 16-31\n+        ));\n+        // A zero-fill during the compose step gives the \"all-Neon-like\" OOB-is-0 semantics\n+        let compose = idxs.simd_lt(high).select(hi_shuf, Simd::splat(0));\n+        let lolo = avx2_cross_shuffle::<0x00>(bytes.into(), bytes.into());\n+        let lo_shuf = Simd::from(avx2_half_pshufb(lolo, idxs.into()));\n+        // Repeat, then pick indices < 16, overwriting indices 0-15 from previous compose step\n+        let compose = idxs.simd_lt(mid).select(lo_shuf, compose);\n+        compose\n+    }\n+}\n+\n+/// This sets up a call to an architecture-specific function, and in doing so\n+/// it persuades rustc that everything is the correct size. Which it is.\n+/// This would not be needed if one could convince Rust that, by matching on N,\n+/// N is that value, and thus it would be valid to substitute e.g. 16.\n+///\n+/// # Safety\n+/// The correctness of this function hinges on the sizes agreeing in actuality.\n+#[allow(dead_code)]\n+#[inline(always)]\n+unsafe fn transize<T, const N: usize>(\n+    f: unsafe fn(T, T) -> T,\n+    bytes: Simd<u8, N>,\n+    idxs: Simd<u8, N>,\n+) -> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    let idxs = zeroing_idxs(idxs);\n+    // SAFETY: Same obligation to use this function as to use mem::transmute_copy.\n+    unsafe { mem::transmute_copy(&f(mem::transmute_copy(&bytes), mem::transmute_copy(&idxs))) }\n+}\n+\n+/// Make indices that yield 0 for this architecture\n+#[inline(always)]\n+fn zeroing_idxs<const N: usize>(idxs: Simd<u8, N>) -> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    // On x86, make sure the top bit is set.\n+    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+    let idxs = {\n+        use crate::simd::SimdPartialOrd;\n+        idxs.simd_lt(Simd::splat(N as u8))\n+            .select(idxs, Simd::splat(u8::MAX))\n+    };\n+    // Simply do nothing on most architectures.\n+    idxs\n+}\n+\n+/// As transize but no implicit call to `zeroing_idxs`.\n+#[allow(dead_code)]\n+#[inline(always)]\n+unsafe fn transize_raw<T, const N: usize>(\n+    f: unsafe fn(T, T) -> T,\n+    bytes: Simd<u8, N>,\n+    idxs: Simd<u8, N>,\n+) -> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    // SAFETY: Same obligation to use this function as to use mem::transmute_copy.\n+    unsafe { mem::transmute_copy(&f(mem::transmute_copy(&bytes), mem::transmute_copy(&idxs))) }\n+}"}, {"sha": "3809cc961515b691663523fb962fcc671a8fff14", "filename": "library/portable-simd/crates/core_simd/src/vector.rs", "status": "modified", "additions": 475, "deletions": 190, "changes": 665, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,60 +1,63 @@\n-mod float;\n-mod int;\n-mod uint;\n-\n-pub use float::*;\n-pub use int::*;\n-pub use uint::*;\n-\n-// Vectors of pointers are not for public use at the current time.\n-pub(crate) mod ptr;\n-\n use crate::simd::{\n-    intrinsics, LaneCount, Mask, MaskElement, SimdPartialOrd, SupportedLaneCount, Swizzle,\n+    intrinsics, LaneCount, Mask, MaskElement, SimdCast, SimdCastPtr, SimdConstPtr, SimdMutPtr,\n+    SimdPartialOrd, SupportedLaneCount, Swizzle,\n };\n+use core::convert::{TryFrom, TryInto};\n \n-/// A SIMD vector of `LANES` elements of type `T`. `Simd<T, N>` has the same shape as [`[T; N]`](array), but operates like `T`.\n+/// A SIMD vector with the shape of `[T; N]` but the operations of `T`.\n ///\n-/// Two vectors of the same type and length will, by convention, support the operators (+, *, etc.) that `T` does.\n-/// These take the lanes at each index on the left-hand side and right-hand side, perform the operation,\n-/// and return the result in the same lane in a vector of equal size. For a given operator, this is equivalent to zipping\n-/// the two arrays together and mapping the operator over each lane.\n+/// `Simd<T, N>` supports the operators (+, *, etc.) that `T` does in \"elementwise\" fashion.\n+/// These take the element at each index from the left-hand side and right-hand side,\n+/// perform the operation, then return the result in the same index in a vector of equal size.\n+/// However, `Simd` differs from normal iteration and normal arrays:\n+/// - `Simd<T, N>` executes `N` operations in a single step with no `break`s\n+/// - `Simd<T, N>` can have an alignment greater than `T`, for better mechanical sympathy\n+///\n+/// By always imposing these constraints on `Simd`, it is easier to compile elementwise operations\n+/// into machine instructions that can themselves be executed in parallel.\n ///\n /// ```rust\n-/// # #![feature(array_zip, portable_simd)]\n+/// # #![feature(portable_simd)]\n /// # use core::simd::{Simd};\n-/// let a0: [i32; 4] = [-2, 0, 2, 4];\n-/// let a1 = [10, 9, 8, 7];\n-/// let zm_add = a0.zip(a1).map(|(lhs, rhs)| lhs + rhs);\n-/// let zm_mul = a0.zip(a1).map(|(lhs, rhs)| lhs * rhs);\n+/// # use core::array;\n+/// let a: [i32; 4] = [-2, 0, 2, 4];\n+/// let b = [10, 9, 8, 7];\n+/// let sum = array::from_fn(|i| a[i] + b[i]);\n+/// let prod = array::from_fn(|i| a[i] * b[i]);\n ///\n /// // `Simd<T, N>` implements `From<[T; N]>`\n-/// let (v0, v1) = (Simd::from(a0), Simd::from(a1));\n+/// let (v, w) = (Simd::from(a), Simd::from(b));\n /// // Which means arrays implement `Into<Simd<T, N>>`.\n-/// assert_eq!(v0 + v1, zm_add.into());\n-/// assert_eq!(v0 * v1, zm_mul.into());\n+/// assert_eq!(v + w, sum.into());\n+/// assert_eq!(v * w, prod.into());\n /// ```\n ///\n-/// `Simd` with integers has the quirk that these operations are also inherently wrapping, as if `T` was [`Wrapping<T>`].\n+///\n+/// `Simd` with integer elements treats operators as wrapping, as if `T` was [`Wrapping<T>`].\n /// Thus, `Simd` does not implement `wrapping_add`, because that is the default behavior.\n /// This means there is no warning on overflows, even in \"debug\" builds.\n /// For most applications where `Simd` is appropriate, it is \"not a bug\" to wrap,\n /// and even \"debug builds\" are unlikely to tolerate the loss of performance.\n /// You may want to consider using explicitly checked arithmetic if such is required.\n-/// Division by zero still causes a panic, so you may want to consider using floating point numbers if that is unacceptable.\n+/// Division by zero on integers still causes a panic, so\n+/// you may want to consider using `f32` or `f64` if that is unacceptable.\n ///\n /// [`Wrapping<T>`]: core::num::Wrapping\n ///\n /// # Layout\n-/// `Simd<T, N>` has a layout similar to `[T; N]` (identical \"shapes\"), but with a greater alignment.\n+/// `Simd<T, N>` has a layout similar to `[T; N]` (identical \"shapes\"), with a greater alignment.\n /// `[T; N]` is aligned to `T`, but `Simd<T, N>` will have an alignment based on both `T` and `N`.\n-/// It is thus sound to [`transmute`] `Simd<T, N>` to `[T; N]`, and will typically optimize to zero cost,\n-/// but the reverse transmutation is more likely to require a copy the compiler cannot simply elide.\n+/// Thus it is sound to [`transmute`] `Simd<T, N>` to `[T; N]` and should optimize to \"zero cost\",\n+/// but the reverse transmutation may require a copy the compiler cannot simply elide.\n ///\n /// # ABI \"Features\"\n-/// Due to Rust's safety guarantees, `Simd<T, N>` is currently passed to and from functions via memory, not SIMD registers,\n-/// except as an optimization. `#[inline]` hints are recommended on functions that accept `Simd<T, N>` or return it.\n-/// The need for this may be corrected in the future.\n+/// Due to Rust's safety guarantees, `Simd<T, N>` is currently passed and returned via memory,\n+/// not SIMD registers, except as an optimization. Using `#[inline]` on functions that accept\n+/// `Simd<T, N>` or return it is recommended, at the cost of code generation time, as\n+/// inlining SIMD-using functions can omit a large function prolog or epilog and thus\n+/// improve both speed and code size. The need for this may be corrected in the future.\n+///\n+/// Using `#[inline(always)]` still requires additional care.\n ///\n /// # Safe SIMD with Unsafe Rust\n ///\n@@ -65,18 +68,22 @@ use crate::simd::{\n /// Thus, when using `unsafe` Rust to read and write `Simd<T, N>` through [raw pointers], it is a good idea to first try with\n /// [`read_unaligned`] and [`write_unaligned`]. This is because:\n /// - [`read`] and [`write`] require full alignment (in this case, `Simd<T, N>`'s alignment)\n-/// - the likely source for reading or destination for writing `Simd<T, N>` is [`[T]`](slice) and similar types, aligned to `T`\n-/// - combining these actions would violate the `unsafe` contract and explode the program into a puff of **undefined behavior**\n-/// - the compiler can implicitly adjust layouts to make unaligned reads or writes fully aligned if it sees the optimization\n-/// - most contemporary processors suffer no performance penalty for \"unaligned\" reads and writes that are aligned at runtime\n+/// - `Simd<T, N>` is often read from or written to [`[T]`](slice) and other types aligned to `T`\n+/// - combining these actions violates the `unsafe` contract and explodes the program into\n+///   a puff of **undefined behavior**\n+/// - the compiler can implicitly adjust layouts to make unaligned reads or writes fully aligned\n+///   if it sees the optimization\n+/// - most contemporary processors with \"aligned\" and \"unaligned\" read and write instructions\n+///   exhibit no performance difference if the \"unaligned\" variant is aligned at runtime\n ///\n-/// By imposing less obligations, unaligned functions are less likely to make the program unsound,\n+/// Less obligations mean unaligned reads and writes are less likely to make the program unsound,\n /// and may be just as fast as stricter alternatives.\n-/// When trying to guarantee alignment, [`[T]::as_simd`][as_simd] is an option for converting `[T]` to `[Simd<T, N>]`,\n-/// and allows soundly operating on an aligned SIMD body, but it may cost more time when handling the scalar head and tail.\n-/// If these are not sufficient, then it is most ideal to design data structures to be already aligned\n-/// to the `Simd<T, N>` you wish to use before using `unsafe` Rust to read or write.\n-/// More conventional ways to compensate for these facts, like materializing `Simd` to or from an array first,\n+/// When trying to guarantee alignment, [`[T]::as_simd`][as_simd] is an option for\n+/// converting `[T]` to `[Simd<T, N>]`, and allows soundly operating on an aligned SIMD body,\n+/// but it may cost more time when handling the scalar head and tail.\n+/// If these are not enough, it is most ideal to design data structures to be already aligned\n+/// to `mem::align_of::<Simd<T, N>>()` before using `unsafe` Rust to read or write.\n+/// Other ways to compensate for these facts, like materializing `Simd` to or from an array first,\n /// are handled by safe methods like [`Simd::from_array`] and [`Simd::from_slice`].\n ///\n /// [`transmute`]: core::mem::transmute\n@@ -86,21 +93,26 @@ use crate::simd::{\n /// [`read`]: pointer::read\n /// [`write`]: pointer::write\n /// [as_simd]: slice::as_simd\n+//\n+// NOTE: Accessing the inner array directly in any way (e.g. by using the `.0` field syntax) or\n+// directly constructing an instance of the type (i.e. `let vector = Simd(array)`) should be\n+// avoided, as it will likely become illegal on `#[repr(simd)]` structs in the future. It also\n+// causes rustc to emit illegal LLVM IR in some cases.\n #[repr(simd)]\n-pub struct Simd<T, const LANES: usize>([T; LANES])\n+pub struct Simd<T, const N: usize>([T; N])\n where\n-    T: SimdElement,\n-    LaneCount<LANES>: SupportedLaneCount;\n+    LaneCount<N>: SupportedLaneCount,\n+    T: SimdElement;\n \n-impl<T, const LANES: usize> Simd<T, LANES>\n+impl<T, const N: usize> Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n-    /// Number of lanes in this vector.\n-    pub const LANES: usize = LANES;\n+    /// Number of elements in this vector.\n+    pub const LANES: usize = N;\n \n-    /// Returns the number of lanes in this SIMD vector.\n+    /// Returns the number of elements in this SIMD vector.\n     ///\n     /// # Examples\n     ///\n@@ -111,10 +123,10 @@ where\n     /// assert_eq!(v.lanes(), 4);\n     /// ```\n     pub const fn lanes(&self) -> usize {\n-        LANES\n+        Self::LANES\n     }\n \n-    /// Constructs a new SIMD vector with all lanes set to the given value.\n+    /// Constructs a new SIMD vector with all elements set to the given value.\n     ///\n     /// # Examples\n     ///\n@@ -125,11 +137,11 @@ where\n     /// assert_eq!(v.as_array(), &[8, 8, 8, 8]);\n     /// ```\n     pub fn splat(value: T) -> Self {\n-        // This is preferred over `[value; LANES]`, since it's explicitly a splat:\n+        // This is preferred over `[value; N]`, since it's explicitly a splat:\n         // https://github.com/rust-lang/rust/issues/97804\n         struct Splat;\n-        impl<const LANES: usize> Swizzle<1, LANES> for Splat {\n-            const INDEX: [usize; LANES] = [0; LANES];\n+        impl<const N: usize> Swizzle<1, N> for Splat {\n+            const INDEX: [usize; N] = [0; N];\n         }\n         Splat::swizzle(Simd::<T, 1>::from([value]))\n     }\n@@ -144,32 +156,100 @@ where\n     /// let v: u64x4 = Simd::from_array([0, 1, 2, 3]);\n     /// assert_eq!(v.as_array(), &[0, 1, 2, 3]);\n     /// ```\n-    pub const fn as_array(&self) -> &[T; LANES] {\n-        &self.0\n+    pub const fn as_array(&self) -> &[T; N] {\n+        // SAFETY: `Simd<T, N>` is just an overaligned `[T; N]` with\n+        // potential padding at the end, so pointer casting to a\n+        // `&[T; N]` is safe.\n+        //\n+        // NOTE: This deliberately doesn't just use `&self.0`, see the comment\n+        // on the struct definition for details.\n+        unsafe { &*(self as *const Self as *const [T; N]) }\n     }\n \n     /// Returns a mutable array reference containing the entire SIMD vector.\n-    pub fn as_mut_array(&mut self) -> &mut [T; LANES] {\n-        &mut self.0\n+    pub fn as_mut_array(&mut self) -> &mut [T; N] {\n+        // SAFETY: `Simd<T, N>` is just an overaligned `[T; N]` with\n+        // potential padding at the end, so pointer casting to a\n+        // `&mut [T; N]` is safe.\n+        //\n+        // NOTE: This deliberately doesn't just use `&mut self.0`, see the comment\n+        // on the struct definition for details.\n+        unsafe { &mut *(self as *mut Self as *mut [T; N]) }\n+    }\n+\n+    /// Load a vector from an array of `T`.\n+    ///\n+    /// This function is necessary since `repr(simd)` has padding for non-power-of-2 vectors (at the time of writing).\n+    /// With padding, `read_unaligned` will read past the end of an array of N elements.\n+    ///\n+    /// # Safety\n+    /// Reading `ptr` must be safe, as if by `<*const [T; N]>::read_unaligned`.\n+    const unsafe fn load(ptr: *const [T; N]) -> Self {\n+        // There are potentially simpler ways to write this function, but this should result in\n+        // LLVM `load <N x T>`\n+\n+        let mut tmp = core::mem::MaybeUninit::<Self>::uninit();\n+        // SAFETY: `Simd<T, N>` always contains `N` elements of type `T`.  It may have padding\n+        // which does not need to be initialized.  The safety of reading `ptr` is ensured by the\n+        // caller.\n+        unsafe {\n+            core::ptr::copy_nonoverlapping(ptr, tmp.as_mut_ptr().cast(), 1);\n+            tmp.assume_init()\n+        }\n+    }\n+\n+    /// Store a vector to an array of `T`.\n+    ///\n+    /// See `load` as to why this function is necessary.\n+    ///\n+    /// # Safety\n+    /// Writing to `ptr` must be safe, as if by `<*mut [T; N]>::write_unaligned`.\n+    const unsafe fn store(self, ptr: *mut [T; N]) {\n+        // There are potentially simpler ways to write this function, but this should result in\n+        // LLVM `store <N x T>`\n+\n+        // Creating a temporary helps LLVM turn the memcpy into a store.\n+        let tmp = self;\n+        // SAFETY: `Simd<T, N>` always contains `N` elements of type `T`.  The safety of writing\n+        // `ptr` is ensured by the caller.\n+        unsafe { core::ptr::copy_nonoverlapping(tmp.as_array(), ptr, 1) }\n     }\n \n     /// Converts an array to a SIMD vector.\n-    pub const fn from_array(array: [T; LANES]) -> Self {\n-        Self(array)\n+    pub const fn from_array(array: [T; N]) -> Self {\n+        // SAFETY: `&array` is safe to read.\n+        //\n+        // FIXME: We currently use a pointer load instead of `transmute_copy` because `repr(simd)`\n+        // results in padding for non-power-of-2 vectors (so vectors are larger than arrays).\n+        //\n+        // NOTE: This deliberately doesn't just use `Self(array)`, see the comment\n+        // on the struct definition for details.\n+        unsafe { Self::load(&array) }\n     }\n \n     /// Converts a SIMD vector to an array.\n-    pub const fn to_array(self) -> [T; LANES] {\n-        self.0\n+    pub const fn to_array(self) -> [T; N] {\n+        let mut tmp = core::mem::MaybeUninit::uninit();\n+        // SAFETY: writing to `tmp` is safe and initializes it.\n+        //\n+        // FIXME: We currently use a pointer store instead of `transmute_copy` because `repr(simd)`\n+        // results in padding for non-power-of-2 vectors (so vectors are larger than arrays).\n+        //\n+        // NOTE: This deliberately doesn't just use `self.0`, see the comment\n+        // on the struct definition for details.\n+        unsafe {\n+            self.store(tmp.as_mut_ptr());\n+            tmp.assume_init()\n+        }\n     }\n \n-    /// Converts a slice to a SIMD vector containing `slice[..LANES]`.\n+    /// Converts a slice to a SIMD vector containing `slice[..N]`.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the slice's length is less than the vector's `Simd::LANES`.\n+    /// Panics if the slice's length is less than the vector's `Simd::N`.\n     ///\n-    /// # Examples\n+    /// # Example\n     ///\n     /// ```\n     /// # #![feature(portable_simd)]\n@@ -180,22 +260,49 @@ where\n     /// ```\n     #[must_use]\n     pub const fn from_slice(slice: &[T]) -> Self {\n-        assert!(slice.len() >= LANES, \"slice length must be at least the number of lanes\");\n-        let mut array = [slice[0]; LANES];\n-        let mut i = 0;\n-        while i < LANES {\n-            array[i] = slice[i];\n-            i += 1;\n-        }\n-        Self(array)\n+        assert!(\n+            slice.len() >= Self::LANES,\n+            \"slice length must be at least the number of elements\"\n+        );\n+        // SAFETY: We just checked that the slice contains\n+        // at least `N` elements.\n+        unsafe { Self::load(slice.as_ptr().cast()) }\n+    }\n+\n+    /// Writes a SIMD vector to the first `N` elements of a slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the slice's length is less than the vector's `Simd::N`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::u32x4;\n+    /// let mut dest = vec![0; 6];\n+    /// let v = u32x4::from_array([1, 2, 3, 4]);\n+    /// v.copy_to_slice(&mut dest);\n+    /// assert_eq!(&dest, &[1, 2, 3, 4, 0, 0]);\n+    /// ```\n+    pub fn copy_to_slice(self, slice: &mut [T]) {\n+        assert!(\n+            slice.len() >= Self::LANES,\n+            \"slice length must be at least the number of elements\"\n+        );\n+        // SAFETY: We just checked that the slice contains\n+        // at least `N` elements.\n+        unsafe { self.store(slice.as_mut_ptr().cast()) }\n     }\n \n-    /// Performs lanewise conversion of a SIMD vector's elements to another SIMD-valid type.\n+    /// Performs elementwise conversion of a SIMD vector's elements to another SIMD-valid type.\n     ///\n-    /// This follows the semantics of Rust's `as` conversion for casting\n-    /// integers to unsigned integers (interpreting as the other type, so `-1` to `MAX`),\n-    /// and from floats to integers (truncating, or saturating at the limits) for each lane,\n-    /// or vice versa.\n+    /// This follows the semantics of Rust's `as` conversion for casting integers between\n+    /// signed and unsigned (interpreting integers as 2s complement, so `-1` to `U::MAX` and\n+    /// `1 << (U::BITS -1)` becoming `I::MIN` ), and from floats to integers (truncating,\n+    /// or saturating at the limits) for each element.\n     ///\n     /// # Examples\n     /// ```\n@@ -215,11 +322,26 @@ where\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn cast<U: SimdElement>(self) -> Simd<U, LANES> {\n-        // Safety: The input argument is a vector of a valid SIMD element type.\n+    pub fn cast<U: SimdCast>(self) -> Simd<U, N>\n+    where\n+        T: SimdCast,\n+    {\n+        // Safety: supported types are guaranteed by SimdCast\n         unsafe { intrinsics::simd_as(self) }\n     }\n \n+    /// Casts a vector of pointers to another pointer type.\n+    #[must_use]\n+    #[inline]\n+    pub fn cast_ptr<U>(self) -> Simd<U, N>\n+    where\n+        T: SimdCastPtr<U>,\n+        U: SimdElement,\n+    {\n+        // Safety: supported types are guaranteed by SimdCastPtr\n+        unsafe { intrinsics::simd_cast_ptr(self) }\n+    }\n+\n     /// Rounds toward zero and converts to the same-width integer type, assuming that\n     /// the value is finite and fits in that type.\n     ///\n@@ -235,90 +357,90 @@ where\n     ///\n     /// [cast]: Simd::cast\n     #[inline]\n-    pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, LANES>\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, N>\n     where\n-        T: core::convert::FloatToInt<I>,\n-        I: SimdElement,\n+        T: core::convert::FloatToInt<I> + SimdCast,\n+        I: SimdCast,\n     {\n-        // Safety: `self` is a vector, and `FloatToInt` ensures the type can be casted to\n-        // an integer.\n+        // Safety: supported types are guaranteed by SimdCast, the caller is responsible for the extra invariants\n         unsafe { intrinsics::simd_cast(self) }\n     }\n \n     /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n+    /// If an index is out-of-bounds, the element is instead selected from the `or` vector.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);  // Note the index that is out-of-bounds\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n     ///\n-    /// let result = Simd::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// let result = Simd::gather_or(&vec, idxs, alt);\n     /// assert_eq!(result, Simd::from_array([-5, 13, 10, 15]));\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn gather_or(slice: &[T], idxs: Simd<usize, LANES>, or: Self) -> Self {\n+    pub fn gather_or(slice: &[T], idxs: Simd<usize, N>, or: Self) -> Self {\n         Self::gather_select(slice, Mask::splat(true), idxs, or)\n     }\n \n-    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// If an index is out-of-bounds, the lane is set to the default value for the type.\n+    /// Reads from indices in `slice` to construct a SIMD vector.\n+    /// If an index is out-of-bounds, the element is set to the default given by `T: Default`.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);  // Note the index that is out-of-bounds\n     ///\n-    /// let result = Simd::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n+    /// let result = Simd::gather_or_default(&vec, idxs);\n     /// assert_eq!(result, Simd::from_array([0, 13, 10, 15]));\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn gather_or_default(slice: &[T], idxs: Simd<usize, LANES>) -> Self\n+    pub fn gather_or_default(slice: &[T], idxs: Simd<usize, N>) -> Self\n     where\n         T: Default,\n     {\n         Self::gather_or(slice, idxs, Self::splat(T::default()))\n     }\n \n-    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If an index is disabled or is out-of-bounds, the lane is selected from the `or` vector.\n+    /// Reads from indices in `slice` to construct a SIMD vector.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If an index is disabled or is out-of-bounds, the element is selected from the `or` vector.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::{Simd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]); // Includes an out-of-bounds index\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Includes a masked element\n     ///\n-    /// let result = Simd::gather_select(&vec, enable, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// let result = Simd::gather_select(&vec, enable, idxs, alt);\n     /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n     /// ```\n     #[must_use]\n     #[inline]\n     pub fn gather_select(\n         slice: &[T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n+        enable: Mask<isize, N>,\n+        idxs: Simd<usize, N>,\n         or: Self,\n     ) -> Self {\n-        let enable: Mask<isize, LANES> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n-        // Safety: We have masked-off out-of-bounds lanes.\n+        let enable: Mask<isize, N> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n+        // Safety: We have masked-off out-of-bounds indices.\n         unsafe { Self::gather_select_unchecked(slice, enable, idxs, or) }\n     }\n \n-    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If an index is disabled, the lane is selected from the `or` vector.\n+    /// Reads from indices in `slice` to construct a SIMD vector.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If an index is disabled, the element is selected from the `or` vector.\n     ///\n     /// # Safety\n     ///\n@@ -332,57 +454,123 @@ where\n     /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n     /// # use simd::{Simd, SimdPartialOrd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]); // Includes an out-of-bounds index\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the final mask lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Includes a masked element\n     /// // If this mask was used to gather, it would be unsound. Let's fix that.\n     /// let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n     ///\n-    /// // We have masked the OOB lane, so it's safe to gather now.\n+    /// // The out-of-bounds index has been masked, so it's safe to gather now.\n     /// let result = unsafe { Simd::gather_select_unchecked(&vec, enable, idxs, alt) };\n     /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n     /// ```\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     #[must_use]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub unsafe fn gather_select_unchecked(\n         slice: &[T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n+        enable: Mask<isize, N>,\n+        idxs: Simd<usize, N>,\n         or: Self,\n     ) -> Self {\n-        let base_ptr = crate::simd::ptr::SimdConstPtr::splat(slice.as_ptr());\n+        let base_ptr = Simd::<*const T, N>::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n-        // Safety: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n-        unsafe { intrinsics::simd_gather(or, ptrs, enable.to_int()) }\n+        // Safety: The caller is responsible for determining the indices are okay to read\n+        unsafe { Self::gather_select_ptr(ptrs, enable, or) }\n+    }\n+\n+    /// Read elementwise from pointers into a SIMD vector.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Each read must satisfy the same conditions as [`core::ptr::read`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdConstPtr};\n+    /// let values = [6, 2, 4, 9];\n+    /// let offsets = Simd::from_array([1, 0, 0, 3]);\n+    /// let source = Simd::splat(values.as_ptr()).wrapping_add(offsets);\n+    /// let gathered = unsafe { Simd::gather_ptr(source) };\n+    /// assert_eq!(gathered, Simd::from_array([2, 6, 6, 9]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn gather_ptr(source: Simd<*const T, N>) -> Self\n+    where\n+        T: Default,\n+    {\n+        // TODO: add an intrinsic that doesn't use a passthru vector, and remove the T: Default bound\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { Self::gather_select_ptr(source, Mask::splat(true), Self::default()) }\n+    }\n+\n+    /// Conditionally read elementwise from pointers into a SIMD vector.\n+    /// The mask `enable`s all `true` pointers and disables all `false` pointers.\n+    /// If a pointer is disabled, the element is selected from the `or` vector,\n+    /// and no read is performed.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Enabled elements must satisfy the same conditions as [`core::ptr::read`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Mask, Simd, SimdConstPtr};\n+    /// let values = [6, 2, 4, 9];\n+    /// let enable = Mask::from_array([true, true, false, true]);\n+    /// let offsets = Simd::from_array([1, 0, 0, 3]);\n+    /// let source = Simd::splat(values.as_ptr()).wrapping_add(offsets);\n+    /// let gathered = unsafe { Simd::gather_select_ptr(source, enable, Simd::splat(0)) };\n+    /// assert_eq!(gathered, Simd::from_array([2, 6, 0, 9]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn gather_select_ptr(\n+        source: Simd<*const T, N>,\n+        enable: Mask<isize, N>,\n+        or: Self,\n+    ) -> Self {\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { intrinsics::simd_gather(or, source, enable.to_int()) }\n     }\n \n     /// Writes the values in a SIMD vector to potentially discontiguous indices in `slice`.\n-    /// If two lanes in the scattered vector would write to the same index\n-    /// only the last lane is guaranteed to actually be written.\n+    /// If an index is out-of-bounds, the write is suppressed without panicking.\n+    /// If two elements in the scattered vector would write to the same index\n+    /// only the last element is guaranteed to actually be written.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]); // Note the duplicate index.\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n     ///\n-    /// vals.scatter(&mut vec, idxs); // index 0 receives two writes.\n+    /// vals.scatter(&mut vec, idxs); // two logical writes means the last wins.\n     /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     #[inline]\n-    pub fn scatter(self, slice: &mut [T], idxs: Simd<usize, LANES>) {\n+    pub fn scatter(self, slice: &mut [T], idxs: Simd<usize, N>) {\n         self.scatter_select(slice, Mask::splat(true), idxs)\n     }\n \n-    /// Writes the values in a SIMD vector to multiple potentially discontiguous indices in `slice`.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If an enabled index is out-of-bounds, the lane is not written.\n-    /// If two enabled lanes in the scattered vector would write to the same index,\n-    /// only the last lane is guaranteed to actually be written.\n+    /// Writes values from a SIMD vector to multiple potentially discontiguous indices in `slice`.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If an enabled index is out-of-bounds, the write is suppressed without panicking.\n+    /// If two enabled elements in the scattered vector would write to the same index,\n+    /// only the last element is guaranteed to actually be written.\n     ///\n     /// # Examples\n     /// ```\n@@ -391,29 +579,24 @@ where\n     /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n     /// # use simd::{Simd, Mask};\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]); // Includes an out-of-bounds index\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Includes a masked element\n     ///\n-    /// vals.scatter_select(&mut vec, enable, idxs); // index 0's second write is masked, thus omitted.\n+    /// vals.scatter_select(&mut vec, enable, idxs); // The last write is masked, thus omitted.\n     /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     #[inline]\n-    pub fn scatter_select(\n-        self,\n-        slice: &mut [T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n-    ) {\n-        let enable: Mask<isize, LANES> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n-        // Safety: We have masked-off out-of-bounds lanes.\n+    pub fn scatter_select(self, slice: &mut [T], enable: Mask<isize, N>, idxs: Simd<usize, N>) {\n+        let enable: Mask<isize, N> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n+        // Safety: We have masked-off out-of-bounds indices.\n         unsafe { self.scatter_select_unchecked(slice, enable, idxs) }\n     }\n \n-    /// Writes the values in a SIMD vector to multiple potentially discontiguous indices in `slice`.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If two enabled lanes in the scattered vector would write to the same index,\n-    /// only the last lane is guaranteed to actually be written.\n+    /// Writes values from a SIMD vector to multiple potentially discontiguous indices in `slice`.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If two enabled elements in the scattered vector would write to the same index,\n+    /// only the last element is guaranteed to actually be written.\n     ///\n     /// # Safety\n     ///\n@@ -429,22 +612,23 @@ where\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Masks the final index\n     /// // If this mask was used to scatter, it would be unsound. Let's fix that.\n     /// let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n     ///\n-    /// // We have masked the OOB lane, so it's safe to scatter now.\n+    /// // We have masked the OOB index, so it's safe to scatter now.\n     /// unsafe { vals.scatter_select_unchecked(&mut vec, enable, idxs); }\n-    /// // index 0's second write is masked, thus was omitted.\n+    /// // The second write to index 0 was masked, thus omitted.\n     /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub unsafe fn scatter_select_unchecked(\n         self,\n         slice: &mut [T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n+        enable: Mask<isize, N>,\n+        idxs: Simd<usize, N>,\n     ) {\n         // Safety: This block works with *mut T derived from &mut 'a [T],\n         // which means it is delicate in Rust's borrowing model, circa 2021:\n@@ -458,36 +642,89 @@ where\n         // 3. &mut [T] which will become our base ptr.\n         unsafe {\n             // Now Entering \u2622\ufe0f *mut T Zone\n-            let base_ptr = crate::simd::ptr::SimdMutPtr::splat(slice.as_mut_ptr());\n+            let base_ptr = Simd::<*mut T, N>::splat(slice.as_mut_ptr());\n             // Ferris forgive me, I have done pointer arithmetic here.\n             let ptrs = base_ptr.wrapping_add(idxs);\n             // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n-            intrinsics::simd_scatter(self, ptrs, enable.to_int())\n+            self.scatter_select_ptr(ptrs, enable);\n             // Cleared \u2622\ufe0f *mut T Zone\n         }\n     }\n+\n+    /// Write pointers elementwise into a SIMD vector.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Each write must satisfy the same conditions as [`core::ptr::write`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdMutPtr};\n+    /// let mut values = [0; 4];\n+    /// let offset = Simd::from_array([3, 2, 1, 0]);\n+    /// let ptrs = Simd::splat(values.as_mut_ptr()).wrapping_add(offset);\n+    /// unsafe { Simd::from_array([6, 3, 5, 7]).scatter_ptr(ptrs); }\n+    /// assert_eq!(values, [7, 5, 3, 6]);\n+    /// ```\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn scatter_ptr(self, dest: Simd<*mut T, N>) {\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { self.scatter_select_ptr(dest, Mask::splat(true)) }\n+    }\n+\n+    /// Conditionally write pointers elementwise into a SIMD vector.\n+    /// The mask `enable`s all `true` pointers and disables all `false` pointers.\n+    /// If a pointer is disabled, the write to its pointee is skipped.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Enabled pointers must satisfy the same conditions as [`core::ptr::write`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Mask, Simd, SimdMutPtr};\n+    /// let mut values = [0; 4];\n+    /// let offset = Simd::from_array([3, 2, 1, 0]);\n+    /// let ptrs = Simd::splat(values.as_mut_ptr()).wrapping_add(offset);\n+    /// let enable = Mask::from_array([true, true, false, false]);\n+    /// unsafe { Simd::from_array([6, 3, 5, 7]).scatter_select_ptr(ptrs, enable); }\n+    /// assert_eq!(values, [0, 0, 3, 6]);\n+    /// ```\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn scatter_select_ptr(self, dest: Simd<*mut T, N>, enable: Mask<isize, N>) {\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { intrinsics::simd_scatter(self, dest, enable.to_int()) }\n+    }\n }\n \n-impl<T, const LANES: usize> Copy for Simd<T, LANES>\n+impl<T, const N: usize> Copy for Simd<T, N>\n where\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n-    LaneCount<LANES>: SupportedLaneCount,\n {\n }\n \n-impl<T, const LANES: usize> Clone for Simd<T, LANES>\n+impl<T, const N: usize> Clone for Simd<T, N>\n where\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n-    LaneCount<LANES>: SupportedLaneCount,\n {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<T, const LANES: usize> Default for Simd<T, LANES>\n+impl<T, const N: usize> Default for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + Default,\n {\n     #[inline]\n@@ -496,20 +733,20 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> PartialEq for Simd<T, LANES>\n+impl<T, const N: usize> PartialEq for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + PartialEq,\n {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         // Safety: All SIMD vectors are SimdPartialEq, and the comparison produces a valid mask.\n         let mask = unsafe {\n-            let tfvec: Simd<<T as SimdElement>::Mask, LANES> = intrinsics::simd_eq(*self, *other);\n+            let tfvec: Simd<<T as SimdElement>::Mask, N> = intrinsics::simd_eq(*self, *other);\n             Mask::from_int_unchecked(tfvec)\n         };\n \n-        // Two vectors are equal if all lanes tested true for vertical equality.\n+        // Two vectors are equal if all elements are equal when compared elementwise\n         mask.all()\n     }\n \n@@ -518,18 +755,18 @@ where\n     fn ne(&self, other: &Self) -> bool {\n         // Safety: All SIMD vectors are SimdPartialEq, and the comparison produces a valid mask.\n         let mask = unsafe {\n-            let tfvec: Simd<<T as SimdElement>::Mask, LANES> = intrinsics::simd_ne(*self, *other);\n+            let tfvec: Simd<<T as SimdElement>::Mask, N> = intrinsics::simd_ne(*self, *other);\n             Mask::from_int_unchecked(tfvec)\n         };\n \n-        // Two vectors are non-equal if any lane tested true for vertical non-equality.\n+        // Two vectors are non-equal if any elements are non-equal when compared elementwise\n         mask.any()\n     }\n }\n \n-impl<T, const LANES: usize> PartialOrd for Simd<T, LANES>\n+impl<T, const N: usize> PartialOrd for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + PartialOrd,\n {\n     #[inline]\n@@ -539,16 +776,16 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> Eq for Simd<T, LANES>\n+impl<T, const N: usize> Eq for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + Eq,\n {\n }\n \n-impl<T, const LANES: usize> Ord for Simd<T, LANES>\n+impl<T, const N: usize> Ord for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + Ord,\n {\n     #[inline]\n@@ -558,9 +795,9 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> core::hash::Hash for Simd<T, LANES>\n+impl<T, const N: usize> core::hash::Hash for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + core::hash::Hash,\n {\n     #[inline]\n@@ -573,72 +810,96 @@ where\n }\n \n // array references\n-impl<T, const LANES: usize> AsRef<[T; LANES]> for Simd<T, LANES>\n+impl<T, const N: usize> AsRef<[T; N]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n-    fn as_ref(&self) -> &[T; LANES] {\n-        &self.0\n+    fn as_ref(&self) -> &[T; N] {\n+        self.as_array()\n     }\n }\n \n-impl<T, const LANES: usize> AsMut<[T; LANES]> for Simd<T, LANES>\n+impl<T, const N: usize> AsMut<[T; N]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n-    fn as_mut(&mut self) -> &mut [T; LANES] {\n-        &mut self.0\n+    fn as_mut(&mut self) -> &mut [T; N] {\n+        self.as_mut_array()\n     }\n }\n \n // slice references\n-impl<T, const LANES: usize> AsRef<[T]> for Simd<T, LANES>\n+impl<T, const N: usize> AsRef<[T]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n     fn as_ref(&self) -> &[T] {\n-        &self.0\n+        self.as_array()\n     }\n }\n \n-impl<T, const LANES: usize> AsMut<[T]> for Simd<T, LANES>\n+impl<T, const N: usize> AsMut<[T]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n     fn as_mut(&mut self) -> &mut [T] {\n-        &mut self.0\n+        self.as_mut_array()\n     }\n }\n \n // vector/array conversion\n-impl<T, const LANES: usize> From<[T; LANES]> for Simd<T, LANES>\n+impl<T, const N: usize> From<[T; N]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n-    fn from(array: [T; LANES]) -> Self {\n-        Self(array)\n+    fn from(array: [T; N]) -> Self {\n+        Self::from_array(array)\n     }\n }\n \n-impl<T, const LANES: usize> From<Simd<T, LANES>> for [T; LANES]\n+impl<T, const N: usize> From<Simd<T, N>> for [T; N]\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n-    fn from(vector: Simd<T, LANES>) -> Self {\n+    fn from(vector: Simd<T, N>) -> Self {\n         vector.to_array()\n     }\n }\n \n+impl<T, const N: usize> TryFrom<&[T]> for Simd<T, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    type Error = core::array::TryFromSliceError;\n+\n+    fn try_from(slice: &[T]) -> Result<Self, core::array::TryFromSliceError> {\n+        Ok(Self::from_array(slice.try_into()?))\n+    }\n+}\n+\n+impl<T, const N: usize> TryFrom<&mut [T]> for Simd<T, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    type Error = core::array::TryFromSliceError;\n+\n+    fn try_from(slice: &mut [T]) -> Result<Self, core::array::TryFromSliceError> {\n+        Ok(Self::from_array(slice.try_into()?))\n+    }\n+}\n+\n mod sealed {\n     pub trait Sealed {}\n }\n@@ -740,3 +1001,27 @@ impl Sealed for f64 {}\n unsafe impl SimdElement for f64 {\n     type Mask = i64;\n }\n+\n+impl<T> Sealed for *const T {}\n+\n+// Safety: (thin) const pointers are valid SIMD element types, and are supported by this API\n+//\n+// Fat pointers may be supported in the future.\n+unsafe impl<T> SimdElement for *const T\n+where\n+    T: core::ptr::Pointee<Metadata = ()>,\n+{\n+    type Mask = isize;\n+}\n+\n+impl<T> Sealed for *mut T {}\n+\n+// Safety: (thin) mut pointers are valid SIMD element types, and are supported by this API\n+//\n+// Fat pointers may be supported in the future.\n+unsafe impl<T> SimdElement for *mut T\n+where\n+    T: core::ptr::Pointee<Metadata = ()>,\n+{\n+    type Mask = isize;\n+}"}, {"sha": "f836c99b1e2dc41564f0e85ad648f5ad2d476c04", "filename": "library/portable-simd/crates/core_simd/src/vector/float.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "patch": "@@ -1,24 +0,0 @@\n-#![allow(non_camel_case_types)]\n-\n-use crate::simd::Simd;\n-\n-/// A 64-bit SIMD vector with two elements of type `f32`.\n-pub type f32x2 = Simd<f32, 2>;\n-\n-/// A 128-bit SIMD vector with four elements of type `f32`.\n-pub type f32x4 = Simd<f32, 4>;\n-\n-/// A 256-bit SIMD vector with eight elements of type `f32`.\n-pub type f32x8 = Simd<f32, 8>;\n-\n-/// A 512-bit SIMD vector with 16 elements of type `f32`.\n-pub type f32x16 = Simd<f32, 16>;\n-\n-/// A 128-bit SIMD vector with two elements of type `f64`.\n-pub type f64x2 = Simd<f64, 2>;\n-\n-/// A 256-bit SIMD vector with four elements of type `f64`.\n-pub type f64x4 = Simd<f64, 4>;\n-\n-/// A 512-bit SIMD vector with eight elements of type `f64`.\n-pub type f64x8 = Simd<f64, 8>;"}, {"sha": "20e56c7dc6443bdca6b8922dc3659e4f554c665e", "filename": "library/portable-simd/crates/core_simd/src/vector/int.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "patch": "@@ -1,63 +0,0 @@\n-#![allow(non_camel_case_types)]\n-\n-use crate::simd::Simd;\n-\n-/// A SIMD vector with two elements of type `isize`.\n-pub type isizex2 = Simd<isize, 2>;\n-\n-/// A SIMD vector with four elements of type `isize`.\n-pub type isizex4 = Simd<isize, 4>;\n-\n-/// A SIMD vector with eight elements of type `isize`.\n-pub type isizex8 = Simd<isize, 8>;\n-\n-/// A 32-bit SIMD vector with two elements of type `i16`.\n-pub type i16x2 = Simd<i16, 2>;\n-\n-/// A 64-bit SIMD vector with four elements of type `i16`.\n-pub type i16x4 = Simd<i16, 4>;\n-\n-/// A 128-bit SIMD vector with eight elements of type `i16`.\n-pub type i16x8 = Simd<i16, 8>;\n-\n-/// A 256-bit SIMD vector with 16 elements of type `i16`.\n-pub type i16x16 = Simd<i16, 16>;\n-\n-/// A 512-bit SIMD vector with 32 elements of type `i16`.\n-pub type i16x32 = Simd<i16, 32>;\n-\n-/// A 64-bit SIMD vector with two elements of type `i32`.\n-pub type i32x2 = Simd<i32, 2>;\n-\n-/// A 128-bit SIMD vector with four elements of type `i32`.\n-pub type i32x4 = Simd<i32, 4>;\n-\n-/// A 256-bit SIMD vector with eight elements of type `i32`.\n-pub type i32x8 = Simd<i32, 8>;\n-\n-/// A 512-bit SIMD vector with 16 elements of type `i32`.\n-pub type i32x16 = Simd<i32, 16>;\n-\n-/// A 128-bit SIMD vector with two elements of type `i64`.\n-pub type i64x2 = Simd<i64, 2>;\n-\n-/// A 256-bit SIMD vector with four elements of type `i64`.\n-pub type i64x4 = Simd<i64, 4>;\n-\n-/// A 512-bit SIMD vector with eight elements of type `i64`.\n-pub type i64x8 = Simd<i64, 8>;\n-\n-/// A 32-bit SIMD vector with four elements of type `i8`.\n-pub type i8x4 = Simd<i8, 4>;\n-\n-/// A 64-bit SIMD vector with eight elements of type `i8`.\n-pub type i8x8 = Simd<i8, 8>;\n-\n-/// A 128-bit SIMD vector with 16 elements of type `i8`.\n-pub type i8x16 = Simd<i8, 16>;\n-\n-/// A 256-bit SIMD vector with 32 elements of type `i8`.\n-pub type i8x32 = Simd<i8, 32>;\n-\n-/// A 512-bit SIMD vector with 64 elements of type `i8`.\n-pub type i8x64 = Simd<i8, 64>;"}, {"sha": "fa756344db91ae3d57b1096848849fe957e18345", "filename": "library/portable-simd/crates/core_simd/src/vector/ptr.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "patch": "@@ -1,51 +0,0 @@\n-//! Private implementation details of public gather/scatter APIs.\n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n-\n-/// A vector of *const T.\n-#[derive(Debug, Copy, Clone)]\n-#[repr(simd)]\n-pub(crate) struct SimdConstPtr<T, const LANES: usize>([*const T; LANES]);\n-\n-impl<T, const LANES: usize> SimdConstPtr<T, LANES>\n-where\n-    LaneCount<LANES>: SupportedLaneCount,\n-    T: Sized,\n-{\n-    #[inline]\n-    #[must_use]\n-    pub fn splat(ptr: *const T) -> Self {\n-        Self([ptr; LANES])\n-    }\n-\n-    #[inline]\n-    #[must_use]\n-    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n-        // Safety: this intrinsic doesn't have a precondition\n-        unsafe { intrinsics::simd_arith_offset(self, addend) }\n-    }\n-}\n-\n-/// A vector of *mut T. Be very careful around potential aliasing.\n-#[derive(Debug, Copy, Clone)]\n-#[repr(simd)]\n-pub(crate) struct SimdMutPtr<T, const LANES: usize>([*mut T; LANES]);\n-\n-impl<T, const LANES: usize> SimdMutPtr<T, LANES>\n-where\n-    LaneCount<LANES>: SupportedLaneCount,\n-    T: Sized,\n-{\n-    #[inline]\n-    #[must_use]\n-    pub fn splat(ptr: *mut T) -> Self {\n-        Self([ptr; LANES])\n-    }\n-\n-    #[inline]\n-    #[must_use]\n-    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n-        // Safety: this intrinsic doesn't have a precondition\n-        unsafe { intrinsics::simd_arith_offset(self, addend) }\n-    }\n-}"}, {"sha": "b4a69c44363f1d5a0d9297ccc06504f1ea65ac78", "filename": "library/portable-simd/crates/core_simd/src/vector/uint.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b24e12785e6a6bacb69953fb389bcd2fc11ae87/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=5b24e12785e6a6bacb69953fb389bcd2fc11ae87", "patch": "@@ -1,63 +0,0 @@\n-#![allow(non_camel_case_types)]\n-\n-use crate::simd::Simd;\n-\n-/// A SIMD vector with two elements of type `usize`.\n-pub type usizex2 = Simd<usize, 2>;\n-\n-/// A SIMD vector with four elements of type `usize`.\n-pub type usizex4 = Simd<usize, 4>;\n-\n-/// A SIMD vector with eight elements of type `usize`.\n-pub type usizex8 = Simd<usize, 8>;\n-\n-/// A 32-bit SIMD vector with two elements of type `u16`.\n-pub type u16x2 = Simd<u16, 2>;\n-\n-/// A 64-bit SIMD vector with four elements of type `u16`.\n-pub type u16x4 = Simd<u16, 4>;\n-\n-/// A 128-bit SIMD vector with eight elements of type `u16`.\n-pub type u16x8 = Simd<u16, 8>;\n-\n-/// A 256-bit SIMD vector with 16 elements of type `u16`.\n-pub type u16x16 = Simd<u16, 16>;\n-\n-/// A 512-bit SIMD vector with 32 elements of type `u16`.\n-pub type u16x32 = Simd<u16, 32>;\n-\n-/// A 64-bit SIMD vector with two elements of type `u32`.\n-pub type u32x2 = Simd<u32, 2>;\n-\n-/// A 128-bit SIMD vector with four elements of type `u32`.\n-pub type u32x4 = Simd<u32, 4>;\n-\n-/// A 256-bit SIMD vector with eight elements of type `u32`.\n-pub type u32x8 = Simd<u32, 8>;\n-\n-/// A 512-bit SIMD vector with 16 elements of type `u32`.\n-pub type u32x16 = Simd<u32, 16>;\n-\n-/// A 128-bit SIMD vector with two elements of type `u64`.\n-pub type u64x2 = Simd<u64, 2>;\n-\n-/// A 256-bit SIMD vector with four elements of type `u64`.\n-pub type u64x4 = Simd<u64, 4>;\n-\n-/// A 512-bit SIMD vector with eight elements of type `u64`.\n-pub type u64x8 = Simd<u64, 8>;\n-\n-/// A 32-bit SIMD vector with four elements of type `u8`.\n-pub type u8x4 = Simd<u8, 4>;\n-\n-/// A 64-bit SIMD vector with eight elements of type `u8`.\n-pub type u8x8 = Simd<u8, 8>;\n-\n-/// A 128-bit SIMD vector with 16 elements of type `u8`.\n-pub type u8x16 = Simd<u8, 16>;\n-\n-/// A 256-bit SIMD vector with 32 elements of type `u8`.\n-pub type u8x32 = Simd<u8, 32>;\n-\n-/// A 512-bit SIMD vector with 64 elements of type `u8`.\n-pub type u8x64 = Simd<u8, 64>;"}, {"sha": "3181826ef59a659df203c31d08469924bcbe98c3", "filename": "library/portable-simd/crates/core_simd/tests/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fautoderef.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,6 +1,6 @@\n // Test that we handle all our \"auto-deref\" cases correctly.\n #![feature(portable_simd)]\n-use core_simd::f32x4;\n+use core_simd::simd::f32x4;\n \n #[cfg(target_arch = \"wasm32\")]\n use wasm_bindgen_test::*;"}, {"sha": "faafa5fa51f1877415b91e3bebbab084920fb1f5", "filename": "library/portable-simd/crates/core_simd/tests/mask_ops_impl/mask_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -2,7 +2,7 @@ macro_rules! mask_tests {\n     { $vector:ident, $lanes:literal } => {\n         #[cfg(test)]\n         mod $vector {\n-            use core_simd::$vector as Vector;\n+            use core_simd::simd::$vector as Vector;\n             const LANES: usize = $lanes;\n \n             #[cfg(target_arch = \"wasm32\")]"}, {"sha": "9f8bad1c36c082e6a9bbe9bc01b65d4e66b8f5c6", "filename": "library/portable-simd/crates/core_simd/tests/masks.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -13,11 +13,13 @@ macro_rules! test_mask_api {\n             #[cfg(target_arch = \"wasm32\")]\n             use wasm_bindgen_test::*;\n \n+            use core_simd::simd::Mask;\n+\n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn set_and_test() {\n                 let values = [true, false, false, true, false, false, true, false];\n-                let mut mask = core_simd::Mask::<$type, 8>::splat(false);\n+                let mut mask = Mask::<$type, 8>::splat(false);\n                 for (lane, value) in values.iter().copied().enumerate() {\n                     mask.set(lane, value);\n                 }\n@@ -29,90 +31,90 @@ macro_rules! test_mask_api {\n             #[test]\n             #[should_panic]\n             fn set_invalid_lane() {\n-                let mut mask = core_simd::Mask::<$type, 8>::splat(false);\n+                let mut mask = Mask::<$type, 8>::splat(false);\n                 mask.set(8, true);\n                 let _ = mask;\n             }\n \n             #[test]\n             #[should_panic]\n             fn test_invalid_lane() {\n-                let mask = core_simd::Mask::<$type, 8>::splat(false);\n+                let mask = Mask::<$type, 8>::splat(false);\n                 let _ = mask.test(8);\n             }\n \n             #[test]\n             fn any() {\n-                assert!(!core_simd::Mask::<$type, 8>::splat(false).any());\n-                assert!(core_simd::Mask::<$type, 8>::splat(true).any());\n-                let mut v = core_simd::Mask::<$type, 8>::splat(false);\n+                assert!(!Mask::<$type, 8>::splat(false).any());\n+                assert!(Mask::<$type, 8>::splat(true).any());\n+                let mut v = Mask::<$type, 8>::splat(false);\n                 v.set(2, true);\n                 assert!(v.any());\n             }\n \n             #[test]\n             fn all() {\n-                assert!(!core_simd::Mask::<$type, 8>::splat(false).all());\n-                assert!(core_simd::Mask::<$type, 8>::splat(true).all());\n-                let mut v = core_simd::Mask::<$type, 8>::splat(false);\n+                assert!(!Mask::<$type, 8>::splat(false).all());\n+                assert!(Mask::<$type, 8>::splat(true).all());\n+                let mut v = Mask::<$type, 8>::splat(false);\n                 v.set(2, true);\n                 assert!(!v.all());\n             }\n \n             #[test]\n             fn roundtrip_int_conversion() {\n                 let values = [true, false, false, true, false, false, true, false];\n-                let mask = core_simd::Mask::<$type, 8>::from_array(values);\n+                let mask = Mask::<$type, 8>::from_array(values);\n                 let int = mask.to_int();\n                 assert_eq!(int.to_array(), [-1, 0, 0, -1, 0, 0, -1, 0]);\n-                assert_eq!(core_simd::Mask::<$type, 8>::from_int(int), mask);\n+                assert_eq!(Mask::<$type, 8>::from_int(int), mask);\n             }\n \n             #[test]\n             fn roundtrip_bitmask_conversion() {\n-                use core_simd::ToBitMask;\n+                use core_simd::simd::ToBitMask;\n                 let values = [\n                     true, false, false, true, false, false, true, false,\n                     true, true, false, false, false, false, false, true,\n                 ];\n-                let mask = core_simd::Mask::<$type, 16>::from_array(values);\n+                let mask = Mask::<$type, 16>::from_array(values);\n                 let bitmask = mask.to_bitmask();\n                 assert_eq!(bitmask, 0b1000001101001001);\n-                assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n+                assert_eq!(Mask::<$type, 16>::from_bitmask(bitmask), mask);\n             }\n \n             #[test]\n             fn roundtrip_bitmask_conversion_short() {\n-                use core_simd::ToBitMask;\n+                use core_simd::simd::ToBitMask;\n \n                 let values = [\n                     false, false, false, true,\n                 ];\n-                let mask = core_simd::Mask::<$type, 4>::from_array(values);\n+                let mask = Mask::<$type, 4>::from_array(values);\n                 let bitmask = mask.to_bitmask();\n                 assert_eq!(bitmask, 0b1000);\n-                assert_eq!(core_simd::Mask::<$type, 4>::from_bitmask(bitmask), mask);\n+                assert_eq!(Mask::<$type, 4>::from_bitmask(bitmask), mask);\n \n                 let values = [true, false];\n-                let mask = core_simd::Mask::<$type, 2>::from_array(values);\n+                let mask = Mask::<$type, 2>::from_array(values);\n                 let bitmask = mask.to_bitmask();\n                 assert_eq!(bitmask, 0b01);\n-                assert_eq!(core_simd::Mask::<$type, 2>::from_bitmask(bitmask), mask);\n+                assert_eq!(Mask::<$type, 2>::from_bitmask(bitmask), mask);\n             }\n \n             #[test]\n             fn cast() {\n-                fn cast_impl<T: core_simd::MaskElement>()\n+                fn cast_impl<T: core_simd::simd::MaskElement>()\n                 where\n-                    core_simd::Mask<$type, 8>: Into<core_simd::Mask<T, 8>>,\n+                    Mask<$type, 8>: Into<Mask<T, 8>>,\n                 {\n                     let values = [true, false, false, true, false, false, true, false];\n-                    let mask = core_simd::Mask::<$type, 8>::from_array(values);\n+                    let mask = Mask::<$type, 8>::from_array(values);\n \n                     let cast_mask = mask.cast::<T>();\n                     assert_eq!(values, cast_mask.to_array());\n \n-                    let into_mask: core_simd::Mask<T, 8> = mask.into();\n+                    let into_mask: Mask<T, 8> = mask.into();\n                     assert_eq!(values, into_mask.to_array());\n                 }\n \n@@ -126,15 +128,15 @@ macro_rules! test_mask_api {\n             #[cfg(feature = \"generic_const_exprs\")]\n             #[test]\n             fn roundtrip_bitmask_array_conversion() {\n-                use core_simd::ToBitMaskArray;\n+                use core_simd::simd::ToBitMaskArray;\n                 let values = [\n                     true, false, false, true, false, false, true, false,\n                     true, true, false, false, false, false, false, true,\n                 ];\n-                let mask = core_simd::Mask::<$type, 16>::from_array(values);\n+                let mask = Mask::<$type, 16>::from_array(values);\n                 let bitmask = mask.to_bitmask_array();\n                 assert_eq!(bitmask, [0b01001001, 0b10000011]);\n-                assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask_array(bitmask), mask);\n+                assert_eq!(Mask::<$type, 16>::from_bitmask_array(bitmask), mask);\n             }\n         }\n     }\n@@ -150,9 +152,10 @@ mod mask_api {\n \n #[test]\n fn convert() {\n+    use core_simd::simd::Mask;\n     let values = [true, false, false, true, false, false, true, false];\n     assert_eq!(\n-        core_simd::Mask::<i8, 8>::from_array(values),\n-        core_simd::Mask::<i32, 8>::from_array(values).into()\n+        Mask::<i8, 8>::from_array(values),\n+        Mask::<i32, 8>::from_array(values).into()\n     );\n }"}, {"sha": "3a02f3f01e1cf8c36b233f01f6d342aec725c015", "filename": "library/portable-simd/crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -7,7 +7,7 @@ macro_rules! impl_unary_op_test {\n         test_helpers::test_lanes! {\n             fn $fn<const LANES: usize>() {\n                 test_helpers::test_unary_elementwise(\n-                    &<core_simd::Simd<$scalar, LANES> as core::ops::$trait>::$fn,\n+                    &<core_simd::simd::Simd<$scalar, LANES> as core::ops::$trait>::$fn,\n                     &$scalar_fn,\n                     &|_| true,\n                 );\n@@ -27,7 +27,7 @@ macro_rules! impl_binary_op_test {\n     { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr } => {\n         mod $fn {\n             use super::*;\n-            use core_simd::Simd;\n+            use core_simd::simd::Simd;\n \n             test_helpers::test_lanes! {\n                 fn normal<const LANES: usize>() {\n@@ -64,7 +64,7 @@ macro_rules! impl_binary_checked_op_test {\n     { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr, $check_fn:expr } => {\n         mod $fn {\n             use super::*;\n-            use core_simd::Simd;\n+            use core_simd::simd::Simd;\n \n             test_helpers::test_lanes! {\n                 fn normal<const LANES: usize>() {\n@@ -173,7 +173,7 @@ macro_rules! impl_signed_tests {\n     { $scalar:tt } => {\n         mod $scalar {\n             use core_simd::simd::SimdInt;\n-            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n+            type Vector<const LANES: usize> = core_simd::simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n             impl_common_integer_tests! { Vector, Scalar }\n@@ -314,7 +314,7 @@ macro_rules! impl_unsigned_tests {\n     { $scalar:tt } => {\n         mod $scalar {\n             use core_simd::simd::SimdUint;\n-            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n+            type Vector<const LANES: usize> = core_simd::simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n             impl_common_integer_tests! { Vector, Scalar }\n@@ -348,8 +348,8 @@ macro_rules! impl_unsigned_tests {\n macro_rules! impl_float_tests {\n     { $scalar:tt, $int_scalar:tt } => {\n         mod $scalar {\n-            use core_simd::SimdFloat;\n-            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n+            use core_simd::simd::SimdFloat;\n+            type Vector<const LANES: usize> = core_simd::simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n             impl_unary_op_test!(Scalar, Neg::neg);"}, {"sha": "0ae8f83b8b97dce9fa792f4359ba8ffeae432c03", "filename": "library/portable-simd/crates/core_simd/tests/pointers.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fpointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fpointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fpointers.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -0,0 +1,111 @@\n+#![feature(portable_simd, strict_provenance)]\n+\n+use core_simd::simd::{Simd, SimdConstPtr, SimdMutPtr};\n+\n+macro_rules! common_tests {\n+    { $constness:ident } => {\n+        test_helpers::test_lanes! {\n+            fn is_null<const LANES: usize>() {\n+                test_helpers::test_unary_mask_elementwise(\n+                    &Simd::<*$constness u32, LANES>::is_null,\n+                    &<*$constness u32>::is_null,\n+                    &|_| true,\n+                );\n+            }\n+\n+            fn addr<const LANES: usize>() {\n+                test_helpers::test_unary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::addr,\n+                    &<*$constness u32>::addr,\n+                    &|_| true,\n+                );\n+            }\n+\n+            fn with_addr<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::with_addr,\n+                    &<*$constness u32>::with_addr,\n+                    &|_, _| true,\n+                );\n+            }\n+\n+            fn expose_addr<const LANES: usize>() {\n+                test_helpers::test_unary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::expose_addr,\n+                    &<*$constness u32>::expose_addr,\n+                    &|_| true,\n+                );\n+            }\n+\n+            fn wrapping_offset<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::wrapping_offset,\n+                    &<*$constness u32>::wrapping_offset,\n+                    &|_, _| true,\n+                );\n+            }\n+\n+            fn wrapping_add<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::wrapping_add,\n+                    &<*$constness u32>::wrapping_add,\n+                    &|_, _| true,\n+                );\n+            }\n+\n+            fn wrapping_sub<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::wrapping_sub,\n+                    &<*$constness u32>::wrapping_sub,\n+                    &|_, _| true,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+mod const_ptr {\n+    use super::*;\n+    common_tests! { const }\n+\n+    test_helpers::test_lanes! {\n+        fn cast_mut<const LANES: usize>() {\n+            test_helpers::test_unary_elementwise(\n+                &Simd::<*const u32, LANES>::cast_mut,\n+                &<*const u32>::cast_mut,\n+                &|_| true,\n+            );\n+        }\n+\n+        fn from_exposed_addr<const LANES: usize>() {\n+            test_helpers::test_unary_elementwise(\n+                &Simd::<*const u32, LANES>::from_exposed_addr,\n+                &core::ptr::from_exposed_addr::<u32>,\n+                &|_| true,\n+            );\n+        }\n+    }\n+}\n+\n+mod mut_ptr {\n+    use super::*;\n+    common_tests! { mut }\n+\n+    test_helpers::test_lanes! {\n+        fn cast_const<const LANES: usize>() {\n+            test_helpers::test_unary_elementwise(\n+                &Simd::<*mut u32, LANES>::cast_const,\n+                &<*mut u32>::cast_const,\n+                &|_| true,\n+            );\n+        }\n+\n+        fn from_exposed_addr<const LANES: usize>() {\n+            test_helpers::test_unary_elementwise(\n+                &Simd::<*mut u32, LANES>::from_exposed_addr,\n+                &core::ptr::from_exposed_addr_mut::<u32>,\n+                &|_| true,\n+            );\n+        }\n+    }\n+}"}, {"sha": "8b9638ad466712c299aebe4e19904de11e40ce11", "filename": "library/portable-simd/crates/core_simd/tests/round.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -5,7 +5,7 @@ macro_rules! float_rounding_test {\n         mod $scalar {\n             use std_float::StdFloat;\n \n-            type Vector<const LANES: usize> = core_simd::Simd<$scalar, LANES>;\n+            type Vector<const LANES: usize> = core_simd::simd::Simd<$scalar, LANES>;\n             type Scalar = $scalar;\n             type IntScalar = $int_scalar;\n "}, {"sha": "8cd7c33e823fb799901d53cddf36825ced6c29ec", "filename": "library/portable-simd/crates/core_simd/tests/swizzle.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,5 +1,5 @@\n #![feature(portable_simd)]\n-use core_simd::{Simd, Swizzle};\n+use core_simd::simd::{Simd, Swizzle};\n \n #[cfg(target_arch = \"wasm32\")]\n use wasm_bindgen_test::*;\n@@ -60,3 +60,17 @@ fn interleave() {\n     assert_eq!(even, a);\n     assert_eq!(odd, b);\n }\n+\n+// portable-simd#298\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn interleave_one() {\n+    let a = Simd::from_array([0]);\n+    let b = Simd::from_array([1]);\n+    let (lo, hi) = a.interleave(b);\n+    assert_eq!(lo.to_array(), [0]);\n+    assert_eq!(hi.to_array(), [1]);\n+    let (even, odd) = lo.deinterleave(hi);\n+    assert_eq!(even, a);\n+    assert_eq!(odd, b);\n+}"}, {"sha": "646cd5f338335075624f5b747d0bb44856364eb1", "filename": "library/portable-simd/crates/core_simd/tests/swizzle_dyn.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle_dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle_dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle_dyn.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -0,0 +1,74 @@\n+#![feature(portable_simd)]\n+use core::{fmt, ops::RangeInclusive};\n+use proptest;\n+use test_helpers::{self, biteq, make_runner, prop_assert_biteq};\n+\n+fn swizzle_dyn_scalar_ver<const N: usize>(values: [u8; N], idxs: [u8; N]) -> [u8; N] {\n+    let mut array = [0; N];\n+    for (i, k) in idxs.into_iter().enumerate() {\n+        if (k as usize) < N {\n+            array[i] = values[k as usize];\n+        };\n+    }\n+    array\n+}\n+\n+test_helpers::test_lanes! {\n+    fn swizzle_dyn<const N: usize>() {\n+        match_simd_with_fallback(\n+            &core_simd::simd::Simd::<u8, N>::swizzle_dyn,\n+            &swizzle_dyn_scalar_ver,\n+            &|_, _| true,\n+        );\n+    }\n+}\n+\n+fn match_simd_with_fallback<Scalar, ScalarResult, Vector, VectorResult, const N: usize>(\n+    fv: &dyn Fn(Vector, Vector) -> VectorResult,\n+    fs: &dyn Fn([Scalar; N], [Scalar; N]) -> [ScalarResult; N],\n+    check: &dyn Fn([Scalar; N], [Scalar; N]) -> bool,\n+) where\n+    Scalar: Copy + fmt::Debug + SwizzleStrategy,\n+    ScalarResult: Copy + biteq::BitEq + fmt::Debug + SwizzleStrategy,\n+    Vector: Into<[Scalar; N]> + From<[Scalar; N]> + Copy,\n+    VectorResult: Into<[ScalarResult; N]> + From<[ScalarResult; N]> + Copy,\n+{\n+    test_swizzles_2(&|x: [Scalar; N], y: [Scalar; N]| {\n+        proptest::prop_assume!(check(x, y));\n+        let result_v: [ScalarResult; N] = fv(x.into(), y.into()).into();\n+        let result_s: [ScalarResult; N] = fs(x, y);\n+        crate::prop_assert_biteq!(result_v, result_s);\n+        Ok(())\n+    });\n+}\n+\n+fn test_swizzles_2<A: fmt::Debug + SwizzleStrategy, B: fmt::Debug + SwizzleStrategy>(\n+    f: &dyn Fn(A, B) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = make_runner();\n+    runner\n+        .run(\n+            &(A::swizzled_strategy(), B::swizzled_strategy()),\n+            |(a, b)| f(a, b),\n+        )\n+        .unwrap();\n+}\n+\n+pub trait SwizzleStrategy {\n+    type Strategy: proptest::strategy::Strategy<Value = Self>;\n+    fn swizzled_strategy() -> Self::Strategy;\n+}\n+\n+impl SwizzleStrategy for u8 {\n+    type Strategy = RangeInclusive<u8>;\n+    fn swizzled_strategy() -> Self::Strategy {\n+        0..=64\n+    }\n+}\n+\n+impl<T: fmt::Debug + SwizzleStrategy, const N: usize> SwizzleStrategy for [T; N] {\n+    type Strategy = test_helpers::array::UniformArrayStrategy<T::Strategy, Self>;\n+    fn swizzled_strategy() -> Self::Strategy {\n+        Self::Strategy::new(T::swizzled_strategy())\n+    }\n+}"}, {"sha": "be0ee4349c579ceb6d89f55a88977bed48fc36cb", "filename": "library/portable-simd/crates/core_simd/tests/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fto_bytes.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -2,7 +2,7 @@\n #![allow(incomplete_features)]\n #![cfg(feature = \"generic_const_exprs\")]\n \n-use core_simd::Simd;\n+use core_simd::simd::Simd;\n \n #[test]\n fn byte_convert() {"}, {"sha": "859e3b94f2cd4fa8fee3b6ef00b036a8a18aca18", "filename": "library/portable-simd/crates/core_simd/tests/try_from_slice.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ftry_from_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ftry_from_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ftry_from_slice.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -0,0 +1,25 @@\n+#![feature(portable_simd)]\n+\n+#[cfg(target_arch = \"wasm32\")]\n+use wasm_bindgen_test::*;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+wasm_bindgen_test_configure!(run_in_browser);\n+\n+use core_simd::simd::i32x4;\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn try_from_slice() {\n+    // Equal length\n+    assert_eq!(\n+        i32x4::try_from([1, 2, 3, 4].as_slice()).unwrap(),\n+        i32x4::from_array([1, 2, 3, 4])\n+    );\n+\n+    // Slice length > vector length\n+    assert!(i32x4::try_from([1, 2, 3, 4, 5].as_slice()).is_err());\n+\n+    // Slice length < vector length\n+    assert!(i32x4::try_from([1, 2, 3].as_slice()).is_err());\n+}"}, {"sha": "1d2bc8b519aa6355e2916b27af8dcecdaf8a598d", "filename": "library/portable-simd/crates/test_helpers/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2FCargo.toml?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -8,3 +8,6 @@ publish = false\n version = \"0.10\"\n default-features = false\n features = [\"alloc\"]\n+\n+[features]\n+all_lane_counts = []"}, {"sha": "984a427320deb746345847a93f04f6181ce490a3", "filename": "library/portable-simd/crates/test_helpers/src/array.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Farray.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -41,6 +41,7 @@ where\n \n     fn new_tree(&self, runner: &mut TestRunner) -> NewTree<Self> {\n         let tree: [S::Tree; LANES] = unsafe {\n+            #[allow(clippy::uninit_assumed_init)]\n             let mut tree: [MaybeUninit<S::Tree>; LANES] = MaybeUninit::uninit().assume_init();\n             for t in tree.iter_mut() {\n                 *t = MaybeUninit::new(self.strategy.new_tree(runner)?)\n@@ -60,6 +61,7 @@ impl<T: ValueTree, const LANES: usize> ValueTree for ArrayValueTree<[T; LANES]>\n \n     fn current(&self) -> Self::Value {\n         unsafe {\n+            #[allow(clippy::uninit_assumed_init)]\n             let mut value: [MaybeUninit<T::Value>; LANES] = MaybeUninit::uninit().assume_init();\n             for (tree_elem, value_elem) in self.tree.iter().zip(value.iter_mut()) {\n                 *value_elem = MaybeUninit::new(tree_elem.current());"}, {"sha": "7d91260d838a63b6be90f19e0e1de9d0e45d3eb0", "filename": "library/portable-simd/crates/test_helpers/src/biteq.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fbiteq.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -55,6 +55,26 @@ macro_rules! impl_float_biteq {\n \n impl_float_biteq! { f32, f64 }\n \n+impl<T> BitEq for *const T {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n+impl<T> BitEq for *mut T {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n impl<T: BitEq, const N: usize> BitEq for [T; N] {\n     fn biteq(&self, other: &Self) -> bool {\n         self.iter()"}, {"sha": "b26cdc311a215678e3083960c4e477d5b412f7f9", "filename": "library/portable-simd/crates/test_helpers/src/lib.rs", "status": "modified", "additions": 242, "deletions": 104, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -38,6 +38,28 @@ impl_num! { usize }\n impl_num! { f32 }\n impl_num! { f64 }\n \n+impl<T> DefaultStrategy for *const T {\n+    type Strategy = proptest::strategy::Map<proptest::num::isize::Any, fn(isize) -> *const T>;\n+    fn default_strategy() -> Self::Strategy {\n+        fn map<T>(x: isize) -> *const T {\n+            x as _\n+        }\n+        use proptest::strategy::Strategy;\n+        proptest::num::isize::ANY.prop_map(map)\n+    }\n+}\n+\n+impl<T> DefaultStrategy for *mut T {\n+    type Strategy = proptest::strategy::Map<proptest::num::isize::Any, fn(isize) -> *mut T>;\n+    fn default_strategy() -> Self::Strategy {\n+        fn map<T>(x: isize) -> *mut T {\n+            x as _\n+        }\n+        use proptest::strategy::Strategy;\n+        proptest::num::isize::ANY.prop_map(map)\n+    }\n+}\n+\n #[cfg(not(target_arch = \"wasm32\"))]\n impl DefaultStrategy for u128 {\n     type Strategy = proptest::num::u128::Any;\n@@ -135,21 +157,21 @@ pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const\n     fs: &dyn Fn(Scalar) -> ScalarResult,\n     check: &dyn Fn([Scalar; LANES]) -> bool,\n ) where\n-    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Scalar: Copy + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n     Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_1(&|x: [Scalar; LANES]| {\n         proptest::prop_assume!(check(x));\n         let result_1: [ScalarResult; LANES] = fv(x.into()).into();\n-        let result_2: [ScalarResult; LANES] = {\n-            let mut result = [ScalarResult::default(); LANES];\n-            for (i, o) in x.iter().zip(result.iter_mut()) {\n-                *o = fs(*i);\n-            }\n-            result\n-        };\n+        let result_2: [ScalarResult; LANES] = x\n+            .iter()\n+            .copied()\n+            .map(fs)\n+            .collect::<Vec<_>>()\n+            .try_into()\n+            .unwrap();\n         crate::prop_assert_biteq!(result_1, result_2);\n         Ok(())\n     });\n@@ -162,7 +184,7 @@ pub fn test_unary_mask_elementwise<Scalar, Vector, Mask, const LANES: usize>(\n     fs: &dyn Fn(Scalar) -> bool,\n     check: &dyn Fn([Scalar; LANES]) -> bool,\n ) where\n-    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar: Copy + core::fmt::Debug + DefaultStrategy,\n     Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n     Mask: Into<[bool; LANES]> + From<[bool; LANES]> + Copy,\n {\n@@ -196,23 +218,24 @@ pub fn test_binary_elementwise<\n     fs: &dyn Fn(Scalar1, Scalar2) -> ScalarResult,\n     check: &dyn Fn([Scalar1; LANES], [Scalar2; LANES]) -> bool,\n ) where\n-    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Scalar1: Copy + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n     Vector1: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n     Vector2: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_2(&|x: [Scalar1; LANES], y: [Scalar2; LANES]| {\n         proptest::prop_assume!(check(x, y));\n         let result_1: [ScalarResult; LANES] = fv(x.into(), y.into()).into();\n-        let result_2: [ScalarResult; LANES] = {\n-            let mut result = [ScalarResult::default(); LANES];\n-            for ((i1, i2), o) in x.iter().zip(y.iter()).zip(result.iter_mut()) {\n-                *o = fs(*i1, *i2);\n-            }\n-            result\n-        };\n+        let result_2: [ScalarResult; LANES] = x\n+            .iter()\n+            .copied()\n+            .zip(y.iter().copied())\n+            .map(|(x, y)| fs(x, y))\n+            .collect::<Vec<_>>()\n+            .try_into()\n+            .unwrap();\n         crate::prop_assert_biteq!(result_1, result_2);\n         Ok(())\n     });\n@@ -333,6 +356,39 @@ pub fn test_ternary_elementwise<\n     );\n }\n \n+#[doc(hidden)]\n+#[macro_export]\n+macro_rules! test_lanes_helper {\n+    ($($(#[$meta:meta])* $fn_name:ident $lanes:literal;)+) => {\n+        $(\n+            #[test]\n+            $(#[$meta])*\n+            fn $fn_name() {\n+                implementation::<$lanes>();\n+            }\n+        )+\n+    };\n+    (\n+        $(#[$meta:meta])+;\n+        $($(#[$meta_before:meta])+ $fn_name_before:ident $lanes_before:literal;)*\n+        $fn_name:ident $lanes:literal;\n+        $($fn_name_rest:ident $lanes_rest:literal;)*\n+    ) => {\n+        $crate::test_lanes_helper!(\n+            $(#[$meta])+;\n+            $($(#[$meta_before])+ $fn_name_before $lanes_before;)*\n+            $(#[$meta])+ $fn_name $lanes;\n+            $($fn_name_rest $lanes_rest;)*\n+        );\n+    };\n+    (\n+        $(#[$meta_ignored:meta])+;\n+        $($(#[$meta:meta])+ $fn_name:ident $lanes:literal;)+\n+    ) => {\n+        $crate::test_lanes_helper!($($(#[$meta])+ $fn_name $lanes;)+);\n+    };\n+}\n+\n /// Expand a const-generic test into separate tests for each possible lane count.\n #[macro_export]\n macro_rules! test_lanes {\n@@ -345,57 +401,96 @@ macro_rules! test_lanes {\n \n                 fn implementation<const $lanes: usize>()\n                 where\n-                    core_simd::LaneCount<$lanes>: core_simd::SupportedLaneCount,\n+                    core_simd::simd::LaneCount<$lanes>: core_simd::simd::SupportedLaneCount,\n                 $body\n \n                 #[cfg(target_arch = \"wasm32\")]\n                 wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);\n \n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n-                fn lanes_1() {\n-                    implementation::<1>();\n-                }\n-\n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n-                fn lanes_2() {\n-                    implementation::<2>();\n-                }\n-\n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n-                fn lanes_4() {\n-                    implementation::<4>();\n-                }\n+                $crate::test_lanes_helper!(\n+                    #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)];\n+                    lanes_1 1;\n+                    lanes_2 2;\n+                    lanes_4 4;\n+                );\n \n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n                 #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n-                fn lanes_8() {\n-                    implementation::<8>();\n-                }\n-\n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                $crate::test_lanes_helper!(\n+                    #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)];\n+                    lanes_8 8;\n+                    lanes_16 16;\n+                    lanes_32 32;\n+                    lanes_64 64;\n+                );\n+\n+                #[cfg(feature = \"all_lane_counts\")]\n+                $crate::test_lanes_helper!(\n+                    // test some odd and even non-power-of-2 lengths on miri\n+                    #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)];\n+                    lanes_3 3;\n+                    lanes_5 5;\n+                    lanes_6 6;\n+                );\n+\n+                #[cfg(feature = \"all_lane_counts\")]\n                 #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n-                fn lanes_16() {\n-                    implementation::<16>();\n-                }\n-\n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n-                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n-                fn lanes_32() {\n-                    implementation::<32>();\n-                }\n-\n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n-                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n-                fn lanes_64() {\n-                    implementation::<64>();\n-                }\n+                $crate::test_lanes_helper!(\n+                    #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)];\n+                    lanes_7 7;\n+                    lanes_9 9;\n+                    lanes_10 10;\n+                    lanes_11 11;\n+                    lanes_12 12;\n+                    lanes_13 13;\n+                    lanes_14 14;\n+                    lanes_15 15;\n+                    lanes_17 17;\n+                    lanes_18 18;\n+                    lanes_19 19;\n+                    lanes_20 20;\n+                    lanes_21 21;\n+                    lanes_22 22;\n+                    lanes_23 23;\n+                    lanes_24 24;\n+                    lanes_25 25;\n+                    lanes_26 26;\n+                    lanes_27 27;\n+                    lanes_28 28;\n+                    lanes_29 29;\n+                    lanes_30 30;\n+                    lanes_31 31;\n+                    lanes_33 33;\n+                    lanes_34 34;\n+                    lanes_35 35;\n+                    lanes_36 36;\n+                    lanes_37 37;\n+                    lanes_38 38;\n+                    lanes_39 39;\n+                    lanes_40 40;\n+                    lanes_41 41;\n+                    lanes_42 42;\n+                    lanes_43 43;\n+                    lanes_44 44;\n+                    lanes_45 45;\n+                    lanes_46 46;\n+                    lanes_47 47;\n+                    lanes_48 48;\n+                    lanes_49 49;\n+                    lanes_50 50;\n+                    lanes_51 51;\n+                    lanes_52 52;\n+                    lanes_53 53;\n+                    lanes_54 54;\n+                    lanes_55 55;\n+                    lanes_56 56;\n+                    lanes_57 57;\n+                    lanes_58 58;\n+                    lanes_59 59;\n+                    lanes_60 60;\n+                    lanes_61 61;\n+                    lanes_62 62;\n+                    lanes_63 63;\n+                );\n             }\n         )*\n     }\n@@ -413,50 +508,93 @@ macro_rules! test_lanes_panic {\n \n                 fn implementation<const $lanes: usize>()\n                 where\n-                    core_simd::LaneCount<$lanes>: core_simd::SupportedLaneCount,\n+                    core_simd::simd::LaneCount<$lanes>: core_simd::simd::SupportedLaneCount,\n                 $body\n \n-                #[test]\n-                #[should_panic]\n-                fn lanes_1() {\n-                    implementation::<1>();\n-                }\n-\n-                #[test]\n-                #[should_panic]\n-                fn lanes_2() {\n-                    implementation::<2>();\n-                }\n-\n-                #[test]\n-                #[should_panic]\n-                fn lanes_4() {\n-                    implementation::<4>();\n-                }\n-\n-                #[test]\n-                #[should_panic]\n-                fn lanes_8() {\n-                    implementation::<8>();\n-                }\n+                $crate::test_lanes_helper!(\n+                    #[should_panic];\n+                    lanes_1 1;\n+                    lanes_2 2;\n+                    lanes_4 4;\n+                );\n \n-                #[test]\n-                #[should_panic]\n-                fn lanes_16() {\n-                    implementation::<16>();\n-                }\n-\n-                #[test]\n-                #[should_panic]\n-                fn lanes_32() {\n-                    implementation::<32>();\n-                }\n-\n-                #[test]\n-                #[should_panic]\n-                fn lanes_64() {\n-                    implementation::<64>();\n-                }\n+                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n+                $crate::test_lanes_helper!(\n+                    #[should_panic];\n+                    lanes_8 8;\n+                    lanes_16 16;\n+                    lanes_32 32;\n+                    lanes_64 64;\n+                );\n+\n+                #[cfg(feature = \"all_lane_counts\")]\n+                $crate::test_lanes_helper!(\n+                    // test some odd and even non-power-of-2 lengths on miri\n+                    #[should_panic];\n+                    lanes_3 3;\n+                    lanes_5 5;\n+                    lanes_6 6;\n+                );\n+\n+                #[cfg(feature = \"all_lane_counts\")]\n+                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n+                $crate::test_lanes_helper!(\n+                    #[should_panic];\n+                    lanes_7 7;\n+                    lanes_9 9;\n+                    lanes_10 10;\n+                    lanes_11 11;\n+                    lanes_12 12;\n+                    lanes_13 13;\n+                    lanes_14 14;\n+                    lanes_15 15;\n+                    lanes_17 17;\n+                    lanes_18 18;\n+                    lanes_19 19;\n+                    lanes_20 20;\n+                    lanes_21 21;\n+                    lanes_22 22;\n+                    lanes_23 23;\n+                    lanes_24 24;\n+                    lanes_25 25;\n+                    lanes_26 26;\n+                    lanes_27 27;\n+                    lanes_28 28;\n+                    lanes_29 29;\n+                    lanes_30 30;\n+                    lanes_31 31;\n+                    lanes_33 33;\n+                    lanes_34 34;\n+                    lanes_35 35;\n+                    lanes_36 36;\n+                    lanes_37 37;\n+                    lanes_38 38;\n+                    lanes_39 39;\n+                    lanes_40 40;\n+                    lanes_41 41;\n+                    lanes_42 42;\n+                    lanes_43 43;\n+                    lanes_44 44;\n+                    lanes_45 45;\n+                    lanes_46 46;\n+                    lanes_47 47;\n+                    lanes_48 48;\n+                    lanes_49 49;\n+                    lanes_50 50;\n+                    lanes_51 51;\n+                    lanes_52 52;\n+                    lanes_53 53;\n+                    lanes_54 54;\n+                    lanes_55 55;\n+                    lanes_56 56;\n+                    lanes_57 57;\n+                    lanes_58 58;\n+                    lanes_59 59;\n+                    lanes_60 60;\n+                    lanes_61 61;\n+                    lanes_62 62;\n+                    lanes_63 63;\n+                );\n             }\n         )*\n     }"}, {"sha": "10939c0f1c38a82bb57f6ab3caf8a887e5c47878", "filename": "src/tools/miri/tests/fail/intrinsics/simd-float-to-int.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,9 +1,8 @@\n-//@error-in-other-file: cannot be represented in target type `i32`\n #![feature(portable_simd)]\n use std::simd::*;\n \n fn main() {\n     unsafe {\n-        let _x: i32x2 = f32x2::from_array([f32::MAX, f32::MIN]).to_int_unchecked();\n+        let _x: i32x2 = f32x2::from_array([f32::MAX, f32::MIN]).to_int_unchecked(); //~ERROR: cannot be represented in target type `i32`\n     }\n }"}, {"sha": "ea5ad62aea908765d616d27fd9f9a7c6d2694974", "filename": "src/tools/miri/tests/fail/intrinsics/simd-float-to-int.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.stderr?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,18 +1,13 @@\n error: Undefined Behavior: `float_to_int_unchecked` intrinsic called on 3.40282347E+38 which cannot be represented in target type `i32`\n-  --> RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n+  --> $DIR/simd-float-to-int.rs:LL:CC\n    |\n-LL |         unsafe { intrinsics::simd_cast(self) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `float_to_int_unchecked` intrinsic called on 3.40282347E+38 which cannot be represented in target type `i32`\n+LL |         let _x: i32x2 = f32x2::from_array([f32::MAX, f32::MIN]).to_int_unchecked();\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `float_to_int_unchecked` intrinsic called on 3.40282347E+38 which cannot be represented in target type `i32`\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:\n-   = note: inside `std::simd::Simd::<f32, 2>::to_int_unchecked::<i32>` at RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n-note: inside `main`\n-  --> $DIR/simd-float-to-int.rs:LL:CC\n-   |\n-LL |         let _x: i32x2 = f32x2::from_array([f32::MAX, f32::MIN]).to_int_unchecked();\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: inside `main` at $DIR/simd-float-to-int.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "ceb7beebd8abad93bd8e3559032a049b372f41e5", "filename": "src/tools/miri/tests/fail/intrinsics/simd-gather.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,11 +1,10 @@\n-//@error-in-other-file: pointer to 1 byte starting at offset 9 is out-of-bounds\n #![feature(portable_simd)]\n use std::simd::*;\n \n fn main() {\n     unsafe {\n         let vec: &[i8] = &[10, 11, 12, 13, 14, 15, 16, 17, 18];\n         let idxs = Simd::from_array([9, 3, 0, 17]);\n-        let _result = Simd::gather_select_unchecked(&vec, Mask::splat(true), idxs, Simd::splat(0));\n+        let _result = Simd::gather_select_unchecked(&vec, Mask::splat(true), idxs, Simd::splat(0)); //~ERROR: pointer to 1 byte starting at offset 9 is out-of-bounds\n     }\n }"}, {"sha": "f82b30a9633ee4e29ee449815ae6daa64edbd5f3", "filename": "src/tools/miri/tests/fail/intrinsics/simd-gather.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.stderr?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,18 +1,13 @@\n error: Undefined Behavior: dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n-  --> RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n+  --> $DIR/simd-gather.rs:LL:CC\n    |\n-LL |         unsafe { intrinsics::simd_gather(or, ptrs, enable.to_int()) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n+LL |         let _result = Simd::gather_select_unchecked(&vec, Mask::splat(true), idxs, Simd::splat(0));\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:\n-   = note: inside `std::simd::Simd::<i8, 4>::gather_select_unchecked` at RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n-note: inside `main`\n-  --> $DIR/simd-gather.rs:LL:CC\n-   |\n-LL |         let _result = Simd::gather_select_unchecked(&vec, Mask::splat(true), idxs, Simd::splat(0));\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: inside `main` at $DIR/simd-gather.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "606a6b2798a088854beb00d34e81f544408c47a1", "filename": "src/tools/miri/tests/fail/intrinsics/simd-scatter.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.rs?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,12 +1,11 @@\n-//@error-in-other-file: pointer to 1 byte starting at offset 9 is out-of-bounds\n #![feature(portable_simd)]\n use std::simd::*;\n \n fn main() {\n     unsafe {\n         let mut vec: Vec<i8> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n         let idxs = Simd::from_array([9, 3, 0, 17]);\n-        Simd::from_array([-27, 82, -41, 124]).scatter_select_unchecked(\n+        Simd::from_array([-27, 82, -41, 124]).scatter_select_unchecked( //~ERROR: pointer to 1 byte starting at offset 9 is out-of-bounds\n             &mut vec,\n             Mask::splat(true),\n             idxs,"}, {"sha": "6d959af85fa751021b9c20f48382350ed87d05fb", "filename": "src/tools/miri/tests/fail/intrinsics/simd-scatter.stderr", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.stderr?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -1,22 +1,17 @@\n error: Undefined Behavior: dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n-  --> RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n-   |\n-LL |             intrinsics::simd_scatter(self, ptrs, enable.to_int())\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n-   |\n-   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n-   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n-   = note: inside `std::simd::Simd::<i8, 4>::scatter_select_unchecked` at RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n-note: inside `main`\n   --> $DIR/simd-scatter.rs:LL:CC\n    |\n LL | /         Simd::from_array([-27, 82, -41, 124]).scatter_select_unchecked(\n LL | |             &mut vec,\n LL | |             Mask::splat(true),\n LL | |             idxs,\n LL | |         );\n-   | |_________^\n+   | |_________^ dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE:\n+   = note: inside `main` at $DIR/simd-scatter.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "217f27efe5cc9eff3f1226110f9552c1725addcb", "filename": "tests/mir-opt/lower_intrinsics.wrapping.LowerIntrinsics.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/tests%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/tests%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -30,10 +30,10 @@\n           _4 = _1;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:45: +1:46\n           StorageLive(_5);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:48: +1:49\n           _5 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:48: +1:49\n--         _3 = wrapping_add::<i32>(move _4, move _5) -> [return: bb1, unwind unreachable]; // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:50\n+-         _3 = std::intrinsics::wrapping_add::<i32>(move _4, move _5) -> [return: bb1, unwind unreachable]; // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:9:14: 9:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_add::<i32>}, val: Value(<ZST>) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {std::intrinsics::wrapping_add::<i32>}, val: Value(<ZST>) }\n +         _3 = Add(move _4, move _5);      // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:50\n +         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:50\n       }\n@@ -46,10 +46,10 @@\n           _7 = _1;                         // scope 1 at $DIR/lower_intrinsics.rs:+2:45: +2:46\n           StorageLive(_8);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:48: +2:49\n           _8 = _2;                         // scope 1 at $DIR/lower_intrinsics.rs:+2:48: +2:49\n--         _6 = wrapping_sub::<i32>(move _7, move _8) -> [return: bb2, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:50\n+-         _6 = std::intrinsics::wrapping_sub::<i32>(move _7, move _8) -> [return: bb2, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:10:14: 10:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_sub::<i32>}, val: Value(<ZST>) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {std::intrinsics::wrapping_sub::<i32>}, val: Value(<ZST>) }\n +         _6 = Sub(move _7, move _8);      // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:50\n +         goto -> bb2;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:50\n       }"}, {"sha": "b0dddd3b1e8d01b1dde5eae95cc448e40de46b67", "filename": "tests/ui/fmt/ifmt-unimpl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26e0c57dde7ea664457e3bf1340f832c722bd349/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26e0c57dde7ea664457e3bf1340f832c722bd349/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr?ref=26e0c57dde7ea664457e3bf1340f832c722bd349", "patch": "@@ -15,7 +15,7 @@ LL |     format!(\"{:X}\", \"3\");\n              NonZeroI64\n              NonZeroI8\n              NonZeroIsize\n-           and 21 others\n+           and 20 others\n    = note: required for `&str` to implement `UpperHex`\n note: required by a bound in `core::fmt::rt::Argument::<'a>::new_upper_hex`\n   --> $SRC_DIR/core/src/fmt/rt.rs:LL:COL"}]}