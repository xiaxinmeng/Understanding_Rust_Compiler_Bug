{"sha": "cefee7bd9a7e188e406cac0190cf4a19fcca27ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZmVlN2JkOWE3ZTE4OGU0MDZjYWMwMTkwY2Y0YTE5ZmNjYTI3ZmY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-09T03:29:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-09T03:29:42Z"}, "message": "Rollup merge of #70868 - petrochenkov:linkorder, r=nagisa,mati865\n\nrustc_codegen_ssa: Refactor construction of linker arguments\n\nAnd add comments.\n\nThis PR doesn't reorder any linker arguments and therefore shouldn't contain any observable changes.\n\nThe next goal here is to\n- Factor out order-independent linker arguments in the compiler code and in target specifications and pass them together. Such arguments generally apply to the whole linking session or the produced linking result rather to individual object files or libraries.\n- Figure out where exactly among the remaining order-dependent arguments we should place customization points like `-C link-args` and `-Z pre-link-args`.\n- Possibly provide command line opt-outs for options that are currently passed unconditionally (like CRT objects or arguments defined by the target spec).\n- Document and stabilize the customization points that are not yet stable (https://github.com/rust-lang/rust/pull/70505).", "tree": {"sha": "393a0a8255eaa6c3a3905152ec4b78bdda5815af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/393a0a8255eaa6c3a3905152ec4b78bdda5815af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cefee7bd9a7e188e406cac0190cf4a19fcca27ff", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejpamCRBK7hj4Ov3rIwAAdHIIAFRovCiO68Bh+Reb7Fz+tjYH\n59ZcV60r1BN2hRcKiENYjOTJEvCHkkeou2SU21YDMRUsPwLdvBwnOpVgjkZLE0HJ\ni+eFXEu91wY5MUAAohhtpeJJyui1iCqOUjZBJLVh4I1vIwQ+9lFaF5OJs4sZEPSM\nxS3y8o8euj4PPasSIrt+RvgdEfs5IG2OPPYVecy96nYutMfFgDoOaxpIorxKQsRp\ncvx+MrgKU4wrkpWdlYEPKK5EPOQJZJEZXhTsLGkht3a1h5jBKeiNBMJKw20Sjheo\n8QP7ZWv4qnCmgv44cRZt7C6LAtugl8msfv3+41uwfTJPNtVFsexCe7oBYyubOEA=\n=NRGm\n-----END PGP SIGNATURE-----\n", "payload": "tree 393a0a8255eaa6c3a3905152ec4b78bdda5815af\nparent a209b4f447b528362354edfd78aa96349633dc17\nparent 5a4fa4554f26b1d34c4b336f4609edc65704643e\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1586402982 +0200\ncommitter GitHub <noreply@github.com> 1586402982 +0200\n\nRollup merge of #70868 - petrochenkov:linkorder, r=nagisa,mati865\n\nrustc_codegen_ssa: Refactor construction of linker arguments\n\nAnd add comments.\n\nThis PR doesn't reorder any linker arguments and therefore shouldn't contain any observable changes.\n\nThe next goal here is to\n- Factor out order-independent linker arguments in the compiler code and in target specifications and pass them together. Such arguments generally apply to the whole linking session or the produced linking result rather to individual object files or libraries.\n- Figure out where exactly among the remaining order-dependent arguments we should place customization points like `-C link-args` and `-Z pre-link-args`.\n- Possibly provide command line opt-outs for options that are currently passed unconditionally (like CRT objects or arguments defined by the target spec).\n- Document and stabilize the customization points that are not yet stable (https://github.com/rust-lang/rust/pull/70505).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cefee7bd9a7e188e406cac0190cf4a19fcca27ff", "html_url": "https://github.com/rust-lang/rust/commit/cefee7bd9a7e188e406cac0190cf4a19fcca27ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cefee7bd9a7e188e406cac0190cf4a19fcca27ff/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a209b4f447b528362354edfd78aa96349633dc17", "url": "https://api.github.com/repos/rust-lang/rust/commits/a209b4f447b528362354edfd78aa96349633dc17", "html_url": "https://github.com/rust-lang/rust/commit/a209b4f447b528362354edfd78aa96349633dc17"}, {"sha": "5a4fa4554f26b1d34c4b336f4609edc65704643e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a4fa4554f26b1d34c4b336f4609edc65704643e", "html_url": "https://github.com/rust-lang/rust/commit/5a4fa4554f26b1d34c4b336f4609edc65704643e"}], "stats": {"total": 674, "additions": 413, "deletions": 261}, "files": [{"sha": "20e64f0c488515c5baec199c38afd8d0e0117a84", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 374, "deletions": 225, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/cefee7bd9a7e188e406cac0190cf4a19fcca27ff/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefee7bd9a7e188e406cac0190cf4a19fcca27ff/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=cefee7bd9a7e188e406cac0190cf4a19fcca27ff", "patch": "@@ -154,7 +154,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain\n-pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathBuf, Command) {\n+fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> Command {\n     let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n \n     // If our linker looks like a batch script on Windows then to execute this\n@@ -193,6 +193,7 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n                     _ => None,\n                 };\n                 if let Some(ref a) = arch {\n+                    // FIXME: Move this to `fn linker_with_args`.\n                     let mut arg = OsString::from(\"/LIBPATH:\");\n                     arg.push(format!(\"{}\\\\lib\\\\{}\\\\store\", root_lib_path.display(), a.to_string()));\n                     cmd.arg(&arg);\n@@ -232,7 +233,7 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n     }\n     cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n \n-    (linker.to_path_buf(), cmd)\n+    cmd\n }\n \n pub fn each_linked_rlib(\n@@ -284,11 +285,7 @@ pub fn each_linked_rlib(\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-pub fn emit_metadata<'a>(\n-    sess: &'a Session,\n-    metadata: &EncodedMetadata,\n-    tmpdir: &TempDir,\n-) -> PathBuf {\n+pub fn emit_metadata(sess: &Session, metadata: &EncodedMetadata, tmpdir: &TempDir) -> PathBuf {\n     let out_filename = tmpdir.path().join(METADATA_FILENAME);\n     let result = fs::write(&out_filename, &metadata.raw_data);\n \n@@ -487,95 +484,18 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     target_cpu: &str,\n ) {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n-    let (linker, flavor) = linker_and_flavor(sess);\n-\n-    let any_dynamic_crate = crate_type == config::CrateType::Dylib\n-        || codegen_results.crate_info.dependency_formats.iter().any(|(ty, list)| {\n-            *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-        });\n-\n-    // The invocations of cc share some flags across platforms\n-    let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n-\n-    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n-        if sess.crt_static(Some(crate_type)) {\n-            cmd.args(args);\n-        }\n-    }\n-    cmd.args(&sess.opts.debugging_opts.pre_link_args);\n-\n-    if sess.target.target.options.is_like_fuchsia {\n-        let prefix = match sess.opts.debugging_opts.sanitizer {\n-            Some(Sanitizer::Address) => \"asan/\",\n-            _ => \"\",\n-        };\n-        cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n-    }\n-\n-    let pre_link_objects = if crate_type == config::CrateType::Executable {\n-        &sess.target.target.options.pre_link_objects_exe\n-    } else {\n-        &sess.target.target.options.pre_link_objects_dll\n-    };\n-    for obj in pre_link_objects {\n-        cmd.arg(get_file_path(sess, obj));\n-    }\n-\n-    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n-        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n-            cmd.arg(get_file_path(sess, obj));\n-        }\n-    }\n-\n-    if sess.target.target.options.is_like_emscripten {\n-        cmd.arg(\"-s\");\n-        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n-            \"DISABLE_EXCEPTION_CATCHING=1\"\n-        } else {\n-            \"DISABLE_EXCEPTION_CATCHING=0\"\n-        });\n-    }\n+    let (linker_path, flavor) = linker_and_flavor(sess);\n+    let mut cmd = linker_with_args::<B>(\n+        &linker_path,\n+        flavor,\n+        sess,\n+        crate_type,\n+        tmpdir,\n+        out_filename,\n+        codegen_results,\n+        target_cpu,\n+    );\n \n-    {\n-        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor, target_cpu);\n-        link_sanitizer_runtime(sess, crate_type, &mut *linker);\n-        link_args::<B>(\n-            &mut *linker,\n-            flavor,\n-            sess,\n-            crate_type,\n-            tmpdir,\n-            out_filename,\n-            codegen_results,\n-        );\n-        cmd = linker.finalize();\n-    }\n-    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    if any_dynamic_crate {\n-        if let Some(args) = sess.target.target.options.late_link_args_dynamic.get(&flavor) {\n-            cmd.args(args);\n-        }\n-    } else {\n-        if let Some(args) = sess.target.target.options.late_link_args_static.get(&flavor) {\n-            cmd.args(args);\n-        }\n-    }\n-    for obj in &sess.target.target.options.post_link_objects {\n-        cmd.arg(get_file_path(sess, obj));\n-    }\n-    if sess.crt_static(Some(crate_type)) {\n-        for obj in &sess.target.target.options.post_link_objects_crt {\n-            cmd.arg(get_file_path(sess, obj));\n-        }\n-    }\n-    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n     for &(ref k, ref v) in &sess.target.target.options.link_env {\n         cmd.env(k, v);\n     }\n@@ -597,7 +517,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     let mut i = 0;\n     loop {\n         i += 1;\n-        prog = sess.time(\"run_linker\", || exec_linker(sess, &mut cmd, out_filename, tmpdir));\n+        prog = sess.time(\"run_linker\", || exec_linker(sess, &cmd, out_filename, tmpdir));\n         let output = match prog {\n             Ok(ref output) => output,\n             Err(_) => break,\n@@ -698,7 +618,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n                 output.extend_from_slice(&prog.stdout);\n                 sess.struct_err(&format!(\n                     \"linking with `{}` failed: {}\",\n-                    pname.display(),\n+                    linker_path.display(),\n                     prog.status\n                 ))\n                 .note(&format!(\"{:?}\", &cmd))\n@@ -714,9 +634,12 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n             let mut linker_error = {\n                 if linker_not_found {\n-                    sess.struct_err(&format!(\"linker `{}` not found\", pname.display()))\n+                    sess.struct_err(&format!(\"linker `{}` not found\", linker_path.display()))\n                 } else {\n-                    sess.struct_err(&format!(\"could not exec the linker `{}`\", pname.display()))\n+                    sess.struct_err(&format!(\n+                        \"could not exec the linker `{}`\",\n+                        linker_path.display()\n+                    ))\n                 }\n             };\n \n@@ -787,7 +710,7 @@ fn link_sanitizer_runtime(sess: &Session, crate_type: config::CrateType, linker:\n             // PR #41352 for details).\n             let libname = format!(\"rustc{}_rt.{}\", channel, name);\n             let rpath = default_tlib.to_str().expect(\"non-utf8 component in path\");\n-            linker.args(&[\"-Wl,-rpath\".into(), \"-Xlinker\".into(), rpath.into()]);\n+            linker.args(&[\"-Wl,-rpath\", \"-Xlinker\", rpath]);\n             linker.link_dylib(Symbol::intern(&libname));\n         }\n         \"x86_64-unknown-linux-gnu\" | \"x86_64-fuchsia\" | \"aarch64-fuchsia\" => {\n@@ -817,7 +740,7 @@ pub fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool\n         && (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n }\n \n-pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n+fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n     fn infer_from(\n         sess: &Session,\n         linker: Option<PathBuf>,\n@@ -905,7 +828,7 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n /// Returns a boolean indicating whether we should preserve the object files on\n /// the filesystem for their debug information. This is often useful with\n /// split-dwarf like schemes.\n-pub fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n+fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n     // If the objects don't have debuginfo there's nothing to preserve.\n     if sess.opts.debuginfo == config::DebugInfo::None {\n         return false;\n@@ -959,7 +882,7 @@ enum RlibFlavor {\n     StaticlibBase,\n }\n \n-pub fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n+fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n     let lib_args: Vec<_> = all_native_libs\n         .iter()\n         .filter(|l| relevant_lib(sess, l))\n@@ -1061,7 +984,7 @@ fn get_crt_libs_path(sess: &Session) -> Option<PathBuf> {\n     }\n }\n \n-pub fn get_file_path(sess: &Session, name: &str) -> PathBuf {\n+fn get_object_file_path(sess: &Session, name: &str) -> PathBuf {\n     // prefer system {,dll}crt2.o libs, see get_crt_libs_path comment for more details\n     if sess.target.target.llvm_target.contains(\"windows-gnu\") {\n         if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n@@ -1085,9 +1008,9 @@ pub fn get_file_path(sess: &Session, name: &str) -> PathBuf {\n     PathBuf::from(name)\n }\n \n-pub fn exec_linker(\n+fn exec_linker(\n     sess: &Session,\n-    cmd: &mut Command,\n+    cmd: &Command,\n     out_filename: &Path,\n     tmpdir: &Path,\n ) -> io::Result<Output> {\n@@ -1233,134 +1156,142 @@ pub fn exec_linker(\n     }\n }\n \n-fn link_args<'a, B: ArchiveBuilder<'a>>(\n+/// Add begin object files defined by the target spec.\n+fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config::CrateType) {\n+    let pre_link_objects = if crate_type == config::CrateType::Executable {\n+        &sess.target.target.options.pre_link_objects_exe\n+    } else {\n+        &sess.target.target.options.pre_link_objects_dll\n+    };\n+    for obj in pre_link_objects {\n+        cmd.add_object(&get_object_file_path(sess, obj));\n+    }\n+\n+    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n+        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n+            cmd.add_object(&get_object_file_path(sess, obj));\n+        }\n+    }\n+}\n+\n+/// Add end object files defined by the target spec.\n+fn add_post_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config::CrateType) {\n+    for obj in &sess.target.target.options.post_link_objects {\n+        cmd.add_object(&get_object_file_path(sess, obj));\n+    }\n+    if sess.crt_static(Some(crate_type)) {\n+        for obj in &sess.target.target.options.post_link_objects_crt {\n+            cmd.add_object(&get_object_file_path(sess, obj));\n+        }\n+    }\n+}\n+\n+/// Add arbitrary \"pre-link\" args defined by the target spec or from command line.\n+/// FIXME: Determine where exactly these args need to be inserted.\n+fn add_pre_link_args(\n     cmd: &mut dyn Linker,\n+    sess: &Session,\n     flavor: LinkerFlavor,\n-    sess: &'a Session,\n     crate_type: config::CrateType,\n-    tmpdir: &Path,\n-    out_filename: &Path,\n-    codegen_results: &CodegenResults,\n ) {\n-    // Linker plugins should be specified early in the list of arguments\n-    cmd.linker_plugin_lto();\n-\n-    // The default library location, we need this to find the runtime.\n-    // The location of crates will be determined as needed.\n-    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n+    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n+        if sess.crt_static(Some(crate_type)) {\n+            cmd.args(args);\n+        }\n+    }\n+    cmd.args(&sess.opts.debugging_opts.pre_link_args);\n+}\n \n-    // target descriptor\n-    let t = &sess.target.target;\n+/// Add arbitrary \"user defined\" args defined from command line and by `#[link_args]` attributes.\n+/// FIXME: Determine where exactly these args need to be inserted.\n+fn add_user_defined_link_args(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    codegen_results: &CodegenResults,\n+) {\n+    cmd.args(&sess.opts.cg.link_args);\n+    cmd.args(&*codegen_results.crate_info.link_args);\n+}\n \n-    // prefer system mingw-w64 libs, see get_crt_libs_path comment for more details\n-    if cfg!(windows) && sess.target.target.llvm_target.contains(\"windows-gnu\") {\n-        if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n-            cmd.include_path(&compiler_libs_path);\n+/// Add arbitrary \"late link\" args defined by the target spec.\n+/// FIXME: Determine where exactly these args need to be inserted.\n+fn add_late_link_args(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    flavor: LinkerFlavor,\n+    crate_type: config::CrateType,\n+    codegen_results: &CodegenResults,\n+) {\n+    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    let any_dynamic_crate = crate_type == config::CrateType::Dylib\n+        || codegen_results.crate_info.dependency_formats.iter().any(|(ty, list)| {\n+            *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+        });\n+    if any_dynamic_crate {\n+        if let Some(args) = sess.target.target.options.late_link_args_dynamic.get(&flavor) {\n+            cmd.args(args);\n+        }\n+    } else {\n+        if let Some(args) = sess.target.target.options.late_link_args_static.get(&flavor) {\n+            cmd.args(args);\n         }\n     }\n+}\n \n-    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+/// Add arbitrary \"post-link\" args defined by the target spec.\n+/// FIXME: Determine where exactly these args need to be inserted.\n+fn add_post_link_args(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n+    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+}\n \n+/// Add object files containing code from the current crate.\n+fn add_local_crate_regular_objects(cmd: &mut dyn Linker, codegen_results: &CodegenResults) {\n     for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n         cmd.add_object(obj);\n     }\n-    cmd.output_filename(out_filename);\n+}\n \n-    if crate_type == config::CrateType::Executable && sess.target.target.options.is_like_windows {\n-        if let Some(ref s) = codegen_results.windows_subsystem {\n-            cmd.subsystem(s);\n-        }\n+/// Add object files for allocator code linked once for the whole crate tree.\n+fn add_local_crate_allocator_objects(cmd: &mut dyn Linker, codegen_results: &CodegenResults) {\n+    if let Some(obj) = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref()) {\n+        cmd.add_object(obj);\n     }\n+}\n \n-    // If we're building something like a dynamic library then some platforms\n-    // need to make sure that all symbols are exported correctly from the\n-    // dynamic library.\n-    cmd.export_symbols(tmpdir, crate_type);\n-\n+/// Add object files containing metadata for the current crate.\n+fn add_local_crate_metadata_objects(\n+    cmd: &mut dyn Linker,\n+    crate_type: config::CrateType,\n+    codegen_results: &CodegenResults,\n+) {\n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n     if crate_type == config::CrateType::Dylib || crate_type == config::CrateType::ProcMacro {\n-        let obj = codegen_results.metadata_module.as_ref().and_then(|m| m.object.as_ref());\n-        if let Some(obj) = obj {\n+        if let Some(obj) = codegen_results.metadata_module.as_ref().and_then(|m| m.object.as_ref())\n+        {\n             cmd.add_object(obj);\n         }\n     }\n+}\n \n-    let obj = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref());\n-    if let Some(obj) = obj {\n-        cmd.add_object(obj);\n-    }\n-\n-    // Try to strip as much out of the generated object by removing unused\n-    // sections if possible. See more comments in linker.rs\n-    if !sess.opts.cg.link_dead_code {\n-        let keep_metadata = crate_type == config::CrateType::Dylib;\n-        cmd.gc_sections(keep_metadata);\n-    }\n-\n-    let attr_link_args = codegen_results.crate_info.link_args.iter();\n-    let user_link_args: Vec<_> =\n-        sess.opts.cg.link_args.iter().chain(attr_link_args).cloned().collect();\n-\n-    if crate_type == config::CrateType::Executable {\n-        let mut position_independent_executable = false;\n-\n-        if t.options.position_independent_executables {\n-            if is_pic(sess)\n-                && !sess.crt_static(Some(crate_type))\n-                && !user_link_args.iter().any(|x| x == \"-static\")\n-            {\n-                position_independent_executable = true;\n-            }\n-        }\n-\n-        if position_independent_executable {\n-            cmd.position_independent_executable();\n-        } else {\n-            // recent versions of gcc can be configured to generate position\n-            // independent executables by default. We have to pass -no-pie to\n-            // explicitly turn that off. Not applicable to ld.\n-            if sess.target.target.options.linker_is_gnu && flavor != LinkerFlavor::Ld {\n-                cmd.no_position_independent_executable();\n-            }\n-        }\n-    }\n-\n-    let relro_level = match sess.opts.debugging_opts.relro_level {\n-        Some(level) => level,\n-        None => t.options.relro_level,\n-    };\n-    match relro_level {\n-        RelroLevel::Full => {\n-            cmd.full_relro();\n-        }\n-        RelroLevel::Partial => {\n-            cmd.partial_relro();\n-        }\n-        RelroLevel::Off => {\n-            cmd.no_relro();\n-        }\n-        RelroLevel::None => {}\n-    }\n-\n-    // Pass optimization flags down to the linker.\n-    cmd.optimize();\n-\n-    // Pass debuginfo flags down to the linker.\n-    cmd.debuginfo();\n-\n-    // We want to, by default, prevent the compiler from accidentally leaking in\n-    // any system libraries, so we may explicitly ask linkers to not link to any\n-    // libraries by default. Note that this does not happen for windows because\n-    // windows pulls in some large number of libraries and I couldn't quite\n-    // figure out which subset we wanted.\n-    //\n-    // This is all naturally configurable via the standard methods as well.\n-    if !sess.opts.cg.default_linker_libraries.unwrap_or(false) && t.options.no_default_libraries {\n-        cmd.no_default_libraries();\n-    }\n-\n+/// Link native libraries corresponding to the current crate and all libraries corresponding to\n+/// all its dependency crates.\n+/// FIXME: Consider combining this with the functions above adding object files for the local crate.\n+fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'a>>(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    crate_type: config::CrateType,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+) {\n     // Take careful note of the ordering of the arguments we pass to the linker\n     // here. Linkers will assume that things on the left depend on things to the\n     // right. Things on the right cannot depend on things on the left. This is\n@@ -1398,22 +1329,73 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(\n     if sess.opts.debugging_opts.link_native_libraries.unwrap_or(true) {\n         add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n     }\n-    // Tell the linker what we're doing.\n+}\n+\n+/// Add sysroot and other globally set directories to the directory search list.\n+fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session) {\n+    // Prefer system mingw-w64 libs, see get_crt_libs_path comment for more details.\n+    if cfg!(windows) && sess.target.target.llvm_target.contains(\"windows-gnu\") {\n+        if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n+            cmd.include_path(&compiler_libs_path);\n+        }\n+    }\n+\n+    // The default library location, we need this to find the runtime.\n+    // The location of crates will be determined as needed.\n+    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n+    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+}\n+\n+/// Add options requesting executables to be position-independent or not position-independent.\n+fn add_position_independent_executable_args(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    flavor: LinkerFlavor,\n+    crate_type: config::CrateType,\n+    codegen_results: &CodegenResults,\n+) {\n     if crate_type != config::CrateType::Executable {\n-        cmd.build_dylib(out_filename);\n+        return;\n     }\n-    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n-        cmd.build_static_executable();\n+\n+    if sess.target.target.options.position_independent_executables {\n+        let attr_link_args = &*codegen_results.crate_info.link_args;\n+        let mut user_defined_link_args = sess.opts.cg.link_args.iter().chain(attr_link_args);\n+        if is_pic(sess)\n+            && !sess.crt_static(Some(crate_type))\n+            && !user_defined_link_args.any(|x| x == \"-static\")\n+        {\n+            cmd.position_independent_executable();\n+            return;\n+        }\n     }\n \n-    if sess.opts.cg.profile_generate.enabled() {\n-        cmd.pgo_gen();\n+    // Recent versions of gcc can be configured to generate position\n+    // independent executables by default. We have to pass -no-pie to\n+    // explicitly turn that off. Not applicable to ld.\n+    if sess.target.target.options.linker_is_gnu && flavor != LinkerFlavor::Ld {\n+        cmd.no_position_independent_executable();\n     }\n+}\n \n-    if sess.opts.debugging_opts.control_flow_guard != CFGuard::Disabled {\n-        cmd.control_flow_guard();\n+/// Add options making relocation sections in the produced ELF files read-only\n+/// and suppressing lazy binding.\n+fn add_relro_args(cmd: &mut dyn Linker, sess: &Session) {\n+    match sess.opts.debugging_opts.relro_level.unwrap_or(sess.target.target.options.relro_level) {\n+        RelroLevel::Full => cmd.full_relro(),\n+        RelroLevel::Partial => cmd.partial_relro(),\n+        RelroLevel::Off => cmd.no_relro(),\n+        RelroLevel::None => {}\n     }\n+}\n \n+/// Add library search paths used at runtime by dynamic linkers.\n+fn add_rpath_args(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    codegen_results: &CodegenResults,\n+    out_filename: &Path,\n+) {\n     // FIXME (#2397): At some point we want to rpath our guesses as to\n     // where extern libraries might live, based on the\n     // addl_lib_search_paths\n@@ -1437,10 +1419,177 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(\n         };\n         cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n     }\n+}\n+\n+/// Produce the linker command line containing linker path and arguments.\n+/// `NO-OPT-OUT` marks the arguments that cannot be removed from the command line\n+/// by the user without creating a custom target specification.\n+/// `OBJECT-FILES` specify whether the arguments can add object files.\n+/// `CUSTOMIZATION-POINT` means that arbitrary arguments defined by the user\n+/// or by the target spec can be inserted here.\n+/// `AUDIT-ORDER` - need to figure out whether the option is order-dependent or not.\n+fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n+    path: &Path,\n+    flavor: LinkerFlavor,\n+    sess: &'a Session,\n+    crate_type: config::CrateType,\n+    tmpdir: &Path,\n+    out_filename: &Path,\n+    codegen_results: &CodegenResults,\n+    target_cpu: &str,\n+) -> Command {\n+    let base_cmd = get_linker(sess, path, flavor);\n+    // FIXME: Move `/LIBPATH` addition for uwp targets from the linker construction\n+    // to the linker args construction.\n+    assert!(base_cmd.get_args().is_empty() || sess.target.target.target_vendor == \"uwp\");\n+    let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor, target_cpu);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n+    add_pre_link_args(cmd, sess, flavor, crate_type);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    if sess.target.target.options.is_like_fuchsia {\n+        let prefix = match sess.opts.debugging_opts.sanitizer {\n+            Some(Sanitizer::Address) => \"asan/\",\n+            _ => \"\",\n+        };\n+        cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n+    }\n+\n+    // NO-OPT-OUT, OBJECT-FILES-YES\n+    add_pre_link_objects(cmd, sess, crate_type);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    if sess.target.target.options.is_like_emscripten {\n+        cmd.arg(\"-s\");\n+        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n+            \"DISABLE_EXCEPTION_CATCHING=1\"\n+        } else {\n+            \"DISABLE_EXCEPTION_CATCHING=0\"\n+        });\n+    }\n+\n+    // OBJECT-FILES-YES, AUDIT-ORDER\n+    link_sanitizer_runtime(sess, crate_type, cmd);\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    // Linker plugins should be specified early in the list of arguments\n+    // FIXME: How \"early\" exactly?\n+    cmd.linker_plugin_lto();\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    // FIXME: Order-dependent, at least relatively to other args adding searh directories.\n+    add_library_search_dirs(cmd, sess);\n+\n+    // OBJECT-FILES-YES\n+    add_local_crate_regular_objects(cmd, codegen_results);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    cmd.output_filename(out_filename);\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    if crate_type == config::CrateType::Executable && sess.target.target.options.is_like_windows {\n+        if let Some(ref s) = codegen_results.windows_subsystem {\n+            cmd.subsystem(s);\n+        }\n+    }\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    // If we're building something like a dynamic library then some platforms\n+    // need to make sure that all symbols are exported correctly from the\n+    // dynamic library.\n+    cmd.export_symbols(tmpdir, crate_type);\n+\n+    // OBJECT-FILES-YES\n+    add_local_crate_metadata_objects(cmd, crate_type, codegen_results);\n+\n+    // OBJECT-FILES-YES\n+    add_local_crate_allocator_objects(cmd, codegen_results);\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    // FIXME: Order dependent, applies to the following objects. Where should it be placed?\n+    // Try to strip as much out of the generated object by removing unused\n+    // sections if possible. See more comments in linker.rs\n+    if !sess.opts.cg.link_dead_code {\n+        let keep_metadata = crate_type == config::CrateType::Dylib;\n+        cmd.gc_sections(keep_metadata);\n+    }\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    add_position_independent_executable_args(cmd, sess, flavor, crate_type, codegen_results);\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    add_relro_args(cmd, sess);\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    // Pass optimization flags down to the linker.\n+    cmd.optimize();\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    // Pass debuginfo flags down to the linker.\n+    cmd.debuginfo();\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    // We want to, by default, prevent the compiler from accidentally leaking in\n+    // any system libraries, so we may explicitly ask linkers to not link to any\n+    // libraries by default. Note that this does not happen for windows because\n+    // windows pulls in some large number of libraries and I couldn't quite\n+    // figure out which subset we wanted.\n+    //\n+    // This is all naturally configurable via the standard methods as well.\n+    if !sess.opts.cg.default_linker_libraries.unwrap_or(false)\n+        && sess.target.target.options.no_default_libraries\n+    {\n+        cmd.no_default_libraries();\n+    }\n+\n+    // OBJECT-FILES-YES\n+    link_local_crate_native_libs_and_dependent_crate_libs::<B>(\n+        cmd,\n+        sess,\n+        crate_type,\n+        codegen_results,\n+        tmpdir,\n+    );\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    // Tell the linker what we're doing.\n+    if crate_type != config::CrateType::Executable {\n+        cmd.build_dylib(out_filename);\n+    }\n+    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n+        cmd.build_static_executable();\n+    }\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    if sess.opts.cg.profile_generate.enabled() {\n+        cmd.pgo_gen();\n+    }\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    if sess.opts.debugging_opts.control_flow_guard != CFGuard::Disabled {\n+        cmd.control_flow_guard();\n+    }\n+\n+    // OBJECT-FILES-NO, AUDIT-ORDER\n+    add_rpath_args(cmd, sess, codegen_results, out_filename);\n+\n+    // OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n+    add_user_defined_link_args(cmd, sess, codegen_results);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    cmd.finalize();\n+\n+    // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n+    add_late_link_args(cmd, sess, flavor, crate_type, codegen_results);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-YES\n+    add_post_link_objects(cmd, sess, crate_type);\n+\n+    // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n+    add_post_link_args(cmd, sess, flavor);\n \n-    // Finally add all the linker arguments provided on the command line along\n-    // with any #[link_args] attributes found inside the crate\n-    cmd.args(&user_link_args);\n+    cmd.take_cmd()\n }\n \n // # Native library linking\n@@ -1454,7 +1603,7 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-pub fn add_local_native_libraries(\n+fn add_local_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     codegen_results: &CodegenResults,\n@@ -1784,7 +1933,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-pub fn add_upstream_native_libraries(\n+fn add_upstream_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     codegen_results: &CodegenResults,\n@@ -1841,14 +1990,14 @@ pub fn add_upstream_native_libraries(\n     }\n }\n \n-pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => rustc_attr::cfg_matches(cfg, &sess.parse_sess, None),\n         None => true,\n     }\n }\n \n-pub fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n+fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n     match sess.lto() {\n         config::Lto::Fat => true,\n         config::Lto::Thin => {"}, {"sha": "0baa37ae9f1ab76eafb6e8fa1fdb185b8bf75c28", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 39, "deletions": 36, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/cefee7bd9a7e188e406cac0190cf4a19fcca27ff/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefee7bd9a7e188e406cac0190cf4a19fcca27ff/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=cefee7bd9a7e188e406cac0190cf4a19fcca27ff", "patch": "@@ -6,6 +6,7 @@ use std::ffi::{OsStr, OsString};\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter};\n+use std::mem;\n use std::path::{Path, PathBuf};\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -87,6 +88,7 @@ impl LinkerInfo {\n /// used to dispatch on whether a GNU-like linker (generally `ld.exe`) or an\n /// MSVC linker (e.g., `link.exe`) is being used.\n pub trait Linker {\n+    fn cmd(&mut self) -> &mut Command;\n     fn link_dylib(&mut self, lib: Symbol);\n     fn link_rust_dylib(&mut self, lib: Symbol, path: &Path);\n     fn link_framework(&mut self, framework: Symbol);\n@@ -111,14 +113,26 @@ pub trait Linker {\n     fn no_default_libraries(&mut self);\n     fn build_dylib(&mut self, out_filename: &Path);\n     fn build_static_executable(&mut self);\n-    fn args(&mut self, args: &[String]);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n     fn subsystem(&mut self, subsystem: &str);\n     fn group_start(&mut self);\n     fn group_end(&mut self);\n     fn linker_plugin_lto(&mut self);\n-    // Should have been finalize(self), but we don't support self-by-value on trait objects (yet?).\n-    fn finalize(&mut self) -> Command;\n+    fn finalize(&mut self);\n+}\n+\n+impl dyn Linker + '_ {\n+    pub fn arg(&mut self, arg: impl AsRef<OsStr>) {\n+        self.cmd().arg(arg);\n+    }\n+\n+    pub fn args(&mut self, args: impl IntoIterator<Item: AsRef<OsStr>>) {\n+        self.cmd().args(args);\n+    }\n+\n+    pub fn take_cmd(&mut self) -> Command {\n+        mem::replace(self.cmd(), Command::new(\"\"))\n+    }\n }\n \n pub struct GccLinker<'a> {\n@@ -208,6 +222,9 @@ impl<'a> GccLinker<'a> {\n }\n \n impl<'a> Linker for GccLinker<'a> {\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.hint_dynamic();\n         self.cmd.arg(format!(\"-l{}\", lib));\n@@ -251,9 +268,6 @@ impl<'a> Linker for GccLinker<'a> {\n     fn build_static_executable(&mut self) {\n         self.cmd.arg(\"-static\");\n     }\n-    fn args(&mut self, args: &[String]) {\n-        self.cmd.args(args);\n-    }\n \n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.hint_dynamic();\n@@ -505,10 +519,8 @@ impl<'a> Linker for GccLinker<'a> {\n         self.linker_arg(&subsystem);\n     }\n \n-    fn finalize(&mut self) -> Command {\n+    fn finalize(&mut self) {\n         self.hint_dynamic(); // Reset to default before returning the composed command line.\n-\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     fn group_start(&mut self) {\n@@ -545,15 +557,15 @@ pub struct MsvcLinker<'a> {\n }\n \n impl<'a> Linker for MsvcLinker<'a> {\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n     fn link_rlib(&mut self, lib: &Path) {\n         self.cmd.arg(lib);\n     }\n     fn add_object(&mut self, path: &Path) {\n         self.cmd.arg(path);\n     }\n-    fn args(&mut self, args: &[String]) {\n-        self.cmd.args(args);\n-    }\n \n     fn build_dylib(&mut self, out_filename: &Path) {\n         self.cmd.arg(\"/DLL\");\n@@ -758,9 +770,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n         }\n     }\n \n-    fn finalize(&mut self) -> Command {\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n-    }\n+    fn finalize(&mut self) {}\n \n     // MSVC doesn't need group indicators\n     fn group_start(&mut self) {}\n@@ -778,6 +788,9 @@ pub struct EmLinker<'a> {\n }\n \n impl<'a> Linker for EmLinker<'a> {\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n     fn include_path(&mut self, path: &Path) {\n         self.cmd.arg(\"-L\").arg(path);\n     }\n@@ -837,10 +850,6 @@ impl<'a> Linker for EmLinker<'a> {\n         // noop\n     }\n \n-    fn args(&mut self, args: &[String]) {\n-        self.cmd.args(args);\n-    }\n-\n     fn framework_path(&mut self, _path: &Path) {\n         bug!(\"frameworks are not supported on Emscripten\")\n     }\n@@ -928,9 +937,7 @@ impl<'a> Linker for EmLinker<'a> {\n         // noop\n     }\n \n-    fn finalize(&mut self) -> Command {\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n-    }\n+    fn finalize(&mut self) {}\n \n     // Appears not necessary on Emscripten\n     fn group_start(&mut self) {}\n@@ -992,6 +999,10 @@ impl<'a> WasmLd<'a> {\n }\n \n impl<'a> Linker for WasmLd<'a> {\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n+\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1030,10 +1041,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn build_static_executable(&mut self) {}\n \n-    fn args(&mut self, args: &[String]) {\n-        self.cmd.args(args);\n-    }\n-\n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1098,9 +1105,7 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn no_position_independent_executable(&mut self) {}\n \n-    fn finalize(&mut self) -> Command {\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n-    }\n+    fn finalize(&mut self) {}\n \n     // Not needed for now with LLD\n     fn group_start(&mut self) {}\n@@ -1162,6 +1167,10 @@ pub struct PtxLinker<'a> {\n }\n \n impl<'a> Linker for PtxLinker<'a> {\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n+\n     fn link_rlib(&mut self, path: &Path) {\n         self.cmd.arg(\"--rlib\").arg(path);\n     }\n@@ -1182,10 +1191,6 @@ impl<'a> Linker for PtxLinker<'a> {\n         self.cmd.arg(\"--bitcode\").arg(path);\n     }\n \n-    fn args(&mut self, args: &[String]) {\n-        self.cmd.args(args);\n-    }\n-\n     fn optimize(&mut self) {\n         match self.sess.lto() {\n             Lto::Thin | Lto::Fat | Lto::ThinLocal => {\n@@ -1200,14 +1205,12 @@ impl<'a> Linker for PtxLinker<'a> {\n         self.cmd.arg(\"-o\").arg(path);\n     }\n \n-    fn finalize(&mut self) -> Command {\n+    fn finalize(&mut self) {\n         // Provide the linker with fallback to internal `target-cpu`.\n         self.cmd.arg(\"--fallback-arch\").arg(match self.sess.opts.cg.target_cpu {\n             Some(ref s) => s,\n             None => &self.sess.target.target.options.cpu,\n         });\n-\n-        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     fn link_dylib(&mut self, _lib: Symbol) {"}]}