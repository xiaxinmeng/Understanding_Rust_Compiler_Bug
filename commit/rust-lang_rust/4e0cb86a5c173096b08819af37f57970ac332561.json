{"sha": "4e0cb86a5c173096b08819af37f57970ac332561", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMGNiODZhNWMxNzMwOTZiMDg4MTlhZjM3ZjU3OTcwYWMzMzI1NjE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-14T03:46:04Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-18T22:18:42Z"}, "message": "rustc: reduce ppaux's public footprint to 5 functions.", "tree": {"sha": "32fa380d613b94c89ad2cd53e7076ad34b6d1616", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32fa380d613b94c89ad2cd53e7076ad34b6d1616"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e0cb86a5c173096b08819af37f57970ac332561", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e0cb86a5c173096b08819af37f57970ac332561", "html_url": "https://github.com/rust-lang/rust/commit/4e0cb86a5c173096b08819af37f57970ac332561", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e0cb86a5c173096b08819af37f57970ac332561/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc383f62941ae079188a9725eb49f3b8a42e35ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc383f62941ae079188a9725eb49f3b8a42e35ae", "html_url": "https://github.com/rust-lang/rust/commit/bc383f62941ae079188a9725eb49f3b8a42e35ae"}], "stats": {"total": 243, "additions": 101, "deletions": 142}, "files": [{"sha": "71a56a3ed3b777b2358437df42ab305f0161b754", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=4e0cb86a5c173096b08819af37f57970ac332561", "patch": "@@ -88,7 +88,6 @@ use syntax::codemap;\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use util::ppaux::bound_region_to_string;\n use util::ppaux::note_and_explain_region;\n \n // Note: only import UserString, not Repr, since user-facing error\n@@ -1441,24 +1440,29 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin) {\n+        let br_string = |br: ty::BoundRegion| {\n+            let mut s = br.user_string(self.tcx);\n+            if !s.is_empty() {\n+                s.push_str(\" \");\n+            }\n+            s\n+        };\n         let var_description = match var_origin {\n             infer::MiscVariable(_) => \"\".to_string(),\n             infer::PatternRegion(_) => \" for pattern\".to_string(),\n             infer::AddrOfRegion(_) => \" for borrow expression\".to_string(),\n             infer::Autoref(_) => \" for autoref\".to_string(),\n             infer::Coercion(_) => \" for automatic coercion\".to_string(),\n             infer::LateBoundRegion(_, br, infer::FnCall) => {\n-                format!(\" for {}in function call\",\n-                        bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n+                format!(\" for lifetime parameter {}in function call\",\n+                        br_string(br))\n             }\n             infer::LateBoundRegion(_, br, infer::HigherRankedType) => {\n-                format!(\" for {}in generic type\",\n-                        bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n+                format!(\" for lifetime parameter {}in generic type\", br_string(br))\n             }\n             infer::LateBoundRegion(_, br, infer::AssocTypeProjection(type_name)) => {\n-                format!(\" for {}in trait containing associated type `{}`\",\n-                        bound_region_to_string(self.tcx, \"lifetime parameter \", true, br),\n-                        token::get_name(type_name))\n+                format!(\" for lifetime parameter {}in trait containing associated type `{}`\",\n+                        br_string(br), token::get_name(type_name))\n             }\n             infer::EarlyBoundRegion(_, name) => {\n                 format!(\" for lifetime parameter `{}`\","}, {"sha": "67c4bb841d086f4ff8c7745b5d2658fb20bd0d35", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4e0cb86a5c173096b08819af37f57970ac332561", "patch": "@@ -61,7 +61,7 @@ use middle::traits;\n use middle::ty;\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use middle::ty_walk::{self, TypeWalker};\n-use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n+use util::ppaux::note_and_explain_region;\n use util::ppaux::ty_to_string;\n use util::ppaux::{Repr, UserString};\n use util::common::{memoized, ErrorReported};\n@@ -5205,12 +5205,12 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n         terr_regions_insufficiently_polymorphic(br, _) => {\n             format!(\"expected bound lifetime parameter {}, \\\n                      found concrete lifetime\",\n-                    bound_region_ptr_to_string(cx, br))\n+                    br.user_string(cx))\n         }\n         terr_regions_overly_polymorphic(br, _) => {\n             format!(\"expected concrete lifetime, \\\n                      found bound lifetime parameter {}\",\n-                    bound_region_ptr_to_string(cx, br))\n+                    br.user_string(cx))\n         }\n         terr_sorts(values) => {\n             // A naive approach to making sure that we're not reporting silly errors such as:"}, {"sha": "83852eff04c846c587209920b379ce00ad13f2b8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 67, "deletions": 103, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4e0cb86a5c173096b08819af37f57970ac332561", "patch": "@@ -52,19 +52,13 @@ pub trait UserString<'tcx> : Repr<'tcx> {\n pub fn note_and_explain_region(cx: &ctxt,\n                                prefix: &str,\n                                region: ty::Region,\n-                               suffix: &str) -> Option<Span> {\n-    match explain_region_and_span(cx, region) {\n-      (ref str, Some(span)) => {\n-        cx.sess.span_note(\n-            span,\n-            &format!(\"{}{}{}\", prefix, *str, suffix));\n-        Some(span)\n-      }\n-      (ref str, None) => {\n-        cx.sess.note(\n-            &format!(\"{}{}{}\", prefix, *str, suffix));\n-        None\n-      }\n+                               suffix: &str) {\n+    let (description, span) = explain_region_and_span(cx, region);\n+    let message = format!(\"{}{}{}\", prefix, description, suffix);\n+    if let Some(span) = span {\n+        cx.sess.span_note(span, &message);\n+    } else {\n+        cx.sess.note(&message);\n     }\n }\n \n@@ -81,8 +75,8 @@ fn item_scope_tag(item: &ast::Item) -> &'static str {\n     }\n }\n \n-pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n-                            -> (String, Option<Span>) {\n+fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n+                           -> (String, Option<Span>) {\n     return match region {\n       ReScope(scope) => {\n         let new_string;\n@@ -138,7 +132,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           BrFresh(_) => \"an anonymous lifetime defined on\".to_string(),\n           _ => {\n               format!(\"the lifetime {} as defined on\",\n-                      bound_region_ptr_to_string(cx, fr.bound_region))\n+                      fr.bound_region.user_string(cx))\n           }\n         };\n \n@@ -182,61 +176,6 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n     }\n }\n \n-pub fn bound_region_ptr_to_string(cx: &ctxt, br: BoundRegion) -> String {\n-    bound_region_to_string(cx, \"\", false, br)\n-}\n-\n-pub fn bound_region_to_string(cx: &ctxt,\n-                           prefix: &str, space: bool,\n-                           br: BoundRegion) -> String {\n-    let space_str = if space { \" \" } else { \"\" };\n-\n-    if cx.sess.verbose() {\n-        return format!(\"{}{}{}\", prefix, br.repr(cx), space_str)\n-    }\n-\n-    match br {\n-        BrNamed(_, name) => {\n-            format!(\"{}{}{}\", prefix, token::get_name(name), space_str)\n-        }\n-        BrAnon(_) | BrFresh(_) | BrEnv => prefix.to_string()\n-    }\n-}\n-\n-// In general, if you are giving a region error message,\n-// you should use `explain_region()` or, better yet,\n-// `note_and_explain_region()`\n-pub fn region_ptr_to_string(cx: &ctxt, region: Region) -> String {\n-    region_to_string(cx, \"&\", true, region)\n-}\n-\n-pub fn region_to_string(cx: &ctxt, prefix: &str, space: bool, region: Region) -> String {\n-    let space_str = if space { \" \" } else { \"\" };\n-\n-    if cx.sess.verbose() {\n-        return format!(\"{}{}{}\", prefix, region.repr(cx), space_str)\n-    }\n-\n-    // These printouts are concise.  They do not contain all the information\n-    // the user might want to diagnose an error, but there is basically no way\n-    // to fit that into a short string.  Hence the recommendation to use\n-    // `explain_region()` or `note_and_explain_region()`.\n-    match region {\n-        ty::ReScope(_) => prefix.to_string(),\n-        ty::ReEarlyBound(ref data) => {\n-            token::get_name(data.name).to_string()\n-        }\n-        ty::ReLateBound(_, br) => bound_region_to_string(cx, prefix, space, br),\n-        ty::ReFree(ref fr) => bound_region_to_string(cx, prefix, space, fr.bound_region),\n-        ty::ReInfer(ReSkolemized(_, br)) => {\n-            bound_region_to_string(cx, prefix, space, br)\n-        }\n-        ty::ReInfer(ReVar(_)) => prefix.to_string(),\n-        ty::ReStatic => format!(\"{}'static{}\", prefix, space_str),\n-        ty::ReEmpty => format!(\"{}'<empty>{}\", prefix, space_str),\n-    }\n-}\n-\n pub fn mutability_to_string(m: ast::Mutability) -> String {\n     match m {\n         ast::MutMutable => \"mut \".to_string(),\n@@ -376,7 +315,11 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             }, ty_to_string(cx, tm.ty))\n         }\n         TyRef(r, ref tm) => {\n-            let mut buf = region_ptr_to_string(cx, *r);\n+            let mut buf = \"&\".to_owned();\n+            buf.push_str(&r.user_string(cx));\n+            if !buf.is_empty() {\n+                buf.push_str(\" \");\n+            }\n             buf.push_str(&mt_to_string(cx, tm));\n             buf\n         }\n@@ -440,26 +383,13 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n     }\n }\n \n-pub fn explicit_self_category_to_str(category: &ty::ExplicitSelfCategory)\n-                                     -> &'static str {\n-    match *category {\n-        ty::StaticExplicitSelfCategory => \"static\",\n-        ty::ByValueExplicitSelfCategory => \"self\",\n-        ty::ByReferenceExplicitSelfCategory(_, ast::MutMutable) => {\n-            \"&mut self\"\n-        }\n-        ty::ByReferenceExplicitSelfCategory(_, ast::MutImmutable) => \"&self\",\n-        ty::ByBoxExplicitSelfCategory => \"Box<self>\",\n-    }\n-}\n-\n-pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n-                              base: &str,\n-                              substs: &subst::Substs<'tcx>,\n-                              did: ast::DefId,\n-                              projections: &[ty::ProjectionPredicate<'tcx>],\n-                              get_generics: GG)\n-                              -> String\n+fn parameterized<'tcx, GG>(cx: &ctxt<'tcx>,\n+                           base: &str,\n+                           substs: &subst::Substs<'tcx>,\n+                           did: ast::DefId,\n+                           projections: &[ty::ProjectionPredicate<'tcx>],\n+                           get_generics: GG)\n+                           -> String\n     where GG : FnOnce() -> ty::Generics<'tcx>\n {\n     if cx.sess.verbose() {\n@@ -495,7 +425,7 @@ pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n         subst::ErasedRegions => { }\n         subst::NonerasedRegions(ref regions) => {\n             for &r in regions {\n-                let s = region_to_string(cx, \"\", false, r);\n+                let s = r.user_string(cx);\n                 if s.is_empty() {\n                     // This happens when the value of the region\n                     // parameter is not easily serialized. This may be\n@@ -579,14 +509,6 @@ pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n     }\n }\n \n-pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n-    let mut s = typ.repr(cx).to_string();\n-    if s.len() >= 32 {\n-        s = (&s[0..32]).to_string();\n-    }\n-    return s;\n-}\n-\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Option<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match self {\n@@ -915,6 +837,19 @@ impl<'tcx> Repr<'tcx> for ty::BoundRegion {\n     }\n }\n \n+impl<'tcx> UserString<'tcx> for ty::BoundRegion {\n+    fn user_string(&self, tcx: &ctxt) -> String {\n+        if tcx.sess.verbose() {\n+            return self.repr(tcx);\n+        }\n+\n+        match *self {\n+            BrNamed(_, name) => token::get_name(name).to_string(),\n+            BrAnon(_) | BrFresh(_) | BrEnv => String::new()\n+        }\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ty::Region {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n@@ -959,7 +894,28 @@ impl<'tcx> Repr<'tcx> for ty::Region {\n \n impl<'tcx> UserString<'tcx> for ty::Region {\n     fn user_string(&self, tcx: &ctxt) -> String {\n-        region_to_string(tcx, \"\", false, *self)\n+        if tcx.sess.verbose() {\n+            return self.repr(tcx);\n+        }\n+\n+        // These printouts are concise.  They do not contain all the information\n+        // the user might want to diagnose an error, but there is basically no way\n+        // to fit that into a short string.  Hence the recommendation to use\n+        // `explain_region()` or `note_and_explain_region()`.\n+        match *self {\n+            ty::ReEarlyBound(ref data) => {\n+                token::get_name(data.name).to_string()\n+            }\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::ReInfer(ReSkolemized(_, br)) => {\n+                br.user_string(tcx)\n+            }\n+            ty::ReScope(_) |\n+            ty::ReInfer(ReVar(_)) => String::new(),\n+            ty::ReStatic => \"'static\".to_owned(),\n+            ty::ReEmpty => \"'<empty>\".to_owned(),\n+        }\n     }\n }\n \n@@ -1446,7 +1402,15 @@ impl<'tcx> Repr<'tcx> for ast::FloatTy {\n \n impl<'tcx> Repr<'tcx> for ty::ExplicitSelfCategory {\n     fn repr(&self, _: &ctxt) -> String {\n-        explicit_self_category_to_str(self).to_string()\n+        match *self {\n+            ty::StaticExplicitSelfCategory => \"static\",\n+            ty::ByValueExplicitSelfCategory => \"self\",\n+            ty::ByReferenceExplicitSelfCategory(_, ast::MutMutable) => {\n+                \"&mut self\"\n+            }\n+            ty::ByReferenceExplicitSelfCategory(_, ast::MutImmutable) => \"&self\",\n+            ty::ByBoxExplicitSelfCategory => \"Box<self>\",\n+        }.to_owned()\n     }\n }\n "}, {"sha": "36f08b3ced977f6c76916db93a0756d5848fadb8", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=4e0cb86a5c173096b08819af37f57970ac332561", "patch": "@@ -1001,20 +1001,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     \"reference must be valid for \",\n                     sub_scope,\n                     \"...\");\n-                let suggestion = if is_statement_scope(self.tcx, super_scope) {\n-                    Some(\"consider using a `let` binding to increase its lifetime\")\n-                } else {\n-                    None\n-                };\n-                let span = note_and_explain_region(\n+                note_and_explain_region(\n                     self.tcx,\n                     \"...but borrowed value is only valid for \",\n                     super_scope,\n                     \"\");\n-                match (span, suggestion) {\n-                    (_, None) => {},\n-                    (Some(span), Some(msg)) => self.tcx.sess.span_help(span, msg),\n-                    (None, Some(msg)) => self.tcx.sess.help(msg),\n+                if let Some(span) = statement_scope_span(self.tcx, super_scope) {\n+                    self.tcx.sess.span_help(span,\n+                        \"consider using a `let` binding to increase its lifetime\");\n                 }\n             }\n \n@@ -1127,16 +1121,16 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn is_statement_scope(tcx: &ty::ctxt, region: ty::Region) -> bool {\n-     match region {\n-         ty::ReScope(scope) => {\n-             match tcx.map.find(scope.node_id()) {\n-                 Some(ast_map::NodeStmt(_)) => true,\n-                 _ => false\n-             }\n-         }\n-         _ => false\n-     }\n+fn statement_scope_span(tcx: &ty::ctxt, region: ty::Region) -> Option<Span> {\n+    match region {\n+        ty::ReScope(scope) => {\n+            match tcx.map.find(scope.node_id()) {\n+                Some(ast_map::NodeStmt(stmt)) => Some(stmt.span),\n+                _ => None\n+            }\n+        }\n+        _ => None\n+    }\n }\n \n impl BitwiseOperator for LoanDataFlowOperator {"}, {"sha": "35dbc722376459bfef654020bbad9516783f86d7", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=4e0cb86a5c173096b08819af37f57970ac332561", "patch": "@@ -39,8 +39,7 @@ use trans::machine::*;\n use trans::monomorphize;\n use trans::type_of::{type_of, type_of_dtor, sizing_type_of, align_of};\n use trans::type_::Type;\n-use util::ppaux;\n-use util::ppaux::{ty_to_short_str, Repr};\n+use util::ppaux::{self, Repr};\n \n use arena::TypedArena;\n use libc::c_uint;\n@@ -247,7 +246,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     });\n     ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n \n-    let _s = StatRecorder::new(ccx, format!(\"drop {}\", ty_to_short_str(ccx.tcx(), t)));\n+    let _s = StatRecorder::new(ccx, format!(\"drop {}\", t.repr(ccx.tcx())));\n \n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n     let (arena, fcx): (TypedArena<_>, FunctionContext);"}, {"sha": "11069fdfd698d8eb4a1ad994431753d542a964b9", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0cb86a5c173096b08819af37f57970ac332561/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=4e0cb86a5c173096b08819af37f57970ac332561", "patch": "@@ -13,7 +13,7 @@ use middle::infer;\n use middle::traits;\n use middle::ty::{self};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace};\n-use util::ppaux::{self, Repr};\n+use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -64,17 +64,15 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 \"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n                         token::get_name(trait_m.name),\n-                        ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self));\n+                        impl_m.explicit_self.repr(tcx));\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n             span_err!(tcx.sess, impl_m_span, E0186,\n                 \"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n                         token::get_name(trait_m.name),\n-                        ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self));\n+                        trait_m.explicit_self.repr(tcx));\n             return;\n         }\n         _ => {"}]}