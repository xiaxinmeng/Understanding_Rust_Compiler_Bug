{"sha": "998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5OGZlY2VjZDY1MTZmYTA3ZDBjZDBhMGM0NjA3ZGRlZjBiYzQwZjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-06T04:42:54Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-11T02:51:06Z"}, "message": "Stop using the '<->' operator", "tree": {"sha": "9597e6c2f0592136086f722338b95196f71104ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9597e6c2f0592136086f722338b95196f71104ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "html_url": "https://github.com/rust-lang/rust/commit/998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d22437ecdc5b52f8517ffde6207347739b26553", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d22437ecdc5b52f8517ffde6207347739b26553", "html_url": "https://github.com/rust-lang/rust/commit/7d22437ecdc5b52f8517ffde6207347739b26553"}], "stats": {"total": 510, "additions": 214, "deletions": 296}, "files": [{"sha": "18e75fb1aa98e3400b35c00dc3d7f8cf03ed6508", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -12,6 +12,7 @@\n \n use cast::transmute_mut;\n use prelude::*;\n+use util::replace;\n \n /*\n A dynamic, mutable location.\n@@ -48,9 +49,7 @@ pub impl<T> Cell<T> {\n             fail!(~\"attempt to take an empty cell\");\n         }\n \n-        let mut value = None;\n-        value <-> self.value;\n-        value.unwrap()\n+        replace(&mut self.value, None).unwrap()\n     }\n \n     /// Returns the value, failing if the cell is full."}, {"sha": "140eb41fdf3d6f316223605954858c7f024c3d6a", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -21,6 +21,7 @@ use uint;\n use unstable;\n use vec;\n use unstable::Exclusive;\n+use util::replace;\n \n use pipes::{recv, try_recv, wait_many, peek, PacketHeader};\n \n@@ -149,9 +150,8 @@ impl<T: Owned> GenericChan<T> for Chan<T> {\n     #[inline(always)]\n     fn send(&self, x: T) {\n         unsafe {\n-            let mut endp = None;\n             let mut self_endp = transmute_mut(&self.endp);\n-            endp <-> *self_endp;\n+            let endp = replace(self_endp, None);\n             *self_endp = Some(streamp::client::data(endp.unwrap(), x))\n         }\n     }\n@@ -161,9 +161,8 @@ impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n     #[inline(always)]\n     fn try_send(&self, x: T) -> bool {\n         unsafe {\n-            let mut endp = None;\n             let mut self_endp = transmute_mut(&self.endp);\n-            endp <-> *self_endp;\n+            let endp = replace(self_endp, None);\n             match streamp::client::try_data(endp.unwrap(), x) {\n                 Some(next) => {\n                     *self_endp = Some(next);\n@@ -179,9 +178,8 @@ impl<T: Owned> GenericPort<T> for Port<T> {\n     #[inline(always)]\n     fn recv(&self) -> T {\n         unsafe {\n-            let mut endp = None;\n             let mut self_endp = transmute_mut(&self.endp);\n-            endp <-> *self_endp;\n+            let endp = replace(self_endp, None);\n             let streamp::data(x, endp) = recv(endp.unwrap());\n             *self_endp = Some(endp);\n             x\n@@ -191,9 +189,8 @@ impl<T: Owned> GenericPort<T> for Port<T> {\n     #[inline(always)]\n     fn try_recv(&self) -> Option<T> {\n         unsafe {\n-            let mut endp = None;\n             let mut self_endp = transmute_mut(&self.endp);\n-            endp <-> *self_endp;\n+            let endp = replace(self_endp, None);\n             match try_recv(endp.unwrap()) {\n                 Some(streamp::data(x, endp)) => {\n                     *self_endp = Some(endp);\n@@ -209,14 +206,13 @@ impl<T: Owned> Peekable<T> for Port<T> {\n     #[inline(always)]\n     fn peek(&self) -> bool {\n         unsafe {\n-            let mut endp = None;\n             let mut self_endp = transmute_mut(&self.endp);\n-            endp <-> *self_endp;\n+            let mut endp = replace(self_endp, None);\n             let peek = match endp {\n                 Some(ref mut endp) => peek(endp),\n                 None => fail!(~\"peeking empty stream\")\n             };\n-            *self_endp <-> endp;\n+            *self_endp = endp;\n             peek\n         }\n     }\n@@ -267,8 +263,7 @@ impl<T:Owned> GenericPort<T> for PortSet<T> {\n             let mut result = None;\n             // we have to swap the ports array so we aren't borrowing\n             // aliasable mutable memory.\n-            let mut ports = ~[];\n-            ports <-> *self_ports;\n+            let mut ports = replace(self_ports, ~[]);\n             while result.is_none() && ports.len() > 0 {\n                 let i = wait_many(ports);\n                 match ports[i].try_recv() {\n@@ -281,7 +276,7 @@ impl<T:Owned> GenericPort<T> for PortSet<T> {\n                     }\n                 }\n             }\n-            ports <-> *self_ports;\n+            *self_ports = ports;\n             result\n         }\n     }\n@@ -320,8 +315,7 @@ impl<T: Owned> GenericChan<T> for SharedChan<T> {\n     fn send(&self, x: T) {\n         let mut xx = Some(x);\n         do self.ch.with_imm |chan| {\n-            let mut x = None;\n-            x <-> xx;\n+            let x = replace(&mut xx, None);\n             chan.send(x.unwrap())\n         }\n     }\n@@ -331,8 +325,7 @@ impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n     fn try_send(&self, x: T) -> bool {\n         let mut xx = Some(x);\n         do self.ch.with_imm |chan| {\n-            let mut x = None;\n-            x <-> xx;\n+            let x = replace(&mut xx, None);\n             chan.try_send(x.unwrap())\n         }\n     }"}, {"sha": "590d4ab3bcb4070d4ca08bc74e1c46bc6b85e584", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -176,16 +176,13 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n     /// Expands the capacity of the array and re-insert each of the\n     /// existing buckets.\n     fn resize(&mut self, new_capacity: uint) {\n-        let old_capacity = self.buckets.len();\n         self.resize_at = resize_at(new_capacity);\n \n-        let mut old_buckets = vec::from_fn(new_capacity, |_| None);\n-        self.buckets <-> old_buckets;\n+        let old_buckets = replace(&mut self.buckets,\n+                                  vec::from_fn(new_capacity, |_| None));\n \n         self.size = 0;\n-        for uint::range(0, old_capacity) |i| {\n-            let mut bucket = None;\n-            bucket <-> old_buckets[i];\n+        do vec::consume(old_buckets) |_, bucket| {\n             self.insert_opt_bucket(bucket);\n         }\n     }\n@@ -265,13 +262,11 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n         };\n \n         let len_buckets = self.buckets.len();\n-        let mut bucket = None;\n-        self.buckets[idx] <-> bucket;\n+        let bucket = replace(&mut self.buckets[idx], None);\n \n         let value = match bucket {\n             None => None,\n-            Some(bucket) => {\n-                let Bucket{value: value, _} = bucket;\n+            Some(Bucket{value, _}) => {\n                 Some(value)\n             },\n         };\n@@ -281,8 +276,7 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n         let size = self.size - 1;\n         idx = self.next_bucket(idx, len_buckets);\n         while self.buckets[idx].is_some() {\n-            let mut bucket = None;\n-            bucket <-> self.buckets[idx];\n+            let bucket = replace(&mut self.buckets[idx], None);\n             self.insert_opt_bucket(bucket);\n             idx = self.next_bucket(idx, len_buckets);\n         }\n@@ -613,15 +607,13 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n     }\n \n     fn consume(&mut self, f: &fn(K, V)) {\n-        let mut buckets = ~[];\n-        self.buckets <-> buckets;\n+        let buckets = replace(&mut self.buckets, ~[]);\n         self.size = 0;\n \n         do vec::consume(buckets) |_, bucket| {\n             match bucket {\n                 None => {},\n-                Some(bucket) => {\n-                    let Bucket{key: key, value: value, _} = bucket;\n+                Some(Bucket{key, value, _}) => {\n                     f(key, value)\n                 }\n             }"}, {"sha": "fe9c78198bb13f945f187088c3375f198e53653e", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -93,6 +93,7 @@ use unstable::intrinsics;\n use ptr;\n use task;\n use vec;\n+use util::replace;\n \n static SPIN_COUNT: uint = 0;\n \n@@ -428,8 +429,7 @@ fn try_recv_<T:Owned>(p: &mut Packet<T>) -> Option<T> {\n     // optimistic path\n     match p.header.state {\n       Full => {\n-        let mut payload = None;\n-        payload <-> p.payload;\n+        let payload = replace(&mut p.payload, None);\n         p.header.state = Empty;\n         return Some(payload.unwrap())\n       },\n@@ -480,8 +480,7 @@ fn try_recv_<T:Owned>(p: &mut Packet<T>) -> Option<T> {\n             fail!(~\"blocking on already blocked packet\")\n           },\n           Full => {\n-            let mut payload = None;\n-            payload <-> p.payload;\n+            let payload = replace(&mut p.payload, None);\n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n                 unsafe {\n@@ -675,8 +674,7 @@ impl<T:Owned,Tbuffer:Owned> Drop for SendPacketBuffered<T,Tbuffer> {\n         unsafe {\n             let this: &mut SendPacketBuffered<T,Tbuffer> = transmute(self);\n             if this.p != None {\n-                let mut p = None;\n-                p <-> this.p;\n+                let p = replace(&mut this.p, None);\n                 sender_terminate(p.unwrap())\n             }\n         }\n@@ -695,9 +693,7 @@ pub fn SendPacketBuffered<T,Tbuffer>(p: *mut Packet<T>)\n \n pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n     fn unwrap(&mut self) -> *mut Packet<T> {\n-        let mut p = None;\n-        p <-> self.p;\n-        p.unwrap()\n+        replace(&mut self.p, None).unwrap()\n     }\n \n     fn header(&mut self) -> *mut PacketHeader {\n@@ -713,9 +709,7 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n \n     fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n         //error!(\"send reuse_buffer\");\n-        let mut tmp = None;\n-        tmp <-> self.buffer;\n-        tmp.unwrap()\n+        replace(&mut self.buffer, None).unwrap()\n     }\n }\n \n@@ -738,8 +732,7 @@ impl<T:Owned,Tbuffer:Owned> Drop for RecvPacketBuffered<T,Tbuffer> {\n         unsafe {\n             let this: &mut RecvPacketBuffered<T,Tbuffer> = transmute(self);\n             if this.p != None {\n-                let mut p = None;\n-                p <-> this.p;\n+                let p = replace(&mut this.p, None);\n                 receiver_terminate(p.unwrap())\n             }\n         }\n@@ -748,15 +741,11 @@ impl<T:Owned,Tbuffer:Owned> Drop for RecvPacketBuffered<T,Tbuffer> {\n \n pub impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n     fn unwrap(&mut self) -> *mut Packet<T> {\n-        let mut p = None;\n-        p <-> self.p;\n-        p.unwrap()\n+        replace(&mut self.p, None).unwrap()\n     }\n \n     fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n-        let mut tmp = None;\n-        tmp <-> self.buffer;\n-        tmp.unwrap()\n+        replace(&mut self.buffer, None).unwrap()\n     }\n }\n "}, {"sha": "db9a17cf97ffe09b797d1d201d083f713651bde9", "filename": "src/libcore/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -35,12 +35,12 @@ pub fn ignore<T>(_x: T) { }\n #[inline(always)]\n pub fn with<T,R>(\n     ptr: @mut T,\n-    mut value: T,\n+    value: T,\n     op: &fn() -> R) -> R\n {\n-    value <-> *ptr;\n+    let prev = replace(ptr, value);\n     let result = op();\n-    *ptr = value;\n+    *ptr = prev;\n     return result;\n }\n "}, {"sha": "77314b173d9818ba7ddf331d85effd2378142780", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -29,6 +29,7 @@ use sys;\n use uint;\n use unstable::intrinsics;\n use vec;\n+use util;\n \n #[cfg(not(test))] use cmp::Equiv;\n \n@@ -470,7 +471,7 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n         let next_ln = v.len() - 1;\n \n         // Save the last element. We're going to overwrite its position\n-        let mut work_elt = v.pop();\n+        let work_elt = v.pop();\n         // We still should have room to work where what last element was\n         assert!(capacity(v) >= ln);\n         // Pretend like we have the original length so we can use\n@@ -501,16 +502,14 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n         // Swap out the element we want from the end\n         let vp = raw::to_mut_ptr(*v);\n         let vp = ptr::mut_offset(vp, next_ln - 1);\n-        *vp <-> work_elt;\n \n-        work_elt\n+        util::replace_ptr(vp, work_elt)\n     }\n }\n \n /// Prepend an element to the vector\n pub fn unshift<T>(v: &mut ~[T], x: T) {\n-    let mut vv = ~[x];\n-    *v <-> vv;\n+    let vv = util::replace(v, ~[x]);\n     v.push_all_move(vv);\n }\n \n@@ -523,7 +522,7 @@ pub fn insert<T>(v: &mut ~[T], i: uint, x: T) {\n     v.push(x);\n     let mut j = len;\n     while j > i {\n-        v[j] <-> v[j - 1];\n+        swap(*v, j, j - 1);\n         j -= 1;\n     }\n }\n@@ -536,7 +535,7 @@ pub fn remove<T>(v: &mut ~[T], i: uint) -> T {\n \n     let mut j = i;\n     while j < len - 1 {\n-        v[j] <-> v[j + 1];\n+        swap(*v, j, j + 1);\n         j += 1;\n     }\n     v.pop()\n@@ -550,10 +549,9 @@ pub fn consume<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n                 // holes we create in the vector. That ensures that, if the\n                 // iterator fails then we won't try to clean up the consumed\n                 // elements during unwinding\n-                let mut x = intrinsics::init();\n+                let x = intrinsics::init();\n                 let p = ptr::mut_offset(p, i);\n-                x <-> *p;\n-                f(i, x);\n+                f(i, util::replace_ptr(p, x));\n             }\n         }\n \n@@ -572,10 +570,9 @@ pub fn consume_reverse<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n                 // holes we create in the vector. That ensures that, if the\n                 // iterator fails then we won't try to clean up the consumed\n                 // elements during unwinding\n-                let mut x = intrinsics::init();\n+                let x = intrinsics::init();\n                 let p = ptr::mut_offset(p, i);\n-                x <-> *p;\n-                f(i, x);\n+                f(i, util::replace_ptr(p, x));\n             }\n         }\n \n@@ -592,8 +589,7 @@ pub fn pop<T>(v: &mut ~[T]) -> T {\n     }\n     let valptr = ptr::to_mut_unsafe_ptr(&mut v[ln - 1u]);\n     unsafe {\n-        let mut val = intrinsics::uninit();\n-        val <-> *valptr;\n+        let val = util::replace_ptr(valptr, intrinsics::uninit());\n         raw::set_len(v, ln - 1u);\n         val\n     }\n@@ -607,8 +603,7 @@ pub fn pop<T>(v: &mut ~[T]) -> T {\n     }\n     let valptr = ptr::to_mut_unsafe_ptr(&mut v[ln - 1u]);\n     unsafe {\n-        let mut val = intrinsics::init();\n-        val <-> *valptr;\n+        let val = util::replace_ptr(valptr, intrinsics::init());\n         raw::set_len(v, ln - 1u);\n         val\n     }\n@@ -626,7 +621,7 @@ pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n         fail!(fmt!(\"vec::swap_remove - index %u >= length %u\", index, ln));\n     }\n     if index < ln - 1 {\n-        v[index] <-> v[ln - 1];\n+        swap(*v, index, ln - 1);\n     }\n     v.pop()\n }\n@@ -682,8 +677,8 @@ pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n     unsafe {\n         do as_mut_buf(rhs) |p, len| {\n             for uint::range(0, len) |i| {\n-                let mut x = intrinsics::uninit();\n-                x <-> *ptr::mut_offset(p, i);\n+                let x = util::replace_ptr(ptr::mut_offset(p, i),\n+                                          intrinsics::uninit());\n                 push(&mut *v, x);\n             }\n         }\n@@ -699,8 +694,8 @@ pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n     unsafe {\n         do as_mut_buf(rhs) |p, len| {\n             for uint::range(0, len) |i| {\n-                let mut x = intrinsics::init();\n-                x <-> *ptr::mut_offset(p, i);\n+                let x = util::replace_ptr(ptr::mut_offset(p, i),\n+                                          intrinsics::init());\n                 push(&mut *v, x);\n             }\n         }\n@@ -716,8 +711,7 @@ pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n         unsafe {\n             // This loop is optimized out for non-drop types.\n             for uint::range(newlen, oldlen) |i| {\n-                let mut dropped = intrinsics::uninit();\n-                dropped <-> *ptr::mut_offset(p, i);\n+                util::replace_ptr(ptr::mut_offset(p, i), intrinsics::uninit());\n             }\n         }\n     }\n@@ -732,8 +726,7 @@ pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n         unsafe {\n             // This loop is optimized out for non-drop types.\n             for uint::range(newlen, oldlen) |i| {\n-                let mut dropped = intrinsics::init();\n-                dropped <-> *ptr::mut_offset(p, i);\n+                util::replace_ptr(ptr::mut_offset(p, i), intrinsics::init());\n             }\n         }\n     }\n@@ -758,14 +751,14 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n                 // last_written < next_to_read < ln\n                 if *ptr::mut_offset(p, next_to_read) ==\n                     *ptr::mut_offset(p, last_written) {\n-                    let mut dropped = intrinsics::uninit();\n-                    dropped <-> *ptr::mut_offset(p, next_to_read);\n+                    util::replace_ptr(ptr::mut_offset(p, next_to_read),\n+                                      intrinsics::uninit());\n                 } else {\n                     last_written += 1;\n                     // last_written <= next_to_read < ln\n                     if next_to_read != last_written {\n-                        *ptr::mut_offset(p, last_written) <->\n-                            *ptr::mut_offset(p, next_to_read);\n+                        util::swap_ptr(ptr::mut_offset(p, last_written),\n+                                       ptr::mut_offset(p, next_to_read));\n                     }\n                 }\n                 // last_written <= next_to_read < ln\n@@ -796,14 +789,14 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n                 // last_written < next_to_read < ln\n                 if *ptr::mut_offset(p, next_to_read) ==\n                     *ptr::mut_offset(p, last_written) {\n-                    let mut dropped = intrinsics::init();\n-                    dropped <-> *ptr::mut_offset(p, next_to_read);\n+                    util::replace_ptr(ptr::mut_offset(p, next_to_read),\n+                                      intrinsics::init());\n                 } else {\n                     last_written += 1;\n                     // last_written <= next_to_read < ln\n                     if next_to_read != last_written {\n-                        *ptr::mut_offset(p, last_written) <->\n-                            *ptr::mut_offset(p, next_to_read);\n+                        util::swap_ptr(ptr::mut_offset(p, last_written),\n+                                       ptr::mut_offset(p, next_to_read));\n                     }\n                 }\n                 // last_written <= next_to_read < ln\n@@ -1028,7 +1021,7 @@ pub fn retain<T>(v: &mut ~[T], f: &fn(t: &T) -> bool) {\n         if !f(&v[i]) {\n             deleted += 1;\n         } else if deleted > 0 {\n-            v[i - deleted] <-> v[i];\n+            swap(*v, i - deleted, i);\n         }\n     }\n \n@@ -1429,15 +1422,25 @@ pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n  * * a - The index of the first element\n  * * b - The index of the second element\n  */\n+#[inline(always)]\n pub fn swap<T>(v: &mut [T], a: uint, b: uint) {\n-    v[a] <-> v[b];\n+    unsafe {\n+        // Can't take two mutable loans from one vector, so instead just cast\n+        // them to their raw pointers to do the swap\n+        let pa: *mut T = ptr::to_mut_unsafe_ptr(&mut v[a]);\n+        let pb: *mut T = ptr::to_mut_unsafe_ptr(&mut v[b]);\n+        util::swap_ptr(pa, pb);\n+    }\n }\n \n /// Reverse the order of elements in a vector, in place\n pub fn reverse<T>(v: &mut [T]) {\n     let mut i: uint = 0;\n     let ln = len::<T>(v);\n-    while i < ln / 2 { v[i] <-> v[ln - i - 1]; i += 1; }\n+    while i < ln / 2 {\n+        swap(v, i, ln - i - 1);\n+        i += 1;\n+    }\n }\n \n /// Returns a vector with the order of elements reversed\n@@ -2476,6 +2479,7 @@ pub mod raw {\n     use sys;\n     use unstable::intrinsics;\n     use vec::{UnboxedVecRepr, as_const_buf, as_mut_buf, len, with_capacity};\n+    use util;\n \n     /// The internal representation of a (boxed) vector\n     pub struct VecRepr {\n@@ -2573,8 +2577,7 @@ pub mod raw {\n     pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n         let mut box = Some(val);\n         do as_mut_buf(v) |p, _len| {\n-            let mut box2 = None;\n-            box2 <-> box;\n+            let box2 = util::replace(&mut box, None);\n             intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)),\n                                       box2.unwrap());\n         }"}, {"sha": "c94acaa1f70db55f1406f7cb871ab3fe75dba124", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -10,6 +10,8 @@\n \n //! A double-ended queue implemented as a circular buffer\n \n+use core::util::replace;\n+\n static initial_capacity: uint = 32u; // 2^5\n \n pub struct Deque<T> {\n@@ -142,9 +144,7 @@ fn grow<T>(nelts: uint, lo: uint, elts: &mut [Option<T>]) -> ~[Option<T>] {\n     let mut rv = ~[];\n \n     do rv.grow_fn(nelts + 1) |i| {\n-        let mut element = None;\n-        element <-> elts[(lo + i) % nelts];\n-        element\n+        replace(&mut elts[(lo + i) % nelts], None)\n     }\n \n     rv"}, {"sha": "ac23ea1a6e2c29429656edeba1ecf4e7b1ff60cf", "filename": "src/libstd/future.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -26,6 +26,7 @@ use core::cell::Cell;\n use core::comm::{PortOne, oneshot, send_one};\n use core::pipes::recv;\n use core::task;\n+use core::util::replace;\n \n #[doc = \"The future type\"]\n #[cfg(stage0)]\n@@ -77,8 +78,7 @@ pub impl<A> Future<A> {\n                 }\n             }\n             {\n-                let mut state = Evaluating;\n-                self.state <-> state;\n+                let state = replace(&mut self.state, Evaluating);\n                 match state {\n                     Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n                     Pending(f) => {\n@@ -108,8 +108,7 @@ pub impl<A> Future<A> {\n                 }\n             }\n             {\n-                let mut state = Evaluating;\n-                self.state <-> state;\n+                let state = replace(&mut self.state, Evaluating);\n                 match state {\n                     Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n                     Pending(f) => {"}, {"sha": "ded632b29d94ecd48b49b7b92d2f96f4dea3f885", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -11,6 +11,7 @@\n //! A priority queue implemented with a binary heap\n \n use core::old_iter::BaseIter;\n+use core::util::{replace, swap};\n \n #[abi = \"rust-intrinsic\"]\n extern \"rust-intrinsic\" mod rusti {\n@@ -73,7 +74,10 @@ pub impl <T:Ord> PriorityQueue<T> {\n     /// Pop the greatest item from the queue - fails if empty\n     fn pop(&mut self) -> T {\n         let mut item = self.data.pop();\n-        if !self.is_empty() { item <-> self.data[0]; self.siftdown(0); }\n+        if !self.is_empty() {\n+            swap(&mut item, &mut self.data[0]);\n+            self.siftdown(0);\n+        }\n         item\n     }\n \n@@ -92,15 +96,15 @@ pub impl <T:Ord> PriorityQueue<T> {\n     /// Optimized version of a push followed by a pop\n     fn push_pop(&mut self, mut item: T) -> T {\n         if !self.is_empty() && self.data[0] > item {\n-            item <-> self.data[0];\n+            swap(&mut item, &mut self.data[0]);\n             self.siftdown(0);\n         }\n         item\n     }\n \n     /// Optimized version of a pop followed by a push - fails if empty\n     fn replace(&mut self, mut item: T) -> T {\n-        item <-> self.data[0];\n+        swap(&mut item, &mut self.data[0]);\n         self.siftdown(0);\n         item\n     }\n@@ -115,7 +119,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n         let mut end = q.len();\n         while end > 1 {\n             end -= 1;\n-            q.data[end] <-> q.data[0];\n+            vec::swap(q.data, 0, end);\n             q.siftdown_range(0, end)\n         }\n         q.to_vec()\n@@ -149,8 +153,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n                 if new > self.data[parent] {\n-                    let mut x = rusti::uninit();\n-                    x <-> self.data[parent];\n+                    let x = replace(&mut self.data[parent], rusti::uninit());\n                     rusti::move_val_init(&mut self.data[pos], x);\n                     pos = parent;\n                     loop\n@@ -169,8 +172,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n                 if new > self.data[parent] {\n-                    let mut x = rusti::init();\n-                    x <-> self.data[parent];\n+                    let x = replace(&mut self.data[parent], rusti::init());\n                     rusti::move_val_init(&mut self.data[pos], x);\n                     pos = parent;\n                     loop\n@@ -194,8 +196,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n                 if right < end && !(self.data[child] > self.data[right]) {\n                     child = right;\n                 }\n-                let mut x = rusti::uninit();\n-                x <-> self.data[child];\n+                let x = replace(&mut self.data[child], rusti::uninit());\n                 rusti::move_val_init(&mut self.data[pos], x);\n                 pos = child;\n                 child = 2 * pos + 1;\n@@ -218,8 +219,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n                 if right < end && !(self.data[child] > self.data[right]) {\n                     child = right;\n                 }\n-                let mut x = rusti::init();\n-                x <-> self.data[child];\n+                let x = replace(&mut self.data[child], rusti::init());\n                 rusti::move_val_init(&mut self.data[pos], x);\n                 pos = child;\n                 child = 2 * pos + 1;"}, {"sha": "0c0f11fc9f0237bc6c41f85d07483df4a19237dc", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -17,6 +17,7 @@ destruction. They are restricted to containing `Owned` types in order to prevent\n \n use core::libc::{c_void, size_t, malloc, free};\n use core::unstable::intrinsics;\n+use core::util;\n \n struct RcBox<T> {\n     value: T,\n@@ -52,8 +53,7 @@ impl<T: Owned> Drop for Rc<T> {\n         unsafe {\n             (*self.ptr).count -= 1;\n             if (*self.ptr).count == 0 {\n-                let mut x = intrinsics::uninit();\n-                x <-> *self.ptr;\n+                util::replace_ptr(self.ptr, intrinsics::uninit());\n                 free(self.ptr as *c_void)\n             }\n         }\n@@ -67,8 +67,7 @@ impl<T: Owned> Drop for Rc<T> {\n         unsafe {\n             (*self.ptr).count -= 1;\n             if (*self.ptr).count == 0 {\n-                let mut x = intrinsics::init();\n-                x <-> *self.ptr;\n+                util::replace_ptr(self.ptr, intrinsics::init());\n                 free(self.ptr as *c_void)\n             }\n         }\n@@ -111,13 +110,6 @@ mod test_rc {\n     }\n }\n \n-#[abi = \"rust-intrinsic\"]\n-extern \"rust-intrinsic\" mod rusti {\n-    fn init<T>() -> T;\n-    #[cfg(not(stage0))]\n-    fn uninit<T>() -> T;\n-}\n-\n #[deriving(Eq)]\n enum Borrow {\n     Mutable,\n@@ -179,8 +171,7 @@ impl<T: Owned> Drop for RcMut<T> {\n         unsafe {\n             (*self.ptr).count -= 1;\n             if (*self.ptr).count == 0 {\n-                let mut x = rusti::uninit();\n-                x <-> *self.ptr;\n+                util::replace_ptr(self.ptr, intrinsics::uninit());\n                 free(self.ptr as *c_void)\n             }\n         }\n@@ -194,8 +185,7 @@ impl<T: Owned> Drop for RcMut<T> {\n         unsafe {\n             (*self.ptr).count -= 1;\n             if (*self.ptr).count == 0 {\n-                let mut x = rusti::init();\n-                x <-> *self.ptr;\n+                util::replace_ptr(self.ptr, intrinsics::init());\n                 free(self.ptr as *c_void)\n             }\n         }"}, {"sha": "876eb716a38334711a4e6e962356ef668caf9796", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -13,6 +13,7 @@\n use core::cmp::{Eq, Ord};\n use core::vec::len;\n use core::vec;\n+use core::util::swap;\n \n type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n \n@@ -63,36 +64,36 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n #[cfg(stage0)]\n fn part<T>(arr: &mut [T], left: uint,\n            right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    arr[pivot] <-> arr[right];\n+    swap(&mut arr[pivot], &mut arr[right]);\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n         let a: &mut T = &mut arr[i];\n         let b: &mut T = &mut arr[right];\n         if compare_func(a, b) {\n-            arr[i] <-> arr[storage_index];\n+            swap(&mut arr[i], &mut arr[storage_index]);\n             storage_index += 1;\n         }\n         i += 1;\n     }\n-    arr[storage_index] <-> arr[right];\n+    swap(&mut arr[storage_index], &mut arr[right]);\n     return storage_index;\n }\n \n #[cfg(not(stage0))]\n fn part<T>(arr: &mut [T], left: uint,\n            right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    arr[pivot] <-> arr[right];\n+    vec::swap(arr, pivot, right);\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n         if compare_func(&arr[i], &arr[right]) {\n-            arr[i] <-> arr[storage_index];\n+            vec::swap(arr, i, storage_index);\n             storage_index += 1;\n         }\n         i += 1;\n     }\n-    arr[storage_index] <-> arr[right];\n+    vec::swap(arr, storage_index, right);\n     return storage_index;\n }\n \n@@ -136,29 +137,29 @@ fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n             j -= 1;\n         }\n         if i >= j { break; }\n-        arr[i] <-> arr[j];\n+        vec::swap(arr, i as uint, j as uint);\n         if arr[i] == v {\n             p += 1;\n-            arr[p] <-> arr[i];\n+            vec::swap(arr, p as uint, i as uint);\n         }\n         if v == arr[j] {\n             q -= 1;\n-            arr[j] <-> arr[q];\n+            vec::swap(arr, j as uint, q as uint);\n         }\n     }\n-    arr[i] <-> arr[right];\n+    vec::swap(arr, i as uint, right as uint);\n     j = i - 1;\n     i += 1;\n     let mut k: int = left;\n     while k < p {\n-        arr[k] <-> arr[j];\n+        vec::swap(arr, k as uint, j as uint);\n         k += 1;\n         j -= 1;\n         if k == len::<T>(arr) as int { break; }\n     }\n     k = right - 1;\n     while k > q {\n-        arr[i] <-> arr[k];\n+        vec::swap(arr, i as uint, k as uint);\n         k -= 1;\n         i += 1;\n         if k == 0 { break; }\n@@ -273,7 +274,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n-        v[i] <-> v[end - i - 1];\n+        vec::swap(v, i, end - i - 1);\n         i += 1;\n     }\n }\n@@ -493,7 +494,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         let mut len1 = len1;\n         let mut len2 = len2;\n \n-        array[dest] <-> array[c2];\n+        vec::swap(array, dest, c2);\n         dest += 1; c2 += 1; len2 -= 1;\n \n         if len2 == 0 {\n@@ -502,7 +503,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         }\n         if len1 == 1 {\n             shift_vec(array, dest, c2, len2);\n-            array[dest+len2] <-> tmp[c1];\n+            swap(&mut tmp[c1], &mut array[dest+len2]);\n             return;\n         }\n \n@@ -515,14 +516,14 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len1 > 1 && len2 != 0);\n                 if array[c2] < tmp[c1] {\n-                    array[dest] <-> array[c2];\n+                    vec::swap(array, dest, c2);\n                     dest += 1; c2 += 1; len2 -= 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 0 {\n                         break_outer = true;\n                     }\n                 } else {\n-                    array[dest] <-> tmp[c1];\n+                    swap(&mut array[dest], &mut tmp[c1]);\n                     dest += 1; c1 += 1; len1 -= 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 1 {\n@@ -548,7 +549,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                     dest += count1; c1 += count1; len1 -= count1;\n                     if len1 <= 1 { break_outer = true; break; }\n                 }\n-                array[dest] <-> array[c2];\n+                vec::swap(array, dest, c2);\n                 dest += 1; c2 += 1; len2 -= 1;\n                 if len2 == 0 { break_outer = true; break; }\n \n@@ -561,7 +562,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                     dest += count2; c2 += count2; len2 -= count2;\n                     if len2 == 0 { break_outer = true; break; }\n                 }\n-                array[dest] <-> tmp[c1];\n+                swap(&mut array[dest], &mut tmp[c1]);\n                 dest += 1; c1 += 1; len1 -= 1;\n                 if len1 == 1 { break_outer = true; break; }\n                 min_gallop -= 1;\n@@ -578,7 +579,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         if len1 == 1 {\n             assert!(len2 > 0);\n             shift_vec(array, dest, c2, len2);\n-            array[dest+len2] <-> tmp[c1];\n+            swap(&mut array[dest+len2], &mut tmp[c1]);\n         } else if len1 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n@@ -603,7 +604,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         let mut len1 = len1;\n         let mut len2 = len2;\n \n-        array[dest] <-> array[c1];\n+        vec::swap(array, dest, c1);\n         dest -= 1; c1 -= 1; len1 -= 1;\n \n         if len1 == 0 {\n@@ -614,7 +615,7 @@ impl<T:Copy + Ord> MergeState<T> {\n             dest -= len1;\n             c1 -= len1;\n             shift_vec(array, dest+1, c1+1, len1);\n-            array[dest] <-> tmp[c2];\n+            swap(&mut array[dest], &mut tmp[c2]);\n             return;\n         }\n \n@@ -627,14 +628,14 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len1 != 0 && len2 > 1);\n                 if tmp[c2] < array[c1] {\n-                    array[dest] <-> array[c1];\n+                    vec::swap(array, dest, c1);\n                     dest -= 1; c1 -= 1; len1 -= 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 0 {\n                         break_outer = true;\n                     }\n                 } else {\n-                    array[dest] <-> tmp[c2];\n+                    swap(&mut array[dest], &mut tmp[c2]);\n                     dest -= 1; c2 -= 1; len2 -= 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 1 {\n@@ -663,7 +664,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                     if len1 == 0 { break_outer = true; break; }\n                 }\n \n-                array[dest] <-> tmp[c2];\n+                swap(&mut array[dest], &mut tmp[c2]);\n                 dest -= 1; c2 -= 1; len2 -= 1;\n                 if len2 == 1 { break_outer = true; break; }\n \n@@ -680,7 +681,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                     copy_vec(array, dest+1, tmp.slice(c2+1, c2+1+count2));\n                     if len2 <= 1 { break_outer = true; break; }\n                 }\n-                array[dest] <-> array[c1];\n+                vec::swap(array, dest, c1);\n                 dest -= 1; c1 -= 1; len1 -= 1;\n                 if len1 == 0 { break_outer = true; break; }\n                 min_gallop -= 1;\n@@ -700,7 +701,7 @@ impl<T:Copy + Ord> MergeState<T> {\n             dest -= len1;\n             c1 -= len1;\n             shift_vec(array, dest+1, c1+1, len1);\n-            array[dest] <-> tmp[c2];\n+            swap(&mut array[dest], &mut tmp[c2]);\n         } else if len2 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n@@ -1090,7 +1091,7 @@ mod big_tests {\n             for 3.times {\n                 let i1 = rng.gen_uint_range(0, n);\n                 let i2 = rng.gen_uint_range(0, n);\n-                arr[i1] <-> arr[i2];\n+                vec::swap(arr, i1, i2);\n             }\n             tim_sort(arr); // 3sort\n             isSorted(arr);\n@@ -1162,7 +1163,7 @@ mod big_tests {\n             for 3.times {\n                 let i1 = rng.gen_uint_range(0, n);\n                 let i2 = rng.gen_uint_range(0, n);\n-                arr[i1] <-> arr[i2];\n+                vec::swap(arr, i1, i2);\n             }\n             tim_sort(arr); // 3sort\n             isSorted(arr);"}, {"sha": "00bd325dd0c21e5e2a144c09107d7c5b22d83efc", "filename": "src/libstd/sort_stage0.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Fsort_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Fsort_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort_stage0.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -13,6 +13,7 @@\n use core::cmp::{Eq, Ord};\n use core::vec::len;\n use core::vec;\n+use core::util;\n \n type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n \n@@ -63,36 +64,36 @@ pub fn merge_sort<T:Copy>(v: &const [T], le: Le<T>) -> ~[T] {\n #[cfg(stage0)]\n fn part<T>(arr: &mut [T], left: uint,\n            right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    arr[pivot] <-> arr[right];\n+    vec::swap(arr, pivot, right);\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n         let a: &mut T = &mut arr[i];\n         let b: &mut T = &mut arr[right];\n         if compare_func(a, b) {\n-            arr[i] <-> arr[storage_index];\n+            vec::swap(arr, i, storage_index);\n             storage_index += 1;\n         }\n         i += 1;\n     }\n-    arr[storage_index] <-> arr[right];\n+    vec::swap(arr, storage_index, right);\n     return storage_index;\n }\n \n #[cfg(not(stage0))]\n fn part<T>(arr: &mut [T], left: uint,\n            right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    arr[pivot] <-> arr[right];\n+    vec::swap(arr, pivot, right);\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n         if compare_func(&arr[i], &arr[right]) {\n-            arr[i] <-> arr[storage_index];\n+            vec::swap(arr, i, storage_index);\n             storage_index += 1;\n         }\n         i += 1;\n     }\n-    arr[storage_index] <-> arr[right];\n+    vec::swap(arr, storage_index, right);\n     return storage_index;\n }\n \n@@ -136,29 +137,29 @@ fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n             j -= 1;\n         }\n         if i >= j { break; }\n-        arr[i] <-> arr[j];\n+        vec::swap(arr, i as uint, j as uint);\n         if arr[i] == v {\n             p += 1;\n-            arr[p] <-> arr[i];\n+            vec::swap(arr, p as uint, i as uint);\n         }\n         if v == arr[j] {\n             q -= 1;\n-            arr[j] <-> arr[q];\n+            vec::swap(arr, j as uint, q as uint);\n         }\n     }\n-    arr[i] <-> arr[right];\n+    vec::swap(arr, i as uint, right as uint);\n     j = i - 1;\n     i += 1;\n     let mut k: int = left;\n     while k < p {\n-        arr[k] <-> arr[j];\n+        vec::swap(arr, k as uint, j as uint);\n         k += 1;\n         j -= 1;\n         if k == len::<T>(arr) as int { break; }\n     }\n     k = right - 1;\n     while k > q {\n-        arr[i] <-> arr[k];\n+        vec::swap(arr, i as uint, k as uint);\n         k -= 1;\n         i += 1;\n         if k == 0 { break; }\n@@ -273,7 +274,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n-        v[i] <-> v[end - i - 1];\n+        vec::swap(v, i, end - i - 1);\n         i += 1;\n     }\n }\n@@ -493,7 +494,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         let mut len1 = len1;\n         let mut len2 = len2;\n \n-        array[dest] <-> array[c2];\n+        vec::swap(array, dest, c2);\n         dest += 1; c2 += 1; len2 -= 1;\n \n         if len2 == 0 {\n@@ -502,7 +503,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         }\n         if len1 == 1 {\n             copy_vec(array, dest, array, c2, len2);\n-            array[dest+len2] <-> tmp[c1];\n+            util::swap(&mut array[dest+len2], &mut tmp[c1]);\n             return;\n         }\n \n@@ -515,14 +516,14 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len1 > 1 && len2 != 0);\n                 if array[c2] < tmp[c1] {\n-                    array[dest] <-> array[c2];\n+                    vec::swap(array, dest, c2);\n                     dest += 1; c2 += 1; len2 -= 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 0 {\n                         break_outer = true;\n                     }\n                 } else {\n-                    array[dest] <-> tmp[c1];\n+                    util::swap(&mut array[dest], &mut tmp[c1]);\n                     dest += 1; c1 += 1; len1 -= 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 1 {\n@@ -546,7 +547,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                     dest += count1; c1 += count1; len1 -= count1;\n                     if len1 <= 1 { break_outer = true; break; }\n                 }\n-                array[dest] <-> array[c2];\n+                vec::swap(array, dest, c2);\n                 dest += 1; c2 += 1; len2 -= 1;\n                 if len2 == 0 { break_outer = true; break; }\n \n@@ -557,7 +558,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                     dest += count2; c2 += count2; len2 -= count2;\n                     if len2 == 0 { break_outer = true; break; }\n                 }\n-                array[dest] <-> tmp[c1];\n+                util::swap(&mut array[dest], &mut tmp[c1]);\n                 dest += 1; c1 += 1; len1 -= 1;\n                 if len1 == 1 { break_outer = true; break; }\n                 min_gallop -= 1;\n@@ -574,7 +575,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         if len1 == 1 {\n             assert!(len2 > 0);\n             copy_vec(array, dest, array, c2, len2);\n-            array[dest+len2] <-> tmp[c1];\n+            util::swap(&mut array[dest+len2], &mut tmp[c1]);\n         } else if len1 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n@@ -599,7 +600,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         let mut len1 = len1;\n         let mut len2 = len2;\n \n-        array[dest] <-> array[c1];\n+        vec::swap(array, dest, c1);\n         dest -= 1; c1 -= 1; len1 -= 1;\n \n         if len1 == 0 {\n@@ -610,7 +611,7 @@ impl<T:Copy + Ord> MergeState<T> {\n             dest -= len1;\n             c1 -= len1;\n             copy_vec(array, dest+1, array, c1+1, len1);\n-            array[dest] <-> tmp[c2];\n+            util::swap(&mut array[dest], &mut tmp[c2]);\n             return;\n         }\n \n@@ -623,14 +624,14 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len1 != 0 && len2 > 1);\n                 if tmp[c2] < array[c1] {\n-                    array[dest] <-> array[c1];\n+                    vec::swap(array, dest, c1);\n                     dest -= 1; c1 -= 1; len1 -= 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 0 {\n                         break_outer = true;\n                     }\n                 } else {\n-                    array[dest] <-> tmp[c2];\n+                    util::swap(&mut array[dest], &mut tmp[c2]);\n                     dest -= 1; c2 -= 1; len2 -= 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 1 {\n@@ -659,7 +660,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                     if len1 == 0 { break_outer = true; break; }\n                 }\n \n-                array[dest] <-> tmp[c2];\n+                util::swap(&mut array[dest], &mut tmp[c2]);\n                 dest -= 1; c2 -= 1; len2 -= 1;\n                 if len2 == 1 { break_outer = true; break; }\n \n@@ -676,7 +677,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                     copy_vec(array, dest+1, tmp, c2+1, count2);\n                     if len2 <= 1 { break_outer = true; break; }\n                 }\n-                array[dest] <-> array[c1];\n+                vec::swap(array, dest, c1);\n                 dest -= 1; c1 -= 1; len1 -= 1;\n                 if len1 == 0 { break_outer = true; break; }\n                 min_gallop -= 1;\n@@ -696,7 +697,7 @@ impl<T:Copy + Ord> MergeState<T> {\n             dest -= len1;\n             c1 -= len1;\n             copy_vec(array, dest+1, array, c1+1, len1);\n-            array[dest] <-> tmp[c2];\n+            util::swap(&mut array[dest], &mut tmp[c2]);\n         } else if len2 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n@@ -1081,7 +1082,7 @@ mod big_tests {\n             for 3.times {\n                 let i1 = rng.gen_uint_range(0, n);\n                 let i2 = rng.gen_uint_range(0, n);\n-                arr[i1] <-> arr[i2];\n+                vec::swap(arr, i1, i2);\n             }\n             tim_sort(arr); // 3sort\n             isSorted(arr);\n@@ -1153,7 +1154,7 @@ mod big_tests {\n             for 3.times {\n                 let i1 = rng.gen_uint_range(0, n);\n                 let i2 = rng.gen_uint_range(0, n);\n-                arr[i1] <-> arr[i2];\n+                vec::swap(arr, i1, i2);\n             }\n             tim_sort(arr); // 3sort\n             isSorted(arr);"}, {"sha": "2b39458d32dcb2215e4a871d723921e43965f0fb", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -13,7 +13,7 @@\n //! `TotalOrd`.\n \n use core::iterator::*;\n-use core::util::replace;\n+use core::util::{swap, replace};\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where where red (horizontal) nodes can only be added\n@@ -756,8 +756,8 @@ fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     if node.left.map_default(false, |x| x.level == node.level) {\n         let mut save = node.left.swap_unwrap();\n-        node.left <-> save.right; // save.right now None\n-        *node <-> save;\n+        swap(&mut node.left, &mut save.right); // save.right now None\n+        swap(node, &mut save);\n         node.right = Some(save);\n     }\n }\n@@ -768,9 +768,9 @@ fn split<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     if node.right.map_default(false,\n       |x| x.right.map_default(false, |y| y.level == node.level)) {\n         let mut save = node.right.swap_unwrap();\n-        node.right <-> save.left; // save.left now None\n+        swap(&mut node.right, &mut save.left); // save.left now None\n         save.level += 1;\n-        *node <-> save;\n+        swap(node, &mut save);\n         node.left = Some(save);\n     }\n }\n@@ -823,14 +823,14 @@ fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n                           key: &K) -> Option<V> {\n     fn heir_swap<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>,\n-                            child: &mut Option<~TreeNode<K, V>>) {\n+                                 child: &mut Option<~TreeNode<K, V>>) {\n         // *could* be done without recursion, but it won't borrow check\n         for child.each_mut |x| {\n             if x.right.is_some() {\n                 heir_swap(node, &mut x.right);\n             } else {\n-                node.key <-> x.key;\n-                node.value <-> x.value;\n+                swap(&mut node.key, &mut x.key);\n+                swap(&mut node.value, &mut x.value);\n             }\n         }\n     }\n@@ -850,8 +850,8 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n                     if left.right.is_some() {\n                         heir_swap(save, &mut left.right);\n                     } else {\n-                        save.key <-> left.key;\n-                        save.value <-> left.value;\n+                        swap(&mut save.key, &mut left.key);\n+                        swap(&mut save.value, &mut left.value);\n                     }\n                     save.left = Some(left);\n                     (remove(&mut save.left, key), true)"}, {"sha": "a9e4ec50c7c0952fb4eb629e3337e3e2c65456b0", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -22,6 +22,7 @@ use core::io;\n use core::pipes::recv;\n use core::run;\n use core::to_bytes;\n+use core::util::replace;\n \n /**\n *\n@@ -352,9 +353,7 @@ impl TPrep for Prep {\n \n             _ => {\n                 let (port, chan) = oneshot();\n-                let mut blk = None;\n-                blk <-> bo;\n-                let blk = blk.unwrap();\n+                let blk = replace(&mut bo, None).unwrap();\n                 let chan = Cell(chan);\n \n                 do task::spawn {\n@@ -386,9 +385,7 @@ fn unwrap<T:Owned +\n             Decodable<json::Decoder>>( // FIXME(#5121)\n         w: Work<T>) -> T {\n     let mut ww = w;\n-    let mut s = None;\n-\n-    ww.res <-> s;\n+    let s = replace(&mut ww.res, None);\n \n     match s {\n         None => fail!(),"}, {"sha": "e6b3b3bbe20d3b16c8b310506e74f07f927a8910", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -14,6 +14,7 @@ extern mod std;\n \n use std::time::precise_time_s;\n use core::rand::RngUtil;\n+use core::util;\n \n macro_rules! bench (\n     ($id:ident) => (maybe_run_test(argv, stringify!($id).to_owned(), $id))\n@@ -115,7 +116,7 @@ fn vec_push_all() {\n             v.push_all(rv);\n         }\n         else {\n-            v <-> rv;\n+            util::swap(&mut v, &mut rv);\n             v.push_all(rv);\n         }\n     }"}, {"sha": "f5191914679fe76c7f77abae0abc95435a88a2cf", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -20,6 +20,7 @@ extern mod std;\n \n use core::cell::Cell;\n use core::pipes::recv;\n+use core::util;\n use std::time;\n use std::future;\n \n@@ -42,10 +43,8 @@ fn thread_ring(i: uint,\n     // Send/Receive lots of messages.\n     for uint::range(0, count) |j| {\n         //error!(\"task %?, iter %?\", i, j);\n-        let mut num_chan2 = None;\n-        let mut num_port2 = None;\n-        num_chan2 <-> num_chan;\n-        num_port2 <-> num_port;\n+        let num_chan2 = replace(&mut num_chan, None);\n+        let num_port2 = replace(&mut num_port, None);\n         num_chan = Some(ring::client::num(num_chan2.unwrap(), i * j));\n         let port = num_port2.unwrap();\n         match recv(port) {"}, {"sha": "210bf5cb6de416c4c9ab7c1e42212d2be46c37a0", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -17,6 +17,7 @@ use core::hashmap::HashMap;\n use core::io::ReaderUtil;\n use core::comm::{stream, Port, Chan};\n use core::cmp::Ord;\n+use core::util;\n \n // given a map, print a sorted version of it\n fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n@@ -159,8 +160,7 @@ fn main() {\n     let mut from_child = ~[];\n     let to_child   = vec::mapi(sizes, |ii, sz| {\n         let sz = *sz;\n-        let mut stream = None;\n-        stream <-> streams[ii];\n+        let stream = util::replace(&mut streams[ii], None);\n         let (from_child_, to_parent_) = stream.unwrap();\n \n         from_child.push(from_child_);"}, {"sha": "40ccfca919b67c2781a76164f8757b831d323ed5", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-swap.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7d22437ecdc5b52f8517ffde6207347739b26553/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d22437ecdc5b52f8517ffde6207347739b26553/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-swap.rs?ref=7d22437ecdc5b52f8517ffde6207347739b26553", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn test1() {\n-    let v: int;\n-    let mut w: int;\n-    v = 1; //~ NOTE prior assignment occurs here\n-    w = 2;\n-    v <-> w; //~ ERROR re-assignment of immutable variable\n-}\n-\n-fn test2() {\n-    let v: int;\n-    let mut w: int;\n-    v = 1; //~ NOTE prior assignment occurs here\n-    w = 2;\n-    w <-> v; //~ ERROR re-assignment of immutable variable\n-}\n-\n-fn main() {\n-}"}, {"sha": "b2d475dd78926c6386c1dea90ed771e59afd71a7", "filename": "src/test/compile-fail/liveness-swap-uninit.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d22437ecdc5b52f8517ffde6207347739b26553/src%2Ftest%2Fcompile-fail%2Fliveness-swap-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d22437ecdc5b52f8517ffde6207347739b26553/src%2Ftest%2Fcompile-fail%2Fliveness-swap-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-swap-uninit.rs?ref=7d22437ecdc5b52f8517ffde6207347739b26553", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let mut x = 3;\n-    let y;\n-    x <-> y; //~ ERROR use of possibly uninitialized variable: `y`\n-    copy x;\n-}"}, {"sha": "5b733129ee5dc8d87a37564b0d85fbb18b791bb7", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -87,7 +87,7 @@ fn f110() {\n \n fn f120() {\n     let x = ~[~\"hi\", ~\"ho\"];\n-    x[0] <-> x[1];\n+    vec::swap(x, 0, 1);\n     touch(&x[0]);\n     touch(&x[1]);\n }"}, {"sha": "eca5fb0d315d87aa2c83bde0a0462d1c21f7c829", "filename": "src/test/compile-fail/swap-no-lval.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7d22437ecdc5b52f8517ffde6207347739b26553/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d22437ecdc5b52f8517ffde6207347739b26553/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs?ref=7d22437ecdc5b52f8517ffde6207347739b26553", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    5 <-> 3;\n-    //~^ ERROR cannot assign\n-    //~^^ ERROR cannot assign\n-}"}, {"sha": "023eaae0a7648a4efbab3eca396b9d4201e72d04", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::util;\n+\n struct Ints {sum: ~int, values: ~[int]}\n \n fn add_int(x: &mut Ints, v: int) {\n     *x.sum += v;\n     let mut values = ~[];\n-    x.values <-> values;\n+    util::swap(&mut values, &mut x.values);\n     values.push(v);\n-    x.values <-> values;\n+    util::swap(&mut values, &mut x.values);\n }\n \n fn iter_ints(x: &Ints, f: &fn(x: &int) -> bool) -> bool {"}, {"sha": "60daaea57d758428a8e48fcad032bf7d640bab5d", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -10,8 +10,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::util;\n+\n // tjc: I don't know why\n pub mod pipes {\n+    use core::util;\n     use core::cast::{forget, transmute};\n \n     pub struct Stuff<T> {\n@@ -104,8 +107,7 @@ pub mod pipes {\n             match old_state {\n               empty | blocked => { task::yield(); }\n               full => {\n-                let mut payload = None;\n-                payload <-> (*p).payload;\n+                let payload = util::replace(&mut p.payload, None);\n                 return Some(payload.unwrap())\n               }\n               terminated => {\n@@ -159,10 +161,9 @@ pub mod pipes {\n         fn finalize(&self) {\n             unsafe {\n                 if self.p != None {\n-                    let mut p = None;\n                     let self_p: &mut Option<*packet<T>> =\n                         cast::transmute(&self.p);\n-                    p <-> *self_p;\n+                    let p = util::replace(self_p, None);\n                     sender_terminate(p.unwrap())\n                 }\n             }\n@@ -171,9 +172,7 @@ pub mod pipes {\n \n     pub impl<T:Owned> send_packet<T> {\n         fn unwrap(&mut self) -> *packet<T> {\n-            let mut p = None;\n-            p <-> self.p;\n-            p.unwrap()\n+            util::replace(&mut self.p, None).unwrap()\n         }\n     }\n \n@@ -192,10 +191,9 @@ pub mod pipes {\n         fn finalize(&self) {\n             unsafe {\n                 if self.p != None {\n-                    let mut p = None;\n                     let self_p: &mut Option<*packet<T>> =\n                         cast::transmute(&self.p);\n-                    p <-> *self_p;\n+                    let p = util::replace(self_p, None);\n                     receiver_terminate(p.unwrap())\n                 }\n             }\n@@ -204,9 +202,7 @@ pub mod pipes {\n \n     pub impl<T:Owned> recv_packet<T> {\n         fn unwrap(&mut self) -> *packet<T> {\n-            let mut p = None;\n-            p <-> self.p;\n-            p.unwrap()\n+            util::replace(&mut self.p, None).unwrap()\n         }\n     }\n \n@@ -225,6 +221,7 @@ pub mod pipes {\n pub mod pingpong {\n     use core::cast;\n     use core::ptr;\n+    use core::util;\n \n     pub struct ping(::pipes::send_packet<pong>);\n     pub struct pong(::pipes::send_packet<ping>);"}, {"sha": "a87a899cafeafc6e58f608cd691dd20a11243f25", "filename": "src/test/run-pass/regions-infer-borrow-scope-addr-of.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-addr-of.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::util;\n+\n pub fn main() {\n     let mut x = 4;\n \n@@ -24,6 +26,6 @@ pub fn main() {\n             }\n         }\n         let mut y = 4;\n-        y <-> x;\n+        util::swap(&mut y, &mut x);\n     }\n }"}, {"sha": "ed69fa41d711f57610f2f2f905acf76e8d45f60f", "filename": "src/test/run-pass/swap-1.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fswap-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fswap-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-1.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::util;\n+\n pub fn main() {\n     let mut x = 3; let mut y = 7;\n-    x <-> y; assert!((x == 7)); assert!((y == 3));\n+    util::swap(&mut x, &mut y);\n+    assert!((x == 7)); assert!((y == 3));\n }"}, {"sha": "63b377b26d83e778c179aca256c3d5fbffe96f23", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn swap<T>(v: &mut [T], i: int, j: int) { v[i] <-> v[j]; }\n+use core::util;\n \n pub fn main() {\n     let mut a: ~[int] = ~[0, 1, 2, 3, 4, 5, 6];\n-    swap(a, 2, 4);\n+    vec::swap(a, 2, 4);\n     assert!((a[2] == 4));\n     assert!((a[4] == 2));\n     let mut n = 42;\n-    n <-> a[0];\n+    util::swap(&mut n, &mut a[0]);\n     assert!((a[0] == 42));\n     assert!((n == 0));\n }"}, {"sha": "05f943bf928ca70b25ff385c10da026aedb7944f", "filename": "src/test/run-pass/swap-overlapping.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -10,6 +10,8 @@\n \n // Issue #5041 - avoid overlapping memcpy when src and dest of a swap are the same\n \n+use core::util;\n+\n pub fn main() {\n     let mut test = TestDescAndFn {\n         desc: TestDesc {\n@@ -22,7 +24,10 @@ pub fn main() {\n }\n \n fn do_swap(test: &mut TestDescAndFn) {\n-    *test <-> *test;\n+    unsafe {\n+        util::swap_ptr(ptr::to_mut_unsafe_ptr(test),\n+                       ptr::to_mut_unsafe_ptr(test));\n+    }\n }\n \n pub enum TestName {"}, {"sha": "bf58e2c7cb53b1aad7031b215a6fee21f3c8d83f", "filename": "src/test/run-pass/unique-swap.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Funique-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Funique-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-swap.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::util;\n+\n pub fn main() {\n     let mut i = ~100;\n     let mut j = ~200;\n-    i <-> j;\n+    util::swap(&mut i, &mut j);\n     assert!(i == ~200);\n     assert!(j == ~100);\n }"}, {"sha": "38aa56b65125b075cbd02546c169f9fcedb904de", "filename": "src/test/run-pass/weird-exprs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998fececd6516fa07d0cd0a0c4607ddef0bc40f0/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exprs.rs?ref=998fececd6516fa07d0cd0a0c4607ddef0bc40f0", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::util;\n+\n // Just a grab bag of stuff that you wouldn't want to actually write.\n \n fn strange() -> bool { let _x: bool = return true; }\n@@ -52,7 +54,7 @@ fn notsure() {\n     let mut _y = (_x = 0) == (_x = 0);\n     let mut _z = (_x = 0) < (_x = 0);\n     let _a = (_x += 0) == (_x = 0);\n-    let _b = (_y <-> _z) == (_y <-> _z);\n+    let _b = util::swap(&mut _y, &mut _z) == util::swap(&mut _y, &mut _z);\n }\n \n fn canttouchthis() -> uint {"}]}