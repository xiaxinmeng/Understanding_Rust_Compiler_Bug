{"sha": "02e1fd48d183c9a28dc7f78b68fded919a1b9338", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZTFmZDQ4ZDE4M2M5YTI4ZGM3Zjc4YjY4ZmRlZDkxOWExYjkzMzg=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-02-01T13:29:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-01T13:29:47Z"}, "message": "Rollup merge of #81618 - bjorn3:sync_cg_clif-2021-02-01, r=bjorn3\n\nSync rustc_codegen_cranelift\n\nThe highlight of this sync are abi compatibility with cg_llvm allowing mixing of cg_clif and cg_llvm compiled crates and switching to the x64 cranelift backend based on the new backend framework.\n\nr? ``@ghost``\n\n``@rustbot`` label +A-codegen +A-cranelift +T-compiler", "tree": {"sha": "657640b240cc83aa584b7b6025cb55721cdd0235", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/657640b240cc83aa584b7b6025cb55721cdd0235"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02e1fd48d183c9a28dc7f78b68fded919a1b9338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02e1fd48d183c9a28dc7f78b68fded919a1b9338", "html_url": "https://github.com/rust-lang/rust/commit/02e1fd48d183c9a28dc7f78b68fded919a1b9338", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02e1fd48d183c9a28dc7f78b68fded919a1b9338/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b8f2acd5f0f450fb3d9320a3295f5b86dbd31f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8f2acd5f0f450fb3d9320a3295f5b86dbd31f1", "html_url": "https://github.com/rust-lang/rust/commit/2b8f2acd5f0f450fb3d9320a3295f5b86dbd31f1"}, {"sha": "a75f9bc3be1d9488de2d13e4afbf724ffadfc70f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a75f9bc3be1d9488de2d13e4afbf724ffadfc70f", "html_url": "https://github.com/rust-lang/rust/commit/a75f9bc3be1d9488de2d13e4afbf724ffadfc70f"}], "stats": {"total": 1711, "additions": 993, "deletions": 718}, "files": [{"sha": "20c58423a0c502c7386799638a300d3f06edbbe3", "filename": ".github/workflows/main.yml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fmain.yml?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -12,6 +12,9 @@ jobs:\n       fail-fast: false\n       matrix:\n         os: [ubuntu-latest, macos-latest]\n+        env:\n+          - BACKEND: \"\"\n+          - BACKEND: --oldbe\n \n     steps:\n     - uses: actions/checkout@v2\n@@ -51,7 +54,7 @@ jobs:\n         export COMPILE_RUNS=2\n         export RUN_RUNS=2\n \n-        ./test.sh\n+        ./test.sh $BACKEND\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz build"}, {"sha": "b241bef9d1e7ff6c03aa98ee03abe04252823a6c", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -8,6 +8,7 @@ perf.data.old\n *.string*\n /build\n /build_sysroot/sysroot_src\n+/build_sysroot/compiler-builtins\n /rust\n /rand\n /regex"}, {"sha": "19ea41563dfd6790dfc320acb280c38ebee9b9d8", "filename": ".vscode/settings.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Fsettings.json?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -1,7 +1,7 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n     \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\"],\n-    \"rust-analyzer.assist.importMergeBehaviour\": \"last\",\n+    \"rust-analyzer.assist.importMergeBehavior\": \"last\",\n     \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\","}, {"sha": "5495cfa5eaa0dc9ca414764805b45b0d288c893e", "filename": "Cargo.lock", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -2,9 +2,9 @@\n # It is not intended for manual editing.\n [[package]]\n name = \"anyhow\"\n-version = \"1.0.34\"\n+version = \"1.0.38\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf8dcb5b4bbaa28653b647d8c77bd4ed40183b48882e130c1f1ffb73de069fd7\"\n+checksum = \"afddf7f520a80dbf76e6f50a35bca42a2331ef227a28b3b6dc5c2e2338d114b1\"\n \n [[package]]\n name = \"ar\"\n@@ -25,15 +25,15 @@ checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n \n [[package]]\n name = \"byteorder\"\n-version = \"1.3.4\"\n+version = \"1.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"08c48aae112d48ed9f069b33538ea9e3e90aa263cfa3d1c24309612b1f7472de\"\n+checksum = \"ae44d1a3d5a19df61dd0c8beb138458ac2a53a7ac09eba97d55592540004306b\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.62\"\n+version = \"1.0.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f1770ced377336a88a67c473594ccc14eca6f4559217c34f64aac8f83d641b40\"\n+checksum = \"4c0496836a84f8d0495758516b8621a622beb77c0fed418570e50764093ced48\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -49,16 +49,16 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -75,27 +75,27 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -105,8 +105,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -123,8 +123,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -135,8 +135,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"raw-cpuid\",\n@@ -145,8 +145,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -209,35 +209,35 @@ checksum = \"d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04\"\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.6.0\"\n+version = \"1.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"55e2e4c765aa53a0424761bf9f41aa7a6ac1efa87238f59560640e27fca028f2\"\n+checksum = \"4fb1fa934250de4de8aef298d81c729a7d33d8c239daa3a7575e6b92bfc7313b\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.80\"\n+version = \"0.2.82\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4d58d1b70b004888f764dfbf6a26a3b0342a1632d33968e4a179d8011c760614\"\n+checksum = \"89203f3fba0a3795506acaad8ebce3c80c0af93f994d5a1d7a0b1eeb23271929\"\n \n [[package]]\n name = \"libloading\"\n-version = \"0.6.5\"\n+version = \"0.6.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1090080fe06ec2648d0da3881d9453d97e71a45f00eb179af7fdd7e3f686fdb0\"\n+checksum = \"351a32417a12d5f7e82c368a66781e307834dae04c6ce0cd4456d52989229883\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n  \"winapi\",\n ]\n \n [[package]]\n name = \"log\"\n-version = \"0.4.11\"\n+version = \"0.4.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4fabed175da42fed1fa0746b0ea71f412aa9d35e76e95e59b192c64b9dc2bf8b\"\n+checksum = \"fcf3805d4480bb5b86070dcfeb9e2cb2ebc148adb753c5cca5f884d1d65a42b2\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n ]\n@@ -272,9 +272,9 @@ dependencies = [\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.7\"\n+version = \"1.0.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"aa563d17ecb180e500da1cfd2b028310ac758de548efdd203e18f283af693f37\"\n+checksum = \"991431c3519a3f36861882da93630ce66b52918dcf1b8e2fd66b397fc96f28df\"\n dependencies = [\n  \"proc-macro2\",\n ]\n@@ -333,6 +333,7 @@ dependencies = [\n  \"indexmap\",\n  \"libloading\",\n  \"object\",\n+ \"smallvec\",\n  \"target-lexicon\",\n ]\n \n@@ -362,15 +363,15 @@ checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.4.2\"\n+version = \"1.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbee7696b84bbf3d89a1c2eccff0850e3047ed46bfcd2e92c29a2d074d57e252\"\n+checksum = \"fe0f37c9e8f3c5a4a66ad655a93c74daac4ad00c441533bf5c6e7990bb42604e\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.48\"\n+version = \"1.0.58\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc371affeffc477f42a221a1e4297aedcea33d47d19b61455588bd9d8f6b19ac\"\n+checksum = \"cc60a3d73ea6594cd712d830cc1f0390fd71542d8c8cd24e70cc54cdfd5e05d5\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -385,18 +386,18 @@ checksum = \"4ee5a98e506fb7231a304c3a1bd7c132a55016cf65001e0282480665870dfcb9\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.22\"\n+version = \"1.0.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0e9ae34b84616eedaaf1e9dd6026dbe00dcafa92aa0c8077cb69df1fcfe5e53e\"\n+checksum = \"76cc616c6abf8c8928e2fdcc0dbfab37175edd8fb49a4641066ad1364fdab146\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.22\"\n+version = \"1.0.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9ba20f23e85b10754cd195504aebf6a27e2e6cbe28c17778a0c930724628dd56\"\n+checksum = \"9be73a2caec27583d0046ef3796c3794f868a5bc813db689eed00c7631275cd1\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "3820fce6d1e0df69ff647f91965a2ac81741e230", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -9,7 +9,7 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\"] }\n+cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x86\", \"x64\"] }\n cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n@@ -21,6 +21,7 @@ object = { version = \"0.22.0\", default-features = false, features = [\"std\", \"rea\n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.0.2\"\n libloading = { version = \"0.6.0\", optional = true }\n+smallvec = \"1.6.1\"\n \n # Uncomment to use local checkout of cranelift\n #[patch.\"https://github.com/bytecodealliance/wasmtime/\"]\n@@ -37,6 +38,7 @@ libloading = { version = \"0.6.0\", optional = true }\n default = [\"jit\", \"inline_asm\"]\n jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n+oldbe = []\n \n [profile.dev]\n # By compiling dependencies with optimizations, performing tests gets much faster."}, {"sha": "6fa5eebdc2f3deec6436b6af11067604cb380450", "filename": "Readme.md", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -1,6 +1,4 @@\n-# WIP Cranelift codegen backend for rust\n-\n-> \u26a0\u26a0\u26a0 Certain kinds of FFI don't work yet. \u26a0\u26a0\u26a0\n+# Cranelift codegen backend for rust\n \n The goal of this project is to create an alternative codegen backend for the rust compiler based on [Cranelift](https://github.com/bytecodealliance/wasmtime/blob/main/cranelift).\n This has the potential to improve compilation times in debug mode.\n@@ -103,8 +101,7 @@ function jit_calc() {\n \n ## Not yet supported\n \n-* Good non-rust abi support ([several problems](https://github.com/bjorn3/rustc_codegen_cranelift/issues/10))\n-* Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041)\n+* Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041))\n     * On Linux there is support for invoking an external assembler for `global_asm!` and `asm!`.\n       `llvm_asm!` will remain unimplemented forever. `asm!` doesn't yet support reg classes. You\n       have to specify specific registers instead."}, {"sha": "598ce35eceaac6dbe21bba8c9a87b9a1bce913f5", "filename": "build.sh", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.sh?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -3,58 +3,84 @@ set -e\n \n # Settings\n export CHANNEL=\"release\"\n-build_sysroot=1\n+build_sysroot=\"clif\"\n target_dir='build'\n+oldbe=''\n while [[ $# != 0 ]]; do\n     case $1 in\n         \"--debug\")\n             export CHANNEL=\"debug\"\n             ;;\n-        \"--without-sysroot\")\n-            build_sysroot=0\n+        \"--sysroot\")\n+            build_sysroot=$2\n+            shift\n             ;;\n         \"--target-dir\")\n             target_dir=$2\n             shift\n             ;;\n+        \"--oldbe\")\n+            oldbe='--features oldbe'\n+            ;;\n         *)\n             echo \"Unknown flag '$1'\"\n-            echo \"Usage: ./build.sh [--debug] [--without-sysroot] [--target-dir DIR]\"\n+            echo \"Usage: ./build.sh [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--oldbe]\"\n+            exit 1\n             ;;\n     esac\n     shift\n done\n \n # Build cg_clif\n unset CARGO_TARGET_DIR\n-export RUSTFLAGS=\"-Zrun_dsymutil=no\"\n unamestr=$(uname)\n if [[ \"$unamestr\" == 'Linux' ]]; then\n    export RUSTFLAGS='-Clink-arg=-Wl,-rpath=$ORIGIN/../lib '$RUSTFLAGS\n elif [[ \"$unamestr\" == 'Darwin' ]]; then\n-   export RUSTFLAGS='-Clink-arg=-Wl,-rpath,@loader_path/../lib -Zosx-rpath-install-name '$RUSTFLAGS\n+   export RUSTFLAGS='-Csplit-debuginfo=unpacked -Clink-arg=-Wl,-rpath,@loader_path/../lib -Zosx-rpath-install-name '$RUSTFLAGS\n    dylib_ext='dylib'\n else\n    echo \"Unsupported os\"\n    exit 1\n fi\n if [[ \"$CHANNEL\" == \"release\" ]]; then\n-    cargo build --release\n+    cargo build $oldbe --release\n else\n-    cargo build\n+    cargo build $oldbe\n fi\n \n+source scripts/ext_config.sh\n+\n rm -rf \"$target_dir\"\n mkdir \"$target_dir\"\n mkdir \"$target_dir\"/bin \"$target_dir\"/lib\n ln target/$CHANNEL/cg_clif{,_build_sysroot} \"$target_dir\"/bin\n ln target/$CHANNEL/*rustc_codegen_cranelift* \"$target_dir\"/lib\n ln rust-toolchain scripts/config.sh scripts/cargo.sh \"$target_dir\"\n \n-if [[ \"$build_sysroot\" == \"1\" ]]; then\n-    echo \"[BUILD] sysroot\"\n-    export CG_CLIF_INCR_CACHE_DISABLED=1\n-    dir=$(pwd)\n-    cd \"$target_dir\"\n-    time \"$dir/build_sysroot/build_sysroot.sh\"\n+mkdir -p \"$target_dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n+if [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n+    cp $(rustc --print sysroot)/lib/rustlib/$TARGET_TRIPLE/lib/*.o \"$target_dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n fi\n+\n+case \"$build_sysroot\" in\n+    \"none\")\n+        ;;\n+    \"llvm\")\n+        cp -r $(rustc --print sysroot)/lib/rustlib/$TARGET_TRIPLE/lib \"$target_dir/lib/rustlib/$TARGET_TRIPLE/\"\n+        ;;\n+    \"clif\")\n+        echo \"[BUILD] sysroot\"\n+        dir=$(pwd)\n+        cd \"$target_dir\"\n+        time \"$dir/build_sysroot/build_sysroot.sh\"\n+        cp lib/rustlib/*/lib/libstd-* lib/\n+        ;;\n+    *)\n+        echo \"Unknown sysroot kind \\`$build_sysroot\\`.\"\n+        echo \"The allowed values are:\"\n+        echo \"    none A sysroot that doesn't contain the standard library\"\n+        echo \"    llvm Copy the sysroot from rustc compiled by cg_llvm\"\n+        echo \"    clif Build a new sysroot using cg_clif\"\n+        exit 1\n+esac"}, {"sha": "0da9999c172853a1fd988d5f3cb16fcb6f2ca0fc", "filename": "build_sysroot/Cargo.lock", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/build_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/build_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.lock?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -2,9 +2,9 @@\n # It is not intended for manual editing.\n [[package]]\n name = \"addr2line\"\n-version = \"0.14.0\"\n+version = \"0.14.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7c0929d69e78dd9bf5408269919fcbcaeb2e35e5d43e5815517cdc6a8e11a423\"\n+checksum = \"a55f82cfe485775d02112886f4169bde0c5894d75e79ead7eafe7e40a25e45f7\"\n dependencies = [\n  \"compiler_builtins\",\n  \"gimli\",\n@@ -63,9 +63,7 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.36\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7cd0782e0a7da7598164153173e5a5d4d9b1da094473c98dce0ff91406112369\"\n+version = \"0.1.39\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -130,9 +128,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.17\"\n+version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aca5565f760fb5b220e499d72710ed156fdb74e631659e99377d9ebfbd13ae8\"\n+checksum = \"322f4de77956e22ed0e5032c359a0f1273f1f7f0d79bfa3b8ffbc730d7fbcc5c\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -141,9 +139,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.81\"\n+version = \"0.2.84\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1482821306169ec4d07f6aca392a4681f66c75c9918aa49641a2595db64053cb\"\n+checksum = \"1cca32fa0182e8c0989459524dc356b8f2b5c10f1b9eb521b7d182c03cf8c5ff\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "82516c98af2a2c9501ec695a40c27c1777985267", "filename": "build_sysroot/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/build_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/build_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.toml?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -11,12 +11,13 @@ test = { path = \"./sysroot_src/library/test\" }\n \n alloc_system = { path = \"./alloc_system\" }\n \n-compiler_builtins = { version = \"=0.1.36\", default-features = false }\n+compiler_builtins = { version = \"0.1.39\", default-features = false, features = [\"no-asm\"] }\n \n [patch.crates-io]\n rustc-std-workspace-core = { path = \"./sysroot_src/library/rustc-std-workspace-core\" }\n rustc-std-workspace-alloc = { path = \"./sysroot_src/library/rustc-std-workspace-alloc\" }\n rustc-std-workspace-std = { path = \"./sysroot_src/library/rustc-std-workspace-std\" }\n+compiler_builtins = { path = \"./compiler-builtins\" }\n \n [profile.dev]\n lto = \"off\""}, {"sha": "282ce4a582c4b6eb2a37fb0ad6b19a7b9f07eabd", "filename": "build_sysroot/build_sysroot.sh", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/build_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/build_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Fbuild_sysroot.sh?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -24,17 +24,16 @@ export CARGO_TARGET_DIR=target\n \n # Build libs\n export RUSTFLAGS=\"$RUSTFLAGS -Zforce-unstable-if-unmarked -Cpanic=abort\"\n+export __CARGO_DEFAULT_LIB_METADATA=\"cg_clif\"\n if [[ \"$1\" != \"--debug\" ]]; then\n     sysroot_channel='release'\n     # FIXME Enable incremental again once rust-lang/rust#74946 is fixed\n-    # FIXME Enable -Zmir-opt-level=2 again once it doesn't ice anymore\n-    CARGO_INCREMENTAL=0 RUSTFLAGS=\"$RUSTFLAGS\" cargo build --target \"$TARGET_TRIPLE\" --release\n+    CARGO_INCREMENTAL=0 RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=2\" cargo build --target \"$TARGET_TRIPLE\" --release\n else\n     sysroot_channel='debug'\n     cargo build --target \"$TARGET_TRIPLE\"\n fi\n \n # Copy files to sysroot\n-mkdir -p \"$dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n ln \"target/$TARGET_TRIPLE/$sysroot_channel/deps/\"* \"$dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n rm \"$dir/lib/rustlib/$TARGET_TRIPLE/lib/\"*.{rmeta,d}"}, {"sha": "d3b87e02ba8913997bb5a600f77deb8301a8edeb", "filename": "build_sysroot/prepare_sysroot_src.sh", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/build_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/build_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Fprepare_sysroot_src.sh?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -29,4 +29,11 @@ git commit --no-gpg-sign -m \"Patch $file\"\n done\n popd\n \n-echo \"Successfully prepared libcore for building\"\n+git clone https://github.com/rust-lang/compiler-builtins.git || echo \"rust-lang/compiler-builtins has already been cloned\"\n+pushd compiler-builtins\n+git checkout -- .\n+git checkout 0.1.39\n+git apply ../../crate_patches/0001-compiler-builtins-Remove-rotate_left-from-Int.patch\n+popd\n+\n+echo \"Successfully prepared sysroot source for building\""}, {"sha": "b47efe72bce0320592bcf20a62e6d67b2e8b723f", "filename": "clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/clean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/clean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clean_all.sh?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -1,5 +1,5 @@\n #!/bin/bash --verbose\n set -e\n \n-rm -rf target/ build/ build_sysroot/{sysroot_src/,target/} perf.data{,.old}\n+rm -rf target/ build/ build_sysroot/{sysroot_src/,target/,compiler-builtins/} perf.data{,.old}\n rm -rf rand/ regex/ simple-raytracer/"}, {"sha": "e14768910a9ac49d3ffb144994e67e2f5367daa9", "filename": "crate_patches/0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/crate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/crate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -0,0 +1,35 @@\n+From 7078cca3cb614e1e82da428380b4e16fc3afef46 Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 21 Jan 2021 14:46:36 +0100\n+Subject: [PATCH] Remove rotate_left from Int\n+\n+---\n+ src/int/mod.rs | 5 -----\n+ 1 file changed, 5 deletions(-)\n+\n+diff --git a/src/int/mod.rs b/src/int/mod.rs\n+index 06054c8..3bea17b 100644\n+--- a/src/int/mod.rs\n++++ b/src/int/mod.rs\n+@@ -85,7 +85,6 @@ pub trait Int:\n+     fn wrapping_sub(self, other: Self) -> Self;\n+     fn wrapping_shl(self, other: u32) -> Self;\n+     fn wrapping_shr(self, other: u32) -> Self;\n+-    fn rotate_left(self, other: u32) -> Self;\n+     fn overflowing_add(self, other: Self) -> (Self, bool);\n+     fn aborting_div(self, other: Self) -> Self;\n+     fn aborting_rem(self, other: Self) -> Self;\n+@@ -209,10 +208,6 @@ macro_rules! int_impl_common {\n+             <Self>::wrapping_shr(self, other)\n+         }\n+ \n+-        fn rotate_left(self, other: u32) -> Self {\n+-            <Self>::rotate_left(self, other)\n+-        }\n+-\n+         fn overflowing_add(self, other: Self) -> (Self, bool) {\n+             <Self>::overflowing_add(self, other)\n+         }\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "f59600ebb330cc9e8a3a40444e7199667e928e1a", "filename": "example/alloc_example.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/example%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/example%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Falloc_example.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -11,7 +11,8 @@ use alloc_system::System;\n #[global_allocator]\n static ALLOC: System = System;\n \n-#[link(name = \"c\")]\n+#[cfg_attr(unix, link(name = \"c\"))]\n+#[cfg_attr(target_env = \"msvc\", link(name = \"msvcrt\"))]\n extern \"C\" {\n     fn puts(s: *const u8) -> i32;\n }"}, {"sha": "002ec7e2e3d7a6e3be28ffad8750d12e1b10e52c", "filename": "example/mini_core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/example%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/example%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -532,8 +532,8 @@ pub mod intrinsics {\n }\n \n pub mod libc {\n-    #[cfg_attr(not(windows), link(name = \"c\"))]\n-    #[cfg_attr(windows, link(name = \"msvcrt\"))]\n+    #[cfg_attr(unix, link(name = \"c\"))]\n+    #[cfg_attr(target_env = \"msvc\", link(name = \"msvcrt\"))]\n     extern \"C\" {\n         pub fn puts(s: *const i8) -> i32;\n         pub fn printf(format: *const i8, ...) -> i32;"}, {"sha": "152041aa9ed0b90f0002be2033f16d2c73e1e4a2", "filename": "example/mod_bench.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/example%2Fmod_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/example%2Fmod_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmod_bench.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -1,7 +1,8 @@\n #![feature(start, box_syntax, core_intrinsics, lang_items)]\n #![no_std]\n \n-#[link(name = \"c\")]\n+#[cfg_attr(unix, link(name = \"c\"))]\n+#[cfg_attr(target_env = \"msvc\", link(name = \"msvcrt\"))]\n extern {}\n \n #[panic_handler]"}, {"sha": "3eb10069adad61f24da73215a2b5c62b108de3ea", "filename": "patches/0022-core-Disable-not-compiling-tests.patch", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/patches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/patches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0022-core-Disable-not-compiling-tests.patch?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -119,5 +119,21 @@ index 6609bc3..241b497 100644\n  \n  #[test]\n  #[should_panic(expected = \"index 0 greater than length of slice\")]\n+diff --git a/library/core/tests/num/ops.rs b/library/core/tests/num/ops.rs\n+index 9979cc8..d5d1d83 100644\n+--- a/library/core/tests/num/ops.rs\n++++ b/library/core/tests/num/ops.rs\n+@@ -238,7 +238,7 @@ macro_rules! test_shift_assign {\n+         }\n+     };\n+ }\n+-test_shift!(test_shl_defined, Shl::shl);\n+-test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n+-test_shift!(test_shr_defined, Shr::shr);\n+-test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);\n++//test_shift!(test_shl_defined, Shl::shl);\n++//test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n++//test_shift!(test_shr_defined, Shr::shr);\n++//test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);\n --\n 2.21.0 (Apple Git-122)"}, {"sha": "a08f00d19c20fa1348bc138d4e779060b23a6e50", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -1 +1 @@\n-nightly-2020-12-23\n+nightly-2021-01-30"}, {"sha": "834708aa9a6fbb3c697a2b407d4aa9caaa5ea5c0", "filename": "scripts/config.sh", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/scripts%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/scripts%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Fconfig.sh?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -12,28 +12,6 @@ else\n    exit 1\n fi\n \n-HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n-TARGET_TRIPLE=$HOST_TRIPLE\n-#TARGET_TRIPLE=\"x86_64-pc-windows-gnu\"\n-#TARGET_TRIPLE=\"aarch64-unknown-linux-gnu\"\n-\n-linker=''\n-RUN_WRAPPER=''\n-export JIT_SUPPORTED=1\n-if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n-   export JIT_SUPPORTED=0\n-   if [[ \"$TARGET_TRIPLE\" == \"aarch64-unknown-linux-gnu\" ]]; then\n-      # We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n-      linker='-Clinker=aarch64-linux-gnu-gcc'\n-      RUN_WRAPPER='qemu-aarch64 -L /usr/aarch64-linux-gnu'\n-   elif [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n-      # We are cross-compiling for Windows. Run tests in wine.\n-      RUN_WRAPPER='wine'\n-   else\n-      echo \"Unknown non-native platform\"\n-   fi\n-fi\n-\n if echo \"$RUSTC_WRAPPER\" | grep sccache; then\n echo\n echo -e \"\\x1b[1;93m=== Warning: Unset RUSTC_WRAPPER to prevent interference with sccache ===\\x1b[0m\"\n@@ -44,16 +22,14 @@ fi\n dir=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\"; pwd)\n \n export RUSTC=$dir\"/bin/cg_clif\"\n-export RUSTFLAGS=$linker\" \"$RUSTFLAGS\n+\n export RUSTDOCFLAGS=$linker' -Cpanic=abort -Zpanic-abort-tests '\\\n '-Zcodegen-backend='$dir'/lib/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$dir\n \n # FIXME remove once the atomic shim is gone\n-if [[ $(uname) == 'Darwin' ]]; then\n+if [[ \"$unamestr\" == 'Darwin' ]]; then\n    export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n fi\n \n-export LD_LIBRARY_PATH=\"$(rustc --print sysroot)/lib\"\n+export LD_LIBRARY_PATH=\"$(rustc --print sysroot)/lib:\"$dir\"/lib\"\n export DYLD_LIBRARY_PATH=$LD_LIBRARY_PATH\n-\n-export CG_CLIF_DISPLAY_CG_TIME=1"}, {"sha": "7971f620df14b36918ac37906419e9e87236808f", "filename": "scripts/ext_config.sh", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/scripts%2Fext_config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/scripts%2Fext_config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Fext_config.sh?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -0,0 +1,27 @@\n+# Note to people running shellcheck: this file should only be sourced, not executed directly.\n+\n+# Various env vars that should only be set for the build system but not for cargo.sh\n+\n+set -e\n+\n+export CG_CLIF_DISPLAY_CG_TIME=1\n+export CG_CLIF_INCR_CACHE_DISABLED=1\n+\n+export HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n+export TARGET_TRIPLE=${TARGET_TRIPLE:-$HOST_TRIPLE}\n+\n+export RUN_WRAPPER=''\n+export JIT_SUPPORTED=1\n+if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n+   export JIT_SUPPORTED=0\n+   if [[ \"$TARGET_TRIPLE\" == \"aarch64-unknown-linux-gnu\" ]]; then\n+      # We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n+      export RUSTFLAGS='-Clinker=aarch64-linux-gnu-gcc '$RUSTFLAGS\n+      export RUN_WRAPPER='qemu-aarch64 -L /usr/aarch64-linux-gnu'\n+   elif [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n+      # We are cross-compiling for Windows. Run tests in wine.\n+      export RUN_WRAPPER='wine'\n+   else\n+      echo \"Unknown non-native platform\"\n+   fi\n+fi"}, {"sha": "d37b57babe612ed3ec1c4d1c9d29823414b0e845", "filename": "scripts/tests.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/scripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/scripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftests.sh?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -3,7 +3,7 @@\n set -e\n \n source build/config.sh\n-export CG_CLIF_INCR_CACHE_DISABLED=1\n+source scripts/ext_config.sh\n MY_RUSTC=\"$RUSTC $RUSTFLAGS -L crate=target/out --out-dir target/out -Cdebuginfo=2\"\n \n function no_sysroot_tests() {"}, {"sha": "9aab45b62e2115f3cb6d4790ad333cc0a77d71a4", "filename": "src/abi/comments.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -4,10 +4,10 @@\n use std::borrow::Cow;\n \n use rustc_middle::mir;\n+use rustc_target::abi::call::PassMode;\n \n use cranelift_codegen::entity::EntityRef;\n \n-use crate::abi::pass_mode::*;\n use crate::prelude::*;\n \n pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n@@ -21,9 +21,9 @@ pub(super) fn add_arg_comment<'tcx>(\n     kind: &str,\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n-    params: EmptySinglePair<Value>,\n-    pass_mode: PassMode,\n-    ty: Ty<'tcx>,\n+    params: &[Value],\n+    arg_abi_mode: PassMode,\n+    arg_layout: TyAndLayout<'tcx>,\n ) {\n     let local = if let Some(local) = local {\n         Cow::Owned(format!(\"{:?}\", local))\n@@ -37,20 +37,28 @@ pub(super) fn add_arg_comment<'tcx>(\n     };\n \n     let params = match params {\n-        Empty => Cow::Borrowed(\"-\"),\n-        Single(param) => Cow::Owned(format!(\"= {:?}\", param)),\n-        Pair(param_a, param_b) => Cow::Owned(format!(\"= {:?}, {:?}\", param_a, param_b)),\n+        [] => Cow::Borrowed(\"-\"),\n+        [param] => Cow::Owned(format!(\"= {:?}\", param)),\n+        [param_a, param_b] => Cow::Owned(format!(\"= {:?},{:?}\", param_a, param_b)),\n+        params => Cow::Owned(format!(\n+            \"= {}\",\n+            params\n+                .iter()\n+                .map(ToString::to_string)\n+                .collect::<Vec<_>>()\n+                .join(\",\")\n+        )),\n     };\n \n-    let pass_mode = format!(\"{:?}\", pass_mode);\n+    let pass_mode = format!(\"{:?}\", arg_abi_mode);\n     fx.add_global_comment(format!(\n         \"{kind:5}{local:>3}{local_field:<5} {params:10} {pass_mode:36} {ty:?}\",\n         kind = kind,\n         local = local,\n         local_field = local_field,\n         params = params,\n         pass_mode = pass_mode,\n-        ty = ty,\n+        ty = arg_layout.ty,\n     ));\n }\n "}, {"sha": "6a025f2e88ae3f8b4c022663739fca48bcc9323b", "filename": "src/abi/mod.rs", "status": "modified", "additions": 136, "deletions": 261, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -6,199 +6,50 @@ mod pass_mode;\n mod returning;\n \n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::{Conv, FnAbi};\n use rustc_target::spec::abi::Abi;\n \n-use cranelift_codegen::ir::{AbiParam, ArgumentPurpose};\n+use cranelift_codegen::ir::AbiParam;\n+use smallvec::smallvec;\n \n use self::pass_mode::*;\n use crate::prelude::*;\n \n pub(crate) use self::returning::{can_return_to_ssa_var, codegen_return};\n \n-// Copied from https://github.com/rust-lang/rust/blob/f52c72948aa1dd718cc1f168d21c91c584c0a662/src/librustc_middle/ty/layout.rs#L2301\n-#[rustfmt::skip]\n-pub(crate) fn fn_sig_for_fn_abi<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty::PolyFnSig<'tcx> {\n-    use rustc_middle::ty::subst::Subst;\n-\n-    // FIXME(davidtwco,eddyb): A `ParamEnv` should be passed through to this function.\n-    let ty = instance.ty(tcx, ty::ParamEnv::reveal_all());\n-    match *ty.kind() {\n-        ty::FnDef(..) => {\n-            // HACK(davidtwco,eddyb): This is a workaround for polymorphization considering\n-            // parameters unused if they show up in the signature, but not in the `mir::Body`\n-            // (i.e. due to being inside a projection that got normalized, see\n-            // `src/test/ui/polymorphization/normalized_sig_types.rs`), and codegen not keeping\n-            // track of a polymorphization `ParamEnv` to allow normalizing later.\n-            let mut sig = match *ty.kind() {\n-                ty::FnDef(def_id, substs) => tcx\n-                    .normalize_erasing_regions(tcx.param_env(def_id), tcx.fn_sig(def_id))\n-                    .subst(tcx, substs),\n-                _ => unreachable!(),\n-            };\n-\n-            if let ty::InstanceDef::VtableShim(..) = instance.def {\n-                // Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.\n-                sig = sig.map_bound(|mut sig| {\n-                    let mut inputs_and_output = sig.inputs_and_output.to_vec();\n-                    inputs_and_output[0] = tcx.mk_mut_ptr(inputs_and_output[0]);\n-                    sig.inputs_and_output = tcx.intern_type_list(&inputs_and_output);\n-                    sig\n-                });\n-            }\n-            sig\n-        }\n-        ty::Closure(def_id, substs) => {\n-            let sig = substs.as_closure().sig();\n-\n-            let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-            sig.map_bound(|sig| {\n-                tcx.mk_fn_sig(\n-                    std::iter::once(env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n-                    sig.output(),\n-                    sig.c_variadic,\n-                    sig.unsafety,\n-                    sig.abi,\n-                )\n-            })\n-        }\n-        ty::Generator(_, substs, _) => {\n-            let sig = substs.as_generator().poly_sig();\n-\n-            let env_region = ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind: ty::BrEnv });\n-            let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n-\n-            let pin_did = tcx.require_lang_item(rustc_hir::LangItem::Pin, None);\n-            let pin_adt_ref = tcx.adt_def(pin_did);\n-            let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n-            let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n-\n-            sig.map_bound(|sig| {\n-                let state_did = tcx.require_lang_item(rustc_hir::LangItem::GeneratorState, None);\n-                let state_adt_ref = tcx.adt_def(state_did);\n-                let state_substs =\n-                    tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n-                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n-\n-                tcx.mk_fn_sig(\n-                    [env_ty, sig.resume_ty].iter(),\n-                    &ret_ty,\n-                    false,\n-                    rustc_hir::Unsafety::Normal,\n-                    rustc_target::spec::abi::Abi::Rust,\n-                )\n-            })\n-        }\n-        _ => bug!(\"unexpected type {:?} in Instance::fn_sig\", ty),\n-    }\n-}\n-\n-fn clif_sig_from_fn_sig<'tcx>(\n+fn clif_sig_from_fn_abi<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     triple: &target_lexicon::Triple,\n-    sig: FnSig<'tcx>,\n-    span: Span,\n-    is_vtable_fn: bool,\n-    requires_caller_location: bool,\n+    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n ) -> Signature {\n-    let abi = match sig.abi {\n-        Abi::System => Abi::C,\n-        abi => abi,\n-    };\n-    let (call_conv, inputs, output): (CallConv, Vec<Ty<'tcx>>, Ty<'tcx>) = match abi {\n-        Abi::Rust => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        Abi::C | Abi::Unadjusted => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        Abi::SysV64 => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n-        Abi::RustCall => {\n-            assert_eq!(sig.inputs().len(), 2);\n-            let extra_args = match sig.inputs().last().unwrap().kind() {\n-                ty::Tuple(ref tupled_arguments) => tupled_arguments,\n-                _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n-            };\n-            let mut inputs: Vec<Ty<'tcx>> = vec![sig.inputs()[0]];\n-            inputs.extend(extra_args.types());\n-            (CallConv::triple_default(triple), inputs, sig.output())\n+    let call_conv = match fn_abi.conv {\n+        Conv::Rust | Conv::C => CallConv::triple_default(triple),\n+        Conv::X86_64SysV => CallConv::SystemV,\n+        Conv::X86_64Win64 => CallConv::WindowsFastcall,\n+        Conv::ArmAapcs\n+        | Conv::Msp430Intr\n+        | Conv::PtxKernel\n+        | Conv::X86Fastcall\n+        | Conv::X86Intr\n+        | Conv::X86Stdcall\n+        | Conv::X86ThisCall\n+        | Conv::X86VectorCall\n+        | Conv::AmdGpuKernel\n+        | Conv::AvrInterrupt\n+        | Conv::AvrNonBlockingInterrupt => {\n+            todo!(\"{:?}\", fn_abi.conv)\n         }\n-        Abi::System => unreachable!(),\n-        Abi::RustIntrinsic => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        _ => unimplemented!(\"unsupported abi {:?}\", sig.abi),\n     };\n-\n-    let inputs = inputs\n-        .into_iter()\n-        .enumerate()\n-        .map(|(i, ty)| {\n-            let mut layout = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n-            if i == 0 && is_vtable_fn {\n-                // Virtual calls turn their self param into a thin pointer.\n-                // See https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src/librustc/ty/layout.rs#L2519-L2572 for more info\n-                layout = tcx\n-                    .layout_of(ParamEnv::reveal_all().and(tcx.mk_mut_ptr(tcx.mk_unit())))\n-                    .unwrap();\n-            }\n-            let pass_mode = get_pass_mode(tcx, layout);\n-            if abi != Abi::Rust && abi != Abi::RustCall && abi != Abi::RustIntrinsic {\n-                match pass_mode {\n-                    PassMode::NoPass | PassMode::ByVal(_) => {}\n-                    PassMode::ByRef { size: Some(size) } => {\n-                        let purpose = ArgumentPurpose::StructArgument(u32::try_from(size.bytes()).expect(\"struct too big to pass on stack\"));\n-                        return EmptySinglePair::Single(AbiParam::special(pointer_ty(tcx), purpose)).into_iter();\n-                    }\n-                    PassMode::ByValPair(_, _) | PassMode::ByRef { size: None } => {\n-                        tcx.sess.span_warn(\n-                            span,\n-                            &format!(\n-                                \"Argument of type `{:?}` with pass mode `{:?}` is not yet supported \\\n-                                for non-rust abi `{}`. Calling this function may result in a crash.\",\n-                                layout.ty,\n-                                pass_mode,\n-                                abi,\n-                            ),\n-                        );\n-                    }\n-                }\n-            }\n-            pass_mode.get_param_ty(tcx).map(AbiParam::new).into_iter()\n-        })\n+    let inputs = fn_abi\n+        .args\n+        .iter()\n+        .map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter())\n         .flatten();\n \n-    let (mut params, returns): (Vec<_>, Vec<_>) = match get_pass_mode(\n-        tcx,\n-        tcx.layout_of(ParamEnv::reveal_all().and(output)).unwrap(),\n-    ) {\n-        PassMode::NoPass => (inputs.collect(), vec![]),\n-        PassMode::ByVal(ret_ty) => (inputs.collect(), vec![AbiParam::new(ret_ty)]),\n-        PassMode::ByValPair(ret_ty_a, ret_ty_b) => (\n-            inputs.collect(),\n-            vec![AbiParam::new(ret_ty_a), AbiParam::new(ret_ty_b)],\n-        ),\n-        PassMode::ByRef { size: Some(_) } => {\n-            (\n-                Some(pointer_ty(tcx)) // First param is place to put return val\n-                    .into_iter()\n-                    .map(|ty| AbiParam::special(ty, ArgumentPurpose::StructReturn))\n-                    .chain(inputs)\n-                    .collect(),\n-                vec![],\n-            )\n-        }\n-        PassMode::ByRef { size: None } => todo!(),\n-    };\n-\n-    if requires_caller_location {\n-        params.push(AbiParam::new(pointer_ty(tcx)));\n-    }\n+    let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n+    // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n+    let params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n \n     Signature {\n         params,\n@@ -207,30 +58,17 @@ fn clif_sig_from_fn_sig<'tcx>(\n     }\n }\n \n-pub(crate) fn get_function_name_and_sig<'tcx>(\n+pub(crate) fn get_function_sig<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     triple: &target_lexicon::Triple,\n     inst: Instance<'tcx>,\n-    support_vararg: bool,\n-) -> (String, Signature) {\n+) -> Signature {\n     assert!(!inst.substs.needs_infer());\n-    let fn_sig = tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_sig_for_fn_abi(tcx, inst));\n-    if fn_sig.c_variadic && !support_vararg {\n-        tcx.sess.span_fatal(\n-            tcx.def_span(inst.def_id()),\n-            \"Variadic function definitions are not yet supported\",\n-        );\n-    }\n-    let sig = clif_sig_from_fn_sig(\n+    clif_sig_from_fn_abi(\n         tcx,\n         triple,\n-        fn_sig,\n-        tcx.def_span(inst.def_id()),\n-        false,\n-        inst.def.requires_caller_location(tcx),\n-    );\n-    (tcx.symbol_name(inst).name.to_string(), sig)\n+        &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]),\n+    )\n }\n \n /// Instance must be monomorphized\n@@ -239,7 +77,8 @@ pub(crate) fn import_function<'tcx>(\n     module: &mut impl Module,\n     inst: Instance<'tcx>,\n ) -> FuncId {\n-    let (name, sig) = get_function_name_and_sig(tcx, module.isa().triple(), inst, true);\n+    let name = tcx.symbol_name(inst).name.to_string();\n+    let sig = get_function_sig(tcx, module.isa().triple(), inst);\n     module\n         .declare_function(&name, Linkage::Import, &sig)\n         .unwrap()\n@@ -263,13 +102,13 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n     pub(crate) fn lib_call(\n         &mut self,\n         name: &str,\n-        input_tys: Vec<types::Type>,\n-        output_tys: Vec<types::Type>,\n+        params: Vec<AbiParam>,\n+        returns: Vec<AbiParam>,\n         args: &[Value],\n     ) -> &[Value] {\n         let sig = Signature {\n-            params: input_tys.iter().cloned().map(AbiParam::new).collect(),\n-            returns: output_tys.iter().cloned().map(AbiParam::new).collect(),\n+            params,\n+            returns,\n             call_conv: CallConv::triple_default(self.triple()),\n         };\n         let func_id = self\n@@ -301,16 +140,18 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n             .iter()\n             .map(|arg| {\n                 (\n-                    self.clif_type(arg.layout().ty).unwrap(),\n+                    AbiParam::new(self.clif_type(arg.layout().ty).unwrap()),\n                     arg.load_scalar(self),\n                 )\n             })\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n         let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.types().map(|ty| self.clif_type(ty).unwrap()).collect()\n+            tup.types()\n+                .map(|ty| AbiParam::new(self.clif_type(ty).unwrap()))\n+                .collect()\n         } else {\n-            vec![self.clif_type(return_ty).unwrap()]\n+            vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n         };\n         let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n         match *ret_vals {\n@@ -352,12 +193,25 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     start_block: Block,\n ) {\n+    fx.bcx.append_block_params_for_function_params(start_block);\n+\n+    fx.bcx.switch_to_block(start_block);\n+    fx.bcx.ins().nop();\n+\n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n     #[cfg(debug_assertions)]\n     self::comments::add_args_header_comment(fx);\n \n-    let ret_place = self::returning::codegen_return_param(fx, &ssa_analyzed, start_block);\n+    let mut block_params_iter = fx\n+        .bcx\n+        .func\n+        .dfg\n+        .block_params(start_block)\n+        .to_vec()\n+        .into_iter();\n+    let ret_place =\n+        self::returning::codegen_return_param(fx, &ssa_analyzed, &mut block_params_iter);\n     assert_eq!(fx.local_map.push(ret_place), RETURN_PLACE);\n \n     // None means pass_mode == NoPass\n@@ -366,6 +220,9 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n         Spread(Vec<Option<CValue<'tcx>>>),\n     }\n \n+    let fn_abi = fx.fn_abi.take().unwrap();\n+    let mut arg_abis_iter = fn_abi.args.iter();\n+\n     let func_params = fx\n         .mir\n         .args_iter()\n@@ -385,14 +242,18 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n                 };\n \n                 let mut params = Vec::new();\n-                for (i, arg_ty) in tupled_arg_tys.types().enumerate() {\n-                    let param = cvalue_for_param(fx, start_block, Some(local), Some(i), arg_ty);\n+                for (i, _arg_ty) in tupled_arg_tys.types().enumerate() {\n+                    let arg_abi = arg_abis_iter.next().unwrap();\n+                    let param =\n+                        cvalue_for_param(fx, Some(local), Some(i), arg_abi, &mut block_params_iter);\n                     params.push(param);\n                 }\n \n                 (local, ArgKind::Spread(params), arg_ty)\n             } else {\n-                let param = cvalue_for_param(fx, start_block, Some(local), None, arg_ty);\n+                let arg_abi = arg_abis_iter.next().unwrap();\n+                let param =\n+                    cvalue_for_param(fx, Some(local), None, arg_abi, &mut block_params_iter);\n                 (local, ArgKind::Normal(param), arg_ty)\n             }\n         })\n@@ -401,13 +262,14 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     assert!(fx.caller_location.is_none());\n     if fx.instance.def.requires_caller_location(fx.tcx) {\n         // Store caller location for `#[track_caller]`.\n-        fx.caller_location = Some(\n-            cvalue_for_param(fx, start_block, None, None, fx.tcx.caller_location_ty()).unwrap(),\n-        );\n+        let arg_abi = arg_abis_iter.next().unwrap();\n+        fx.caller_location =\n+            Some(cvalue_for_param(fx, None, None, arg_abi, &mut block_params_iter).unwrap());\n     }\n \n-    fx.bcx.switch_to_block(start_block);\n-    fx.bcx.ins().nop();\n+    assert!(arg_abis_iter.next().is_none(), \"ArgAbi left behind\");\n+    fx.fn_abi = Some(fn_abi);\n+    assert!(block_params_iter.next().is_none(), \"arg_value left behind\");\n \n     #[cfg(debug_assertions)]\n     self::comments::add_locals_header_comment(fx);\n@@ -533,6 +395,21 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         None\n     };\n \n+    let extra_args = &args[fn_sig.inputs().len()..];\n+    let extra_args = extra_args\n+        .iter()\n+        .map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx)))\n+        .collect::<Vec<_>>();\n+    let fn_abi = if let Some(instance) = instance {\n+        FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n+    } else {\n+        FnAbi::of_fn_ptr(\n+            &RevealAllLayoutCx(fx.tcx),\n+            fn_ty.fn_sig(fx.tcx),\n+            &extra_args,\n+        )\n+    };\n+\n     let is_cold = instance\n         .map(|inst| {\n             fx.tcx\n@@ -570,8 +447,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n     //   | indirect call target\n     //   |         | the first argument to be passed\n-    //   v         v          v virtual calls are special cased below\n-    let (func_ref, first_arg, is_virtual_call) = match instance {\n+    //   v         v\n+    let (func_ref, first_arg) = match instance {\n         // Trait object call\n         Some(Instance {\n             def: InstanceDef::Virtual(_, idx),\n@@ -582,23 +459,19 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(\n                     nop_inst,\n-                    format!(\n-                        \"virtual call; self arg pass mode: {:?}\",\n-                        get_pass_mode(fx.tcx, args[0].layout())\n-                    ),\n+                    format!(\"virtual call; self arg pass mode: {:?}\", &fn_abi.args[0],),\n                 );\n             }\n             let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0], idx);\n-            (Some(method), Single(ptr), true)\n+            (Some(method), smallvec![ptr])\n         }\n \n         // Normal call\n         Some(_) => (\n             None,\n             args.get(0)\n-                .map(|arg| adjust_arg_for_abi(fx, *arg))\n-                .unwrap_or(Empty),\n-            false,\n+                .map(|arg| adjust_arg_for_abi(fx, *arg, &fn_abi.args[0]))\n+                .unwrap_or(smallvec![]),\n         ),\n \n         // Indirect call\n@@ -612,23 +485,27 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             (\n                 Some(func),\n                 args.get(0)\n-                    .map(|arg| adjust_arg_for_abi(fx, *arg))\n-                    .unwrap_or(Empty),\n-                false,\n+                    .map(|arg| adjust_arg_for_abi(fx, *arg, &fn_abi.args[0]))\n+                    .unwrap_or(smallvec![]),\n             )\n         }\n     };\n \n     let ret_place = destination.map(|(place, _)| place);\n-    let (call_inst, call_args) =\n-        self::returning::codegen_with_call_return_arg(fx, fn_sig, ret_place, |fx, return_ptr| {\n+    let (call_inst, call_args) = self::returning::codegen_with_call_return_arg(\n+        fx,\n+        &fn_abi.ret,\n+        ret_place,\n+        |fx, return_ptr| {\n+            let regular_args_count = args.len();\n             let mut call_args: Vec<Value> = return_ptr\n                 .into_iter()\n                 .chain(first_arg.into_iter())\n                 .chain(\n                     args.into_iter()\n+                        .enumerate()\n                         .skip(1)\n-                        .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n+                        .map(|(i, arg)| adjust_arg_for_abi(fx, arg, &fn_abi.args[i]).into_iter())\n                         .flatten(),\n                 )\n                 .collect::<Vec<_>>();\n@@ -639,18 +516,17 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             {\n                 // Pass the caller location for `#[track_caller]`.\n                 let caller_location = fx.get_caller_location(span);\n-                call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n+                call_args.extend(\n+                    adjust_arg_for_abi(fx, caller_location, &fn_abi.args[regular_args_count])\n+                        .into_iter(),\n+                );\n+                assert_eq!(fn_abi.args.len(), regular_args_count + 1);\n+            } else {\n+                assert_eq!(fn_abi.args.len(), regular_args_count);\n             }\n \n             let call_inst = if let Some(func_ref) = func_ref {\n-                let sig = clif_sig_from_fn_sig(\n-                    fx.tcx,\n-                    fx.triple(),\n-                    fn_sig,\n-                    span,\n-                    is_virtual_call,\n-                    false, // calls through function pointers never pass the caller location\n-                );\n+                let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n                 let sig = fx.bcx.import_signature(sig);\n                 fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n             } else {\n@@ -660,7 +536,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             };\n \n             (call_inst, call_args)\n-        });\n+        },\n+    );\n \n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n@@ -701,37 +578,33 @@ pub(crate) fn codegen_drop<'tcx>(\n     drop_place: CPlace<'tcx>,\n ) {\n     let ty = drop_place.layout().ty;\n-    let drop_fn = Instance::resolve_drop_in_place(fx.tcx, ty).polymorphize(fx.tcx);\n+    let drop_instance = Instance::resolve_drop_in_place(fx.tcx, ty).polymorphize(fx.tcx);\n \n-    if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n+    if let ty::InstanceDef::DropGlue(_, None) = drop_instance.def {\n         // we don't actually need to drop anything\n     } else {\n-        let drop_fn_ty = drop_fn.ty(fx.tcx, ParamEnv::reveal_all());\n-        let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-            ParamEnv::reveal_all(),\n-            drop_fn_ty.fn_sig(fx.tcx),\n-        );\n-        assert_eq!(fn_sig.output(), fx.tcx.mk_unit());\n-\n         match ty.kind() {\n             ty::Dynamic(..) => {\n                 let (ptr, vtable) = drop_place.to_ptr_maybe_unsized();\n                 let ptr = ptr.get_addr(fx);\n                 let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n \n-                let sig = clif_sig_from_fn_sig(\n-                    fx.tcx,\n-                    fx.triple(),\n-                    fn_sig,\n-                    span,\n-                    true,\n-                    false, // `drop_in_place` is never `#[track_caller]`\n-                );\n+                // FIXME(eddyb) perhaps move some of this logic into\n+                // `Instance::resolve_drop_in_place`?\n+                let virtual_drop = Instance {\n+                    def: ty::InstanceDef::Virtual(drop_instance.def_id(), 0),\n+                    substs: drop_instance.substs,\n+                };\n+                let fn_abi = FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), virtual_drop, &[]);\n+\n+                let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n                 let sig = fx.bcx.import_signature(sig);\n                 fx.bcx.ins().call_indirect(sig, drop_fn, &[ptr]);\n             }\n             _ => {\n-                assert!(!matches!(drop_fn.def, InstanceDef::Virtual(_, _)));\n+                assert!(!matches!(drop_instance.def, InstanceDef::Virtual(_, _)));\n+\n+                let fn_abi = FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), drop_instance, &[]);\n \n                 let arg_value = drop_place.place_ref(\n                     fx,\n@@ -743,17 +616,19 @@ pub(crate) fn codegen_drop<'tcx>(\n                         },\n                     )),\n                 );\n-                let arg_value = adjust_arg_for_abi(fx, arg_value);\n+                let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0]);\n \n                 let mut call_args: Vec<Value> = arg_value.into_iter().collect::<Vec<_>>();\n \n-                if drop_fn.def.requires_caller_location(fx.tcx) {\n+                if drop_instance.def.requires_caller_location(fx.tcx) {\n                     // Pass the caller location for `#[track_caller]`.\n                     let caller_location = fx.get_caller_location(span);\n-                    call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n+                    call_args.extend(\n+                        adjust_arg_for_abi(fx, caller_location, &fn_abi.args[1]).into_iter(),\n+                    );\n                 }\n \n-                let func_ref = fx.get_function_ref(drop_fn);\n+                let func_ref = fx.get_function_ref(drop_instance);\n                 fx.bcx.ins().call(func_ref, &call_args);\n             }\n         }"}, {"sha": "1202c23dbe7b3ba77bb3da86b85bbf0976960c14", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 294, "deletions": 127, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -1,140 +1,281 @@\n //! Argument passing\n \n use crate::prelude::*;\n+use crate::value_and_place::assert_assignable;\n \n-pub(super) use EmptySinglePair::*;\n+use cranelift_codegen::ir::{ArgumentExtension, ArgumentPurpose};\n+use rustc_target::abi::call::{\n+    ArgAbi, ArgAttributes, ArgExtension as RustcArgExtension, CastTarget, PassMode, Reg, RegKind,\n+};\n+use smallvec::{smallvec, SmallVec};\n \n-#[derive(Copy, Clone, Debug)]\n-pub(super) enum PassMode {\n-    NoPass,\n-    ByVal(Type),\n-    ByValPair(Type, Type),\n-    ByRef { size: Option<Size> },\n+pub(super) trait ArgAbiExt<'tcx> {\n+    fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> SmallVec<[AbiParam; 2]>;\n+    fn get_abi_return(&self, tcx: TyCtxt<'tcx>) -> (Option<AbiParam>, Vec<AbiParam>);\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub(super) enum EmptySinglePair<T> {\n-    Empty,\n-    Single(T),\n-    Pair(T, T),\n+fn reg_to_abi_param(reg: Reg) -> AbiParam {\n+    let clif_ty = match (reg.kind, reg.size.bytes()) {\n+        (RegKind::Integer, 1) => types::I8,\n+        (RegKind::Integer, 2) => types::I16,\n+        (RegKind::Integer, 4) => types::I32,\n+        (RegKind::Integer, 8) => types::I64,\n+        (RegKind::Integer, 16) => types::I128,\n+        (RegKind::Float, 4) => types::F32,\n+        (RegKind::Float, 8) => types::F64,\n+        (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n+        _ => unreachable!(\"{:?}\", reg),\n+    };\n+    AbiParam::new(clif_ty)\n }\n \n-impl<T> EmptySinglePair<T> {\n-    pub(super) fn into_iter(self) -> EmptySinglePairIter<T> {\n-        EmptySinglePairIter(self)\n-    }\n-\n-    pub(super) fn map<U>(self, mut f: impl FnMut(T) -> U) -> EmptySinglePair<U> {\n-        match self {\n-            Empty => Empty,\n-            Single(v) => Single(f(v)),\n-            Pair(a, b) => Pair(f(a), f(b)),\n-        }\n+fn apply_arg_attrs_to_abi_param(mut param: AbiParam, arg_attrs: ArgAttributes) -> AbiParam {\n+    match arg_attrs.arg_ext {\n+        RustcArgExtension::None => {}\n+        RustcArgExtension::Zext => param.extension = ArgumentExtension::Uext,\n+        RustcArgExtension::Sext => param.extension = ArgumentExtension::Sext,\n     }\n+    param\n }\n \n-pub(super) struct EmptySinglePairIter<T>(EmptySinglePair<T>);\n-\n-impl<T> Iterator for EmptySinglePairIter<T> {\n-    type Item = T;\n+fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n+    let (rest_count, rem_bytes) = if cast.rest.unit.size.bytes() == 0 {\n+        (0, 0)\n+    } else {\n+        (\n+            cast.rest.total.bytes() / cast.rest.unit.size.bytes(),\n+            cast.rest.total.bytes() % cast.rest.unit.size.bytes(),\n+        )\n+    };\n \n-    fn next(&mut self) -> Option<T> {\n-        match std::mem::replace(&mut self.0, Empty) {\n-            Empty => None,\n-            Single(v) => Some(v),\n-            Pair(a, b) => {\n-                self.0 = Single(b);\n-                Some(a)\n-            }\n+    if cast.prefix.iter().all(|x| x.is_none()) {\n+        // Simplify to a single unit when there is no prefix and size <= unit size\n+        if cast.rest.total <= cast.rest.unit.size {\n+            let clif_ty = match (cast.rest.unit.kind, cast.rest.unit.size.bytes()) {\n+                (RegKind::Integer, 1) => types::I8,\n+                (RegKind::Integer, 2) => types::I16,\n+                (RegKind::Integer, 3..=4) => types::I32,\n+                (RegKind::Integer, 5..=8) => types::I64,\n+                (RegKind::Integer, 9..=16) => types::I128,\n+                (RegKind::Float, 4) => types::F32,\n+                (RegKind::Float, 8) => types::F64,\n+                (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n+                _ => unreachable!(\"{:?}\", cast.rest.unit),\n+            };\n+            return smallvec![AbiParam::new(clif_ty)];\n         }\n     }\n-}\n \n-impl<T: std::fmt::Debug> EmptySinglePair<T> {\n-    pub(super) fn assert_single(self) -> T {\n-        match self {\n-            Single(v) => v,\n-            _ => panic!(\"Called assert_single on {:?}\", self),\n-        }\n-    }\n+    // Create list of fields in the main structure\n+    let mut args = cast\n+        .prefix\n+        .iter()\n+        .flatten()\n+        .map(|&kind| {\n+            reg_to_abi_param(Reg {\n+                kind,\n+                size: cast.prefix_chunk_size,\n+            })\n+        })\n+        .chain((0..rest_count).map(|_| reg_to_abi_param(cast.rest.unit)))\n+        .collect::<SmallVec<_>>();\n \n-    pub(super) fn assert_pair(self) -> (T, T) {\n-        match self {\n-            Pair(a, b) => (a, b),\n-            _ => panic!(\"Called assert_pair on {:?}\", self),\n-        }\n+    // Append final integer\n+    if rem_bytes != 0 {\n+        // Only integers can be really split further.\n+        assert_eq!(cast.rest.unit.kind, RegKind::Integer);\n+        args.push(reg_to_abi_param(Reg {\n+            kind: RegKind::Integer,\n+            size: Size::from_bytes(rem_bytes),\n+        }));\n     }\n-}\n \n-impl PassMode {\n-    pub(super) fn get_param_ty(self, tcx: TyCtxt<'_>) -> EmptySinglePair<Type> {\n-        match self {\n-            PassMode::NoPass => Empty,\n-            PassMode::ByVal(clif_type) => Single(clif_type),\n-            PassMode::ByValPair(a, b) => Pair(a, b),\n-            PassMode::ByRef { size: Some(_) } => Single(pointer_ty(tcx)),\n-            PassMode::ByRef { size: None } => Pair(pointer_ty(tcx), pointer_ty(tcx)),\n-        }\n-    }\n+    args\n }\n \n-pub(super) fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> PassMode {\n-    if layout.is_zst() {\n-        // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n-        PassMode::NoPass\n-    } else {\n-        match &layout.abi {\n-            Abi::Uninhabited => PassMode::NoPass,\n-            Abi::Scalar(scalar) => PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone())),\n-            Abi::ScalarPair(a, b) => {\n-                let a = scalar_to_clif_type(tcx, a.clone());\n-                let b = scalar_to_clif_type(tcx, b.clone());\n-                if a == types::I128 && b == types::I128 {\n-                    // Returning (i128, i128) by-val-pair would take 4 regs, while only 3 are\n-                    // available on x86_64. Cranelift gets confused when too many return params\n-                    // are used.\n-                    PassMode::ByRef {\n-                        size: Some(layout.size),\n-                    }\n-                } else {\n-                    PassMode::ByValPair(a, b)\n+impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n+    fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> SmallVec<[AbiParam; 2]> {\n+        match self.mode {\n+            PassMode::Ignore => smallvec![],\n+            PassMode::Direct(attrs) => match &self.layout.abi {\n+                Abi::Scalar(scalar) => {\n+                    smallvec![apply_arg_attrs_to_abi_param(\n+                        AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())),\n+                        attrs\n+                    )]\n                 }\n-            }\n-\n-            // FIXME implement Vector Abi in a cg_llvm compatible way\n-            Abi::Vector { .. } => {\n-                if let Some(vector_ty) = crate::intrinsics::clif_vector_type(tcx, layout) {\n-                    PassMode::ByVal(vector_ty)\n+                Abi::Vector { .. } => {\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    smallvec![AbiParam::new(vector_ty)]\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            PassMode::Pair(attrs_a, attrs_b) => match &self.layout.abi {\n+                Abi::ScalarPair(a, b) => {\n+                    let a = scalar_to_clif_type(tcx, a.clone());\n+                    let b = scalar_to_clif_type(tcx, b.clone());\n+                    smallvec![\n+                        apply_arg_attrs_to_abi_param(AbiParam::new(a), attrs_a),\n+                        apply_arg_attrs_to_abi_param(AbiParam::new(b), attrs_b),\n+                    ]\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n+            PassMode::Indirect {\n+                attrs,\n+                extra_attrs: None,\n+                on_stack,\n+            } => {\n+                if on_stack {\n+                    let size = u32::try_from(self.layout.size.bytes()).unwrap();\n+                    smallvec![apply_arg_attrs_to_abi_param(\n+                        AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructArgument(size),),\n+                        attrs\n+                    )]\n                 } else {\n-                    PassMode::ByRef {\n-                        size: Some(layout.size),\n-                    }\n+                    smallvec![apply_arg_attrs_to_abi_param(\n+                        AbiParam::new(pointer_ty(tcx)),\n+                        attrs\n+                    )]\n                 }\n             }\n+            PassMode::Indirect {\n+                attrs,\n+                extra_attrs: Some(extra_attrs),\n+                on_stack,\n+            } => {\n+                assert!(!on_stack);\n+                smallvec![\n+                    apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), attrs),\n+                    apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), extra_attrs),\n+                ]\n+            }\n+        }\n+    }\n \n-            Abi::Aggregate { sized: true } => PassMode::ByRef {\n-                size: Some(layout.size),\n+    fn get_abi_return(&self, tcx: TyCtxt<'tcx>) -> (Option<AbiParam>, Vec<AbiParam>) {\n+        match self.mode {\n+            PassMode::Ignore => (None, vec![]),\n+            PassMode::Direct(_) => match &self.layout.abi {\n+                Abi::Scalar(scalar) => (\n+                    None,\n+                    vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))],\n+                ),\n+                Abi::Vector { .. } => {\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    (None, vec![AbiParam::new(vector_ty)])\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            PassMode::Pair(_, _) => match &self.layout.abi {\n+                Abi::ScalarPair(a, b) => {\n+                    let a = scalar_to_clif_type(tcx, a.clone());\n+                    let b = scalar_to_clif_type(tcx, b.clone());\n+                    (None, vec![AbiParam::new(a), AbiParam::new(b)])\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            Abi::Aggregate { sized: false } => PassMode::ByRef { size: None },\n+            PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n+            PassMode::Indirect {\n+                attrs: _,\n+                extra_attrs: None,\n+                on_stack,\n+            } => {\n+                assert!(!on_stack);\n+                (\n+                    Some(AbiParam::special(\n+                        pointer_ty(tcx),\n+                        ArgumentPurpose::StructReturn,\n+                    )),\n+                    vec![],\n+                )\n+            }\n+            PassMode::Indirect {\n+                attrs: _,\n+                extra_attrs: Some(_),\n+                on_stack: _,\n+            } => unreachable!(\"unsized return value\"),\n         }\n     }\n }\n \n+pub(super) fn to_casted_value<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    arg: CValue<'tcx>,\n+    cast: CastTarget,\n+) -> SmallVec<[Value; 2]> {\n+    let (ptr, meta) = arg.force_stack(fx);\n+    assert!(meta.is_none());\n+    let mut offset = 0;\n+    cast_target_to_abi_params(cast)\n+        .into_iter()\n+        .map(|param| {\n+            let val = ptr\n+                .offset_i64(fx, offset)\n+                .load(fx, param.value_type, MemFlags::new());\n+            offset += i64::from(param.value_type.bytes());\n+            val\n+        })\n+        .collect()\n+}\n+\n+pub(super) fn from_casted_value<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    block_params: &[Value],\n+    layout: TyAndLayout<'tcx>,\n+    cast: CastTarget,\n+) -> CValue<'tcx> {\n+    let abi_params = cast_target_to_abi_params(cast);\n+    let abi_param_size: u32 = abi_params\n+        .iter()\n+        .map(|param| param.value_type.bytes())\n+        .sum();\n+    let layout_size = u32::try_from(layout.size.bytes()).unwrap();\n+    let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+        kind: StackSlotKind::ExplicitSlot,\n+        // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n+        // specify stack slot alignment.\n+        // Stack slot size may be bigger for for example `[u8; 3]` which is packed into an `i32`.\n+        // It may also be smaller for example when the type is a wrapper around an integer with a\n+        // larger alignment than the integer.\n+        size: (std::cmp::max(abi_param_size, layout_size) + 15) / 16 * 16,\n+        offset: None,\n+    });\n+    let ptr = Pointer::new(fx.bcx.ins().stack_addr(pointer_ty(fx.tcx), stack_slot, 0));\n+    let mut offset = 0;\n+    let mut block_params_iter = block_params.into_iter().copied();\n+    for param in abi_params {\n+        let val = ptr.offset_i64(fx, offset).store(\n+            fx,\n+            block_params_iter.next().unwrap(),\n+            MemFlags::new(),\n+        );\n+        offset += i64::from(param.value_type.bytes());\n+        val\n+    }\n+    assert_eq!(block_params_iter.next(), None, \"Leftover block param\");\n+    CValue::by_ref(ptr, layout)\n+}\n+\n /// Get a set of values to be passed as function arguments.\n pub(super) fn adjust_arg_for_abi<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     arg: CValue<'tcx>,\n-) -> EmptySinglePair<Value> {\n-    match get_pass_mode(fx.tcx, arg.layout()) {\n-        PassMode::NoPass => Empty,\n-        PassMode::ByVal(_) => Single(arg.load_scalar(fx)),\n-        PassMode::ByValPair(_, _) => {\n+    arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+) -> SmallVec<[Value; 2]> {\n+    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty);\n+    match arg_abi.mode {\n+        PassMode::Ignore => smallvec![],\n+        PassMode::Direct(_) => smallvec![arg.load_scalar(fx)],\n+        PassMode::Pair(_, _) => {\n             let (a, b) = arg.load_scalar_pair(fx);\n-            Pair(a, b)\n+            smallvec![a, b]\n         }\n-        PassMode::ByRef { size: _ } => match arg.force_stack(fx) {\n-            (ptr, None) => Single(ptr.get_addr(fx)),\n-            (ptr, Some(meta)) => Pair(ptr.get_addr(fx), meta),\n+        PassMode::Cast(cast) => to_casted_value(fx, arg, cast),\n+        PassMode::Indirect { .. } => match arg.force_stack(fx) {\n+            (ptr, None) => smallvec![ptr.get_addr(fx)],\n+            (ptr, Some(meta)) => smallvec![ptr.get_addr(fx), meta],\n         },\n     }\n }\n@@ -143,46 +284,72 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n /// as necessary.\n pub(super) fn cvalue_for_param<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    start_block: Block,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n-    arg_ty: Ty<'tcx>,\n+    arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+    block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> Option<CValue<'tcx>> {\n-    let layout = fx.layout_of(arg_ty);\n-    let pass_mode = get_pass_mode(fx.tcx, layout);\n-\n-    if let PassMode::NoPass = pass_mode {\n-        return None;\n-    }\n-\n-    let clif_types = pass_mode.get_param_ty(fx.tcx);\n-    let block_params = clif_types.map(|t| fx.bcx.append_block_param(start_block, t));\n+    let block_params = arg_abi\n+        .get_abi_param(fx.tcx)\n+        .into_iter()\n+        .map(|abi_param| {\n+            let block_param = block_params_iter.next().unwrap();\n+            assert_eq!(\n+                fx.bcx.func.dfg.value_type(block_param),\n+                abi_param.value_type\n+            );\n+            block_param\n+        })\n+        .collect::<SmallVec<[_; 2]>>();\n \n     #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n         fx,\n         \"arg\",\n         local,\n         local_field,\n-        block_params,\n-        pass_mode,\n-        arg_ty,\n+        &block_params,\n+        arg_abi.mode,\n+        arg_abi.layout,\n     );\n \n-    match pass_mode {\n-        PassMode::NoPass => unreachable!(),\n-        PassMode::ByVal(_) => Some(CValue::by_val(block_params.assert_single(), layout)),\n-        PassMode::ByValPair(_, _) => {\n-            let (a, b) = block_params.assert_pair();\n-            Some(CValue::by_val_pair(a, b, layout))\n+    match arg_abi.mode {\n+        PassMode::Ignore => None,\n+        PassMode::Direct(_) => {\n+            assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n+            Some(CValue::by_val(block_params[0], arg_abi.layout))\n+        }\n+        PassMode::Pair(_, _) => {\n+            assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n+            Some(CValue::by_val_pair(\n+                block_params[0],\n+                block_params[1],\n+                arg_abi.layout,\n+            ))\n+        }\n+        PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {\n+            assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n+            Some(CValue::by_ref(\n+                Pointer::new(block_params[0]),\n+                arg_abi.layout,\n+            ))\n         }\n-        PassMode::ByRef { size: Some(_) } => Some(CValue::by_ref(\n-            Pointer::new(block_params.assert_single()),\n-            layout,\n-        )),\n-        PassMode::ByRef { size: None } => {\n-            let (ptr, meta) = block_params.assert_pair();\n-            Some(CValue::by_ref_unsized(Pointer::new(ptr), meta, layout))\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => {\n+            assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n+            Some(CValue::by_ref_unsized(\n+                Pointer::new(block_params[0]),\n+                block_params[1],\n+                arg_abi.layout,\n+            ))\n         }\n     }\n }"}, {"sha": "a382963bf1ed743b0963690b2fb3800c3da3ef40", "filename": "src/abi/returning.rs", "status": "modified", "additions": 146, "deletions": 48, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -1,21 +1,57 @@\n //! Return value handling\n \n-use crate::abi::pass_mode::*;\n use crate::prelude::*;\n \n-fn return_layout<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx, impl Module>) -> TyAndLayout<'tcx> {\n-    fx.layout_of(fx.monomorphize(&fx.mir.local_decls[RETURN_PLACE].ty))\n-}\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n+use smallvec::{smallvec, SmallVec};\n \n /// Can the given type be returned into an ssa var or does it need to be returned on the stack.\n pub(crate) fn can_return_to_ssa_var<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    dest_layout: TyAndLayout<'tcx>,\n+    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    func: &mir::Operand<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n ) -> bool {\n-    match get_pass_mode(tcx, dest_layout) {\n-        PassMode::NoPass | PassMode::ByVal(_) | PassMode::ByValPair(_, _) => true,\n-        // FIXME Make it possible to return ByRef to an ssa var.\n-        PassMode::ByRef { size: _ } => false,\n+    let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n+    let fn_sig = fx\n+        .tcx\n+        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+\n+    // Handle special calls like instrinsics and empty drop glue.\n+    let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n+        let instance = ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n+            .unwrap()\n+            .unwrap()\n+            .polymorphize(fx.tcx);\n+\n+        match instance.def {\n+            InstanceDef::Intrinsic(_) | InstanceDef::DropGlue(_, _) => {\n+                return true;\n+            }\n+            _ => Some(instance),\n+        }\n+    } else {\n+        None\n+    };\n+\n+    let extra_args = &args[fn_sig.inputs().len()..];\n+    let extra_args = extra_args\n+        .iter()\n+        .map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx)))\n+        .collect::<Vec<_>>();\n+    let fn_abi = if let Some(instance) = instance {\n+        FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n+    } else {\n+        FnAbi::of_fn_ptr(\n+            &RevealAllLayoutCx(fx.tcx),\n+            fn_ty.fn_sig(fx.tcx),\n+            &extra_args,\n+        )\n+    };\n+    match fn_abi.ret.mode {\n+        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) => true,\n+        // FIXME Make it possible to return Cast and Indirect to an ssa var.\n+        PassMode::Cast(_) | PassMode::Indirect { .. } => false,\n     }\n }\n \n@@ -24,27 +60,45 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n pub(super) fn codegen_return_param<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     ssa_analyzed: &rustc_index::vec::IndexVec<Local, crate::analyze::SsaKind>,\n-    start_block: Block,\n+    block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n-    let ret_layout = return_layout(fx);\n-    let ret_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n-    let (ret_place, ret_param) = match ret_pass_mode {\n-        PassMode::NoPass => (CPlace::no_place(ret_layout), Empty),\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => {\n+    let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n+        PassMode::Ignore => (\n+            CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout),\n+            smallvec![],\n+        ),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n-                super::make_local_place(fx, RETURN_PLACE, ret_layout, is_ssa),\n-                Empty,\n+                super::make_local_place(\n+                    fx,\n+                    RETURN_PLACE,\n+                    fx.fn_abi.as_ref().unwrap().ret.layout,\n+                    is_ssa,\n+                ),\n+                smallvec![],\n             )\n         }\n-        PassMode::ByRef { size: Some(_) } => {\n-            let ret_param = fx.bcx.append_block_param(start_block, fx.pointer_type);\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {\n+            let ret_param = block_params_iter.next().unwrap();\n+            assert_eq!(fx.bcx.func.dfg.value_type(ret_param), pointer_ty(fx.tcx));\n             (\n-                CPlace::for_ptr(Pointer::new(ret_param), ret_layout),\n-                Single(ret_param),\n+                CPlace::for_ptr(\n+                    Pointer::new(ret_param),\n+                    fx.fn_abi.as_ref().unwrap().ret.layout,\n+                ),\n+                smallvec![ret_param],\n             )\n         }\n-        PassMode::ByRef { size: None } => todo!(),\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n     };\n \n     #[cfg(not(debug_assertions))]\n@@ -56,9 +110,9 @@ pub(super) fn codegen_return_param<'tcx>(\n         \"ret\",\n         Some(RETURN_PLACE),\n         None,\n-        ret_param,\n-        ret_pass_mode,\n-        ret_layout.ty,\n+        &ret_param,\n+        fx.fn_abi.as_ref().unwrap().ret.mode,\n+        fx.fn_abi.as_ref().unwrap().ret.layout,\n     );\n \n     ret_place\n@@ -68,63 +122,107 @@ pub(super) fn codegen_return_param<'tcx>(\n /// returns the call return value(s) if any are written to the correct place.\n pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n     fx: &mut FunctionCx<'_, 'tcx, M>,\n-    fn_sig: FnSig<'tcx>,\n+    ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n     f: impl FnOnce(&mut FunctionCx<'_, 'tcx, M>, Option<Value>) -> (Inst, T),\n ) -> (Inst, T) {\n-    let ret_layout = fx.layout_of(fn_sig.output());\n-\n-    let output_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n-    let return_ptr = match output_pass_mode {\n-        PassMode::NoPass => None,\n-        PassMode::ByRef { size: Some(_) } => match ret_place {\n+    let return_ptr = match ret_arg_abi.mode {\n+        PassMode::Ignore => None,\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => match ret_place {\n             Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n         },\n-        PassMode::ByRef { size: None } => todo!(),\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => None,\n     };\n \n     let (call_inst, meta) = f(fx, return_ptr);\n \n-    match output_pass_mode {\n-        PassMode::NoPass => {}\n-        PassMode::ByVal(_) => {\n+    match ret_arg_abi.mode {\n+        PassMode::Ignore => {}\n+        PassMode::Direct(_) => {\n             if let Some(ret_place) = ret_place {\n                 let ret_val = fx.bcx.inst_results(call_inst)[0];\n-                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_layout));\n+                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_arg_abi.layout));\n             }\n         }\n-        PassMode::ByValPair(_, _) => {\n+        PassMode::Pair(_, _) => {\n             if let Some(ret_place) = ret_place {\n                 let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n                 let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n-                ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n+                ret_place.write_cvalue(\n+                    fx,\n+                    CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout),\n+                );\n             }\n         }\n-        PassMode::ByRef { size: Some(_) } => {}\n-        PassMode::ByRef { size: None } => todo!(),\n+        PassMode::Cast(cast) => {\n+            if let Some(ret_place) = ret_place {\n+                let results = fx\n+                    .bcx\n+                    .inst_results(call_inst)\n+                    .into_iter()\n+                    .copied()\n+                    .collect::<SmallVec<[Value; 2]>>();\n+                let result =\n+                    super::pass_mode::from_casted_value(fx, &results, ret_place.layout(), cast);\n+                ret_place.write_cvalue(fx, result);\n+            }\n+        }\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {}\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n     }\n \n     (call_inst, meta)\n }\n \n /// Codegen a return instruction with the right return value(s) if any.\n pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    match get_pass_mode(fx.tcx, return_layout(fx)) {\n-        PassMode::NoPass | PassMode::ByRef { size: Some(_) } => {\n+    match fx.fn_abi.as_ref().unwrap().ret.mode {\n+        PassMode::Ignore\n+        | PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {\n             fx.bcx.ins().return_(&[]);\n         }\n-        PassMode::ByRef { size: None } => todo!(),\n-        PassMode::ByVal(_) => {\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n+        PassMode::Direct(_) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx).load_scalar(fx);\n             fx.bcx.ins().return_(&[ret_val]);\n         }\n-        PassMode::ByValPair(_, _) => {\n+        PassMode::Pair(_, _) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n         }\n+        PassMode::Cast(cast) => {\n+            let place = fx.get_local_place(RETURN_PLACE);\n+            let ret_val = place.to_cvalue(fx);\n+            let ret_vals = super::pass_mode::to_casted_value(fx, ret_val, cast);\n+            fx.bcx.ins().return_(&ret_vals);\n+        }\n     }\n }"}, {"sha": "62fbcfe3f7a5df6bda3f4c7b4093b6aa4ba875e7", "filename": "src/analyze.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -40,11 +40,14 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, S\n         }\n \n         match &bb.terminator().kind {\n-            TerminatorKind::Call { destination, .. } => {\n+            TerminatorKind::Call {\n+                destination,\n+                func,\n+                args,\n+                ..\n+            } => {\n                 if let Some((dest_place, _dest_bb)) = destination {\n-                    let dest_layout = fx\n-                        .layout_of(fx.monomorphize(&dest_place.ty(&fx.mir.local_decls, fx.tcx).ty));\n-                    if !crate::abi::can_return_to_ssa_var(fx.tcx, dest_layout) {\n+                    if !crate::abi::can_return_to_ssa_var(fx, func, args) {\n                         not_ssa(&mut flag_map, dest_place.local)\n                     }\n                 }"}, {"sha": "4842628a99da7d391cc6371617961290705180f2", "filename": "src/base.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -2,6 +2,8 @@\n \n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::FnAbi;\n \n use crate::prelude::*;\n \n@@ -19,7 +21,8 @@ pub(crate) fn codegen_fn<'tcx>(\n     let mir = tcx.instance_mir(instance.def);\n \n     // Declare function\n-    let (name, sig) = get_function_name_and_sig(tcx, cx.module.isa().triple(), instance, false);\n+    let name = tcx.symbol_name(instance).name.to_string();\n+    let sig = get_function_sig(tcx, cx.module.isa().triple(), instance);\n     let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n \n     cx.cached_context.clear();\n@@ -50,6 +53,7 @@ pub(crate) fn codegen_fn<'tcx>(\n \n         instance,\n         mir,\n+        fn_abi: Some(FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n \n         bcx,\n         block_map,\n@@ -117,6 +121,9 @@ pub(crate) fn codegen_fn<'tcx>(\n     context.compute_domtree();\n     context.eliminate_unreachable_code(cx.module.isa()).unwrap();\n     context.dce(cx.module.isa()).unwrap();\n+    // Some Cranelift optimizations expect the domtree to not yet be computed and as such don't\n+    // invalidate it when it would change.\n+    context.domtree.clear();\n \n     context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n \n@@ -1053,7 +1060,11 @@ pub(crate) fn codegen_panic_inner<'tcx>(\n \n     fx.lib_call(\n         &*symbol_name,\n-        vec![fx.pointer_type, fx.pointer_type, fx.pointer_type],\n+        vec![\n+            AbiParam::new(fx.pointer_type),\n+            AbiParam::new(fx.pointer_type),\n+            AbiParam::new(fx.pointer_type),\n+        ],\n         vec![],\n         args,\n     );"}, {"sha": "83e5dc6e6724d683d9db19c87b2247a5ee41ead5", "filename": "src/bin/cg_clif_build_sysroot.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fbin%2Fcg_clif_build_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fbin%2Fcg_clif_build_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcg_clif_build_sysroot.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -53,10 +53,7 @@ impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n                 .unwrap()\n                 .parent()\n                 .unwrap()\n-                .parent()\n-                .unwrap()\n-                .join(\"build_sysroot\")\n-                .join(\"sysroot\"),\n+                .to_owned(),\n         );\n     }\n }"}, {"sha": "866ba90e4ae4ba5d9a73e67216f2ed7bf21872d5", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -1,5 +1,7 @@\n //! Replaces 128-bit operators with lang item calls where necessary\n \n+use cranelift_codegen::ir::ArgumentPurpose;\n+\n use crate::prelude::*;\n \n pub(crate) fn maybe_codegen<'tcx>(\n@@ -24,41 +26,41 @@ pub(crate) fn maybe_codegen<'tcx>(\n             None\n         }\n         BinOp::Add | BinOp::Sub if !checked => None,\n-        BinOp::Add => {\n-            let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-            return Some(if is_signed {\n-                fx.easy_call(\"__rust_i128_addo\", &[lhs, rhs], out_ty)\n+        BinOp::Mul if !checked => {\n+            let val_ty = if is_signed {\n+                fx.tcx.types.i128\n             } else {\n-                fx.easy_call(\"__rust_u128_addo\", &[lhs, rhs], out_ty)\n-            });\n+                fx.tcx.types.u128\n+            };\n+            Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n         }\n-        BinOp::Sub => {\n+        BinOp::Add | BinOp::Sub | BinOp::Mul => {\n+            assert!(checked);\n             let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-            return Some(if is_signed {\n-                fx.easy_call(\"__rust_i128_subo\", &[lhs, rhs], out_ty)\n-            } else {\n-                fx.easy_call(\"__rust_u128_subo\", &[lhs, rhs], out_ty)\n-            });\n-        }\n-        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n-        BinOp::Mul => {\n-            let res = if checked {\n-                let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                if is_signed {\n-                    fx.easy_call(\"__rust_i128_mulo\", &[lhs, rhs], out_ty)\n-                } else {\n-                    fx.easy_call(\"__rust_u128_mulo\", &[lhs, rhs], out_ty)\n-                }\n-            } else {\n-                let val_ty = if is_signed {\n-                    fx.tcx.types.i128\n-                } else {\n-                    fx.tcx.types.u128\n-                };\n-                fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty)\n+            let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n+            let param_types = vec![\n+                AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                AbiParam::new(types::I128),\n+                AbiParam::new(types::I128),\n+            ];\n+            let args = [\n+                out_place.to_ptr().get_addr(fx),\n+                lhs.load_scalar(fx),\n+                rhs.load_scalar(fx),\n+            ];\n+            let name = match (bin_op, is_signed) {\n+                (BinOp::Add, false) => \"__rust_u128_addo\",\n+                (BinOp::Add, true) => \"__rust_i128_addo\",\n+                (BinOp::Sub, false) => \"__rust_u128_subo\",\n+                (BinOp::Sub, true) => \"__rust_i128_subo\",\n+                (BinOp::Mul, false) => \"__rust_u128_mulo\",\n+                (BinOp::Mul, true) => \"__rust_i128_mulo\",\n+                _ => unreachable!(),\n             };\n-            Some(res)\n+            fx.lib_call(name, param_types, vec![], &args);\n+            Some(out_place.to_cvalue(fx))\n         }\n+        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n         BinOp::Div => {\n             assert!(!checked);\n             if is_signed {"}, {"sha": "fbee84e09f7a6e40625dc9728b3eb4dc73e6d20c", "filename": "src/common.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -1,4 +1,5 @@\n use rustc_index::vec::IndexVec;\n+use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n@@ -294,6 +295,7 @@ pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n \n     pub(crate) instance: Instance<'tcx>,\n     pub(crate) mir: &'tcx Body<'tcx>,\n+    pub(crate) fn_abi: Option<FnAbi<'tcx, Ty<'tcx>>>,\n \n     pub(crate) bcx: FunctionBuilder<'clif>,\n     pub(crate) block_map: IndexVec<BasicBlock, Block>,\n@@ -319,16 +321,7 @@ impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n     type TyAndLayout = TyAndLayout<'tcx>;\n \n     fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n-        assert!(!ty.still_further_specializable());\n-        self.tcx\n-            .layout_of(ParamEnv::reveal_all().and(&ty))\n-            .unwrap_or_else(|e| {\n-                if let layout::LayoutError::SizeOverflow(_) = e {\n-                    self.tcx.sess.fatal(&e.to_string())\n-                } else {\n-                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n-            })\n+        RevealAllLayoutCx(self.tcx).layout_of(ty)\n     }\n }\n \n@@ -442,3 +435,47 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         self.bcx.ins().global_value(self.pointer_type, local_msg_id)\n     }\n }\n+\n+pub(crate) struct RevealAllLayoutCx<'tcx>(pub(crate) TyCtxt<'tcx>);\n+\n+impl<'tcx> LayoutOf for RevealAllLayoutCx<'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyAndLayout = TyAndLayout<'tcx>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n+        assert!(!ty.still_further_specializable());\n+        self.0\n+            .layout_of(ParamEnv::reveal_all().and(&ty))\n+            .unwrap_or_else(|e| {\n+                if let layout::LayoutError::SizeOverflow(_) = e {\n+                    self.0.sess.fatal(&e.to_string())\n+                } else {\n+                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+                }\n+            })\n+    }\n+}\n+\n+impl<'tcx> layout::HasTyCtxt<'tcx> for RevealAllLayoutCx<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.0\n+    }\n+}\n+\n+impl<'tcx> rustc_target::abi::HasDataLayout for RevealAllLayoutCx<'tcx> {\n+    fn data_layout(&self) -> &rustc_target::abi::TargetDataLayout {\n+        &self.0.data_layout\n+    }\n+}\n+\n+impl<'tcx> layout::HasParamEnv<'tcx> for RevealAllLayoutCx<'tcx> {\n+    fn param_env(&self) -> ParamEnv<'tcx> {\n+        ParamEnv::reveal_all()\n+    }\n+}\n+\n+impl<'tcx> HasTargetSpec for RevealAllLayoutCx<'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.0.sess.target\n+    }\n+}"}, {"sha": "df89883f0bbb7418df249bbba4a8f04e3e191171", "filename": "src/driver/aot.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -281,9 +281,6 @@ pub(super) fn run_aot(\n         None\n     };\n \n-    rustc_incremental::assert_dep_graph(tcx);\n-    rustc_incremental::save_dep_graph(tcx);\n-\n     let metadata_module = if need_metadata_module {\n         let _timer = tcx.prof.generic_activity(\"codegen crate metadata\");\n         let (metadata_cgu_name, tmp_file) = tcx.sess.time(\"write compressed metadata\", || {\n@@ -322,10 +319,6 @@ pub(super) fn run_aot(\n         None\n     };\n \n-    if tcx.sess.opts.output_types.should_codegen() {\n-        rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n-    }\n-\n     Box::new((\n         CodegenResults {\n             crate_name: tcx.crate_name(LOCAL_CRATE),"}, {"sha": "2d14ff2c0221d19c868dea6be771dd18106ff136", "filename": "src/driver/jit.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -156,12 +156,8 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n             let jit_module = jit_module.as_mut().unwrap();\n             let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n \n-            let (name, sig) = crate::abi::get_function_name_and_sig(\n-                tcx,\n-                cx.module.isa().triple(),\n-                instance,\n-                true,\n-            );\n+            let name = tcx.symbol_name(instance).name.to_string();\n+            let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), instance);\n             let func_id = cx\n                 .module\n                 .declare_function(&name, Linkage::Export, &sig)\n@@ -246,8 +242,8 @@ pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: In\n \n     let pointer_type = cx.module.target_config().pointer_type();\n \n-    let (name, sig) =\n-        crate::abi::get_function_name_and_sig(tcx, cx.module.isa().triple(), inst, true);\n+    let name = tcx.symbol_name(inst).name.to_string();\n+    let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), inst);\n     let func_id = cx\n         .module\n         .declare_function(&name, Linkage::Export, &sig)"}, {"sha": "2497f9dfdfbcf0d9ba8cc80972cce666549cd81b", "filename": "src/driver/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -50,12 +50,9 @@ fn predefine_mono_items<'tcx>(\n         for &(mono_item, (linkage, visibility)) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(instance) => {\n-                    let (name, sig) = get_function_name_and_sig(\n-                        cx.tcx,\n-                        cx.module.isa().triple(),\n-                        instance,\n-                        false,\n-                    );\n+                    let name = cx.tcx.symbol_name(instance).name.to_string();\n+                    let _inst_guard = crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, name));\n+                    let sig = get_function_sig(cx.tcx, cx.module.isa().triple(), instance);\n                     let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n                     cx.module.declare_function(&name, linkage, &sig).unwrap();\n                 }"}, {"sha": "170750461cace0a60c10e8f98e0d3f848a7831ea", "filename": "src/lib.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -27,7 +27,6 @@ extern crate rustc_incremental;\n extern crate rustc_index;\n extern crate rustc_session;\n extern crate rustc_span;\n-extern crate rustc_symbol_mangling;\n extern crate rustc_target;\n \n // This prevents duplicating functions and statics that are already part of the host rustc process.\n@@ -90,7 +89,8 @@ mod prelude {\n     pub(crate) use rustc_middle::mir::{self, *};\n     pub(crate) use rustc_middle::ty::layout::{self, TyAndLayout};\n     pub(crate) use rustc_middle::ty::{\n-        self, FloatTy, FnSig, Instance, InstanceDef, IntTy, ParamEnv, Ty, TyCtxt, TypeAndMut, TypeFoldable, UintTy,\n+        self, FloatTy, Instance, InstanceDef, IntTy, ParamEnv, Ty, TyCtxt, TypeAndMut,\n+        TypeFoldable, UintTy,\n     };\n     pub(crate) use rustc_target::abi::{Abi, LayoutOf, Scalar, Size, VariantIdx};\n \n@@ -256,8 +256,6 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         };\n         let res = driver::codegen_crate(tcx, metadata, need_metadata_module, config);\n \n-        rustc_symbol_mangling::test::report_symbol_names(tcx);\n-\n         res\n     }\n \n@@ -279,18 +277,14 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     ) -> Result<(), ErrorReported> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n-        let _timer = sess.prof.generic_activity(\"link_crate\");\n-\n-        sess.time(\"linking\", || {\n-            let target_cpu = crate::target_triple(sess).to_string();\n-            link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n-                sess,\n-                &codegen_results,\n-                outputs,\n-                &codegen_results.crate_name.as_str(),\n-                &target_cpu,\n-            );\n-        });\n+        let target_cpu = crate::target_triple(sess).to_string();\n+        link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n+            sess,\n+            &codegen_results,\n+            outputs,\n+            &codegen_results.crate_name.as_str(),\n+            &target_cpu,\n+        );\n \n         Ok(())\n     }\n@@ -345,7 +339,12 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n \n     let flags = settings::Flags::new(flags_builder);\n \n-    let mut isa_builder = cranelift_codegen::isa::lookup(target_triple).unwrap();\n+    let variant = if cfg!(feature = \"oldbe\") {\n+        cranelift_codegen::isa::BackendVariant::Legacy\n+    } else {\n+        cranelift_codegen::isa::BackendVariant::MachInst\n+    };\n+    let mut isa_builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n     // Don't use \"haswell\", as it implies `has_lzcnt`.macOS CI is still at Ivy Bridge EP, so `lzcnt`\n     // is interpreted as `bsr`.\n     isa_builder.enable(\"nehalem\").unwrap();"}, {"sha": "b193cea877dad493996c9bbee8cf1a1011345bc3", "filename": "src/main_shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -69,8 +69,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n-        let (main_name, main_sig) =\n-            get_function_name_and_sig(tcx, m.isa().triple(), instance, false);\n+        let main_name = tcx.symbol_name(instance).name.to_string();\n+        let main_sig = get_function_sig(tcx, m.isa().triple(), instance);\n         let main_func_id = m\n             .declare_function(&main_name, Linkage::Import, &main_sig)\n             .unwrap();"}, {"sha": "d1d2b3b872a4b10002163eafe76e6eb664c88151", "filename": "src/num.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -280,7 +280,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                     (val, fx.bcx.ins().bor(has_underflow, has_overflow))\n                 }\n                 types::I64 => {\n-                    //let val = fx.easy_call(\"__mulodi4\", &[lhs, rhs, overflow_ptr], types::I64);\n                     let val = fx.bcx.ins().imul(lhs, rhs);\n                     let has_overflow = if !signed {\n                         let val_hi = fx.bcx.ins().umulhi(lhs, rhs);"}, {"sha": "f4a15ab12d5112fbc8b9c324f65ca2c7adf19e4e", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -61,7 +61,9 @@ use cranelift_codegen::{\n     write::{FuncWriter, PlainWriter},\n };\n \n+use rustc_middle::ty::layout::FnAbiExt;\n use rustc_session::config::OutputType;\n+use rustc_target::abi::call::FnAbi;\n \n use crate::prelude::*;\n \n@@ -78,11 +80,8 @@ impl CommentWriter {\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name),\n                 format!(\"instance {:?}\", instance),\n                 format!(\n-                    \"sig {:?}\",\n-                    tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        crate::abi::fn_sig_for_fn_abi(tcx, instance)\n-                    )\n+                    \"abi {:?}\",\n+                    FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])\n                 ),\n                 String::new(),\n             ]"}, {"sha": "765604e0f984ec343bba1fd8398a3b6b6008fc83", "filename": "src/value_and_place.rs", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -334,7 +334,9 @@ impl<'tcx> CPlace<'tcx> {\n \n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n-            size: u32::try_from(layout.size.bytes()).unwrap(),\n+            // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n+            // specify stack slot alignment.\n+            size: (u32::try_from(layout.size.bytes()).unwrap() + 15) / 16 * 16,\n             offset: None,\n         });\n         CPlace {\n@@ -450,64 +452,6 @@ impl<'tcx> CPlace<'tcx> {\n         fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n         from: CValue<'tcx>,\n     ) {\n-        fn assert_assignable<'tcx>(\n-            fx: &FunctionCx<'_, 'tcx, impl Module>,\n-            from_ty: Ty<'tcx>,\n-            to_ty: Ty<'tcx>,\n-        ) {\n-            match (from_ty.kind(), to_ty.kind()) {\n-                (ty::Ref(_, a, _), ty::Ref(_, b, _))\n-                | (\n-                    ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n-                    ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n-                ) => {\n-                    assert_assignable(fx, a, b);\n-                }\n-                (ty::FnPtr(_), ty::FnPtr(_)) => {\n-                    let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        from_ty.fn_sig(fx.tcx),\n-                    );\n-                    let to_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        to_ty.fn_sig(fx.tcx),\n-                    );\n-                    assert_eq!(\n-                        from_sig, to_sig,\n-                        \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n-                        from_sig, to_sig, fx,\n-                    );\n-                    // fn(&T) -> for<'l> fn(&'l T) is allowed\n-                }\n-                (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n-                    for (from, to) in from_traits.iter().zip(to_traits) {\n-                        let from = fx\n-                            .tcx\n-                            .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n-                        let to = fx\n-                            .tcx\n-                            .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n-                        assert_eq!(\n-                            from, to,\n-                            \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n-                            from_traits, to_traits, fx,\n-                        );\n-                    }\n-                    // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n-                }\n-                _ => {\n-                    assert_eq!(\n-                        from_ty,\n-                        to_ty,\n-                        \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n-                        from_ty,\n-                        to_ty,\n-                        fx,\n-                    );\n-                }\n-            }\n-        }\n-\n         assert_assignable(fx, from.layout().ty, self.layout().ty);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n@@ -556,7 +500,9 @@ impl<'tcx> CPlace<'tcx> {\n                     // FIXME do something more efficient for transmutes between vectors and integers.\n                     let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n                         kind: StackSlotKind::ExplicitSlot,\n-                        size: src_ty.bytes(),\n+                        // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n+                        // specify stack slot alignment.\n+                        size: (src_ty.bytes() + 15) / 16 * 16,\n                         offset: None,\n                     });\n                     let ptr = Pointer::stack_slot(stack_slot);\n@@ -794,3 +740,62 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n }\n+\n+#[track_caller]\n+pub(crate) fn assert_assignable<'tcx>(\n+    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+) {\n+    match (from_ty.kind(), to_ty.kind()) {\n+        (ty::Ref(_, a, _), ty::Ref(_, b, _))\n+        | (\n+            ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n+            ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n+        ) => {\n+            assert_assignable(fx, a, b);\n+        }\n+        (ty::Ref(_, a, _), ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }))\n+        | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }), ty::Ref(_, b, _)) => {\n+            assert_assignable(fx, a, b);\n+        }\n+        (ty::FnPtr(_), ty::FnPtr(_)) => {\n+            let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+                ParamEnv::reveal_all(),\n+                from_ty.fn_sig(fx.tcx),\n+            );\n+            let to_sig = fx\n+                .tcx\n+                .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to_ty.fn_sig(fx.tcx));\n+            assert_eq!(\n+                from_sig, to_sig,\n+                \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n+                from_sig, to_sig, fx,\n+            );\n+            // fn(&T) -> for<'l> fn(&'l T) is allowed\n+        }\n+        (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n+            for (from, to) in from_traits.iter().zip(to_traits) {\n+                let from = fx\n+                    .tcx\n+                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n+                let to = fx\n+                    .tcx\n+                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n+                assert_eq!(\n+                    from, to,\n+                    \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n+                    from_traits, to_traits, fx,\n+                );\n+            }\n+            // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n+        }\n+        _ => {\n+            assert_eq!(\n+                from_ty, to_ty,\n+                \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n+                from_ty, to_ty, fx,\n+            );\n+        }\n+    }\n+}"}, {"sha": "5ab10e0e905c7b9ce3fb60fbe37bd7f443642706", "filename": "test.sh", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02e1fd48d183c9a28dc7f78b68fded919a1b9338/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02e1fd48d183c9a28dc7f78b68fded919a1b9338/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=02e1fd48d183c9a28dc7f78b68fded919a1b9338", "patch": "@@ -1,9 +1,7 @@\n #!/bin/bash\n set -e\n \n-export RUSTFLAGS=\"-Zrun_dsymutil=no\"\n-\n-./build.sh --without-sysroot \"$@\"\n+./build.sh --sysroot none \"$@\"\n \n rm -r target/out || true\n "}]}