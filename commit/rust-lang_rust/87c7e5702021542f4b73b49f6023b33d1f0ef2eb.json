{"sha": "87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YzdlNTcwMjAyMTU0MmY0YjczYjQ5ZjYwMjNiMzNkMWYwZWYyZWI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-21T23:35:01Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-22T15:05:27Z"}, "message": "Rename ty::Slice to ty::List", "tree": {"sha": "f943e0023595824fd4e7b8515adf77b0a3523d49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f943e0023595824fd4e7b8515adf77b0a3523d49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "html_url": "https://github.com/rust-lang/rust/commit/87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "674ef668f13c52a1fadbf01b24d8da1e12d15e70", "url": "https://api.github.com/repos/rust-lang/rust/commits/674ef668f13c52a1fadbf01b24d8da1e12d15e70", "html_url": "https://github.com/rust-lang/rust/commit/674ef668f13c52a1fadbf01b24d8da1e12d15e70"}], "stats": {"total": 279, "additions": 140, "deletions": 139}, "files": [{"sha": "a64d8c2967f636d05ab80fd2e5b114705fd58698", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -25,7 +25,7 @@ use ty;\n use mir;\n \n impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n-for &'gcx ty::Slice<T>\n+for &'gcx ty::List<T>\n     where T: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -53,7 +53,7 @@ for &'gcx ty::Slice<T>\n     }\n }\n \n-impl<'a, 'gcx, T> ToStableHashKey<StableHashingContext<'a>> for &'gcx ty::Slice<T>\n+impl<'a, 'gcx, T> ToStableHashKey<StableHashingContext<'a>> for &'gcx ty::List<T>\n     where T: HashStable<StableHashingContext<'a>>\n {\n     type KeyType = Fingerprint;"}, {"sha": "7d5b0a8de8b87c52ace03a5dd3bce01ac4b5b71f", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -23,7 +23,7 @@ use infer::InferCtxt;\n use std::sync::atomic::Ordering;\n use ty::fold::{TypeFoldable, TypeFolder};\n use ty::subst::Kind;\n-use ty::{self, CanonicalVar, Lift, Slice, Ty, TyCtxt, TypeFlags};\n+use ty::{self, CanonicalVar, Lift, List, Ty, TyCtxt, TypeFlags};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -327,7 +327,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n         if !value.has_type_flags(needs_canonical_flags) {\n             let out_value = gcx.lift(value).unwrap();\n             let canon_value = Canonical {\n-                variables: Slice::empty(),\n+                variables: List::empty(),\n                 value: out_value,\n             };\n             return canon_value;"}, {"sha": "cb1e39bb9f7428d033f52306b761ec2d84835fe1", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -40,7 +40,7 @@ use std::ops::Index;\n use syntax::source_map::Span;\n use ty::fold::TypeFoldable;\n use ty::subst::Kind;\n-use ty::{self, CanonicalVar, Lift, Region, Slice, TyCtxt};\n+use ty::{self, CanonicalVar, Lift, Region, List, TyCtxt};\n \n mod canonicalizer;\n \n@@ -57,7 +57,7 @@ pub struct Canonical<'gcx, V> {\n     pub value: V,\n }\n \n-pub type CanonicalVarInfos<'gcx> = &'gcx Slice<CanonicalVarInfo>;\n+pub type CanonicalVarInfos<'gcx> = &'gcx List<CanonicalVarInfo>;\n \n impl<'gcx> UseSpecializedDecodable for CanonicalVarInfos<'gcx> {}\n \n@@ -221,7 +221,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     fn fresh_inference_vars_for_canonical_vars(\n         &self,\n         span: Span,\n-        variables: &Slice<CanonicalVarInfo>,\n+        variables: &List<CanonicalVarInfo>,\n     ) -> CanonicalVarValues<'tcx> {\n         let var_values: IndexVec<CanonicalVar, Kind<'tcx>> = variables\n             .iter()"}, {"sha": "e2dbe88354060b2221957de9398ed8696e392ecd", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -24,7 +24,7 @@ use infer::outlives::env::OutlivesEnvironment;\n use middle::region;\n use mir::interpret::ConstEvalErr;\n use ty::subst::Substs;\n-use ty::{self, AdtKind, Slice, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n+use ty::{self, AdtKind, List, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n use infer::{InferCtxt};\n@@ -325,7 +325,7 @@ pub enum Goal<'tcx> {\n     CannotProve,\n }\n \n-pub type Goals<'tcx> = &'tcx Slice<Goal<'tcx>>;\n+pub type Goals<'tcx> = &'tcx List<Goal<'tcx>>;\n \n impl<'tcx> DomainGoal<'tcx> {\n     pub fn into_goal(self) -> Goal<'tcx> {\n@@ -357,7 +357,7 @@ pub enum Clause<'tcx> {\n }\n \n /// Multiple clauses.\n-pub type Clauses<'tcx> = &'tcx Slice<Clause<'tcx>>;\n+pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n \n /// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n /// that the domain goal `D` is true if `G1...Gn` are provable. This"}, {"sha": "87535a6ae8d1466d53f908d4b6e08f7ed26ee596", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -620,7 +620,7 @@ EnumLiftImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<traits::Goal<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n             .map(|t| t.fold_with(folder))\n@@ -658,7 +658,7 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<traits::Clause<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Clause<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n             .map(|t| t.fold_with(folder))"}, {"sha": "c343ded76578629921ab12052ec3ded2a8a60dd6", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -212,7 +212,7 @@ pub fn decode_region<'a, 'tcx, D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D\n \n #[inline]\n pub fn decode_ty_slice<'a, 'tcx, D>(decoder: &mut D)\n-                                    -> Result<&'tcx ty::Slice<Ty<'tcx>>, D::Error>\n+                                    -> Result<&'tcx ty::List<Ty<'tcx>>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {\n@@ -232,7 +232,7 @@ pub fn decode_adt_def<'a, 'tcx, D>(decoder: &mut D)\n \n #[inline]\n pub fn decode_existential_predicate_slice<'a, 'tcx, D>(decoder: &mut D)\n-    -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, D::Error>\n+    -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {\n@@ -366,10 +366,10 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::Slice<ty::Ty<'tcx>>>\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::List<ty::Ty<'tcx>>>\n             for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(&mut self)\n-                                      -> Result<&'tcx ty::Slice<ty::Ty<'tcx>>, Self::Error> {\n+                                      -> Result<&'tcx ty::List<ty::Ty<'tcx>>, Self::Error> {\n                     decode_ty_slice(self)\n                 }\n             }\n@@ -381,10 +381,10 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>\n                 for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(&mut self)\n-                    -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n+                    -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n                     decode_existential_predicate_slice(self)\n                 }\n             }"}, {"sha": "ba274236eb90393434040921aa2d7355c394a1d9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -38,7 +38,7 @@ use ty::ReprOptions;\n use traits;\n use traits::{Clause, Clauses, Goal, Goals};\n use ty::{self, Ty, TypeAndMut};\n-use ty::{TyS, TypeVariants, Slice};\n+use ty::{TyS, TypeVariants, List};\n use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const};\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use ty::RegionKind;\n@@ -135,15 +135,15 @@ pub struct CtxtInterners<'tcx> {\n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n     type_: InternedSet<'tcx, TyS<'tcx>>,\n-    type_list: InternedSet<'tcx, Slice<Ty<'tcx>>>,\n+    type_list: InternedSet<'tcx, List<Ty<'tcx>>>,\n     substs: InternedSet<'tcx, Substs<'tcx>>,\n-    canonical_var_infos: InternedSet<'tcx, Slice<CanonicalVarInfo>>,\n+    canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo>>,\n     region: InternedSet<'tcx, RegionKind>,\n-    existential_predicates: InternedSet<'tcx, Slice<ExistentialPredicate<'tcx>>>,\n-    predicates: InternedSet<'tcx, Slice<Predicate<'tcx>>>,\n+    existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n+    predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n-    clauses: InternedSet<'tcx, Slice<Clause<'tcx>>>,\n-    goals: InternedSet<'tcx, Slice<Goal<'tcx>>>,\n+    clauses: InternedSet<'tcx, List<Clause<'tcx>>>,\n+    goals: InternedSet<'tcx, List<Goal<'tcx>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -1593,12 +1593,12 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Goal<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Goal<'a>> {\n-    type Lifted = &'tcx Slice<Goal<'tcx>>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<Goal<'a>> {\n+    type Lifted = &'tcx List<Goal<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'tcx>,\n-    ) -> Option<&'tcx Slice<Goal<'tcx>>> {\n+    ) -> Option<&'tcx List<Goal<'tcx>>> {\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n@@ -1611,12 +1611,12 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Goal<'a>> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Clause<'a>> {\n-    type Lifted = &'tcx Slice<Clause<'tcx>>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<Clause<'a>> {\n+    type Lifted = &'tcx List<Clause<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'tcx>,\n-    ) -> Option<&'tcx Slice<Clause<'tcx>>> {\n+    ) -> Option<&'tcx List<Clause<'tcx>>> {\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n@@ -1648,7 +1648,7 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     type Lifted = &'tcx Substs<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n         if self.len() == 0 {\n-            return Some(Slice::empty());\n+            return Some(List::empty());\n         }\n         if tcx.interners.arena.in_arena(&self[..] as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n@@ -1662,12 +1662,12 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n-    type Lifted = &'tcx Slice<Ty<'tcx>>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<Ty<'a>> {\n+    type Lifted = &'tcx List<Ty<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-                             -> Option<&'tcx Slice<Ty<'tcx>>> {\n+                             -> Option<&'tcx List<Ty<'tcx>>> {\n         if self.len() == 0 {\n-            return Some(Slice::empty());\n+            return Some(List::empty());\n         }\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n@@ -1681,12 +1681,12 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<ExistentialPredicate<'a>> {\n-    type Lifted = &'tcx Slice<ExistentialPredicate<'tcx>>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<ExistentialPredicate<'a>> {\n+    type Lifted = &'tcx List<ExistentialPredicate<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-        -> Option<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n+        -> Option<&'tcx List<ExistentialPredicate<'tcx>>> {\n         if self.is_empty() {\n-            return Some(Slice::empty());\n+            return Some(List::empty());\n         }\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n@@ -1700,12 +1700,12 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<ExistentialPredicate<'a>> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Predicate<'a>> {\n-    type Lifted = &'tcx Slice<Predicate<'tcx>>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<Predicate<'a>> {\n+    type Lifted = &'tcx List<Predicate<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-        -> Option<&'tcx Slice<Predicate<'tcx>>> {\n+        -> Option<&'tcx List<Predicate<'tcx>>> {\n         if self.is_empty() {\n-            return Some(Slice::empty());\n+            return Some(List::empty());\n         }\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n@@ -1719,11 +1719,11 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Predicate<'a>> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<CanonicalVarInfo> {\n-    type Lifted = &'tcx Slice<CanonicalVarInfo>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<CanonicalVarInfo> {\n+    type Lifted = &'tcx List<CanonicalVarInfo>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         if self.len() == 0 {\n-            return Some(Slice::empty());\n+            return Some(List::empty());\n         }\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n@@ -2113,28 +2113,28 @@ impl<'tcx: 'lcx, 'lcx> Borrow<TypeVariants<'lcx>> for Interned<'tcx, TyS<'tcx>>\n     }\n }\n \n-// NB: An Interned<Slice<T>> compares and hashes as its elements.\n-impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, Slice<T>> {\n-    fn eq(&self, other: &Interned<'tcx, Slice<T>>) -> bool {\n+// NB: An Interned<List<T>> compares and hashes as its elements.\n+impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, List<T>> {\n+    fn eq(&self, other: &Interned<'tcx, List<T>>) -> bool {\n         self.0[..] == other.0[..]\n     }\n }\n \n-impl<'tcx, T: Eq> Eq for Interned<'tcx, Slice<T>> {}\n+impl<'tcx, T: Eq> Eq for Interned<'tcx, List<T>> {}\n \n-impl<'tcx, T: Hash> Hash for Interned<'tcx, Slice<T>> {\n+impl<'tcx, T: Hash> Hash for Interned<'tcx, List<T>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         self.0[..].hash(s)\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, Slice<Ty<'tcx>>> {\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, List<Ty<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Ty<'lcx>] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, Slice<CanonicalVarInfo>> {\n+impl<'tcx: 'lcx, 'lcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, List<CanonicalVarInfo>> {\n     fn borrow<'a>(&'a self) -> &'a [CanonicalVarInfo] {\n         &self.0[..]\n     }\n@@ -2153,14 +2153,14 @@ impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n }\n \n impl<'tcx: 'lcx, 'lcx> Borrow<[ExistentialPredicate<'lcx>]>\n-    for Interned<'tcx, Slice<ExistentialPredicate<'tcx>>> {\n+    for Interned<'tcx, List<ExistentialPredicate<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [ExistentialPredicate<'lcx>] {\n         &self.0[..]\n     }\n }\n \n impl<'tcx: 'lcx, 'lcx> Borrow<[Predicate<'lcx>]>\n-    for Interned<'tcx, Slice<Predicate<'tcx>>> {\n+    for Interned<'tcx, List<Predicate<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Predicate<'lcx>] {\n         &self.0[..]\n     }\n@@ -2173,14 +2173,14 @@ impl<'tcx: 'lcx, 'lcx> Borrow<Const<'lcx>> for Interned<'tcx, Const<'tcx>> {\n }\n \n impl<'tcx: 'lcx, 'lcx> Borrow<[Clause<'lcx>]>\n-for Interned<'tcx, Slice<Clause<'tcx>>> {\n+for Interned<'tcx, List<Clause<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Clause<'lcx>] {\n         &self.0[..]\n     }\n }\n \n impl<'tcx: 'lcx, 'lcx> Borrow<[Goal<'lcx>]>\n-for Interned<'tcx, Slice<Goal<'tcx>>> {\n+for Interned<'tcx, List<Goal<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Goal<'lcx>] {\n         &self.0[..]\n     }\n@@ -2274,9 +2274,9 @@ macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ident)),+) => (\n         $(intern_method!( 'tcx, $field: $method(\n             &[$ty<'tcx>],\n-            |a, v| Slice::from_arena(a, v),\n+            |a, v| List::from_arena(a, v),\n             Deref::deref,\n-            |xs: &[$ty]| xs.iter().any(keep_local)) -> Slice<$ty<'tcx>>);)+\n+            |xs: &[$ty]| xs.iter().any(keep_local)) -> List<$ty<'tcx>>);)+\n     )\n }\n \n@@ -2298,10 +2298,10 @@ intern_method! {\n     'tcx,\n     canonical_var_infos: _intern_canonical_var_infos(\n         &[CanonicalVarInfo],\n-        |a, v| Slice::from_arena(a, v),\n+        |a, v| List::from_arena(a, v),\n         Deref::deref,\n         |_xs: &[CanonicalVarInfo]| -> bool { false }\n-    ) -> Slice<CanonicalVarInfo>\n+    ) -> List<CanonicalVarInfo>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -2480,7 +2480,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_dynamic(\n         self,\n-        obj: ty::Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>,\n+        obj: ty::Binder<&'tcx List<ExistentialPredicate<'tcx>>>,\n         reg: ty::Region<'tcx>\n     ) -> Ty<'tcx> {\n         self.mk_ty(TyDynamic(obj, reg))\n@@ -2509,7 +2509,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyGenerator(id, generator_substs, movability))\n     }\n \n-    pub fn mk_generator_witness(self, types: ty::Binder<&'tcx Slice<Ty<'tcx>>>) -> Ty<'tcx> {\n+    pub fn mk_generator_witness(self, types: ty::Binder<&'tcx List<Ty<'tcx>>>) -> Ty<'tcx> {\n         self.mk_ty(TyGeneratorWitness(types))\n     }\n \n@@ -2553,60 +2553,60 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn intern_existential_predicates(self, eps: &[ExistentialPredicate<'tcx>])\n-        -> &'tcx Slice<ExistentialPredicate<'tcx>> {\n+        -> &'tcx List<ExistentialPredicate<'tcx>> {\n         assert!(!eps.is_empty());\n         assert!(eps.windows(2).all(|w| w[0].stable_cmp(self, &w[1]) != Ordering::Greater));\n         self._intern_existential_predicates(eps)\n     }\n \n     pub fn intern_predicates(self, preds: &[Predicate<'tcx>])\n-        -> &'tcx Slice<Predicate<'tcx>> {\n+        -> &'tcx List<Predicate<'tcx>> {\n         // FIXME consider asking the input slice to be sorted to avoid\n         // re-interning permutations, in which case that would be asserted\n         // here.\n         if preds.len() == 0 {\n             // The macro-generated method below asserts we don't intern an empty slice.\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self._intern_predicates(preds)\n         }\n     }\n \n-    pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx Slice<Ty<'tcx>> {\n+    pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx List<Ty<'tcx>> {\n         if ts.len() == 0 {\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self._intern_type_list(ts)\n         }\n     }\n \n-    pub fn intern_substs(self, ts: &[Kind<'tcx>]) -> &'tcx Slice<Kind<'tcx>> {\n+    pub fn intern_substs(self, ts: &[Kind<'tcx>]) -> &'tcx List<Kind<'tcx>> {\n         if ts.len() == 0 {\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self._intern_substs(ts)\n         }\n     }\n \n     pub fn intern_canonical_var_infos(self, ts: &[CanonicalVarInfo]) -> CanonicalVarInfos<'gcx> {\n         if ts.len() == 0 {\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self.global_tcx()._intern_canonical_var_infos(ts)\n         }\n     }\n \n     pub fn intern_clauses(self, ts: &[Clause<'tcx>]) -> Clauses<'tcx> {\n         if ts.len() == 0 {\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self._intern_clauses(ts)\n         }\n     }\n \n     pub fn intern_goals(self, ts: &[Goal<'tcx>]) -> Goals<'tcx> {\n         if ts.len() == 0 {\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self._intern_goals(ts)\n         }\n@@ -2629,24 +2629,24 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_existential_predicates<I: InternAs<[ExistentialPredicate<'tcx>],\n-                                     &'tcx Slice<ExistentialPredicate<'tcx>>>>(self, iter: I)\n+                                     &'tcx List<ExistentialPredicate<'tcx>>>>(self, iter: I)\n                                      -> I::Output {\n         iter.intern_with(|xs| self.intern_existential_predicates(xs))\n     }\n \n     pub fn mk_predicates<I: InternAs<[Predicate<'tcx>],\n-                                     &'tcx Slice<Predicate<'tcx>>>>(self, iter: I)\n+                                     &'tcx List<Predicate<'tcx>>>>(self, iter: I)\n                                      -> I::Output {\n         iter.intern_with(|xs| self.intern_predicates(xs))\n     }\n \n     pub fn mk_type_list<I: InternAs<[Ty<'tcx>],\n-                        &'tcx Slice<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n+                        &'tcx List<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|xs| self.intern_type_list(xs))\n     }\n \n     pub fn mk_substs<I: InternAs<[Kind<'tcx>],\n-                     &'tcx Slice<Kind<'tcx>>>>(self, iter: I) -> I::Output {\n+                     &'tcx List<Kind<'tcx>>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|xs| self.intern_substs(xs))\n     }\n "}, {"sha": "5ba697ee79532716331694c5e0fb4e12de3575f1", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -51,7 +51,7 @@ pub enum TypeError<'tcx> {\n     CyclicTy(Ty<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n-    ExistentialMismatch(ExpectedFound<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>),\n+    ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n \n     OldStyleLUB(Box<TypeError<'tcx>>),\n }"}, {"sha": "46fbedb5a2641ae07e3a9224461cd3780a2af80d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -596,27 +596,28 @@ impl<'tcx> serialize::UseSpecializedDecodable for Ty<'tcx> {}\n pub type CanonicalTy<'gcx> = Canonical<'gcx, Ty<'gcx>>;\n \n extern {\n-    /// A dummy type used to force Slice to by unsized without requiring fat pointers\n-    type OpaqueSliceContents;\n+    /// A dummy type used to force List to by unsized without requiring fat pointers\n+    type OpaqueListContents;\n }\n \n /// A wrapper for slices with the additional invariant\n /// that the slice is interned and no other slice with\n /// the same contents can exist in the same context.\n /// This means we can use pointer for both\n /// equality comparisons and hashing.\n+/// Note: `Slice` was already taken by the `Ty`.\n #[repr(C)]\n-pub struct Slice<T> {\n+pub struct List<T> {\n     len: usize,\n     data: [T; 0],\n-    opaque: OpaqueSliceContents,\n+    opaque: OpaqueListContents,\n }\n \n-unsafe impl<T: Sync> Sync for Slice<T> {}\n+unsafe impl<T: Sync> Sync for List<T> {}\n \n-impl<T: Copy> Slice<T> {\n+impl<T: Copy> List<T> {\n     #[inline]\n-    fn from_arena<'tcx>(arena: &'tcx SyncDroplessArena, slice: &[T]) -> &'tcx Slice<T> {\n+    fn from_arena<'tcx>(arena: &'tcx SyncDroplessArena, slice: &[T]) -> &'tcx List<T> {\n         assert!(!mem::needs_drop::<T>());\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n@@ -633,7 +634,7 @@ impl<T: Copy> Slice<T> {\n             size,\n             cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n         unsafe {\n-            let result = &mut *(mem.as_mut_ptr() as *mut Slice<T>);\n+            let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n             // Write the length\n             result.len = slice.len();\n \n@@ -646,51 +647,51 @@ impl<T: Copy> Slice<T> {\n     }\n }\n \n-impl<T: fmt::Debug> fmt::Debug for Slice<T> {\n+impl<T: fmt::Debug> fmt::Debug for List<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         (**self).fmt(f)\n     }\n }\n \n-impl<T: Encodable> Encodable for Slice<T> {\n+impl<T: Encodable> Encodable for List<T> {\n     #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<T> Ord for Slice<T> where T: Ord {\n-    fn cmp(&self, other: &Slice<T>) -> Ordering {\n+impl<T> Ord for List<T> where T: Ord {\n+    fn cmp(&self, other: &List<T>) -> Ordering {\n         if self == other { Ordering::Equal } else {\n             <[T] as Ord>::cmp(&**self, &**other)\n         }\n     }\n }\n \n-impl<T> PartialOrd for Slice<T> where T: PartialOrd {\n-    fn partial_cmp(&self, other: &Slice<T>) -> Option<Ordering> {\n+impl<T> PartialOrd for List<T> where T: PartialOrd {\n+    fn partial_cmp(&self, other: &List<T>) -> Option<Ordering> {\n         if self == other { Some(Ordering::Equal) } else {\n             <[T] as PartialOrd>::partial_cmp(&**self, &**other)\n         }\n     }\n }\n \n-impl<T: PartialEq> PartialEq for Slice<T> {\n+impl<T: PartialEq> PartialEq for List<T> {\n     #[inline]\n-    fn eq(&self, other: &Slice<T>) -> bool {\n+    fn eq(&self, other: &List<T>) -> bool {\n         ptr::eq(self, other)\n     }\n }\n-impl<T: Eq> Eq for Slice<T> {}\n+impl<T: Eq> Eq for List<T> {}\n \n-impl<T> Hash for Slice<T> {\n+impl<T> Hash for List<T> {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const Slice<T>).hash(s)\n+        (self as *const List<T>).hash(s)\n     }\n }\n \n-impl<T> Deref for Slice<T> {\n+impl<T> Deref for List<T> {\n     type Target = [T];\n     #[inline(always)]\n     fn deref(&self) -> &[T] {\n@@ -700,7 +701,7 @@ impl<T> Deref for Slice<T> {\n     }\n }\n \n-impl<'a, T> IntoIterator for &'a Slice<T> {\n+impl<'a, T> IntoIterator for &'a List<T> {\n     type Item = &'a T;\n     type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n     #[inline(always)]\n@@ -709,17 +710,17 @@ impl<'a, T> IntoIterator for &'a Slice<T> {\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<Ty<'tcx>> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx List<Ty<'tcx>> {}\n \n-impl<T> Slice<T> {\n+impl<T> List<T> {\n     #[inline(always)]\n-    pub fn empty<'a>() -> &'a Slice<T> {\n+    pub fn empty<'a>() -> &'a List<T> {\n         #[repr(align(64), C)]\n         struct EmptySlice([u8; 64]);\n         static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n         assert!(mem::align_of::<T>() <= 64);\n         unsafe {\n-            &*(&EMPTY_SLICE as *const _ as *const Slice<T>)\n+            &*(&EMPTY_SLICE as *const _ as *const List<T>)\n         }\n     }\n }\n@@ -1556,7 +1557,7 @@ pub struct ParamEnv<'tcx> {\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations, and elaborated and normalized.\n-    pub caller_bounds: &'tcx Slice<ty::Predicate<'tcx>>,\n+    pub caller_bounds: &'tcx List<ty::Predicate<'tcx>>,\n \n     /// Typically, this is `Reveal::UserFacing`, but during codegen we\n     /// want `Reveal::All` -- note that this is always paired with an\n@@ -1570,7 +1571,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// Trait`) are left hidden, so this is suitable for ordinary\n     /// type-checking.\n     pub fn empty() -> Self {\n-        Self::new(ty::Slice::empty(), Reveal::UserFacing)\n+        Self::new(List::empty(), Reveal::UserFacing)\n     }\n \n     /// Construct a trait environment with no where clauses in scope\n@@ -1581,11 +1582,11 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// NB. If you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n     pub fn reveal_all() -> Self {\n-        Self::new(ty::Slice::empty(), Reveal::All)\n+        Self::new(List::empty(), Reveal::All)\n     }\n \n     /// Construct a trait environment with the given set of predicates.\n-    pub fn new(caller_bounds: &'tcx ty::Slice<ty::Predicate<'tcx>>,\n+    pub fn new(caller_bounds: &'tcx List<ty::Predicate<'tcx>>,\n                reveal: Reveal)\n                -> Self {\n         ty::ParamEnv { caller_bounds, reveal }\n@@ -1603,7 +1604,7 @@ impl<'tcx> ParamEnv<'tcx> {\n \n     /// Returns this same environment but with no caller bounds.\n     pub fn without_caller_bounds(self) -> Self {\n-        ty::ParamEnv { caller_bounds: ty::Slice::empty(), ..self }\n+        ty::ParamEnv { caller_bounds: List::empty(), ..self }\n     }\n \n     /// Creates a suitable environment in which to perform trait"}, {"sha": "85f72203da81765de51f50ffd9c8f5212c4e760d", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -316,7 +316,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n }\n \n #[derive(Debug, Clone)]\n-struct GeneratorWitness<'tcx>(&'tcx ty::Slice<Ty<'tcx>>);\n+struct GeneratorWitness<'tcx>(&'tcx ty::List<Ty<'tcx>>);\n \n TupleStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for GeneratorWitness<'tcx> {\n@@ -578,7 +578,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n+impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &Self,\n                            b: &Self)"}, {"sha": "9fad583050f3b6eec33f81f8df3acdf7e90f7457", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -735,7 +735,7 @@ BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> { reveal, caller_bounds }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n         folder.tcx().intern_existential_predicates(&v)\n@@ -754,7 +754,7 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<Ty<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|t| t.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n         folder.tcx().intern_type_list(&v)\n@@ -1010,7 +1010,7 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::Predicate<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n         folder.tcx().intern_predicates(&v)"}, {"sha": "c0c435ae80a068446d3cf2eb2d529eb322645a1c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -18,7 +18,7 @@ use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n-use ty::{Slice, TyS, ParamEnvAnd, ParamEnv};\n+use ty::{List, TyS, ParamEnvAnd, ParamEnv};\n use util::captures::Captures;\n use mir::interpret::{Scalar, Pointer};\n \n@@ -133,7 +133,7 @@ pub enum TypeVariants<'tcx> {\n     TyFnPtr(PolyFnSig<'tcx>),\n \n     /// A trait, defined with `trait`.\n-    TyDynamic(Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n+    TyDynamic(Binder<&'tcx List<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n@@ -145,13 +145,13 @@ pub enum TypeVariants<'tcx> {\n \n     /// A type representin the types stored inside a generator.\n     /// This should only appear in GeneratorInteriors.\n-    TyGeneratorWitness(Binder<&'tcx Slice<Ty<'tcx>>>),\n+    TyGeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n \n     /// The never type `!`\n     TyNever,\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    TyTuple(&'tcx Slice<Ty<'tcx>>),\n+    TyTuple(&'tcx List<Ty<'tcx>>),\n \n     /// The projection of an associated type.  For example,\n     /// `<T as Trait<..>>::N`.\n@@ -536,9 +536,9 @@ impl<'a, 'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<ExistentialPredicate<'tcx>> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx List<ExistentialPredicate<'tcx>> {}\n \n-impl<'tcx> Slice<ExistentialPredicate<'tcx>> {\n+impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     pub fn principal(&self) -> Option<ExistentialTraitRef<'tcx>> {\n         match self.get(0) {\n             Some(&ExistentialPredicate::Trait(tr)) => Some(tr),\n@@ -568,7 +568,7 @@ impl<'tcx> Slice<ExistentialPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> Binder<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n+impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n     pub fn principal(&self) -> Option<PolyExistentialTraitRef<'tcx>> {\n         self.skip_binder().principal().map(Binder::bind)\n     }\n@@ -918,7 +918,7 @@ impl<'tcx> PolyGenSig<'tcx> {\n /// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct FnSig<'tcx> {\n-    pub inputs_and_output: &'tcx Slice<Ty<'tcx>>,\n+    pub inputs_and_output: &'tcx List<Ty<'tcx>>,\n     pub variadic: bool,\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n@@ -943,7 +943,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])\n     }\n-    pub fn inputs_and_output(&self) -> ty::Binder<&'tcx Slice<Ty<'tcx>>> {\n+    pub fn inputs_and_output(&self) -> ty::Binder<&'tcx List<Ty<'tcx>>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs_and_output)\n     }\n     pub fn output(&self) -> ty::Binder<Ty<'tcx>> {"}, {"sha": "f76411da4581684fe7592c3a4c5130119c5b6c74", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -11,7 +11,7 @@\n // Type substitutions.\n \n use hir::def_id::DefId;\n-use ty::{self, Lift, Slice, Ty, TyCtxt};\n+use ty::{self, Lift, List, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n@@ -177,7 +177,7 @@ impl<'tcx> Decodable for Kind<'tcx> {\n }\n \n /// A substitution mapping generic parameters to new values.\n-pub type Substs<'tcx> = Slice<Kind<'tcx>>;\n+pub type Substs<'tcx> = List<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     /// Creates a Substs that maps each generic parameter to itself."}, {"sha": "d97553d62515e66342116c10319701bd0d989a81", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -453,7 +453,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     }\n \n     fn from_object_ty(&mut self, ty: Ty<'tcx>,\n-                      data: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n+                      data: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n                       region: ty::Region<'tcx>) {\n         // Imagine a type like this:\n         //\n@@ -513,7 +513,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// `ty::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n+    existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>)\n     -> Vec<ty::Region<'tcx>>\n {\n     // Since we don't actually *know* the self type for an object,"}, {"sha": "964a65065bc2c2da33cf3281efef5ae2cad3d6bb", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -586,7 +586,7 @@ impl<'a, T: Print> Print for &'a T {\n }\n \n define_print! {\n-    ('tcx) &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n+    ('tcx) &'tcx ty::List<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n         display {\n             // Generate the main trait ref, including associated types.\n             ty::tls::with(|tcx| {\n@@ -672,7 +672,7 @@ impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n }\n \n define_print! {\n-    ('tcx) &'tcx ty::Slice<Ty<'tcx>>, (self, f, cx) {\n+    ('tcx) &'tcx ty::List<Ty<'tcx>>, (self, f, cx) {\n         display {\n             write!(f, \"{{\")?;\n             let mut tys = self.iter();\n@@ -993,7 +993,7 @@ impl fmt::Debug for ty::FloatVarValue {\n \n define_print_multi! {\n     [\n-    ('tcx) ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n+    ('tcx) ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n     ('tcx) ty::Binder<ty::TraitRef<'tcx>>,\n     ('tcx) ty::Binder<ty::FnSig<'tcx>>,\n     ('tcx) ty::Binder<ty::TraitPredicate<'tcx>>,"}, {"sha": "2509ad5c906b3db0c57a34f6fe6cadfe884242ce", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -36,7 +36,7 @@ pub(super) fn sub_types<'tcx>(\n         ty::Variance::Covariant,\n         locations,\n         borrowck_context,\n-        ty::Slice::empty(),\n+        ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n }\n@@ -54,7 +54,7 @@ pub(super) fn eq_types<'tcx>(\n         ty::Variance::Invariant,\n         locations,\n         borrowck_context,\n-        ty::Slice::empty(),\n+        ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n }"}, {"sha": "cd75cf549572b8ed81f2f868d11c2d9c6f4a3ce6", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -506,7 +506,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         &self,\n         indices: &UniversalRegionIndices<'tcx>,\n         defining_ty: DefiningTy<'tcx>,\n-    ) -> ty::Binder<&'tcx ty::Slice<Ty<'tcx>>> {\n+    ) -> ty::Binder<&'tcx ty::List<Ty<'tcx>>> {\n         let tcx = self.infcx.tcx;\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {"}, {"sha": "acad0a1fa2c4ec522766309dbc51b6c98bb6036b", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -13,7 +13,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n use rustc::mir::*;\n-use rustc::ty::{Slice, Ty, TyCtxt, TypeVariants};\n+use rustc::ty::{List, Ty, TyCtxt, TypeVariants};\n use rustc_data_structures::indexed_vec::{Idx};\n use transform::{MirPass, MirSource};\n use syntax;\n@@ -114,7 +114,7 @@ impl Lower128Bit {\n                         source_info,\n                         kind: TerminatorKind::Call {\n                             func: Operand::function_handle(tcx, call_did,\n-                                Slice::empty(), source_info.span),\n+                                List::empty(), source_info.span),\n                             args: vec![lhs, rhs],\n                             destination: Some((place, bb)),\n                             cleanup: None,"}, {"sha": "9fd3b318ec14038ef7ff1bf9c5b81b5badcc1125", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -17,7 +17,7 @@ use rustc::traits::{\n     WhereClause,\n };\n use rustc::ty::query::Providers;\n-use rustc::ty::{self, Slice, TyCtxt};\n+use rustc::ty::{self, List, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::mem;\n use syntax::ast;\n@@ -162,7 +162,7 @@ crate fn program_clauses_for<'a, 'tcx>(\n         DefPathData::AssocTypeInImpl(..) => program_clauses_for_associated_type_value(tcx, def_id),\n         DefPathData::AssocTypeInTrait(..) => program_clauses_for_associated_type_def(tcx, def_id),\n         DefPathData::TypeNs(..) => program_clauses_for_type_def(tcx, def_id),\n-        _ => Slice::empty(),\n+        _ => List::empty(),\n     }\n }\n \n@@ -319,7 +319,7 @@ fn program_clauses_for_trait<'a, 'tcx>(\n \n fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     if let ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n-        return Slice::empty();\n+        return List::empty();\n     }\n \n     // Rule Implemented-From-Impl (see rustc guide)"}, {"sha": "9624fc36e0eada9d06d78ebdc994ef6b5ec98834", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c7e5702021542f4b73b49f6023b33d1f0ef2eb/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=87c7e5702021542f4b73b49f6023b33d1f0ef2eb", "patch": "@@ -1666,7 +1666,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     /// we return `None`.\n     fn compute_object_lifetime_bound(&self,\n         span: Span,\n-        existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n+        existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>)\n         -> Option<ty::Region<'tcx>> // if None, use the default\n     {\n         let tcx = self.tcx();"}]}