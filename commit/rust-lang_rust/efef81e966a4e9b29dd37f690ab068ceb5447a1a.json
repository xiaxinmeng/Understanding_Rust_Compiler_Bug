{"sha": "efef81e966a4e9b29dd37f690ab068ceb5447a1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZWY4MWU5NjZhNGU5YjI5ZGQzN2Y2OTBhYjA2OGNlYjU0NDdhMWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-15T21:58:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-18T17:32:38Z"}, "message": "Stop checking the correctness of explicit self twice; instead, just\nuse simple pattern matching to take a guess at what the method's self\ncategory is in astconv, and check it more thoroughly later.", "tree": {"sha": "62043dfdc7efb6fed51d4f8e13aeed1d71b7b3c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62043dfdc7efb6fed51d4f8e13aeed1d71b7b3c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efef81e966a4e9b29dd37f690ab068ceb5447a1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efef81e966a4e9b29dd37f690ab068ceb5447a1a", "html_url": "https://github.com/rust-lang/rust/commit/efef81e966a4e9b29dd37f690ab068ceb5447a1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efef81e966a4e9b29dd37f690ab068ceb5447a1a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8a94c5dfaaf5f1dacc110bb81d292c4382554d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a94c5dfaaf5f1dacc110bb81d292c4382554d9", "html_url": "https://github.com/rust-lang/rust/commit/c8a94c5dfaaf5f1dacc110bb81d292c4382554d9"}], "stats": {"total": 126, "additions": 70, "deletions": 56}, "files": [{"sha": "90238f7913558ff65df7468c80976a153be8fd96", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 57, "deletions": 50, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/efef81e966a4e9b29dd37f690ab068ceb5447a1a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efef81e966a4e9b29dd37f690ab068ceb5447a1a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=efef81e966a4e9b29dd37f690ab068ceb5447a1a", "patch": "@@ -1215,8 +1215,9 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n                                     this: &AC,\n                                     rscope: &RS,\n                                     self_info: &SelfInfo)\n-                                    -> ty::ExplicitSelfCategory {\n-    match self_info.explicit_self.node {\n+                                    -> ty::ExplicitSelfCategory\n+{\n+    return match self_info.explicit_self.node {\n         ast::SelfStatic => ty::StaticExplicitSelfCategory,\n         ast::SelfValue(_) => ty::ByValueExplicitSelfCategory,\n         ast::SelfRegion(ref lifetime, mutability, _) => {\n@@ -1230,57 +1231,63 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n         ast::SelfExplicit(ref ast_type, _) => {\n             let explicit_type = ast_ty_to_ty(this, rscope, &**ast_type);\n \n-            {\n-                let inference_context = infer::new_infer_ctxt(this.tcx());\n-                let expected_self = self_info.untransformed_self_ty;\n-                let actual_self = explicit_type;\n-                let result = infer::mk_eqty(\n-                    &inference_context,\n-                    false,\n-                    infer::Misc(self_info.explicit_self.span),\n-                    expected_self,\n-                    actual_self);\n-                match result {\n-                    Ok(_) => {\n-                        inference_context.resolve_regions_and_report_errors();\n-                        return ty::ByValueExplicitSelfCategory\n-                    }\n-                    Err(_) => {}\n+            // We wish to (for now) categorize an explicit self\n+            // declaration like `self: SomeType` into either `self`,\n+            // `&self`, `&mut self`, or `Box<self>`. We do this here\n+            // by some simple pattern matching. A more precise check\n+            // is done later in `check_method_self_type()`.\n+            //\n+            // Examples:\n+            //\n+            // ```\n+            // impl Foo for &T {\n+            //     // Legal declarations:\n+            //     fn method1(self: &&T); // ByReferenceExplicitSelfCategory\n+            //     fn method2(self: &T); // ByValueExplicitSelfCategory\n+            //     fn method3(self: Box<&T>); // ByBoxExplicitSelfCategory\n+            //\n+            //     // Invalid cases will be caught later by `check_method_self_type`:\n+            //     fn method_err1(self: &mut T); // ByReferenceExplicitSelfCategory\n+            // }\n+            // ```\n+            //\n+            // To do the check we just count the number of \"modifiers\"\n+            // on each type and compare them. If they are the same or\n+            // the impl has more, we call it \"by value\". Otherwise, we\n+            // look at the outermost modifier on the method decl and\n+            // call it by-ref, by-box as appropriate. For method1, for\n+            // example, the impl type has one modifier, but the method\n+            // type has two, so we end up with\n+            // ByReferenceExplicitSelfCategory.\n+\n+            let impl_modifiers = count_modifiers(self_info.untransformed_self_ty);\n+            let method_modifiers = count_modifiers(explicit_type);\n+\n+            debug!(\"determine_explicit_self_category(self_info.untransformed_self_ty={} \\\n+                   explicit_type={} \\\n+                   modifiers=({},{})\",\n+                   self_info.untransformed_self_ty.repr(this.tcx()),\n+                   explicit_type.repr(this.tcx()),\n+                   impl_modifiers,\n+                   method_modifiers);\n+\n+            if impl_modifiers >= method_modifiers {\n+                ty::ByValueExplicitSelfCategory\n+            } else {\n+                match ty::get(explicit_type).sty {\n+                    ty::ty_rptr(r, mt) => ty::ByReferenceExplicitSelfCategory(r, mt.mutbl),\n+                    ty::ty_uniq(_) => ty::ByBoxExplicitSelfCategory,\n+                    _ => ty::ByValueExplicitSelfCategory,\n                 }\n             }\n+        }\n+    };\n \n-            match ty::get(explicit_type).sty {\n-                ty::ty_rptr(region, tm) => {\n-                    typeck::require_same_types(\n-                        this.tcx(),\n-                        None,\n-                        false,\n-                        self_info.explicit_self.span,\n-                        self_info.untransformed_self_ty,\n-                        tm.ty,\n-                        || \"not a valid type for `self`\".to_string());\n-                    return ty::ByReferenceExplicitSelfCategory(region,\n-                                                               tm.mutbl)\n-                }\n-                ty::ty_uniq(typ) => {\n-                    typeck::require_same_types(\n-                        this.tcx(),\n-                        None,\n-                        false,\n-                        self_info.explicit_self.span,\n-                        self_info.untransformed_self_ty,\n-                        typ,\n-                        || \"not a valid type for `self`\".to_string());\n-                    return ty::ByBoxExplicitSelfCategory\n-                }\n-                _ => {\n-                    this.tcx()\n-                        .sess\n-                        .span_err(self_info.explicit_self.span,\n-                                  \"not a valid type for `self`\");\n-                    return ty::ByValueExplicitSelfCategory\n-                }\n-            }\n+    fn count_modifiers(ty: ty::t) -> uint {\n+        match ty::get(ty).sty {\n+            ty::ty_rptr(_, mt) => count_modifiers(mt.ty) + 1,\n+            ty::ty_uniq(t) => count_modifiers(t) + 1,\n+            _ => 0,\n         }\n     }\n }"}, {"sha": "9b2264b8902a3614b2c2c4441fd0f319fcb7b349", "filename": "src/test/compile-fail/explicit-self-lifetime-mismatch.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efef81e966a4e9b29dd37f690ab068ceb5447a1a/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efef81e966a4e9b29dd37f690ab068ceb5447a1a/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs?ref=efef81e966a4e9b29dd37f690ab068ceb5447a1a", "patch": "@@ -14,12 +14,9 @@ struct Foo<'a,'b> {\n }\n \n impl<'a,'b> Foo<'a,'b> {\n-    // The number of errors is related to the way invariance works.\n     fn bar(self: Foo<'b,'a>) {}\n     //~^ ERROR mismatched types: expected `Foo<'a, 'b>`, found `Foo<'b, 'a>`\n     //~^^ ERROR mismatched types: expected `Foo<'a, 'b>`, found `Foo<'b, 'a>`\n-    //~^^^ ERROR mismatched types: expected `Foo<'b, 'a>`, found `Foo<'a, 'b>`\n-    //~^^^^ ERROR mismatched types: expected `Foo<'b, 'a>`, found `Foo<'a, 'b>`\n }\n \n fn main() {}"}, {"sha": "8d3610affdfb967aa4f0539b7c5bf6a5c85449f8", "filename": "src/test/compile-fail/ufcs-explicit-self-bad.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efef81e966a4e9b29dd37f690ab068ceb5447a1a/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efef81e966a4e9b29dd37f690ab068ceb5447a1a/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs?ref=efef81e966a4e9b29dd37f690ab068ceb5447a1a", "patch": "@@ -14,7 +14,6 @@ struct Foo {\n \n impl Foo {\n     fn foo(self: int, x: int) -> int {  //~ ERROR mismatched self type\n-//~^ ERROR not a valid type for `self`\n         self.f + x\n     }\n }\n@@ -25,15 +24,26 @@ struct Bar<T> {\n \n impl<T> Bar<T> {\n     fn foo(self: Bar<int>, x: int) -> int { //~ ERROR mismatched self type\n-//~^ ERROR not a valid type for `self`\n         x\n     }\n     fn bar(self: &Bar<uint>, x: int) -> int {   //~ ERROR mismatched self type\n-//~^ ERROR not a valid type for `self`\n         x\n     }\n }\n \n+trait SomeTrait {\n+    fn dummy1(&self);\n+    fn dummy2(&self);\n+    fn dummy3(&self);\n+}\n+\n+impl<'a, T> SomeTrait for &'a Bar<T> {\n+    fn dummy1(self: &&'a Bar<T>) { }\n+    fn dummy2(self: &Bar<T>) {} //~ ERROR mismatched self type\n+    fn dummy3(self: &&Bar<T>) {} //~ ERROR lifetime mismatch\n+    //~^ ERROR lifetime mismatch\n+}\n+\n fn main() {\n     let foo = box Foo {\n         f: 1,"}]}