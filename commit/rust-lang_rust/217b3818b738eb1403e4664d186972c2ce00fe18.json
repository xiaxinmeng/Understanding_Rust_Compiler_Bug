{"sha": "217b3818b738eb1403e4664d186972c2ce00fe18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxN2IzODE4YjczOGViMTQwM2U0NjY0ZDE4Njk3MmMyY2UwMGZlMTg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-09-05T08:38:49Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-09-05T08:38:49Z"}, "message": "Rustup to rustc 1.48.0-nightly (c59199efc 2020-09-04)", "tree": {"sha": "313f397821059035128f44e12270f63f641156a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/313f397821059035128f44e12270f63f641156a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/217b3818b738eb1403e4664d186972c2ce00fe18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/217b3818b738eb1403e4664d186972c2ce00fe18", "html_url": "https://github.com/rust-lang/rust/commit/217b3818b738eb1403e4664d186972c2ce00fe18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/217b3818b738eb1403e4664d186972c2ce00fe18/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9b0d5119b5d32deb433b332dfee1eaf4283c561", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b0d5119b5d32deb433b332dfee1eaf4283c561", "html_url": "https://github.com/rust-lang/rust/commit/c9b0d5119b5d32deb433b332dfee1eaf4283c561"}], "stats": {"total": 200, "additions": 120, "deletions": 80}, "files": [{"sha": "a6cde8fdea0972b338dcd5d4562e8642761af011", "filename": "Cargo.lock", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -1,10 +1,16 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+[[package]]\n+name = \"adler\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e\"\n+\n [[package]]\n name = \"ahash\"\n-version = \"0.3.8\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e8fd72866655d1904d6b0997d0b07ba561047d070fbe29de039031c641b61217\"\n+checksum = \"6d66721683190aeea775c737eee925aea24719058d86d815e8ee121dd9f37d19\"\n \n [[package]]\n name = \"anyhow\"\n@@ -182,6 +188,18 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"flate2\"\n+version = \"1.0.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"766d0e77a2c1502169d4a93ff3b8c15a71fd946cd0126309752104e5f3c46d94\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crc32fast\",\n+ \"libc\",\n+ \"miniz_oxide\",\n+]\n+\n [[package]]\n name = \"gcc\"\n version = \"0.3.55\"\n@@ -203,18 +221,26 @@ version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"34f595585f103464d8d2f6e9864682d74c1601fed5e07d62b1c9058dba8246fb\"\n dependencies = [\n- \"ahash\",\n  \"autocfg\",\n ]\n \n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"00d63df3d41950fb462ed38308eea019113ad1508da725bbedcd0fa5a85ef5f7\"\n+dependencies = [\n+ \"ahash\",\n+]\n+\n [[package]]\n name = \"indexmap\"\n version = \"1.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5b88cd59ee5f71fea89a62248fc8f387d44400cefe05ef548466d61ced9029a7\"\n dependencies = [\n  \"autocfg\",\n- \"hashbrown\",\n+ \"hashbrown 0.8.1\",\n ]\n \n [[package]]\n@@ -250,6 +276,15 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"miniz_oxide\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4d7559a8a40d0f97e1edea3220f698f78b1c5ab67532e49f68fde3910323b722\"\n+dependencies = [\n+ \"adler\",\n+]\n+\n [[package]]\n name = \"object\"\n version = \"0.21.1\"\n@@ -331,8 +366,9 @@ dependencies = [\n  \"cranelift-module\",\n  \"cranelift-object\",\n  \"cranelift-simplejit\",\n+ \"flate2\",\n  \"gimli\",\n- \"hashbrown\",\n+ \"hashbrown 0.9.0\",\n  \"indexmap\",\n  \"libloading\",\n  \"object\","}, {"sha": "7466da7b8718de4f931999a47ddb10cfbf674a65", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -24,6 +24,7 @@ indexmap = \"1.0.2\"\n cfg-if = \"0.1.10\"\n libloading = { version = \"0.6.0\", optional = true }\n hashbrown = \"0.9.0\"\n+flate2 = \"1.0.17\"\n \n # Uncomment to use local checkout of cranelift\n #[patch.\"https://github.com/bytecodealliance/wasmtime/\"]"}, {"sha": "44f31b7cd925877c0584251811c0deed5464e86e", "filename": "build_sysroot/Cargo.lock", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/build_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/build_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.lock?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n \n [[package]]\n name = \"autocfg\"\n-version = \"1.0.0\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d\"\n+checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.58\"\n+version = \"1.0.59\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f9a06fb2e53271d7c279ec1efea6ab691c35a2ae67ec0d91d7acec0caf13b518\"\n+checksum = \"66120af515773fb005778dc07c261bd201ec8ce50bd6e7144c927753fe013381\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -63,9 +63,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.32\"\n+version = \"0.1.35\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7bc4ac2c824d2bfc612cba57708198547e9a26943af0632aff033e0693074d5c\"\n+checksum = \"e3fcd8aba10d17504c87ef12d4f62ef404c6a4703d16682a9eb5543e6cf24455\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -142,18 +142,18 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.74\"\n+version = \"0.2.76\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2f02823cf78b754822df5f7f268fb59822e7296276d3e069d8e8cb26a14bd10\"\n+checksum = \"755456fae044e6fa1ebbbd1b3e902ae19e73097ed4ed87bb79934a867c007bc3\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.4.0\"\n+version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"be0f75932c1f6cfae3c04000e40114adf955636e19040f9c0a2c380702aa1c7f\"\n+checksum = \"4d7559a8a40d0f97e1edea3220f698f78b1c5ab67532e49f68fde3910323b722\"\n dependencies = [\n  \"adler\",\n  \"compiler_builtins\","}, {"sha": "1894600e31aa90994dc6f7b4c2303c6fedc9b902", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -1 +1 @@\n-nightly-2020-08-23\n+nightly-2020-09-05"}, {"sha": "d0215ba94dd05dba9c8ceea58dcf6d6b66f0dde9", "filename": "src/abi/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -20,14 +20,14 @@ pub(crate) fn fn_sig_for_fn_abi<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx\n \n     // FIXME(davidtwco,eddyb): A `ParamEnv` should be passed through to this function.\n     let ty = instance.ty(tcx, ty::ParamEnv::reveal_all());\n-    match ty.kind {\n+    match *ty.kind() {\n         ty::FnDef(..) => {\n             // HACK(davidtwco,eddyb): This is a workaround for polymorphization considering\n             // parameters unused if they show up in the signature, but not in the `mir::Body`\n             // (i.e. due to being inside a projection that got normalized, see\n             // `src/test/ui/polymorphization/normalized_sig_types.rs`), and codegen not keeping\n             // track of a polymorphization `ParamEnv` to allow normalizing later.\n-            let mut sig = match ty.kind {\n+            let mut sig = match *ty.kind() {\n                 ty::FnDef(def_id, substs) => tcx\n                     .normalize_erasing_regions(tcx.param_env(def_id), tcx.fn_sig(def_id))\n                     .subst(tcx, substs),\n@@ -65,13 +65,13 @@ pub(crate) fn fn_sig_for_fn_abi<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx\n             let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n             let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n \n-            let pin_did = tcx.require_lang_item(rustc_hir::LangItem::PinTypeLangItem, None);\n+            let pin_did = tcx.require_lang_item(rustc_hir::LangItem::Pin, None);\n             let pin_adt_ref = tcx.adt_def(pin_did);\n             let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n             let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n \n             sig.map_bound(|sig| {\n-                let state_did = tcx.require_lang_item(rustc_hir::LangItem::GeneratorStateLangItem, None);\n+                let state_did = tcx.require_lang_item(rustc_hir::LangItem::GeneratorState, None);\n                 let state_adt_ref = tcx.adt_def(state_did);\n                 let state_substs =\n                     tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n@@ -116,7 +116,7 @@ fn clif_sig_from_fn_sig<'tcx>(\n         Abi::SysV64 => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n         Abi::RustCall => {\n             assert_eq!(sig.inputs().len(), 2);\n-            let extra_args = match sig.inputs().last().unwrap().kind {\n+            let extra_args = match sig.inputs().last().unwrap().kind() {\n                 ty::Tuple(ref tupled_arguments) => tupled_arguments,\n                 _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n             };\n@@ -307,7 +307,7 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n             })\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n-        let return_tys = if let ty::Tuple(tup) = return_ty.kind {\n+        let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n             tup.types().map(|ty| self.clif_type(ty).unwrap()).collect()\n         } else {\n             vec![self.clif_type(return_ty).unwrap()]\n@@ -379,7 +379,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n                 // to reconstruct it into a tuple local variable, from multiple\n                 // individual function arguments.\n \n-                let tupled_arg_tys = match arg_ty.kind {\n+                let tupled_arg_tys = match arg_ty.kind() {\n                     ty::Tuple(ref tys) => tys,\n                     _ => bug!(\"spread argument isn't a tuple?! but {:?}\", arg_ty),\n                 };\n@@ -500,7 +500,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     let destination = destination.map(|(place, bb)| (trans_place(fx, place), bb));\n \n     // Handle special calls like instrinsics and empty drop glue.\n-    let instance = if let ty::FnDef(def_id, substs) = fn_ty.kind {\n+    let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n         let instance = ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n             .unwrap()\n             .unwrap()\n@@ -553,7 +553,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         let self_arg = trans_operand(fx, &args[0]);\n         let pack_arg = trans_operand(fx, &args[1]);\n \n-        let tupled_arguments = match pack_arg.layout().ty.kind {\n+        let tupled_arguments = match pack_arg.layout().ty.kind() {\n             ty::Tuple(ref tupled_arguments) => tupled_arguments,\n             _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n         };\n@@ -715,7 +715,7 @@ pub(crate) fn codegen_drop<'tcx>(\n         );\n         assert_eq!(fn_sig.output(), fx.tcx.mk_unit());\n \n-        match ty.kind {\n+        match ty.kind() {\n             ty::Dynamic(..) => {\n                 let (ptr, vtable) = drop_place.to_ptr_maybe_unsized();\n                 let ptr = ptr.get_addr(fx);"}, {"sha": "7aca709fba141ce3d5658410813cdc79030ad1ed", "filename": "src/base.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -281,7 +281,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                         let len = trans_operand(fx, len).load_scalar(fx);\n                         let index = trans_operand(fx, index).load_scalar(fx);\n                         args = [index, len, location];\n-                        rustc_hir::lang_items::PanicBoundsCheckFnLangItem\n+                        rustc_hir::LangItem::PanicBoundsCheck\n                     }\n                     _ => {\n                         let msg_str = msg.description();\n@@ -291,7 +291,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                             .ins()\n                             .iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n                         args = [msg_ptr, msg_len, location];\n-                        rustc_hir::lang_items::PanicFnLangItem\n+                        rustc_hir::LangItem::Panic\n                     }\n                 };\n \n@@ -322,7 +322,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n             } => {\n                 let discr = trans_operand(fx, discr).load_scalar(fx);\n \n-                if switch_ty.kind == fx.tcx.types.bool.kind {\n+                if switch_ty.kind() == fx.tcx.types.bool.kind() {\n                     assert_eq!(targets.len(), 2);\n                     let then_block = fx.get_block(targets[0]);\n                     let else_block = fx.get_block(targets[1]);\n@@ -504,7 +504,7 @@ fn trans_stmt<'tcx>(\n                     let layout = operand.layout();\n                     let val = operand.load_scalar(fx);\n                     let res = match un_op {\n-                        UnOp::Not => match layout.ty.kind {\n+                        UnOp::Not => match layout.ty.kind() {\n                             ty::Bool => {\n                                 let res = fx.bcx.ins().icmp_imm(IntCC::Equal, val, 0);\n                                 CValue::by_val(fx.bcx.ins().bint(types::I8, res), layout)\n@@ -514,7 +514,7 @@ fn trans_stmt<'tcx>(\n                             }\n                             _ => unreachable!(\"un op Not for {:?}\", layout.ty),\n                         },\n-                        UnOp::Neg => match layout.ty.kind {\n+                        UnOp::Neg => match layout.ty.kind() {\n                             ty::Int(IntTy::I128) => {\n                                 // FIXME remove this case once ineg.i128 works\n                                 let zero = CValue::const_val(fx, layout, 0);\n@@ -530,7 +530,7 @@ fn trans_stmt<'tcx>(\n                 Rvalue::Cast(CastKind::Pointer(PointerCast::ReifyFnPointer), operand, to_ty) => {\n                     let from_ty = fx.monomorphize(&operand.ty(&fx.mir.local_decls, fx.tcx));\n                     let to_layout = fx.layout_of(fx.monomorphize(to_ty));\n-                    match from_ty.kind {\n+                    match *from_ty.kind() {\n                         ty::FnDef(def_id, substs) => {\n                             let func_ref = fx.get_function_ref(\n                                 Instance::resolve_for_fn_ptr(\n@@ -585,10 +585,10 @@ fn trans_stmt<'tcx>(\n                             let (ptr, _extra) = operand.load_scalar_pair(fx);\n                             lval.write_cvalue(fx, CValue::by_val(ptr, dest_layout))\n                         }\n-                    } else if let ty::Adt(adt_def, _substs) = from_ty.kind {\n+                    } else if let ty::Adt(adt_def, _substs) = from_ty.kind() {\n                         // enum -> discriminant value\n                         assert!(adt_def.is_enum());\n-                        match to_ty.kind {\n+                        match to_ty.kind() {\n                             ty::Uint(_) | ty::Int(_) => {}\n                             _ => unreachable!(\"cast adt {} -> {}\", from_ty, to_ty),\n                         }\n@@ -658,7 +658,7 @@ fn trans_stmt<'tcx>(\n                     _to_ty,\n                 ) => {\n                     let operand = trans_operand(fx, operand);\n-                    match operand.layout().ty.kind {\n+                    match *operand.layout().ty.kind() {\n                         ty::Closure(def_id, substs) => {\n                             let instance = Instance::resolve_closure(\n                                 fx.tcx,\n@@ -706,8 +706,6 @@ fn trans_stmt<'tcx>(\n                     lval.write_cvalue(fx, CValue::by_val(len, usize_layout));\n                 }\n                 Rvalue::NullaryOp(NullOp::Box, content_ty) => {\n-                    use rustc_hir::lang_items::ExchangeMallocFnLangItem;\n-\n                     let usize_type = fx.clif_type(fx.tcx.types.usize).unwrap();\n                     let content_ty = fx.monomorphize(content_ty);\n                     let layout = fx.layout_of(content_ty);\n@@ -719,7 +717,11 @@ fn trans_stmt<'tcx>(\n                     let box_layout = fx.layout_of(fx.tcx.mk_box(content_ty));\n \n                     // Allocate space:\n-                    let def_id = match fx.tcx.lang_items().require(ExchangeMallocFnLangItem) {\n+                    let def_id = match fx\n+                        .tcx\n+                        .lang_items()\n+                        .require(rustc_hir::LangItem::ExchangeMalloc)\n+                    {\n                         Ok(id) => id,\n                         Err(s) => {\n                             fx.tcx\n@@ -868,7 +870,7 @@ fn codegen_array_len<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     place: CPlace<'tcx>,\n ) -> Value {\n-    match place.layout().ty.kind {\n+    match *place.layout().ty.kind() {\n         ty::Array(_elem_ty, len) => {\n             let len = fx\n                 .monomorphize(&len)\n@@ -907,25 +909,29 @@ pub(crate) fn trans_place<'tcx>(\n                 min_length: _,\n                 from_end,\n             } => {\n+                let offset: u64 = offset;\n                 let index = if !from_end {\n-                    fx.bcx.ins().iconst(fx.pointer_type, i64::from(offset))\n+                    fx.bcx.ins().iconst(fx.pointer_type, offset as i64)\n                 } else {\n                     let len = codegen_array_len(fx, cplace);\n-                    fx.bcx.ins().iadd_imm(len, -i64::from(offset))\n+                    fx.bcx.ins().iadd_imm(len, -(offset as i64))\n                 };\n                 cplace = cplace.place_index(fx, index);\n             }\n             PlaceElem::Subslice { from, to, from_end } => {\n                 // These indices are generated by slice patterns.\n                 // slice[from:-to] in Python terms.\n \n-                match cplace.layout().ty.kind {\n+                let from: u64 = from;\n+                let to: u64 = to;\n+\n+                match cplace.layout().ty.kind() {\n                     ty::Array(elem_ty, _len) => {\n                         assert!(!from_end, \"array subslices are never `from_end`\");\n                         let elem_layout = fx.layout_of(elem_ty);\n                         let ptr = cplace.to_ptr();\n                         cplace = CPlace::for_ptr(\n-                            ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * i64::from(from)),\n+                            ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * (from as i64)),\n                             fx.layout_of(fx.tcx.mk_array(elem_ty, u64::from(to) - u64::from(from))),\n                         );\n                     }\n@@ -935,10 +941,8 @@ pub(crate) fn trans_place<'tcx>(\n                         let (ptr, len) = cplace.to_ptr_maybe_unsized();\n                         let len = len.unwrap();\n                         cplace = CPlace::for_ptr_with_extra(\n-                            ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * i64::from(from)),\n-                            fx.bcx\n-                                .ins()\n-                                .iadd_imm(len, -(i64::from(from) + i64::from(to))),\n+                            ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * (from as i64)),\n+                            fx.bcx.ins().iadd_imm(len, -(from as i64 + to as i64)),\n                             cplace.layout(),\n                         );\n                     }"}, {"sha": "d4b5d660ba8d8f9a3ddedef6d86f98e796fa5e1e", "filename": "src/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -31,7 +31,7 @@ pub(crate) fn scalar_to_clif_type(tcx: TyCtxt<'_>, scalar: Scalar) -> Type {\n }\n \n fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Type> {\n-    Some(match ty.kind {\n+    Some(match ty.kind() {\n         ty::Bool => types::I8,\n         ty::Uint(size) => match size {\n             UintTy::U8 => types::I8,\n@@ -88,7 +88,7 @@ fn clif_pair_type_from_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<(types::Type, types::Type)> {\n-    Some(match ty.kind {\n+    Some(match ty.kind() {\n         ty::Tuple(substs) if substs.len() == 2 => {\n             let mut types = substs.types();\n             let a = clif_type_from_ty(tcx, types.next().unwrap())?;\n@@ -279,7 +279,7 @@ pub(crate) fn type_min_max_value(\n }\n \n pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..) | ty::Char | ty::Uint(..) | ty::Bool => false,\n         ty::Int(..) => true,\n         ty::Float(..) => false, // `signed` is unused for floats"}, {"sha": "70e0cf1a9e4ef6c5ccfcccbb08b694cec097e1e9", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -170,7 +170,7 @@ impl<'tcx> DebugContext<'tcx> {\n         let name = format!(\"{}\", ty);\n         let layout = self.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n \n-        let type_id = match ty.kind {\n+        let type_id = match ty.kind() {\n             ty::Bool => primitive(&mut self.dwarf, gimli::DW_ATE_boolean),\n             ty::Char => primitive(&mut self.dwarf, gimli::DW_ATE_UTF),\n             ty::Uint(_) => primitive(&mut self.dwarf, gimli::DW_ATE_unsigned),"}, {"sha": "ab1c888b4c00ce4acaa04744f532b15468e1590f", "filename": "src/intrinsics/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm.rs?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -87,7 +87,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n             };\n \n             simd_pair_for_each_lane(fx, x, y, ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind {\n+                let res_lane = match lane_layout.ty.kind() {\n                     ty::Float(_) => fx.bcx.ins().fcmp(flt_cc, x_lane, y_lane),\n                     _ => unreachable!(\"{:?}\", lane_layout.ty),\n                 };"}, {"sha": "fd95c25b572d5c6c4041a58fbcaf6cd750350333", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -141,7 +141,7 @@ macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $\n }\n \n macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n-    match $ty.kind {\n+    match $ty.kind() {\n         ty::Uint(_) | ty::Int(_) => {}\n         _ => {\n             $fx.tcx.sess.span_err(\n@@ -302,7 +302,7 @@ macro simd_cmp {\n                 $y,\n                 $ret,\n                 |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n-                    let res_lane = match lane_layout.ty.kind {\n+                    let res_lane = match lane_layout.ty.kind() {\n                         ty::Uint(_) | ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc, x_lane, y_lane),\n                         _ => unreachable!(\"{:?}\", lane_layout.ty),\n                     };\n@@ -319,7 +319,7 @@ macro simd_cmp {\n             $y,\n             $ret,\n             |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind {\n+                let res_lane = match lane_layout.ty.kind() {\n                     ty::Uint(_) => fx.bcx.ins().icmp(IntCC::$cc_u, x_lane, y_lane),\n                     ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc_s, x_lane, y_lane),\n                     _ => unreachable!(\"{:?}\", lane_layout.ty),\n@@ -341,7 +341,7 @@ macro simd_int_binop {\n             $y,\n             $ret,\n             |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind {\n+                let res_lane = match lane_layout.ty.kind() {\n                     ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n                     ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n                     _ => unreachable!(\"{:?}\", lane_layout.ty),\n@@ -363,7 +363,7 @@ macro simd_int_flt_binop {\n             $y,\n             $ret,\n             |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind {\n+                let res_lane = match lane_layout.ty.kind() {\n                     ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n                     ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n                     ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n@@ -382,7 +382,7 @@ macro simd_flt_binop($fx:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) {\n         $y,\n         $ret,\n         |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-            let res_lane = match lane_layout.ty.kind {\n+            let res_lane = match lane_layout.ty.kind() {\n                 ty::Float(_) => fx.bcx.ins().$op(x_lane, y_lane),\n                 _ => unreachable!(\"{:?}\", lane_layout.ty),\n             };"}, {"sha": "03a1629c1431b9e327c9456bafb4ef8d1b0329cc", "filename": "src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -9,7 +9,6 @@\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n \n-extern crate flate2;\n #[cfg(feature = \"jit\")]\n extern crate libc;\n #[macro_use]"}, {"sha": "520a54b8e53338380e8bffaf5bb88c873ea9528b", "filename": "src/main_shim.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -1,3 +1,6 @@\n+use rustc_hir::LangItem;\n+use rustc_session::config::EntryFnType;\n+\n use crate::prelude::*;\n \n /// Create the `main` function which will initialize the rust runtime and call\n@@ -7,9 +10,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n     module: &mut Module<impl Backend + 'static>,\n     unwind_context: &mut UnwindContext<'_>,\n ) {\n-    use rustc_hir::lang_items::StartFnLangItem;\n-    use rustc_session::config::EntryFnType;\n-\n     let (main_def_id, use_start_lang_item) = match tcx.entry_fn(LOCAL_CRATE) {\n         Some((def_id, entry_ty)) => (\n             def_id.to_def_id(),\n@@ -88,7 +88,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n             let call_inst = if use_start_lang_item {\n-                let start_def_id = tcx.require_lang_item(StartFnLangItem, None);\n+                let start_def_id = tcx.require_lang_item(LangItem::Start, None);\n                 let start_instance = Instance::resolve(\n                     tcx,\n                     ParamEnv::reveal_all(),"}, {"sha": "3c290026776d1204485d91fe95a29f762a600a6d", "filename": "src/num.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -59,15 +59,15 @@ pub(crate) fn codegen_binop<'tcx>(\n ) -> CValue<'tcx> {\n     match bin_op {\n         BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n-            match in_lhs.layout().ty.kind {\n+            match in_lhs.layout().ty.kind() {\n                 ty::Bool | ty::Uint(_) | ty::Int(_) | ty::Char => {\n                     let signed = type_sign(in_lhs.layout().ty);\n                     let lhs = in_lhs.load_scalar(fx);\n                     let rhs = in_rhs.load_scalar(fx);\n \n                     let (lhs, rhs) = if (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n-                        && (in_lhs.layout().ty.kind == fx.tcx.types.i8.kind\n-                            || in_lhs.layout().ty.kind == fx.tcx.types.i16.kind)\n+                        && (in_lhs.layout().ty.kind() == fx.tcx.types.i8.kind()\n+                            || in_lhs.layout().ty.kind() == fx.tcx.types.i16.kind())\n                     {\n                         // FIXME(CraneStation/cranelift#896) icmp_imm.i8/i16 with eq/ne for signed ints is implemented wrong.\n                         (\n@@ -86,7 +86,7 @@ pub(crate) fn codegen_binop<'tcx>(\n         _ => {}\n     }\n \n-    match in_lhs.layout().ty.kind {\n+    match in_lhs.layout().ty.kind() {\n         ty::Bool => crate::num::trans_bool_binop(fx, bin_op, in_lhs, in_rhs),\n         ty::Uint(_) | ty::Int(_) => crate::num::trans_int_binop(fx, bin_op, in_lhs, in_rhs),\n         ty::Float(_) => crate::num::trans_float_binop(fx, bin_op, in_lhs, in_rhs),\n@@ -373,7 +373,7 @@ pub(crate) fn trans_float_binop<'tcx>(\n         BinOp::Mul => b.fmul(lhs, rhs),\n         BinOp::Div => b.fdiv(lhs, rhs),\n         BinOp::Rem => {\n-            let name = match in_lhs.layout().ty.kind {\n+            let name = match in_lhs.layout().ty.kind() {\n                 ty::Float(FloatTy::F32) => \"fmodf\",\n                 ty::Float(FloatTy::F64) => \"fmod\",\n                 _ => bug!(),"}, {"sha": "962fcaf48efc3e6833649ef72409c8ff1dc6eaa9", "filename": "src/unsize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -17,7 +17,7 @@ pub(crate) fn unsized_info<'tcx>(\n     let (source, target) =\n         fx.tcx\n             .struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n-    match (&source.kind, &target.kind) {\n+    match (&source.kind(), &target.kind()) {\n         (&ty::Array(_, len), &ty::Slice(_)) => fx.bcx.ins().iconst(\n             fx.pointer_type,\n             len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64,\n@@ -46,7 +46,7 @@ fn unsize_thin_ptr<'tcx>(\n     src_layout: TyAndLayout<'tcx>,\n     dst_layout: TyAndLayout<'tcx>,\n ) -> (Value, Value) {\n-    match (&src_layout.ty.kind, &dst_layout.ty.kind) {\n+    match (&src_layout.ty.kind(), &dst_layout.ty.kind()) {\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _))\n         | (&ty::Ref(_, a, _), &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n@@ -105,7 +105,7 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n         };\n         dst.write_cvalue(fx, CValue::by_val_pair(base, info, dst.layout()));\n     };\n-    match (&src_ty.kind, &dst_ty.kind) {\n+    match (&src_ty.kind(), &dst_ty.kind()) {\n         (&ty::Ref(..), &ty::Ref(..))\n         | (&ty::Ref(..), &ty::RawPtr(..))\n         | (&ty::RawPtr(..), &ty::RawPtr(..)) => coerce_ptr(),\n@@ -153,7 +153,7 @@ pub(crate) fn size_and_align_of_dst<'tcx>(\n             .iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n         return (size, align);\n     }\n-    match layout.ty.kind {\n+    match layout.ty.kind() {\n         ty::Dynamic(..) => {\n             // load size/align from vtable\n             (\n@@ -199,7 +199,7 @@ pub(crate) fn size_and_align_of_dst<'tcx>(\n             let size = fx.bcx.ins().iadd_imm(unsized_size, sized_size as i64);\n \n             // Packed types ignore the alignment of their fields.\n-            if let ty::Adt(def, _) = layout.ty.kind {\n+            if let ty::Adt(def, _) = layout.ty.kind() {\n                 if def.repr.packed() {\n                     unsized_align = sized_align;\n                 }"}, {"sha": "765c482e83cdbc840cdb50437b2f61531f5e3079", "filename": "src/value_and_place.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217b3818b738eb1403e4664d186972c2ce00fe18/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=217b3818b738eb1403e4664d186972c2ce00fe18", "patch": "@@ -24,7 +24,7 @@ fn codegen_field<'tcx>(\n         if !field_layout.is_unsized() {\n             return simple(fx);\n         }\n-        match field_layout.ty.kind {\n+        match field_layout.ty.kind() {\n             ty::Slice(..) | ty::Str | ty::Foreign(..) => return simple(fx),\n             ty::Adt(def, _) if def.repr.packed() => {\n                 assert_eq!(layout.align.abi.bytes(), 1);\n@@ -235,7 +235,7 @@ impl<'tcx> CValue<'tcx> {\n \n         let clif_ty = fx.clif_type(layout.ty).unwrap();\n \n-        match layout.ty.kind {\n+        match layout.ty.kind() {\n             ty::Bool => {\n                 assert!(\n                     const_val == 0 || const_val == 1,\n@@ -246,7 +246,7 @@ impl<'tcx> CValue<'tcx> {\n             _ => {}\n         }\n \n-        let val = match layout.ty.kind {\n+        let val = match layout.ty.kind() {\n             ty::Uint(UintTy::U128) | ty::Int(IntTy::I128) => {\n                 let lsb = fx.bcx.ins().iconst(types::I64, const_val as u64 as i64);\n                 let msb = fx\n@@ -279,11 +279,11 @@ impl<'tcx> CValue<'tcx> {\n \n     pub(crate) fn cast_pointer_to(self, layout: TyAndLayout<'tcx>) -> Self {\n         assert!(matches!(\n-            self.layout().ty.kind,\n+            self.layout().ty.kind(),\n             ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n         ));\n         assert!(matches!(\n-            layout.ty.kind,\n+            layout.ty.kind(),\n             ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n         ));\n         assert_eq!(self.layout().abi, layout.abi);\n@@ -454,7 +454,7 @@ impl<'tcx> CPlace<'tcx> {\n             from_ty: Ty<'tcx>,\n             to_ty: Ty<'tcx>,\n         ) {\n-            match (&from_ty.kind, &to_ty.kind) {\n+            match (&from_ty.kind(), &to_ty.kind()) {\n                 (ty::Ref(_, a, _), ty::Ref(_, b, _))\n                 | (\n                     ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n@@ -716,7 +716,7 @@ impl<'tcx> CPlace<'tcx> {\n         fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n         index: Value,\n     ) -> CPlace<'tcx> {\n-        let (elem_layout, ptr) = match self.layout().ty.kind {\n+        let (elem_layout, ptr) = match self.layout().ty.kind() {\n             ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.to_ptr()),\n             ty::Slice(elem_ty) => (fx.layout_of(elem_ty), self.to_ptr_maybe_unsized().0),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),"}]}