{"sha": "a6264002637f60322d17329eaf4a25b9abe2c638", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MjY0MDAyNjM3ZjYwMzIyZDE3MzI5ZWFmNGEyNWI5YWJlMmM2Mzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-17T12:32:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-17T12:32:47Z"}, "message": "Auto merge of #33049 - Manishearth:rollup, r=Manishearth\n\nRollup of 10 pull requests\n\n- Successful merges: #31441, #32956, #33003, #33022, #33023, #33032, #33039, #33044, #33045, #33046\n- Failed merges:", "tree": {"sha": "1f9dd84192aec21329dca55d56d508771f31c5c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f9dd84192aec21329dca55d56d508771f31c5c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6264002637f60322d17329eaf4a25b9abe2c638", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6264002637f60322d17329eaf4a25b9abe2c638", "html_url": "https://github.com/rust-lang/rust/commit/a6264002637f60322d17329eaf4a25b9abe2c638", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6264002637f60322d17329eaf4a25b9abe2c638/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f207ddb9bf22b5832e660183aee74c6356edee1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f207ddb9bf22b5832e660183aee74c6356edee1c", "html_url": "https://github.com/rust-lang/rust/commit/f207ddb9bf22b5832e660183aee74c6356edee1c"}, {"sha": "e1db767dbca8106de05e28143835f361d39966fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1db767dbca8106de05e28143835f361d39966fd", "html_url": "https://github.com/rust-lang/rust/commit/e1db767dbca8106de05e28143835f361d39966fd"}], "stats": {"total": 767, "additions": 542, "deletions": 225}, "files": [{"sha": "9d61feef81a80ec2fdc1a753f4e275f185543441", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -307,7 +307,7 @@ are:\n [gsearchdocs]: https://www.google.com/search?q=site:doc.rust-lang.org+your+query+here\n [rif]: http://internals.rust-lang.org\n [rr]: https://doc.rust-lang.org/book/README.html\n-[tlgba]: http://tomlee.co/2014/04/03/a-more-detailed-tour-of-the-rust-compiler/\n+[tlgba]: http://tomlee.co/2014/04/a-more-detailed-tour-of-the-rust-compiler/\n [ro]: http://www.rustaceans.org/\n [rctd]: ./COMPILER_TESTS.md\n [cheatsheet]: http://buildbot.rust-lang.org/homu/"}, {"sha": "7056a6c0f1708f42579dd0bc33ce7fb212aa7323", "filename": "src/doc/book/casting-between-types.md", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcasting-between-types.md?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -165,10 +165,15 @@ Rust lets us:\n ```rust\n use std::mem;\n \n-unsafe {\n-    let a = [0u8, 0u8, 0u8, 0u8];\n-\n-    let b = mem::transmute::<[u8; 4], u32>(a);\n+fn main() {\n+    unsafe {\n+        let a = [0u8, 1u8, 0u8, 0u8];\n+        let b = mem::transmute::<[u8; 4], u32>(a);\n+        println!(\"{}\", b); // 256\n+        // or, more concisely:\n+        let c: u32 = mem::transmute(a);\n+        println!(\"{}\", c); // 256\n+    }\n }\n ```\n "}, {"sha": "ad34de9e3df97b2b9a954785010ee797dab87eb3", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 176, "deletions": 5, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -31,6 +31,16 @@\n // Since Rust doesn't actually have dependent types and polymorphic recursion,\n // we make do with lots of unsafety.\n \n+// A major goal of this module is to avoid complexity by treating the tree as a generic (if\n+// weirdly shaped) container and avoiding dealing with most of the B-Tree invariants. As such,\n+// this module doesn't care whether the entries are sorted, which nodes can be underfull, or\n+// even what underfull means. However, we do rely on a few invariants:\n+//\n+// - Trees must have uniform depth/height. This means that every path down to a leaf from a\n+//   given node has exactly the same length.\n+// - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n+//   This implies that even an empty internal node has at least one edge.\n+\n use alloc::heap;\n use core::marker::PhantomData;\n use core::mem;\n@@ -43,17 +53,43 @@ use boxed::Box;\n const B: usize = 6;\n pub const CAPACITY: usize = 2 * B - 1;\n \n+/// The underlying representation of leaf nodes. Note that it is often unsafe to actually store\n+/// these, since only the first `len` keys and values are assumed to be initialized. As such,\n+/// these should always be put behind pointers, and specifically behind `BoxedNode` in the owned\n+/// case.\n+///\n+/// See also rust-lang/rfcs#197, which would make this structure significantly more safe by\n+/// avoiding accidentally dropping unused and uninitialized keys and values.\n struct LeafNode<K, V> {\n+    /// The arrays storing the actual data of the node. Only the first `len` elements of each\n+    /// array are initialized and valid.\n     keys: [K; CAPACITY],\n     vals: [V; CAPACITY],\n+\n+    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n+    /// This either points to an actual node or is null.\n     parent: *const InternalNode<K, V>,\n+\n+    /// This node's index into the parent node's `edges` array.\n+    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n+    /// This is only guaranteed to be initialized when `parent` is nonnull.\n     parent_idx: u16,\n+\n+    /// The number of keys and values this node stores.\n+    ///\n+    /// This is at the end of the node's representation and next to `parent_idx` to encourage\n+    /// the compiler to join `len` and `parent_idx` into the same 32-bit word, reducing space\n+    /// overhead.\n     len: u16,\n }\n \n impl<K, V> LeafNode<K, V> {\n+    /// Creates a new `LeafNode`. Unsafe because all nodes should really be hidden behind\n+    /// `BoxedNode`, preventing accidental dropping of uninitialized keys and values.\n     unsafe fn new() -> Self {\n         LeafNode {\n+            // As a general policy, we leave fields uninitialized if they can be, as this should\n+            // be both slightly faster and easier to track in Valgrind.\n             keys: mem::uninitialized(),\n             vals: mem::uninitialized(),\n             parent: ptr::null(),\n@@ -63,15 +99,28 @@ impl<K, V> LeafNode<K, V> {\n     }\n }\n \n-// We use repr(C) so that a pointer to an internal node can be\n-// directly used as a pointer to a leaf node\n+/// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n+/// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n+/// `InternalNode` can be directly casted to a pointer to the underlying `LeafNode` portion of the\n+/// node, allowing code to act on leaf and internal nodes generically without having to even check\n+/// which of the two a pointer is pointing at. This property is enabled by the use of `repr(C)`.\n #[repr(C)]\n struct InternalNode<K, V> {\n     data: LeafNode<K, V>,\n+\n+    /// The pointers to the children of this node. `len + 1` of these are considered\n+    /// initialized and valid.\n     edges: [BoxedNode<K, V>; 2 * B],\n }\n \n impl<K, V> InternalNode<K, V> {\n+    /// Creates a new `InternalNode`.\n+    ///\n+    /// This is unsafe for two reasons. First, it returns an `InternalNode` by value, risking\n+    /// dropping of uninitialized fields. Second, an invariant of internal nodes is that `len + 1`\n+    /// edges are initialized and valid, meaning that even when the node is empty (having a\n+    /// `len` of 0), there must be one initialized and valid edge. This function does not set up\n+    /// such an edge.\n     unsafe fn new() -> Self {\n         InternalNode {\n             data: LeafNode::new(),\n@@ -80,8 +129,12 @@ impl<K, V> InternalNode<K, V> {\n     }\n }\n \n+/// An owned pointer to a node. This basically is either `Box<LeafNode<K, V>>` or\n+/// `Box<InternalNode<K, V>>`. However, it contains no information as to which of the two types\n+/// of nodes is acutally behind the box, and, partially due to this lack of information, has no\n+/// destructor.\n struct BoxedNode<K, V> {\n-    ptr: Unique<LeafNode<K, V>> // we don't know if this points to a leaf node or an internal node\n+    ptr: Unique<LeafNode<K, V>>\n }\n \n impl<K, V> BoxedNode<K, V> {\n@@ -156,7 +209,7 @@ impl<K, V> Root<K, V> {\n         }\n     }\n \n-    /// Add a new internal node with a single edge, pointing to the previous root, and make that\n+    /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n     /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n     pub fn push_level(&mut self)\n             -> NodeRef<marker::Mut, K, V, marker::Internal> {\n@@ -180,7 +233,7 @@ impl<K, V> Root<K, V> {\n         ret\n     }\n \n-    ///\u00a0Remove the root node, using its first child as the new root. This cannot be called when\n+    /// Removes the root node, using its first child as the new root. This cannot be called when\n     /// the tree consists only of a leaf node. As it is intended only to be called when the root\n     /// has only one edge, no cleanup is done on any of the other children are elements of the root.\n     /// This decreases the height by 1 and is the opposite of `push_level`.\n@@ -229,6 +282,7 @@ impl<K, V> Root<K, V> {\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n     node: NonZero<*const LeafNode<K, V>>,\n+    // This is null unless the borrow type is `Mut`\n     root: *const Root<K, V>,\n     _marker: PhantomData<(BorrowType, Type)>\n }\n@@ -268,10 +322,14 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n \n \n impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n+    /// Finds the length of the node. This is the number of keys or values. In an\n+    /// internal node, the number of edges is `len() + 1`.\n     pub fn len(&self) -> usize {\n         self.as_leaf().len as usize\n     }\n \n+    /// Removes any static information about whether this node is a `Leaf` or an\n+    /// `Internal` node.\n     pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n@@ -281,6 +339,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n+    /// Temporarily takes out another, immutable reference to the same node.\n     fn reborrow<'a>(&'a self) -> NodeRef<marker::Immut<'a>, K, V, Type> {\n         NodeRef {\n             height: self.height,\n@@ -304,6 +363,13 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         self.reborrow().into_slices().1\n     }\n \n+    /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n+    /// node actually has a parent, where `handle` points to the edge of the parent\n+    /// that points to the current node. Returns `Err(self)` if the current node has\n+    /// no parent, giving back the original `NodeRef`.\n+    ///\n+    /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n+    /// both, upon success, do nothing.\n     pub fn ascend(self) -> Result<\n         Handle<\n             NodeRef<\n@@ -344,6 +410,9 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n+    /// Similar to `ascend`, gets a reference to a node's parent node, but also\n+    /// deallocate the current node in the process. This is unsafe because the\n+    /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(self) -> Option<\n         Handle<\n             NodeRef<\n@@ -362,6 +431,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n+    /// Similar to `ascend`, gets a reference to a node's parent node, but also\n+    /// deallocate the current node in the process. This is unsafe because the\n+    /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(self) -> Option<\n         Handle<\n             NodeRef<\n@@ -384,6 +456,8 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n }\n \n impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Unsafely asserts to the compiler some static information about whether this\n+    /// node is a `Leaf`.\n     unsafe fn cast_unchecked<NewType>(&mut self)\n             -> NodeRef<marker::Mut, K, V, NewType> {\n \n@@ -395,6 +469,16 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// Temporarily takes out another, mutable reference to the same node. Beware, as\n+    /// this method is very dangerous, doubly so since it may not immediately appear\n+    /// dangerous.\n+    ///\n+    /// Because mutable pointers can roam anywhere around the tree and can even (through\n+    /// `into_root_mut`) mess with the root of the tree, the result of `reborrow_mut`\n+    /// can easily be used to make the original mutable pointer dangling, or, in the case\n+    /// of a reborrowed handle, out of bounds.\n+    // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n+    // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n     unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut, K, V, Type> {\n         NodeRef {\n             height: self.height,\n@@ -437,6 +521,8 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Gets a mutable reference to the root itself. This is useful primarily when the\n+    /// height of the tree needs to be adjusted. Never call this on a reborrowed pointer.\n     pub fn into_root_mut(self) -> &'a mut Root<K, V> {\n         unsafe {\n             &mut *(self.root as *mut Root<K, V>)\n@@ -460,6 +546,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n+    /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n@@ -474,6 +561,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         self.as_leaf_mut().len += 1;\n     }\n \n+    /// Adds a key/value pair to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n@@ -488,6 +576,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// Adds a key/value pair and an edge to go to the right of that pair to\n+    /// the end of the node.\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n@@ -506,6 +596,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         }\n     }\n \n+    /// Adds a key/value pair and an edge to go to the left of that pair to\n+    /// the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n@@ -534,6 +626,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Removes a key/value pair from the end of this node. If this is an internal node,\n+    /// also removes the edge that was to the right of that pair.\n     pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() > 0);\n@@ -558,6 +652,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n+    /// Removes a key/value pair from the beginning of this node. If this is an internal node,\n+    /// also removes the edge that was to the left of that pair.\n     pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() > 0);\n@@ -597,6 +693,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n }\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Checks whether a node is an `Internal` node or a `Leaf` node.\n     pub fn force(self) -> ForceResult<\n         NodeRef<BorrowType, K, V, marker::Leaf>,\n         NodeRef<BorrowType, K, V, marker::Internal>\n@@ -619,26 +716,38 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     }\n }\n \n+/// A reference to a specific key/value pair or edge within a node. The `Node` parameter\n+/// must be a `NodeRef`, while the `Type` can either be `KV` (signifying a handle on a key/value\n+/// pair) or `Edge` (signifying a handle on an edge).\n+///\n+/// Note that even `Leaf` nodes can have `Edge` handles. Instead of representing a pointer to\n+/// a child node, these represent the spaces where child pointers would go between the key/value\n+/// pairs. For example, in a node with length 2, there would be 3 possible edge locations - one\n+/// to the left of the node, one between the two pairs, and one at the right of the node.\n pub struct Handle<Node, Type> {\n     node: Node,\n     idx: usize,\n     _marker: PhantomData<Type>\n }\n \n impl<Node: Copy, Type> Copy for Handle<Node, Type> { }\n+// We don't need the full generality of `#[derive(Clone)]`, as the only time `Node` will be\n+// `Clone`able is when it is an immutable reference and therefore `Copy`.\n impl<Node: Copy, Type> Clone for Handle<Node, Type> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n impl<Node, Type> Handle<Node, Type> {\n+    /// Retrieves the node that contains the edge of key/value pair this handle pointes to.\n     pub fn into_node(self) -> Node {\n         self.node\n     }\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n+    /// Creates a new handle to a key/value pair in `node`. `idx` must be less than `node.len()`.\n     pub fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         // Necessary for correctness, but in a private module\n         debug_assert!(idx < node.len());\n@@ -670,6 +779,7 @@ impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n impl<BorrowType, K, V, NodeType, HandleType>\n         Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType> {\n \n+    /// Temporarily takes out another, immutable handle on the same location.\n     pub fn reborrow(&self)\n             -> Handle<NodeRef<marker::Immut, K, V, NodeType>, HandleType> {\n \n@@ -685,6 +795,16 @@ impl<BorrowType, K, V, NodeType, HandleType>\n impl<'a, K, V, NodeType, HandleType>\n         Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n \n+    /// Temporarily takes out another, mutable handle on the same location. Beware, as\n+    /// this method is very dangerous, doubly so since it may not immediately appear\n+    /// dangerous.\n+    ///\n+    /// Because mutable pointers can roam anywhere around the tree and can even (through\n+    /// `into_root_mut`) mess with the root of the tree, the result of `reborrow_mut`\n+    /// can easily be used to make the original mutable pointer dangling, or, in the case\n+    /// of a reborrowed handle, out of bounds.\n+    // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n+    // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n     pub unsafe fn reborrow_mut(&mut self)\n             -> Handle<NodeRef<marker::Mut, K, V, NodeType>, HandleType> {\n \n@@ -700,6 +820,8 @@ impl<'a, K, V, NodeType, HandleType>\n impl<BorrowType, K, V, NodeType>\n         Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n \n+    /// Creates a new handle to an edge in `node`. `idx` must be less than or equal to\n+    /// `node.len()`.\n     pub fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         // Necessary for correctness, but in a private module\n         debug_assert!(idx <= node.len());\n@@ -733,6 +855,11 @@ impl<BorrowType, K, V, NodeType>\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// this edge. This method assumes that there is enough space in the node for the new\n+    /// pair to fit.\n+    ///\n+    /// The returned pointer points to the inserted value.\n     fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n@@ -747,6 +874,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n         }\n     }\n \n+    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// this edge. This method splits the node if there isn't enough room.\n+    ///\n+    /// The returned pointer points to the inserted value.\n     pub fn insert(mut self, key: K, val: V)\n             -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n \n@@ -774,6 +905,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n+    /// Fixes the parent pointer and index in the child node below this edge. This is useful\n+    /// when the ordering of edges has been changed, such as in the various `insert` methods.\n     fn correct_parent_link(mut self) {\n         let idx = self.idx as u16;\n         let ptr = self.node.as_internal_mut() as *mut _;\n@@ -782,18 +915,24 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         child.as_leaf_mut().parent_idx = idx;\n     }\n \n+    /// Unsafely asserts to the compiler some static information about whether the underlying\n+    /// node of this handle is a `Leaf`.\n     unsafe fn cast_unchecked<NewType>(&mut self)\n             -> Handle<NodeRef<marker::Mut, K, V, NewType>, marker::Edge> {\n \n         Handle::new_edge(self.node.cast_unchecked(), self.idx)\n     }\n \n+    /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n+    /// between this edge and the key/value pair to the right of this edge. This method assumes\n+    /// that there is enough space in the node for the new pair to fit.\n     fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but in an internal module\n         debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n+            // This cast is a lie, but it allows us to reuse the key/value insertion logic.\n             self.cast_unchecked::<marker::Leaf>().insert_fit(key, val);\n \n             slice_insert(\n@@ -811,6 +950,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n+    /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n+    /// between this edge and the key/value pair to the right of this edge. This method splits\n+    /// the node if there isn't enough room.\n     pub fn insert(mut self, key: K, val: V, edge: Root<K, V>)\n             -> InsertResult<'a, K, V, marker::Internal> {\n \n@@ -843,6 +985,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n impl<BorrowType, K, V>\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n \n+    /// Finds the node pointed to by this edge.\n+    ///\n+    /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n+    /// both, upon success, do nothing.\n     pub fn descend(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.node.height - 1,\n@@ -885,6 +1031,13 @@ impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n+    /// Splits the underlying node into three parts:\n+    ///\n+    /// - The node is truncated to only contain the key/value pairs to the right of\n+    ///   this handle.\n+    /// - The key and value pointed to by this handle and extracted.\n+    /// - All the key/value pairs to the right of this handle are put into a newly\n+    ///   allocated node.\n     pub fn split(mut self)\n             -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n         unsafe {\n@@ -920,6 +1073,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n         }\n     }\n \n+    /// Removes the key/value pair pointed to by this handle, returning the edge between the\n+    /// now adjacent key/value pairs to the left and right of this handle.\n     pub fn remove(mut self)\n             -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n         unsafe {\n@@ -932,6 +1087,13 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n+    /// Splits the underlying node into three parts:\n+    ///\n+    /// - The node is truncated to only contain the edges and key/value pairs to the\n+    ///   right of this handle.\n+    /// - The key and value pointed to by this handle and extracted.\n+    /// - All the edges and key/value pairs to the right of this handle are put into\n+    ///   a newly allocated node.\n     pub fn split(mut self)\n             -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n         unsafe {\n@@ -979,6 +1141,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n+    /// Returns whether it is valid to call `.merge()`, i.e., whether there is enough room in\n+    /// a node to hold the combination of the nodes to the left and right of this handle along\n+    /// with the key/value pair at this handle.\n     pub fn can_merge(&self) -> bool {\n         (\n             self.reborrow()\n@@ -993,6 +1158,11 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         ) <= CAPACITY\n     }\n \n+    /// Combines the node immediately to the left of this handle, the key/value pair pointed\n+    /// to by this handle, and the node immediately to the right of this handle into one new\n+    /// child of the underlying node, returning an edge referencing that new child.\n+    ///\n+    /// Assumes that this edge `.can_merge()`.\n     pub fn merge(mut self)\n             -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n         let self1 = unsafe { ptr::read(&self) };\n@@ -1068,6 +1238,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n impl<BorrowType, K, V, HandleType>\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType> {\n \n+    /// Check whether the underlying node is an `Internal` node or a `Leaf` node.\n     pub fn force(self) -> ForceResult<\n         Handle<NodeRef<BorrowType, K, V, marker::Leaf>, HandleType>,\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, HandleType>"}, {"sha": "589ac90b308ad78d77d4b17b2398a28c44d04ab3", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -38,9 +38,23 @@ use slice::SliceExt;\n /// all standard arithmetic operations on the underlying value are\n /// intended to have wrapping semantics.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Default)]\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\n pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Wrapping<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"wrapping_display\", since = \"1.10.0\")]\n+impl<T: fmt::Display> fmt::Display for Wrapping<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n mod wrapping;\n \n // All these modules are technically private and only exposed for libcoretest:"}, {"sha": "a3c7ab481a765f63cee345578b23fdabd85a8cec", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -119,6 +119,17 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// `src` is not used before the data is overwritten again (e.g. with `write`,\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let x = 12;\n+/// let y = &x as *const i32;\n+///\n+/// unsafe { println!(\"{}\", std::ptr::read(y)); }\n+/// ```\n #[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n@@ -155,6 +166,21 @@ pub unsafe fn read_and_drop<T>(dest: *mut T) -> T {\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let mut x = 0;\n+/// let y = &mut x as *mut i32;\n+/// let z = 12;\n+///\n+/// unsafe {\n+///     std::ptr::write(y, z);\n+///     println!(\"{}\", std::ptr::read(y));\n+/// }\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n@@ -185,6 +211,17 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// `src` is not used before the data is overwritten again (e.g. with `write`,\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let x = 12;\n+/// let y = &x as *const i32;\n+///\n+/// unsafe { println!(\"{}\", std::ptr::read_volatile(y)); }\n+/// ```\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n@@ -217,6 +254,21 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let mut x = 0;\n+/// let y = &mut x as *mut i32;\n+/// let z = 12;\n+///\n+/// unsafe {\n+///     std::ptr::write_volatile(y, z);\n+///     println!(\"{}\", std::ptr::read_volatile(y));\n+/// }\n+/// ```\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {"}, {"sha": "217445715a81b8d31e1d16256b3586a05a0ee059", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -12,5 +12,4 @@ crate-type = [\"dylib\"]\n log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n rustc = { path = \"../librustc\" }\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n arena = { path = \"../libarena\" }"}, {"sha": "2547c756b9d6a1c21a430982a72aae25345dd584", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 53, "deletions": 49, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -13,7 +13,6 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use DefModifiers;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n@@ -28,9 +27,9 @@ use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty::{self, VariantKind};\n \n-use syntax::ast::Name;\n+use syntax::ast::{Name, NodeId};\n use syntax::attr::AttrMetaMethods;\n-use syntax::parse::token::{special_idents, SELF_KEYWORD_NAME, SUPER_KEYWORD_NAME};\n+use syntax::parse::token::keywords;\n use syntax::codemap::{Span, DUMMY_SP};\n \n use rustc::hir;\n@@ -53,10 +52,9 @@ impl<'a> ToNameBinding<'a> for (Module<'a>, Span) {\n     }\n }\n \n-impl<'a> ToNameBinding<'a> for (Def, Span, DefModifiers, ty::Visibility) {\n+impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n-        let kind = NameBindingKind::Def(self.0);\n-        NameBinding { modifiers: self.2, kind: kind, span: Some(self.1), vis: self.3 }\n+        NameBinding { kind: NameBindingKind::Def(self.0), span: Some(self.1), vis: self.2 }\n     }\n }\n \n@@ -100,12 +98,42 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         block.stmts.iter().any(is_item)\n     }\n \n+    fn sanity_check_import(&self, view_path: &hir::ViewPath, id: NodeId) {\n+        let path = match view_path.node {\n+            ViewPathSimple(_, ref path) |\n+            ViewPathGlob (ref path) |\n+            ViewPathList(ref path, _) => path\n+        };\n+\n+        // Check for type parameters\n+        let found_param = path.segments.iter().any(|segment| {\n+            !segment.parameters.types().is_empty() ||\n+            !segment.parameters.lifetimes().is_empty() ||\n+            !segment.parameters.bindings().is_empty()\n+        });\n+        if found_param {\n+            self.session.span_err(path.span,\n+                                  \"type or lifetime parameter is found in import path\");\n+        }\n+\n+        // Checking for special identifiers in path\n+        // prevent `self` or `super` at beginning of global path\n+        if path.global && path.segments.len() > 0 {\n+            let first = path.segments[0].identifier.name;\n+            if first == keywords::Super.to_name() || first == keywords::SelfValue.to_name() {\n+                self.session.add_lint(\n+                    lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH, id, path.span,\n+                    format!(\"expected identifier, found keyword `{}`\", first)\n+                );\n+            }\n+        }\n+    }\n+\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, parent_ref: &mut Module<'b>) {\n         let parent = *parent_ref;\n         let name = item.name;\n         let sp = item.span;\n-        let modifiers = DefModifiers::IMPORTABLE;\n         self.current_module = parent;\n         let vis = self.resolve_visibility(&item.vis);\n \n@@ -114,10 +142,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 // Extract and intern the module part of the path. For\n                 // globs and lists, the path is found directly in the AST;\n                 // for simple paths we have to munge the path a little.\n-                let is_global;\n                 let module_path: Vec<Name> = match view_path.node {\n                     ViewPathSimple(_, ref full_path) => {\n-                        is_global = full_path.global;\n                         full_path.segments\n                                  .split_last()\n                                  .unwrap()\n@@ -129,30 +155,17 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n                     ViewPathGlob(ref module_ident_path) |\n                     ViewPathList(ref module_ident_path, _) => {\n-                        is_global = module_ident_path.global;\n                         module_ident_path.segments\n                                          .iter()\n                                          .map(|seg| seg.identifier.name)\n                                          .collect()\n                     }\n                 };\n \n-                // Checking for special identifiers in path\n-                // prevent `self` or `super` at beginning of global path\n-                if is_global && (module_path.first() == Some(&SELF_KEYWORD_NAME) ||\n-                                 module_path.first() == Some(&SUPER_KEYWORD_NAME)) {\n-                    self.session.add_lint(\n-                        lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH,\n-                        item.id,\n-                        item.span,\n-                        format!(\"expected identifier, found keyword `{}`\",\n-                                module_path.first().unwrap().as_str()));\n-                }\n+                self.sanity_check_import(view_path, item.id);\n \n                 // Build up the import directives.\n-                let is_prelude = item.attrs.iter().any(|attr| {\n-                    attr.name() == special_idents::prelude_import.name.as_str()\n-                });\n+                let is_prelude = item.attrs.iter().any(|attr| attr.name() == \"prelude_import\");\n \n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path) => {\n@@ -268,21 +281,21 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             ItemStatic(_, m, _) => {\n                 let mutbl = m == hir::MutMutable;\n                 let def = Def::Static(self.ast_map.local_def_id(item.id), mutbl);\n-                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n+                self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n             ItemConst(_, _) => {\n                 let def = Def::Const(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n+                self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n             ItemFn(_, _, _, _, _, _) => {\n                 let def = Def::Fn(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n+                self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n \n             // These items live in the type namespace.\n             ItemTy(..) => {\n                 let def = Def::TyAlias(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, modifiers, vis));\n+                self.define(parent, name, TypeNS, (def, sp, vis));\n             }\n \n             ItemEnum(ref enum_definition, _) => {\n@@ -301,13 +314,13 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             ItemStruct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def = Def::Struct(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, modifiers, vis));\n+                self.define(parent, name, TypeNS, (def, sp, vis));\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 if !struct_def.is_struct() {\n                     let def = Def::Struct(self.ast_map.local_def_id(struct_def.id()));\n-                    self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n+                    self.define(parent, name, ValueNS, (def, sp, vis));\n                 }\n \n                 // Record the def ID and fields of this struct.\n@@ -339,8 +352,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                         hir::TypeTraitItem(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n                     };\n \n-                    let modifiers = DefModifiers::empty(); // NB: not DefModifiers::IMPORTABLE\n-                    self.define(module_parent, item.name, ns, (def, item.span, modifiers, vis));\n+                    self.define(module_parent, item.name, ns, (def, item.span, vis));\n \n                     self.trait_item_map.insert((item.name, def_id), item_def_id);\n                 }\n@@ -363,19 +375,16 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n         // Variants are always treated as importable to allow them to be glob used.\n         // All variants are defined in both type and value namespaces as future-proofing.\n-        let modifiers = DefModifiers::IMPORTABLE;\n         let def = Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id()));\n-\n-        self.define(parent, name, ValueNS, (def, variant.span, modifiers, parent.vis));\n-        self.define(parent, name, TypeNS, (def, variant.span, modifiers, parent.vis));\n+        self.define(parent, name, ValueNS, (def, variant.span, parent.vis));\n+        self.define(parent, name, TypeNS, (def, variant.span, parent.vis));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self,\n                                             foreign_item: &ForeignItem,\n                                             parent: Module<'b>) {\n         let name = foreign_item.name;\n-        let modifiers = DefModifiers::IMPORTABLE;\n \n         let def = match foreign_item.node {\n             ForeignItemFn(..) => {\n@@ -387,7 +396,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         };\n         self.current_module = parent;\n         let vis = self.resolve_visibility(&foreign_item.vis);\n-        self.define(parent, name, ValueNS, (def, foreign_item.span, modifiers, vis));\n+        self.define(parent, name, ValueNS, (def, foreign_item.span, vis));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &mut Module<'b>) {\n@@ -422,10 +431,6 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n         let name = xcdef.name;\n         let vis = if parent.is_trait() { ty::Visibility::Public } else { xcdef.vis };\n-        let modifiers = match parent.is_normal() {\n-            true => DefModifiers::IMPORTABLE,\n-            false => DefModifiers::empty(),\n-        };\n \n         match def {\n             Def::Mod(_) | Def::ForeignMod(_) | Def::Enum(..) => {\n@@ -439,9 +444,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 debug!(\"(building reduced graph for external crate) building variant {}\", name);\n                 // Variants are always treated as importable to allow them to be glob used.\n                 // All variants are defined in both type and value namespaces as future-proofing.\n-                let modifiers = DefModifiers::IMPORTABLE;\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n                 if self.session.cstore.variant_kind(variant_id) == Some(VariantKind::Struct) {\n                     // Not adding fields for variants as they are not accessed with a self receiver\n                     self.structs.insert(variant_id, Vec::new());\n@@ -454,7 +458,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             Def::Method(..) => {\n                 debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n                        name);\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n+                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n             }\n             Def::Trait(def_id) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n@@ -480,16 +484,16 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n             }\n             Def::Struct(def_id)\n                 if self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_none() => {\n                 debug!(\"(building reduced graph for external crate) building type and value for {}\",\n                        name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n                 if let Some(ctor_def_id) = self.session.cstore.struct_ctor_def_id(def_id) {\n                     let def = Def::Struct(ctor_def_id);\n-                    self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n+                    self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n                 }\n \n                 // Record the def ID and fields of this struct."}, {"sha": "f32cf7aa9f41af4f7c72fd3a7e178a2662919cc4", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -29,9 +29,6 @@ extern crate log;\n extern crate syntax;\n extern crate arena;\n #[macro_use]\n-#[no_link]\n-extern crate rustc_bitflags;\n-#[macro_use]\n extern crate rustc;\n \n use self::PatternBindingMode::*;\n@@ -915,18 +912,9 @@ impl<'a> fmt::Debug for ModuleS<'a> {\n     }\n }\n \n-bitflags! {\n-    #[derive(Debug)]\n-    flags DefModifiers: u8 {\n-        const IMPORTABLE = 1 << 1,\n-        const GLOB_IMPORTED = 1 << 3,\n-    }\n-}\n-\n // Records a possibly-private value, type, or module definition.\n #[derive(Clone, Debug)]\n pub struct NameBinding<'a> {\n-    modifiers: DefModifiers,\n     kind: NameBindingKind<'a>,\n     span: Option<Span>,\n     vis: ty::Visibility,\n@@ -938,7 +926,7 @@ enum NameBindingKind<'a> {\n     Module(Module<'a>),\n     Import {\n         binding: &'a NameBinding<'a>,\n-        id: NodeId,\n+        directive: &'a ImportDirective<'a>,\n         // Some(error) if using this imported name causes the import to be a privacy error\n         privacy_error: Option<Box<PrivacyError<'a>>>,\n     },\n@@ -950,7 +938,6 @@ struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n impl<'a> NameBinding<'a> {\n     fn create_from_module(module: Module<'a>, span: Option<Span>) -> Self {\n         NameBinding {\n-            modifiers: DefModifiers::IMPORTABLE,\n             kind: NameBindingKind::Module(module),\n             span: span,\n             vis: module.vis,\n@@ -973,10 +960,6 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    fn defined_with(&self, modifiers: DefModifiers) -> bool {\n-        self.modifiers.contains(modifiers)\n-    }\n-\n     fn is_pseudo_public(&self) -> bool {\n         self.pseudo_vis() == ty::Visibility::Public\n     }\n@@ -1003,6 +986,20 @@ impl<'a> NameBinding<'a> {\n             _ => false,\n         }\n     }\n+\n+    fn is_glob_import(&self) -> bool {\n+        match self.kind {\n+            NameBindingKind::Import { directive, .. } => directive.is_glob(),\n+            _ => false,\n+        }\n+    }\n+\n+    fn is_importable(&self) -> bool {\n+        match self.def().unwrap() {\n+            Def::AssociatedConst(..) | Def::Method(..) | Def::AssociatedTy(..) => false,\n+            _ => true,\n+        }\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -1228,27 +1225,28 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             self.used_crates.insert(krate);\n         }\n \n-        let (import_id, privacy_error) = match binding.kind {\n-            NameBindingKind::Import { id, ref privacy_error, .. } => (id, privacy_error),\n+        let (directive, privacy_error) = match binding.kind {\n+            NameBindingKind::Import { directive, ref privacy_error, .. } =>\n+                (directive, privacy_error),\n             _ => return,\n         };\n \n-        self.used_imports.insert((import_id, ns));\n+        self.used_imports.insert((directive.id, ns));\n         if let Some(error) = privacy_error.as_ref() {\n             self.privacy_errors.push((**error).clone());\n         }\n \n         if !self.make_glob_map {\n             return;\n         }\n-        if self.glob_map.contains_key(&import_id) {\n-            self.glob_map.get_mut(&import_id).unwrap().insert(name);\n+        if self.glob_map.contains_key(&directive.id) {\n+            self.glob_map.get_mut(&directive.id).unwrap().insert(name);\n             return;\n         }\n \n         let mut new_set = FnvHashSet();\n         new_set.insert(name);\n-        self.glob_map.insert(import_id, new_set);\n+        self.glob_map.insert(directive.id, new_set);\n     }\n \n     fn get_trait_name(&self, did: DefId) -> Name {\n@@ -2408,7 +2406,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 }\n                             }\n                         }\n-                    } else {\n+                    } else if let Err(false) = self.resolve_path(pat_id, &path, 0, ValueNS) {\n                         resolve_error(\n                             self,\n                             path.span,"}, {"sha": "03492043dd4498acd57c78184732afd5801db928", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -10,7 +10,6 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use DefModifiers;\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBinding, NameBindingKind, PrivacyError};\n@@ -59,36 +58,34 @@ impl ImportDirectiveSubclass {\n /// One import directive.\n #[derive(Debug,Clone)]\n pub struct ImportDirective<'a> {\n+    pub id: NodeId,\n     module_path: Vec<Name>,\n     target_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n     subclass: ImportDirectiveSubclass,\n     span: Span,\n-    id: NodeId,\n     vis: ty::Visibility, // see note in ImportResolutionPerNamespace about how to use this\n     is_prelude: bool,\n }\n \n impl<'a> ImportDirective<'a> {\n     // Given the binding to which this directive resolves in a particular namespace,\n     // this returns the binding for the name this directive defines in that namespace.\n-    fn import(&self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n+    fn import(&'a self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n               -> NameBinding<'a> {\n-        let mut modifiers = DefModifiers::IMPORTABLE;\n-        if let GlobImport = self.subclass {\n-            modifiers = modifiers | DefModifiers::GLOB_IMPORTED;\n-        }\n-\n         NameBinding {\n             kind: NameBindingKind::Import {\n                 binding: binding,\n-                id: self.id,\n+                directive: self,\n                 privacy_error: privacy_error,\n             },\n             span: Some(self.span),\n-            modifiers: modifiers,\n             vis: self.vis,\n         }\n     }\n+\n+    pub fn is_glob(&self) -> bool {\n+        match self.subclass { ImportDirectiveSubclass::GlobImport => true, _ => false }\n+    }\n }\n \n #[derive(Clone, Default)]\n@@ -141,9 +138,9 @@ impl<'a> SingleImports<'a> {\n impl<'a> NameResolution<'a> {\n     fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n         if let Some(old_binding) = self.binding {\n-            if binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+            if binding.is_glob_import() {\n                 self.duplicate_globs.push(binding);\n-            } else if old_binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+            } else if old_binding.is_glob_import() {\n                 self.duplicate_globs.push(old_binding);\n                 self.binding = Some(binding);\n             } else {\n@@ -160,7 +157,7 @@ impl<'a> NameResolution<'a> {\n     fn binding(&self) -> Option<&'a NameBinding<'a>> {\n         self.binding.and_then(|binding| match self.single_imports {\n             SingleImports::None => Some(binding),\n-            _ if !binding.defined_with(DefModifiers::GLOB_IMPORTED) => Some(binding),\n+            _ if !binding.is_glob_import() => Some(binding),\n             _ => None, // The binding could be shadowed by a single import, so it is not known.\n         })\n     }\n@@ -170,7 +167,7 @@ impl<'a> NameResolution<'a> {\n     fn try_result(&self, ns: Namespace, allow_private_imports: bool)\n                   -> Option<ResolveResult<&'a NameBinding<'a>>> {\n         match self.binding {\n-            Some(binding) if !binding.defined_with(DefModifiers::GLOB_IMPORTED) =>\n+            Some(binding) if !binding.is_glob_import() =>\n                 return Some(Success(binding)),\n             _ => {} // Items and single imports are not shadowable\n         };\n@@ -337,7 +334,7 @@ impl<'a> ::ModuleS<'a> {\n     }\n \n     fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n-        if !binding.defined_with(DefModifiers::IMPORTABLE) || !binding.is_pseudo_public() { return }\n+        if !binding.is_importable() || !binding.is_pseudo_public() { return }\n         for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n             let _ = importer.try_define_child(name, ns, directive.import(binding, None));\n         }\n@@ -410,7 +407,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // resolution for it so that later resolve stages won't complain.\n         if let SingleImport { target, .. } = e.import_directive.subclass {\n             let dummy_binding = self.resolver.arenas.alloc_name_binding(NameBinding {\n-                modifiers: DefModifiers::GLOB_IMPORTED,\n                 kind: NameBindingKind::Def(Def::Err),\n                 span: None,\n                 vis: ty::Visibility::Public,\n@@ -517,7 +513,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             determined.set(true);\n             if let Success(binding) = *result {\n-                if !binding.defined_with(DefModifiers::IMPORTABLE) {\n+                if !binding.is_importable() {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n                 }\n@@ -662,7 +658,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n-            if binding.defined_with(DefModifiers::IMPORTABLE) && binding.is_pseudo_public() {\n+            if binding.is_importable() && binding.is_pseudo_public() {\n                 let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n             }\n         }\n@@ -705,14 +701,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            if let NameBindingKind::Import { binding: orig_binding, id, .. } = binding.kind {\n+            if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n                 if ns == TypeNS && orig_binding.is_variant() &&\n                    !orig_binding.vis.is_at_least(binding.vis, &self.resolver.ast_map) {\n                     let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring its enum as `pub`\",\n                                       name);\n                     let lint = lint::builtin::PRIVATE_IN_PUBLIC;\n-                    self.resolver.session.add_lint(lint, id, binding.span.unwrap(), msg);\n+                    self.resolver.session.add_lint(lint, directive.id, binding.span.unwrap(), msg);\n                 }\n             }\n         }"}, {"sha": "646efe09da81e15d4293e87d82b471b6472830e3", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -2717,7 +2717,7 @@ Rust does not currently support this. A simple example that causes this error:\n \n ```compile_fail\n fn main() {\n-    let _: Box<std::io::Read+std::io::Write>;\n+    let _: Box<std::io::Read + std::io::Write>;\n }\n ```\n \n@@ -2727,7 +2727,7 @@ following compiles correctly:\n \n ```\n fn main() {\n-    let _: Box<std::io::Read+Copy+Sync>;\n+    let _: Box<std::io::Read + Send + Sync>;\n }\n ```\n \"##,"}, {"sha": "624748f352ee1ec9903947914c27cc7822b58c4c", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -1030,7 +1030,7 @@ impl f32 {\n     /// let abs_difference_1 = (f.1 - x.cos()).abs();\n     ///\n     /// assert!(abs_difference_0 <= f32::EPSILON);\n-    /// assert!(abs_difference_0 <= f32::EPSILON);\n+    /// assert!(abs_difference_1 <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "6515301aefd14d0a05e009e17a3f5a2a54057af3", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -903,7 +903,7 @@ impl f64 {\n     /// let abs_difference_1 = (f.1 - x.cos()).abs();\n     ///\n     /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_0 < 1e-10);\n+    /// assert!(abs_difference_1 < 1e-10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "f3d3bbd9f99052160c6f685d6160f896b2fb820f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 63, "deletions": 111, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -81,6 +81,8 @@ type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute> >);\n pub enum PathParsingMode {\n     /// A path with no type parameters; e.g. `foo::bar::Baz`\n     NoTypesAllowed,\n+    /// Same as `NoTypesAllowed`, but may end with `::{` or `::*`, which are left unparsed\n+    ImportPrefix,\n     /// A path with a lifetime and type parameters, with no double colons\n     /// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n     LifetimeAndTypesWithoutColons,\n@@ -591,20 +593,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_path_list_item(&mut self) -> PResult<'a, ast::PathListItem> {\n-        let lo = self.span.lo;\n-        let node = if self.eat_keyword(keywords::SelfValue) {\n-            let rename = self.parse_rename()?;\n-            ast::PathListItemKind::Mod { id: ast::DUMMY_NODE_ID, rename: rename }\n-        } else {\n-            let ident = self.parse_ident()?;\n-            let rename = self.parse_rename()?;\n-            ast::PathListItemKind::Ident { name: ident, rename: rename, id: ast::DUMMY_NODE_ID }\n-        };\n-        let hi = self.last_span.hi;\n-        Ok(spanned(lo, hi, node))\n-    }\n-\n     /// Check if the next token is `tok`, and return `true` if so.\n     ///\n     /// This method will automatically add `tok` to `expected_tokens` if `tok` is not\n@@ -1763,8 +1751,8 @@ impl<'a> Parser<'a> {\n             LifetimeAndTypesWithColons => {\n                 self.parse_path_segments_with_colons()?\n             }\n-            NoTypesAllowed => {\n-                self.parse_path_segments_without_types()?\n+            NoTypesAllowed | ImportPrefix => {\n+                self.parse_path_segments_without_types(mode == ImportPrefix)?\n             }\n         };\n         path.segments.extend(segments);\n@@ -1801,8 +1789,8 @@ impl<'a> Parser<'a> {\n             LifetimeAndTypesWithColons => {\n                 self.parse_path_segments_with_colons()?\n             }\n-            NoTypesAllowed => {\n-                self.parse_path_segments_without_types()?\n+            NoTypesAllowed | ImportPrefix => {\n+                self.parse_path_segments_without_types(mode == ImportPrefix)?\n             }\n         };\n \n@@ -1920,7 +1908,8 @@ impl<'a> Parser<'a> {\n \n     /// Examples:\n     /// - `a::b::c`\n-    pub fn parse_path_segments_without_types(&mut self) -> PResult<'a, Vec<ast::PathSegment>> {\n+    pub fn parse_path_segments_without_types(&mut self, import_prefix: bool)\n+                                             -> PResult<'a, Vec<ast::PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n@@ -1932,9 +1921,11 @@ impl<'a> Parser<'a> {\n                 parameters: ast::PathParameters::none()\n             });\n \n-            // If we do not see a `::`, stop.\n-            if !self.eat(&token::ModSep) {\n+            // If we do not see a `::` or see `::{`/`::*`, stop.\n+            if !self.check(&token::ModSep) || import_prefix && self.is_import_coupler() {\n                 return Ok(segments);\n+            } else {\n+                self.bump();\n             }\n         }\n     }\n@@ -6127,106 +6118,67 @@ impl<'a> Parser<'a> {\n         self.parse_item_(attrs, true, false)\n     }\n \n+    fn parse_path_list_items(&mut self) -> PResult<'a, Vec<ast::PathListItem>> {\n+        self.parse_unspanned_seq(&token::OpenDelim(token::Brace),\n+                                 &token::CloseDelim(token::Brace),\n+                                 SeqSep::trailing_allowed(token::Comma), |this| {\n+            let lo = this.span.lo;\n+            let node = if this.eat_keyword(keywords::SelfValue) {\n+                let rename = this.parse_rename()?;\n+                ast::PathListItemKind::Mod { id: ast::DUMMY_NODE_ID, rename: rename }\n+            } else {\n+                let ident = this.parse_ident()?;\n+                let rename = this.parse_rename()?;\n+                ast::PathListItemKind::Ident { name: ident, rename: rename, id: ast::DUMMY_NODE_ID }\n+            };\n+            let hi = this.last_span.hi;\n+            Ok(spanned(lo, hi, node))\n+        })\n+    }\n+\n+    /// `::{` or `::*`\n+    fn is_import_coupler(&mut self) -> bool {\n+        self.check(&token::ModSep) &&\n+            self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace) ||\n+                                   *t == token::BinOp(token::Star))\n+    }\n \n-    /// Matches view_path : MOD? non_global_path as IDENT\n-    /// | MOD? non_global_path MOD_SEP LBRACE RBRACE\n-    /// | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n-    /// | MOD? non_global_path MOD_SEP STAR\n-    /// | MOD? non_global_path\n+    /// Matches ViewPath:\n+    /// MOD_SEP? non_global_path\n+    /// MOD_SEP? non_global_path as IDENT\n+    /// MOD_SEP? non_global_path MOD_SEP STAR\n+    /// MOD_SEP? non_global_path MOD_SEP LBRACE item_seq RBRACE\n+    /// MOD_SEP? LBRACE item_seq RBRACE\n     fn parse_view_path(&mut self) -> PResult<'a, P<ViewPath>> {\n         let lo = self.span.lo;\n-\n-        // Allow a leading :: because the paths are absolute either way.\n-        // This occurs with \"use $crate::...\" in macros.\n-        let is_global = self.eat(&token::ModSep);\n-\n-        if self.check(&token::OpenDelim(token::Brace)) {\n-            // use {foo,bar}\n-            let idents = self.parse_unspanned_seq(\n-                &token::OpenDelim(token::Brace),\n-                &token::CloseDelim(token::Brace),\n-                SeqSep::trailing_allowed(token::Comma),\n-                |p| p.parse_path_list_item())?;\n-            let path = ast::Path {\n+        if self.check(&token::OpenDelim(token::Brace)) || self.is_import_coupler() {\n+            // `{foo, bar}` or `::{foo, bar}`\n+            let prefix = ast::Path {\n+                global: self.eat(&token::ModSep),\n+                segments: Vec::new(),\n                 span: mk_sp(lo, self.span.hi),\n-                global: is_global,\n-                segments: Vec::new()\n             };\n-            return Ok(P(spanned(lo, self.span.hi, ViewPathList(path, idents))));\n-        }\n-\n-        let first_ident = self.parse_ident()?;\n-        let mut path = vec!(first_ident);\n-        if let token::ModSep = self.token {\n-            // foo::bar or foo::{a,b,c} or foo::*\n-            while self.check(&token::ModSep) {\n+            let items = self.parse_path_list_items()?;\n+            Ok(P(spanned(lo, self.span.hi, ViewPathList(prefix, items))))\n+        } else {\n+            let prefix = self.parse_path(ImportPrefix)?;\n+            if self.is_import_coupler() {\n+                // `foo::bar::{a, b}` or `foo::bar::*`\n                 self.bump();\n-\n-                match self.token {\n-                  token::Ident(..) => {\n-                    let ident = self.parse_ident()?;\n-                    path.push(ident);\n-                  }\n-\n-                  // foo::bar::{a,b,c}\n-                  token::OpenDelim(token::Brace) => {\n-                    let idents = self.parse_unspanned_seq(\n-                        &token::OpenDelim(token::Brace),\n-                        &token::CloseDelim(token::Brace),\n-                        SeqSep::trailing_allowed(token::Comma),\n-                        |p| p.parse_path_list_item()\n-                    )?;\n-                    let path = ast::Path {\n-                        span: mk_sp(lo, self.span.hi),\n-                        global: is_global,\n-                        segments: path.into_iter().map(|identifier| {\n-                            ast::PathSegment {\n-                                identifier: identifier,\n-                                parameters: ast::PathParameters::none(),\n-                            }\n-                        }).collect()\n-                    };\n-                    return Ok(P(spanned(lo, self.span.hi, ViewPathList(path, idents))));\n-                  }\n-\n-                  // foo::bar::*\n-                  token::BinOp(token::Star) => {\n+                if self.check(&token::BinOp(token::Star)) {\n                     self.bump();\n-                    let path = ast::Path {\n-                        span: mk_sp(lo, self.span.hi),\n-                        global: is_global,\n-                        segments: path.into_iter().map(|identifier| {\n-                            ast::PathSegment {\n-                                identifier: identifier,\n-                                parameters: ast::PathParameters::none(),\n-                            }\n-                        }).collect()\n-                    };\n-                    return Ok(P(spanned(lo, self.span.hi, ViewPathGlob(path))));\n-                  }\n-\n-                  // fall-through for case foo::bar::;\n-                  token::Semi => {\n-                    self.span_err(self.span, \"expected identifier or `{` or `*`, found `;`\");\n-                  }\n-\n-                  _ => break\n+                    Ok(P(spanned(lo, self.span.hi, ViewPathGlob(prefix))))\n+                } else {\n+                    let items = self.parse_path_list_items()?;\n+                    Ok(P(spanned(lo, self.span.hi, ViewPathList(prefix, items))))\n                 }\n+            } else {\n+                // `foo::bar` or `foo::bar as baz`\n+                let rename = self.parse_rename()?.\n+                                  unwrap_or(prefix.segments.last().unwrap().identifier);\n+                Ok(P(spanned(lo, self.last_span.hi, ViewPathSimple(rename, prefix))))\n             }\n         }\n-        let mut rename_to = path[path.len() - 1];\n-        let path = ast::Path {\n-            span: mk_sp(lo, self.last_span.hi),\n-            global: is_global,\n-            segments: path.into_iter().map(|identifier| {\n-                ast::PathSegment {\n-                    identifier: identifier,\n-                    parameters: ast::PathParameters::none(),\n-                }\n-            }).collect()\n-        };\n-        rename_to = self.parse_rename()?.unwrap_or(rename_to);\n-        Ok(P(spanned(lo, self.last_span.hi, ViewPathSimple(rename_to, path))))\n     }\n \n     fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {"}, {"sha": "beb15a11a969533c20682d69ec1493fa8961b5cf", "filename": "src/test/compile-fail/import-prefix-macro-1.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-1.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    pub mod b {\n+        pub mod c {\n+            pub struct S;\n+            pub struct Z;\n+        }\n+    }\n+}\n+\n+macro_rules! import {\n+    ($p: path) => (use $p {S, Z}); //~ERROR expected one of `::`, `;`, or `as`, found `{`\n+}\n+\n+import! { a::b::c }\n+\n+fn main() {}"}, {"sha": "56c6273aa9a29e12edbf61e655128df3926019bc", "filename": "src/test/compile-fail/import-prefix-macro-2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-2.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    pub mod b {\n+        pub mod c {\n+            pub struct S;\n+            pub struct Z;\n+        }\n+    }\n+}\n+\n+macro_rules! import {\n+    ($p: path) => (use ::$p {S, Z}); //~ERROR  expected identifier, found `a::b::c`\n+}\n+\n+import! { a::b::c }\n+\n+fn main() {}"}, {"sha": "66d4d6d06211da6fec00b0aeff66c7ec3db90d34", "filename": "src/test/compile-fail/import-ty-params.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    pub mod b {\n+        pub mod c {\n+            pub struct S<T>(T);\n+        }\n+    }\n+}\n+\n+macro_rules! import {\n+    ($p: path) => (use $p;);\n+}\n+\n+import! { a::b::c::S<u8> } //~ERROR type or lifetime parameter is found in import path\n+\n+fn main() {}"}, {"sha": "9b675958003206fa52742f77b19be819ffbce29b", "filename": "src/test/compile-fail/pattern-error-continue.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -42,4 +42,8 @@ fn main() {\n     //~^ ERROR mismatched types\n     //~| expected `char`\n     //~| found `bool`\n+\n+    match () {\n+        E::V => {} //~ ERROR failed to resolve. Use of undeclared type or module `E`\n+    }\n }"}, {"sha": "613f54eb331349d907c4c46b2f1d69a3243648ea", "filename": "src/test/compile-fail/self_type_keyword-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fself_type_keyword-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fself_type_keyword-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword-2.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::Self as Foo; //~ ERROR unresolved import `self::Self`\n+\n+pub fn main() {}"}, {"sha": "b28f48bb1056e2f6e09588c2280582f7662cb5b7", "filename": "src/test/compile-fail/self_type_keyword.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -39,9 +39,6 @@ pub fn main() {\n     }\n }\n \n-use self::Self as Foo;\n-//~^ ERROR expected identifier, found keyword `Self`\n-\n use std::option::Option as Self;\n //~^ ERROR expected identifier, found keyword `Self`\n "}, {"sha": "e6a10d43e2994331be2f33b408a42193de398e9a", "filename": "src/test/parse-fail/use-ends-with-mod-sep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fparse-fail%2Fuse-ends-with-mod-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Fparse-fail%2Fuse-ends-with-mod-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fuse-ends-with-mod-sep.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -10,4 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-use std::any::; //~ ERROR expected identifier or `{` or `*`, found `;`\n+use std::any::; //~ ERROR expected identifier, found `;`"}, {"sha": "cfe4ff78e6258d13b9aa9888119601b3add2915a", "filename": "src/test/run-pass/import-prefix-macro.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Frun-pass%2Fimport-prefix-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6264002637f60322d17329eaf4a25b9abe2c638/src%2Ftest%2Frun-pass%2Fimport-prefix-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-prefix-macro.rs?ref=a6264002637f60322d17329eaf4a25b9abe2c638", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    pub mod b {\n+        pub mod c {\n+            pub struct S;\n+            pub struct Z;\n+        }\n+        pub struct W;\n+    }\n+}\n+\n+macro_rules! import {\n+    (1 $p: path) => (use $p;);\n+    (2 $p: path) => (use $p::{Z};);\n+    (3 $p: path) => (use $p::*;);\n+}\n+\n+import! { 1 a::b::c::S }\n+import! { 2 a::b::c }\n+import! { 3 a::b }\n+\n+fn main() {\n+    let s = S;\n+    let z = Z;\n+    let w = W;\n+}"}]}