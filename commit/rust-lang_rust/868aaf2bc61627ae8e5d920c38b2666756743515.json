{"sha": "868aaf2bc61627ae8e5d920c38b2666756743515", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OGFhZjJiYzYxNjI3YWU4ZTVkOTIwYzM4YjI2NjY3NTY3NDM1MTU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-08-26T11:21:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-26T11:21:17Z"}, "message": "Merge #5889\n\n5889: Allow logging to file r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "195496d5b2eff211159ef00db29acc353d57c591", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/195496d5b2eff211159ef00db29acc353d57c591"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/868aaf2bc61627ae8e5d920c38b2666756743515", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfRkWtCRBK7hj4Ov3rIwAAdHIIABrbg4K23VfPhrEEsmIOYLCk\n4NM94GLWdHPk6tZw5M5YaXanGkO8Ny6y/kUU8T01OppSu9fUh0PYSIel8hAroWO/\nvw5EgNs9uENHKRLSJnTjhFn8W3F26qwksUUpBfg8tuqy8UMj1suQefoNjrGry3N3\nniQKVtRhdfACZphyxQFxpsF/ArUN4S4sSzzvgRyWH5BCE9+69sI69dSo6/Ih2rXG\n/yamKWazFWC7rHClFNK5E6sYj7E7pwOZrUgmhIMWYh2IhMbLyOqRdYasQAqSwSuI\nzZE7PsD7472s+8gouoXy4IaJ9X7mWgUM+2l/W3Qd7wN2O6BEYB1/LUo9KfD/EXo=\n=kPDs\n-----END PGP SIGNATURE-----\n", "payload": "tree 195496d5b2eff211159ef00db29acc353d57c591\nparent 51f5af223f01e7938fb07821027afe511d480826\nparent ed6304131a5a738da72b88d5deb67be4555b4c7f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1598440877 +0000\ncommitter GitHub <noreply@github.com> 1598440877 +0000\n\nMerge #5889\n\n5889: Allow logging to file r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/868aaf2bc61627ae8e5d920c38b2666756743515", "html_url": "https://github.com/rust-lang/rust/commit/868aaf2bc61627ae8e5d920c38b2666756743515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/868aaf2bc61627ae8e5d920c38b2666756743515/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51f5af223f01e7938fb07821027afe511d480826", "url": "https://api.github.com/repos/rust-lang/rust/commits/51f5af223f01e7938fb07821027afe511d480826", "html_url": "https://github.com/rust-lang/rust/commit/51f5af223f01e7938fb07821027afe511d480826"}, {"sha": "ed6304131a5a738da72b88d5deb67be4555b4c7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed6304131a5a738da72b88d5deb67be4555b4c7f", "html_url": "https://github.com/rust-lang/rust/commit/ed6304131a5a738da72b88d5deb67be4555b4c7f"}], "stats": {"total": 584, "additions": 257, "deletions": 327}, "files": [{"sha": "41ce5cae91e0407fd792e327f288424e808673d3", "filename": "crates/rust-analyzer/src/bin/args.rs", "status": "modified", "additions": 161, "deletions": 312, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/868aaf2bc61627ae8e5d920c38b2666756743515/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868aaf2bc61627ae8e5d920c38b2666756743515/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs?ref=868aaf2bc61627ae8e5d920c38b2666756743515", "patch": "@@ -5,55 +5,115 @@\n \n use std::{env, fmt::Write, path::PathBuf};\n \n-use anyhow::{bail, Result};\n+use anyhow::{bail, format_err, Result};\n use pico_args::Arguments;\n use rust_analyzer::cli::{AnalysisStatsCmd, BenchCmd, BenchWhat, Position, Verbosity};\n use ssr::{SsrPattern, SsrRule};\n use vfs::AbsPathBuf;\n \n pub(crate) struct Args {\n     pub(crate) verbosity: Verbosity,\n+    pub(crate) log_file: Option<PathBuf>,\n     pub(crate) command: Command,\n }\n \n pub(crate) enum Command {\n-    Parse {\n-        no_dump: bool,\n-    },\n+    Parse { no_dump: bool },\n     Symbols,\n-    Highlight {\n-        rainbow: bool,\n-    },\n+    Highlight { rainbow: bool },\n     AnalysisStats(AnalysisStatsCmd),\n     Bench(BenchCmd),\n-    Diagnostics {\n-        path: PathBuf,\n-        load_output_dirs: bool,\n-        with_proc_macro: bool,\n-        /// Include files which are not modules. In rust-analyzer\n-        /// this would include the parser test files.\n-        all: bool,\n-    },\n-    Ssr {\n-        rules: Vec<SsrRule>,\n-    },\n-    StructuredSearch {\n-        debug_snippet: Option<String>,\n-        patterns: Vec<SsrPattern>,\n-    },\n+    Diagnostics { path: PathBuf, load_output_dirs: bool, with_proc_macro: bool },\n+    Ssr { rules: Vec<SsrRule> },\n+    StructuredSearch { debug_snippet: Option<String>, patterns: Vec<SsrPattern> },\n     ProcMacro,\n     RunServer,\n     Version,\n     Help,\n }\n \n+const HELP: &str = \"\\\n+rust-analyzer\n+\n+USAGE:\n+    rust-analyzer [FLAGS] [COMMAND] [COMMAND_OPTIONS]\n+\n+FLAGS:\n+    --version         Print version\n+    -h, --help        Print this help\n+\n+    -v,  --verbose\n+    -vv, --spammy\n+    -q,  --quiet      Set verbosity\n+\n+    --log-file <PATH> Log to the specified filed instead of stderr\n+\n+ENVIRONMENTAL VARIABLES:\n+    RA_LOG            Set log filter in env_logger format\n+    RA_PROFILE        Enable hierarchical profiler\n+\n+COMMANDS:\n+\n+not specified         Launch LSP server\n+\n+parse < main.rs       Parse tree\n+    --no-dump         Suppress printing\n+\n+symbols < main.rs     Parse input an print the list of symbols\n+\n+highlight < main.rs   Highlight input as html\n+    --rainbow         Enable rainbow highlighting of identifiers\n+\n+analysis-stats <PATH> Batch typecheck project and print summary statistics\n+    <PATH>            Directory with Cargo.toml\n+    --randomize       Randomize order in which crates, modules, and items are processed\n+    --parallel        Run type inference in parallel\n+    --memory-usage    Collect memory usage statistics\n+    -o, --only <PATH> Only analyze items matching this path\n+    --with-deps       Also analyze all dependencies\n+    --load-output-dirs\n+                      Load OUT_DIR values by running `cargo check` before analysis\n+    --with-proc-macro Use proc-macro-srv for proc-macro expanding\n+\n+analysis-bench <PATH> Benchmark specific analysis operation\n+    <PATH>            Directory with Cargo.toml\n+    --highlight <PATH>\n+                      Compute syntax highlighting for this file\n+    --complete <PATH:LINE:COLUMN>\n+                      Compute completions at this location\n+    --goto-def <PATH:LINE:COLUMN>\n+                      Compute goto definition at this location\n+    --memory-usage    Collect memory usage statistics\n+    --load-output-dirs\n+                      Load OUT_DIR values by running `cargo check` before analysis\n+    --with-proc-macro Use proc-macro-srv for proc-macro expanding\n+\n+diagnostics <PATH>\n+    <PATH>            Directory with Cargo.toml\n+    --load-output-dirs\n+                      Load OUT_DIR values by running `cargo check` before analysis\n+    --with-proc-macro Use proc-macro-srv for proc-macro expanding\n+\n+ssr [RULE...]\n+    <RULE>            A structured search replace rule (`$a.foo($b) ==> bar($a, $b)`)\n+\n+search [PATTERN..]\n+    <PATTERN>         A structured search replace pattern (`$a.foo($b)`)\n+    --debug <snippet> Prints debug information for any nodes with source exactly\n+                      equal to <snippet>\n+\";\n+\n impl Args {\n     pub(crate) fn parse() -> Result<Args> {\n         let mut matches = Arguments::from_env();\n \n         if matches.contains(\"--version\") {\n             matches.finish().or_else(handle_extra_flags)?;\n-            return Ok(Args { verbosity: Verbosity::Normal, command: Command::Version });\n+            return Ok(Args {\n+                verbosity: Verbosity::Normal,\n+                log_file: None,\n+                command: Command::Version,\n+            });\n         }\n \n         let verbosity = match (\n@@ -68,311 +128,100 @@ impl Args {\n             (false, true, false) => Verbosity::Verbose,\n             (false, true, true) => bail!(\"Invalid flags: -q conflicts with -v\"),\n         };\n+        let log_file = matches.opt_value_from_str(\"--log-file\")?;\n+\n+        if matches.contains([\"-h\", \"--help\"]) {\n+            eprintln!(\"{}\", HELP);\n+            return Ok(Args { verbosity, log_file: None, command: Command::Help });\n+        }\n \n-        let help = Ok(Args { verbosity, command: Command::Help });\n         let subcommand = match matches.subcommand()? {\n             Some(it) => it,\n             None => {\n-                if matches.contains([\"-h\", \"--help\"]) {\n-                    print_subcommands();\n-                    return help;\n-                }\n                 matches.finish().or_else(handle_extra_flags)?;\n-                return Ok(Args { verbosity, command: Command::RunServer });\n+                return Ok(Args { verbosity, log_file, command: Command::RunServer });\n             }\n         };\n         let command = match subcommand.as_str() {\n-            \"parse\" => {\n-                if matches.contains([\"-h\", \"--help\"]) {\n-                    eprintln!(\n-                        \"\\\n-rust-analyzer parse\n-\n-USAGE:\n-    rust-analyzer parse [FLAGS]\n-\n-FLAGS:\n-    -h, --help       Prints help information\n-        --no-dump\"\n-                    );\n-                    return help;\n-                }\n-\n-                let no_dump = matches.contains(\"--no-dump\");\n-                matches.finish().or_else(handle_extra_flags)?;\n-                Command::Parse { no_dump }\n-            }\n-            \"symbols\" => {\n-                if matches.contains([\"-h\", \"--help\"]) {\n-                    eprintln!(\n-                        \"\\\n-rust-analyzer symbols\n-\n-USAGE:\n-    rust-analyzer highlight [FLAGS]\n-\n-FLAGS:\n-    -h, --help    Prints help inforamtion\"\n-                    );\n-                    return help;\n-                }\n-\n-                matches.finish().or_else(handle_extra_flags)?;\n-\n-                Command::Symbols\n-            }\n-            \"highlight\" => {\n-                if matches.contains([\"-h\", \"--help\"]) {\n-                    eprintln!(\n-                        \"\\\n-rust-analyzer highlight\n-\n-USAGE:\n-    rust-analyzer highlight [FLAGS]\n-\n-FLAGS:\n-    -h, --help       Prints help information\n-    -r, --rainbow\"\n-                    );\n-                    return help;\n-                }\n-\n-                let rainbow = matches.contains([\"-r\", \"--rainbow\"]);\n-                matches.finish().or_else(handle_extra_flags)?;\n-                Command::Highlight { rainbow }\n-            }\n-            \"analysis-stats\" => {\n-                if matches.contains([\"-h\", \"--help\"]) {\n-                    eprintln!(\n-                        \"\\\n-rust-analyzer analysis-stats\n-\n-USAGE:\n-    rust-analyzer analysis-stats [FLAGS] [OPTIONS] [PATH]\n-\n-FLAGS:\n-    -o, --only              Only analyze items matching this path\n-    -h, --help              Prints help information\n-        --memory-usage      Collect memory usage statistics\n-        --randomize         Randomize order in which crates, modules, and items are processed\n-        --parallel          Run type inference in parallel\n-        --load-output-dirs  Load OUT_DIR values by running `cargo check` before analysis\n-        --with-proc-macro   Use ra-proc-macro-srv for proc-macro expanding\n-        --with-deps         Also analyze all dependencies\n-    -v, --verbose\n-    -q, --quiet\n-\n-OPTIONS:\n-    -o <ONLY>\n-\n-ARGS:\n-    <PATH>\"\n-                    );\n-                    return help;\n-                }\n-\n-                let randomize = matches.contains(\"--randomize\");\n-                let parallel = matches.contains(\"--parallel\");\n-                let memory_usage = matches.contains(\"--memory-usage\");\n-                let only: Option<String> = matches.opt_value_from_str([\"-o\", \"--only\"])?;\n-                let with_deps: bool = matches.contains(\"--with-deps\");\n-                let load_output_dirs = matches.contains(\"--load-output-dirs\");\n-                let with_proc_macro = matches.contains(\"--with-proc-macro\");\n-                let path = {\n-                    let mut trailing = matches.free()?;\n-                    if trailing.len() != 1 {\n-                        bail!(\"Invalid flags\");\n-                    }\n-                    trailing.pop().unwrap().into()\n-                };\n-\n-                Command::AnalysisStats(AnalysisStatsCmd {\n-                    randomize,\n-                    parallel,\n-                    memory_usage,\n-                    only,\n-                    with_deps,\n-                    path,\n-                    load_output_dirs,\n-                    with_proc_macro,\n-                })\n-            }\n-            \"analysis-bench\" => {\n-                if matches.contains([\"-h\", \"--help\"]) {\n-                    eprintln!(\n-                        \"\\\n-rust-analyzer analysis-bench\n-\n-USAGE:\n-    rust-analyzer analysis-bench [FLAGS] [OPTIONS]\n-\n-FLAGS:\n-    -h, --help          Prints help information\n-    --memory-usage      Collect memory usage statistics\n-    --load-output-dirs  Load OUT_DIR values by running `cargo check` before analysis\n-    --with-proc-macro   Use ra-proc-macro-srv for proc-macro expanding\n-    -v, --verbose\n-\n-OPTIONS:\n-    --project <PATH>                 Path to directory with Cargo.toml\n-    --complete <PATH:LINE:COLUMN>    Compute completions at this location\n-    --goto-def <PATH:LINE:COLUMN>    Compute goto definition at this location\n-    --highlight <PATH>               Hightlight this file\n-\n-ARGS:\n-    <PATH>    Project to analyse\"\n-                    );\n-                    return help;\n-                }\n-\n-                let path: PathBuf = matches.opt_value_from_str(\"--project\")?.unwrap_or_default();\n-                let highlight_path: Option<String> = matches.opt_value_from_str(\"--highlight\")?;\n-                let complete_path: Option<Position> = matches.opt_value_from_str(\"--complete\")?;\n-                let goto_def_path: Option<Position> = matches.opt_value_from_str(\"--goto-def\")?;\n-                let what = match (highlight_path, complete_path, goto_def_path) {\n-                    (Some(path), None, None) => {\n-                        let path = env::current_dir().unwrap().join(path);\n-                        BenchWhat::Highlight { path: AbsPathBuf::assert(path) }\n+            \"parse\" => Command::Parse { no_dump: matches.contains(\"--no-dump\") },\n+            \"symbols\" => Command::Symbols,\n+            \"highlight\" => Command::Highlight { rainbow: matches.contains(\"--rainbow\") },\n+            \"analysis-stats\" => Command::AnalysisStats(AnalysisStatsCmd {\n+                randomize: matches.contains(\"--randomize\"),\n+                parallel: matches.contains(\"--parallel\"),\n+                memory_usage: matches.contains(\"--memory-usage\"),\n+                only: matches.opt_value_from_str([\"-o\", \"--only\"])?,\n+                with_deps: matches.contains(\"--with-deps\"),\n+                load_output_dirs: matches.contains(\"--load-output-dirs\"),\n+                with_proc_macro: matches.contains(\"--with-proc-macro\"),\n+                path: matches\n+                    .free_from_str()?\n+                    .ok_or_else(|| format_err!(\"expected positional argument\"))?,\n+            }),\n+            \"analysis-bench\" => Command::Bench(BenchCmd {\n+                what: {\n+                    let highlight_path: Option<String> =\n+                        matches.opt_value_from_str(\"--highlight\")?;\n+                    let complete_path: Option<Position> =\n+                        matches.opt_value_from_str(\"--complete\")?;\n+                    let goto_def_path: Option<Position> =\n+                        matches.opt_value_from_str(\"--goto-def\")?;\n+                    match (highlight_path, complete_path, goto_def_path) {\n+                            (Some(path), None, None) => {\n+                                let path = env::current_dir().unwrap().join(path);\n+                                BenchWhat::Highlight { path: AbsPathBuf::assert(path) }\n+                            }\n+                            (None, Some(position), None) => BenchWhat::Complete(position),\n+                            (None, None, Some(position)) => BenchWhat::GotoDef(position),\n+                            _ => panic!(\n+                                \"exactly one of  `--highlight`, `--complete` or `--goto-def` must be set\"\n+                            ),\n+                        }\n+                },\n+                memory_usage: matches.contains(\"--memory-usage\"),\n+                load_output_dirs: matches.contains(\"--load-output-dirs\"),\n+                with_proc_macro: matches.contains(\"--with-proc-macro\"),\n+                path: matches\n+                    .free_from_str()?\n+                    .ok_or_else(|| format_err!(\"expected positional argument\"))?,\n+            }),\n+            \"diagnostics\" => Command::Diagnostics {\n+                load_output_dirs: matches.contains(\"--load-output-dirs\"),\n+                with_proc_macro: matches.contains(\"--with-proc-macro\"),\n+                path: matches\n+                    .free_from_str()?\n+                    .ok_or_else(|| format_err!(\"expected positional argument\"))?,\n+            },\n+            \"proc-macro\" => Command::ProcMacro,\n+            \"ssr\" => Command::Ssr {\n+                rules: {\n+                    let mut acc = Vec::new();\n+                    while let Some(rule) = matches.free_from_str()? {\n+                        acc.push(rule);\n                     }\n-                    (None, Some(position), None) => BenchWhat::Complete(position),\n-                    (None, None, Some(position)) => BenchWhat::GotoDef(position),\n-                    _ => panic!(\n-                        \"exactly one of  `--highlight`, `--complete` or `--goto-def` must be set\"\n-                    ),\n-                };\n-                let memory_usage = matches.contains(\"--memory-usage\");\n-                let load_output_dirs = matches.contains(\"--load-output-dirs\");\n-                let with_proc_macro = matches.contains(\"--with-proc-macro\");\n-                Command::Bench(BenchCmd {\n-                    memory_usage,\n-                    path,\n-                    what,\n-                    load_output_dirs,\n-                    with_proc_macro,\n-                })\n-            }\n-            \"diagnostics\" => {\n-                if matches.contains([\"-h\", \"--help\"]) {\n-                    eprintln!(\n-                        \"\\\n-rust-analyzer diagnostics\n-\n-USAGE:\n-    rust-analyzer diagnostics [FLAGS] [PATH]\n-\n-FLAGS:\n-    -h, --help              Prints help information\n-        --load-output-dirs  Load OUT_DIR values by running `cargo check` before analysis\n-        --all               Include all files rather than only modules\n-\n-ARGS:\n-    <PATH>\"\n-                    );\n-                    return help;\n-                }\n-\n-                let load_output_dirs = matches.contains(\"--load-output-dirs\");\n-                let with_proc_macro = matches.contains(\"--with-proc-macro\");\n-                let all = matches.contains(\"--all\");\n-                let path = {\n-                    let mut trailing = matches.free()?;\n-                    if trailing.len() != 1 {\n-                        bail!(\"Invalid flags\");\n+                    acc\n+                },\n+            },\n+            \"search\" => Command::StructuredSearch {\n+                debug_snippet: matches.opt_value_from_str(\"--debug\")?,\n+                patterns: {\n+                    let mut acc = Vec::new();\n+                    while let Some(rule) = matches.free_from_str()? {\n+                        acc.push(rule);\n                     }\n-                    trailing.pop().unwrap().into()\n-                };\n-\n-                Command::Diagnostics { path, load_output_dirs, with_proc_macro, all }\n-            }\n-            \"proc-macro\" => Command::ProcMacro,\n-            \"ssr\" => {\n-                if matches.contains([\"-h\", \"--help\"]) {\n-                    eprintln!(\n-                        \"\\\n-rust-analyzer ssr\n-\n-USAGE:\n-    rust-analyzer ssr [FLAGS] [RULE...]\n-\n-EXAMPLE:\n-    rust-analyzer ssr '$a.foo($b) ==> bar($a, $b)'\n-\n-FLAGS:\n-    --debug <snippet>   Prints debug information for any nodes with source exactly equal to <snippet>\n-    -h, --help          Prints help information\n-\n-ARGS:\n-    <RULE>              A structured search replace rule\"\n-                    );\n-                    return help;\n-                }\n-                let mut rules = Vec::new();\n-                while let Some(rule) = matches.free_from_str()? {\n-                    rules.push(rule);\n-                }\n-                Command::Ssr { rules }\n-            }\n-            \"search\" => {\n-                if matches.contains([\"-h\", \"--help\"]) {\n-                    eprintln!(\n-                        \"\\\n-rust-analyzer search\n-\n-USAGE:\n-    rust-analyzer search [FLAGS] [PATTERN...]\n-\n-EXAMPLE:\n-    rust-analyzer search '$a.foo($b)'\n-\n-FLAGS:\n-    --debug <snippet>   Prints debug information for any nodes with source exactly equal to <snippet>\n-    -h, --help          Prints help information\n-\n-ARGS:\n-    <PATTERN>           A structured search pattern\"\n-                    );\n-                    return help;\n-                }\n-                let debug_snippet = matches.opt_value_from_str(\"--debug\")?;\n-                let mut patterns = Vec::new();\n-                while let Some(rule) = matches.free_from_str()? {\n-                    patterns.push(rule);\n-                }\n-                Command::StructuredSearch { patterns, debug_snippet }\n-            }\n+                    acc\n+                },\n+            },\n             _ => {\n-                print_subcommands();\n-                return help;\n+                eprintln!(\"{}\", HELP);\n+                return Ok(Args { verbosity, log_file: None, command: Command::Help });\n             }\n         };\n-        Ok(Args { verbosity, command })\n+        matches.finish().or_else(handle_extra_flags)?;\n+        Ok(Args { verbosity, log_file, command })\n     }\n }\n \n-fn print_subcommands() {\n-    eprintln!(\n-        \"\\\n-rust-analyzer\n-\n-USAGE:\n-    rust-analyzer <SUBCOMMAND>\n-\n-FLAGS:\n-    -h, --help        Prints help information\n-\n-SUBCOMMANDS:\n-    analysis-bench\n-    analysis-stats\n-    highlight\n-    diagnostics\n-    proc-macro\n-    parse\n-    search\n-    ssr\n-    symbols\"\n-    )\n-}\n-\n fn handle_extra_flags(e: pico_args::Error) -> Result<()> {\n     if let pico_args::Error::UnusedArgsLeft(flags) = e {\n         let mut invalid_flags = String::new();"}, {"sha": "3bcb1ae37d4c77a99ff4202672f7359930de8e05", "filename": "crates/rust-analyzer/src/bin/logger.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/868aaf2bc61627ae8e5d920c38b2666756743515/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868aaf2bc61627ae8e5d920c38b2666756743515/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs?ref=868aaf2bc61627ae8e5d920c38b2666756743515", "patch": "@@ -0,0 +1,73 @@\n+//! Simple logger that logs either to stderr or to a file, using `env_logger`\n+//! filter syntax. Amusingly, there's no crates.io crate that can do this and\n+//! only this.\n+\n+use std::{\n+    fs::File,\n+    io::{BufWriter, Write},\n+};\n+\n+use env_logger::filter::{Builder, Filter};\n+use log::{Log, Metadata, Record};\n+use parking_lot::Mutex;\n+\n+pub(crate) struct Logger {\n+    filter: Filter,\n+    file: Option<Mutex<BufWriter<File>>>,\n+}\n+\n+impl Logger {\n+    pub(crate) fn new(log_file: Option<File>, filter: Option<&str>) -> Logger {\n+        let filter = {\n+            let mut builder = Builder::new();\n+            if let Some(filter) = filter {\n+                builder.parse(filter);\n+            }\n+            builder.build()\n+        };\n+\n+        let file = log_file.map(|it| Mutex::new(BufWriter::new(it)));\n+\n+        Logger { filter, file }\n+    }\n+\n+    pub(crate) fn install(self) {\n+        let max_level = self.filter.filter();\n+        let _ = log::set_boxed_logger(Box::new(self)).map(|()| log::set_max_level(max_level));\n+    }\n+}\n+\n+impl Log for Logger {\n+    fn enabled(&self, metadata: &Metadata) -> bool {\n+        self.filter.enabled(metadata)\n+    }\n+\n+    fn log(&self, record: &Record) {\n+        if !self.filter.matches(record) {\n+            return;\n+        }\n+        match &self.file {\n+            Some(w) => {\n+                let _ = writeln!(\n+                    w.lock(),\n+                    \"[{} {}] {}\",\n+                    record.level(),\n+                    record.module_path().unwrap_or_default(),\n+                    record.args(),\n+                );\n+            }\n+            None => eprintln!(\n+                \"[{} {}] {}\",\n+                record.level(),\n+                record.module_path().unwrap_or_default(),\n+                record.args(),\n+            ),\n+        }\n+    }\n+\n+    fn flush(&self) {\n+        if let Some(w) = &self.file {\n+            let _ = w.lock().flush();\n+        }\n+    }\n+}"}, {"sha": "ba4402ade3013c925ca40c8cd6f4f12578520c4c", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/868aaf2bc61627ae8e5d920c38b2666756743515/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868aaf2bc61627ae8e5d920c38b2666756743515/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=868aaf2bc61627ae8e5d920c38b2666756743515", "patch": "@@ -2,8 +2,9 @@\n //!\n //! Based on cli flags, either spawns an LSP server, or runs a batch analysis\n mod args;\n+mod logger;\n \n-use std::{convert::TryFrom, process};\n+use std::{convert::TryFrom, env, fs, path::PathBuf, process};\n \n use lsp_server::Connection;\n use project_model::ProjectManifest;\n@@ -26,8 +27,8 @@ fn main() {\n }\n \n fn try_main() -> Result<()> {\n-    setup_logging()?;\n     let args = args::Args::parse()?;\n+    setup_logging(args.log_file)?;\n     match args.command {\n         args::Command::RunServer => run_server()?,\n         args::Command::ProcMacro => proc_macro_srv::cli::run()?,\n@@ -37,8 +38,8 @@ fn try_main() -> Result<()> {\n         args::Command::Highlight { rainbow } => cli::highlight(rainbow)?,\n         args::Command::AnalysisStats(cmd) => cmd.run(args.verbosity)?,\n         args::Command::Bench(cmd) => cmd.run(args.verbosity)?,\n-        args::Command::Diagnostics { path, load_output_dirs, with_proc_macro, all } => {\n-            cli::diagnostics(path.as_ref(), load_output_dirs, with_proc_macro, all)?\n+        args::Command::Diagnostics { path, load_output_dirs, with_proc_macro } => {\n+            cli::diagnostics(path.as_ref(), load_output_dirs, with_proc_macro)?\n         }\n         args::Command::Ssr { rules } => {\n             cli::apply_ssr_rules(rules)?;\n@@ -52,9 +53,21 @@ fn try_main() -> Result<()> {\n     Ok(())\n }\n \n-fn setup_logging() -> Result<()> {\n-    std::env::set_var(\"RUST_BACKTRACE\", \"short\");\n-    env_logger::try_init_from_env(\"RA_LOG\")?;\n+fn setup_logging(log_file: Option<PathBuf>) -> Result<()> {\n+    env::set_var(\"RUST_BACKTRACE\", \"short\");\n+\n+    let log_file = match log_file {\n+        Some(path) => {\n+            if let Some(parent) = path.parent() {\n+                let _ = fs::create_dir_all(parent);\n+            }\n+            Some(fs::File::create(path)?)\n+        }\n+        None => None,\n+    };\n+    let filter = env::var(\"RA_LOG\").ok();\n+    logger::Logger::new(log_file, filter.as_deref()).install();\n+\n     profile::init();\n     Ok(())\n }\n@@ -95,7 +108,7 @@ fn run_server() -> Result<()> {\n         {\n             Some(it) => it,\n             None => {\n-                let cwd = std::env::current_dir()?;\n+                let cwd = env::current_dir()?;\n                 AbsPathBuf::assert(cwd)\n             }\n         };"}, {"sha": "f3b6c900e6b65f3b120c2582d37c573460046f92", "filename": "crates/rust-analyzer/src/cli/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/868aaf2bc61627ae8e5d920c38b2666756743515/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868aaf2bc61627ae8e5d920c38b2666756743515/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=868aaf2bc61627ae8e5d920c38b2666756743515", "patch": "@@ -12,12 +12,7 @@ use ide::{DiagnosticsConfig, Severity};\n \n use crate::cli::{load_cargo::load_cargo, Result};\n \n-pub fn diagnostics(\n-    path: &Path,\n-    load_output_dirs: bool,\n-    with_proc_macro: bool,\n-    _all: bool,\n-) -> Result<()> {\n+pub fn diagnostics(path: &Path, load_output_dirs: bool, with_proc_macro: bool) -> Result<()> {\n     let (host, _vfs) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n     let db = host.raw_database();\n     let analysis = host.analysis();"}, {"sha": "8c966288b75c6d1b162ea906f7057c65d49fc756", "filename": "docs/user/manual.adoc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/868aaf2bc61627ae8e5d920c38b2666756743515/docs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/868aaf2bc61627ae8e5d920c38b2666756743515/docs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fmanual.adoc?ref=868aaf2bc61627ae8e5d920c38b2666756743515", "patch": "@@ -351,7 +351,7 @@ Relative paths are interpreted relative to `rust-project.json` file location or\n \n See https://github.com/rust-analyzer/rust-project.json-example for a small example.\n \n-You can set `RA_LOG` environmental variable to `\"'rust_analyzer=info\"` to inspect how rust-analyzer handles config and project loading.\n+You can set `RA_LOG` environmental variable to `rust_analyzer=info` to inspect how rust-analyzer handles config and project loading.\n \n == Features\n "}]}