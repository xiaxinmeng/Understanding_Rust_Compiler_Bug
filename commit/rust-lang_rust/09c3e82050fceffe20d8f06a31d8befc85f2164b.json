{"sha": "09c3e82050fceffe20d8f06a31d8befc85f2164b", "node_id": "C_kwDOAAsO6NoAKDA5YzNlODIwNTBmY2VmZmUyMGQ4ZjA2YTMxZDhiZWZjODVmMjE2NGI", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-09T03:18:32Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-11T02:56:54Z"}, "message": "Refactor the second half of `parse_tt`.\n\nThe current structure makes it hard to tell that there are just four\ndistinct code paths, depending on how many items there are in `bb_items`\nand `next_items`. This commit introduces a `match` that clarifies\nthings.", "tree": {"sha": "4c6aca06620ce6637e7f992b4b49909ed8cebf97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c6aca06620ce6637e7f992b4b49909ed8cebf97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09c3e82050fceffe20d8f06a31d8befc85f2164b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09c3e82050fceffe20d8f06a31d8befc85f2164b", "html_url": "https://github.com/rust-lang/rust/commit/09c3e82050fceffe20d8f06a31d8befc85f2164b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09c3e82050fceffe20d8f06a31d8befc85f2164b/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "352e621368c31d7b4a6362e081586cdb931ba020", "url": "https://api.github.com/repos/rust-lang/rust/commits/352e621368c31d7b4a6362e081586cdb931ba020", "html_url": "https://github.com/rust-lang/rust/commit/352e621368c31d7b4a6362e081586cdb931ba020"}], "stats": {"total": 129, "additions": 68, "deletions": 61}, "files": [{"sha": "718f155c60c05edc8318465b683749d5177f9be0", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 68, "deletions": 61, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/09c3e82050fceffe20d8f06a31d8befc85f2164b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c3e82050fceffe20d8f06a31d8befc85f2164b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=09c3e82050fceffe20d8f06a31d8befc85f2164b", "patch": "@@ -744,70 +744,77 @@ pub(super) fn parse_tt(\n         // unnecessary implicit clone later in `Rc::make_mut`.\n         drop(eof_items);\n \n-        // If there are no possible next positions AND we aren't waiting for the black-box parser,\n-        // then there is a syntax error.\n-        if bb_items.is_empty() && next_items.is_empty() {\n-            return Failure(parser.token.clone(), \"no rules expected this token in macro call\");\n-        }\n+        match (next_items.len(), bb_items.len()) {\n+            (0, 0) => {\n+                // There are no possible next positions AND we aren't waiting for the black-box\n+                // parser: syntax error.\n+                return Failure(parser.token.clone(), \"no rules expected this token in macro call\");\n+            }\n \n-        if (!bb_items.is_empty() && !next_items.is_empty()) || bb_items.len() > 1 {\n-            // We need to call out to parse some rust nonterminal (black-box) parser. But something\n-            // is wrong, because there is not EXACTLY ONE of these.\n-            let nts = bb_items\n-                .iter()\n-                .map(|item| match item.top_elts.get_tt(item.idx) {\n-                    TokenTree::MetaVarDecl(_, bind, Some(kind)) => format!(\"{} ('{}')\", kind, bind),\n-                    _ => panic!(),\n-                })\n-                .collect::<Vec<String>>()\n-                .join(\" or \");\n-\n-            return Error(\n-                parser.token.span,\n-                format!(\n-                    \"local ambiguity when calling macro `{macro_name}`: multiple parsing options: {}\",\n-                    match next_items.len() {\n-                        0 => format!(\"built-in NTs {}.\", nts),\n-                        1 => format!(\"built-in NTs {} or 1 other option.\", nts),\n-                        n => format!(\"built-in NTs {} or {} other options.\", nts, n),\n-                    }\n-                ),\n-            );\n-        }\n+            (_, 0) => {\n+                // Dump all possible `next_items` into `cur_items` for the next iteration. Then\n+                // process the next token.\n+                cur_items.extend(next_items.drain(..));\n+                parser.to_mut().bump();\n+            }\n \n-        if !next_items.is_empty() {\n-            // Dump all possible `next_items` into `cur_items` for the next iteration. Then process\n-            // the next token.\n-            cur_items.extend(next_items.drain(..));\n-            parser.to_mut().bump();\n-        } else {\n-            // Finally, we have the case where we need to call the black-box parser to get some\n-            // nonterminal.\n-            assert_eq!(bb_items.len(), 1);\n-\n-            let mut item = bb_items.pop().unwrap();\n-            if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts.get_tt(item.idx) {\n-                let match_cur = item.match_cur;\n-                // We use the span of the metavariable declaration to determine any\n-                // edition-specific matching behavior for non-terminals.\n-                let nt = match parser.to_mut().parse_nonterminal(kind) {\n-                    Err(mut err) => {\n-                        err.span_label(\n-                            span,\n-                            format!(\"while parsing argument for this `{}` macro fragment\", kind),\n-                        )\n-                        .emit();\n-                        return ErrorReported;\n-                    }\n-                    Ok(nt) => nt,\n-                };\n-                item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n-                item.idx += 1;\n-                item.match_cur += 1;\n-            } else {\n-                unreachable!()\n+            (0, 1) => {\n+                // We need to call the black-box parser to get some nonterminal.\n+                let mut item = bb_items.pop().unwrap();\n+                if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts.get_tt(item.idx)\n+                {\n+                    let match_cur = item.match_cur;\n+                    // We use the span of the metavariable declaration to determine any\n+                    // edition-specific matching behavior for non-terminals.\n+                    let nt = match parser.to_mut().parse_nonterminal(kind) {\n+                        Err(mut err) => {\n+                            err.span_label(\n+                                span,\n+                                format!(\n+                                    \"while parsing argument for this `{}` macro fragment\",\n+                                    kind\n+                                ),\n+                            )\n+                            .emit();\n+                            return ErrorReported;\n+                        }\n+                        Ok(nt) => nt,\n+                    };\n+                    item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n+                    item.idx += 1;\n+                    item.match_cur += 1;\n+                } else {\n+                    unreachable!()\n+                }\n+                cur_items.push(item);\n+            }\n+\n+            (_, _) => {\n+                // We need to call the black-box parser to get some nonterminal, but something is\n+                // wrong.\n+                let nts = bb_items\n+                    .iter()\n+                    .map(|item| match item.top_elts.get_tt(item.idx) {\n+                        TokenTree::MetaVarDecl(_, bind, Some(kind)) => {\n+                            format!(\"{} ('{}')\", kind, bind)\n+                        }\n+                        _ => panic!(),\n+                    })\n+                    .collect::<Vec<String>>()\n+                    .join(\" or \");\n+\n+                return Error(\n+                    parser.token.span,\n+                    format!(\n+                        \"local ambiguity when calling macro `{macro_name}`: multiple parsing options: {}\",\n+                        match next_items.len() {\n+                            0 => format!(\"built-in NTs {}.\", nts),\n+                            1 => format!(\"built-in NTs {} or 1 other option.\", nts),\n+                            n => format!(\"built-in NTs {} or {} other options.\", nts, n),\n+                        }\n+                    ),\n+                );\n             }\n-            cur_items.push(item);\n         }\n \n         assert!(!cur_items.is_empty());"}]}