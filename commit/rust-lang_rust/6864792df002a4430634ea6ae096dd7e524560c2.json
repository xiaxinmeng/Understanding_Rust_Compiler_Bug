{"sha": "6864792df002a4430634ea6ae096dd7e524560c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NjQ3OTJkZjAwMmE0NDMwNjM0ZWE2YWUwOTZkZDdlNTI0NTYwYzI=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-02-12T03:53:10Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-02-12T20:44:31Z"}, "message": "Separate macro and plugin loading\n\nNow they just share a bit of code internal to creader.\n\nResolves #22198 to my satisfaction.", "tree": {"sha": "ed58a4df4bd2110bf783b693ad69245280fbadd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed58a4df4bd2110bf783b693ad69245280fbadd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6864792df002a4430634ea6ae096dd7e524560c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6864792df002a4430634ea6ae096dd7e524560c2", "html_url": "https://github.com/rust-lang/rust/commit/6864792df002a4430634ea6ae096dd7e524560c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6864792df002a4430634ea6ae096dd7e524560c2/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b784bacbfb3135bd34cd994023ac1e841ad9ceb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b784bacbfb3135bd34cd994023ac1e841ad9ceb", "html_url": "https://github.com/rust-lang/rust/commit/6b784bacbfb3135bd34cd994023ac1e841ad9ceb"}], "stats": {"total": 376, "additions": 205, "deletions": 171}, "files": [{"sha": "28c98d455f046dc2e04601c1ce421275b52492af", "filename": "src/librustc/metadata/macro_import.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/6864792df002a4430634ea6ae096dd7e524560c2/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6864792df002a4430634ea6ae096dd7e524560c2/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=6864792df002a4430634ea6ae096dd7e524560c2", "patch": "@@ -0,0 +1,186 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Used by `rustc` when loading a crate with exported macros.\n+\n+use session::Session;\n+use metadata::creader::CrateReader;\n+\n+use std::collections::{HashSet, HashMap};\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+use syntax::attr::AttrMetaMethods;\n+\n+struct MacroLoader<'a> {\n+    sess: &'a Session,\n+    span_whitelist: HashSet<Span>,\n+    reader: CrateReader<'a>,\n+    macros: Vec<ast::MacroDef>,\n+}\n+\n+impl<'a> MacroLoader<'a> {\n+    fn new(sess: &'a Session) -> MacroLoader<'a> {\n+        MacroLoader {\n+            sess: sess,\n+            span_whitelist: HashSet::new(),\n+            reader: CrateReader::new(sess),\n+            macros: vec![],\n+        }\n+    }\n+}\n+\n+/// Read exported macros.\n+pub fn read_macro_defs(sess: &Session, krate: &ast::Crate) -> Vec<ast::MacroDef> {\n+    let mut loader = MacroLoader::new(sess);\n+\n+    // We need to error on `#[macro_use] extern crate` when it isn't at the\n+    // crate root, because `$crate` won't work properly. Identify these by\n+    // spans, because the crate map isn't set up yet.\n+    for item in &krate.module.items {\n+        if let ast::ItemExternCrate(_) = item.node {\n+            loader.span_whitelist.insert(item.span);\n+        }\n+    }\n+\n+    visit::walk_crate(&mut loader, krate);\n+\n+    loader.macros\n+}\n+\n+pub type MacroSelection = HashMap<token::InternedString, Span>;\n+\n+// note that macros aren't expanded yet, and therefore macros can't add macro imports.\n+impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        // We're only interested in `extern crate`.\n+        match item.node {\n+            ast::ItemExternCrate(_) => {}\n+            _ => {\n+                visit::walk_item(self, item);\n+                return;\n+            }\n+        }\n+\n+        // Parse the attributes relating to macros.\n+        let mut import = Some(HashMap::new());  // None => load all\n+        let mut reexport = HashMap::new();\n+\n+        for attr in &item.attrs {\n+            let mut used = true;\n+            match &attr.name()[] {\n+                \"phase\" => {\n+                    self.sess.span_err(attr.span, \"#[phase] is deprecated\");\n+                }\n+                \"plugin\" => {\n+                    self.sess.span_err(attr.span, \"#[plugin] on `extern crate` is deprecated\");\n+                    self.sess.span_help(attr.span, &format!(\"use a crate attribute instead, \\\n+                                                            i.e. #![plugin({})]\",\n+                                                            item.ident.as_str())[]);\n+                }\n+                \"macro_use\" => {\n+                    let names = attr.meta_item_list();\n+                    if names.is_none() {\n+                        // no names => load all\n+                        import = None;\n+                    }\n+                    if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n+                        for attr in names {\n+                            if let ast::MetaWord(ref name) = attr.node {\n+                                sel.insert(name.clone(), attr.span);\n+                            } else {\n+                                self.sess.span_err(attr.span, \"bad macro import\");\n+                            }\n+                        }\n+                    }\n+                }\n+                \"macro_reexport\" => {\n+                    let names = match attr.meta_item_list() {\n+                        Some(names) => names,\n+                        None => {\n+                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                            continue;\n+                        }\n+                    };\n+\n+                    for attr in names {\n+                        if let ast::MetaWord(ref name) = attr.node {\n+                            reexport.insert(name.clone(), attr.span);\n+                        } else {\n+                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                        }\n+                    }\n+                }\n+                _ => used = false,\n+            }\n+            if used {\n+                attr::mark_used(attr);\n+            }\n+        }\n+\n+        self.load_macros(item, import, reexport)\n+    }\n+\n+    fn visit_mac(&mut self, _: &ast::Mac) {\n+        // bummer... can't see macro imports inside macros.\n+        // do nothing.\n+    }\n+}\n+\n+impl<'a> MacroLoader<'a> {\n+    fn load_macros<'b>(&mut self,\n+                       vi: &ast::Item,\n+                       import: Option<MacroSelection>,\n+                       reexport: MacroSelection) {\n+        if let Some(sel) = import.as_ref() {\n+            if sel.is_empty() && reexport.is_empty() {\n+                return;\n+            }\n+        }\n+\n+        if !self.span_whitelist.contains(&vi.span) {\n+            self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n+                                         the crate root\");\n+            return;\n+        }\n+\n+        let macros = self.reader.read_exported_macros(vi);\n+        let mut seen = HashSet::new();\n+\n+        for mut def in macros {\n+            let name = token::get_ident(def.ident);\n+            seen.insert(name.clone());\n+\n+            def.use_locally = match import.as_ref() {\n+                None => true,\n+                Some(sel) => sel.contains_key(&name),\n+            };\n+            def.export = reexport.contains_key(&name);\n+            self.macros.push(def);\n+        }\n+\n+        if let Some(sel) = import.as_ref() {\n+            for (name, span) in sel.iter() {\n+                if !seen.contains(name) {\n+                    self.sess.span_err(*span, \"imported macro not found\");\n+                }\n+            }\n+        }\n+\n+        for (name, span) in reexport.iter() {\n+            if !seen.contains(name) {\n+                self.sess.span_err(*span, \"reexported macro not found\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "0bf1e6d198fa2ad1fab28f8f611c6d4ae06a7c24", "filename": "src/librustc/metadata/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6864792df002a4430634ea6ae096dd7e524560c2/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6864792df002a4430634ea6ae096dd7e524560c2/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=6864792df002a4430634ea6ae096dd7e524560c2", "patch": "@@ -18,3 +18,4 @@ pub mod cstore;\n pub mod csearch;\n pub mod loader;\n pub mod filesearch;\n+pub mod macro_import;"}, {"sha": "1895cbcb5421e341f051dd3b4c6109b8dc6f811e", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 12, "deletions": 167, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/6864792df002a4430634ea6ae096dd7e524560c2/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6864792df002a4430634ea6ae096dd7e524560c2/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=6864792df002a4430634ea6ae096dd7e524560c2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Used by `rustc` when loading a plugin, or a crate with exported macros.\n+//! Used by `rustc` when loading a plugin.\n \n use session::Session;\n use metadata::creader::CrateReader;\n@@ -17,15 +17,10 @@ use plugin::registry::Registry;\n use std::mem;\n use std::env;\n use std::dynamic_lib::DynamicLibrary;\n-use std::collections::{HashSet, HashMap};\n use std::borrow::ToOwned;\n use syntax::ast;\n-use syntax::attr;\n use syntax::codemap::{Span, COMMAND_LINE_SP};\n-use syntax::parse::token;\n use syntax::ptr::P;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n use syntax::attr::AttrMetaMethods;\n \n /// Pointer to a registrar function.\n@@ -37,51 +32,17 @@ pub struct PluginRegistrar {\n     pub args: Vec<P<ast::MetaItem>>,\n }\n \n-/// Information about loaded plugins.\n-pub struct Plugins {\n-    /// Imported macros.\n-    pub macros: Vec<ast::MacroDef>,\n-    /// Registrars, as function pointers.\n-    pub registrars: Vec<PluginRegistrar>,\n-}\n-\n-pub struct PluginLoader<'a> {\n+struct PluginLoader<'a> {\n     sess: &'a Session,\n-    span_whitelist: HashSet<Span>,\n     reader: CrateReader<'a>,\n-    pub plugins: Plugins,\n-}\n-\n-impl<'a> PluginLoader<'a> {\n-    fn new(sess: &'a Session) -> PluginLoader<'a> {\n-        PluginLoader {\n-            sess: sess,\n-            reader: CrateReader::new(sess),\n-            span_whitelist: HashSet::new(),\n-            plugins: Plugins {\n-                macros: vec!(),\n-                registrars: vec!(),\n-            },\n-        }\n-    }\n+    plugins: Vec<PluginRegistrar>,\n }\n \n /// Read plugin metadata and dynamically load registrar functions.\n pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n-                    addl_plugins: Option<Vec<String>>) -> Plugins {\n+                    addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n     let mut loader = PluginLoader::new(sess);\n \n-    // We need to error on `#[macro_use] extern crate` when it isn't at the\n-    // crate root, because `$crate` won't work properly. Identify these by\n-    // spans, because the crate map isn't set up yet.\n-    for item in &krate.module.items {\n-        if let ast::ItemExternCrate(_) = item.node {\n-            loader.span_whitelist.insert(item.span);\n-        }\n-    }\n-\n-    visit::walk_crate(&mut loader, krate);\n-\n     for attr in &krate.attrs {\n         if !attr.check_name(\"plugin\") {\n             continue;\n@@ -112,140 +73,24 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n         }\n     }\n \n-    return loader.plugins;\n-}\n-\n-pub type MacroSelection = HashMap<token::InternedString, Span>;\n-\n-// note that macros aren't expanded yet, and therefore macros can't add plugins.\n-impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        // We're only interested in `extern crate`.\n-        match item.node {\n-            ast::ItemExternCrate(_) => {}\n-            _ => {\n-                visit::walk_item(self, item);\n-                return;\n-            }\n-        }\n-\n-        // Parse the attributes relating to macro loading.\n-        let mut import = Some(HashMap::new());  // None => load all\n-        let mut reexport = HashMap::new();\n-        for attr in &item.attrs {\n-            let mut used = true;\n-            match &attr.name()[] {\n-                \"phase\" => {\n-                    self.sess.span_err(attr.span, \"#[phase] is deprecated\");\n-                }\n-                \"plugin\" => {\n-                    self.sess.span_err(attr.span, \"#[plugin] on `extern crate` is deprecated\");\n-                    self.sess.span_help(attr.span, &format!(\"use a crate attribute instead, \\\n-                                                            i.e. #![plugin({})]\",\n-                                                            item.ident.as_str())[]);\n-                }\n-                \"macro_use\" => {\n-                    let names = attr.meta_item_list();\n-                    if names.is_none() {\n-                        // no names => load all\n-                        import = None;\n-                    }\n-                    if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n-                        for attr in names {\n-                            if let ast::MetaWord(ref name) = attr.node {\n-                                sel.insert(name.clone(), attr.span);\n-                            } else {\n-                                self.sess.span_err(attr.span, \"bad macro import\");\n-                            }\n-                        }\n-                    }\n-                }\n-                \"macro_reexport\" => {\n-                    let names = match attr.meta_item_list() {\n-                        Some(names) => names,\n-                        None => {\n-                            self.sess.span_err(attr.span, \"bad macro reexport\");\n-                            continue;\n-                        }\n-                    };\n-\n-                    for attr in names {\n-                        if let ast::MetaWord(ref name) = attr.node {\n-                            reexport.insert(name.clone(), attr.span);\n-                        } else {\n-                            self.sess.span_err(attr.span, \"bad macro reexport\");\n-                        }\n-                    }\n-                }\n-                _ => used = false,\n-            }\n-            if used {\n-                attr::mark_used(attr);\n-            }\n-        }\n-\n-        self.load_macros(item, import, reexport)\n-    }\n-\n-    fn visit_mac(&mut self, _: &ast::Mac) {\n-        // bummer... can't see plugins inside macros.\n-        // do nothing.\n-    }\n+    loader.plugins\n }\n \n impl<'a> PluginLoader<'a> {\n-    pub fn load_macros<'b>(&mut self,\n-                           vi: &ast::Item,\n-                           import: Option<MacroSelection>,\n-                           reexport: MacroSelection) {\n-        if let Some(sel) = import.as_ref() {\n-            if sel.is_empty() && reexport.is_empty() {\n-                return;\n-            }\n-        }\n-\n-        if !self.span_whitelist.contains(&vi.span) {\n-            self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n-                                         the crate root\");\n-            return;\n-        }\n-\n-        let macros = self.reader.read_exported_macros(vi);\n-        let mut seen = HashSet::new();\n-\n-        for mut def in macros {\n-            let name = token::get_ident(def.ident);\n-            seen.insert(name.clone());\n-\n-            def.use_locally = match import.as_ref() {\n-                None => true,\n-                Some(sel) => sel.contains_key(&name),\n-            };\n-            def.export = reexport.contains_key(&name);\n-            self.plugins.macros.push(def);\n-        }\n-\n-        if let Some(sel) = import.as_ref() {\n-            for (name, span) in sel.iter() {\n-                if !seen.contains(name) {\n-                    self.sess.span_err(*span, \"imported macro not found\");\n-                }\n-            }\n-        }\n-\n-        for (name, span) in reexport.iter() {\n-            if !seen.contains(name) {\n-                self.sess.span_err(*span, \"reexported macro not found\");\n-            }\n+    fn new(sess: &'a Session) -> PluginLoader<'a> {\n+        PluginLoader {\n+            sess: sess,\n+            reader: CrateReader::new(sess),\n+            plugins: vec![],\n         }\n     }\n \n-    pub fn load_plugin(&mut self, span: Span, name: &str, args: Vec<P<ast::MetaItem>>) {\n+    fn load_plugin(&mut self, span: Span, name: &str, args: Vec<P<ast::MetaItem>>) {\n         let registrar = self.reader.find_plugin_registrar(span, name);\n \n         if let Some((lib, symbol)) = registrar {\n             let fun = self.dylink_registrar(span, lib, symbol);\n-            self.plugins.registrars.push(PluginRegistrar {\n+            self.plugins.push(PluginRegistrar {\n                 fun: fun,\n                 args: args,\n             });"}, {"sha": "5461279f17bfb538b29812c501e521e7c3ae51e3", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6864792df002a4430634ea6ae096dd7e524560c2/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6864792df002a4430634ea6ae096dd7e524560c2/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6864792df002a4430634ea6ae096dd7e524560c2", "patch": "@@ -12,11 +12,11 @@ use rustc::session::Session;\n use rustc::session::config::{self, Input, OutputFilenames};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n+use rustc::metadata;\n use rustc::metadata::creader::CrateReader;\n use rustc::middle::{stability, ty, reachable};\n use rustc::middle::dependency_format;\n use rustc::middle;\n-use rustc::plugin::load::Plugins;\n use rustc::plugin::registry::Registry;\n use rustc::plugin;\n use rustc::util::common::time;\n@@ -409,10 +409,12 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                  syntax::std_inject::maybe_inject_crates_ref(krate,\n                                                              sess.opts.alt_std_name.clone()));\n \n+    let macros = time(time_passes, \"macro loading\", (), |_|\n+        metadata::macro_import::read_macro_defs(sess, &krate));\n+\n     let mut addl_plugins = Some(addl_plugins);\n-    let Plugins { macros, registrars }\n-        = time(time_passes, \"plugin loading\", (), |_|\n-               plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n+    let registrars = time(time_passes, \"plugin loading\", (), |_|\n+        plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n \n     let mut registry = Registry::new(sess, &krate);\n "}]}