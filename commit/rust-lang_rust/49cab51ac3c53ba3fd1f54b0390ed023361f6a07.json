{"sha": "49cab51ac3c53ba3fd1f54b0390ed023361f6a07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5Y2FiNTFhYzNjNTNiYTNmZDFmNTRiMDM5MGVkMDIzMzYxZjZhMDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-16T07:52:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-16T07:52:12Z"}, "message": "Auto merge of #987 - christianpoveda:check-unsupported-fs-flags, r=RalfJung\n\nError when there is an unsupported flag for opening a file\n\n@RalfJung this is my attempt to check for undesired flags. I also changed fcntl to error when doing any other action besides getting the flags for a fd", "tree": {"sha": "b269453c665652c7b5dcc6ae961010a473fb83ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b269453c665652c7b5dcc6ae961010a473fb83ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49cab51ac3c53ba3fd1f54b0390ed023361f6a07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49cab51ac3c53ba3fd1f54b0390ed023361f6a07", "html_url": "https://github.com/rust-lang/rust/commit/49cab51ac3c53ba3fd1f54b0390ed023361f6a07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49cab51ac3c53ba3fd1f54b0390ed023361f6a07/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d01c306fe032de4f2c4722ae235caa021ad37db", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d01c306fe032de4f2c4722ae235caa021ad37db", "html_url": "https://github.com/rust-lang/rust/commit/0d01c306fe032de4f2c4722ae235caa021ad37db"}, {"sha": "24872230dc25f40b5683549bdb1e288964744e77", "url": "https://api.github.com/repos/rust-lang/rust/commits/24872230dc25f40b5683549bdb1e288964744e77", "html_url": "https://github.com/rust-lang/rust/commit/24872230dc25f40b5683549bdb1e288964744e77"}], "stats": {"total": 78, "additions": 47, "deletions": 31}, "files": [{"sha": "c3dc5e60f0b4b4e3f7deec6b632090351b8bbfd9", "filename": "src/shims/fs.rs", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/49cab51ac3c53ba3fd1f54b0390ed023361f6a07/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49cab51ac3c53ba3fd1f54b0390ed023361f6a07/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=49cab51ac3c53ba3fd1f54b0390ed023361f6a07", "patch": "@@ -9,7 +9,6 @@ use crate::*;\n \n pub struct FileHandle {\n     file: File,\n-    flag: i32,\n }\n \n pub struct FileHandler {\n@@ -44,27 +43,57 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let mut options = OpenOptions::new();\n \n-        // The first two bits of the flag correspond to the access mode of the file in linux.\n+        let o_rdonly = this.eval_libc_i32(\"O_RDONLY\")?;\n+        let o_wronly = this.eval_libc_i32(\"O_WRONLY\")?;\n+        let o_rdwr = this.eval_libc_i32(\"O_RDWR\")?;\n+        // The first two bits of the flag correspond to the access mode in linux, macOS and\n+        // windows. We need to check that in fact the access mode flags for the current platform\n+        // only use these two bits, otherwise we are in an unsupported platform and should error.\n+        if (o_rdonly | o_wronly | o_rdwr) & !0b11 != 0 {\n+            throw_unsup_format!(\"Access mode flags on this platform are unsupported\");\n+        }\n+        // Now we check the access mode\n         let access_mode = flag & 0b11;\n \n-        if access_mode == this.eval_libc_i32(\"O_RDONLY\")? {\n+        if access_mode == o_rdonly {\n             options.read(true);\n-        } else if access_mode == this.eval_libc_i32(\"O_WRONLY\")? {\n+        } else if access_mode == o_wronly {\n             options.write(true);\n-        } else if access_mode == this.eval_libc_i32(\"O_RDWR\")? {\n+        } else if access_mode == o_rdwr {\n             options.read(true).write(true);\n         } else {\n             throw_unsup_format!(\"Unsupported access mode {:#x}\", access_mode);\n         }\n+        // We need to check that there aren't unsupported options in `flag`. For this we try to\n+        // reproduce the content of `flag` in the `mirror` variable using only the supported\n+        // options.\n+        let mut mirror = access_mode;\n \n-        if flag & this.eval_libc_i32(\"O_APPEND\")? != 0 {\n+        let o_append = this.eval_libc_i32(\"O_APPEND\")?;\n+        if flag & o_append != 0 {\n             options.append(true);\n+            mirror |= o_append;\n         }\n-        if flag & this.eval_libc_i32(\"O_TRUNC\")? != 0 {\n+        let o_trunc = this.eval_libc_i32(\"O_TRUNC\")?;\n+        if flag & o_trunc != 0 {\n             options.truncate(true);\n+            mirror |= o_trunc;\n         }\n-        if flag & this.eval_libc_i32(\"O_CREAT\")? != 0 {\n+        let o_creat = this.eval_libc_i32(\"O_CREAT\")?;\n+        if flag & o_creat != 0 {\n             options.create(true);\n+            mirror |= o_creat;\n+        }\n+        let o_cloexec = this.eval_libc_i32(\"O_CLOEXEC\")?;\n+        if flag & o_cloexec != 0 {\n+            // We do not need to do anything for this flag because `std` already sets it.\n+            // (Technically we do not support *not* setting this flag, but we ignore that.)\n+            mirror |= o_cloexec;\n+        }\n+        // If `flag` is not equal to `mirror`, there is an unsupported option enabled in `flag`,\n+        // then we throw an error.\n+        if flag != mirror {\n+            throw_unsup_format!(\"unsupported flags {:#x}\", flag & !mirror);\n         }\n \n         let path_bytes = this\n@@ -76,7 +105,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let fd = options.open(path).map(|file| {\n             let mut fh = &mut this.machine.file_handler;\n             fh.low += 1;\n-            fh.handles.insert(fh.low, FileHandle { file, flag });\n+            fh.handles.insert(fh.low, FileHandle { file });\n             fh.low\n         });\n \n@@ -87,7 +116,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         fd_op: OpTy<'tcx, Tag>,\n         cmd_op: OpTy<'tcx, Tag>,\n-        arg_op: Option<OpTy<'tcx, Tag>>,\n+        _arg1_op: Option<OpTy<'tcx, Tag>>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -97,29 +126,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         let cmd = this.read_scalar(cmd_op)?.to_i32()?;\n-\n-        if cmd == this.eval_libc_i32(\"F_SETFD\")? {\n-            // This does not affect the file itself. Certain flags might require changing the file\n-            // or the way it is accessed somehow.\n-            let flag = this.read_scalar(arg_op.unwrap())?.to_i32()?;\n-            // The only usage of this in stdlib at the moment is to enable the `FD_CLOEXEC` flag.\n+        // We only support getting the flags for a descriptor\n+        if cmd == this.eval_libc_i32(\"F_GETFD\")? {\n+            // Currently this is the only flag that `F_GETFD` returns. It is OK to just return the\n+            // `FD_CLOEXEC` value without checking if the flag is set for the file because `std`\n+            // always sets this flag when opening a file. However we still need to check that the\n+            // file itself is open.\n             let fd_cloexec = this.eval_libc_i32(\"FD_CLOEXEC\")?;\n-            if let Some(FileHandle { flag: old_flag, .. }) =\n-                this.machine.file_handler.handles.get_mut(&fd)\n-            {\n-                // Check that the only difference between the old flag and the current flag is\n-                // exactly the `FD_CLOEXEC` value.\n-                if flag ^ *old_flag == fd_cloexec {\n-                    *old_flag = flag;\n-                } else {\n-                    throw_unsup_format!(\"Unsupported arg {:#x} for `F_SETFD`\", flag);\n-                }\n-            }\n-            Ok(0)\n-        } else if cmd == this.eval_libc_i32(\"F_GETFD\")? {\n-            this.get_handle_and(fd, |handle| Ok(handle.flag))\n+            this.get_handle_and(fd, |_| Ok(fd_cloexec))\n         } else {\n-            throw_unsup_format!(\"Unsupported command {:#x}\", cmd);\n+            throw_unsup_format!(\"The {:#x} command is not supported for `fcntl`)\", cmd);\n         }\n     }\n "}]}