{"sha": "622613f957e07ffe1398fa17bc84f185e62df27f", "node_id": "C_kwDOAAsO6NoAKDYyMjYxM2Y5NTdlMDdmZmUxMzk4ZmExN2JjODRmMTg1ZTYyZGYyN2Y", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-23T17:59:08Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-27T03:34:20Z"}, "message": "Use real exec on cfg(unix) targets\n\nWhen cargo-miri is executed as a cargo test runner or rustdoc runtool,\nexternal tools expect what they launch as the runner/runtool to be the\nprocess actually running the test. But in the implementation, we launch\nthe Miri interpreter as a subprocess using std::process::Command. This\ntends to confuse other tools (like nextest) and users (like the author).\nWhat we really want is to call POSIX exec so that the cargo-miri process\nbecomes the interpreter.\n\nSo this implements just that; we call execve via a cfg(unix) extension\ntrait. Windows has no such mechanism, but it also doesn't have POSIX\nsignals, which is the primary tripping hazard this change fixes.", "tree": {"sha": "a942acaa85c968e1d7223b57999882f050a33b23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a942acaa85c968e1d7223b57999882f050a33b23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/622613f957e07ffe1398fa17bc84f185e62df27f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/622613f957e07ffe1398fa17bc84f185e62df27f", "html_url": "https://github.com/rust-lang/rust/commit/622613f957e07ffe1398fa17bc84f185e62df27f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/622613f957e07ffe1398fa17bc84f185e62df27f/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbff63a6944b3285a9525881dc85870e694fb055", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbff63a6944b3285a9525881dc85870e694fb055", "html_url": "https://github.com/rust-lang/rust/commit/cbff63a6944b3285a9525881dc85870e694fb055"}], "stats": {"total": 84, "additions": 61, "deletions": 23}, "files": [{"sha": "ce7328e2e6c56dd5095786630a337114d1ec478c", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/622613f957e07ffe1398fa17bc84f185e62df27f/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622613f957e07ffe1398fa17bc84f185e62df27f/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=622613f957e07ffe1398fa17bc84f185e62df27f", "patch": "@@ -51,7 +51,7 @@ enum MiriCommand {\n }\n \n /// The information to run a crate with the given environment.\n-#[derive(Serialize, Deserialize)]\n+#[derive(Clone, Serialize, Deserialize)]\n struct CrateRunEnv {\n     /// The command-line arguments.\n     args: Vec<String>,\n@@ -249,27 +249,56 @@ fn xargo_check() -> Command {\n     Command::new(env::var_os(\"XARGO_CHECK\").unwrap_or_else(|| OsString::from(\"xargo-check\")))\n }\n \n-/// Execute the command. If it fails, fail this process with the same exit code.\n-/// Otherwise, continue.\n-fn exec(mut cmd: Command) {\n-    let exit_status = cmd.status().expect(\"failed to run command\");\n-    if exit_status.success().not() {\n+/// Execute the `Command`, where possible by replacing the current process with a new process\n+/// described by the `Command`. Then exit this process with the exit code of the new process.\n+fn exec(mut cmd: Command) -> ! {\n+    // On non-Unix imitate POSIX exec as closely as we can\n+    #[cfg(not(unix))]\n+    {\n+        let exit_status = cmd.status().expect(\"failed to run command\");\n         std::process::exit(exit_status.code().unwrap_or(-1))\n     }\n+    // On Unix targets, actually exec.\n+    // If exec returns, process setup has failed. This is the same error condition as the expect in\n+    // the non-Unix case.\n+    #[cfg(unix)]\n+    {\n+        use std::os::unix::process::CommandExt;\n+        let error = cmd.exec();\n+        Err(error).expect(\"failed to run command\")\n+    }\n }\n \n-/// Execute the command and pipe `input` into its stdin.\n-/// If it fails, fail this process with the same exit code.\n-/// Otherwise, continue.\n-fn exec_with_pipe(mut cmd: Command, input: &[u8]) {\n-    cmd.stdin(process::Stdio::piped());\n-    let mut child = cmd.spawn().expect(\"failed to spawn process\");\n+/// Execute the `Command`, where possible by replacing the current process with a new process\n+/// described by the `Command`. Then exit this process with the exit code of the new process.\n+/// `input` is also piped to the new process's stdin, on cfg(unix) platforms by writing its\n+/// contents to `path` first, then setting stdin to that file.\n+fn exec_with_pipe<P>(mut cmd: Command, input: &[u8], path: P) -> !\n+where\n+    P: AsRef<Path>,\n+{\n+    #[cfg(unix)]\n     {\n-        let stdin = child.stdin.as_mut().expect(\"failed to open stdin\");\n-        stdin.write_all(input).expect(\"failed to write out test source\");\n+        // Write the bytes we want to send to stdin out to a file\n+        std::fs::write(&path, input).unwrap();\n+        // Open the file for reading, and set our new stdin to it\n+        let stdin = File::open(&path).unwrap();\n+        cmd.stdin(stdin);\n+        // Unlink the file so that it is fully cleaned up as soon as the new process exits\n+        std::fs::remove_file(&path).unwrap();\n+        // Finally, we can hand off control.\n+        exec(cmd)\n     }\n-    let exit_status = child.wait().expect(\"failed to run command\");\n-    if exit_status.success().not() {\n+    #[cfg(not(unix))]\n+    {\n+        drop(path); // We don't need the path, we can pipe the bytes directly\n+        cmd.stdin(process::Stdio::piped());\n+        let mut child = cmd.spawn().expect(\"failed to spawn process\");\n+        {\n+            let stdin = child.stdin.as_mut().expect(\"failed to open stdin\");\n+            stdin.write_all(input).expect(\"failed to write out test source\");\n+        }\n+        let exit_status = child.wait().expect(\"failed to run command\");\n         std::process::exit(exit_status.code().unwrap_or(-1))\n     }\n }\n@@ -872,6 +901,8 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n         // and environment variables; this is used when cargo calls us again in the CARGO_TARGET_RUNNER phase.\n         let env = CrateRunEnv::collect(args, inside_rustdoc);\n \n+        store_json(CrateRunInfo::RunWith(env.clone()));\n+\n         // Rustdoc expects us to exit with an error code if the test is marked as `compile_fail`,\n         // just creating the JSON file is not enough: we need to detect syntax errors,\n         // so we need to run Miri with `MIRI_BE_RUSTC` for a check-only build.\n@@ -888,7 +919,15 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n                 cmd.arg(\"--emit=metadata\");\n             }\n \n-            cmd.args(&env.args);\n+            // Alter the `-o` parameter so that it does not overwrite the JSON file we stored above.\n+            let mut args = env.args.clone();\n+            for i in 0..args.len() {\n+                if args[i] == \"-o\" {\n+                    args[i + 1].push_str(\".miri\");\n+                }\n+            }\n+\n+            cmd.args(&args);\n             cmd.env(\"MIRI_BE_RUSTC\", \"target\");\n \n             if verbose > 0 {\n@@ -899,11 +938,9 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n                 eprintln!(\"[cargo-miri rustc inside rustdoc] going to run:\\n{:?}\", cmd);\n             }\n \n-            exec_with_pipe(cmd, &env.stdin);\n+            exec_with_pipe(cmd, &env.stdin, format!(\"{}.stdin\", out_filename(\"\", \"\").display()));\n         }\n \n-        store_json(CrateRunInfo::RunWith(env));\n-\n         return;\n     }\n \n@@ -983,8 +1020,6 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n             \"[cargo-miri rustc] target_crate={target_crate} runnable_crate={runnable_crate} print={print}\"\n         );\n     }\n-    debug_cmd(\"[cargo-miri rustc]\", verbose, &cmd);\n-    exec(cmd);\n \n     // Create a stub .rlib file if \"link\" was requested by cargo.\n     // This is necessary to prevent cargo from doing rebuilds all the time.\n@@ -999,6 +1034,9 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n         File::create(out_filename(\"\", \".dll\")).expect(\"failed to create fake .dll file\");\n         File::create(out_filename(\"\", \".lib\")).expect(\"failed to create fake .lib file\");\n     }\n+\n+    debug_cmd(\"[cargo-miri rustc]\", verbose, &cmd);\n+    exec(cmd);\n }\n \n #[derive(Debug, Copy, Clone, PartialEq)]\n@@ -1100,7 +1138,7 @@ fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: RunnerPhas\n     // Run it.\n     debug_cmd(\"[cargo-miri runner]\", verbose, &cmd);\n     match phase {\n-        RunnerPhase::Rustdoc => exec_with_pipe(cmd, &info.stdin),\n+        RunnerPhase::Rustdoc => exec_with_pipe(cmd, &info.stdin, format!(\"{}.stdin\", binary)),\n         RunnerPhase::Cargo => exec(cmd),\n     }\n }"}]}