{"sha": "6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NTNmY2Q0Y2NhYTg0Y2Y4YTIxYjU5OTFiYWUyM2E1OTIzZGY5OGI=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-11T04:58:16Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-17T02:57:42Z"}, "message": "extract libcollections tests into libcollectionstest", "tree": {"sha": "65fadd39302af66a1fff6508e9a20b822927624a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65fadd39302af66a1fff6508e9a20b822927624a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "html_url": "https://github.com/rust-lang/rust/commit/6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/comments", "author": null, "committer": null, "parents": [{"sha": "3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "html_url": "https://github.com/rust-lang/rust/commit/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a"}], "stats": {"total": 18290, "additions": 9192, "deletions": 9098}, "files": [{"sha": "57adaee51980be5c8bf14e35c06ac61fa6bfbf45", "filename": "mk/dist.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -53,6 +53,7 @@ PKG_FILES := \\\n       driver                                   \\\n       etc                                      \\\n       $(foreach crate,$(CRATES),lib$(crate))   \\\n+      libcollectionstest                       \\\n       libcoretest                              \\\n       libbacktrace                             \\\n       rt                                       \\"}, {"sha": "0851909a776e797d2e54b47ca6d0496cfd33d7df", "filename": "mk/tests.mk", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -19,7 +19,11 @@\n DEPS_coretest :=\n $(eval $(call RUST_CRATE,coretest))\n \n-TEST_TARGET_CRATES = $(filter-out core unicode,$(TARGET_CRATES)) coretest\n+DEPS_collectionstest :=\n+$(eval $(call RUST_CRATE,collectionstest))\n+\n+TEST_TARGET_CRATES = $(filter-out collections core unicode,$(TARGET_CRATES)) \\\n+\t\t\t\t\t\t\t\t\t\t collectionstest coretest\n TEST_DOC_CRATES = $(DOC_CRATES)\n TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_resolve rustc_trans rustc_lint,\\\n                      $(HOST_CRATES))"}, {"sha": "11c8656c994b29da5771ed3bf58e3f445aa82314", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -693,218 +693,3 @@ impl<T: Ord> Extend<T> for BinaryHeap<T> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-\n-    use super::BinaryHeap;\n-\n-    #[test]\n-    fn test_iterator() {\n-        let data = vec![5, 9, 3];\n-        let iterout = [9, 5, 3];\n-        let heap = BinaryHeap::from_vec(data);\n-        let mut i = 0;\n-        for el in &heap {\n-            assert_eq!(*el, iterout[i]);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_iterator_reverse() {\n-        let data = vec![5, 9, 3];\n-        let iterout = vec![3, 5, 9];\n-        let pq = BinaryHeap::from_vec(data);\n-\n-        let v: Vec<_> = pq.iter().rev().cloned().collect();\n-        assert_eq!(v, iterout);\n-    }\n-\n-    #[test]\n-    fn test_move_iter() {\n-        let data = vec![5, 9, 3];\n-        let iterout = vec![9, 5, 3];\n-        let pq = BinaryHeap::from_vec(data);\n-\n-        let v: Vec<_> = pq.into_iter().collect();\n-        assert_eq!(v, iterout);\n-    }\n-\n-    #[test]\n-    fn test_move_iter_size_hint() {\n-        let data = vec![5, 9];\n-        let pq = BinaryHeap::from_vec(data);\n-\n-        let mut it = pq.into_iter();\n-\n-        assert_eq!(it.size_hint(), (2, Some(2)));\n-        assert_eq!(it.next(), Some(9));\n-\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert_eq!(it.next(), Some(5));\n-\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_move_iter_reverse() {\n-        let data = vec![5, 9, 3];\n-        let iterout = vec![3, 5, 9];\n-        let pq = BinaryHeap::from_vec(data);\n-\n-        let v: Vec<_> = pq.into_iter().rev().collect();\n-        assert_eq!(v, iterout);\n-    }\n-\n-    #[test]\n-    fn test_peek_and_pop() {\n-        let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n-        let mut sorted = data.clone();\n-        sorted.sort();\n-        let mut heap = BinaryHeap::from_vec(data);\n-        while !heap.is_empty() {\n-            assert_eq!(heap.peek().unwrap(), sorted.last().unwrap());\n-            assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_push() {\n-        let mut heap = BinaryHeap::from_vec(vec![2, 4, 9]);\n-        assert_eq!(heap.len(), 3);\n-        assert!(*heap.peek().unwrap() == 9);\n-        heap.push(11);\n-        assert_eq!(heap.len(), 4);\n-        assert!(*heap.peek().unwrap() == 11);\n-        heap.push(5);\n-        assert_eq!(heap.len(), 5);\n-        assert!(*heap.peek().unwrap() == 11);\n-        heap.push(27);\n-        assert_eq!(heap.len(), 6);\n-        assert!(*heap.peek().unwrap() == 27);\n-        heap.push(3);\n-        assert_eq!(heap.len(), 7);\n-        assert!(*heap.peek().unwrap() == 27);\n-        heap.push(103);\n-        assert_eq!(heap.len(), 8);\n-        assert!(*heap.peek().unwrap() == 103);\n-    }\n-\n-    #[test]\n-    fn test_push_unique() {\n-        let mut heap = BinaryHeap::<Box<_>>::from_vec(vec![box 2, box 4, box 9]);\n-        assert_eq!(heap.len(), 3);\n-        assert!(*heap.peek().unwrap() == box 9);\n-        heap.push(box 11);\n-        assert_eq!(heap.len(), 4);\n-        assert!(*heap.peek().unwrap() == box 11);\n-        heap.push(box 5);\n-        assert_eq!(heap.len(), 5);\n-        assert!(*heap.peek().unwrap() == box 11);\n-        heap.push(box 27);\n-        assert_eq!(heap.len(), 6);\n-        assert!(*heap.peek().unwrap() == box 27);\n-        heap.push(box 3);\n-        assert_eq!(heap.len(), 7);\n-        assert!(*heap.peek().unwrap() == box 27);\n-        heap.push(box 103);\n-        assert_eq!(heap.len(), 8);\n-        assert!(*heap.peek().unwrap() == box 103);\n-    }\n-\n-    #[test]\n-    fn test_push_pop() {\n-        let mut heap = BinaryHeap::from_vec(vec![5, 5, 2, 1, 3]);\n-        assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.push_pop(6), 6);\n-        assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.push_pop(0), 5);\n-        assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.push_pop(4), 5);\n-        assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.push_pop(1), 4);\n-        assert_eq!(heap.len(), 5);\n-    }\n-\n-    #[test]\n-    fn test_replace() {\n-        let mut heap = BinaryHeap::from_vec(vec![5, 5, 2, 1, 3]);\n-        assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(6).unwrap(), 5);\n-        assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(0).unwrap(), 6);\n-        assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(4).unwrap(), 5);\n-        assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(1).unwrap(), 4);\n-        assert_eq!(heap.len(), 5);\n-    }\n-\n-    fn check_to_vec(mut data: Vec<i32>) {\n-        let heap = BinaryHeap::from_vec(data.clone());\n-        let mut v = heap.clone().into_vec();\n-        v.sort();\n-        data.sort();\n-\n-        assert_eq!(v, data);\n-        assert_eq!(heap.into_sorted_vec(), data);\n-    }\n-\n-    #[test]\n-    fn test_to_vec() {\n-        check_to_vec(vec![]);\n-        check_to_vec(vec![5]);\n-        check_to_vec(vec![3, 2]);\n-        check_to_vec(vec![2, 3]);\n-        check_to_vec(vec![5, 1, 2]);\n-        check_to_vec(vec![1, 100, 2, 3]);\n-        check_to_vec(vec![1, 3, 5, 7, 9, 2, 4, 6, 8, 0]);\n-        check_to_vec(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n-        check_to_vec(vec![9, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0]);\n-        check_to_vec(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n-        check_to_vec(vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]);\n-        check_to_vec(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2]);\n-        check_to_vec(vec![5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_empty_pop() {\n-        let mut heap = BinaryHeap::<i32>::new();\n-        assert!(heap.pop().is_none());\n-    }\n-\n-    #[test]\n-    fn test_empty_peek() {\n-        let empty = BinaryHeap::<i32>::new();\n-        assert!(empty.peek().is_none());\n-    }\n-\n-    #[test]\n-    fn test_empty_replace() {\n-        let mut heap = BinaryHeap::new();\n-        assert!(heap.replace(5).is_none());\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n-\n-        let mut q: BinaryHeap<_> = xs.iter().rev().cloned().collect();\n-\n-        for &x in &xs {\n-            assert_eq!(q.pop().unwrap(), x);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_drain() {\n-        let mut q: BinaryHeap<_> = [9, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n-\n-        assert_eq!(q.drain().take(5).count(), 5);\n-\n-        assert!(q.is_empty());\n-    }\n-}"}, {"sha": "1dd463e0405ff57db41fcf9c3a64538522b469ca", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 0, "deletions": 1180, "changes": 1180, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -1903,1183 +1903,3 @@ impl<'a> IntoIterator for &'a BitSet {\n         self.iter()\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use core::u32;\n-\n-    use super::BitVec;\n-\n-    #[test]\n-    fn test_to_str() {\n-        let zerolen = BitVec::new();\n-        assert_eq!(format!(\"{:?}\", zerolen), \"\");\n-\n-        let eightbits = BitVec::from_elem(8, false);\n-        assert_eq!(format!(\"{:?}\", eightbits), \"00000000\")\n-    }\n-\n-    #[test]\n-    fn test_0_elements() {\n-        let act = BitVec::new();\n-        let exp = Vec::new();\n-        assert!(act.eq_vec(&exp));\n-        assert!(act.none() && act.all());\n-    }\n-\n-    #[test]\n-    fn test_1_element() {\n-        let mut act = BitVec::from_elem(1, false);\n-        assert!(act.eq_vec(&[false]));\n-        assert!(act.none() && !act.all());\n-        act = BitVec::from_elem(1, true);\n-        assert!(act.eq_vec(&[true]));\n-        assert!(!act.none() && act.all());\n-    }\n-\n-    #[test]\n-    fn test_2_elements() {\n-        let mut b = BitVec::from_elem(2, false);\n-        b.set(0, true);\n-        b.set(1, false);\n-        assert_eq!(format!(\"{:?}\", b), \"10\");\n-        assert!(!b.none() && !b.all());\n-    }\n-\n-    #[test]\n-    fn test_10_elements() {\n-        let mut act;\n-        // all 0\n-\n-        act = BitVec::from_elem(10, false);\n-        assert!((act.eq_vec(\n-                    &[false, false, false, false, false, false, false, false, false, false])));\n-        assert!(act.none() && !act.all());\n-        // all 1\n-\n-        act = BitVec::from_elem(10, true);\n-        assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n-        assert!(!act.none() && act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(10, false);\n-        act.set(0, true);\n-        act.set(1, true);\n-        act.set(2, true);\n-        act.set(3, true);\n-        act.set(4, true);\n-        assert!((act.eq_vec(&[true, true, true, true, true, false, false, false, false, false])));\n-        assert!(!act.none() && !act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(10, false);\n-        act.set(5, true);\n-        act.set(6, true);\n-        act.set(7, true);\n-        act.set(8, true);\n-        act.set(9, true);\n-        assert!((act.eq_vec(&[false, false, false, false, false, true, true, true, true, true])));\n-        assert!(!act.none() && !act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(10, false);\n-        act.set(0, true);\n-        act.set(3, true);\n-        act.set(6, true);\n-        act.set(9, true);\n-        assert!((act.eq_vec(&[true, false, false, true, false, false, true, false, false, true])));\n-        assert!(!act.none() && !act.all());\n-    }\n-\n-    #[test]\n-    fn test_31_elements() {\n-        let mut act;\n-        // all 0\n-\n-        act = BitVec::from_elem(31, false);\n-        assert!(act.eq_vec(\n-                &[false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false]));\n-        assert!(act.none() && !act.all());\n-        // all 1\n-\n-        act = BitVec::from_elem(31, true);\n-        assert!(act.eq_vec(\n-                &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                  true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                  true, true, true, true, true]));\n-        assert!(!act.none() && act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(31, false);\n-        act.set(0, true);\n-        act.set(1, true);\n-        act.set(2, true);\n-        act.set(3, true);\n-        act.set(4, true);\n-        act.set(5, true);\n-        act.set(6, true);\n-        act.set(7, true);\n-        assert!(act.eq_vec(\n-                &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false]));\n-        assert!(!act.none() && !act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(31, false);\n-        act.set(16, true);\n-        act.set(17, true);\n-        act.set(18, true);\n-        act.set(19, true);\n-        act.set(20, true);\n-        act.set(21, true);\n-        act.set(22, true);\n-        act.set(23, true);\n-        assert!(act.eq_vec(\n-                &[false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, true, true, true, true, true, true, true, true,\n-                  false, false, false, false, false, false, false]));\n-        assert!(!act.none() && !act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(31, false);\n-        act.set(24, true);\n-        act.set(25, true);\n-        act.set(26, true);\n-        act.set(27, true);\n-        act.set(28, true);\n-        act.set(29, true);\n-        act.set(30, true);\n-        assert!(act.eq_vec(\n-                &[false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, true, true, true, true, true, true, true]));\n-        assert!(!act.none() && !act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(31, false);\n-        act.set(3, true);\n-        act.set(17, true);\n-        act.set(30, true);\n-        assert!(act.eq_vec(\n-                &[false, false, false, true, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, true, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, true]));\n-        assert!(!act.none() && !act.all());\n-    }\n-\n-    #[test]\n-    fn test_32_elements() {\n-        let mut act;\n-        // all 0\n-\n-        act = BitVec::from_elem(32, false);\n-        assert!(act.eq_vec(\n-                &[false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false, false]));\n-        assert!(act.none() && !act.all());\n-        // all 1\n-\n-        act = BitVec::from_elem(32, true);\n-        assert!(act.eq_vec(\n-                &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                  true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                  true, true, true, true, true, true]));\n-        assert!(!act.none() && act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(32, false);\n-        act.set(0, true);\n-        act.set(1, true);\n-        act.set(2, true);\n-        act.set(3, true);\n-        act.set(4, true);\n-        act.set(5, true);\n-        act.set(6, true);\n-        act.set(7, true);\n-        assert!(act.eq_vec(\n-                &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false]));\n-        assert!(!act.none() && !act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(32, false);\n-        act.set(16, true);\n-        act.set(17, true);\n-        act.set(18, true);\n-        act.set(19, true);\n-        act.set(20, true);\n-        act.set(21, true);\n-        act.set(22, true);\n-        act.set(23, true);\n-        assert!(act.eq_vec(\n-                &[false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, true, true, true, true, true, true, true, true,\n-                  false, false, false, false, false, false, false, false]));\n-        assert!(!act.none() && !act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(32, false);\n-        act.set(24, true);\n-        act.set(25, true);\n-        act.set(26, true);\n-        act.set(27, true);\n-        act.set(28, true);\n-        act.set(29, true);\n-        act.set(30, true);\n-        act.set(31, true);\n-        assert!(act.eq_vec(\n-                &[false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, true, true, true, true, true, true, true, true]));\n-        assert!(!act.none() && !act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(32, false);\n-        act.set(3, true);\n-        act.set(17, true);\n-        act.set(30, true);\n-        act.set(31, true);\n-        assert!(act.eq_vec(\n-                &[false, false, false, true, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, true, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, true, true]));\n-        assert!(!act.none() && !act.all());\n-    }\n-\n-    #[test]\n-    fn test_33_elements() {\n-        let mut act;\n-        // all 0\n-\n-        act = BitVec::from_elem(33, false);\n-        assert!(act.eq_vec(\n-                &[false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false, false, false]));\n-        assert!(act.none() && !act.all());\n-        // all 1\n-\n-        act = BitVec::from_elem(33, true);\n-        assert!(act.eq_vec(\n-                &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                  true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                  true, true, true, true, true, true, true]));\n-        assert!(!act.none() && act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(33, false);\n-        act.set(0, true);\n-        act.set(1, true);\n-        act.set(2, true);\n-        act.set(3, true);\n-        act.set(4, true);\n-        act.set(5, true);\n-        act.set(6, true);\n-        act.set(7, true);\n-        assert!(act.eq_vec(\n-                &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false]));\n-        assert!(!act.none() && !act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(33, false);\n-        act.set(16, true);\n-        act.set(17, true);\n-        act.set(18, true);\n-        act.set(19, true);\n-        act.set(20, true);\n-        act.set(21, true);\n-        act.set(22, true);\n-        act.set(23, true);\n-        assert!(act.eq_vec(\n-                &[false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, true, true, true, true, true, true, true, true,\n-                  false, false, false, false, false, false, false, false, false]));\n-        assert!(!act.none() && !act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(33, false);\n-        act.set(24, true);\n-        act.set(25, true);\n-        act.set(26, true);\n-        act.set(27, true);\n-        act.set(28, true);\n-        act.set(29, true);\n-        act.set(30, true);\n-        act.set(31, true);\n-        assert!(act.eq_vec(\n-                &[false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, false, false, false, false, false,\n-                  false, false, true, true, true, true, true, true, true, true, false]));\n-        assert!(!act.none() && !act.all());\n-        // mixed\n-\n-        act = BitVec::from_elem(33, false);\n-        act.set(3, true);\n-        act.set(17, true);\n-        act.set(30, true);\n-        act.set(31, true);\n-        act.set(32, true);\n-        assert!(act.eq_vec(\n-                &[false, false, false, true, false, false, false, false, false, false, false, false,\n-                  false, false, false, false, false, true, false, false, false, false, false, false,\n-                  false, false, false, false, false, false, true, true, true]));\n-        assert!(!act.none() && !act.all());\n-    }\n-\n-    #[test]\n-    fn test_equal_differing_sizes() {\n-        let v0 = BitVec::from_elem(10, false);\n-        let v1 = BitVec::from_elem(11, false);\n-        assert!(v0 != v1);\n-    }\n-\n-    #[test]\n-    fn test_equal_greatly_differing_sizes() {\n-        let v0 = BitVec::from_elem(10, false);\n-        let v1 = BitVec::from_elem(110, false);\n-        assert!(v0 != v1);\n-    }\n-\n-    #[test]\n-    fn test_equal_sneaky_small() {\n-        let mut a = BitVec::from_elem(1, false);\n-        a.set(0, true);\n-\n-        let mut b = BitVec::from_elem(1, true);\n-        b.set(0, true);\n-\n-        assert_eq!(a, b);\n-    }\n-\n-    #[test]\n-    fn test_equal_sneaky_big() {\n-        let mut a = BitVec::from_elem(100, false);\n-        for i in 0..100 {\n-            a.set(i, true);\n-        }\n-\n-        let mut b = BitVec::from_elem(100, true);\n-        for i in 0..100 {\n-            b.set(i, true);\n-        }\n-\n-        assert_eq!(a, b);\n-    }\n-\n-    #[test]\n-    fn test_from_bytes() {\n-        let bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n-        let str = concat!(\"10110110\", \"00000000\", \"11111111\");\n-        assert_eq!(format!(\"{:?}\", bit_vec), str);\n-    }\n-\n-    #[test]\n-    fn test_to_bytes() {\n-        let mut bv = BitVec::from_elem(3, true);\n-        bv.set(1, false);\n-        assert_eq!(bv.to_bytes(), [0b10100000]);\n-\n-        let mut bv = BitVec::from_elem(9, false);\n-        bv.set(2, true);\n-        bv.set(8, true);\n-        assert_eq!(bv.to_bytes(), [0b00100000, 0b10000000]);\n-    }\n-\n-    #[test]\n-    fn test_from_bools() {\n-        let bools = vec![true, false, true, true];\n-        let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n-        assert_eq!(format!(\"{:?}\", bit_vec), \"1011\");\n-    }\n-\n-    #[test]\n-    fn test_to_bools() {\n-        let bools = vec![false, false, true, false, false, true, true, false];\n-        assert_eq!(BitVec::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n-    }\n-\n-    #[test]\n-    fn test_bit_vec_iterator() {\n-        let bools = vec![true, false, true, true];\n-        let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n-\n-        assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), bools);\n-\n-        let long: Vec<_> = (0..10000).map(|i| i % 2 == 0).collect();\n-        let bit_vec: BitVec = long.iter().map(|n| *n).collect();\n-        assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), long)\n-    }\n-\n-    #[test]\n-    fn test_small_difference() {\n-        let mut b1 = BitVec::from_elem(3, false);\n-        let mut b2 = BitVec::from_elem(3, false);\n-        b1.set(0, true);\n-        b1.set(1, true);\n-        b2.set(1, true);\n-        b2.set(2, true);\n-        assert!(b1.difference(&b2));\n-        assert!(b1[0]);\n-        assert!(!b1[1]);\n-        assert!(!b1[2]);\n-    }\n-\n-    #[test]\n-    fn test_big_difference() {\n-        let mut b1 = BitVec::from_elem(100, false);\n-        let mut b2 = BitVec::from_elem(100, false);\n-        b1.set(0, true);\n-        b1.set(40, true);\n-        b2.set(40, true);\n-        b2.set(80, true);\n-        assert!(b1.difference(&b2));\n-        assert!(b1[0]);\n-        assert!(!b1[40]);\n-        assert!(!b1[80]);\n-    }\n-\n-    #[test]\n-    fn test_small_clear() {\n-        let mut b = BitVec::from_elem(14, true);\n-        assert!(!b.none() && b.all());\n-        b.clear();\n-        assert!(b.none() && !b.all());\n-    }\n-\n-    #[test]\n-    fn test_big_clear() {\n-        let mut b = BitVec::from_elem(140, true);\n-        assert!(!b.none() && b.all());\n-        b.clear();\n-        assert!(b.none() && !b.all());\n-    }\n-\n-    #[test]\n-    fn test_bit_vec_lt() {\n-        let mut a = BitVec::from_elem(5, false);\n-        let mut b = BitVec::from_elem(5, false);\n-\n-        assert!(!(a < b) && !(b < a));\n-        b.set(2, true);\n-        assert!(a < b);\n-        a.set(3, true);\n-        assert!(a < b);\n-        a.set(2, true);\n-        assert!(!(a < b) && b < a);\n-        b.set(0, true);\n-        assert!(a < b);\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = BitVec::from_elem(5, false);\n-        let mut b = BitVec::from_elem(5, false);\n-\n-        assert!(a <= b && a >= b);\n-        a.set(1, true);\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        b.set(1, true);\n-        b.set(2, true);\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n-    }\n-\n-\n-    #[test]\n-    fn test_small_bit_vec_tests() {\n-        let v = BitVec::from_bytes(&[0]);\n-        assert!(!v.all());\n-        assert!(!v.any());\n-        assert!(v.none());\n-\n-        let v = BitVec::from_bytes(&[0b00010100]);\n-        assert!(!v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n-\n-        let v = BitVec::from_bytes(&[0xFF]);\n-        assert!(v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n-    }\n-\n-    #[test]\n-    fn test_big_bit_vec_tests() {\n-        let v = BitVec::from_bytes(&[ // 88 bits\n-            0, 0, 0, 0,\n-            0, 0, 0, 0,\n-            0, 0, 0]);\n-        assert!(!v.all());\n-        assert!(!v.any());\n-        assert!(v.none());\n-\n-        let v = BitVec::from_bytes(&[ // 88 bits\n-            0, 0, 0b00010100, 0,\n-            0, 0, 0, 0b00110100,\n-            0, 0, 0]);\n-        assert!(!v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n-\n-        let v = BitVec::from_bytes(&[ // 88 bits\n-            0xFF, 0xFF, 0xFF, 0xFF,\n-            0xFF, 0xFF, 0xFF, 0xFF,\n-            0xFF, 0xFF, 0xFF]);\n-        assert!(v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n-    }\n-\n-    #[test]\n-    fn test_bit_vec_push_pop() {\n-        let mut s = BitVec::from_elem(5 * u32::BITS as usize - 2, false);\n-        assert_eq!(s.len(), 5 * u32::BITS as usize - 2);\n-        assert_eq!(s[5 * u32::BITS as usize - 3], false);\n-        s.push(true);\n-        s.push(true);\n-        assert_eq!(s[5 * u32::BITS as usize - 2], true);\n-        assert_eq!(s[5 * u32::BITS as usize - 1], true);\n-        // Here the internal vector will need to be extended\n-        s.push(false);\n-        assert_eq!(s[5 * u32::BITS as usize], false);\n-        s.push(false);\n-        assert_eq!(s[5 * u32::BITS as usize + 1], false);\n-        assert_eq!(s.len(), 5 * u32::BITS as usize + 2);\n-        // Pop it all off\n-        assert_eq!(s.pop(), Some(false));\n-        assert_eq!(s.pop(), Some(false));\n-        assert_eq!(s.pop(), Some(true));\n-        assert_eq!(s.pop(), Some(true));\n-        assert_eq!(s.len(), 5 * u32::BITS as usize - 2);\n-    }\n-\n-    #[test]\n-    fn test_bit_vec_truncate() {\n-        let mut s = BitVec::from_elem(5 * u32::BITS as usize, true);\n-\n-        assert_eq!(s, BitVec::from_elem(5 * u32::BITS as usize, true));\n-        assert_eq!(s.len(), 5 * u32::BITS as usize);\n-        s.truncate(4 * u32::BITS as usize);\n-        assert_eq!(s, BitVec::from_elem(4 * u32::BITS as usize, true));\n-        assert_eq!(s.len(), 4 * u32::BITS as usize);\n-        // Truncating to a size > s.len() should be a noop\n-        s.truncate(5 * u32::BITS as usize);\n-        assert_eq!(s, BitVec::from_elem(4 * u32::BITS as usize, true));\n-        assert_eq!(s.len(), 4 * u32::BITS as usize);\n-        s.truncate(3 * u32::BITS as usize - 10);\n-        assert_eq!(s, BitVec::from_elem(3 * u32::BITS as usize - 10, true));\n-        assert_eq!(s.len(), 3 * u32::BITS as usize - 10);\n-        s.truncate(0);\n-        assert_eq!(s, BitVec::from_elem(0, true));\n-        assert_eq!(s.len(), 0);\n-    }\n-\n-    #[test]\n-    fn test_bit_vec_reserve() {\n-        let mut s = BitVec::from_elem(5 * u32::BITS as usize, true);\n-        // Check capacity\n-        assert!(s.capacity() >= 5 * u32::BITS as usize);\n-        s.reserve(2 * u32::BITS as usize);\n-        assert!(s.capacity() >= 7 * u32::BITS as usize);\n-        s.reserve(7 * u32::BITS as usize);\n-        assert!(s.capacity() >= 12 * u32::BITS as usize);\n-        s.reserve_exact(7 * u32::BITS as usize);\n-        assert!(s.capacity() >= 12 * u32::BITS as usize);\n-        s.reserve(7 * u32::BITS as usize + 1);\n-        assert!(s.capacity() >= 12 * u32::BITS as usize + 1);\n-        // Check that length hasn't changed\n-        assert_eq!(s.len(), 5 * u32::BITS as usize);\n-        s.push(true);\n-        s.push(false);\n-        s.push(true);\n-        assert_eq!(s[5 * u32::BITS as usize - 1], true);\n-        assert_eq!(s[5 * u32::BITS as usize - 0], true);\n-        assert_eq!(s[5 * u32::BITS as usize + 1], false);\n-        assert_eq!(s[5 * u32::BITS as usize + 2], true);\n-    }\n-\n-    #[test]\n-    fn test_bit_vec_grow() {\n-        let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n-        bit_vec.grow(32, true);\n-        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                     0xFF, 0xFF, 0xFF, 0xFF]));\n-        bit_vec.grow(64, false);\n-        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n-        bit_vec.grow(16, true);\n-        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n-    }\n-\n-    #[test]\n-    fn test_bit_vec_extend() {\n-        let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n-        let ext = BitVec::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n-        bit_vec.extend(ext.iter());\n-        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n-                                     0b01001001, 0b10010010, 0b10111101]));\n-    }\n-}\n-\n-\n-\n-\n-#[cfg(test)]\n-mod bit_vec_bench {\n-    use std::prelude::v1::*;\n-    use std::rand;\n-    use std::rand::Rng;\n-    use std::u32;\n-    use test::{Bencher, black_box};\n-\n-    use super::BitVec;\n-\n-    const BENCH_BITS : usize = 1 << 14;\n-\n-    fn rng() -> rand::IsaacRng {\n-        let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n-        rand::SeedableRng::from_seed(seed)\n-    }\n-\n-    #[bench]\n-    fn bench_usize_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = 0 as usize;\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS as usize);\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_set_big_fixed(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, true);\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_set_big_variable(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_set_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = BitVec::from_elem(u32::BITS as usize, false);\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec.set((r.next_u32() as usize) % u32::BITS as usize, true);\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vec_big_union(b: &mut Bencher) {\n-        let mut b1 = BitVec::from_elem(BENCH_BITS, false);\n-        let b2 = BitVec::from_elem(BENCH_BITS, false);\n-        b.iter(|| {\n-            b1.union(&b2)\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vec_small_iter(b: &mut Bencher) {\n-        let bit_vec = BitVec::from_elem(u32::BITS as usize, false);\n-        b.iter(|| {\n-            let mut sum = 0;\n-            for _ in 0..10 {\n-                for pres in &bit_vec {\n-                    sum += pres as usize;\n-                }\n-            }\n-            sum\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vec_big_iter(b: &mut Bencher) {\n-        let bit_vec = BitVec::from_elem(BENCH_BITS, false);\n-        b.iter(|| {\n-            let mut sum = 0;\n-            for pres in &bit_vec {\n-                sum += pres as usize;\n-            }\n-            sum\n-        })\n-    }\n-}\n-\n-\n-\n-\n-\n-\n-\n-#[cfg(test)]\n-mod bit_set_test {\n-    use prelude::*;\n-    use std::iter::range_step;\n-\n-    use super::{BitVec, BitSet};\n-\n-    #[test]\n-    fn test_bit_set_show() {\n-        let mut s = BitSet::new();\n-        s.insert(1);\n-        s.insert(10);\n-        s.insert(50);\n-        s.insert(2);\n-        assert_eq!(\"{1, 2, 10, 50}\", format!(\"{:?}\", s));\n-    }\n-\n-    #[test]\n-    fn test_bit_set_from_usizes() {\n-        let usizes = vec![0, 2, 2, 3];\n-        let a: BitSet = usizes.into_iter().collect();\n-        let mut b = BitSet::new();\n-        b.insert(0);\n-        b.insert(2);\n-        b.insert(3);\n-        assert_eq!(a, b);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_iterator() {\n-        let usizes = vec![0, 2, 2, 3];\n-        let bit_vec: BitSet = usizes.into_iter().collect();\n-\n-        let idxs: Vec<_> = bit_vec.iter().collect();\n-        assert_eq!(idxs, [0, 2, 3]);\n-\n-        let long: BitSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n-        let real: Vec<_> = range_step(0, 10000, 2).collect();\n-\n-        let idxs: Vec<_> = long.iter().collect();\n-        assert_eq!(idxs, real);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_frombit_vec_init() {\n-        let bools = [true, false];\n-        let lengths = [10, 64, 100];\n-        for &b in &bools {\n-            for &l in &lengths {\n-                let bitset = BitSet::from_bit_vec(BitVec::from_elem(l, b));\n-                assert_eq!(bitset.contains(&1), b);\n-                assert_eq!(bitset.contains(&(l-1)), b);\n-                assert!(!bitset.contains(&l));\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_bit_vec_masking() {\n-        let b = BitVec::from_elem(140, true);\n-        let mut bs = BitSet::from_bit_vec(b);\n-        assert!(bs.contains(&139));\n-        assert!(!bs.contains(&140));\n-        assert!(bs.insert(150));\n-        assert!(!bs.contains(&140));\n-        assert!(!bs.contains(&149));\n-        assert!(bs.contains(&150));\n-        assert!(!bs.contains(&151));\n-    }\n-\n-    #[test]\n-    fn test_bit_set_basic() {\n-        let mut b = BitSet::new();\n-        assert!(b.insert(3));\n-        assert!(!b.insert(3));\n-        assert!(b.contains(&3));\n-        assert!(b.insert(4));\n-        assert!(!b.insert(4));\n-        assert!(b.contains(&3));\n-        assert!(b.insert(400));\n-        assert!(!b.insert(400));\n-        assert!(b.contains(&400));\n-        assert_eq!(b.len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_intersection() {\n-        let mut a = BitSet::new();\n-        let mut b = BitSet::new();\n-\n-        assert!(a.insert(11));\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(77));\n-        assert!(a.insert(103));\n-        assert!(a.insert(5));\n-\n-        assert!(b.insert(2));\n-        assert!(b.insert(11));\n-        assert!(b.insert(77));\n-        assert!(b.insert(5));\n-        assert!(b.insert(3));\n-\n-        let expected = [3, 5, 11, 77];\n-        let actual: Vec<_> = a.intersection(&b).collect();\n-        assert_eq!(actual, expected);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_difference() {\n-        let mut a = BitSet::new();\n-        let mut b = BitSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(200));\n-        assert!(a.insert(500));\n-\n-        assert!(b.insert(3));\n-        assert!(b.insert(200));\n-\n-        let expected = [1, 5, 500];\n-        let actual: Vec<_> = a.difference(&b).collect();\n-        assert_eq!(actual, expected);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_symmetric_difference() {\n-        let mut a = BitSet::new();\n-        let mut b = BitSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-\n-        assert!(b.insert(3));\n-        assert!(b.insert(9));\n-        assert!(b.insert(14));\n-        assert!(b.insert(220));\n-\n-        let expected = [1, 5, 11, 14, 220];\n-        let actual: Vec<_> = a.symmetric_difference(&b).collect();\n-        assert_eq!(actual, expected);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_union() {\n-        let mut a = BitSet::new();\n-        let mut b = BitSet::new();\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-        assert!(a.insert(160));\n-        assert!(a.insert(19));\n-        assert!(a.insert(24));\n-        assert!(a.insert(200));\n-\n-        assert!(b.insert(1));\n-        assert!(b.insert(5));\n-        assert!(b.insert(9));\n-        assert!(b.insert(13));\n-        assert!(b.insert(19));\n-\n-        let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160, 200];\n-        let actual: Vec<_> = a.union(&b).collect();\n-        assert_eq!(actual, expected);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_subset() {\n-        let mut set1 = BitSet::new();\n-        let mut set2 = BitSet::new();\n-\n-        assert!(set1.is_subset(&set2)); //  {}  {}\n-        set2.insert(100);\n-        assert!(set1.is_subset(&set2)); //  {}  { 1 }\n-        set2.insert(200);\n-        assert!(set1.is_subset(&set2)); //  {}  { 1, 2 }\n-        set1.insert(200);\n-        assert!(set1.is_subset(&set2)); //  { 2 }  { 1, 2 }\n-        set1.insert(300);\n-        assert!(!set1.is_subset(&set2)); // { 2, 3 }  { 1, 2 }\n-        set2.insert(300);\n-        assert!(set1.is_subset(&set2)); // { 2, 3 }  { 1, 2, 3 }\n-        set2.insert(400);\n-        assert!(set1.is_subset(&set2)); // { 2, 3 }  { 1, 2, 3, 4 }\n-        set2.remove(&100);\n-        assert!(set1.is_subset(&set2)); // { 2, 3 }  { 2, 3, 4 }\n-        set2.remove(&300);\n-        assert!(!set1.is_subset(&set2)); // { 2, 3 }  { 2, 4 }\n-        set1.remove(&300);\n-        assert!(set1.is_subset(&set2)); // { 2 }  { 2, 4 }\n-    }\n-\n-    #[test]\n-    fn test_bit_set_is_disjoint() {\n-        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01000000]));\n-        let c = BitSet::new();\n-        let d = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00110000]));\n-\n-        assert!(!a.is_disjoint(&d));\n-        assert!(!d.is_disjoint(&a));\n-\n-        assert!(a.is_disjoint(&b));\n-        assert!(a.is_disjoint(&c));\n-        assert!(b.is_disjoint(&a));\n-        assert!(b.is_disjoint(&c));\n-        assert!(c.is_disjoint(&a));\n-        assert!(c.is_disjoint(&b));\n-    }\n-\n-    #[test]\n-    fn test_bit_set_union_with() {\n-        //a should grow to include larger elements\n-        let mut a = BitSet::new();\n-        a.insert(0);\n-        let mut b = BitSet::new();\n-        b.insert(5);\n-        let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n-        a.union_with(&b);\n-        assert_eq!(a, expected);\n-\n-        // Standard\n-        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n-        let c = a.clone();\n-        a.union_with(&b);\n-        b.union_with(&c);\n-        assert_eq!(a.len(), 4);\n-        assert_eq!(b.len(), 4);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_intersect_with() {\n-        // Explicitly 0'ed bits\n-        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n-        let c = a.clone();\n-        a.intersect_with(&b);\n-        b.intersect_with(&c);\n-        assert!(a.is_empty());\n-        assert!(b.is_empty());\n-\n-        // Uninitialized bits should behave like 0's\n-        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-        let mut b = BitSet::new();\n-        let c = a.clone();\n-        a.intersect_with(&b);\n-        b.intersect_with(&c);\n-        assert!(a.is_empty());\n-        assert!(b.is_empty());\n-\n-        // Standard\n-        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n-        let c = a.clone();\n-        a.intersect_with(&b);\n-        b.intersect_with(&c);\n-        assert_eq!(a.len(), 2);\n-        assert_eq!(b.len(), 2);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_difference_with() {\n-        // Explicitly 0'ed bits\n-        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n-        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-        a.difference_with(&b);\n-        assert!(a.is_empty());\n-\n-        // Uninitialized bits should behave like 0's\n-        let mut a = BitSet::new();\n-        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11111111]));\n-        a.difference_with(&b);\n-        assert!(a.is_empty());\n-\n-        // Standard\n-        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n-        let c = a.clone();\n-        a.difference_with(&b);\n-        b.difference_with(&c);\n-        assert_eq!(a.len(), 1);\n-        assert_eq!(b.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_symmetric_difference_with() {\n-        //a should grow to include larger elements\n-        let mut a = BitSet::new();\n-        a.insert(0);\n-        a.insert(1);\n-        let mut b = BitSet::new();\n-        b.insert(1);\n-        b.insert(5);\n-        let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n-        a.symmetric_difference_with(&b);\n-        assert_eq!(a, expected);\n-\n-        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-        let b = BitSet::new();\n-        let c = a.clone();\n-        a.symmetric_difference_with(&b);\n-        assert_eq!(a, c);\n-\n-        // Standard\n-        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11100010]));\n-        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101010]));\n-        let c = a.clone();\n-        a.symmetric_difference_with(&b);\n-        b.symmetric_difference_with(&c);\n-        assert_eq!(a.len(), 2);\n-        assert_eq!(b.len(), 2);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_eq() {\n-        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n-        let c = BitSet::new();\n-\n-        assert!(a == a);\n-        assert!(a != b);\n-        assert!(a != c);\n-        assert!(b == b);\n-        assert!(b == c);\n-        assert!(c == c);\n-    }\n-\n-    #[test]\n-    fn test_bit_set_cmp() {\n-        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n-        let c = BitSet::new();\n-\n-        assert_eq!(a.cmp(&b), Greater);\n-        assert_eq!(a.cmp(&c), Greater);\n-        assert_eq!(b.cmp(&a), Less);\n-        assert_eq!(b.cmp(&c), Equal);\n-        assert_eq!(c.cmp(&a), Less);\n-        assert_eq!(c.cmp(&b), Equal);\n-    }\n-\n-    #[test]\n-    fn test_bit_vec_remove() {\n-        let mut a = BitSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.remove(&1));\n-\n-        assert!(a.insert(100));\n-        assert!(a.remove(&100));\n-\n-        assert!(a.insert(1000));\n-        assert!(a.remove(&1000));\n-        a.shrink_to_fit();\n-    }\n-\n-    #[test]\n-    fn test_bit_vec_clone() {\n-        let mut a = BitSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(100));\n-        assert!(a.insert(1000));\n-\n-        let mut b = a.clone();\n-\n-        assert!(a == b);\n-\n-        assert!(b.remove(&1));\n-        assert!(a.contains(&1));\n-\n-        assert!(a.remove(&1000));\n-        assert!(b.contains(&1000));\n-    }\n-}\n-\n-\n-\n-\n-\n-#[cfg(test)]\n-mod bit_set_bench {\n-    use std::prelude::v1::*;\n-    use std::rand;\n-    use std::rand::Rng;\n-    use std::u32;\n-    use test::{Bencher, black_box};\n-\n-    use super::{BitVec, BitSet};\n-\n-    const BENCH_BITS : usize = 1 << 14;\n-\n-    fn rng() -> rand::IsaacRng {\n-        let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n-        rand::SeedableRng::from_seed(seed)\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vecset_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = BitSet::new();\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec.insert((r.next_u32() as usize) % u32::BITS as usize);\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vecset_big(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = BitSet::new();\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec.insert((r.next_u32() as usize) % BENCH_BITS);\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vecset_iter(b: &mut Bencher) {\n-        let bit_vec = BitSet::from_bit_vec(BitVec::from_fn(BENCH_BITS,\n-                                              |idx| {idx % 3 == 0}));\n-        b.iter(|| {\n-            let mut sum = 0;\n-            for idx in &bit_vec {\n-                sum += idx as usize;\n-            }\n-            sum\n-        })\n-    }\n-}"}, {"sha": "c7e1e3c91766ef297d71fbad17905910d2530c61", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -1599,309 +1599,3 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n }\n-\n-\n-\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-    use std::iter::range_inclusive;\n-\n-    use super::BTreeMap;\n-    use super::Entry::{Occupied, Vacant};\n-    use Bound::{self, Included, Excluded, Unbounded};\n-\n-    #[test]\n-    fn test_basic_large() {\n-        let mut map = BTreeMap::new();\n-        let size = 10000;\n-        assert_eq!(map.len(), 0);\n-\n-        for i in 0..size {\n-            assert_eq!(map.insert(i, 10*i), None);\n-            assert_eq!(map.len(), i + 1);\n-        }\n-\n-        for i in 0..size {\n-            assert_eq!(map.get(&i).unwrap(), &(i*10));\n-        }\n-\n-        for i in size..size*2 {\n-            assert_eq!(map.get(&i), None);\n-        }\n-\n-        for i in 0..size {\n-            assert_eq!(map.insert(i, 100*i), Some(10*i));\n-            assert_eq!(map.len(), size);\n-        }\n-\n-        for i in 0..size {\n-            assert_eq!(map.get(&i).unwrap(), &(i*100));\n-        }\n-\n-        for i in 0..size/2 {\n-            assert_eq!(map.remove(&(i*2)), Some(i*200));\n-            assert_eq!(map.len(), size - i - 1);\n-        }\n-\n-        for i in 0..size/2 {\n-            assert_eq!(map.get(&(2*i)), None);\n-            assert_eq!(map.get(&(2*i+1)).unwrap(), &(i*200 + 100));\n-        }\n-\n-        for i in 0..size/2 {\n-            assert_eq!(map.remove(&(2*i)), None);\n-            assert_eq!(map.remove(&(2*i+1)), Some(i*200 + 100));\n-            assert_eq!(map.len(), size/2 - i - 1);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_basic_small() {\n-        let mut map = BTreeMap::new();\n-        assert_eq!(map.remove(&1), None);\n-        assert_eq!(map.get(&1), None);\n-        assert_eq!(map.insert(1, 1), None);\n-        assert_eq!(map.get(&1), Some(&1));\n-        assert_eq!(map.insert(1, 2), Some(1));\n-        assert_eq!(map.get(&1), Some(&2));\n-        assert_eq!(map.insert(2, 4), None);\n-        assert_eq!(map.get(&2), Some(&4));\n-        assert_eq!(map.remove(&1), Some(2));\n-        assert_eq!(map.remove(&2), Some(4));\n-        assert_eq!(map.remove(&1), None);\n-    }\n-\n-    #[test]\n-    fn test_iter() {\n-        let size = 10000;\n-\n-        // Forwards\n-        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-\n-        fn test<T>(size: usize, mut iter: T) where T: Iterator<Item=(usize, usize)> {\n-            for i in 0..size {\n-                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n-                assert_eq!(iter.next().unwrap(), (i, i));\n-            }\n-            assert_eq!(iter.size_hint(), (0, Some(0)));\n-            assert_eq!(iter.next(), None);\n-        }\n-        test(size, map.iter().map(|(&k, &v)| (k, v)));\n-        test(size, map.iter_mut().map(|(&k, &mut v)| (k, v)));\n-        test(size, map.into_iter());\n-    }\n-\n-    #[test]\n-    fn test_iter_rev() {\n-        let size = 10000;\n-\n-        // Forwards\n-        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-\n-        fn test<T>(size: usize, mut iter: T) where T: Iterator<Item=(usize, usize)> {\n-            for i in 0..size {\n-                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n-                assert_eq!(iter.next().unwrap(), (size - i - 1, size - i - 1));\n-            }\n-            assert_eq!(iter.size_hint(), (0, Some(0)));\n-            assert_eq!(iter.next(), None);\n-        }\n-        test(size, map.iter().rev().map(|(&k, &v)| (k, v)));\n-        test(size, map.iter_mut().rev().map(|(&k, &mut v)| (k, v)));\n-        test(size, map.into_iter().rev());\n-    }\n-\n-    #[test]\n-    fn test_iter_mixed() {\n-        let size = 10000;\n-\n-        // Forwards\n-        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-\n-        fn test<T>(size: usize, mut iter: T)\n-                where T: Iterator<Item=(usize, usize)> + DoubleEndedIterator {\n-            for i in 0..size / 4 {\n-                assert_eq!(iter.size_hint(), (size - i * 2, Some(size - i * 2)));\n-                assert_eq!(iter.next().unwrap(), (i, i));\n-                assert_eq!(iter.next_back().unwrap(), (size - i - 1, size - i - 1));\n-            }\n-            for i in size / 4..size * 3 / 4 {\n-                assert_eq!(iter.size_hint(), (size * 3 / 4 - i, Some(size * 3 / 4 - i)));\n-                assert_eq!(iter.next().unwrap(), (i, i));\n-            }\n-            assert_eq!(iter.size_hint(), (0, Some(0)));\n-            assert_eq!(iter.next(), None);\n-        }\n-        test(size, map.iter().map(|(&k, &v)| (k, v)));\n-        test(size, map.iter_mut().map(|(&k, &mut v)| (k, v)));\n-        test(size, map.into_iter());\n-    }\n-\n-    #[test]\n-    fn test_range_small() {\n-        let size = 5;\n-\n-        // Forwards\n-        let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-\n-        let mut j = 0;\n-        for ((&k, &v), i) in map.range(Included(&2), Unbounded).zip(2..size) {\n-            assert_eq!(k, i);\n-            assert_eq!(v, i);\n-            j += 1;\n-        }\n-        assert_eq!(j, size - 2);\n-    }\n-\n-    #[test]\n-    fn test_range_1000() {\n-        let size = 1000;\n-        let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-\n-        fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n-            let mut kvs = map.range(min, max).map(|(&k, &v)| (k, v));\n-            let mut pairs = (0..size).map(|i| (i, i));\n-\n-            for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n-                assert_eq!(kv, pair);\n-            }\n-            assert_eq!(kvs.next(), None);\n-            assert_eq!(pairs.next(), None);\n-        }\n-        test(&map, size, Included(&0), Excluded(&size));\n-        test(&map, size, Unbounded, Excluded(&size));\n-        test(&map, size, Included(&0), Included(&(size - 1)));\n-        test(&map, size, Unbounded, Included(&(size - 1)));\n-        test(&map, size, Included(&0), Unbounded);\n-        test(&map, size, Unbounded, Unbounded);\n-    }\n-\n-    #[test]\n-    fn test_range() {\n-        let size = 200;\n-        let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-\n-        for i in 0..size {\n-            for j in i..size {\n-                let mut kvs = map.range(Included(&i), Included(&j)).map(|(&k, &v)| (k, v));\n-                let mut pairs = range_inclusive(i, j).map(|i| (i, i));\n-\n-                for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n-                    assert_eq!(kv, pair);\n-                }\n-                assert_eq!(kvs.next(), None);\n-                assert_eq!(pairs.next(), None);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_entry(){\n-        let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n-\n-        let mut map: BTreeMap<_, _> = xs.iter().cloned().collect();\n-\n-        // Existing key (insert)\n-        match map.entry(1) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                assert_eq!(view.get(), &10);\n-                assert_eq!(view.insert(100), 10);\n-            }\n-        }\n-        assert_eq!(map.get(&1).unwrap(), &100);\n-        assert_eq!(map.len(), 6);\n-\n-\n-        // Existing key (update)\n-        match map.entry(2) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                let v = view.get_mut();\n-                *v *= 10;\n-            }\n-        }\n-        assert_eq!(map.get(&2).unwrap(), &200);\n-        assert_eq!(map.len(), 6);\n-\n-        // Existing key (take)\n-        match map.entry(3) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(view) => {\n-                assert_eq!(view.remove(), 30);\n-            }\n-        }\n-        assert_eq!(map.get(&3), None);\n-        assert_eq!(map.len(), 5);\n-\n-\n-        // Inexistent key (insert)\n-        match map.entry(10) {\n-            Occupied(_) => unreachable!(),\n-            Vacant(view) => {\n-                assert_eq!(*view.insert(1000), 1000);\n-            }\n-        }\n-        assert_eq!(map.get(&10).unwrap(), &1000);\n-        assert_eq!(map.len(), 6);\n-    }\n-}\n-\n-\n-\n-\n-\n-\n-#[cfg(test)]\n-mod bench {\n-    use prelude::*;\n-    use std::rand::{weak_rng, Rng};\n-    use test::{Bencher, black_box};\n-\n-    use super::BTreeMap;\n-\n-    map_insert_rand_bench!{insert_rand_100,    100,    BTreeMap}\n-    map_insert_rand_bench!{insert_rand_10_000, 10_000, BTreeMap}\n-\n-    map_insert_seq_bench!{insert_seq_100,    100,    BTreeMap}\n-    map_insert_seq_bench!{insert_seq_10_000, 10_000, BTreeMap}\n-\n-    map_find_rand_bench!{find_rand_100,    100,    BTreeMap}\n-    map_find_rand_bench!{find_rand_10_000, 10_000, BTreeMap}\n-\n-    map_find_seq_bench!{find_seq_100,    100,    BTreeMap}\n-    map_find_seq_bench!{find_seq_10_000, 10_000, BTreeMap}\n-\n-    fn bench_iter(b: &mut Bencher, size: i32) {\n-        let mut map = BTreeMap::<i32, i32>::new();\n-        let mut rng = weak_rng();\n-\n-        for _ in 0..size {\n-            map.insert(rng.gen(), rng.gen());\n-        }\n-\n-        b.iter(|| {\n-            for entry in &map {\n-                black_box(entry);\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn iter_20(b: &mut Bencher) {\n-        bench_iter(b, 20);\n-    }\n-\n-    #[bench]\n-    pub fn iter_1000(b: &mut Bencher) {\n-        bench_iter(b, 1000);\n-    }\n-\n-    #[bench]\n-    pub fn iter_100000(b: &mut Bencher) {\n-        bench_iter(b, 100000);\n-    }\n-}"}, {"sha": "5616d36ce0ba9ffadb9a1619b0616218a0fab4c7", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -742,180 +742,3 @@ impl<'a, T: Ord> Iterator for Union<'a, T> {\n         }\n     }\n }\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-\n-    use super::BTreeSet;\n-    use std::hash::{self, SipHasher};\n-\n-    #[test]\n-    fn test_clone_eq() {\n-      let mut m = BTreeSet::new();\n-\n-      m.insert(1);\n-      m.insert(2);\n-\n-      assert!(m.clone() == m);\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-      let mut x = BTreeSet::new();\n-      let mut y = BTreeSet::new();\n-\n-      x.insert(1);\n-      x.insert(2);\n-      x.insert(3);\n-\n-      y.insert(3);\n-      y.insert(2);\n-      y.insert(1);\n-\n-      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n-    }\n-\n-    struct Counter<'a, 'b> {\n-        i: &'a mut usize,\n-        expected: &'b [i32],\n-    }\n-\n-    impl<'a, 'b, 'c> FnMut<(&'c i32,)> for Counter<'a, 'b> {\n-        type Output = bool;\n-\n-        extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c i32,)) -> bool {\n-            assert_eq!(x, self.expected[*self.i]);\n-            *self.i += 1;\n-            true\n-        }\n-    }\n-\n-    fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F) where\n-        // FIXME Replace Counter with `Box<FnMut(_) -> _>`\n-        F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, Counter) -> bool,\n-    {\n-        let mut set_a = BTreeSet::new();\n-        let mut set_b = BTreeSet::new();\n-\n-        for x in a { assert!(set_a.insert(*x)) }\n-        for y in b { assert!(set_b.insert(*y)) }\n-\n-        let mut i = 0;\n-        f(&set_a, &set_b, Counter { i: &mut i, expected: expected });\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_intersection() {\n-        fn check_intersection(a: &[i32], b: &[i32], expected: &[i32]) {\n-            check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n-        }\n-\n-        check_intersection(&[], &[], &[]);\n-        check_intersection(&[1, 2, 3], &[], &[]);\n-        check_intersection(&[], &[1, 2, 3], &[]);\n-        check_intersection(&[2], &[1, 2, 3], &[2]);\n-        check_intersection(&[1, 2, 3], &[2], &[2]);\n-        check_intersection(&[11, 1, 3, 77, 103, 5, -5],\n-                           &[2, 11, 77, -9, -42, 5, 3],\n-                           &[3, 5, 11, 77]);\n-    }\n-\n-    #[test]\n-    fn test_difference() {\n-        fn check_difference(a: &[i32], b: &[i32], expected: &[i32]) {\n-            check(a, b, expected, |x, y, f| x.difference(y).all(f))\n-        }\n-\n-        check_difference(&[], &[], &[]);\n-        check_difference(&[1, 12], &[], &[1, 12]);\n-        check_difference(&[], &[1, 2, 3, 9], &[]);\n-        check_difference(&[1, 3, 5, 9, 11],\n-                         &[3, 9],\n-                         &[1, 5, 11]);\n-        check_difference(&[-5, 11, 22, 33, 40, 42],\n-                         &[-12, -5, 14, 23, 34, 38, 39, 50],\n-                         &[11, 22, 33, 40, 42]);\n-    }\n-\n-    #[test]\n-    fn test_symmetric_difference() {\n-        fn check_symmetric_difference(a: &[i32], b: &[i32], expected: &[i32]) {\n-            check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n-        }\n-\n-        check_symmetric_difference(&[], &[], &[]);\n-        check_symmetric_difference(&[1, 2, 3], &[2], &[1, 3]);\n-        check_symmetric_difference(&[2], &[1, 2, 3], &[1, 3]);\n-        check_symmetric_difference(&[1, 3, 5, 9, 11],\n-                                   &[-2, 3, 9, 14, 22],\n-                                   &[-2, 1, 5, 11, 14, 22]);\n-    }\n-\n-    #[test]\n-    fn test_union() {\n-        fn check_union(a: &[i32], b: &[i32], expected: &[i32]) {\n-            check(a, b, expected, |x, y, f| x.union(y).all(f))\n-        }\n-\n-        check_union(&[], &[], &[]);\n-        check_union(&[1, 2, 3], &[2], &[1, 2, 3]);\n-        check_union(&[2], &[1, 2, 3], &[1, 2, 3]);\n-        check_union(&[1, 3, 5, 9, 11, 16, 19, 24],\n-                    &[-2, 1, 5, 9, 13, 19],\n-                    &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n-    }\n-\n-    #[test]\n-    fn test_zip() {\n-        let mut x = BTreeSet::new();\n-        x.insert(5);\n-        x.insert(12);\n-        x.insert(11);\n-\n-        let mut y = BTreeSet::new();\n-        y.insert(\"foo\");\n-        y.insert(\"bar\");\n-\n-        let x = x;\n-        let y = y;\n-        let mut z = x.iter().zip(y.iter());\n-\n-        // FIXME: #5801: this needs a type hint to compile...\n-        let result: Option<(&usize, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&5, &(\"bar\")));\n-\n-        let result: Option<(&usize, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&11, &(\"foo\")));\n-\n-        let result: Option<(&usize, & &'static str)> = z.next();\n-        assert!(result.is_none());\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n-\n-        let set: BTreeSet<_> = xs.iter().cloned().collect();\n-\n-        for x in &xs {\n-            assert!(set.contains(x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut set = BTreeSet::new();\n-        let empty = BTreeSet::<i32>::new();\n-\n-        set.insert(1);\n-        set.insert(2);\n-\n-        let set_str = format!(\"{:?}\", set);\n-\n-        assert_eq!(set_str, \"{1, 2}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"{}\");\n-    }\n-}"}, {"sha": "fe2efc7164d0cae0c8d69b3f75e6010def7e512b", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 0, "deletions": 238, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -285,241 +285,3 @@ impl<E:CLike> Extend<E> for EnumSet<E> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use self::Foo::*;\n-    use prelude::*;\n-    use core::mem;\n-\n-    use super::{EnumSet, CLike};\n-\n-    #[derive(Copy, PartialEq, Debug)]\n-    #[repr(usize)]\n-    enum Foo {\n-        A, B, C\n-    }\n-\n-    impl CLike for Foo {\n-        fn to_usize(&self) -> usize {\n-            *self as usize\n-        }\n-\n-        fn from_usize(v: usize) -> Foo {\n-            unsafe { mem::transmute(v) }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_new() {\n-        let e: EnumSet<Foo> = EnumSet::new();\n-        assert!(e.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut e = EnumSet::new();\n-        assert!(format!(\"{:?}\", e) == \"{}\");\n-        e.insert(A);\n-        assert!(format!(\"{:?}\", e) == \"{A}\");\n-        e.insert(C);\n-        assert!(format!(\"{:?}\", e) == \"{A, C}\");\n-    }\n-\n-    #[test]\n-    fn test_len() {\n-        let mut e = EnumSet::new();\n-        assert_eq!(e.len(), 0);\n-        e.insert(A);\n-        e.insert(B);\n-        e.insert(C);\n-        assert_eq!(e.len(), 3);\n-        e.remove(&A);\n-        assert_eq!(e.len(), 2);\n-        e.clear();\n-        assert_eq!(e.len(), 0);\n-    }\n-\n-    ///////////////////////////////////////////////////////////////////////////\n-    // intersect\n-\n-    #[test]\n-    fn test_two_empties_do_not_intersect() {\n-        let e1: EnumSet<Foo> = EnumSet::new();\n-        let e2: EnumSet<Foo> = EnumSet::new();\n-        assert!(e1.is_disjoint(&e2));\n-    }\n-\n-    #[test]\n-    fn test_empty_does_not_intersect_with_full() {\n-        let e1: EnumSet<Foo> = EnumSet::new();\n-\n-        let mut e2: EnumSet<Foo> = EnumSet::new();\n-        e2.insert(A);\n-        e2.insert(B);\n-        e2.insert(C);\n-\n-        assert!(e1.is_disjoint(&e2));\n-    }\n-\n-    #[test]\n-    fn test_disjoint_intersects() {\n-        let mut e1: EnumSet<Foo> = EnumSet::new();\n-        e1.insert(A);\n-\n-        let mut e2: EnumSet<Foo> = EnumSet::new();\n-        e2.insert(B);\n-\n-        assert!(e1.is_disjoint(&e2));\n-    }\n-\n-    #[test]\n-    fn test_overlapping_intersects() {\n-        let mut e1: EnumSet<Foo> = EnumSet::new();\n-        e1.insert(A);\n-\n-        let mut e2: EnumSet<Foo> = EnumSet::new();\n-        e2.insert(A);\n-        e2.insert(B);\n-\n-        assert!(!e1.is_disjoint(&e2));\n-    }\n-\n-    ///////////////////////////////////////////////////////////////////////////\n-    // contains and contains_elem\n-\n-    #[test]\n-    fn test_superset() {\n-        let mut e1: EnumSet<Foo> = EnumSet::new();\n-        e1.insert(A);\n-\n-        let mut e2: EnumSet<Foo> = EnumSet::new();\n-        e2.insert(A);\n-        e2.insert(B);\n-\n-        let mut e3: EnumSet<Foo> = EnumSet::new();\n-        e3.insert(C);\n-\n-        assert!(e1.is_subset(&e2));\n-        assert!(e2.is_superset(&e1));\n-        assert!(!e3.is_superset(&e2));\n-        assert!(!e2.is_superset(&e3))\n-    }\n-\n-    #[test]\n-    fn test_contains() {\n-        let mut e1: EnumSet<Foo> = EnumSet::new();\n-        e1.insert(A);\n-        assert!(e1.contains(&A));\n-        assert!(!e1.contains(&B));\n-        assert!(!e1.contains(&C));\n-\n-        e1.insert(A);\n-        e1.insert(B);\n-        assert!(e1.contains(&A));\n-        assert!(e1.contains(&B));\n-        assert!(!e1.contains(&C));\n-    }\n-\n-    ///////////////////////////////////////////////////////////////////////////\n-    // iter\n-\n-    #[test]\n-    fn test_iterator() {\n-        let mut e1: EnumSet<Foo> = EnumSet::new();\n-\n-        let elems: ::vec::Vec<Foo> = e1.iter().collect();\n-        assert!(elems.is_empty());\n-\n-        e1.insert(A);\n-        let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!([A], elems);\n-\n-        e1.insert(C);\n-        let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!([A,C], elems);\n-\n-        e1.insert(C);\n-        let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!([A,C], elems);\n-\n-        e1.insert(B);\n-        let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!([A,B,C], elems);\n-    }\n-\n-    ///////////////////////////////////////////////////////////////////////////\n-    // operators\n-\n-    #[test]\n-    fn test_operators() {\n-        let mut e1: EnumSet<Foo> = EnumSet::new();\n-        e1.insert(A);\n-        e1.insert(C);\n-\n-        let mut e2: EnumSet<Foo> = EnumSet::new();\n-        e2.insert(B);\n-        e2.insert(C);\n-\n-        let e_union = e1 | e2;\n-        let elems: ::vec::Vec<_> = e_union.iter().collect();\n-        assert_eq!([A,B,C], elems);\n-\n-        let e_intersection = e1 & e2;\n-        let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n-        assert_eq!([C], elems);\n-\n-        // Another way to express intersection\n-        let e_intersection = e1 - (e1 - e2);\n-        let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n-        assert_eq!([C], elems);\n-\n-        let e_subtract = e1 - e2;\n-        let elems: ::vec::Vec<_> = e_subtract.iter().collect();\n-        assert_eq!([A], elems);\n-\n-        // Bitwise XOR of two sets, aka symmetric difference\n-        let e_symmetric_diff = e1 ^ e2;\n-        let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!([A,B], elems);\n-\n-        // Another way to express symmetric difference\n-        let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n-        let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!([A,B], elems);\n-\n-        // Yet another way to express symmetric difference\n-        let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n-        let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!([A,B], elems);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_overflow() {\n-        #[allow(dead_code)]\n-        #[derive(Copy)]\n-        #[repr(usize)]\n-        enum Bar {\n-            V00, V01, V02, V03, V04, V05, V06, V07, V08, V09,\n-            V10, V11, V12, V13, V14, V15, V16, V17, V18, V19,\n-            V20, V21, V22, V23, V24, V25, V26, V27, V28, V29,\n-            V30, V31, V32, V33, V34, V35, V36, V37, V38, V39,\n-            V40, V41, V42, V43, V44, V45, V46, V47, V48, V49,\n-            V50, V51, V52, V53, V54, V55, V56, V57, V58, V59,\n-            V60, V61, V62, V63, V64, V65, V66, V67, V68, V69,\n-        }\n-\n-        impl CLike for Bar {\n-            fn to_usize(&self) -> usize {\n-                *self as usize\n-            }\n-\n-            fn from_usize(v: usize) -> Bar {\n-                unsafe { mem::transmute(v) }\n-            }\n-        }\n-        let mut set = EnumSet::new();\n-        set.insert(Bar::V64);\n-    }\n-}"}, {"sha": "bb7db1151e83380217f02eba632deee685fe71e0", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -434,15 +434,3 @@ pub fn format(args: Arguments) -> string::String {\n     let _ = write!(&mut output, \"{}\", args);\n     output\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use fmt;\n-\n-    #[test]\n-    fn test_format() {\n-        let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n-        assert_eq!(s.as_slice(), \"Hello, world!\");\n-    }\n-}"}, {"sha": "0d53215a5965985e6e5c0e3a3a377f7d17afdd0b", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -47,10 +47,6 @@ extern crate core;\n extern crate unicode;\n extern crate alloc;\n \n-#[cfg(test)] extern crate test;\n-#[cfg(test)] #[macro_use] extern crate std;\n-#[cfg(test)] #[macro_use] extern crate log;\n-\n pub use binary_heap::BinaryHeap;\n pub use bit_vec::BitVec;\n pub use bit_set::BitSet;\n@@ -85,8 +81,6 @@ pub use alloc::boxed;\n #[macro_use]\n mod macros;\n \n-#[cfg(test)] #[macro_use] mod bench;\n-\n pub mod binary_heap;\n mod bit;\n mod btree;\n@@ -137,47 +131,10 @@ pub mod btree_set {\n #[doc(hidden)]\n pub fn fixme_14344_be_sure_to_link_to_collections() {}\n \n-#[cfg(not(test))]\n mod std {\n     pub use core::ops;      // RangeFull\n }\n \n-#[cfg(test)]\n-mod prelude {\n-    // from core.\n-    pub use core::clone::Clone;\n-    pub use core::cmp::{PartialEq, Eq, PartialOrd, Ord};\n-    pub use core::cmp::Ordering::{Less, Equal, Greater};\n-    pub use core::iter::range;\n-    pub use core::iter::{FromIterator, Extend, IteratorExt};\n-    pub use core::iter::{Iterator, DoubleEndedIterator, RandomAccessIterator};\n-    pub use core::iter::{ExactSizeIterator};\n-    pub use core::marker::{Copy, Send, Sized, Sync};\n-    pub use core::mem::drop;\n-    pub use core::ops::{Drop, Fn, FnMut, FnOnce};\n-    pub use core::option::Option;\n-    pub use core::option::Option::{Some, None};\n-    pub use core::ptr::PtrExt;\n-    pub use core::result::Result;\n-    pub use core::result::Result::{Ok, Err};\n-\n-    // in core and collections (may differ).\n-    pub use slice::{AsSlice, SliceExt};\n-    #[cfg(stage0)]\n-    pub use str::{Str, StrExt};\n-    #[cfg(not(stage0))]\n-    pub use str::Str;\n-\n-    // from other crates.\n-    pub use alloc::boxed::Box;\n-\n-    // from collections.\n-    pub use borrow::IntoCow;\n-    pub use slice::SliceConcatExt;\n-    pub use string::{String, ToString};\n-    pub use vec::Vec;\n-}\n-\n /// An endpoint of a range of keys.\n #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n pub enum Bound<T> {"}, {"sha": "0799e14e6574db992bc139827d0a120adfb7f2b0", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 0, "deletions": 569, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -938,572 +938,3 @@ impl<A: Hash> Hash for LinkedList<A> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use std::rand;\n-    use std::hash::{self, SipHasher};\n-    use std::thread;\n-    use test::Bencher;\n-    use test;\n-\n-    use super::{LinkedList, Node};\n-\n-    pub fn check_links<T>(list: &LinkedList<T>) {\n-        let mut len = 0;\n-        let mut last_ptr: Option<&Node<T>> = None;\n-        let mut node_ptr: &Node<T>;\n-        match list.list_head {\n-            None => { assert_eq!(0, list.length); return }\n-            Some(ref node) => node_ptr = &**node,\n-        }\n-        loop {\n-            match (last_ptr, node_ptr.prev.resolve_immut()) {\n-                (None   , None      ) => {}\n-                (None   , _         ) => panic!(\"prev link for list_head\"),\n-                (Some(p), Some(pptr)) => {\n-                    assert_eq!(p as *const Node<T>, pptr as *const Node<T>);\n-                }\n-                _ => panic!(\"prev link is none, not good\"),\n-            }\n-            match node_ptr.next {\n-                Some(ref next) => {\n-                    last_ptr = Some(node_ptr);\n-                    node_ptr = &**next;\n-                    len += 1;\n-                }\n-                None => {\n-                    len += 1;\n-                    break;\n-                }\n-            }\n-        }\n-        assert_eq!(len, list.length);\n-    }\n-\n-    #[test]\n-    fn test_basic() {\n-        let mut m = LinkedList::<Box<_>>::new();\n-        assert_eq!(m.pop_front(), None);\n-        assert_eq!(m.pop_back(), None);\n-        assert_eq!(m.pop_front(), None);\n-        m.push_front(box 1);\n-        assert_eq!(m.pop_front(), Some(box 1));\n-        m.push_back(box 2);\n-        m.push_back(box 3);\n-        assert_eq!(m.len(), 2);\n-        assert_eq!(m.pop_front(), Some(box 2));\n-        assert_eq!(m.pop_front(), Some(box 3));\n-        assert_eq!(m.len(), 0);\n-        assert_eq!(m.pop_front(), None);\n-        m.push_back(box 1);\n-        m.push_back(box 3);\n-        m.push_back(box 5);\n-        m.push_back(box 7);\n-        assert_eq!(m.pop_front(), Some(box 1));\n-\n-        let mut n = LinkedList::new();\n-        n.push_front(2);\n-        n.push_front(3);\n-        {\n-            assert_eq!(n.front().unwrap(), &3);\n-            let x = n.front_mut().unwrap();\n-            assert_eq!(*x, 3);\n-            *x = 0;\n-        }\n-        {\n-            assert_eq!(n.back().unwrap(), &2);\n-            let y = n.back_mut().unwrap();\n-            assert_eq!(*y, 2);\n-            *y = 1;\n-        }\n-        assert_eq!(n.pop_front(), Some(0));\n-        assert_eq!(n.pop_front(), Some(1));\n-    }\n-\n-    #[cfg(test)]\n-    fn generate_test() -> LinkedList<i32> {\n-        list_from(&[0,1,2,3,4,5,6])\n-    }\n-\n-    #[cfg(test)]\n-    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n-        v.iter().cloned().collect()\n-    }\n-\n-    #[test]\n-    fn test_append() {\n-        // Empty to empty\n-        {\n-            let mut m = LinkedList::<i32>::new();\n-            let mut n = LinkedList::new();\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 0);\n-            assert_eq!(n.len(), 0);\n-        }\n-        // Non-empty to empty\n-        {\n-            let mut m = LinkedList::new();\n-            let mut n = LinkedList::new();\n-            n.push_back(2);\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            assert_eq!(n.len(), 0);\n-            check_links(&m);\n-        }\n-        // Empty to non-empty\n-        {\n-            let mut m = LinkedList::new();\n-            let mut n = LinkedList::new();\n-            m.push_back(2);\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            check_links(&m);\n-        }\n-\n-        // Non-empty to non-empty\n-        let v = vec![1,2,3,4,5];\n-        let u = vec![9,8,1,2,3,4,5];\n-        let mut m = list_from(&v);\n-        let mut n = list_from(&u);\n-        m.append(&mut n);\n-        check_links(&m);\n-        let mut sum = v;\n-        sum.push_all(&u);\n-        assert_eq!(sum.len(), m.len());\n-        for elt in sum {\n-            assert_eq!(m.pop_front(), Some(elt))\n-        }\n-        assert_eq!(n.len(), 0);\n-        // let's make sure it's working properly, since we\n-        // did some direct changes to private members\n-        n.push_back(3);\n-        assert_eq!(n.len(), 1);\n-        assert_eq!(n.pop_front(), Some(3));\n-        check_links(&n);\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        // singleton\n-        {\n-            let mut m = LinkedList::new();\n-            m.push_back(1);\n-\n-            let p = m.split_off(0);\n-            assert_eq!(m.len(), 0);\n-            assert_eq!(p.len(), 1);\n-            assert_eq!(p.back(), Some(&1));\n-            assert_eq!(p.front(), Some(&1));\n-        }\n-\n-        // not singleton, forwards\n-        {\n-            let u = vec![1,2,3,4,5];\n-            let mut m = list_from(&u);\n-            let mut n = m.split_off(2);\n-            assert_eq!(m.len(), 2);\n-            assert_eq!(n.len(), 3);\n-            for elt in 1..3 {\n-                assert_eq!(m.pop_front(), Some(elt));\n-            }\n-            for elt in 3..6 {\n-                assert_eq!(n.pop_front(), Some(elt));\n-            }\n-        }\n-        // not singleton, backwards\n-        {\n-            let u = vec![1,2,3,4,5];\n-            let mut m = list_from(&u);\n-            let mut n = m.split_off(4);\n-            assert_eq!(m.len(), 4);\n-            assert_eq!(n.len(), 1);\n-            for elt in 1..5 {\n-                assert_eq!(m.pop_front(), Some(elt));\n-            }\n-            for elt in 5..6 {\n-                assert_eq!(n.pop_front(), Some(elt));\n-            }\n-        }\n-\n-        // no-op on the last index\n-        {\n-            let mut m = LinkedList::new();\n-            m.push_back(1);\n-\n-            let p = m.split_off(1);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(p.len(), 0);\n-            assert_eq!(m.back(), Some(&1));\n-            assert_eq!(m.front(), Some(&1));\n-        }\n-\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let m = generate_test();\n-        for (i, elt) in m.iter().enumerate() {\n-            assert_eq!(i as i32, *elt);\n-        }\n-        let mut n = LinkedList::new();\n-        assert_eq!(n.iter().next(), None);\n-        n.push_front(4);\n-        let mut it = n.iter();\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert_eq!(it.next().unwrap(), &4);\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_iterator_clone() {\n-        let mut n = LinkedList::new();\n-        n.push_back(2);\n-        n.push_back(3);\n-        n.push_back(4);\n-        let mut it = n.iter();\n-        it.next();\n-        let mut jt = it.clone();\n-        assert_eq!(it.next(), jt.next());\n-        assert_eq!(it.next_back(), jt.next_back());\n-        assert_eq!(it.next(), jt.next());\n-    }\n-\n-    #[test]\n-    fn test_iterator_double_end() {\n-        let mut n = LinkedList::new();\n-        assert_eq!(n.iter().next(), None);\n-        n.push_front(4);\n-        n.push_front(5);\n-        n.push_front(6);\n-        let mut it = n.iter();\n-        assert_eq!(it.size_hint(), (3, Some(3)));\n-        assert_eq!(it.next().unwrap(), &6);\n-        assert_eq!(it.size_hint(), (2, Some(2)));\n-        assert_eq!(it.next_back().unwrap(), &4);\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert_eq!(it.next_back().unwrap(), &5);\n-        assert_eq!(it.next_back(), None);\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_rev_iter() {\n-        let m = generate_test();\n-        for (i, elt) in m.iter().rev().enumerate() {\n-            assert_eq!((6 - i) as i32, *elt);\n-        }\n-        let mut n = LinkedList::new();\n-        assert_eq!(n.iter().rev().next(), None);\n-        n.push_front(4);\n-        let mut it = n.iter().rev();\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert_eq!(it.next().unwrap(), &4);\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_mut_iter() {\n-        let mut m = generate_test();\n-        let mut len = m.len();\n-        for (i, elt) in m.iter_mut().enumerate() {\n-            assert_eq!(i as i32, *elt);\n-            len -= 1;\n-        }\n-        assert_eq!(len, 0);\n-        let mut n = LinkedList::new();\n-        assert!(n.iter_mut().next().is_none());\n-        n.push_front(4);\n-        n.push_back(5);\n-        let mut it = n.iter_mut();\n-        assert_eq!(it.size_hint(), (2, Some(2)));\n-        assert!(it.next().is_some());\n-        assert!(it.next().is_some());\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_iterator_mut_double_end() {\n-        let mut n = LinkedList::new();\n-        assert!(n.iter_mut().next_back().is_none());\n-        n.push_front(4);\n-        n.push_front(5);\n-        n.push_front(6);\n-        let mut it = n.iter_mut();\n-        assert_eq!(it.size_hint(), (3, Some(3)));\n-        assert_eq!(*it.next().unwrap(), 6);\n-        assert_eq!(it.size_hint(), (2, Some(2)));\n-        assert_eq!(*it.next_back().unwrap(), 4);\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert_eq!(*it.next_back().unwrap(), 5);\n-        assert!(it.next_back().is_none());\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_insert_prev() {\n-        let mut m = list_from(&[0,2,4,6,8]);\n-        let len = m.len();\n-        {\n-            let mut it = m.iter_mut();\n-            it.insert_next(-2);\n-            loop {\n-                match it.next() {\n-                    None => break,\n-                    Some(elt) => {\n-                        it.insert_next(*elt + 1);\n-                        match it.peek_next() {\n-                            Some(x) => assert_eq!(*x, *elt + 2),\n-                            None => assert_eq!(8, *elt),\n-                        }\n-                    }\n-                }\n-            }\n-            it.insert_next(0);\n-            it.insert_next(1);\n-        }\n-        check_links(&m);\n-        assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n-    }\n-\n-    #[test]\n-    fn test_mut_rev_iter() {\n-        let mut m = generate_test();\n-        for (i, elt) in m.iter_mut().rev().enumerate() {\n-            assert_eq!((6 - i) as i32, *elt);\n-        }\n-        let mut n = LinkedList::new();\n-        assert!(n.iter_mut().rev().next().is_none());\n-        n.push_front(4);\n-        let mut it = n.iter_mut().rev();\n-        assert!(it.next().is_some());\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_send() {\n-        let n = list_from(&[1,2,3]);\n-        thread::spawn(move || {\n-            check_links(&n);\n-            let a: &[_] = &[&1,&2,&3];\n-            assert_eq!(a, n.iter().collect::<Vec<_>>());\n-        }).join().ok().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        let mut n = list_from(&[]);\n-        let mut m = list_from(&[]);\n-        assert!(n == m);\n-        n.push_front(1);\n-        assert!(n != m);\n-        m.push_back(1);\n-        assert!(n == m);\n-\n-        let n = list_from(&[2,3,4]);\n-        let m = list_from(&[1,2,3]);\n-        assert!(n != m);\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-      let mut x = LinkedList::new();\n-      let mut y = LinkedList::new();\n-\n-      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n-\n-      x.push_back(1);\n-      x.push_back(2);\n-      x.push_back(3);\n-\n-      y.push_front(3);\n-      y.push_front(2);\n-      y.push_front(1);\n-\n-      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let n = list_from(&[]);\n-        let m = list_from(&[1,2,3]);\n-        assert!(n < m);\n-        assert!(m > n);\n-        assert!(n <= n);\n-        assert!(n >= n);\n-    }\n-\n-    #[test]\n-    fn test_ord_nan() {\n-        let nan = 0.0f64/0.0;\n-        let n = list_from(&[nan]);\n-        let m = list_from(&[nan]);\n-        assert!(!(n < m));\n-        assert!(!(n > m));\n-        assert!(!(n <= m));\n-        assert!(!(n >= m));\n-\n-        let n = list_from(&[nan]);\n-        let one = list_from(&[1.0f64]);\n-        assert!(!(n < one));\n-        assert!(!(n > one));\n-        assert!(!(n <= one));\n-        assert!(!(n >= one));\n-\n-        let u = list_from(&[1.0f64,2.0,nan]);\n-        let v = list_from(&[1.0f64,2.0,3.0]);\n-        assert!(!(u < v));\n-        assert!(!(u > v));\n-        assert!(!(u <= v));\n-        assert!(!(u >= v));\n-\n-        let s = list_from(&[1.0f64,2.0,4.0,2.0]);\n-        let t = list_from(&[1.0f64,2.0,3.0,2.0]);\n-        assert!(!(s < t));\n-        assert!(s > one);\n-        assert!(!(s <= one));\n-        assert!(s >= one);\n-    }\n-\n-    #[test]\n-    fn test_fuzz() {\n-        for _ in 0..25 {\n-            fuzz_test(3);\n-            fuzz_test(16);\n-            fuzz_test(189);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let list: LinkedList<_> = (0..10).collect();\n-        assert_eq!(format!(\"{:?}\", list), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n-\n-        let list: LinkedList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n-        assert_eq!(format!(\"{:?}\", list), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n-    }\n-\n-    #[cfg(test)]\n-    fn fuzz_test(sz: i32) {\n-        let mut m: LinkedList<_> = LinkedList::new();\n-        let mut v = vec![];\n-        for i in 0..sz {\n-            check_links(&m);\n-            let r: u8 = rand::random();\n-            match r % 6 {\n-                0 => {\n-                    m.pop_back();\n-                    v.pop();\n-                }\n-                1 => {\n-                    if !v.is_empty() {\n-                        m.pop_front();\n-                        v.remove(0);\n-                    }\n-                }\n-                2 | 4 =>  {\n-                    m.push_front(-i);\n-                    v.insert(0, -i);\n-                }\n-                3 | 5 | _ => {\n-                    m.push_back(i);\n-                    v.push(i);\n-                }\n-            }\n-        }\n-\n-        check_links(&m);\n-\n-        let mut i = 0;\n-        for (a, &b) in m.into_iter().zip(v.iter()) {\n-            i += 1;\n-            assert_eq!(a, b);\n-        }\n-        assert_eq!(i, v.len());\n-    }\n-\n-    #[bench]\n-    fn bench_collect_into(b: &mut test::Bencher) {\n-        let v = &[0; 64];\n-        b.iter(|| {\n-            let _: LinkedList<_> = v.iter().cloned().collect();\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_push_front(b: &mut test::Bencher) {\n-        let mut m: LinkedList<_> = LinkedList::new();\n-        b.iter(|| {\n-            m.push_front(0);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_push_back(b: &mut test::Bencher) {\n-        let mut m: LinkedList<_> = LinkedList::new();\n-        b.iter(|| {\n-            m.push_back(0);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_push_back_pop_back(b: &mut test::Bencher) {\n-        let mut m: LinkedList<_> = LinkedList::new();\n-        b.iter(|| {\n-            m.push_back(0);\n-            m.pop_back();\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_push_front_pop_front(b: &mut test::Bencher) {\n-        let mut m: LinkedList<_> = LinkedList::new();\n-        b.iter(|| {\n-            m.push_front(0);\n-            m.pop_front();\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_iter(b: &mut test::Bencher) {\n-        let v = &[0; 128];\n-        let m: LinkedList<_> = v.iter().cloned().collect();\n-        b.iter(|| {\n-            assert!(m.iter().count() == 128);\n-        })\n-    }\n-    #[bench]\n-    fn bench_iter_mut(b: &mut test::Bencher) {\n-        let v = &[0; 128];\n-        let mut m: LinkedList<_> = v.iter().cloned().collect();\n-        b.iter(|| {\n-            assert!(m.iter_mut().count() == 128);\n-        })\n-    }\n-    #[bench]\n-    fn bench_iter_rev(b: &mut test::Bencher) {\n-        let v = &[0; 128];\n-        let m: LinkedList<_> = v.iter().cloned().collect();\n-        b.iter(|| {\n-            assert!(m.iter().rev().count() == 128);\n-        })\n-    }\n-    #[bench]\n-    fn bench_iter_mut_rev(b: &mut test::Bencher) {\n-        let v = &[0; 128];\n-        let mut m: LinkedList<_> = v.iter().cloned().collect();\n-        b.iter(|| {\n-            assert!(m.iter_mut().rev().count() == 128);\n-        })\n-    }\n-}"}, {"sha": "15b67376887c2073eee6fd51a2cb4649541efc07", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 0, "deletions": 1630, "changes": 1630, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -2339,1633 +2339,3 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n         old\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use alloc::boxed::Box;\n-    use core::cmp::Ordering::{Greater, Less, Equal};\n-    use core::prelude::{Some, None, Clone};\n-    use core::prelude::{Iterator, IteratorExt};\n-    use core::prelude::{AsSlice};\n-    use core::prelude::Ord;\n-    use core::default::Default;\n-    use core::mem;\n-    use std::iter::RandomAccessIterator;\n-    use std::rand::{Rng, thread_rng};\n-    use std::rc::Rc;\n-    use string::ToString;\n-    use vec::Vec;\n-    use super::{ElementSwaps, SliceConcatExt, SliceExt};\n-\n-    fn square(n: usize) -> usize { n * n }\n-\n-    fn is_odd(n: &usize) -> bool { *n % 2 == 1 }\n-\n-    #[test]\n-    fn test_from_fn() {\n-        // Test on-stack from_fn.\n-        let mut v: Vec<_> = (0..3).map(square).collect();\n-        {\n-            let v = v;\n-            assert_eq!(v.len(), 3);\n-            assert_eq!(v[0], 0);\n-            assert_eq!(v[1], 1);\n-            assert_eq!(v[2], 4);\n-        }\n-\n-        // Test on-heap from_fn.\n-        v = (0..5).map(square).collect();\n-        {\n-            let v = v;\n-            assert_eq!(v.len(), 5);\n-            assert_eq!(v[0], 0);\n-            assert_eq!(v[1], 1);\n-            assert_eq!(v[2], 4);\n-            assert_eq!(v[3], 9);\n-            assert_eq!(v[4], 16);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_elem() {\n-        // Test on-stack from_elem.\n-        let mut v = vec![10, 10];\n-        {\n-            let v = v;\n-            assert_eq!(v.len(), 2);\n-            assert_eq!(v[0], 10);\n-            assert_eq!(v[1], 10);\n-        }\n-\n-        // Test on-heap from_elem.\n-        v = vec![20; 6];\n-        {\n-            let v = v.as_slice();\n-            assert_eq!(v[0], 20);\n-            assert_eq!(v[1], 20);\n-            assert_eq!(v[2], 20);\n-            assert_eq!(v[3], 20);\n-            assert_eq!(v[4], 20);\n-            assert_eq!(v[5], 20);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        let xs: [i32; 0] = [];\n-        assert!(xs.is_empty());\n-        assert!(![0].is_empty());\n-    }\n-\n-    #[test]\n-    fn test_len_divzero() {\n-        type Z = [i8; 0];\n-        let v0 : &[Z] = &[];\n-        let v1 : &[Z] = &[[]];\n-        let v2 : &[Z] = &[[], []];\n-        assert_eq!(mem::size_of::<Z>(), 0);\n-        assert_eq!(v0.len(), 0);\n-        assert_eq!(v1.len(), 1);\n-        assert_eq!(v2.len(), 2);\n-    }\n-\n-    #[test]\n-    fn test_get() {\n-        let mut a = vec![11];\n-        assert_eq!(a.get(1), None);\n-        a = vec![11, 12];\n-        assert_eq!(a.get(1).unwrap(), &12);\n-        a = vec![11, 12, 13];\n-        assert_eq!(a.get(1).unwrap(), &12);\n-    }\n-\n-    #[test]\n-    fn test_first() {\n-        let mut a = vec![];\n-        assert_eq!(a.first(), None);\n-        a = vec![11];\n-        assert_eq!(a.first().unwrap(), &11);\n-        a = vec![11, 12];\n-        assert_eq!(a.first().unwrap(), &11);\n-    }\n-\n-    #[test]\n-    fn test_first_mut() {\n-        let mut a = vec![];\n-        assert_eq!(a.first_mut(), None);\n-        a = vec![11];\n-        assert_eq!(*a.first_mut().unwrap(), 11);\n-        a = vec![11, 12];\n-        assert_eq!(*a.first_mut().unwrap(), 11);\n-    }\n-\n-    #[test]\n-    fn test_tail() {\n-        let mut a = vec![11];\n-        let b: &[i32] = &[];\n-        assert_eq!(a.tail(), b);\n-        a = vec![11, 12];\n-        let b: &[i32] = &[12];\n-        assert_eq!(a.tail(), b);\n-    }\n-\n-    #[test]\n-    fn test_tail_mut() {\n-        let mut a = vec![11];\n-        let b: &mut [i32] = &mut [];\n-        assert!(a.tail_mut() == b);\n-        a = vec![11, 12];\n-        let b: &mut [_] = &mut [12];\n-        assert!(a.tail_mut() == b);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_tail_empty() {\n-        let a = Vec::<i32>::new();\n-        a.tail();\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_tail_mut_empty() {\n-        let mut a = Vec::<i32>::new();\n-        a.tail_mut();\n-    }\n-\n-    #[test]\n-    fn test_init() {\n-        let mut a = vec![11];\n-        let b: &[i32] = &[];\n-        assert_eq!(a.init(), b);\n-        a = vec![11, 12];\n-        let b: &[_] = &[11];\n-        assert_eq!(a.init(), b);\n-    }\n-\n-    #[test]\n-    fn test_init_mut() {\n-        let mut a = vec![11];\n-        let b: &mut [i32] = &mut [];\n-        assert!(a.init_mut() == b);\n-        a = vec![11, 12];\n-        let b: &mut [_] = &mut [11];\n-        assert!(a.init_mut() == b);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_init_empty() {\n-        let a = Vec::<i32>::new();\n-        a.init();\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_init_mut_empty() {\n-        let mut a = Vec::<i32>::new();\n-        a.init_mut();\n-    }\n-\n-    #[test]\n-    fn test_last() {\n-        let mut a = vec![];\n-        assert_eq!(a.last(), None);\n-        a = vec![11];\n-        assert_eq!(a.last().unwrap(), &11);\n-        a = vec![11, 12];\n-        assert_eq!(a.last().unwrap(), &12);\n-    }\n-\n-    #[test]\n-    fn test_last_mut() {\n-        let mut a = vec![];\n-        assert_eq!(a.last_mut(), None);\n-        a = vec![11];\n-        assert_eq!(*a.last_mut().unwrap(), 11);\n-        a = vec![11, 12];\n-        assert_eq!(*a.last_mut().unwrap(), 12);\n-    }\n-\n-    #[test]\n-    fn test_slice() {\n-        // Test fixed length vector.\n-        let vec_fixed = [1, 2, 3, 4];\n-        let v_a = vec_fixed[1..vec_fixed.len()].to_vec();\n-        assert_eq!(v_a.len(), 3);\n-\n-        assert_eq!(v_a[0], 2);\n-        assert_eq!(v_a[1], 3);\n-        assert_eq!(v_a[2], 4);\n-\n-        // Test on stack.\n-        let vec_stack: &[_] = &[1, 2, 3];\n-        let v_b = vec_stack[1..3].to_vec();\n-        assert_eq!(v_b.len(), 2);\n-\n-        assert_eq!(v_b[0], 2);\n-        assert_eq!(v_b[1], 3);\n-\n-        // Test `Box<[T]>`\n-        let vec_unique = vec![1, 2, 3, 4, 5, 6];\n-        let v_d = vec_unique[1..6].to_vec();\n-        assert_eq!(v_d.len(), 5);\n-\n-        assert_eq!(v_d[0], 2);\n-        assert_eq!(v_d[1], 3);\n-        assert_eq!(v_d[2], 4);\n-        assert_eq!(v_d[3], 5);\n-        assert_eq!(v_d[4], 6);\n-    }\n-\n-    #[test]\n-    fn test_slice_from() {\n-        let vec: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(&vec[..], vec);\n-        let b: &[_] = &[3, 4];\n-        assert_eq!(&vec[2..], b);\n-        let b: &[_] = &[];\n-        assert_eq!(&vec[4..], b);\n-    }\n-\n-    #[test]\n-    fn test_slice_to() {\n-        let vec: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(&vec[..4], vec);\n-        let b: &[_] = &[1, 2];\n-        assert_eq!(&vec[..2], b);\n-        let b: &[_] = &[];\n-        assert_eq!(&vec[..0], b);\n-    }\n-\n-\n-    #[test]\n-    fn test_pop() {\n-        let mut v = vec![5];\n-        let e = v.pop();\n-        assert_eq!(v.len(), 0);\n-        assert_eq!(e, Some(5));\n-        let f = v.pop();\n-        assert_eq!(f, None);\n-        let g = v.pop();\n-        assert_eq!(g, None);\n-    }\n-\n-    #[test]\n-    fn test_swap_remove() {\n-        let mut v = vec![1, 2, 3, 4, 5];\n-        let mut e = v.swap_remove(0);\n-        assert_eq!(e, 1);\n-        assert_eq!(v, [5, 2, 3, 4]);\n-        e = v.swap_remove(3);\n-        assert_eq!(e, 4);\n-        assert_eq!(v, [5, 2, 3]);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_swap_remove_fail() {\n-        let mut v = vec![1];\n-        let _ = v.swap_remove(0);\n-        let _ = v.swap_remove(0);\n-    }\n-\n-    #[test]\n-    fn test_swap_remove_noncopyable() {\n-        // Tests that we don't accidentally run destructors twice.\n-        let mut v: Vec<Box<_>> = Vec::new();\n-        v.push(box 0u8);\n-        v.push(box 0u8);\n-        v.push(box 0u8);\n-        let mut _e = v.swap_remove(0);\n-        assert_eq!(v.len(), 2);\n-        _e = v.swap_remove(1);\n-        assert_eq!(v.len(), 1);\n-        _e = v.swap_remove(0);\n-        assert_eq!(v.len(), 0);\n-    }\n-\n-    #[test]\n-    fn test_push() {\n-        // Test on-stack push().\n-        let mut v = vec![];\n-        v.push(1);\n-        assert_eq!(v.len(), 1);\n-        assert_eq!(v[0], 1);\n-\n-        // Test on-heap push().\n-        v.push(2);\n-        assert_eq!(v.len(), 2);\n-        assert_eq!(v[0], 1);\n-        assert_eq!(v[1], 2);\n-    }\n-\n-    #[test]\n-    fn test_truncate() {\n-        let mut v: Vec<Box<_>> = vec![box 6,box 5,box 4];\n-        v.truncate(1);\n-        let v = v;\n-        assert_eq!(v.len(), 1);\n-        assert_eq!(*(v[0]), 6);\n-        // If the unsafe block didn't drop things properly, we blow up here.\n-    }\n-\n-    #[test]\n-    fn test_clear() {\n-        let mut v: Vec<Box<_>> = vec![box 6,box 5,box 4];\n-        v.clear();\n-        assert_eq!(v.len(), 0);\n-        // If the unsafe block didn't drop things properly, we blow up here.\n-    }\n-\n-    #[test]\n-    fn test_dedup() {\n-        fn case(a: Vec<i32>, b: Vec<i32>) {\n-            let mut v = a;\n-            v.dedup();\n-            assert_eq!(v, b);\n-        }\n-        case(vec![], vec![]);\n-        case(vec![1], vec![1]);\n-        case(vec![1,1], vec![1]);\n-        case(vec![1,2,3], vec![1,2,3]);\n-        case(vec![1,1,2,3], vec![1,2,3]);\n-        case(vec![1,2,2,3], vec![1,2,3]);\n-        case(vec![1,2,3,3], vec![1,2,3]);\n-        case(vec![1,1,2,2,2,3,3], vec![1,2,3]);\n-    }\n-\n-    #[test]\n-    fn test_dedup_unique() {\n-        let mut v0: Vec<Box<_>> = vec![box 1, box 1, box 2, box 3];\n-        v0.dedup();\n-        let mut v1: Vec<Box<_>> = vec![box 1, box 2, box 2, box 3];\n-        v1.dedup();\n-        let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n-        v2.dedup();\n-        /*\n-         * If the boxed pointers were leaked or otherwise misused, valgrind\n-         * and/or rt should raise errors.\n-         */\n-    }\n-\n-    #[test]\n-    fn test_dedup_shared() {\n-        let mut v0: Vec<Box<_>> = vec![box 1, box 1, box 2, box 3];\n-        v0.dedup();\n-        let mut v1: Vec<Box<_>> = vec![box 1, box 2, box 2, box 3];\n-        v1.dedup();\n-        let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n-        v2.dedup();\n-        /*\n-         * If the pointers were leaked or otherwise misused, valgrind and/or\n-         * rt should raise errors.\n-         */\n-    }\n-\n-    #[test]\n-    fn test_retain() {\n-        let mut v = vec![1, 2, 3, 4, 5];\n-        v.retain(is_odd);\n-        assert_eq!(v, [1, 3, 5]);\n-    }\n-\n-    #[test]\n-    fn test_element_swaps() {\n-        let mut v = [1, 2, 3];\n-        for (i, (a, b)) in ElementSwaps::new(v.len()).enumerate() {\n-            v.swap(a, b);\n-            match i {\n-                0 => assert!(v == [1, 3, 2]),\n-                1 => assert!(v == [3, 1, 2]),\n-                2 => assert!(v == [3, 2, 1]),\n-                3 => assert!(v == [2, 3, 1]),\n-                4 => assert!(v == [2, 1, 3]),\n-                5 => assert!(v == [1, 2, 3]),\n-                _ => panic!(),\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_permutations() {\n-        {\n-            let v: [i32; 0] = [];\n-            let mut it = v.permutations();\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 1);\n-            assert_eq!(max_opt.unwrap(), 1);\n-            assert_eq!(it.next(), Some(v.to_vec()));\n-            assert_eq!(it.next(), None);\n-        }\n-        {\n-            let v = [\"Hello\".to_string()];\n-            let mut it = v.permutations();\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 1);\n-            assert_eq!(max_opt.unwrap(), 1);\n-            assert_eq!(it.next(), Some(v.to_vec()));\n-            assert_eq!(it.next(), None);\n-        }\n-        {\n-            let v = [1, 2, 3];\n-            let mut it = v.permutations();\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 3*2);\n-            assert_eq!(max_opt.unwrap(), 3*2);\n-            assert_eq!(it.next(), Some(vec![1,2,3]));\n-            assert_eq!(it.next(), Some(vec![1,3,2]));\n-            assert_eq!(it.next(), Some(vec![3,1,2]));\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 3);\n-            assert_eq!(max_opt.unwrap(), 3);\n-            assert_eq!(it.next(), Some(vec![3,2,1]));\n-            assert_eq!(it.next(), Some(vec![2,3,1]));\n-            assert_eq!(it.next(), Some(vec![2,1,3]));\n-            assert_eq!(it.next(), None);\n-        }\n-        {\n-            // check that we have N! permutations\n-            let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n-            let mut amt = 0;\n-            let mut it = v.permutations();\n-            let (min_size, max_opt) = it.size_hint();\n-            for _perm in it.by_ref() {\n-                amt += 1;\n-            }\n-            assert_eq!(amt, it.swaps.swaps_made);\n-            assert_eq!(amt, min_size);\n-            assert_eq!(amt, 2 * 3 * 4 * 5 * 6);\n-            assert_eq!(amt, max_opt.unwrap());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_lexicographic_permutations() {\n-        let v : &mut[_] = &mut[1, 2, 3, 4, 5];\n-        assert!(v.prev_permutation() == false);\n-        assert!(v.next_permutation());\n-        let b: &mut[_] = &mut[1, 2, 3, 5, 4];\n-        assert!(v == b);\n-        assert!(v.prev_permutation());\n-        let b: &mut[_] = &mut[1, 2, 3, 4, 5];\n-        assert!(v == b);\n-        assert!(v.next_permutation());\n-        assert!(v.next_permutation());\n-        let b: &mut[_] = &mut[1, 2, 4, 3, 5];\n-        assert!(v == b);\n-        assert!(v.next_permutation());\n-        let b: &mut[_] = &mut[1, 2, 4, 5, 3];\n-        assert!(v == b);\n-\n-        let v : &mut[_] = &mut[1, 0, 0, 0];\n-        assert!(v.next_permutation() == false);\n-        assert!(v.prev_permutation());\n-        let b: &mut[_] = &mut[0, 1, 0, 0];\n-        assert!(v == b);\n-        assert!(v.prev_permutation());\n-        let b: &mut[_] = &mut[0, 0, 1, 0];\n-        assert!(v == b);\n-        assert!(v.prev_permutation());\n-        let b: &mut[_] = &mut[0, 0, 0, 1];\n-        assert!(v == b);\n-        assert!(v.prev_permutation() == false);\n-    }\n-\n-    #[test]\n-    fn test_lexicographic_permutations_empty_and_short() {\n-        let empty : &mut[i32] = &mut[];\n-        assert!(empty.next_permutation() == false);\n-        let b: &mut[i32] = &mut[];\n-        assert!(empty == b);\n-        assert!(empty.prev_permutation() == false);\n-        assert!(empty == b);\n-\n-        let one_elem : &mut[_] = &mut[4];\n-        assert!(one_elem.prev_permutation() == false);\n-        let b: &mut[_] = &mut[4];\n-        assert!(one_elem == b);\n-        assert!(one_elem.next_permutation() == false);\n-        assert!(one_elem == b);\n-\n-        let two_elem : &mut[_] = &mut[1, 2];\n-        assert!(two_elem.prev_permutation() == false);\n-        let b : &mut[_] = &mut[1, 2];\n-        let c : &mut[_] = &mut[2, 1];\n-        assert!(two_elem == b);\n-        assert!(two_elem.next_permutation());\n-        assert!(two_elem == c);\n-        assert!(two_elem.next_permutation() == false);\n-        assert!(two_elem == c);\n-        assert!(two_elem.prev_permutation());\n-        assert!(two_elem == b);\n-        assert!(two_elem.prev_permutation() == false);\n-        assert!(two_elem == b);\n-    }\n-\n-    #[test]\n-    fn test_position_elem() {\n-        assert!([].position_elem(&1).is_none());\n-\n-        let v1 = vec![1, 2, 3, 3, 2, 5];\n-        assert_eq!(v1.position_elem(&1), Some(0));\n-        assert_eq!(v1.position_elem(&2), Some(1));\n-        assert_eq!(v1.position_elem(&5), Some(5));\n-        assert!(v1.position_elem(&4).is_none());\n-    }\n-\n-    #[test]\n-    fn test_binary_search() {\n-        assert_eq!([1,2,3,4,5].binary_search(&5).ok(), Some(4));\n-        assert_eq!([1,2,3,4,5].binary_search(&4).ok(), Some(3));\n-        assert_eq!([1,2,3,4,5].binary_search(&3).ok(), Some(2));\n-        assert_eq!([1,2,3,4,5].binary_search(&2).ok(), Some(1));\n-        assert_eq!([1,2,3,4,5].binary_search(&1).ok(), Some(0));\n-\n-        assert_eq!([2,4,6,8,10].binary_search(&1).ok(), None);\n-        assert_eq!([2,4,6,8,10].binary_search(&5).ok(), None);\n-        assert_eq!([2,4,6,8,10].binary_search(&4).ok(), Some(1));\n-        assert_eq!([2,4,6,8,10].binary_search(&10).ok(), Some(4));\n-\n-        assert_eq!([2,4,6,8].binary_search(&1).ok(), None);\n-        assert_eq!([2,4,6,8].binary_search(&5).ok(), None);\n-        assert_eq!([2,4,6,8].binary_search(&4).ok(), Some(1));\n-        assert_eq!([2,4,6,8].binary_search(&8).ok(), Some(3));\n-\n-        assert_eq!([2,4,6].binary_search(&1).ok(), None);\n-        assert_eq!([2,4,6].binary_search(&5).ok(), None);\n-        assert_eq!([2,4,6].binary_search(&4).ok(), Some(1));\n-        assert_eq!([2,4,6].binary_search(&6).ok(), Some(2));\n-\n-        assert_eq!([2,4].binary_search(&1).ok(), None);\n-        assert_eq!([2,4].binary_search(&5).ok(), None);\n-        assert_eq!([2,4].binary_search(&2).ok(), Some(0));\n-        assert_eq!([2,4].binary_search(&4).ok(), Some(1));\n-\n-        assert_eq!([2].binary_search(&1).ok(), None);\n-        assert_eq!([2].binary_search(&5).ok(), None);\n-        assert_eq!([2].binary_search(&2).ok(), Some(0));\n-\n-        assert_eq!([].binary_search(&1).ok(), None);\n-        assert_eq!([].binary_search(&5).ok(), None);\n-\n-        assert!([1,1,1,1,1].binary_search(&1).ok() != None);\n-        assert!([1,1,1,1,2].binary_search(&1).ok() != None);\n-        assert!([1,1,1,2,2].binary_search(&1).ok() != None);\n-        assert!([1,1,2,2,2].binary_search(&1).ok() != None);\n-        assert_eq!([1,2,2,2,2].binary_search(&1).ok(), Some(0));\n-\n-        assert_eq!([1,2,3,4,5].binary_search(&6).ok(), None);\n-        assert_eq!([1,2,3,4,5].binary_search(&0).ok(), None);\n-    }\n-\n-    #[test]\n-    fn test_reverse() {\n-        let mut v = vec![10, 20];\n-        assert_eq!(v[0], 10);\n-        assert_eq!(v[1], 20);\n-        v.reverse();\n-        assert_eq!(v[0], 20);\n-        assert_eq!(v[1], 10);\n-\n-        let mut v3 = Vec::<i32>::new();\n-        v3.reverse();\n-        assert!(v3.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_sort() {\n-        for len in 4..25 {\n-            for _ in 0..100 {\n-                let mut v: Vec<_> = thread_rng().gen_iter::<i32>().take(len).collect();\n-                let mut v1 = v.clone();\n-\n-                v.sort();\n-                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-\n-                v1.sort_by(|a, b| a.cmp(b));\n-                assert!(v1.windows(2).all(|w| w[0] <= w[1]));\n-\n-                v1.sort_by(|a, b| b.cmp(a));\n-                assert!(v1.windows(2).all(|w| w[0] >= w[1]));\n-            }\n-        }\n-\n-        // shouldn't panic\n-        let mut v: [i32; 0] = [];\n-        v.sort();\n-\n-        let mut v = [0xDEADBEEFu64];\n-        v.sort();\n-        assert!(v == [0xDEADBEEF]);\n-    }\n-\n-    #[test]\n-    fn test_sort_stability() {\n-        for len in 4..25 {\n-            for _ in 0..10 {\n-                let mut counts = [0; 10];\n-\n-                // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n-                // where the first item of each tuple is random, but\n-                // the second item represents which occurrence of that\n-                // number this element is, i.e. the second elements\n-                // will occur in sorted order.\n-                let mut v: Vec<_> = (0..len).map(|_| {\n-                        let n = thread_rng().gen::<usize>() % 10;\n-                        counts[n] += 1;\n-                        (n, counts[n])\n-                    }).collect();\n-\n-                // only sort on the first element, so an unstable sort\n-                // may mix up the counts.\n-                v.sort_by(|&(a,_), &(b,_)| a.cmp(&b));\n-\n-                // this comparison includes the count (the second item\n-                // of the tuple), so elements with equal first items\n-                // will need to be ordered with increasing\n-                // counts... i.e. exactly asserting that this sort is\n-                // stable.\n-                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_concat() {\n-        let v: [Vec<i32>; 0] = [];\n-        let c = v.concat();\n-        assert_eq!(c, []);\n-        let d = [vec![1], vec![2, 3]].concat();\n-        assert_eq!(d, [1, 2, 3]);\n-\n-        let v: &[&[_]] = &[&[1], &[2, 3]];\n-        assert_eq!(v.connect(&0), [1, 0, 2, 3]);\n-        let v: &[&[_]] = &[&[1], &[2], &[3]];\n-        assert_eq!(v.connect(&0), [1, 0, 2, 0, 3]);\n-    }\n-\n-    #[test]\n-    fn test_connect() {\n-        let v: [Vec<i32>; 0] = [];\n-        assert_eq!(v.connect(&0), []);\n-        assert_eq!([vec![1], vec![2, 3]].connect(&0), [1, 0, 2, 3]);\n-        assert_eq!([vec![1], vec![2], vec![3]].connect(&0), [1, 0, 2, 0, 3]);\n-\n-        let v: [&[_]; 2] = [&[1], &[2, 3]];\n-        assert_eq!(v.connect(&0), [1, 0, 2, 3]);\n-        let v: [&[_]; 3] = [&[1], &[2], &[3]];\n-        assert_eq!(v.connect(&0), [1, 0, 2, 0, 3]);\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        let mut a = vec![1, 2, 4];\n-        a.insert(2, 3);\n-        assert_eq!(a, [1, 2, 3, 4]);\n-\n-        let mut a = vec![1, 2, 3];\n-        a.insert(0, 0);\n-        assert_eq!(a, [0, 1, 2, 3]);\n-\n-        let mut a = vec![1, 2, 3];\n-        a.insert(3, 4);\n-        assert_eq!(a, [1, 2, 3, 4]);\n-\n-        let mut a = vec![];\n-        a.insert(0, 1);\n-        assert_eq!(a, [1]);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_insert_oob() {\n-        let mut a = vec![1, 2, 3];\n-        a.insert(4, 5);\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        let mut a = vec![1, 2, 3, 4];\n-\n-        assert_eq!(a.remove(2), 3);\n-        assert_eq!(a, [1, 2, 4]);\n-\n-        assert_eq!(a.remove(2), 4);\n-        assert_eq!(a, [1, 2]);\n-\n-        assert_eq!(a.remove(0), 1);\n-        assert_eq!(a, [2]);\n-\n-        assert_eq!(a.remove(0), 2);\n-        assert_eq!(a, []);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_remove_fail() {\n-        let mut a = vec![1];\n-        let _ = a.remove(0);\n-        let _ = a.remove(0);\n-    }\n-\n-    #[test]\n-    fn test_capacity() {\n-        let mut v = vec![0];\n-        v.reserve_exact(10);\n-        assert!(v.capacity() >= 11);\n-    }\n-\n-    #[test]\n-    fn test_slice_2() {\n-        let v = vec![1, 2, 3, 4, 5];\n-        let v = v.slice(1, 3);\n-        assert_eq!(v.len(), 2);\n-        assert_eq!(v[0], 2);\n-        assert_eq!(v[1], 3);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_permute_fail() {\n-        let v: [(Box<_>, Rc<_>); 4] =\n-            [(box 0, Rc::new(0)), (box 0, Rc::new(0)),\n-             (box 0, Rc::new(0)), (box 0, Rc::new(0))];\n-        let mut i = 0;\n-        for _ in v.permutations() {\n-            if i == 2 {\n-                panic!()\n-            }\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_total_ord() {\n-        let c = &[1, 2, 3];\n-        [1, 2, 3, 4][..].cmp(c) == Greater;\n-        let c = &[1, 2, 3, 4];\n-        [1, 2, 3][..].cmp(c) == Less;\n-        let c = &[1, 2, 3, 6];\n-        [1, 2, 3, 4][..].cmp(c) == Equal;\n-        let c = &[1, 2, 3, 4, 5, 6];\n-        [1, 2, 3, 4, 5, 5, 5, 5][..].cmp(c) == Less;\n-        let c = &[1, 2, 3, 4];\n-        [2, 2][..].cmp(c) == Greater;\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let xs = [1, 2, 5, 10, 11];\n-        let mut it = xs.iter();\n-        assert_eq!(it.size_hint(), (5, Some(5)));\n-        assert_eq!(it.next().unwrap(), &1);\n-        assert_eq!(it.size_hint(), (4, Some(4)));\n-        assert_eq!(it.next().unwrap(), &2);\n-        assert_eq!(it.size_hint(), (3, Some(3)));\n-        assert_eq!(it.next().unwrap(), &5);\n-        assert_eq!(it.size_hint(), (2, Some(2)));\n-        assert_eq!(it.next().unwrap(), &10);\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert_eq!(it.next().unwrap(), &11);\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_random_access_iterator() {\n-        let xs = [1, 2, 5, 10, 11];\n-        let mut it = xs.iter();\n-\n-        assert_eq!(it.indexable(), 5);\n-        assert_eq!(it.idx(0).unwrap(), &1);\n-        assert_eq!(it.idx(2).unwrap(), &5);\n-        assert_eq!(it.idx(4).unwrap(), &11);\n-        assert!(it.idx(5).is_none());\n-\n-        assert_eq!(it.next().unwrap(), &1);\n-        assert_eq!(it.indexable(), 4);\n-        assert_eq!(it.idx(0).unwrap(), &2);\n-        assert_eq!(it.idx(3).unwrap(), &11);\n-        assert!(it.idx(4).is_none());\n-\n-        assert_eq!(it.next().unwrap(), &2);\n-        assert_eq!(it.indexable(), 3);\n-        assert_eq!(it.idx(1).unwrap(), &10);\n-        assert!(it.idx(3).is_none());\n-\n-        assert_eq!(it.next().unwrap(), &5);\n-        assert_eq!(it.indexable(), 2);\n-        assert_eq!(it.idx(1).unwrap(), &11);\n-\n-        assert_eq!(it.next().unwrap(), &10);\n-        assert_eq!(it.indexable(), 1);\n-        assert_eq!(it.idx(0).unwrap(), &11);\n-        assert!(it.idx(1).is_none());\n-\n-        assert_eq!(it.next().unwrap(), &11);\n-        assert_eq!(it.indexable(), 0);\n-        assert!(it.idx(0).is_none());\n-\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_iter_size_hints() {\n-        let mut xs = [1, 2, 5, 10, 11];\n-        assert_eq!(xs.iter().size_hint(), (5, Some(5)));\n-        assert_eq!(xs.iter_mut().size_hint(), (5, Some(5)));\n-    }\n-\n-    #[test]\n-    fn test_iter_clone() {\n-        let xs = [1, 2, 5];\n-        let mut it = xs.iter();\n-        it.next();\n-        let mut jt = it.clone();\n-        assert_eq!(it.next(), jt.next());\n-        assert_eq!(it.next(), jt.next());\n-        assert_eq!(it.next(), jt.next());\n-    }\n-\n-    #[test]\n-    fn test_mut_iterator() {\n-        let mut xs = [1, 2, 3, 4, 5];\n-        for x in &mut xs {\n-            *x += 1;\n-        }\n-        assert!(xs == [2, 3, 4, 5, 6])\n-    }\n-\n-    #[test]\n-    fn test_rev_iterator() {\n-\n-        let xs = [1, 2, 5, 10, 11];\n-        let ys = [11, 10, 5, 2, 1];\n-        let mut i = 0;\n-        for &x in xs.iter().rev() {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, 5);\n-    }\n-\n-    #[test]\n-    fn test_mut_rev_iterator() {\n-        let mut xs = [1, 2, 3, 4, 5];\n-        for (i,x) in xs.iter_mut().rev().enumerate() {\n-            *x += i;\n-        }\n-        assert!(xs == [5, 5, 5, 5, 5])\n-    }\n-\n-    #[test]\n-    fn test_move_iterator() {\n-        let xs = vec![1,2,3,4,5];\n-        assert_eq!(xs.into_iter().fold(0, |a: usize, b: usize| 10*a + b), 12345);\n-    }\n-\n-    #[test]\n-    fn test_move_rev_iterator() {\n-        let xs = vec![1,2,3,4,5];\n-        assert_eq!(xs.into_iter().rev().fold(0, |a: usize, b: usize| 10*a + b), 54321);\n-    }\n-\n-    #[test]\n-    fn test_splitator() {\n-        let xs = &[1,2,3,4,5];\n-\n-        let splits: &[&[_]] = &[&[1], &[3], &[5]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&[_]] = &[&[], &[2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&[_]] = &[&[1,2,3,4], &[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&[_]] = &[&[], &[], &[], &[], &[], &[]];\n-        assert_eq!(xs.split(|_| true).collect::<Vec<&[i32]>>(),\n-                   splits);\n-\n-        let xs: &[i32] = &[];\n-        let splits: &[&[i32]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n-    }\n-\n-    #[test]\n-    fn test_splitnator() {\n-        let xs = &[1,2,3,4,5];\n-\n-        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&[_]] = &[&[1], &[3,4,5]];\n-        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&[_]] = &[&[], &[], &[], &[4,5]];\n-        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<_>>(),\n-                   splits);\n-\n-        let xs: &[i32] = &[];\n-        let splits: &[&[i32]] = &[&[]];\n-        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<_>>(), splits);\n-    }\n-\n-    #[test]\n-    fn test_splitnator_mut() {\n-        let xs = &mut [1,2,3,4,5];\n-\n-        let splits: &[&mut[_]] = &[&mut [1,2,3,4,5]];\n-        assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&mut[_]] = &[&mut [1], &mut [3,4,5]];\n-        assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&mut[_]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n-        assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<_>>(),\n-                   splits);\n-\n-        let xs: &mut [i32] = &mut [];\n-        let splits: &[&mut[i32]] = &[&mut []];\n-        assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<_>>(),\n-                   splits);\n-    }\n-\n-    #[test]\n-    fn test_rsplitator() {\n-        let xs = &[1,2,3,4,5];\n-\n-        let splits: &[&[_]] = &[&[5], &[3], &[1]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&[_]] = &[&[2,3,4,5], &[]];\n-        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&[_]] = &[&[], &[1,2,3,4]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<_>>(),\n-                   splits);\n-\n-        let xs: &[i32] = &[];\n-        let splits: &[&[i32]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[i32]>>(), splits);\n-    }\n-\n-    #[test]\n-    fn test_rsplitnator() {\n-        let xs = &[1,2,3,4,5];\n-\n-        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&[_]] = &[&[5], &[1,2,3]];\n-        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-                   splits);\n-        let splits: &[&[_]] = &[&[], &[], &[], &[1,2]];\n-        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<_>>(),\n-                   splits);\n-\n-        let xs: &[i32]  = &[];\n-        let splits: &[&[i32]] = &[&[]];\n-        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n-    }\n-\n-    #[test]\n-    fn test_windowsator() {\n-        let v = &[1,2,3,4];\n-\n-        let wins: &[&[_]] = &[&[1,2], &[2,3], &[3,4]];\n-        assert_eq!(v.windows(2).collect::<Vec<_>>(), wins);\n-\n-        let wins: &[&[_]] = &[&[1,2,3], &[2,3,4]];\n-        assert_eq!(v.windows(3).collect::<Vec<_>>(), wins);\n-        assert!(v.windows(6).next().is_none());\n-\n-        let wins: &[&[_]] = &[&[3,4], &[2,3], &[1,2]];\n-        assert_eq!(v.windows(2).rev().collect::<Vec<&[_]>>(), wins);\n-        let mut it = v.windows(2);\n-        assert_eq!(it.indexable(), 3);\n-        let win: &[_] = &[1,2];\n-        assert_eq!(it.idx(0).unwrap(), win);\n-        let win: &[_] = &[2,3];\n-        assert_eq!(it.idx(1).unwrap(), win);\n-        let win: &[_] = &[3,4];\n-        assert_eq!(it.idx(2).unwrap(), win);\n-        assert_eq!(it.idx(3), None);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_windowsator_0() {\n-        let v = &[1,2,3,4];\n-        let _it = v.windows(0);\n-    }\n-\n-    #[test]\n-    fn test_chunksator() {\n-        use core::iter::ExactSizeIterator;\n-\n-        let v = &[1,2,3,4,5];\n-\n-        assert_eq!(v.chunks(2).len(), 3);\n-\n-        let chunks: &[&[_]] = &[&[1,2], &[3,4], &[5]];\n-        assert_eq!(v.chunks(2).collect::<Vec<_>>(), chunks);\n-        let chunks: &[&[_]] = &[&[1,2,3], &[4,5]];\n-        assert_eq!(v.chunks(3).collect::<Vec<_>>(), chunks);\n-        let chunks: &[&[_]] = &[&[1,2,3,4,5]];\n-        assert_eq!(v.chunks(6).collect::<Vec<_>>(), chunks);\n-\n-        let chunks: &[&[_]] = &[&[5], &[3,4], &[1,2]];\n-        assert_eq!(v.chunks(2).rev().collect::<Vec<_>>(), chunks);\n-        let mut it = v.chunks(2);\n-        assert_eq!(it.indexable(), 3);\n-\n-        let chunk: &[_] = &[1,2];\n-        assert_eq!(it.idx(0).unwrap(), chunk);\n-        let chunk: &[_] = &[3,4];\n-        assert_eq!(it.idx(1).unwrap(), chunk);\n-        let chunk: &[_] = &[5];\n-        assert_eq!(it.idx(2).unwrap(), chunk);\n-        assert_eq!(it.idx(3), None);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_chunksator_0() {\n-        let v = &[1,2,3,4];\n-        let _it = v.chunks(0);\n-    }\n-\n-    #[test]\n-    fn test_move_from() {\n-        let mut a = [1,2,3,4,5];\n-        let b = vec![6,7,8];\n-        assert_eq!(a.move_from(b, 0, 3), 3);\n-        assert!(a == [6,7,8,4,5]);\n-        let mut a = [7,2,8,1];\n-        let b = vec![3,1,4,1,5,9];\n-        assert_eq!(a.move_from(b, 0, 6), 4);\n-        assert!(a == [3,1,4,1]);\n-        let mut a = [1,2,3,4];\n-        let b = vec![5,6,7,8,9,0];\n-        assert_eq!(a.move_from(b, 2, 3), 1);\n-        assert!(a == [7,2,3,4]);\n-        let mut a = [1,2,3,4,5];\n-        let b = vec![5,6,7,8,9,0];\n-        assert_eq!(a[2..4].move_from(b,1,6), 2);\n-        assert!(a == [1,2,6,7,5]);\n-    }\n-\n-    #[test]\n-    fn test_reverse_part() {\n-        let mut values = [1,2,3,4,5];\n-        values[1..4].reverse();\n-        assert!(values == [1,4,3,2,5]);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        macro_rules! test_show_vec {\n-            ($x:expr, $x_str:expr) => ({\n-                let (x, x_str) = ($x, $x_str);\n-                assert_eq!(format!(\"{:?}\", x), x_str);\n-                assert_eq!(format!(\"{:?}\", x), x_str);\n-            })\n-        }\n-        let empty = Vec::<i32>::new();\n-        test_show_vec!(empty, \"[]\");\n-        test_show_vec!(vec![1], \"[1]\");\n-        test_show_vec!(vec![1, 2, 3], \"[1, 2, 3]\");\n-        test_show_vec!(vec![vec![], vec![1], vec![1, 1]],\n-                       \"[[], [1], [1, 1]]\");\n-\n-        let empty_mut: &mut [i32] = &mut[];\n-        test_show_vec!(empty_mut, \"[]\");\n-        let v = &mut[1];\n-        test_show_vec!(v, \"[1]\");\n-        let v = &mut[1, 2, 3];\n-        test_show_vec!(v, \"[1, 2, 3]\");\n-        let v: &mut[&mut[_]] = &mut[&mut[], &mut[1], &mut[1, 1]];\n-        test_show_vec!(v, \"[[], [1], [1, 1]]\");\n-    }\n-\n-    #[test]\n-    fn test_vec_default() {\n-        macro_rules! t {\n-            ($ty:ty) => {{\n-                let v: $ty = Default::default();\n-                assert!(v.is_empty());\n-            }}\n-        }\n-\n-        t!(&[i32]);\n-        t!(Vec<i32>);\n-    }\n-\n-    #[test]\n-    fn test_bytes_set_memory() {\n-        use slice::bytes::MutableByteVector;\n-        let mut values = [1,2,3,4,5];\n-        values[0..5].set_memory(0xAB);\n-        assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n-        values[2..4].set_memory(0xFF);\n-        assert!(values == [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_overflow_does_not_cause_segfault() {\n-        let mut v = vec![];\n-        v.reserve_exact(-1);\n-        v.push(1);\n-        v.push(2);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_overflow_does_not_cause_segfault_managed() {\n-        let mut v = vec![Rc::new(1)];\n-        v.reserve_exact(-1);\n-        v.push(Rc::new(2));\n-    }\n-\n-    #[test]\n-    fn test_mut_split_at() {\n-        let mut values = [1u8,2,3,4,5];\n-        {\n-            let (left, right) = values.split_at_mut(2);\n-            {\n-                let left: &[_] = left;\n-                assert!(left[..left.len()] == [1, 2]);\n-            }\n-            for p in left {\n-                *p += 1;\n-            }\n-\n-            {\n-                let right: &[_] = right;\n-                assert!(right[..right.len()] == [3, 4, 5]);\n-            }\n-            for p in right {\n-                *p += 2;\n-            }\n-        }\n-\n-        assert!(values == [2, 3, 5, 6, 7]);\n-    }\n-\n-    #[derive(Clone, PartialEq)]\n-    struct Foo;\n-\n-    #[test]\n-    fn test_iter_zero_sized() {\n-        let mut v = vec![Foo, Foo, Foo];\n-        assert_eq!(v.len(), 3);\n-        let mut cnt = 0;\n-\n-        for f in &v {\n-            assert!(*f == Foo);\n-            cnt += 1;\n-        }\n-        assert_eq!(cnt, 3);\n-\n-        for f in &v[1..3] {\n-            assert!(*f == Foo);\n-            cnt += 1;\n-        }\n-        assert_eq!(cnt, 5);\n-\n-        for f in &mut v {\n-            assert!(*f == Foo);\n-            cnt += 1;\n-        }\n-        assert_eq!(cnt, 8);\n-\n-        for f in v {\n-            assert!(f == Foo);\n-            cnt += 1;\n-        }\n-        assert_eq!(cnt, 11);\n-\n-        let xs: [Foo; 3] = [Foo, Foo, Foo];\n-        cnt = 0;\n-        for f in &xs {\n-            assert!(*f == Foo);\n-            cnt += 1;\n-        }\n-        assert!(cnt == 3);\n-    }\n-\n-    #[test]\n-    fn test_shrink_to_fit() {\n-        let mut xs = vec![0, 1, 2, 3];\n-        for i in 4..100 {\n-            xs.push(i)\n-        }\n-        assert_eq!(xs.capacity(), 128);\n-        xs.shrink_to_fit();\n-        assert_eq!(xs.capacity(), 100);\n-        assert_eq!(xs, (0..100).collect::<Vec<_>>());\n-    }\n-\n-    #[test]\n-    fn test_starts_with() {\n-        assert!(b\"foobar\".starts_with(b\"foo\"));\n-        assert!(!b\"foobar\".starts_with(b\"oob\"));\n-        assert!(!b\"foobar\".starts_with(b\"bar\"));\n-        assert!(!b\"foo\".starts_with(b\"foobar\"));\n-        assert!(!b\"bar\".starts_with(b\"foobar\"));\n-        assert!(b\"foobar\".starts_with(b\"foobar\"));\n-        let empty: &[u8] = &[];\n-        assert!(empty.starts_with(empty));\n-        assert!(!empty.starts_with(b\"foo\"));\n-        assert!(b\"foobar\".starts_with(empty));\n-    }\n-\n-    #[test]\n-    fn test_ends_with() {\n-        assert!(b\"foobar\".ends_with(b\"bar\"));\n-        assert!(!b\"foobar\".ends_with(b\"oba\"));\n-        assert!(!b\"foobar\".ends_with(b\"foo\"));\n-        assert!(!b\"foo\".ends_with(b\"foobar\"));\n-        assert!(!b\"bar\".ends_with(b\"foobar\"));\n-        assert!(b\"foobar\".ends_with(b\"foobar\"));\n-        let empty: &[u8] = &[];\n-        assert!(empty.ends_with(empty));\n-        assert!(!empty.ends_with(b\"foo\"));\n-        assert!(b\"foobar\".ends_with(empty));\n-    }\n-\n-    #[test]\n-    fn test_mut_splitator() {\n-        let mut xs = [0,1,0,2,3,0,0,4,5,0];\n-        assert_eq!(xs.split_mut(|x| *x == 0).count(), 6);\n-        for slice in xs.split_mut(|x| *x == 0) {\n-            slice.reverse();\n-        }\n-        assert!(xs == [0,1,0,3,2,0,0,5,4,0]);\n-\n-        let mut xs = [0,1,0,2,3,0,0,4,5,0,6,7];\n-        for slice in xs.split_mut(|x| *x == 0).take(5) {\n-            slice.reverse();\n-        }\n-        assert!(xs == [0,1,0,3,2,0,0,5,4,0,6,7]);\n-    }\n-\n-    #[test]\n-    fn test_mut_splitator_rev() {\n-        let mut xs = [1,2,0,3,4,0,0,5,6,0];\n-        for slice in xs.split_mut(|x| *x == 0).rev().take(4) {\n-            slice.reverse();\n-        }\n-        assert!(xs == [1,2,0,4,3,0,0,6,5,0]);\n-    }\n-\n-    #[test]\n-    fn test_get_mut() {\n-        let mut v = [0,1,2];\n-        assert_eq!(v.get_mut(3), None);\n-        v.get_mut(1).map(|e| *e = 7);\n-        assert_eq!(v[1], 7);\n-        let mut x = 2;\n-        assert_eq!(v.get_mut(2), Some(&mut x));\n-    }\n-\n-    #[test]\n-    fn test_mut_chunks() {\n-        use core::iter::ExactSizeIterator;\n-\n-        let mut v = [0, 1, 2, 3, 4, 5, 6];\n-        assert_eq!(v.chunks_mut(2).len(), 4);\n-        for (i, chunk) in v.chunks_mut(3).enumerate() {\n-            for x in chunk {\n-                *x = i as u8;\n-            }\n-        }\n-        let result = [0, 0, 0, 1, 1, 1, 2];\n-        assert!(v == result);\n-    }\n-\n-    #[test]\n-    fn test_mut_chunks_rev() {\n-        let mut v = [0, 1, 2, 3, 4, 5, 6];\n-        for (i, chunk) in v.chunks_mut(3).rev().enumerate() {\n-            for x in chunk {\n-                *x = i as u8;\n-            }\n-        }\n-        let result = [2, 2, 2, 1, 1, 1, 0];\n-        assert!(v == result);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_mut_chunks_0() {\n-        let mut v = [1, 2, 3, 4];\n-        let _it = v.chunks_mut(0);\n-    }\n-\n-    #[test]\n-    fn test_mut_last() {\n-        let mut x = [1, 2, 3, 4, 5];\n-        let h = x.last_mut();\n-        assert_eq!(*h.unwrap(), 5);\n-\n-        let y: &mut [i32] = &mut [];\n-        assert!(y.last_mut().is_none());\n-    }\n-\n-    #[test]\n-    fn test_to_vec() {\n-        let xs: Box<_> = box [1, 2, 3];\n-        let ys = xs.to_vec();\n-        assert_eq!(ys, [1, 2, 3]);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    use prelude::*;\n-    use core::mem;\n-    use core::ptr;\n-    use core::iter::repeat;\n-    use std::rand::{weak_rng, Rng};\n-    use test::{Bencher, black_box};\n-\n-    #[bench]\n-    fn iterator(b: &mut Bencher) {\n-        // peculiar numbers to stop LLVM from optimising the summation\n-        // out.\n-        let v: Vec<_> = (0..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect();\n-\n-        b.iter(|| {\n-            let mut sum = 0;\n-            for x in &v {\n-                sum += *x;\n-            }\n-            // sum == 11806, to stop dead code elimination.\n-            if sum == 0 {panic!()}\n-        })\n-    }\n-\n-    #[bench]\n-    fn mut_iterator(b: &mut Bencher) {\n-        let mut v: Vec<_> = repeat(0).take(100).collect();\n-\n-        b.iter(|| {\n-            let mut i = 0;\n-            for x in &mut v {\n-                *x = i;\n-                i += 1;\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn concat(b: &mut Bencher) {\n-        let xss: Vec<Vec<i32>> =\n-            (0..100).map(|i| (0..i).collect()).collect();\n-        b.iter(|| {\n-            xss.concat();\n-        });\n-    }\n-\n-    #[bench]\n-    fn connect(b: &mut Bencher) {\n-        let xss: Vec<Vec<i32>> =\n-            (0..100).map(|i| (0..i).collect()).collect();\n-        b.iter(|| {\n-            xss.connect(&0)\n-        });\n-    }\n-\n-    #[bench]\n-    fn push(b: &mut Bencher) {\n-        let mut vec = Vec::<i32>::new();\n-        b.iter(|| {\n-            vec.push(0);\n-            black_box(&vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn starts_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| {\n-            vec.starts_with(&vec)\n-        })\n-    }\n-\n-    #[bench]\n-    fn starts_with_single_element(b: &mut Bencher) {\n-        let vec: Vec<_> = vec![0];\n-        b.iter(|| {\n-            vec.starts_with(&vec)\n-        })\n-    }\n-\n-    #[bench]\n-    fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        let mut match_vec: Vec<_> = (0..99).collect();\n-        match_vec.push(0);\n-        b.iter(|| {\n-            vec.starts_with(&match_vec)\n-        })\n-    }\n-\n-    #[bench]\n-    fn ends_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| {\n-            vec.ends_with(&vec)\n-        })\n-    }\n-\n-    #[bench]\n-    fn ends_with_single_element(b: &mut Bencher) {\n-        let vec: Vec<_> = vec![0];\n-        b.iter(|| {\n-            vec.ends_with(&vec)\n-        })\n-    }\n-\n-    #[bench]\n-    fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        let mut match_vec: Vec<_> = (0..100).collect();\n-        match_vec[0] = 200;\n-        b.iter(|| {\n-            vec.starts_with(&match_vec)\n-        })\n-    }\n-\n-    #[bench]\n-    fn contains_last_element(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| {\n-            vec.contains(&99)\n-        })\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_from_elem(b: &mut Bencher) {\n-        b.iter(|| {\n-            repeat(0u8).take(1024).collect::<Vec<_>>()\n-        });\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_set_memory(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut v = Vec::<u8>::with_capacity(1024);\n-            unsafe {\n-                let vp = v.as_mut_ptr();\n-                ptr::set_memory(vp, 0, 1024);\n-                v.set_len(1024);\n-            }\n-            v\n-        });\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_loop_set(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut v = Vec::<u8>::with_capacity(1024);\n-            unsafe {\n-                v.set_len(1024);\n-            }\n-            for i in 0..1024 {\n-                v[i] = 0;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_mut_iter(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut v = Vec::<u8>::with_capacity(1024);\n-            unsafe {\n-                v.set_len(1024);\n-            }\n-            for x in &mut v {\n-                *x = 0;\n-            }\n-            v\n-        });\n-    }\n-\n-    #[bench]\n-    fn random_inserts(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n-        b.iter(|| {\n-            let mut v: Vec<_> = repeat((0, 0)).take(30).collect();\n-            for _ in 0..100 {\n-                let l = v.len();\n-                v.insert(rng.gen::<usize>() % (l + 1),\n-                         (1, 1));\n-            }\n-        })\n-    }\n-    #[bench]\n-    fn random_removes(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n-        b.iter(|| {\n-            let mut v: Vec<_> = repeat((0, 0)).take(130).collect();\n-            for _ in 0..100 {\n-                let l = v.len();\n-                v.remove(rng.gen::<usize>() % l);\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn sort_random_small(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n-        b.iter(|| {\n-            let mut v: Vec<_> = rng.gen_iter::<u64>().take(5).collect();\n-            v.sort();\n-        });\n-        b.bytes = 5 * mem::size_of::<u64>() as u64;\n-    }\n-\n-    #[bench]\n-    fn sort_random_medium(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n-        b.iter(|| {\n-            let mut v: Vec<_> = rng.gen_iter::<u64>().take(100).collect();\n-            v.sort();\n-        });\n-        b.bytes = 100 * mem::size_of::<u64>() as u64;\n-    }\n-\n-    #[bench]\n-    fn sort_random_large(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n-        b.iter(|| {\n-            let mut v: Vec<_> = rng.gen_iter::<u64>().take(10000).collect();\n-            v.sort();\n-        });\n-        b.bytes = 10000 * mem::size_of::<u64>() as u64;\n-    }\n-\n-    #[bench]\n-    fn sort_sorted(b: &mut Bencher) {\n-        let mut v: Vec<_> = (0..10000).collect();\n-        b.iter(|| {\n-            v.sort();\n-        });\n-        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n-    }\n-\n-    type BigSortable = (u64, u64, u64, u64);\n-\n-    #[bench]\n-    fn sort_big_random_small(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n-        b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>().take(5)\n-                           .collect::<Vec<BigSortable>>();\n-            v.sort();\n-        });\n-        b.bytes = 5 * mem::size_of::<BigSortable>() as u64;\n-    }\n-\n-    #[bench]\n-    fn sort_big_random_medium(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n-        b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>().take(100)\n-                           .collect::<Vec<BigSortable>>();\n-            v.sort();\n-        });\n-        b.bytes = 100 * mem::size_of::<BigSortable>() as u64;\n-    }\n-\n-    #[bench]\n-    fn sort_big_random_large(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n-        b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>().take(10000)\n-                           .collect::<Vec<BigSortable>>();\n-            v.sort();\n-        });\n-        b.bytes = 10000 * mem::size_of::<BigSortable>() as u64;\n-    }\n-\n-    #[bench]\n-    fn sort_big_sorted(b: &mut Bencher) {\n-        let mut v: Vec<BigSortable> = (0..10000).map(|i| (i, i, i, i)).collect();\n-        b.iter(|| {\n-            v.sort();\n-        });\n-        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n-    }\n-}"}, {"sha": "fc93b0b75a7ab9e2a3e561b49526e055fc2c198a", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 0, "deletions": 1665, "changes": 1665, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -2690,1668 +2690,3 @@ impl str {\n         return s;\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-\n-    use core::iter::AdditiveIterator;\n-    use super::from_utf8;\n-    use super::Utf8Error;\n-\n-    #[test]\n-    fn test_le() {\n-        assert!(\"\" <= \"\");\n-        assert!(\"\" <= \"foo\");\n-        assert!(\"foo\" <= \"foo\");\n-        assert!(\"foo\" != \"bar\");\n-    }\n-\n-    #[test]\n-    fn test_len() {\n-        assert_eq!(\"\".len(), 0);\n-        assert_eq!(\"hello world\".len(), 11);\n-        assert_eq!(\"\\x63\".len(), 1);\n-        assert_eq!(\"\\u{a2}\".len(), 2);\n-        assert_eq!(\"\\u{3c0}\".len(), 2);\n-        assert_eq!(\"\\u{2620}\".len(), 3);\n-        assert_eq!(\"\\u{1d11e}\".len(), 4);\n-\n-        assert_eq!(\"\".chars().count(), 0);\n-        assert_eq!(\"hello world\".chars().count(), 11);\n-        assert_eq!(\"\\x63\".chars().count(), 1);\n-        assert_eq!(\"\\u{a2}\".chars().count(), 1);\n-        assert_eq!(\"\\u{3c0}\".chars().count(), 1);\n-        assert_eq!(\"\\u{2620}\".chars().count(), 1);\n-        assert_eq!(\"\\u{1d11e}\".chars().count(), 1);\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().count(), 19);\n-\n-        assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(false), 10);\n-        assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(true), 10);\n-        assert_eq!(\"\\0\\0\\0\\0\\0\".width(false), 0);\n-        assert_eq!(\"\\0\\0\\0\\0\\0\".width(true), 0);\n-        assert_eq!(\"\".width(false), 0);\n-        assert_eq!(\"\".width(true), 0);\n-        assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(false), 4);\n-        assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(true), 8);\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        assert_eq!(\"hello\".find('l'), Some(2));\n-        assert_eq!(\"hello\".find(|c:char| c == 'o'), Some(4));\n-        assert!(\"hello\".find('x').is_none());\n-        assert!(\"hello\".find(|c:char| c == 'x').is_none());\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find('\u534e'), Some(30));\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find(|c: char| c == '\u534e'), Some(30));\n-    }\n-\n-    #[test]\n-    fn test_rfind() {\n-        assert_eq!(\"hello\".rfind('l'), Some(3));\n-        assert_eq!(\"hello\".rfind(|c:char| c == 'o'), Some(4));\n-        assert!(\"hello\".rfind('x').is_none());\n-        assert!(\"hello\".rfind(|c:char| c == 'x').is_none());\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind('\u534e'), Some(30));\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|c: char| c == '\u534e'), Some(30));\n-    }\n-\n-    #[test]\n-    fn test_collect() {\n-        let empty = String::from_str(\"\");\n-        let s: String = empty.chars().collect();\n-        assert_eq!(empty, s);\n-        let data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n-        let s: String = data.chars().collect();\n-        assert_eq!(data, s);\n-    }\n-\n-    #[test]\n-    fn test_into_bytes() {\n-        let data = String::from_str(\"asdf\");\n-        let buf = data.into_bytes();\n-        assert_eq!(b\"asdf\", buf);\n-    }\n-\n-    #[test]\n-    fn test_find_str() {\n-        // byte positions\n-        assert_eq!(\"\".find_str(\"\"), Some(0));\n-        assert!(\"banana\".find_str(\"apple pie\").is_none());\n-\n-        let data = \"abcabc\";\n-        assert_eq!(data[0..6].find_str(\"ab\"), Some(0));\n-        assert_eq!(data[2..6].find_str(\"ab\"), Some(3 - 2));\n-        assert!(data[2..4].find_str(\"ab\").is_none());\n-\n-        let string = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let mut data = String::from_str(string);\n-        data.push_str(string);\n-        assert!(data.find_str(\"\u0e44\u0e17\u534e\").is_none());\n-        assert_eq!(data[0..43].find_str(\"\"), Some(0));\n-        assert_eq!(data[6..43].find_str(\"\"), Some(6 - 6));\n-\n-        assert_eq!(data[0..43].find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0));\n-        assert_eq!(data[0..43].find_str(\"\u0e17\u0e28\u0e44\"), Some(12));\n-        assert_eq!(data[0..43].find_str(\"\u0e22\u4e2d\"), Some(24));\n-        assert_eq!(data[0..43].find_str(\"i\u1ec7t\"), Some(34));\n-        assert_eq!(data[0..43].find_str(\"Nam\"), Some(40));\n-\n-        assert_eq!(data[43..86].find_str(\"\u0e1b\u0e23\u0e30\"), Some(43 - 43));\n-        assert_eq!(data[43..86].find_str(\"\u0e17\u0e28\u0e44\"), Some(55 - 43));\n-        assert_eq!(data[43..86].find_str(\"\u0e22\u4e2d\"), Some(67 - 43));\n-        assert_eq!(data[43..86].find_str(\"i\u1ec7t\"), Some(77 - 43));\n-        assert_eq!(data[43..86].find_str(\"Nam\"), Some(83 - 43));\n-    }\n-\n-    #[test]\n-    fn test_slice_chars() {\n-        fn t(a: &str, b: &str, start: usize) {\n-            assert_eq!(a.slice_chars(start, start + b.chars().count()), b);\n-        }\n-        t(\"\", \"\", 0);\n-        t(\"hello\", \"llo\", 2);\n-        t(\"hello\", \"el\", 1);\n-        t(\"\u03b1\u03b2\u03bb\", \"\u03b2\", 1);\n-        t(\"\u03b1\u03b2\u03bb\", \"\", 3);\n-        assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".slice_chars(2, 8));\n-    }\n-\n-    fn s(x: &str) -> String { x.to_string() }\n-\n-    macro_rules! test_concat {\n-        ($expected: expr, $string: expr) => {\n-            {\n-                let s: String = $string.concat();\n-                assert_eq!($expected, s);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_concat_for_different_types() {\n-        test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n-        test_concat!(\"ab\", vec![\"a\", \"b\"]);\n-        test_concat!(\"ab\", vec![\"a\", \"b\"]);\n-        test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n-    }\n-\n-    #[test]\n-    fn test_concat_for_different_lengths() {\n-        let empty: &[&str] = &[];\n-        test_concat!(\"\", empty);\n-        test_concat!(\"a\", [\"a\"]);\n-        test_concat!(\"ab\", [\"a\", \"b\"]);\n-        test_concat!(\"abc\", [\"\", \"a\", \"bc\"]);\n-    }\n-\n-    macro_rules! test_connect {\n-        ($expected: expr, $string: expr, $delim: expr) => {\n-            {\n-                let s = $string.connect($delim);\n-                assert_eq!($expected, s);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_connect_for_different_types() {\n-        test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n-        let hyphen = \"-\".to_string();\n-        test_connect!(\"a-b\", [s(\"a\"), s(\"b\")], &*hyphen);\n-        test_connect!(\"a-b\", vec![\"a\", \"b\"], &*hyphen);\n-        test_connect!(\"a-b\", &*vec![\"a\", \"b\"], \"-\");\n-        test_connect!(\"a-b\", vec![s(\"a\"), s(\"b\")], \"-\");\n-    }\n-\n-    #[test]\n-    fn test_connect_for_different_lengths() {\n-        let empty: &[&str] = &[];\n-        test_connect!(\"\", empty, \"-\");\n-        test_connect!(\"a\", [\"a\"], \"-\");\n-        test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n-        test_connect!(\"-a-bc\", [\"\", \"a\", \"bc\"], \"-\");\n-    }\n-\n-    #[test]\n-    fn test_unsafe_slice() {\n-        assert_eq!(\"ab\", unsafe {\"abc\".slice_unchecked(0, 2)});\n-        assert_eq!(\"bc\", unsafe {\"abc\".slice_unchecked(1, 3)});\n-        assert_eq!(\"\", unsafe {\"abc\".slice_unchecked(1, 1)});\n-        fn a_million_letter_a() -> String {\n-            let mut i = 0;\n-            let mut rs = String::new();\n-            while i < 100000 {\n-                rs.push_str(\"aaaaaaaaaa\");\n-                i += 1;\n-            }\n-            rs\n-        }\n-        fn half_a_million_letter_a() -> String {\n-            let mut i = 0;\n-            let mut rs = String::new();\n-            while i < 100000 {\n-                rs.push_str(\"aaaaa\");\n-                i += 1;\n-            }\n-            rs\n-        }\n-        let letters = a_million_letter_a();\n-        assert!(half_a_million_letter_a() ==\n-            unsafe {String::from_str(letters.slice_unchecked(\n-                                     0,\n-                                     500000))});\n-    }\n-\n-    #[test]\n-    fn test_starts_with() {\n-        assert!((\"\".starts_with(\"\")));\n-        assert!((\"abc\".starts_with(\"\")));\n-        assert!((\"abc\".starts_with(\"a\")));\n-        assert!((!\"a\".starts_with(\"abc\")));\n-        assert!((!\"\".starts_with(\"abc\")));\n-        assert!((!\"\u00f6dd\".starts_with(\"-\")));\n-        assert!((\"\u00f6dd\".starts_with(\"\u00f6d\")));\n-    }\n-\n-    #[test]\n-    fn test_ends_with() {\n-        assert!((\"\".ends_with(\"\")));\n-        assert!((\"abc\".ends_with(\"\")));\n-        assert!((\"abc\".ends_with(\"c\")));\n-        assert!((!\"a\".ends_with(\"abc\")));\n-        assert!((!\"\".ends_with(\"abc\")));\n-        assert!((!\"dd\u00f6\".ends_with(\"-\")));\n-        assert!((\"dd\u00f6\".ends_with(\"d\u00f6\")));\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        assert!(\"\".is_empty());\n-        assert!(!\"a\".is_empty());\n-    }\n-\n-    #[test]\n-    fn test_replace() {\n-        let a = \"a\";\n-        assert_eq!(\"\".replace(a, \"b\"), String::from_str(\"\"));\n-        assert_eq!(\"a\".replace(a, \"b\"), String::from_str(\"b\"));\n-        assert_eq!(\"ab\".replace(a, \"b\"), String::from_str(\"bb\"));\n-        let test = \"test\";\n-        assert!(\" test test \".replace(test, \"toast\") ==\n-            String::from_str(\" toast toast \"));\n-        assert_eq!(\" test test \".replace(test, \"\"), String::from_str(\"   \"));\n-    }\n-\n-    #[test]\n-    fn test_replace_2a() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-\n-        let a = \"\u0e1b\u0e23\u0e30\u0e40\";\n-        let a2 = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(data.replace(a, repl), a2);\n-    }\n-\n-    #[test]\n-    fn test_replace_2b() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-\n-        let b = \"\u0e30\u0e40\";\n-        let b2 = \"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(data.replace(b, repl), b2);\n-    }\n-\n-    #[test]\n-    fn test_replace_2c() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-\n-        let c = \"\u4e2d\u534e\";\n-        let c2 = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-        assert_eq!(data.replace(c, repl), c2);\n-    }\n-\n-    #[test]\n-    fn test_replace_2d() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-\n-        let d = \"\u0e44\u0e17\u534e\";\n-        assert_eq!(data.replace(d, repl), data);\n-    }\n-\n-    #[test]\n-    fn test_slice() {\n-        assert_eq!(\"ab\", \"abc\".slice(0, 2));\n-        assert_eq!(\"bc\", \"abc\".slice(1, 3));\n-        assert_eq!(\"\", \"abc\".slice(1, 1));\n-        assert_eq!(\"\\u{65e5}\", \"\\u{65e5}\\u{672c}\".slice(0, 3));\n-\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(\"\u0e1b\", data.slice(0, 3));\n-        assert_eq!(\"\u0e23\", data.slice(3, 6));\n-        assert_eq!(\"\", data.slice(3, 3));\n-        assert_eq!(\"\u534e\", data.slice(30, 33));\n-\n-        fn a_million_letter_x() -> String {\n-            let mut i = 0;\n-            let mut rs = String::new();\n-            while i < 100000 {\n-                rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n-                i += 1;\n-            }\n-            rs\n-        }\n-        fn half_a_million_letter_x() -> String {\n-            let mut i = 0;\n-            let mut rs = String::new();\n-            while i < 100000 {\n-                rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n-                i += 1;\n-            }\n-            rs\n-        }\n-        let letters = a_million_letter_x();\n-        assert!(half_a_million_letter_x() ==\n-            String::from_str(letters.slice(0, 3 * 500000)));\n-    }\n-\n-    #[test]\n-    fn test_slice_2() {\n-        let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-\n-        assert_eq!(\"\u534e\", ss.slice(3, 6));\n-        assert_eq!(\"Vi\u1ec7t Nam\", ss.slice(6, 16));\n-\n-        assert_eq!(\"ab\", \"abc\".slice(0, 2));\n-        assert_eq!(\"bc\", \"abc\".slice(1, 3));\n-        assert_eq!(\"\", \"abc\".slice(1, 1));\n-\n-        assert_eq!(\"\u4e2d\", ss.slice(0, 3));\n-        assert_eq!(\"\u534eV\", ss.slice(3, 7));\n-        assert_eq!(\"\", ss.slice(3, 3));\n-        /*0: \u4e2d\n-          3: \u534e\n-          6: V\n-          7: i\n-          8: \u1ec7\n-         11: t\n-         12:\n-         13: N\n-         14: a\n-         15: m */\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_slice_fail() {\n-        \"\u4e2d\u534eVi\u1ec7t Nam\".slice(0, 2);\n-    }\n-\n-    #[test]\n-    fn test_slice_from() {\n-        assert_eq!(\"abcd\".slice_from(0), \"abcd\");\n-        assert_eq!(\"abcd\".slice_from(2), \"cd\");\n-        assert_eq!(\"abcd\".slice_from(4), \"\");\n-    }\n-    #[test]\n-    fn test_slice_to() {\n-        assert_eq!(\"abcd\".slice_to(0), \"\");\n-        assert_eq!(\"abcd\".slice_to(2), \"ab\");\n-        assert_eq!(\"abcd\".slice_to(4), \"abcd\");\n-    }\n-\n-    #[test]\n-    fn test_trim_left_matches() {\n-        let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_left_matches(v), \" *** foo *** \");\n-        let chars: &[char] = &['*', ' '];\n-        assert_eq!(\" *** foo *** \".trim_left_matches(chars), \"foo *** \");\n-        assert_eq!(\" ***  *** \".trim_left_matches(chars), \"\");\n-        assert_eq!(\"foo *** \".trim_left_matches(chars), \"foo *** \");\n-\n-        assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n-        let chars: &[char] = &['1', '2'];\n-        assert_eq!(\"12foo1bar12\".trim_left_matches(chars), \"foo1bar12\");\n-        assert_eq!(\"123foo1bar123\".trim_left_matches(|c: char| c.is_numeric()), \"foo1bar123\");\n-    }\n-\n-    #[test]\n-    fn test_trim_right_matches() {\n-        let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_right_matches(v), \" *** foo *** \");\n-        let chars: &[char] = &['*', ' '];\n-        assert_eq!(\" *** foo *** \".trim_right_matches(chars), \" *** foo\");\n-        assert_eq!(\" ***  *** \".trim_right_matches(chars), \"\");\n-        assert_eq!(\" *** foo\".trim_right_matches(chars), \" *** foo\");\n-\n-        assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n-        let chars: &[char] = &['1', '2'];\n-        assert_eq!(\"12foo1bar12\".trim_right_matches(chars), \"12foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_right_matches(|c: char| c.is_numeric()), \"123foo1bar\");\n-    }\n-\n-    #[test]\n-    fn test_trim_matches() {\n-        let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_matches(v), \" *** foo *** \");\n-        let chars: &[char] = &['*', ' '];\n-        assert_eq!(\" *** foo *** \".trim_matches(chars), \"foo\");\n-        assert_eq!(\" ***  *** \".trim_matches(chars), \"\");\n-        assert_eq!(\"foo\".trim_matches(chars), \"foo\");\n-\n-        assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n-        let chars: &[char] = &['1', '2'];\n-        assert_eq!(\"12foo1bar12\".trim_matches(chars), \"foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_matches(|c: char| c.is_numeric()), \"foo1bar\");\n-    }\n-\n-    #[test]\n-    fn test_trim_left() {\n-        assert_eq!(\"\".trim_left(), \"\");\n-        assert_eq!(\"a\".trim_left(), \"a\");\n-        assert_eq!(\"    \".trim_left(), \"\");\n-        assert_eq!(\"     blah\".trim_left(), \"blah\");\n-        assert_eq!(\"   \\u{3000}  wut\".trim_left(), \"wut\");\n-        assert_eq!(\"hey \".trim_left(), \"hey \");\n-    }\n-\n-    #[test]\n-    fn test_trim_right() {\n-        assert_eq!(\"\".trim_right(), \"\");\n-        assert_eq!(\"a\".trim_right(), \"a\");\n-        assert_eq!(\"    \".trim_right(), \"\");\n-        assert_eq!(\"blah     \".trim_right(), \"blah\");\n-        assert_eq!(\"wut   \\u{3000}  \".trim_right(), \"wut\");\n-        assert_eq!(\" hey\".trim_right(), \" hey\");\n-    }\n-\n-    #[test]\n-    fn test_trim() {\n-        assert_eq!(\"\".trim(), \"\");\n-        assert_eq!(\"a\".trim(), \"a\");\n-        assert_eq!(\"    \".trim(), \"\");\n-        assert_eq!(\"    blah     \".trim(), \"blah\");\n-        assert_eq!(\"\\nwut   \\u{3000}  \".trim(), \"wut\");\n-        assert_eq!(\" hey dude \".trim(), \"hey dude\");\n-    }\n-\n-    #[test]\n-    fn test_is_whitespace() {\n-        assert!(\"\".chars().all(|c| c.is_whitespace()));\n-        assert!(\" \".chars().all(|c| c.is_whitespace()));\n-        assert!(\"\\u{2009}\".chars().all(|c| c.is_whitespace())); // Thin space\n-        assert!(\"  \\n\\t   \".chars().all(|c| c.is_whitespace()));\n-        assert!(!\"   _   \".chars().all(|c| c.is_whitespace()));\n-    }\n-\n-    #[test]\n-    fn test_slice_shift_char() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-        assert_eq!(data.slice_shift_char(), Some(('\u0e1b', \"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\")));\n-    }\n-\n-    #[test]\n-    fn test_slice_shift_char_2() {\n-        let empty = \"\";\n-        assert_eq!(empty.slice_shift_char(), None);\n-    }\n-\n-    #[test]\n-    fn test_is_utf8() {\n-        // deny overlong encodings\n-        assert!(from_utf8(&[0xc0, 0x80]).is_err());\n-        assert!(from_utf8(&[0xc0, 0xae]).is_err());\n-        assert!(from_utf8(&[0xe0, 0x80, 0x80]).is_err());\n-        assert!(from_utf8(&[0xe0, 0x80, 0xaf]).is_err());\n-        assert!(from_utf8(&[0xe0, 0x81, 0x81]).is_err());\n-        assert!(from_utf8(&[0xf0, 0x82, 0x82, 0xac]).is_err());\n-        assert!(from_utf8(&[0xf4, 0x90, 0x80, 0x80]).is_err());\n-\n-        // deny surrogates\n-        assert!(from_utf8(&[0xED, 0xA0, 0x80]).is_err());\n-        assert!(from_utf8(&[0xED, 0xBF, 0xBF]).is_err());\n-\n-        assert!(from_utf8(&[0xC2, 0x80]).is_ok());\n-        assert!(from_utf8(&[0xDF, 0xBF]).is_ok());\n-        assert!(from_utf8(&[0xE0, 0xA0, 0x80]).is_ok());\n-        assert!(from_utf8(&[0xED, 0x9F, 0xBF]).is_ok());\n-        assert!(from_utf8(&[0xEE, 0x80, 0x80]).is_ok());\n-        assert!(from_utf8(&[0xEF, 0xBF, 0xBF]).is_ok());\n-        assert!(from_utf8(&[0xF0, 0x90, 0x80, 0x80]).is_ok());\n-        assert!(from_utf8(&[0xF4, 0x8F, 0xBF, 0xBF]).is_ok());\n-    }\n-\n-    #[test]\n-    fn test_is_utf16() {\n-        use unicode::str::is_utf16;\n-        macro_rules! pos {\n-            ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } }\n-        }\n-\n-        // non-surrogates\n-        pos!(&[0x0000],\n-             &[0x0001, 0x0002],\n-             &[0xD7FF],\n-             &[0xE000]);\n-\n-        // surrogate pairs (randomly generated with Python 3's\n-        // .encode('utf-16be'))\n-        pos!(&[0xdb54, 0xdf16, 0xd880, 0xdee0, 0xdb6a, 0xdd45],\n-             &[0xd91f, 0xdeb1, 0xdb31, 0xdd84, 0xd8e2, 0xde14],\n-             &[0xdb9f, 0xdc26, 0xdb6f, 0xde58, 0xd850, 0xdfae]);\n-\n-        // mixtures (also random)\n-        pos!(&[0xd921, 0xdcc2, 0x002d, 0x004d, 0xdb32, 0xdf65],\n-             &[0xdb45, 0xdd2d, 0x006a, 0xdacd, 0xddfe, 0x0006],\n-             &[0x0067, 0xd8ff, 0xddb7, 0x000f, 0xd900, 0xdc80]);\n-\n-        // negative tests\n-        macro_rules! neg {\n-            ($($e:expr),*) => { { $(assert!(!is_utf16($e));)* } }\n-        }\n-\n-        neg!(\n-            // surrogate + regular unit\n-            &[0xdb45, 0x0000],\n-            // surrogate + lead surrogate\n-            &[0xd900, 0xd900],\n-            // unterminated surrogate\n-            &[0xd8ff],\n-            // trail surrogate without a lead\n-            &[0xddb7]);\n-\n-        // random byte sequences that Python 3's .decode('utf-16be')\n-        // failed on\n-        neg!(&[0x5b3d, 0x0141, 0xde9e, 0x8fdc, 0xc6e7],\n-             &[0xdf5a, 0x82a5, 0x62b9, 0xb447, 0x92f3],\n-             &[0xda4e, 0x42bc, 0x4462, 0xee98, 0xc2ca],\n-             &[0xbe00, 0xb04a, 0x6ecb, 0xdd89, 0xe278],\n-             &[0x0465, 0xab56, 0xdbb6, 0xa893, 0x665e],\n-             &[0x6b7f, 0x0a19, 0x40f4, 0xa657, 0xdcc5],\n-             &[0x9b50, 0xda5e, 0x24ec, 0x03ad, 0x6dee],\n-             &[0x8d17, 0xcaa7, 0xf4ae, 0xdf6e, 0xbed7],\n-             &[0xdaee, 0x2584, 0x7d30, 0xa626, 0x121a],\n-             &[0xd956, 0x4b43, 0x7570, 0xccd6, 0x4f4a],\n-             &[0x9dcf, 0x1b49, 0x4ba5, 0xfce9, 0xdffe],\n-             &[0x6572, 0xce53, 0xb05a, 0xf6af, 0xdacf],\n-             &[0x1b90, 0x728c, 0x9906, 0xdb68, 0xf46e],\n-             &[0x1606, 0xbeca, 0xbe76, 0x860f, 0xdfa5],\n-             &[0x8b4f, 0xde7a, 0xd220, 0x9fac, 0x2b6f],\n-             &[0xb8fe, 0xebbe, 0xda32, 0x1a5f, 0x8b8b],\n-             &[0x934b, 0x8956, 0xc434, 0x1881, 0xddf7],\n-             &[0x5a95, 0x13fc, 0xf116, 0xd89b, 0x93f9],\n-             &[0xd640, 0x71f1, 0xdd7d, 0x77eb, 0x1cd8],\n-             &[0x348b, 0xaef0, 0xdb2c, 0xebf1, 0x1282],\n-             &[0x50d7, 0xd824, 0x5010, 0xb369, 0x22ea]);\n-    }\n-\n-    #[test]\n-    fn test_as_bytes() {\n-        // no null\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109\n-        ];\n-        let b: &[u8] = &[];\n-        assert_eq!(\"\".as_bytes(), b);\n-        assert_eq!(\"abc\".as_bytes(), b\"abc\");\n-        assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_as_bytes_fail() {\n-        // Don't double free. (I'm not sure if this exercises the\n-        // original problem code path anymore.)\n-        let s = String::from_str(\"\");\n-        let _bytes = s.as_bytes();\n-        panic!();\n-    }\n-\n-    #[test]\n-    fn test_as_ptr() {\n-        let buf = \"hello\".as_ptr();\n-        unsafe {\n-            assert_eq!(*buf.offset(0), b'h');\n-            assert_eq!(*buf.offset(1), b'e');\n-            assert_eq!(*buf.offset(2), b'l');\n-            assert_eq!(*buf.offset(3), b'l');\n-            assert_eq!(*buf.offset(4), b'o');\n-        }\n-    }\n-\n-    #[test]\n-    fn test_subslice_offset() {\n-        let a = \"kernelsprite\";\n-        let b = &a[7..a.len()];\n-        let c = &a[0..a.len() - 6];\n-        assert_eq!(a.subslice_offset(b), 7);\n-        assert_eq!(a.subslice_offset(c), 0);\n-\n-        let string = \"a\\nb\\nc\";\n-        let lines: Vec<&str> = string.lines().collect();\n-        assert_eq!(string.subslice_offset(lines[0]), 0);\n-        assert_eq!(string.subslice_offset(lines[1]), 2);\n-        assert_eq!(string.subslice_offset(lines[2]), 4);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_subslice_offset_2() {\n-        let a = \"alchemiter\";\n-        let b = \"cruxtruder\";\n-        a.subslice_offset(b);\n-    }\n-\n-    #[test]\n-    fn vec_str_conversions() {\n-        let s1: String = String::from_str(\"All mimsy were the borogoves\");\n-\n-        let v: Vec<u8> = s1.as_bytes().to_vec();\n-        let s2: String = String::from_str(from_utf8(&v).unwrap());\n-        let mut i = 0;\n-        let n1 = s1.len();\n-        let n2 = v.len();\n-        assert_eq!(n1, n2);\n-        while i < n1 {\n-            let a: u8 = s1.as_bytes()[i];\n-            let b: u8 = s2.as_bytes()[i];\n-            debug!(\"{}\", a);\n-            debug!(\"{}\", b);\n-            assert_eq!(a, b);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_contains() {\n-        assert!(\"abcde\".contains(\"bcd\"));\n-        assert!(\"abcde\".contains(\"abcd\"));\n-        assert!(\"abcde\".contains(\"bcde\"));\n-        assert!(\"abcde\".contains(\"\"));\n-        assert!(\"\".contains(\"\"));\n-        assert!(!\"abcde\".contains(\"def\"));\n-        assert!(!\"\".contains(\"a\"));\n-\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert!(data.contains(\"\u0e1b\u0e23\u0e30\u0e40\"));\n-        assert!(data.contains(\"\u0e30\u0e40\"));\n-        assert!(data.contains(\"\u4e2d\u534e\"));\n-        assert!(!data.contains(\"\u0e44\u0e17\u534e\"));\n-    }\n-\n-    #[test]\n-    fn test_contains_char() {\n-        assert!(\"abc\".contains_char('b'));\n-        assert!(\"a\".contains_char('a'));\n-        assert!(!\"abc\".contains_char('d'));\n-        assert!(!\"\".contains_char('a'));\n-    }\n-\n-    #[test]\n-    fn test_char_at() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n-        let mut pos = 0;\n-        for ch in &v {\n-            assert!(s.char_at(pos) == *ch);\n-            pos += ch.to_string().len();\n-        }\n-    }\n-\n-    #[test]\n-    fn test_char_at_reverse() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n-        let mut pos = s.len();\n-        for ch in v.iter().rev() {\n-            assert!(s.char_at_reverse(pos) == *ch);\n-            pos -= ch.to_string().len();\n-        }\n-    }\n-\n-    #[test]\n-    fn test_escape_unicode() {\n-        assert_eq!(\"abc\".escape_unicode(),\n-                   String::from_str(\"\\\\u{61}\\\\u{62}\\\\u{63}\"));\n-        assert_eq!(\"a c\".escape_unicode(),\n-                   String::from_str(\"\\\\u{61}\\\\u{20}\\\\u{63}\"));\n-        assert_eq!(\"\\r\\n\\t\".escape_unicode(),\n-                   String::from_str(\"\\\\u{d}\\\\u{a}\\\\u{9}\"));\n-        assert_eq!(\"'\\\"\\\\\".escape_unicode(),\n-                   String::from_str(\"\\\\u{27}\\\\u{22}\\\\u{5c}\"));\n-        assert_eq!(\"\\x00\\x01\\u{fe}\\u{ff}\".escape_unicode(),\n-                   String::from_str(\"\\\\u{0}\\\\u{1}\\\\u{fe}\\\\u{ff}\"));\n-        assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode(),\n-                   String::from_str(\"\\\\u{100}\\\\u{ffff}\"));\n-        assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_unicode(),\n-                   String::from_str(\"\\\\u{10000}\\\\u{10ffff}\"));\n-        assert_eq!(\"ab\\u{fb00}\".escape_unicode(),\n-                   String::from_str(\"\\\\u{61}\\\\u{62}\\\\u{fb00}\"));\n-        assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode(),\n-                   String::from_str(\"\\\\u{1d4ea}\\\\u{d}\"));\n-    }\n-\n-    #[test]\n-    fn test_escape_default() {\n-        assert_eq!(\"abc\".escape_default(), String::from_str(\"abc\"));\n-        assert_eq!(\"a c\".escape_default(), String::from_str(\"a c\"));\n-        assert_eq!(\"\\r\\n\\t\".escape_default(), String::from_str(\"\\\\r\\\\n\\\\t\"));\n-        assert_eq!(\"'\\\"\\\\\".escape_default(), String::from_str(\"\\\\'\\\\\\\"\\\\\\\\\"));\n-        assert_eq!(\"\\u{100}\\u{ffff}\".escape_default(),\n-                   String::from_str(\"\\\\u{100}\\\\u{ffff}\"));\n-        assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_default(),\n-                   String::from_str(\"\\\\u{10000}\\\\u{10ffff}\"));\n-        assert_eq!(\"ab\\u{fb00}\".escape_default(),\n-                   String::from_str(\"ab\\\\u{fb00}\"));\n-        assert_eq!(\"\\u{1d4ea}\\r\".escape_default(),\n-                   String::from_str(\"\\\\u{1d4ea}\\\\r\"));\n-    }\n-\n-    #[test]\n-    fn test_total_ord() {\n-        \"1234\".cmp(\"123\") == Greater;\n-        \"123\".cmp(\"1234\") == Less;\n-        \"1234\".cmp(\"1234\") == Equal;\n-        \"12345555\".cmp(\"123456\") == Less;\n-        \"22\".cmp(\"1234\") == Greater;\n-    }\n-\n-    #[test]\n-    fn test_char_range_at() {\n-        let data = \"b\u00a2\u20ac\ud852\udf62\ud852\udf62\u20ac\u00a2b\";\n-        assert_eq!('b', data.char_range_at(0).ch);\n-        assert_eq!('\u00a2', data.char_range_at(1).ch);\n-        assert_eq!('\u20ac', data.char_range_at(3).ch);\n-        assert_eq!('\ud852\udf62', data.char_range_at(6).ch);\n-        assert_eq!('\ud852\udf62', data.char_range_at(10).ch);\n-        assert_eq!('\u20ac', data.char_range_at(14).ch);\n-        assert_eq!('\u00a2', data.char_range_at(17).ch);\n-        assert_eq!('b', data.char_range_at(19).ch);\n-    }\n-\n-    #[test]\n-    fn test_char_range_at_reverse_underflow() {\n-        assert_eq!(\"abc\".char_range_at_reverse(0).next, 0);\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n-\n-        let mut pos = 0;\n-        let it = s.chars();\n-\n-        for c in it {\n-            assert_eq!(c, v[pos]);\n-            pos += 1;\n-        }\n-        assert_eq!(pos, v.len());\n-    }\n-\n-    #[test]\n-    fn test_rev_iterator() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n-\n-        let mut pos = 0;\n-        let it = s.chars().rev();\n-\n-        for c in it {\n-            assert_eq!(c, v[pos]);\n-            pos += 1;\n-        }\n-        assert_eq!(pos, v.len());\n-    }\n-\n-    #[test]\n-    fn test_chars_decoding() {\n-        let mut bytes = [0; 4];\n-        for c in (0..0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n-            let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(&bytes[..len]).unwrap();\n-            if Some(c) != s.chars().next() {\n-                panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_chars_rev_decoding() {\n-        let mut bytes = [0; 4];\n-        for c in (0..0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n-            let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(&bytes[..len]).unwrap();\n-            if Some(c) != s.chars().rev().next() {\n-                panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_iterator_clone() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let mut it = s.chars();\n-        it.next();\n-        assert!(it.clone().zip(it).all(|(x,y)| x == y));\n-    }\n-\n-    #[test]\n-    fn test_bytesator() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109\n-        ];\n-        let mut pos = 0;\n-\n-        for b in s.bytes() {\n-            assert_eq!(b, v[pos]);\n-            pos += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_bytes_revator() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109\n-        ];\n-        let mut pos = v.len();\n-\n-        for b in s.bytes().rev() {\n-            pos -= 1;\n-            assert_eq!(b, v[pos]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_char_indicesator() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let p = [0, 3, 6, 9, 12, 15, 18, 19, 20, 23, 24, 25, 26, 27];\n-        let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n-\n-        let mut pos = 0;\n-        let it = s.char_indices();\n-\n-        for c in it {\n-            assert_eq!(c, (p[pos], v[pos]));\n-            pos += 1;\n-        }\n-        assert_eq!(pos, v.len());\n-        assert_eq!(pos, p.len());\n-    }\n-\n-    #[test]\n-    fn test_char_indices_revator() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let p = [27, 26, 25, 24, 23, 20, 19, 18, 15, 12, 9, 6, 3, 0];\n-        let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n-\n-        let mut pos = 0;\n-        let it = s.char_indices().rev();\n-\n-        for c in it {\n-            assert_eq!(c, (p[pos], v[pos]));\n-            pos += 1;\n-        }\n-        assert_eq!(pos, v.len());\n-        assert_eq!(pos, p.len());\n-    }\n-\n-    #[test]\n-    fn test_splitn_char_iterator() {\n-        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-        let split: Vec<&str> = data.splitn(3, ' ').collect();\n-        assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n-\n-        let split: Vec<&str> = data.splitn(3, |c: char| c == ' ').collect();\n-        assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n-\n-        // Unicode\n-        let split: Vec<&str> = data.splitn(3, '\u00e4').collect();\n-        assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n-\n-        let split: Vec<&str> = data.splitn(3, |c: char| c == '\u00e4').collect();\n-        assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n-    }\n-\n-    #[test]\n-    fn test_split_char_iterator_no_trailing() {\n-        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-        let split: Vec<&str> = data.split('\\n').collect();\n-        assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n-\n-        let split: Vec<&str> = data.split_terminator('\\n').collect();\n-        assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n-    }\n-\n-    #[test]\n-    fn test_words() {\n-        let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-        let words: Vec<&str> = data.words().collect();\n-        assert_eq!(words, [\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n-    }\n-\n-    #[test]\n-    fn test_nfd_chars() {\n-        macro_rules! t {\n-            ($input: expr, $expected: expr) => {\n-                assert_eq!($input.nfd_chars().collect::<String>(), $expected);\n-            }\n-        }\n-        t!(\"abc\", \"abc\");\n-        t!(\"\\u{1e0b}\\u{1c4}\", \"d\\u{307}\\u{1c4}\");\n-        t!(\"\\u{2026}\", \"\\u{2026}\");\n-        t!(\"\\u{2126}\", \"\\u{3a9}\");\n-        t!(\"\\u{1e0b}\\u{323}\", \"d\\u{323}\\u{307}\");\n-        t!(\"\\u{1e0d}\\u{307}\", \"d\\u{323}\\u{307}\");\n-        t!(\"a\\u{301}\", \"a\\u{301}\");\n-        t!(\"\\u{301}a\", \"\\u{301}a\");\n-        t!(\"\\u{d4db}\", \"\\u{1111}\\u{1171}\\u{11b6}\");\n-        t!(\"\\u{ac1c}\", \"\\u{1100}\\u{1162}\");\n-    }\n-\n-    #[test]\n-    fn test_nfkd_chars() {\n-        macro_rules! t {\n-            ($input: expr, $expected: expr) => {\n-                assert_eq!($input.nfkd_chars().collect::<String>(), $expected);\n-            }\n-        }\n-        t!(\"abc\", \"abc\");\n-        t!(\"\\u{1e0b}\\u{1c4}\", \"d\\u{307}DZ\\u{30c}\");\n-        t!(\"\\u{2026}\", \"...\");\n-        t!(\"\\u{2126}\", \"\\u{3a9}\");\n-        t!(\"\\u{1e0b}\\u{323}\", \"d\\u{323}\\u{307}\");\n-        t!(\"\\u{1e0d}\\u{307}\", \"d\\u{323}\\u{307}\");\n-        t!(\"a\\u{301}\", \"a\\u{301}\");\n-        t!(\"\\u{301}a\", \"\\u{301}a\");\n-        t!(\"\\u{d4db}\", \"\\u{1111}\\u{1171}\\u{11b6}\");\n-        t!(\"\\u{ac1c}\", \"\\u{1100}\\u{1162}\");\n-    }\n-\n-    #[test]\n-    fn test_nfc_chars() {\n-        macro_rules! t {\n-            ($input: expr, $expected: expr) => {\n-                assert_eq!($input.nfc_chars().collect::<String>(), $expected);\n-            }\n-        }\n-        t!(\"abc\", \"abc\");\n-        t!(\"\\u{1e0b}\\u{1c4}\", \"\\u{1e0b}\\u{1c4}\");\n-        t!(\"\\u{2026}\", \"\\u{2026}\");\n-        t!(\"\\u{2126}\", \"\\u{3a9}\");\n-        t!(\"\\u{1e0b}\\u{323}\", \"\\u{1e0d}\\u{307}\");\n-        t!(\"\\u{1e0d}\\u{307}\", \"\\u{1e0d}\\u{307}\");\n-        t!(\"a\\u{301}\", \"\\u{e1}\");\n-        t!(\"\\u{301}a\", \"\\u{301}a\");\n-        t!(\"\\u{d4db}\", \"\\u{d4db}\");\n-        t!(\"\\u{ac1c}\", \"\\u{ac1c}\");\n-        t!(\"a\\u{300}\\u{305}\\u{315}\\u{5ae}b\", \"\\u{e0}\\u{5ae}\\u{305}\\u{315}b\");\n-    }\n-\n-    #[test]\n-    fn test_nfkc_chars() {\n-        macro_rules! t {\n-            ($input: expr, $expected: expr) => {\n-                assert_eq!($input.nfkc_chars().collect::<String>(), $expected);\n-            }\n-        }\n-        t!(\"abc\", \"abc\");\n-        t!(\"\\u{1e0b}\\u{1c4}\", \"\\u{1e0b}D\\u{17d}\");\n-        t!(\"\\u{2026}\", \"...\");\n-        t!(\"\\u{2126}\", \"\\u{3a9}\");\n-        t!(\"\\u{1e0b}\\u{323}\", \"\\u{1e0d}\\u{307}\");\n-        t!(\"\\u{1e0d}\\u{307}\", \"\\u{1e0d}\\u{307}\");\n-        t!(\"a\\u{301}\", \"\\u{e1}\");\n-        t!(\"\\u{301}a\", \"\\u{301}a\");\n-        t!(\"\\u{d4db}\", \"\\u{d4db}\");\n-        t!(\"\\u{ac1c}\", \"\\u{ac1c}\");\n-        t!(\"a\\u{300}\\u{305}\\u{315}\\u{5ae}b\", \"\\u{e0}\\u{5ae}\\u{305}\\u{315}b\");\n-    }\n-\n-    #[test]\n-    fn test_lines() {\n-        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-        let lines: Vec<&str> = data.lines().collect();\n-        assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n-\n-        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\"; // no trailing \\n\n-        let lines: Vec<&str> = data.lines().collect();\n-        assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n-    }\n-\n-    #[test]\n-    fn test_graphemes() {\n-        use core::iter::order;\n-        // official Unicode test data\n-        // from http://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n-        let test_same: [(_, &[_]); 325] = [\n-            (\"\\u{20}\\u{20}\", &[\"\\u{20}\", \"\\u{20}\"]),\n-            (\"\\u{20}\\u{308}\\u{20}\", &[\"\\u{20}\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{20}\\u{D}\", &[\"\\u{20}\", \"\\u{D}\"]),\n-            (\"\\u{20}\\u{308}\\u{D}\", &[\"\\u{20}\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{20}\\u{A}\", &[\"\\u{20}\", \"\\u{A}\"]),\n-            (\"\\u{20}\\u{308}\\u{A}\", &[\"\\u{20}\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{20}\\u{1}\", &[\"\\u{20}\", \"\\u{1}\"]),\n-            (\"\\u{20}\\u{308}\\u{1}\", &[\"\\u{20}\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{20}\\u{300}\", &[\"\\u{20}\\u{300}\"]),\n-            (\"\\u{20}\\u{308}\\u{300}\", &[\"\\u{20}\\u{308}\\u{300}\"]),\n-            (\"\\u{20}\\u{1100}\", &[\"\\u{20}\", \"\\u{1100}\"]),\n-            (\"\\u{20}\\u{308}\\u{1100}\", &[\"\\u{20}\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{20}\\u{1160}\", &[\"\\u{20}\", \"\\u{1160}\"]),\n-            (\"\\u{20}\\u{308}\\u{1160}\", &[\"\\u{20}\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{20}\\u{11A8}\", &[\"\\u{20}\", \"\\u{11A8}\"]),\n-            (\"\\u{20}\\u{308}\\u{11A8}\", &[\"\\u{20}\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{20}\\u{AC00}\", &[\"\\u{20}\", \"\\u{AC00}\"]),\n-            (\"\\u{20}\\u{308}\\u{AC00}\", &[\"\\u{20}\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{20}\\u{AC01}\", &[\"\\u{20}\", \"\\u{AC01}\"]),\n-            (\"\\u{20}\\u{308}\\u{AC01}\", &[\"\\u{20}\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{20}\\u{1F1E6}\", &[\"\\u{20}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{20}\\u{308}\\u{1F1E6}\", &[\"\\u{20}\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{20}\\u{378}\", &[\"\\u{20}\", \"\\u{378}\"]),\n-            (\"\\u{20}\\u{308}\\u{378}\", &[\"\\u{20}\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{D}\\u{20}\", &[\"\\u{D}\", \"\\u{20}\"]),\n-            (\"\\u{D}\\u{308}\\u{20}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{D}\\u{D}\", &[\"\\u{D}\", \"\\u{D}\"]),\n-            (\"\\u{D}\\u{308}\\u{D}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{D}\\u{A}\", &[\"\\u{D}\\u{A}\"]),\n-            (\"\\u{D}\\u{308}\\u{A}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{D}\\u{1}\", &[\"\\u{D}\", \"\\u{1}\"]),\n-            (\"\\u{D}\\u{308}\\u{1}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{D}\\u{300}\", &[\"\\u{D}\", \"\\u{300}\"]),\n-            (\"\\u{D}\\u{308}\\u{300}\", &[\"\\u{D}\", \"\\u{308}\\u{300}\"]),\n-            (\"\\u{D}\\u{903}\", &[\"\\u{D}\", \"\\u{903}\"]),\n-            (\"\\u{D}\\u{1100}\", &[\"\\u{D}\", \"\\u{1100}\"]),\n-            (\"\\u{D}\\u{308}\\u{1100}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{D}\\u{1160}\", &[\"\\u{D}\", \"\\u{1160}\"]),\n-            (\"\\u{D}\\u{308}\\u{1160}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{D}\\u{11A8}\", &[\"\\u{D}\", \"\\u{11A8}\"]),\n-            (\"\\u{D}\\u{308}\\u{11A8}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{D}\\u{AC00}\", &[\"\\u{D}\", \"\\u{AC00}\"]),\n-            (\"\\u{D}\\u{308}\\u{AC00}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{D}\\u{AC01}\", &[\"\\u{D}\", \"\\u{AC01}\"]),\n-            (\"\\u{D}\\u{308}\\u{AC01}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{D}\\u{1F1E6}\", &[\"\\u{D}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{D}\\u{308}\\u{1F1E6}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{D}\\u{378}\", &[\"\\u{D}\", \"\\u{378}\"]),\n-            (\"\\u{D}\\u{308}\\u{378}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{A}\\u{20}\", &[\"\\u{A}\", \"\\u{20}\"]),\n-            (\"\\u{A}\\u{308}\\u{20}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{A}\\u{D}\", &[\"\\u{A}\", \"\\u{D}\"]),\n-            (\"\\u{A}\\u{308}\\u{D}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{A}\\u{A}\", &[\"\\u{A}\", \"\\u{A}\"]),\n-            (\"\\u{A}\\u{308}\\u{A}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{A}\\u{1}\", &[\"\\u{A}\", \"\\u{1}\"]),\n-            (\"\\u{A}\\u{308}\\u{1}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{A}\\u{300}\", &[\"\\u{A}\", \"\\u{300}\"]),\n-            (\"\\u{A}\\u{308}\\u{300}\", &[\"\\u{A}\", \"\\u{308}\\u{300}\"]),\n-            (\"\\u{A}\\u{903}\", &[\"\\u{A}\", \"\\u{903}\"]),\n-            (\"\\u{A}\\u{1100}\", &[\"\\u{A}\", \"\\u{1100}\"]),\n-            (\"\\u{A}\\u{308}\\u{1100}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{A}\\u{1160}\", &[\"\\u{A}\", \"\\u{1160}\"]),\n-            (\"\\u{A}\\u{308}\\u{1160}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{A}\\u{11A8}\", &[\"\\u{A}\", \"\\u{11A8}\"]),\n-            (\"\\u{A}\\u{308}\\u{11A8}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{A}\\u{AC00}\", &[\"\\u{A}\", \"\\u{AC00}\"]),\n-            (\"\\u{A}\\u{308}\\u{AC00}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{A}\\u{AC01}\", &[\"\\u{A}\", \"\\u{AC01}\"]),\n-            (\"\\u{A}\\u{308}\\u{AC01}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{A}\\u{1F1E6}\", &[\"\\u{A}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{A}\\u{308}\\u{1F1E6}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{A}\\u{378}\", &[\"\\u{A}\", \"\\u{378}\"]),\n-            (\"\\u{A}\\u{308}\\u{378}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{1}\\u{20}\", &[\"\\u{1}\", \"\\u{20}\"]),\n-            (\"\\u{1}\\u{308}\\u{20}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{1}\\u{D}\", &[\"\\u{1}\", \"\\u{D}\"]),\n-            (\"\\u{1}\\u{308}\\u{D}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{1}\\u{A}\", &[\"\\u{1}\", \"\\u{A}\"]),\n-            (\"\\u{1}\\u{308}\\u{A}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{1}\\u{1}\", &[\"\\u{1}\", \"\\u{1}\"]),\n-            (\"\\u{1}\\u{308}\\u{1}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{1}\\u{300}\", &[\"\\u{1}\", \"\\u{300}\"]),\n-            (\"\\u{1}\\u{308}\\u{300}\", &[\"\\u{1}\", \"\\u{308}\\u{300}\"]),\n-            (\"\\u{1}\\u{903}\", &[\"\\u{1}\", \"\\u{903}\"]),\n-            (\"\\u{1}\\u{1100}\", &[\"\\u{1}\", \"\\u{1100}\"]),\n-            (\"\\u{1}\\u{308}\\u{1100}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{1}\\u{1160}\", &[\"\\u{1}\", \"\\u{1160}\"]),\n-            (\"\\u{1}\\u{308}\\u{1160}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{1}\\u{11A8}\", &[\"\\u{1}\", \"\\u{11A8}\"]),\n-            (\"\\u{1}\\u{308}\\u{11A8}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{1}\\u{AC00}\", &[\"\\u{1}\", \"\\u{AC00}\"]),\n-            (\"\\u{1}\\u{308}\\u{AC00}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{1}\\u{AC01}\", &[\"\\u{1}\", \"\\u{AC01}\"]),\n-            (\"\\u{1}\\u{308}\\u{AC01}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{1}\\u{1F1E6}\", &[\"\\u{1}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{1}\\u{308}\\u{1F1E6}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{1}\\u{378}\", &[\"\\u{1}\", \"\\u{378}\"]),\n-            (\"\\u{1}\\u{308}\\u{378}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{300}\\u{20}\", &[\"\\u{300}\", \"\\u{20}\"]),\n-            (\"\\u{300}\\u{308}\\u{20}\", &[\"\\u{300}\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{300}\\u{D}\", &[\"\\u{300}\", \"\\u{D}\"]),\n-            (\"\\u{300}\\u{308}\\u{D}\", &[\"\\u{300}\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{300}\\u{A}\", &[\"\\u{300}\", \"\\u{A}\"]),\n-            (\"\\u{300}\\u{308}\\u{A}\", &[\"\\u{300}\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{300}\\u{1}\", &[\"\\u{300}\", \"\\u{1}\"]),\n-            (\"\\u{300}\\u{308}\\u{1}\", &[\"\\u{300}\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{300}\\u{300}\", &[\"\\u{300}\\u{300}\"]),\n-            (\"\\u{300}\\u{308}\\u{300}\", &[\"\\u{300}\\u{308}\\u{300}\"]),\n-            (\"\\u{300}\\u{1100}\", &[\"\\u{300}\", \"\\u{1100}\"]),\n-            (\"\\u{300}\\u{308}\\u{1100}\", &[\"\\u{300}\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{300}\\u{1160}\", &[\"\\u{300}\", \"\\u{1160}\"]),\n-            (\"\\u{300}\\u{308}\\u{1160}\", &[\"\\u{300}\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{300}\\u{11A8}\", &[\"\\u{300}\", \"\\u{11A8}\"]),\n-            (\"\\u{300}\\u{308}\\u{11A8}\", &[\"\\u{300}\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{300}\\u{AC00}\", &[\"\\u{300}\", \"\\u{AC00}\"]),\n-            (\"\\u{300}\\u{308}\\u{AC00}\", &[\"\\u{300}\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{300}\\u{AC01}\", &[\"\\u{300}\", \"\\u{AC01}\"]),\n-            (\"\\u{300}\\u{308}\\u{AC01}\", &[\"\\u{300}\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{300}\\u{1F1E6}\", &[\"\\u{300}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{300}\\u{308}\\u{1F1E6}\", &[\"\\u{300}\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{300}\\u{378}\", &[\"\\u{300}\", \"\\u{378}\"]),\n-            (\"\\u{300}\\u{308}\\u{378}\", &[\"\\u{300}\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{903}\\u{20}\", &[\"\\u{903}\", \"\\u{20}\"]),\n-            (\"\\u{903}\\u{308}\\u{20}\", &[\"\\u{903}\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{903}\\u{D}\", &[\"\\u{903}\", \"\\u{D}\"]),\n-            (\"\\u{903}\\u{308}\\u{D}\", &[\"\\u{903}\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{903}\\u{A}\", &[\"\\u{903}\", \"\\u{A}\"]),\n-            (\"\\u{903}\\u{308}\\u{A}\", &[\"\\u{903}\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{903}\\u{1}\", &[\"\\u{903}\", \"\\u{1}\"]),\n-            (\"\\u{903}\\u{308}\\u{1}\", &[\"\\u{903}\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{903}\\u{300}\", &[\"\\u{903}\\u{300}\"]),\n-            (\"\\u{903}\\u{308}\\u{300}\", &[\"\\u{903}\\u{308}\\u{300}\"]),\n-            (\"\\u{903}\\u{1100}\", &[\"\\u{903}\", \"\\u{1100}\"]),\n-            (\"\\u{903}\\u{308}\\u{1100}\", &[\"\\u{903}\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{903}\\u{1160}\", &[\"\\u{903}\", \"\\u{1160}\"]),\n-            (\"\\u{903}\\u{308}\\u{1160}\", &[\"\\u{903}\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{903}\\u{11A8}\", &[\"\\u{903}\", \"\\u{11A8}\"]),\n-            (\"\\u{903}\\u{308}\\u{11A8}\", &[\"\\u{903}\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{903}\\u{AC00}\", &[\"\\u{903}\", \"\\u{AC00}\"]),\n-            (\"\\u{903}\\u{308}\\u{AC00}\", &[\"\\u{903}\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{903}\\u{AC01}\", &[\"\\u{903}\", \"\\u{AC01}\"]),\n-            (\"\\u{903}\\u{308}\\u{AC01}\", &[\"\\u{903}\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{903}\\u{1F1E6}\", &[\"\\u{903}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{903}\\u{308}\\u{1F1E6}\", &[\"\\u{903}\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{903}\\u{378}\", &[\"\\u{903}\", \"\\u{378}\"]),\n-            (\"\\u{903}\\u{308}\\u{378}\", &[\"\\u{903}\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{1100}\\u{20}\", &[\"\\u{1100}\", \"\\u{20}\"]),\n-            (\"\\u{1100}\\u{308}\\u{20}\", &[\"\\u{1100}\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{1100}\\u{D}\", &[\"\\u{1100}\", \"\\u{D}\"]),\n-            (\"\\u{1100}\\u{308}\\u{D}\", &[\"\\u{1100}\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{1100}\\u{A}\", &[\"\\u{1100}\", \"\\u{A}\"]),\n-            (\"\\u{1100}\\u{308}\\u{A}\", &[\"\\u{1100}\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{1100}\\u{1}\", &[\"\\u{1100}\", \"\\u{1}\"]),\n-            (\"\\u{1100}\\u{308}\\u{1}\", &[\"\\u{1100}\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{1100}\\u{300}\", &[\"\\u{1100}\\u{300}\"]),\n-            (\"\\u{1100}\\u{308}\\u{300}\", &[\"\\u{1100}\\u{308}\\u{300}\"]),\n-            (\"\\u{1100}\\u{1100}\", &[\"\\u{1100}\\u{1100}\"]),\n-            (\"\\u{1100}\\u{308}\\u{1100}\", &[\"\\u{1100}\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{1100}\\u{1160}\", &[\"\\u{1100}\\u{1160}\"]),\n-            (\"\\u{1100}\\u{308}\\u{1160}\", &[\"\\u{1100}\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{1100}\\u{11A8}\", &[\"\\u{1100}\", \"\\u{11A8}\"]),\n-            (\"\\u{1100}\\u{308}\\u{11A8}\", &[\"\\u{1100}\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{1100}\\u{AC00}\", &[\"\\u{1100}\\u{AC00}\"]),\n-            (\"\\u{1100}\\u{308}\\u{AC00}\", &[\"\\u{1100}\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{1100}\\u{AC01}\", &[\"\\u{1100}\\u{AC01}\"]),\n-            (\"\\u{1100}\\u{308}\\u{AC01}\", &[\"\\u{1100}\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{1100}\\u{1F1E6}\", &[\"\\u{1100}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{1100}\\u{308}\\u{1F1E6}\", &[\"\\u{1100}\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{1100}\\u{378}\", &[\"\\u{1100}\", \"\\u{378}\"]),\n-            (\"\\u{1100}\\u{308}\\u{378}\", &[\"\\u{1100}\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{1160}\\u{20}\", &[\"\\u{1160}\", \"\\u{20}\"]),\n-            (\"\\u{1160}\\u{308}\\u{20}\", &[\"\\u{1160}\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{1160}\\u{D}\", &[\"\\u{1160}\", \"\\u{D}\"]),\n-            (\"\\u{1160}\\u{308}\\u{D}\", &[\"\\u{1160}\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{1160}\\u{A}\", &[\"\\u{1160}\", \"\\u{A}\"]),\n-            (\"\\u{1160}\\u{308}\\u{A}\", &[\"\\u{1160}\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{1160}\\u{1}\", &[\"\\u{1160}\", \"\\u{1}\"]),\n-            (\"\\u{1160}\\u{308}\\u{1}\", &[\"\\u{1160}\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{1160}\\u{300}\", &[\"\\u{1160}\\u{300}\"]),\n-            (\"\\u{1160}\\u{308}\\u{300}\", &[\"\\u{1160}\\u{308}\\u{300}\"]),\n-            (\"\\u{1160}\\u{1100}\", &[\"\\u{1160}\", \"\\u{1100}\"]),\n-            (\"\\u{1160}\\u{308}\\u{1100}\", &[\"\\u{1160}\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{1160}\\u{1160}\", &[\"\\u{1160}\\u{1160}\"]),\n-            (\"\\u{1160}\\u{308}\\u{1160}\", &[\"\\u{1160}\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{1160}\\u{11A8}\", &[\"\\u{1160}\\u{11A8}\"]),\n-            (\"\\u{1160}\\u{308}\\u{11A8}\", &[\"\\u{1160}\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{1160}\\u{AC00}\", &[\"\\u{1160}\", \"\\u{AC00}\"]),\n-            (\"\\u{1160}\\u{308}\\u{AC00}\", &[\"\\u{1160}\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{1160}\\u{AC01}\", &[\"\\u{1160}\", \"\\u{AC01}\"]),\n-            (\"\\u{1160}\\u{308}\\u{AC01}\", &[\"\\u{1160}\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{1160}\\u{1F1E6}\", &[\"\\u{1160}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{1160}\\u{308}\\u{1F1E6}\", &[\"\\u{1160}\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{1160}\\u{378}\", &[\"\\u{1160}\", \"\\u{378}\"]),\n-            (\"\\u{1160}\\u{308}\\u{378}\", &[\"\\u{1160}\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{11A8}\\u{20}\", &[\"\\u{11A8}\", \"\\u{20}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{20}\", &[\"\\u{11A8}\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{11A8}\\u{D}\", &[\"\\u{11A8}\", \"\\u{D}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{D}\", &[\"\\u{11A8}\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{11A8}\\u{A}\", &[\"\\u{11A8}\", \"\\u{A}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{A}\", &[\"\\u{11A8}\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{11A8}\\u{1}\", &[\"\\u{11A8}\", \"\\u{1}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{1}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{11A8}\\u{300}\", &[\"\\u{11A8}\\u{300}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{300}\", &[\"\\u{11A8}\\u{308}\\u{300}\"]),\n-            (\"\\u{11A8}\\u{1100}\", &[\"\\u{11A8}\", \"\\u{1100}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{1100}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{11A8}\\u{1160}\", &[\"\\u{11A8}\", \"\\u{1160}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{1160}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{11A8}\\u{11A8}\", &[\"\\u{11A8}\\u{11A8}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{11A8}\", &[\"\\u{11A8}\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{11A8}\\u{AC00}\", &[\"\\u{11A8}\", \"\\u{AC00}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{AC00}\", &[\"\\u{11A8}\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{11A8}\\u{AC01}\", &[\"\\u{11A8}\", \"\\u{AC01}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{AC01}\", &[\"\\u{11A8}\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{11A8}\\u{1F1E6}\", &[\"\\u{11A8}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{1F1E6}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{11A8}\\u{378}\", &[\"\\u{11A8}\", \"\\u{378}\"]),\n-            (\"\\u{11A8}\\u{308}\\u{378}\", &[\"\\u{11A8}\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{AC00}\\u{20}\", &[\"\\u{AC00}\", \"\\u{20}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{20}\", &[\"\\u{AC00}\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{AC00}\\u{D}\", &[\"\\u{AC00}\", \"\\u{D}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{D}\", &[\"\\u{AC00}\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{AC00}\\u{A}\", &[\"\\u{AC00}\", \"\\u{A}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{A}\", &[\"\\u{AC00}\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{AC00}\\u{1}\", &[\"\\u{AC00}\", \"\\u{1}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{1}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{AC00}\\u{300}\", &[\"\\u{AC00}\\u{300}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{300}\", &[\"\\u{AC00}\\u{308}\\u{300}\"]),\n-            (\"\\u{AC00}\\u{1100}\", &[\"\\u{AC00}\", \"\\u{1100}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{1100}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{AC00}\\u{1160}\", &[\"\\u{AC00}\\u{1160}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{1160}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{AC00}\\u{11A8}\", &[\"\\u{AC00}\\u{11A8}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{11A8}\", &[\"\\u{AC00}\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{AC00}\\u{AC00}\", &[\"\\u{AC00}\", \"\\u{AC00}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{AC00}\", &[\"\\u{AC00}\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{AC00}\\u{AC01}\", &[\"\\u{AC00}\", \"\\u{AC01}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{AC01}\", &[\"\\u{AC00}\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{AC00}\\u{1F1E6}\", &[\"\\u{AC00}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{1F1E6}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{AC00}\\u{378}\", &[\"\\u{AC00}\", \"\\u{378}\"]),\n-            (\"\\u{AC00}\\u{308}\\u{378}\", &[\"\\u{AC00}\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{AC01}\\u{20}\", &[\"\\u{AC01}\", \"\\u{20}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{20}\", &[\"\\u{AC01}\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{AC01}\\u{D}\", &[\"\\u{AC01}\", \"\\u{D}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{D}\", &[\"\\u{AC01}\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{AC01}\\u{A}\", &[\"\\u{AC01}\", \"\\u{A}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{A}\", &[\"\\u{AC01}\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{AC01}\\u{1}\", &[\"\\u{AC01}\", \"\\u{1}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{1}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{AC01}\\u{300}\", &[\"\\u{AC01}\\u{300}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{300}\", &[\"\\u{AC01}\\u{308}\\u{300}\"]),\n-            (\"\\u{AC01}\\u{1100}\", &[\"\\u{AC01}\", \"\\u{1100}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{1100}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{AC01}\\u{1160}\", &[\"\\u{AC01}\", \"\\u{1160}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{1160}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{AC01}\\u{11A8}\", &[\"\\u{AC01}\\u{11A8}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{11A8}\", &[\"\\u{AC01}\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{AC01}\\u{AC00}\", &[\"\\u{AC01}\", \"\\u{AC00}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{AC00}\", &[\"\\u{AC01}\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{AC01}\\u{AC01}\", &[\"\\u{AC01}\", \"\\u{AC01}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{AC01}\", &[\"\\u{AC01}\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{AC01}\\u{1F1E6}\", &[\"\\u{AC01}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{1F1E6}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{AC01}\\u{378}\", &[\"\\u{AC01}\", \"\\u{378}\"]),\n-            (\"\\u{AC01}\\u{308}\\u{378}\", &[\"\\u{AC01}\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{1F1E6}\\u{20}\", &[\"\\u{1F1E6}\", \"\\u{20}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{20}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{1F1E6}\\u{D}\", &[\"\\u{1F1E6}\", \"\\u{D}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{D}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{1F1E6}\\u{A}\", &[\"\\u{1F1E6}\", \"\\u{A}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{A}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{1F1E6}\\u{1}\", &[\"\\u{1F1E6}\", \"\\u{1}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{1}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{1F1E6}\\u{300}\", &[\"\\u{1F1E6}\\u{300}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{300}\", &[\"\\u{1F1E6}\\u{308}\\u{300}\"]),\n-            (\"\\u{1F1E6}\\u{1100}\", &[\"\\u{1F1E6}\", \"\\u{1100}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{1100}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{1F1E6}\\u{1160}\", &[\"\\u{1F1E6}\", \"\\u{1160}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{1160}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{1F1E6}\\u{11A8}\", &[\"\\u{1F1E6}\", \"\\u{11A8}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{11A8}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{1F1E6}\\u{AC00}\", &[\"\\u{1F1E6}\", \"\\u{AC00}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{AC00}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{1F1E6}\\u{AC01}\", &[\"\\u{1F1E6}\", \"\\u{AC01}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{AC01}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{1F1E6}\\u{1F1E6}\", &[\"\\u{1F1E6}\\u{1F1E6}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{1F1E6}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{1F1E6}\\u{378}\", &[\"\\u{1F1E6}\", \"\\u{378}\"]),\n-            (\"\\u{1F1E6}\\u{308}\\u{378}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{378}\\u{20}\", &[\"\\u{378}\", \"\\u{20}\"]),\n-            (\"\\u{378}\\u{308}\\u{20}\", &[\"\\u{378}\\u{308}\", \"\\u{20}\"]),\n-            (\"\\u{378}\\u{D}\", &[\"\\u{378}\", \"\\u{D}\"]),\n-            (\"\\u{378}\\u{308}\\u{D}\", &[\"\\u{378}\\u{308}\", \"\\u{D}\"]),\n-            (\"\\u{378}\\u{A}\", &[\"\\u{378}\", \"\\u{A}\"]),\n-            (\"\\u{378}\\u{308}\\u{A}\", &[\"\\u{378}\\u{308}\", \"\\u{A}\"]),\n-            (\"\\u{378}\\u{1}\", &[\"\\u{378}\", \"\\u{1}\"]),\n-            (\"\\u{378}\\u{308}\\u{1}\", &[\"\\u{378}\\u{308}\", \"\\u{1}\"]),\n-            (\"\\u{378}\\u{300}\", &[\"\\u{378}\\u{300}\"]),\n-            (\"\\u{378}\\u{308}\\u{300}\", &[\"\\u{378}\\u{308}\\u{300}\"]),\n-            (\"\\u{378}\\u{1100}\", &[\"\\u{378}\", \"\\u{1100}\"]),\n-            (\"\\u{378}\\u{308}\\u{1100}\", &[\"\\u{378}\\u{308}\", \"\\u{1100}\"]),\n-            (\"\\u{378}\\u{1160}\", &[\"\\u{378}\", \"\\u{1160}\"]),\n-            (\"\\u{378}\\u{308}\\u{1160}\", &[\"\\u{378}\\u{308}\", \"\\u{1160}\"]),\n-            (\"\\u{378}\\u{11A8}\", &[\"\\u{378}\", \"\\u{11A8}\"]),\n-            (\"\\u{378}\\u{308}\\u{11A8}\", &[\"\\u{378}\\u{308}\", \"\\u{11A8}\"]),\n-            (\"\\u{378}\\u{AC00}\", &[\"\\u{378}\", \"\\u{AC00}\"]),\n-            (\"\\u{378}\\u{308}\\u{AC00}\", &[\"\\u{378}\\u{308}\", \"\\u{AC00}\"]),\n-            (\"\\u{378}\\u{AC01}\", &[\"\\u{378}\", \"\\u{AC01}\"]),\n-            (\"\\u{378}\\u{308}\\u{AC01}\", &[\"\\u{378}\\u{308}\", \"\\u{AC01}\"]),\n-            (\"\\u{378}\\u{1F1E6}\", &[\"\\u{378}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{378}\\u{308}\\u{1F1E6}\", &[\"\\u{378}\\u{308}\", \"\\u{1F1E6}\"]),\n-            (\"\\u{378}\\u{378}\", &[\"\\u{378}\", \"\\u{378}\"]),\n-            (\"\\u{378}\\u{308}\\u{378}\", &[\"\\u{378}\\u{308}\", \"\\u{378}\"]),\n-            (\"\\u{61}\\u{1F1E6}\\u{62}\", &[\"\\u{61}\", \"\\u{1F1E6}\", \"\\u{62}\"]),\n-            (\"\\u{1F1F7}\\u{1F1FA}\", &[\"\\u{1F1F7}\\u{1F1FA}\"]),\n-            (\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\", &[\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\"]),\n-            (\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\\u{1F1EA}\",\n-            &[\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\\u{1F1EA}\"]),\n-            (\"\\u{1F1F7}\\u{1F1FA}\\u{200B}\\u{1F1F8}\\u{1F1EA}\",\n-             &[\"\\u{1F1F7}\\u{1F1FA}\", \"\\u{200B}\", \"\\u{1F1F8}\\u{1F1EA}\"]),\n-            (\"\\u{1F1E6}\\u{1F1E7}\\u{1F1E8}\", &[\"\\u{1F1E6}\\u{1F1E7}\\u{1F1E8}\"]),\n-            (\"\\u{1F1E6}\\u{200D}\\u{1F1E7}\\u{1F1E8}\", &[\"\\u{1F1E6}\\u{200D}\",\n-             \"\\u{1F1E7}\\u{1F1E8}\"]),\n-            (\"\\u{1F1E6}\\u{1F1E7}\\u{200D}\\u{1F1E8}\",\n-             &[\"\\u{1F1E6}\\u{1F1E7}\\u{200D}\", \"\\u{1F1E8}\"]),\n-            (\"\\u{20}\\u{200D}\\u{646}\", &[\"\\u{20}\\u{200D}\", \"\\u{646}\"]),\n-            (\"\\u{646}\\u{200D}\\u{20}\", &[\"\\u{646}\\u{200D}\", \"\\u{20}\"]),\n-        ];\n-\n-        let test_diff: [(_, &[_], &[_]); 23] = [\n-            (\"\\u{20}\\u{903}\", &[\"\\u{20}\\u{903}\"], &[\"\\u{20}\", \"\\u{903}\"]), (\"\\u{20}\\u{308}\\u{903}\",\n-            &[\"\\u{20}\\u{308}\\u{903}\"], &[\"\\u{20}\\u{308}\", \"\\u{903}\"]), (\"\\u{D}\\u{308}\\u{903}\",\n-            &[\"\\u{D}\", \"\\u{308}\\u{903}\"], &[\"\\u{D}\", \"\\u{308}\", \"\\u{903}\"]), (\"\\u{A}\\u{308}\\u{903}\",\n-            &[\"\\u{A}\", \"\\u{308}\\u{903}\"], &[\"\\u{A}\", \"\\u{308}\", \"\\u{903}\"]), (\"\\u{1}\\u{308}\\u{903}\",\n-            &[\"\\u{1}\", \"\\u{308}\\u{903}\"], &[\"\\u{1}\", \"\\u{308}\", \"\\u{903}\"]), (\"\\u{300}\\u{903}\",\n-            &[\"\\u{300}\\u{903}\"], &[\"\\u{300}\", \"\\u{903}\"]), (\"\\u{300}\\u{308}\\u{903}\",\n-            &[\"\\u{300}\\u{308}\\u{903}\"], &[\"\\u{300}\\u{308}\", \"\\u{903}\"]), (\"\\u{903}\\u{903}\",\n-            &[\"\\u{903}\\u{903}\"], &[\"\\u{903}\", \"\\u{903}\"]), (\"\\u{903}\\u{308}\\u{903}\",\n-            &[\"\\u{903}\\u{308}\\u{903}\"], &[\"\\u{903}\\u{308}\", \"\\u{903}\"]), (\"\\u{1100}\\u{903}\",\n-            &[\"\\u{1100}\\u{903}\"], &[\"\\u{1100}\", \"\\u{903}\"]), (\"\\u{1100}\\u{308}\\u{903}\",\n-            &[\"\\u{1100}\\u{308}\\u{903}\"], &[\"\\u{1100}\\u{308}\", \"\\u{903}\"]), (\"\\u{1160}\\u{903}\",\n-            &[\"\\u{1160}\\u{903}\"], &[\"\\u{1160}\", \"\\u{903}\"]), (\"\\u{1160}\\u{308}\\u{903}\",\n-            &[\"\\u{1160}\\u{308}\\u{903}\"], &[\"\\u{1160}\\u{308}\", \"\\u{903}\"]), (\"\\u{11A8}\\u{903}\",\n-            &[\"\\u{11A8}\\u{903}\"], &[\"\\u{11A8}\", \"\\u{903}\"]), (\"\\u{11A8}\\u{308}\\u{903}\",\n-            &[\"\\u{11A8}\\u{308}\\u{903}\"], &[\"\\u{11A8}\\u{308}\", \"\\u{903}\"]), (\"\\u{AC00}\\u{903}\",\n-            &[\"\\u{AC00}\\u{903}\"], &[\"\\u{AC00}\", \"\\u{903}\"]), (\"\\u{AC00}\\u{308}\\u{903}\",\n-            &[\"\\u{AC00}\\u{308}\\u{903}\"], &[\"\\u{AC00}\\u{308}\", \"\\u{903}\"]), (\"\\u{AC01}\\u{903}\",\n-            &[\"\\u{AC01}\\u{903}\"], &[\"\\u{AC01}\", \"\\u{903}\"]), (\"\\u{AC01}\\u{308}\\u{903}\",\n-            &[\"\\u{AC01}\\u{308}\\u{903}\"], &[\"\\u{AC01}\\u{308}\", \"\\u{903}\"]), (\"\\u{1F1E6}\\u{903}\",\n-            &[\"\\u{1F1E6}\\u{903}\"], &[\"\\u{1F1E6}\", \"\\u{903}\"]), (\"\\u{1F1E6}\\u{308}\\u{903}\",\n-            &[\"\\u{1F1E6}\\u{308}\\u{903}\"], &[\"\\u{1F1E6}\\u{308}\", \"\\u{903}\"]), (\"\\u{378}\\u{903}\",\n-            &[\"\\u{378}\\u{903}\"], &[\"\\u{378}\", \"\\u{903}\"]), (\"\\u{378}\\u{308}\\u{903}\",\n-            &[\"\\u{378}\\u{308}\\u{903}\"], &[\"\\u{378}\\u{308}\", \"\\u{903}\"]),\n-        ];\n-\n-        for &(s, g) in &test_same[..] {\n-            // test forward iterator\n-            assert!(order::equals(s.graphemes(true), g.iter().cloned()));\n-            assert!(order::equals(s.graphemes(false), g.iter().cloned()));\n-\n-            // test reverse iterator\n-            assert!(order::equals(s.graphemes(true).rev(), g.iter().rev().cloned()));\n-            assert!(order::equals(s.graphemes(false).rev(), g.iter().rev().cloned()));\n-        }\n-\n-        for &(s, gt, gf) in &test_diff {\n-            // test forward iterator\n-            assert!(order::equals(s.graphemes(true), gt.iter().cloned()));\n-            assert!(order::equals(s.graphemes(false), gf.iter().cloned()));\n-\n-            // test reverse iterator\n-            assert!(order::equals(s.graphemes(true).rev(), gt.iter().rev().cloned()));\n-            assert!(order::equals(s.graphemes(false).rev(), gf.iter().rev().cloned()));\n-        }\n-\n-        // test the indices iterators\n-        let s = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n-        let gr_inds = s.grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n-        let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n-        assert_eq!(gr_inds, b);\n-        let gr_inds = s.grapheme_indices(true).rev().collect::<Vec<(usize, &str)>>();\n-        let b: &[_] = &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0, \"a\u0310\")];\n-        assert_eq!(gr_inds, b);\n-        let mut gr_inds_iter = s.grapheme_indices(true);\n-        {\n-            let gr_inds = gr_inds_iter.by_ref();\n-            let e1 = gr_inds.size_hint();\n-            assert_eq!(e1, (1, Some(13)));\n-            let c = gr_inds.count();\n-            assert_eq!(c, 4);\n-        }\n-        let e2 = gr_inds_iter.size_hint();\n-        assert_eq!(e2, (0, Some(0)));\n-\n-        // make sure the reverse iterator does the right thing with \"\\n\" at beginning of string\n-        let s = \"\\n\\r\\n\\r\";\n-        let gr = s.graphemes(true).rev().collect::<Vec<&str>>();\n-        let b: &[_] = &[\"\\r\", \"\\r\\n\", \"\\n\"];\n-        assert_eq!(gr, b);\n-    }\n-\n-    #[test]\n-    fn test_split_strator() {\n-        fn t(s: &str, sep: &str, u: &[&str]) {\n-            let v: Vec<&str> = s.split_str(sep).collect();\n-            assert_eq!(v, u);\n-        }\n-        t(\"--1233345--\", \"12345\", &[\"--1233345--\"]);\n-        t(\"abc::hello::there\", \"::\", &[\"abc\", \"hello\", \"there\"]);\n-        t(\"::hello::there\", \"::\", &[\"\", \"hello\", \"there\"]);\n-        t(\"hello::there::\", \"::\", &[\"hello\", \"there\", \"\"]);\n-        t(\"::hello::there::\", \"::\", &[\"\", \"hello\", \"there\", \"\"]);\n-        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", &[\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]);\n-        t(\"zzXXXzzYYYzz\", \"zz\", &[\"\", \"XXX\", \"YYY\", \"\"]);\n-        t(\"zzXXXzYYYz\", \"XXX\", &[\"zz\", \"zYYYz\"]);\n-        t(\".XXX.YYY.\", \".\", &[\"\", \"XXX\", \"YYY\", \"\"]);\n-        t(\"\", \".\", &[\"\"]);\n-        t(\"zz\", \"zz\", &[\"\",\"\"]);\n-        t(\"ok\", \"z\", &[\"ok\"]);\n-        t(\"zzz\", \"zz\", &[\"\",\"z\"]);\n-        t(\"zzzzz\", \"zz\", &[\"\",\"\",\"z\"]);\n-    }\n-\n-    #[test]\n-    fn test_str_default() {\n-        use core::default::Default;\n-        fn t<S: Default + Str>() {\n-            let s: S = Default::default();\n-            assert_eq!(s.as_slice(), \"\");\n-        }\n-\n-        t::<&str>();\n-        t::<String>();\n-    }\n-\n-    #[test]\n-    fn test_str_container() {\n-        fn sum_len(v: &[&str]) -> usize {\n-            v.iter().map(|x| x.len()).sum()\n-        }\n-\n-        let s = String::from_str(\"01234\");\n-        assert_eq!(5, sum_len(&[\"012\", \"\", \"34\"]));\n-        assert_eq!(5, sum_len(&[&String::from_str(\"01\"),\n-                                &String::from_str(\"2\"),\n-                                &String::from_str(\"34\"),\n-                                &String::from_str(\"\")]));\n-        assert_eq!(5, sum_len(&[&s]));\n-    }\n-\n-    #[test]\n-    fn test_str_from_utf8() {\n-        let xs = b\"hello\";\n-        assert_eq!(from_utf8(xs), Ok(\"hello\"));\n-\n-        let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        assert_eq!(from_utf8(xs), Ok(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n-\n-        let xs = b\"hello\\xFF\";\n-        assert_eq!(from_utf8(xs), Err(Utf8Error::TooShort));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    use super::*;\n-    use prelude::{SliceExt, IteratorExt, SliceConcatExt};\n-    use test::Bencher;\n-    use test::black_box;\n-\n-    #[bench]\n-    fn char_iterator(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| s.chars().count());\n-    }\n-\n-    #[bench]\n-    fn char_iterator_for(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| {\n-            for ch in s.chars() { black_box(ch); }\n-        });\n-    }\n-\n-    #[bench]\n-    fn char_iterator_ascii(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| s.chars().count());\n-    }\n-\n-    #[bench]\n-    fn char_iterator_rev(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| s.chars().rev().count());\n-    }\n-\n-    #[bench]\n-    fn char_iterator_rev_for(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| {\n-            for ch in s.chars().rev() { black_box(ch); }\n-        });\n-    }\n-\n-    #[bench]\n-    fn char_indicesator(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let len = s.chars().count();\n-\n-        b.iter(|| assert_eq!(s.char_indices().count(), len));\n-    }\n-\n-    #[bench]\n-    fn char_indicesator_rev(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let len = s.chars().count();\n-\n-        b.iter(|| assert_eq!(s.char_indices().rev().count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_unicode_ascii(b: &mut Bencher) {\n-        let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-\n-        b.iter(|| assert_eq!(s.split('V').count(), 3));\n-    }\n-\n-    #[bench]\n-    fn split_ascii(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-\n-        b.iter(|| assert_eq!(s.split(' ').count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_extern_fn(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-        fn pred(c: char) -> bool { c == ' ' }\n-\n-        b.iter(|| assert_eq!(s.split(pred).count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_closure(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-\n-        b.iter(|| assert_eq!(s.split(|c: char| c == ' ').count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_slice(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-\n-        let c: &[char] = &[' '];\n-        b.iter(|| assert_eq!(s.split(c).count(), len));\n-    }\n-\n-    #[bench]\n-    fn bench_connect(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let sep = \"\u2192\";\n-        let v = vec![s, s, s, s, s, s, s, s, s, s];\n-        b.iter(|| {\n-            assert_eq!(v.connect(sep).len(), s.len() * 10 + sep.len() * 9);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_short_short(b: &mut Bencher) {\n-        let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n-        let needle = \"sit\";\n-\n-        b.iter(|| {\n-            assert!(haystack.contains(needle));\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_short_long(b: &mut Bencher) {\n-        let haystack = \"\\\n-Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n-ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n-eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n-sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n-tempus vel, gravida nec quam.\n-\n-In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n-sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n-diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n-lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n-eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n-interdum. Curabitur ut nisi justo.\n-\n-Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n-mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n-lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n-est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n-felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n-ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n-feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n-Aliquam sit amet placerat lorem.\n-\n-Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n-mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n-Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n-lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n-suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n-cursus accumsan.\n-\n-Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n-feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n-vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n-leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n-malesuada sollicitudin quam eu fermentum.\";\n-        let needle = \"english\";\n-\n-        b.iter(|| {\n-            assert!(!haystack.contains(needle));\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_bad_naive(b: &mut Bencher) {\n-        let haystack = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n-        let needle = \"aaaaaaaab\";\n-\n-        b.iter(|| {\n-            assert!(!haystack.contains(needle));\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_equal(b: &mut Bencher) {\n-        let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n-        let needle = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n-\n-        b.iter(|| {\n-            assert!(haystack.contains(needle));\n-        })\n-    }\n-}"}, {"sha": "6d1b929cf601ce90299d4bcbfef09869c3dd1ecc", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 447, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -1014,450 +1014,3 @@ impl fmt::Write for String {\n         Ok(())\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use test::Bencher;\n-\n-    use str::Utf8Error;\n-    use core::iter::repeat;\n-    use super::{as_string, CowString};\n-\n-    #[test]\n-    fn test_as_string() {\n-        let x = \"foo\";\n-        assert_eq!(x, &**as_string(x));\n-    }\n-\n-    #[test]\n-    fn test_from_str() {\n-      let owned: Option<::std::string::String> = \"string\".parse().ok();\n-      assert_eq!(owned.as_ref().map(|s| &**s), Some(\"string\"));\n-    }\n-\n-    #[test]\n-    fn test_unsized_to_string() {\n-        let s: &str = \"abc\";\n-        let _: String = (*s).to_string();\n-    }\n-\n-    #[test]\n-    fn test_from_utf8() {\n-        let xs = b\"hello\".to_vec();\n-        assert_eq!(String::from_utf8(xs).unwrap(),\n-                   String::from_str(\"hello\"));\n-\n-        let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes().to_vec();\n-        assert_eq!(String::from_utf8(xs).unwrap(),\n-                   String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n-\n-        let xs = b\"hello\\xFF\".to_vec();\n-        let err = String::from_utf8(xs).err().unwrap();\n-        assert_eq!(err.utf8_error(), Utf8Error::TooShort);\n-        assert_eq!(err.into_bytes(), b\"hello\\xff\".to_vec());\n-    }\n-\n-    #[test]\n-    fn test_from_utf8_lossy() {\n-        let xs = b\"hello\";\n-        let ys: CowString = \"hello\".into_cow();\n-        assert_eq!(String::from_utf8_lossy(xs), ys);\n-\n-        let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        let ys: CowString = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow();\n-        assert_eq!(String::from_utf8_lossy(xs), ys);\n-\n-        let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n-        assert_eq!(String::from_utf8_lossy(xs),\n-                   String::from_str(\"Hello\\u{FFFD} There\\u{FFFD} Goodbye\").into_cow());\n-\n-        let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n-        assert_eq!(String::from_utf8_lossy(xs),\n-                   String::from_str(\"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\").into_cow());\n-\n-        let xs = b\"\\xF5foo\\xF5\\x80bar\";\n-        assert_eq!(String::from_utf8_lossy(xs),\n-                   String::from_str(\"\\u{FFFD}foo\\u{FFFD}\\u{FFFD}bar\").into_cow());\n-\n-        let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n-        assert_eq!(String::from_utf8_lossy(xs),\n-                   String::from_str(\"\\u{FFFD}foo\\u{FFFD}bar\\u{FFFD}baz\").into_cow());\n-\n-        let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n-        assert_eq!(String::from_utf8_lossy(xs),\n-                   String::from_str(\"\\u{FFFD}foo\\u{FFFD}bar\\u{FFFD}\\u{FFFD}baz\").into_cow());\n-\n-        let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n-        assert_eq!(String::from_utf8_lossy(xs), String::from_str(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}\\u{FFFD}\\\n-                                               foo\\u{10000}bar\").into_cow());\n-\n-        // surrogates\n-        let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n-        assert_eq!(String::from_utf8_lossy(xs), String::from_str(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}foo\\\n-                                               \\u{FFFD}\\u{FFFD}\\u{FFFD}bar\").into_cow());\n-    }\n-\n-    #[test]\n-    fn test_from_utf16() {\n-        let pairs =\n-            [(String::from_str(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\"),\n-              vec![0xd800, 0xdf45, 0xd800, 0xdf3f,\n-                0xd800, 0xdf3b, 0xd800, 0xdf46,\n-                0xd800, 0xdf39, 0xd800, 0xdf3b,\n-                0xd800, 0xdf30, 0x000a]),\n-\n-             (String::from_str(\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\"),\n-              vec![0xd801, 0xdc12, 0xd801,\n-                0xdc49, 0xd801, 0xdc2e, 0xd801,\n-                0xdc40, 0xd801, 0xdc32, 0xd801,\n-                0xdc4b, 0x0020, 0xd801, 0xdc0f,\n-                0xd801, 0xdc32, 0xd801, 0xdc4d,\n-                0x000a]),\n-\n-             (String::from_str(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\"),\n-              vec![0xd800, 0xdf00, 0xd800, 0xdf16,\n-                0xd800, 0xdf0b, 0xd800, 0xdf04,\n-                0xd800, 0xdf11, 0xd800, 0xdf09,\n-                0x00b7, 0xd800, 0xdf0c, 0xd800,\n-                0xdf04, 0xd800, 0xdf15, 0xd800,\n-                0xdf04, 0xd800, 0xdf0b, 0xd800,\n-                0xdf09, 0xd800, 0xdf11, 0x000a ]),\n-\n-             (String::from_str(\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\"),\n-              vec![0xd801, 0xdc8b, 0xd801, 0xdc98,\n-                0xd801, 0xdc88, 0xd801, 0xdc91,\n-                0xd801, 0xdc9b, 0xd801, 0xdc92,\n-                0x0020, 0xd801, 0xdc95, 0xd801,\n-                0xdc93, 0x0020, 0xd801, 0xdc88,\n-                0xd801, 0xdc9a, 0xd801, 0xdc8d,\n-                0x0020, 0xd801, 0xdc8f, 0xd801,\n-                0xdc9c, 0xd801, 0xdc92, 0xd801,\n-                0xdc96, 0xd801, 0xdc86, 0x0020,\n-                0xd801, 0xdc95, 0xd801, 0xdc86,\n-                0x000a ]),\n-             // Issue #12318, even-numbered non-BMP planes\n-             (String::from_str(\"\\u{20000}\"),\n-              vec![0xD840, 0xDC00])];\n-\n-        for p in &pairs {\n-            let (s, u) = (*p).clone();\n-            let s_as_utf16 = s.utf16_units().collect::<Vec<u16>>();\n-            let u_as_string = String::from_utf16(&u).unwrap();\n-\n-            assert!(::unicode::str::is_utf16(&u));\n-            assert_eq!(s_as_utf16, u);\n-\n-            assert_eq!(u_as_string, s);\n-            assert_eq!(String::from_utf16_lossy(&u), s);\n-\n-            assert_eq!(String::from_utf16(&s_as_utf16).unwrap(), s);\n-            assert_eq!(u_as_string.utf16_units().collect::<Vec<u16>>(), u);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_utf16_invalid() {\n-        // completely positive cases tested above.\n-        // lead + eof\n-        assert!(String::from_utf16(&[0xD800]).is_err());\n-        // lead + lead\n-        assert!(String::from_utf16(&[0xD800, 0xD800]).is_err());\n-\n-        // isolated trail\n-        assert!(String::from_utf16(&[0x0061, 0xDC00]).is_err());\n-\n-        // general\n-        assert!(String::from_utf16(&[0xD800, 0xd801, 0xdc8b, 0xD800]).is_err());\n-    }\n-\n-    #[test]\n-    fn test_from_utf16_lossy() {\n-        // completely positive cases tested above.\n-        // lead + eof\n-        assert_eq!(String::from_utf16_lossy(&[0xD800]), String::from_str(\"\\u{FFFD}\"));\n-        // lead + lead\n-        assert_eq!(String::from_utf16_lossy(&[0xD800, 0xD800]),\n-                   String::from_str(\"\\u{FFFD}\\u{FFFD}\"));\n-\n-        // isolated trail\n-        assert_eq!(String::from_utf16_lossy(&[0x0061, 0xDC00]), String::from_str(\"a\\u{FFFD}\"));\n-\n-        // general\n-        assert_eq!(String::from_utf16_lossy(&[0xD800, 0xd801, 0xdc8b, 0xD800]),\n-                   String::from_str(\"\\u{FFFD}\ud801\udc8b\\u{FFFD}\"));\n-    }\n-\n-    #[test]\n-    fn test_push_bytes() {\n-        let mut s = String::from_str(\"ABC\");\n-        unsafe {\n-            let mv = s.as_mut_vec();\n-            mv.push_all(&[b'D']);\n-        }\n-        assert_eq!(s, \"ABCD\");\n-    }\n-\n-    #[test]\n-    fn test_push_str() {\n-        let mut s = String::new();\n-        s.push_str(\"\");\n-        assert_eq!(&s[0..], \"\");\n-        s.push_str(\"abc\");\n-        assert_eq!(&s[0..], \"abc\");\n-        s.push_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(&s[0..], \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-    }\n-\n-    #[test]\n-    fn test_push() {\n-        let mut data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n-        data.push('\u534e');\n-        data.push('b'); // 1 byte\n-        data.push('\u00a2'); // 2 byte\n-        data.push('\u20ac'); // 3 byte\n-        data.push('\ud852\udf62'); // 4 byte\n-        assert_eq!(data, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n-    }\n-\n-    #[test]\n-    fn test_pop() {\n-        let mut data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n-        assert_eq!(data.pop().unwrap(), '\ud852\udf62'); // 4 bytes\n-        assert_eq!(data.pop().unwrap(), '\u20ac'); // 3 bytes\n-        assert_eq!(data.pop().unwrap(), '\u00a2'); // 2 bytes\n-        assert_eq!(data.pop().unwrap(), 'b'); // 1 bytes\n-        assert_eq!(data.pop().unwrap(), '\u534e');\n-        assert_eq!(data, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n-    }\n-\n-    #[test]\n-    fn test_str_truncate() {\n-        let mut s = String::from_str(\"12345\");\n-        s.truncate(5);\n-        assert_eq!(s, \"12345\");\n-        s.truncate(3);\n-        assert_eq!(s, \"123\");\n-        s.truncate(0);\n-        assert_eq!(s, \"\");\n-\n-        let mut s = String::from_str(\"12345\");\n-        let p = s.as_ptr();\n-        s.truncate(3);\n-        s.push_str(\"6\");\n-        let p_ = s.as_ptr();\n-        assert_eq!(p_, p);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_str_truncate_invalid_len() {\n-        let mut s = String::from_str(\"12345\");\n-        s.truncate(6);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_str_truncate_split_codepoint() {\n-        let mut s = String::from_str(\"\\u{FC}\"); // \u00fc\n-        s.truncate(1);\n-    }\n-\n-    #[test]\n-    fn test_str_clear() {\n-        let mut s = String::from_str(\"12345\");\n-        s.clear();\n-        assert_eq!(s.len(), 0);\n-        assert_eq!(s, \"\");\n-    }\n-\n-    #[test]\n-    fn test_str_add() {\n-        let a = String::from_str(\"12345\");\n-        let b = a + \"2\";\n-        let b = b + \"2\";\n-        assert_eq!(b.len(), 7);\n-        assert_eq!(b, \"1234522\");\n-    }\n-\n-    #[test]\n-    fn remove() {\n-        let mut s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\".to_string();;\n-        assert_eq!(s.remove(0), '\u0e28');\n-        assert_eq!(s.len(), 33);\n-        assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n-        assert_eq!(s.remove(17), '\u1ec7');\n-        assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n-    }\n-\n-    #[test] #[should_panic]\n-    fn remove_bad() {\n-        \"\u0e28\".to_string().remove(1);\n-    }\n-\n-    #[test]\n-    fn insert() {\n-        let mut s = \"foobar\".to_string();\n-        s.insert(0, '\u1ec7');\n-        assert_eq!(s, \"\u1ec7foobar\");\n-        s.insert(6, '\u0e22');\n-        assert_eq!(s, \"\u1ec7foo\u0e22bar\");\n-    }\n-\n-    #[test] #[should_panic] fn insert_bad1() { \"\".to_string().insert(1, 't'); }\n-    #[test] #[should_panic] fn insert_bad2() { \"\u1ec7\".to_string().insert(1, 't'); }\n-\n-    #[test]\n-    fn test_slicing() {\n-        let s = \"foobar\".to_string();\n-        assert_eq!(\"foobar\", &s[..]);\n-        assert_eq!(\"foo\", &s[..3]);\n-        assert_eq!(\"bar\", &s[3..]);\n-        assert_eq!(\"oob\", &s[1..4]);\n-    }\n-\n-    #[test]\n-    fn test_simple_types() {\n-        assert_eq!(1.to_string(), \"1\");\n-        assert_eq!((-1).to_string(), \"-1\");\n-        assert_eq!(200.to_string(), \"200\");\n-        assert_eq!(2.to_string(), \"2\");\n-        assert_eq!(true.to_string(), \"true\");\n-        assert_eq!(false.to_string(), \"false\");\n-        assert_eq!((\"hi\".to_string()).to_string(), \"hi\");\n-    }\n-\n-    #[test]\n-    fn test_vectors() {\n-        let x: Vec<i32> = vec![];\n-        assert_eq!(format!(\"{:?}\", x), \"[]\");\n-        assert_eq!(format!(\"{:?}\", vec![1]), \"[1]\");\n-        assert_eq!(format!(\"{:?}\", vec![1, 2, 3]), \"[1, 2, 3]\");\n-        assert!(format!(\"{:?}\", vec![vec![], vec![1], vec![1, 1]]) ==\n-               \"[[], [1], [1, 1]]\");\n-    }\n-\n-    #[test]\n-    fn test_from_iterator() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_string();\n-        let t = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let u = \"Vi\u1ec7t Nam\";\n-\n-        let a: String = s.chars().collect();\n-        assert_eq!(s, a);\n-\n-        let mut b = t.to_string();\n-        b.extend(u.chars());\n-        assert_eq!(s, b);\n-\n-        let c: String = vec![t, u].into_iter().collect();\n-        assert_eq!(s, c);\n-\n-        let mut d = t.to_string();\n-        d.extend(vec![u].into_iter());\n-        assert_eq!(s, d);\n-    }\n-\n-    #[bench]\n-    fn bench_with_capacity(b: &mut Bencher) {\n-        b.iter(|| {\n-            String::with_capacity(100)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_push_str(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        b.iter(|| {\n-            let mut r = String::new();\n-            r.push_str(s);\n-        });\n-    }\n-\n-    const REPETITIONS: u64 = 10_000;\n-\n-    #[bench]\n-    fn bench_push_str_one_byte(b: &mut Bencher) {\n-        b.bytes = REPETITIONS;\n-        b.iter(|| {\n-            let mut r = String::new();\n-            for _ in 0..REPETITIONS {\n-                r.push_str(\"a\")\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_push_char_one_byte(b: &mut Bencher) {\n-        b.bytes = REPETITIONS;\n-        b.iter(|| {\n-            let mut r = String::new();\n-            for _ in 0..REPETITIONS {\n-                r.push('a')\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_push_char_two_bytes(b: &mut Bencher) {\n-        b.bytes = REPETITIONS * 2;\n-        b.iter(|| {\n-            let mut r = String::new();\n-            for _ in 0..REPETITIONS {\n-                r.push('\u00e2')\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n-        let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n-                  Lorem ipsum dolor sit amet, consectetur. \";\n-\n-        assert_eq!(100, s.len());\n-        b.iter(|| {\n-            let _ = String::from_utf8_lossy(s);\n-        });\n-    }\n-\n-    #[bench]\n-    fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n-        let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n-        assert_eq!(100, s.len());\n-        b.iter(|| {\n-            let _ = String::from_utf8_lossy(s);\n-        });\n-    }\n-\n-    #[bench]\n-    fn from_utf8_lossy_invalid(b: &mut Bencher) {\n-        let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n-        b.iter(|| {\n-            let _ = String::from_utf8_lossy(s);\n-        });\n-    }\n-\n-    #[bench]\n-    fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n-        let s = repeat(0xf5).take(100).collect::<Vec<_>>();\n-        b.iter(|| {\n-            let _ = String::from_utf8_lossy(&s);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_exact_size_shrink_to_fit(b: &mut Bencher) {\n-        let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n-                 Lorem ipsum dolor sit amet, consectetur. \";\n-        // ensure our operation produces an exact-size string before we benchmark it\n-        let mut r = String::with_capacity(s.len());\n-        r.push_str(s);\n-        assert_eq!(r.len(), r.capacity());\n-        b.iter(|| {\n-            let mut r = String::with_capacity(s.len());\n-            r.push_str(s);\n-            r.shrink_to_fit();\n-            r\n-        });\n-    }\n-}"}, {"sha": "22da0a191ca2474834d67035ae231d0330a1d568", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 988, "changes": 988, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -1951,991 +1951,3 @@ impl<T,U> Drop for PartialVecZeroSized<T,U> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use core::mem::size_of;\n-    use core::iter::repeat;\n-    use test::Bencher;\n-    use super::as_vec;\n-\n-    struct DropCounter<'a> {\n-        count: &'a mut u32\n-    }\n-\n-    #[unsafe_destructor]\n-    impl<'a> Drop for DropCounter<'a> {\n-        fn drop(&mut self) {\n-            *self.count += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_as_vec() {\n-        let xs = [1u8, 2u8, 3u8];\n-        assert_eq!(&**as_vec(&xs), xs);\n-    }\n-\n-    #[test]\n-    fn test_as_vec_dtor() {\n-        let (mut count_x, mut count_y) = (0, 0);\n-        {\n-            let xs = &[DropCounter { count: &mut count_x }, DropCounter { count: &mut count_y }];\n-            assert_eq!(as_vec(xs).len(), 2);\n-        }\n-        assert_eq!(count_x, 1);\n-        assert_eq!(count_y, 1);\n-    }\n-\n-    #[test]\n-    fn test_small_vec_struct() {\n-        assert!(size_of::<Vec<u8>>() == size_of::<usize>() * 3);\n-    }\n-\n-    #[test]\n-    fn test_double_drop() {\n-        struct TwoVec<T> {\n-            x: Vec<T>,\n-            y: Vec<T>\n-        }\n-\n-        let (mut count_x, mut count_y) = (0, 0);\n-        {\n-            let mut tv = TwoVec {\n-                x: Vec::new(),\n-                y: Vec::new()\n-            };\n-            tv.x.push(DropCounter {count: &mut count_x});\n-            tv.y.push(DropCounter {count: &mut count_y});\n-\n-            // If Vec had a drop flag, here is where it would be zeroed.\n-            // Instead, it should rely on its internal state to prevent\n-            // doing anything significant when dropped multiple times.\n-            drop(tv.x);\n-\n-            // Here tv goes out of scope, tv.y should be dropped, but not tv.x.\n-        }\n-\n-        assert_eq!(count_x, 1);\n-        assert_eq!(count_y, 1);\n-    }\n-\n-    #[test]\n-    fn test_reserve() {\n-        let mut v = Vec::new();\n-        assert_eq!(v.capacity(), 0);\n-\n-        v.reserve(2);\n-        assert!(v.capacity() >= 2);\n-\n-        for i in 0..16 {\n-            v.push(i);\n-        }\n-\n-        assert!(v.capacity() >= 16);\n-        v.reserve(16);\n-        assert!(v.capacity() >= 32);\n-\n-        v.push(16);\n-\n-        v.reserve(16);\n-        assert!(v.capacity() >= 33)\n-    }\n-\n-    #[test]\n-    fn test_extend() {\n-        let mut v = Vec::new();\n-        let mut w = Vec::new();\n-\n-        v.extend(0..3);\n-        for i in 0..3 { w.push(i) }\n-\n-        assert_eq!(v, w);\n-\n-        v.extend(3..10);\n-        for i in 3..10 { w.push(i) }\n-\n-        assert_eq!(v, w);\n-    }\n-\n-    #[test]\n-    fn test_slice_from_mut() {\n-        let mut values = vec![1, 2, 3, 4, 5];\n-        {\n-            let slice = &mut values[2 ..];\n-            assert!(slice == [3, 4, 5]);\n-            for p in slice {\n-                *p += 2;\n-            }\n-        }\n-\n-        assert!(values == [1, 2, 5, 6, 7]);\n-    }\n-\n-    #[test]\n-    fn test_slice_to_mut() {\n-        let mut values = vec![1, 2, 3, 4, 5];\n-        {\n-            let slice = &mut values[.. 2];\n-            assert!(slice == [1, 2]);\n-            for p in slice {\n-                *p += 1;\n-            }\n-        }\n-\n-        assert!(values == [2, 3, 3, 4, 5]);\n-    }\n-\n-    #[test]\n-    fn test_split_at_mut() {\n-        let mut values = vec![1, 2, 3, 4, 5];\n-        {\n-            let (left, right) = values.split_at_mut(2);\n-            {\n-                let left: &[_] = left;\n-                assert!(&left[..left.len()] == &[1, 2]);\n-            }\n-            for p in left {\n-                *p += 1;\n-            }\n-\n-            {\n-                let right: &[_] = right;\n-                assert!(&right[..right.len()] == &[3, 4, 5]);\n-            }\n-            for p in right {\n-                *p += 2;\n-            }\n-        }\n-\n-        assert_eq!(values, [2, 3, 5, 6, 7]);\n-    }\n-\n-    #[test]\n-    fn test_clone() {\n-        let v: Vec<i32> = vec![];\n-        let w = vec!(1, 2, 3);\n-\n-        assert_eq!(v, v.clone());\n-\n-        let z = w.clone();\n-        assert_eq!(w, z);\n-        // they should be disjoint in memory.\n-        assert!(w.as_ptr() != z.as_ptr())\n-    }\n-\n-    #[test]\n-    fn test_clone_from() {\n-        let mut v = vec!();\n-        let three: Vec<Box<_>> = vec!(box 1, box 2, box 3);\n-        let two: Vec<Box<_>> = vec!(box 4, box 5);\n-        // zero, long\n-        v.clone_from(&three);\n-        assert_eq!(v, three);\n-\n-        // equal\n-        v.clone_from(&three);\n-        assert_eq!(v, three);\n-\n-        // long, short\n-        v.clone_from(&two);\n-        assert_eq!(v, two);\n-\n-        // short, long\n-        v.clone_from(&three);\n-        assert_eq!(v, three)\n-    }\n-\n-    #[test]\n-    fn test_retain() {\n-        let mut vec = vec![1, 2, 3, 4];\n-        vec.retain(|&x| x % 2 == 0);\n-        assert_eq!(vec, [2, 4]);\n-    }\n-\n-    #[test]\n-    fn zero_sized_values() {\n-        let mut v = Vec::new();\n-        assert_eq!(v.len(), 0);\n-        v.push(());\n-        assert_eq!(v.len(), 1);\n-        v.push(());\n-        assert_eq!(v.len(), 2);\n-        assert_eq!(v.pop(), Some(()));\n-        assert_eq!(v.pop(), Some(()));\n-        assert_eq!(v.pop(), None);\n-\n-        assert_eq!(v.iter().count(), 0);\n-        v.push(());\n-        assert_eq!(v.iter().count(), 1);\n-        v.push(());\n-        assert_eq!(v.iter().count(), 2);\n-\n-        for &() in &v {}\n-\n-        assert_eq!(v.iter_mut().count(), 2);\n-        v.push(());\n-        assert_eq!(v.iter_mut().count(), 3);\n-        v.push(());\n-        assert_eq!(v.iter_mut().count(), 4);\n-\n-        for &mut () in &mut v {}\n-        unsafe { v.set_len(0); }\n-        assert_eq!(v.iter_mut().count(), 0);\n-    }\n-\n-    #[test]\n-    fn test_partition() {\n-        assert_eq!(vec![].into_iter().partition(|x: &i32| *x < 3), (vec![], vec![]));\n-        assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 0), (vec![], vec![1, 2, 3]));\n-    }\n-\n-    #[test]\n-    fn test_zip_unzip() {\n-        let z1 = vec![(1, 4), (2, 5), (3, 6)];\n-\n-        let (left, right): (Vec<_>, Vec<_>) = z1.iter().cloned().unzip();\n-\n-        assert_eq!((1, 4), (left[0], right[0]));\n-        assert_eq!((2, 5), (left[1], right[1]));\n-        assert_eq!((3, 6), (left[2], right[2]));\n-    }\n-\n-    #[test]\n-    fn test_unsafe_ptrs() {\n-        unsafe {\n-            // Test on-stack copy-from-buf.\n-            let a = [1, 2, 3];\n-            let ptr = a.as_ptr();\n-            let b = Vec::from_raw_buf(ptr, 3);\n-            assert_eq!(b, [1, 2, 3]);\n-\n-            // Test on-heap copy-from-buf.\n-            let c = vec![1, 2, 3, 4, 5];\n-            let ptr = c.as_ptr();\n-            let d = Vec::from_raw_buf(ptr, 5);\n-            assert_eq!(d, [1, 2, 3, 4, 5]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_vec_truncate_drop() {\n-        static mut drops: u32 = 0;\n-        struct Elem(i32);\n-        impl Drop for Elem {\n-            fn drop(&mut self) {\n-                unsafe { drops += 1; }\n-            }\n-        }\n-\n-        let mut v = vec![Elem(1), Elem(2), Elem(3), Elem(4), Elem(5)];\n-        assert_eq!(unsafe { drops }, 0);\n-        v.truncate(3);\n-        assert_eq!(unsafe { drops }, 2);\n-        v.truncate(0);\n-        assert_eq!(unsafe { drops }, 5);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_vec_truncate_fail() {\n-        struct BadElem(i32);\n-        impl Drop for BadElem {\n-            fn drop(&mut self) {\n-                let BadElem(ref mut x) = *self;\n-                if *x == 0xbadbeef {\n-                    panic!(\"BadElem panic: 0xbadbeef\")\n-                }\n-            }\n-        }\n-\n-        let mut v = vec![BadElem(1), BadElem(2), BadElem(0xbadbeef), BadElem(4)];\n-        v.truncate(0);\n-    }\n-\n-    #[test]\n-    fn test_index() {\n-        let vec = vec![1, 2, 3];\n-        assert!(vec[1] == 2);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_index_out_of_bounds() {\n-        let vec = vec![1, 2, 3];\n-        let _ = vec[3];\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_slice_out_of_bounds_1() {\n-        let x = vec![1, 2, 3, 4, 5];\n-        &x[-1..];\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_slice_out_of_bounds_2() {\n-        let x = vec![1, 2, 3, 4, 5];\n-        &x[..6];\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_slice_out_of_bounds_3() {\n-        let x = vec![1, 2, 3, 4, 5];\n-        &x[-1..4];\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_slice_out_of_bounds_4() {\n-        let x = vec![1, 2, 3, 4, 5];\n-        &x[1..6];\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_slice_out_of_bounds_5() {\n-        let x = vec![1, 2, 3, 4, 5];\n-        &x[3..2];\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_swap_remove_empty() {\n-        let mut vec= Vec::<i32>::new();\n-        vec.swap_remove(0);\n-    }\n-\n-    #[test]\n-    fn test_move_iter_unwrap() {\n-        let mut vec = Vec::with_capacity(7);\n-        vec.push(1);\n-        vec.push(2);\n-        let ptr = vec.as_ptr();\n-        vec = vec.into_iter().into_inner();\n-        assert_eq!(vec.as_ptr(), ptr);\n-        assert_eq!(vec.capacity(), 7);\n-        assert_eq!(vec.len(), 0);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_map_in_place_incompatible_types_fail() {\n-        let v = vec![0, 1, 2];\n-        v.map_in_place(|_| ());\n-    }\n-\n-    #[test]\n-    fn test_map_in_place() {\n-        let v = vec![0, 1, 2];\n-        assert_eq!(v.map_in_place(|i: u32| i as i32 - 1), [-1, 0, 1]);\n-    }\n-\n-    #[test]\n-    fn test_map_in_place_zero_sized() {\n-        let v = vec![(), ()];\n-        #[derive(PartialEq, Debug)]\n-        struct ZeroSized;\n-        assert_eq!(v.map_in_place(|_| ZeroSized), [ZeroSized, ZeroSized]);\n-    }\n-\n-    #[test]\n-    fn test_map_in_place_zero_drop_count() {\n-        use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n-\n-        #[derive(Clone, PartialEq, Debug)]\n-        struct Nothing;\n-        impl Drop for Nothing { fn drop(&mut self) { } }\n-\n-        #[derive(Clone, PartialEq, Debug)]\n-        struct ZeroSized;\n-        impl Drop for ZeroSized {\n-            fn drop(&mut self) {\n-                DROP_COUNTER.fetch_add(1, Ordering::Relaxed);\n-            }\n-        }\n-        const NUM_ELEMENTS: usize = 2;\n-        static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n-\n-        let v = repeat(Nothing).take(NUM_ELEMENTS).collect::<Vec<_>>();\n-\n-        DROP_COUNTER.store(0, Ordering::Relaxed);\n-\n-        let v = v.map_in_place(|_| ZeroSized);\n-        assert_eq!(DROP_COUNTER.load(Ordering::Relaxed), 0);\n-        drop(v);\n-        assert_eq!(DROP_COUNTER.load(Ordering::Relaxed), NUM_ELEMENTS);\n-    }\n-\n-    #[test]\n-    fn test_move_items() {\n-        let vec = vec![1, 2, 3];\n-        let mut vec2 = vec![];\n-        for i in vec {\n-            vec2.push(i);\n-        }\n-        assert_eq!(vec2, [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_move_items_reverse() {\n-        let vec = vec![1, 2, 3];\n-        let mut vec2 = vec![];\n-        for i in vec.into_iter().rev() {\n-            vec2.push(i);\n-        }\n-        assert_eq!(vec2, [3, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_move_items_zero_sized() {\n-        let vec = vec![(), (), ()];\n-        let mut vec2 = vec![];\n-        for i in vec {\n-            vec2.push(i);\n-        }\n-        assert_eq!(vec2, [(), (), ()]);\n-    }\n-\n-    #[test]\n-    fn test_drain_items() {\n-        let mut vec = vec![1, 2, 3];\n-        let mut vec2 = vec![];\n-        for i in vec.drain() {\n-            vec2.push(i);\n-        }\n-        assert_eq!(vec, []);\n-        assert_eq!(vec2, [ 1, 2, 3 ]);\n-    }\n-\n-    #[test]\n-    fn test_drain_items_reverse() {\n-        let mut vec = vec![1, 2, 3];\n-        let mut vec2 = vec![];\n-        for i in vec.drain().rev() {\n-            vec2.push(i);\n-        }\n-        assert_eq!(vec, []);\n-        assert_eq!(vec2, [3, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_drain_items_zero_sized() {\n-        let mut vec = vec![(), (), ()];\n-        let mut vec2 = vec![];\n-        for i in vec.drain() {\n-            vec2.push(i);\n-        }\n-        assert_eq!(vec, []);\n-        assert_eq!(vec2, [(), (), ()]);\n-    }\n-\n-    #[test]\n-    fn test_into_boxed_slice() {\n-        let xs = vec![1, 2, 3];\n-        let ys = xs.into_boxed_slice();\n-        assert_eq!(&*ys, [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_append() {\n-        let mut vec = vec![1, 2, 3];\n-        let mut vec2 = vec![4, 5, 6];\n-        vec.append(&mut vec2);\n-        assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n-        assert_eq!(vec2, []);\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        let mut vec = vec![1, 2, 3, 4, 5, 6];\n-        let vec2 = vec.split_off(4);\n-        assert_eq!(vec, [1, 2, 3, 4]);\n-        assert_eq!(vec2, [5, 6]);\n-    }\n-\n-    #[bench]\n-    fn bench_new(b: &mut Bencher) {\n-        b.iter(|| {\n-            let v: Vec<u32> = Vec::new();\n-            assert_eq!(v.len(), 0);\n-            assert_eq!(v.capacity(), 0);\n-        })\n-    }\n-\n-    fn do_bench_with_capacity(b: &mut Bencher, src_len: usize) {\n-        b.bytes = src_len as u64;\n-\n-        b.iter(|| {\n-            let v: Vec<u32> = Vec::with_capacity(src_len);\n-            assert_eq!(v.len(), 0);\n-            assert_eq!(v.capacity(), src_len);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_with_capacity_0000(b: &mut Bencher) {\n-        do_bench_with_capacity(b, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_with_capacity_0010(b: &mut Bencher) {\n-        do_bench_with_capacity(b, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_with_capacity_0100(b: &mut Bencher) {\n-        do_bench_with_capacity(b, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_with_capacity_1000(b: &mut Bencher) {\n-        do_bench_with_capacity(b, 1000)\n-    }\n-\n-    fn do_bench_from_fn(b: &mut Bencher, src_len: usize) {\n-        b.bytes = src_len as u64;\n-\n-        b.iter(|| {\n-            let dst = (0..src_len).collect::<Vec<_>>();\n-            assert_eq!(dst.len(), src_len);\n-            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_from_fn_0000(b: &mut Bencher) {\n-        do_bench_from_fn(b, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_from_fn_0010(b: &mut Bencher) {\n-        do_bench_from_fn(b, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_from_fn_0100(b: &mut Bencher) {\n-        do_bench_from_fn(b, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_from_fn_1000(b: &mut Bencher) {\n-        do_bench_from_fn(b, 1000)\n-    }\n-\n-    fn do_bench_from_elem(b: &mut Bencher, src_len: usize) {\n-        b.bytes = src_len as u64;\n-\n-        b.iter(|| {\n-            let dst: Vec<usize> = repeat(5).take(src_len).collect();\n-            assert_eq!(dst.len(), src_len);\n-            assert!(dst.iter().all(|x| *x == 5));\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_from_elem_0000(b: &mut Bencher) {\n-        do_bench_from_elem(b, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_from_elem_0010(b: &mut Bencher) {\n-        do_bench_from_elem(b, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_from_elem_0100(b: &mut Bencher) {\n-        do_bench_from_elem(b, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_from_elem_1000(b: &mut Bencher) {\n-        do_bench_from_elem(b, 1000)\n-    }\n-\n-    fn do_bench_from_slice(b: &mut Bencher, src_len: usize) {\n-        let src: Vec<_> = FromIterator::from_iter(0..src_len);\n-\n-        b.bytes = src_len as u64;\n-\n-        b.iter(|| {\n-            let dst = src.clone()[..].to_vec();\n-            assert_eq!(dst.len(), src_len);\n-            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_from_slice_0000(b: &mut Bencher) {\n-        do_bench_from_slice(b, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_from_slice_0010(b: &mut Bencher) {\n-        do_bench_from_slice(b, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_from_slice_0100(b: &mut Bencher) {\n-        do_bench_from_slice(b, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_from_slice_1000(b: &mut Bencher) {\n-        do_bench_from_slice(b, 1000)\n-    }\n-\n-    fn do_bench_from_iter(b: &mut Bencher, src_len: usize) {\n-        let src: Vec<_> = FromIterator::from_iter(0..src_len);\n-\n-        b.bytes = src_len as u64;\n-\n-        b.iter(|| {\n-            let dst: Vec<_> = FromIterator::from_iter(src.clone().into_iter());\n-            assert_eq!(dst.len(), src_len);\n-            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_from_iter_0000(b: &mut Bencher) {\n-        do_bench_from_iter(b, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_from_iter_0010(b: &mut Bencher) {\n-        do_bench_from_iter(b, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_from_iter_0100(b: &mut Bencher) {\n-        do_bench_from_iter(b, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_from_iter_1000(b: &mut Bencher) {\n-        do_bench_from_iter(b, 1000)\n-    }\n-\n-    fn do_bench_extend(b: &mut Bencher, dst_len: usize, src_len: usize) {\n-        let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n-        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-        b.bytes = src_len as u64;\n-\n-        b.iter(|| {\n-            let mut dst = dst.clone();\n-            dst.extend(src.clone().into_iter());\n-            assert_eq!(dst.len(), dst_len + src_len);\n-            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_extend_0000_0000(b: &mut Bencher) {\n-        do_bench_extend(b, 0, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_extend_0000_0010(b: &mut Bencher) {\n-        do_bench_extend(b, 0, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_extend_0000_0100(b: &mut Bencher) {\n-        do_bench_extend(b, 0, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_extend_0000_1000(b: &mut Bencher) {\n-        do_bench_extend(b, 0, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_extend_0010_0010(b: &mut Bencher) {\n-        do_bench_extend(b, 10, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_extend_0100_0100(b: &mut Bencher) {\n-        do_bench_extend(b, 100, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_extend_1000_1000(b: &mut Bencher) {\n-        do_bench_extend(b, 1000, 1000)\n-    }\n-\n-    fn do_bench_push_all(b: &mut Bencher, dst_len: usize, src_len: usize) {\n-        let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n-        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-        b.bytes = src_len as u64;\n-\n-        b.iter(|| {\n-            let mut dst = dst.clone();\n-            dst.push_all(&src);\n-            assert_eq!(dst.len(), dst_len + src_len);\n-            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_0000_0000(b: &mut Bencher) {\n-        do_bench_push_all(b, 0, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_0000_0010(b: &mut Bencher) {\n-        do_bench_push_all(b, 0, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_0000_0100(b: &mut Bencher) {\n-        do_bench_push_all(b, 0, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_0000_1000(b: &mut Bencher) {\n-        do_bench_push_all(b, 0, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_0010_0010(b: &mut Bencher) {\n-        do_bench_push_all(b, 10, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_0100_0100(b: &mut Bencher) {\n-        do_bench_push_all(b, 100, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_1000_1000(b: &mut Bencher) {\n-        do_bench_push_all(b, 1000, 1000)\n-    }\n-\n-    fn do_bench_push_all_move(b: &mut Bencher, dst_len: usize, src_len: usize) {\n-        let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n-        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-        b.bytes = src_len as u64;\n-\n-        b.iter(|| {\n-            let mut dst = dst.clone();\n-            dst.extend(src.clone().into_iter());\n-            assert_eq!(dst.len(), dst_len + src_len);\n-            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_move_0000_0000(b: &mut Bencher) {\n-        do_bench_push_all_move(b, 0, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_move_0000_0010(b: &mut Bencher) {\n-        do_bench_push_all_move(b, 0, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_move_0000_0100(b: &mut Bencher) {\n-        do_bench_push_all_move(b, 0, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_move_0000_1000(b: &mut Bencher) {\n-        do_bench_push_all_move(b, 0, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_move_0010_0010(b: &mut Bencher) {\n-        do_bench_push_all_move(b, 10, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_move_0100_0100(b: &mut Bencher) {\n-        do_bench_push_all_move(b, 100, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_push_all_move_1000_1000(b: &mut Bencher) {\n-        do_bench_push_all_move(b, 1000, 1000)\n-    }\n-\n-    fn do_bench_clone(b: &mut Bencher, src_len: usize) {\n-        let src: Vec<usize> = FromIterator::from_iter(0..src_len);\n-\n-        b.bytes = src_len as u64;\n-\n-        b.iter(|| {\n-            let dst = src.clone();\n-            assert_eq!(dst.len(), src_len);\n-            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_clone_0000(b: &mut Bencher) {\n-        do_bench_clone(b, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_0010(b: &mut Bencher) {\n-        do_bench_clone(b, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_0100(b: &mut Bencher) {\n-        do_bench_clone(b, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_1000(b: &mut Bencher) {\n-        do_bench_clone(b, 1000)\n-    }\n-\n-    fn do_bench_clone_from(b: &mut Bencher, times: usize, dst_len: usize, src_len: usize) {\n-        let dst: Vec<_> = FromIterator::from_iter(0..src_len);\n-        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-        b.bytes = (times * src_len) as u64;\n-\n-        b.iter(|| {\n-            let mut dst = dst.clone();\n-\n-            for _ in 0..times {\n-                dst.clone_from(&src);\n-\n-                assert_eq!(dst.len(), src_len);\n-                assert!(dst.iter().enumerate().all(|(i, x)| dst_len + i == *x));\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_0000_0000(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 0, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_0000_0010(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 0, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_0000_0100(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 0, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_0000_1000(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 0, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_0010_0010(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 10, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_0100_0100(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 100, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_1000_1000(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 1000, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_0010_0100(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 10, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_0100_1000(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 100, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_0010_0000(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 10, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_0100_0010(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 100, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_01_1000_0100(b: &mut Bencher) {\n-        do_bench_clone_from(b, 1, 1000, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_0000_0000(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 0, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_0000_0010(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 0, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_0000_0100(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 0, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_0000_1000(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 0, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_0010_0010(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 10, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_0100_0100(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 100, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_1000_1000(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 1000, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_0010_0100(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 10, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_0100_1000(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 100, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_0010_0000(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 10, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_0100_0010(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 100, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_clone_from_10_1000_0100(b: &mut Bencher) {\n-        do_bench_clone_from(b, 10, 1000, 100)\n-    }\n-}"}, {"sha": "700ee059a7fa562f1fe1d4216e10ea700fcd9441", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 1118, "changes": 1118, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -1768,1121 +1768,3 @@ impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n         write!(f, \"]\")\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use self::Taggy::*;\n-    use self::Taggypar::*;\n-    use prelude::*;\n-    use core::iter;\n-    use std::fmt::Debug;\n-    use std::hash::{self, SipHasher};\n-    use test::Bencher;\n-    use test;\n-\n-    use super::VecDeque;\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_simple() {\n-        let mut d = VecDeque::new();\n-        assert_eq!(d.len(), 0);\n-        d.push_front(17);\n-        d.push_front(42);\n-        d.push_back(137);\n-        assert_eq!(d.len(), 3);\n-        d.push_back(137);\n-        assert_eq!(d.len(), 4);\n-        assert_eq!(*d.front().unwrap(), 42);\n-        assert_eq!(*d.back().unwrap(), 137);\n-        let mut i = d.pop_front();\n-        assert_eq!(i, Some(42));\n-        i = d.pop_back();\n-        assert_eq!(i, Some(137));\n-        i = d.pop_back();\n-        assert_eq!(i, Some(137));\n-        i = d.pop_back();\n-        assert_eq!(i, Some(17));\n-        assert_eq!(d.len(), 0);\n-        d.push_back(3);\n-        assert_eq!(d.len(), 1);\n-        d.push_front(2);\n-        assert_eq!(d.len(), 2);\n-        d.push_back(4);\n-        assert_eq!(d.len(), 3);\n-        d.push_front(1);\n-        assert_eq!(d.len(), 4);\n-        debug!(\"{}\", d[0]);\n-        debug!(\"{}\", d[1]);\n-        debug!(\"{}\", d[2]);\n-        debug!(\"{}\", d[3]);\n-        assert_eq!(d[0], 1);\n-        assert_eq!(d[1], 2);\n-        assert_eq!(d[2], 3);\n-        assert_eq!(d[3], 4);\n-    }\n-\n-    #[cfg(test)]\n-    fn test_parameterized<T:Clone + PartialEq + Debug>(a: T, b: T, c: T, d: T) {\n-        let mut deq = VecDeque::new();\n-        assert_eq!(deq.len(), 0);\n-        deq.push_front(a.clone());\n-        deq.push_front(b.clone());\n-        deq.push_back(c.clone());\n-        assert_eq!(deq.len(), 3);\n-        deq.push_back(d.clone());\n-        assert_eq!(deq.len(), 4);\n-        assert_eq!((*deq.front().unwrap()).clone(), b.clone());\n-        assert_eq!((*deq.back().unwrap()).clone(), d.clone());\n-        assert_eq!(deq.pop_front().unwrap(), b.clone());\n-        assert_eq!(deq.pop_back().unwrap(), d.clone());\n-        assert_eq!(deq.pop_back().unwrap(), c.clone());\n-        assert_eq!(deq.pop_back().unwrap(), a.clone());\n-        assert_eq!(deq.len(), 0);\n-        deq.push_back(c.clone());\n-        assert_eq!(deq.len(), 1);\n-        deq.push_front(b.clone());\n-        assert_eq!(deq.len(), 2);\n-        deq.push_back(d.clone());\n-        assert_eq!(deq.len(), 3);\n-        deq.push_front(a.clone());\n-        assert_eq!(deq.len(), 4);\n-        assert_eq!(deq[0].clone(), a.clone());\n-        assert_eq!(deq[1].clone(), b.clone());\n-        assert_eq!(deq[2].clone(), c.clone());\n-        assert_eq!(deq[3].clone(), d.clone());\n-    }\n-\n-    #[test]\n-    fn test_push_front_grow() {\n-        let mut deq = VecDeque::new();\n-        for i in 0..66 {\n-            deq.push_front(i);\n-        }\n-        assert_eq!(deq.len(), 66);\n-\n-        for i in 0..66 {\n-            assert_eq!(deq[i], 65 - i);\n-        }\n-\n-        let mut deq = VecDeque::new();\n-        for i in 0..66 {\n-            deq.push_back(i);\n-        }\n-\n-        for i in 0..66 {\n-            assert_eq!(deq[i], i);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_index() {\n-        let mut deq = VecDeque::new();\n-        for i in 1..4 {\n-            deq.push_front(i);\n-        }\n-        assert_eq!(deq[1], 2);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_index_out_of_bounds() {\n-        let mut deq = VecDeque::new();\n-        for i in 1..4 {\n-            deq.push_front(i);\n-        }\n-        deq[3];\n-    }\n-\n-    #[bench]\n-    fn bench_new(b: &mut test::Bencher) {\n-        b.iter(|| {\n-            let ring: VecDeque<i32> = VecDeque::new();\n-            test::black_box(ring);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_push_back_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::with_capacity(101);\n-        b.iter(|| {\n-            for i in 0..100 {\n-                deq.push_back(i);\n-            }\n-            deq.head = 0;\n-            deq.tail = 0;\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_push_front_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::with_capacity(101);\n-        b.iter(|| {\n-            for i in 0..100 {\n-                deq.push_front(i);\n-            }\n-            deq.head = 0;\n-            deq.tail = 0;\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq= VecDeque::<i32>::with_capacity(101);\n-\n-        b.iter(|| {\n-            deq.head = 100;\n-            deq.tail = 0;\n-            while !deq.is_empty() {\n-                test::black_box(deq.pop_back());\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_pop_front_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::<i32>::with_capacity(101);\n-\n-        b.iter(|| {\n-            deq.head = 100;\n-            deq.tail = 0;\n-            while !deq.is_empty() {\n-                test::black_box(deq.pop_front());\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_grow_1025(b: &mut test::Bencher) {\n-        b.iter(|| {\n-            let mut deq = VecDeque::new();\n-            for i in 0..1025 {\n-                deq.push_front(i);\n-            }\n-            test::black_box(deq);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_iter_1000(b: &mut test::Bencher) {\n-        let ring: VecDeque<_> = (0..1000).collect();\n-\n-        b.iter(|| {\n-            let mut sum = 0;\n-            for &i in &ring {\n-                sum += i;\n-            }\n-            test::black_box(sum);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_mut_iter_1000(b: &mut test::Bencher) {\n-        let mut ring: VecDeque<_> = (0..1000).collect();\n-\n-        b.iter(|| {\n-            let mut sum = 0;\n-            for i in &mut ring {\n-                sum += *i;\n-            }\n-            test::black_box(sum);\n-        })\n-    }\n-\n-    #[derive(Clone, PartialEq, Debug)]\n-    enum Taggy {\n-        One(i32),\n-        Two(i32, i32),\n-        Three(i32, i32, i32),\n-    }\n-\n-    #[derive(Clone, PartialEq, Debug)]\n-    enum Taggypar<T> {\n-        Onepar(T),\n-        Twopar(T, T),\n-        Threepar(T, T, T),\n-    }\n-\n-    #[derive(Clone, PartialEq, Debug)]\n-    struct RecCy {\n-        x: i32,\n-        y: i32,\n-        t: Taggy\n-    }\n-\n-    #[test]\n-    fn test_param_int() {\n-        test_parameterized::<i32>(5, 72, 64, 175);\n-    }\n-\n-    #[test]\n-    fn test_param_taggy() {\n-        test_parameterized::<Taggy>(One(1), Two(1, 2), Three(1, 2, 3), Two(17, 42));\n-    }\n-\n-    #[test]\n-    fn test_param_taggypar() {\n-        test_parameterized::<Taggypar<i32>>(Onepar::<i32>(1),\n-                                            Twopar::<i32>(1, 2),\n-                                            Threepar::<i32>(1, 2, 3),\n-                                            Twopar::<i32>(17, 42));\n-    }\n-\n-    #[test]\n-    fn test_param_reccy() {\n-        let reccy1 = RecCy { x: 1, y: 2, t: One(1) };\n-        let reccy2 = RecCy { x: 345, y: 2, t: Two(1, 2) };\n-        let reccy3 = RecCy { x: 1, y: 777, t: Three(1, 2, 3) };\n-        let reccy4 = RecCy { x: 19, y: 252, t: Two(17, 42) };\n-        test_parameterized::<RecCy>(reccy1, reccy2, reccy3, reccy4);\n-    }\n-\n-    #[test]\n-    fn test_with_capacity() {\n-        let mut d = VecDeque::with_capacity(0);\n-        d.push_back(1);\n-        assert_eq!(d.len(), 1);\n-        let mut d = VecDeque::with_capacity(50);\n-        d.push_back(1);\n-        assert_eq!(d.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_with_capacity_non_power_two() {\n-        let mut d3 = VecDeque::with_capacity(3);\n-        d3.push_back(1);\n-\n-        // X = None, | = lo\n-        // [|1, X, X]\n-        assert_eq!(d3.pop_front(), Some(1));\n-        // [X, |X, X]\n-        assert_eq!(d3.front(), None);\n-\n-        // [X, |3, X]\n-        d3.push_back(3);\n-        // [X, |3, 6]\n-        d3.push_back(6);\n-        // [X, X, |6]\n-        assert_eq!(d3.pop_front(), Some(3));\n-\n-        // Pushing the lo past half way point to trigger\n-        // the 'B' scenario for growth\n-        // [9, X, |6]\n-        d3.push_back(9);\n-        // [9, 12, |6]\n-        d3.push_back(12);\n-\n-        d3.push_back(15);\n-        // There used to be a bug here about how the\n-        // VecDeque made growth assumptions about the\n-        // underlying Vec which didn't hold and lead\n-        // to corruption.\n-        // (Vec grows to next power of two)\n-        //good- [9, 12, 15, X, X, X, X, |6]\n-        //bug-  [15, 12, X, X, X, |6, X, X]\n-        assert_eq!(d3.pop_front(), Some(6));\n-\n-        // Which leads us to the following state which\n-        // would be a failure case.\n-        //bug-  [15, 12, X, X, X, X, |X, X]\n-        assert_eq!(d3.front(), Some(&9));\n-    }\n-\n-    #[test]\n-    fn test_reserve_exact() {\n-        let mut d = VecDeque::new();\n-        d.push_back(0);\n-        d.reserve_exact(50);\n-        assert!(d.capacity() >= 51);\n-    }\n-\n-    #[test]\n-    fn test_reserve() {\n-        let mut d = VecDeque::new();\n-        d.push_back(0);\n-        d.reserve(50);\n-        assert!(d.capacity() >= 51);\n-    }\n-\n-    #[test]\n-    fn test_swap() {\n-        let mut d: VecDeque<_> = (0..5).collect();\n-        d.pop_front();\n-        d.swap(0, 3);\n-        assert_eq!(d.iter().cloned().collect::<Vec<_>>(), [4, 2, 3, 1]);\n-    }\n-\n-    #[test]\n-    fn test_iter() {\n-        let mut d = VecDeque::new();\n-        assert_eq!(d.iter().next(), None);\n-        assert_eq!(d.iter().size_hint(), (0, Some(0)));\n-\n-        for i in 0..5 {\n-            d.push_back(i);\n-        }\n-        {\n-            let b: &[_] = &[&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<_>>(), b);\n-        }\n-\n-        for i in 6..9 {\n-            d.push_front(i);\n-        }\n-        {\n-            let b: &[_] = &[&8,&7,&6,&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<_>>(), b);\n-        }\n-\n-        let mut it = d.iter();\n-        let mut len = d.len();\n-        loop {\n-            match it.next() {\n-                None => break,\n-                _ => { len -= 1; assert_eq!(it.size_hint(), (len, Some(len))) }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_rev_iter() {\n-        let mut d = VecDeque::new();\n-        assert_eq!(d.iter().rev().next(), None);\n-\n-        for i in 0..5 {\n-            d.push_back(i);\n-        }\n-        {\n-            let b: &[_] = &[&4,&3,&2,&1,&0];\n-            assert_eq!(d.iter().rev().collect::<Vec<_>>(), b);\n-        }\n-\n-        for i in 6..9 {\n-            d.push_front(i);\n-        }\n-        let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n-        assert_eq!(d.iter().rev().collect::<Vec<_>>(), b);\n-    }\n-\n-    #[test]\n-    fn test_mut_rev_iter_wrap() {\n-        let mut d = VecDeque::with_capacity(3);\n-        assert!(d.iter_mut().rev().next().is_none());\n-\n-        d.push_back(1);\n-        d.push_back(2);\n-        d.push_back(3);\n-        assert_eq!(d.pop_front(), Some(1));\n-        d.push_back(4);\n-\n-        assert_eq!(d.iter_mut().rev().cloned().collect::<Vec<_>>(),\n-                   vec![4, 3, 2]);\n-    }\n-\n-    #[test]\n-    fn test_mut_iter() {\n-        let mut d = VecDeque::new();\n-        assert!(d.iter_mut().next().is_none());\n-\n-        for i in 0..3 {\n-            d.push_front(i);\n-        }\n-\n-        for (i, elt) in d.iter_mut().enumerate() {\n-            assert_eq!(*elt, 2 - i);\n-            *elt = i;\n-        }\n-\n-        {\n-            let mut it = d.iter_mut();\n-            assert_eq!(*it.next().unwrap(), 0);\n-            assert_eq!(*it.next().unwrap(), 1);\n-            assert_eq!(*it.next().unwrap(), 2);\n-            assert!(it.next().is_none());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_mut_rev_iter() {\n-        let mut d = VecDeque::new();\n-        assert!(d.iter_mut().rev().next().is_none());\n-\n-        for i in 0..3 {\n-            d.push_front(i);\n-        }\n-\n-        for (i, elt) in d.iter_mut().rev().enumerate() {\n-            assert_eq!(*elt, i);\n-            *elt = i;\n-        }\n-\n-        {\n-            let mut it = d.iter_mut().rev();\n-            assert_eq!(*it.next().unwrap(), 0);\n-            assert_eq!(*it.next().unwrap(), 1);\n-            assert_eq!(*it.next().unwrap(), 2);\n-            assert!(it.next().is_none());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_iter() {\n-\n-        // Empty iter\n-        {\n-            let d: VecDeque<i32> = VecDeque::new();\n-            let mut iter = d.into_iter();\n-\n-            assert_eq!(iter.size_hint(), (0, Some(0)));\n-            assert_eq!(iter.next(), None);\n-            assert_eq!(iter.size_hint(), (0, Some(0)));\n-        }\n-\n-        // simple iter\n-        {\n-            let mut d = VecDeque::new();\n-            for i in 0..5 {\n-                d.push_back(i);\n-            }\n-\n-            let b = vec![0,1,2,3,4];\n-            assert_eq!(d.into_iter().collect::<Vec<_>>(), b);\n-        }\n-\n-        // wrapped iter\n-        {\n-            let mut d = VecDeque::new();\n-            for i in 0..5 {\n-                d.push_back(i);\n-            }\n-            for i in 6..9 {\n-                d.push_front(i);\n-            }\n-\n-            let b = vec![8,7,6,0,1,2,3,4];\n-            assert_eq!(d.into_iter().collect::<Vec<_>>(), b);\n-        }\n-\n-        // partially used\n-        {\n-            let mut d = VecDeque::new();\n-            for i in 0..5 {\n-                d.push_back(i);\n-            }\n-            for i in 6..9 {\n-                d.push_front(i);\n-            }\n-\n-            let mut it = d.into_iter();\n-            assert_eq!(it.size_hint(), (8, Some(8)));\n-            assert_eq!(it.next(), Some(8));\n-            assert_eq!(it.size_hint(), (7, Some(7)));\n-            assert_eq!(it.next_back(), Some(4));\n-            assert_eq!(it.size_hint(), (6, Some(6)));\n-            assert_eq!(it.next(), Some(7));\n-            assert_eq!(it.size_hint(), (5, Some(5)));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_drain() {\n-\n-        // Empty iter\n-        {\n-            let mut d: VecDeque<i32> = VecDeque::new();\n-\n-            {\n-                let mut iter = d.drain();\n-\n-                assert_eq!(iter.size_hint(), (0, Some(0)));\n-                assert_eq!(iter.next(), None);\n-                assert_eq!(iter.size_hint(), (0, Some(0)));\n-            }\n-\n-            assert!(d.is_empty());\n-        }\n-\n-        // simple iter\n-        {\n-            let mut d = VecDeque::new();\n-            for i in 0..5 {\n-                d.push_back(i);\n-            }\n-\n-            assert_eq!(d.drain().collect::<Vec<_>>(), [0, 1, 2, 3, 4]);\n-            assert!(d.is_empty());\n-        }\n-\n-        // wrapped iter\n-        {\n-            let mut d = VecDeque::new();\n-            for i in 0..5 {\n-                d.push_back(i);\n-            }\n-            for i in 6..9 {\n-                d.push_front(i);\n-            }\n-\n-            assert_eq!(d.drain().collect::<Vec<_>>(), [8,7,6,0,1,2,3,4]);\n-            assert!(d.is_empty());\n-        }\n-\n-        // partially used\n-        {\n-            let mut d: VecDeque<_> = VecDeque::new();\n-            for i in 0..5 {\n-                d.push_back(i);\n-            }\n-            for i in 6..9 {\n-                d.push_front(i);\n-            }\n-\n-            {\n-                let mut it = d.drain();\n-                assert_eq!(it.size_hint(), (8, Some(8)));\n-                assert_eq!(it.next(), Some(8));\n-                assert_eq!(it.size_hint(), (7, Some(7)));\n-                assert_eq!(it.next_back(), Some(4));\n-                assert_eq!(it.size_hint(), (6, Some(6)));\n-                assert_eq!(it.next(), Some(7));\n-                assert_eq!(it.size_hint(), (5, Some(5)));\n-            }\n-            assert!(d.is_empty());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        use core::iter;\n-        let v = vec!(1,2,3,4,5,6,7);\n-        let deq: VecDeque<_> = v.iter().cloned().collect();\n-        let u: Vec<_> = deq.iter().cloned().collect();\n-        assert_eq!(u, v);\n-\n-        let seq = iter::count(0, 2).take(256);\n-        let deq: VecDeque<_> = seq.collect();\n-        for (i, &x) in deq.iter().enumerate() {\n-            assert_eq!(2*i, x);\n-        }\n-        assert_eq!(deq.len(), 256);\n-    }\n-\n-    #[test]\n-    fn test_clone() {\n-        let mut d = VecDeque::new();\n-        d.push_front(17);\n-        d.push_front(42);\n-        d.push_back(137);\n-        d.push_back(137);\n-        assert_eq!(d.len(), 4);\n-        let mut e = d.clone();\n-        assert_eq!(e.len(), 4);\n-        while !d.is_empty() {\n-            assert_eq!(d.pop_back(), e.pop_back());\n-        }\n-        assert_eq!(d.len(), 0);\n-        assert_eq!(e.len(), 0);\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        let mut d = VecDeque::new();\n-        assert!(d == VecDeque::with_capacity(0));\n-        d.push_front(137);\n-        d.push_front(17);\n-        d.push_front(42);\n-        d.push_back(137);\n-        let mut e = VecDeque::with_capacity(0);\n-        e.push_back(42);\n-        e.push_back(17);\n-        e.push_back(137);\n-        e.push_back(137);\n-        assert!(&e == &d);\n-        e.pop_back();\n-        e.push_back(0);\n-        assert!(e != d);\n-        e.clear();\n-        assert!(e == VecDeque::new());\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-      let mut x = VecDeque::new();\n-      let mut y = VecDeque::new();\n-\n-      x.push_back(1);\n-      x.push_back(2);\n-      x.push_back(3);\n-\n-      y.push_back(0);\n-      y.push_back(1);\n-      y.pop_front();\n-      y.push_back(2);\n-      y.push_back(3);\n-\n-      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let x = VecDeque::new();\n-        let mut y = VecDeque::new();\n-        y.push_back(1);\n-        y.push_back(2);\n-        y.push_back(3);\n-        assert!(x < y);\n-        assert!(y > x);\n-        assert!(x <= x);\n-        assert!(x >= x);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let ringbuf: VecDeque<_> = (0..10).collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n-\n-        let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n-                                                                        .cloned()\n-                                                                        .collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n-    }\n-\n-    #[test]\n-    fn test_drop() {\n-        static mut drops: i32 = 0;\n-        struct Elem;\n-        impl Drop for Elem {\n-            fn drop(&mut self) {\n-                unsafe { drops += 1; }\n-            }\n-        }\n-\n-        let mut ring = VecDeque::new();\n-        ring.push_back(Elem);\n-        ring.push_front(Elem);\n-        ring.push_back(Elem);\n-        ring.push_front(Elem);\n-        drop(ring);\n-\n-        assert_eq!(unsafe {drops}, 4);\n-    }\n-\n-    #[test]\n-    fn test_drop_with_pop() {\n-        static mut drops: i32 = 0;\n-        struct Elem;\n-        impl Drop for Elem {\n-            fn drop(&mut self) {\n-                unsafe { drops += 1; }\n-            }\n-        }\n-\n-        let mut ring = VecDeque::new();\n-        ring.push_back(Elem);\n-        ring.push_front(Elem);\n-        ring.push_back(Elem);\n-        ring.push_front(Elem);\n-\n-        drop(ring.pop_back());\n-        drop(ring.pop_front());\n-        assert_eq!(unsafe {drops}, 2);\n-\n-        drop(ring);\n-        assert_eq!(unsafe {drops}, 4);\n-    }\n-\n-    #[test]\n-    fn test_drop_clear() {\n-        static mut drops: i32 = 0;\n-        struct Elem;\n-        impl Drop for Elem {\n-            fn drop(&mut self) {\n-                unsafe { drops += 1; }\n-            }\n-        }\n-\n-        let mut ring = VecDeque::new();\n-        ring.push_back(Elem);\n-        ring.push_front(Elem);\n-        ring.push_back(Elem);\n-        ring.push_front(Elem);\n-        ring.clear();\n-        assert_eq!(unsafe {drops}, 4);\n-\n-        drop(ring);\n-        assert_eq!(unsafe {drops}, 4);\n-    }\n-\n-    #[test]\n-    fn test_reserve_grow() {\n-        // test growth path A\n-        // [T o o H] -> [T o o H . . . . ]\n-        let mut ring = VecDeque::with_capacity(4);\n-        for i in 0..3 {\n-            ring.push_back(i);\n-        }\n-        ring.reserve(7);\n-        for i in 0..3 {\n-            assert_eq!(ring.pop_front(), Some(i));\n-        }\n-\n-        // test growth path B\n-        // [H T o o] -> [. T o o H . . . ]\n-        let mut ring = VecDeque::with_capacity(4);\n-        for i in 0..1 {\n-            ring.push_back(i);\n-            assert_eq!(ring.pop_front(), Some(i));\n-        }\n-        for i in 0..3 {\n-            ring.push_back(i);\n-        }\n-        ring.reserve(7);\n-        for i in 0..3 {\n-            assert_eq!(ring.pop_front(), Some(i));\n-        }\n-\n-        // test growth path C\n-        // [o o H T] -> [o o H . . . . T ]\n-        let mut ring = VecDeque::with_capacity(4);\n-        for i in 0..3 {\n-            ring.push_back(i);\n-            assert_eq!(ring.pop_front(), Some(i));\n-        }\n-        for i in 0..3 {\n-            ring.push_back(i);\n-        }\n-        ring.reserve(7);\n-        for i in 0..3 {\n-            assert_eq!(ring.pop_front(), Some(i));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_get() {\n-        let mut ring = VecDeque::new();\n-        ring.push_back(0);\n-        assert_eq!(ring.get(0), Some(&0));\n-        assert_eq!(ring.get(1), None);\n-\n-        ring.push_back(1);\n-        assert_eq!(ring.get(0), Some(&0));\n-        assert_eq!(ring.get(1), Some(&1));\n-        assert_eq!(ring.get(2), None);\n-\n-        ring.push_back(2);\n-        assert_eq!(ring.get(0), Some(&0));\n-        assert_eq!(ring.get(1), Some(&1));\n-        assert_eq!(ring.get(2), Some(&2));\n-        assert_eq!(ring.get(3), None);\n-\n-        assert_eq!(ring.pop_front(), Some(0));\n-        assert_eq!(ring.get(0), Some(&1));\n-        assert_eq!(ring.get(1), Some(&2));\n-        assert_eq!(ring.get(2), None);\n-\n-        assert_eq!(ring.pop_front(), Some(1));\n-        assert_eq!(ring.get(0), Some(&2));\n-        assert_eq!(ring.get(1), None);\n-\n-        assert_eq!(ring.pop_front(), Some(2));\n-        assert_eq!(ring.get(0), None);\n-        assert_eq!(ring.get(1), None);\n-    }\n-\n-    #[test]\n-    fn test_get_mut() {\n-        let mut ring = VecDeque::new();\n-        for i in 0..3 {\n-            ring.push_back(i);\n-        }\n-\n-        match ring.get_mut(1) {\n-            Some(x) => *x = -1,\n-            None => ()\n-        };\n-\n-        assert_eq!(ring.get_mut(0), Some(&mut 0));\n-        assert_eq!(ring.get_mut(1), Some(&mut -1));\n-        assert_eq!(ring.get_mut(2), Some(&mut 2));\n-        assert_eq!(ring.get_mut(3), None);\n-\n-        assert_eq!(ring.pop_front(), Some(0));\n-        assert_eq!(ring.get_mut(0), Some(&mut -1));\n-        assert_eq!(ring.get_mut(1), Some(&mut 2));\n-        assert_eq!(ring.get_mut(2), None);\n-    }\n-\n-    #[test]\n-    fn test_swap_front_back_remove() {\n-        fn test(back: bool) {\n-            // This test checks that every single combination of tail position and length is tested.\n-            // Capacity 15 should be large enough to cover every case.\n-            let mut tester = VecDeque::with_capacity(15);\n-            let usable_cap = tester.capacity();\n-            let final_len = usable_cap / 2;\n-\n-            for len in 0..final_len {\n-                let expected = if back {\n-                    (0..len).collect()\n-                } else {\n-                    (0..len).rev().collect()\n-                };\n-                for tail_pos in 0..usable_cap {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    if back {\n-                        for i in 0..len * 2 {\n-                            tester.push_front(i);\n-                        }\n-                        for i in 0..len {\n-                            assert_eq!(tester.swap_back_remove(i), Some(len * 2 - 1 - i));\n-                        }\n-                    } else {\n-                        for i in 0..len * 2 {\n-                            tester.push_back(i);\n-                        }\n-                        for i in 0..len {\n-                            let idx = tester.len() - 1 - i;\n-                            assert_eq!(tester.swap_front_remove(idx), Some(len * 2 - 1 - i));\n-                        }\n-                    }\n-                    assert!(tester.tail < tester.cap);\n-                    assert!(tester.head < tester.cap);\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-        test(true);\n-        test(false);\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        // This test checks that every single combination of tail position, length, and\n-        // insertion position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-\n-        // len is the length *after* insertion\n-        for len in 1..cap {\n-            // 0, 1, 2, .., len - 1\n-            let expected = iter::count(0, 1).take(len).collect();\n-            for tail_pos in 0..cap {\n-                for to_insert in 0..len {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        if i != to_insert {\n-                            tester.push_back(i);\n-                        }\n-                    }\n-                    tester.insert(to_insert, to_insert);\n-                    assert!(tester.tail < tester.cap);\n-                    assert!(tester.head < tester.cap);\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        // This test checks that every single combination of tail position, length, and\n-        // removal position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-        // len is the length *after* removal\n-        for len in 0..cap - 1 {\n-            // 0, 1, 2, .., len - 1\n-            let expected = iter::count(0, 1).take(len).collect();\n-            for tail_pos in 0..cap {\n-                for to_remove in 0..len + 1 {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        if i == to_remove {\n-                            tester.push_back(1234);\n-                        }\n-                        tester.push_back(i);\n-                    }\n-                    if to_remove == len {\n-                        tester.push_back(1234);\n-                    }\n-                    tester.remove(to_remove);\n-                    assert!(tester.tail < tester.cap);\n-                    assert!(tester.head < tester.cap);\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_shrink_to_fit() {\n-        // This test checks that every single combination of head and tail position,\n-        // is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-        tester.reserve(63);\n-        let max_cap = tester.capacity();\n-\n-        for len in 0..cap + 1 {\n-            // 0, 1, 2, .., len - 1\n-            let expected = iter::count(0, 1).take(len).collect();\n-            for tail_pos in 0..max_cap + 1 {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n-                tester.reserve(63);\n-                for i in 0..len {\n-                    tester.push_back(i);\n-                }\n-                tester.shrink_to_fit();\n-                assert!(tester.capacity() <= cap);\n-                assert!(tester.tail < tester.cap);\n-                assert!(tester.head < tester.cap);\n-                assert_eq!(tester, expected);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_front() {\n-        let mut ring = VecDeque::new();\n-        ring.push_back(10);\n-        ring.push_back(20);\n-        assert_eq!(ring.front(), Some(&10));\n-        ring.pop_front();\n-        assert_eq!(ring.front(), Some(&20));\n-        ring.pop_front();\n-        assert_eq!(ring.front(), None);\n-    }\n-\n-    #[test]\n-    fn test_as_slices() {\n-        let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n-        let cap = ring.capacity() as i32;\n-        let first = cap/2;\n-        let last  = cap - first;\n-        for i in 0..first {\n-            ring.push_back(i);\n-\n-            let (left, right) = ring.as_slices();\n-            let expected: Vec<_> = (0..i+1).collect();\n-            assert_eq!(left, expected);\n-            assert_eq!(right, []);\n-        }\n-\n-        for j in -last..0 {\n-            ring.push_front(j);\n-            let (left, right) = ring.as_slices();\n-            let expected_left: Vec<_> = (-last..j+1).rev().collect();\n-            let expected_right: Vec<_> = (0..first).collect();\n-            assert_eq!(left, expected_left);\n-            assert_eq!(right, expected_right);\n-        }\n-\n-        assert_eq!(ring.len() as i32, cap);\n-        assert_eq!(ring.capacity() as i32, cap);\n-    }\n-\n-    #[test]\n-    fn test_as_mut_slices() {\n-        let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n-        let cap = ring.capacity() as i32;\n-        let first = cap/2;\n-        let last  = cap - first;\n-        for i in 0..first {\n-            ring.push_back(i);\n-\n-            let (left, right) = ring.as_mut_slices();\n-            let expected: Vec<_> = (0..i+1).collect();\n-            assert_eq!(left, expected);\n-            assert_eq!(right, []);\n-        }\n-\n-        for j in -last..0 {\n-            ring.push_front(j);\n-            let (left, right) = ring.as_mut_slices();\n-            let expected_left: Vec<_> = (-last..j+1).rev().collect();\n-            let expected_right: Vec<_> = (0..first).collect();\n-            assert_eq!(left, expected_left);\n-            assert_eq!(right, expected_right);\n-        }\n-\n-        assert_eq!(ring.len() as i32, cap);\n-        assert_eq!(ring.capacity() as i32, cap);\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        // This test checks that every single combination of tail position, length, and\n-        // split position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-        // len is the length *before* splitting\n-        for len in 0..cap {\n-            // index to split at\n-            for at in 0..len + 1 {\n-                // 0, 1, 2, .., at - 1 (may be empty)\n-                let expected_self = iter::count(0, 1).take(at).collect();\n-                // at, at + 1, .., len - 1 (may be empty)\n-                let expected_other = iter::count(at, 1).take(len - at).collect();\n-\n-                for tail_pos in 0..cap {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        tester.push_back(i);\n-                    }\n-                    let result = tester.split_off(at);\n-                    assert!(tester.tail < tester.cap);\n-                    assert!(tester.head < tester.cap);\n-                    assert!(result.tail < result.cap);\n-                    assert!(result.head < result.cap);\n-                    assert_eq!(tester, expected_self);\n-                    assert_eq!(result, expected_other);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_append() {\n-        let mut a: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n-        let mut b: VecDeque<_> = vec![4, 5, 6].into_iter().collect();\n-\n-        // normal append\n-        a.append(&mut b);\n-        assert_eq!(a.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n-        assert_eq!(b.iter().cloned().collect::<Vec<_>>(), []);\n-\n-        // append nothing to something\n-        a.append(&mut b);\n-        assert_eq!(a.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n-        assert_eq!(b.iter().cloned().collect::<Vec<_>>(), []);\n-\n-        // append something to nothing\n-        b.append(&mut a);\n-        assert_eq!(b.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n-        assert_eq!(a.iter().cloned().collect::<Vec<_>>(), []);\n-    }\n-}"}, {"sha": "6e67d8763273d7c0156473b126b4662d061911f3", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 0, "deletions": 507, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -1004,510 +1004,3 @@ impl<V> Iterator for IntoIter<V> {\n impl<V> DoubleEndedIterator for IntoIter<V> {\n     fn next_back(&mut self) -> Option<(usize, V)> { self.iter.next_back() }\n }\n-\n-#[cfg(test)]\n-mod test_map {\n-    use prelude::*;\n-    use core::hash::{hash, SipHasher};\n-\n-    use super::VecMap;\n-    use super::Entry::{Occupied, Vacant};\n-\n-    #[test]\n-    fn test_get_mut() {\n-        let mut m = VecMap::new();\n-        assert!(m.insert(1, 12).is_none());\n-        assert!(m.insert(2, 8).is_none());\n-        assert!(m.insert(5, 14).is_none());\n-        let new = 100;\n-        match m.get_mut(&5) {\n-            None => panic!(), Some(x) => *x = new\n-        }\n-        assert_eq!(m.get(&5), Some(&new));\n-    }\n-\n-    #[test]\n-    fn test_len() {\n-        let mut map = VecMap::new();\n-        assert_eq!(map.len(), 0);\n-        assert!(map.is_empty());\n-        assert!(map.insert(5, 20).is_none());\n-        assert_eq!(map.len(), 1);\n-        assert!(!map.is_empty());\n-        assert!(map.insert(11, 12).is_none());\n-        assert_eq!(map.len(), 2);\n-        assert!(!map.is_empty());\n-        assert!(map.insert(14, 22).is_none());\n-        assert_eq!(map.len(), 3);\n-        assert!(!map.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_clear() {\n-        let mut map = VecMap::new();\n-        assert!(map.insert(5, 20).is_none());\n-        assert!(map.insert(11, 12).is_none());\n-        assert!(map.insert(14, 22).is_none());\n-        map.clear();\n-        assert!(map.is_empty());\n-        assert!(map.get(&5).is_none());\n-        assert!(map.get(&11).is_none());\n-        assert!(map.get(&14).is_none());\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        let mut m = VecMap::new();\n-        assert_eq!(m.insert(1, 2), None);\n-        assert_eq!(m.insert(1, 3), Some(2));\n-        assert_eq!(m.insert(1, 4), Some(3));\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        let mut m = VecMap::new();\n-        m.insert(1, 2);\n-        assert_eq!(m.remove(&1), Some(2));\n-        assert_eq!(m.remove(&1), None);\n-    }\n-\n-    #[test]\n-    fn test_keys() {\n-        let mut map = VecMap::new();\n-        map.insert(1, 'a');\n-        map.insert(2, 'b');\n-        map.insert(3, 'c');\n-        let keys: Vec<_> = map.keys().collect();\n-        assert_eq!(keys.len(), 3);\n-        assert!(keys.contains(&1));\n-        assert!(keys.contains(&2));\n-        assert!(keys.contains(&3));\n-    }\n-\n-    #[test]\n-    fn test_values() {\n-        let mut map = VecMap::new();\n-        map.insert(1, 'a');\n-        map.insert(2, 'b');\n-        map.insert(3, 'c');\n-        let values: Vec<_> = map.values().cloned().collect();\n-        assert_eq!(values.len(), 3);\n-        assert!(values.contains(&'a'));\n-        assert!(values.contains(&'b'));\n-        assert!(values.contains(&'c'));\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let mut m = VecMap::new();\n-\n-        assert!(m.insert(0, 1).is_none());\n-        assert!(m.insert(1, 2).is_none());\n-        assert!(m.insert(3, 5).is_none());\n-        assert!(m.insert(6, 10).is_none());\n-        assert!(m.insert(10, 11).is_none());\n-\n-        let mut it = m.iter();\n-        assert_eq!(it.size_hint(), (0, Some(11)));\n-        assert_eq!(it.next().unwrap(), (0, &1));\n-        assert_eq!(it.size_hint(), (0, Some(10)));\n-        assert_eq!(it.next().unwrap(), (1, &2));\n-        assert_eq!(it.size_hint(), (0, Some(9)));\n-        assert_eq!(it.next().unwrap(), (3, &5));\n-        assert_eq!(it.size_hint(), (0, Some(7)));\n-        assert_eq!(it.next().unwrap(), (6, &10));\n-        assert_eq!(it.size_hint(), (0, Some(4)));\n-        assert_eq!(it.next().unwrap(), (10, &11));\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_iterator_size_hints() {\n-        let mut m = VecMap::new();\n-\n-        assert!(m.insert(0, 1).is_none());\n-        assert!(m.insert(1, 2).is_none());\n-        assert!(m.insert(3, 5).is_none());\n-        assert!(m.insert(6, 10).is_none());\n-        assert!(m.insert(10, 11).is_none());\n-\n-        assert_eq!(m.iter().size_hint(), (0, Some(11)));\n-        assert_eq!(m.iter().rev().size_hint(), (0, Some(11)));\n-        assert_eq!(m.iter_mut().size_hint(), (0, Some(11)));\n-        assert_eq!(m.iter_mut().rev().size_hint(), (0, Some(11)));\n-    }\n-\n-    #[test]\n-    fn test_mut_iterator() {\n-        let mut m = VecMap::new();\n-\n-        assert!(m.insert(0, 1).is_none());\n-        assert!(m.insert(1, 2).is_none());\n-        assert!(m.insert(3, 5).is_none());\n-        assert!(m.insert(6, 10).is_none());\n-        assert!(m.insert(10, 11).is_none());\n-\n-        for (k, v) in &mut m {\n-            *v += k as isize;\n-        }\n-\n-        let mut it = m.iter();\n-        assert_eq!(it.next().unwrap(), (0, &1));\n-        assert_eq!(it.next().unwrap(), (1, &3));\n-        assert_eq!(it.next().unwrap(), (3, &8));\n-        assert_eq!(it.next().unwrap(), (6, &16));\n-        assert_eq!(it.next().unwrap(), (10, &21));\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_rev_iterator() {\n-        let mut m = VecMap::new();\n-\n-        assert!(m.insert(0, 1).is_none());\n-        assert!(m.insert(1, 2).is_none());\n-        assert!(m.insert(3, 5).is_none());\n-        assert!(m.insert(6, 10).is_none());\n-        assert!(m.insert(10, 11).is_none());\n-\n-        let mut it = m.iter().rev();\n-        assert_eq!(it.next().unwrap(), (10, &11));\n-        assert_eq!(it.next().unwrap(), (6, &10));\n-        assert_eq!(it.next().unwrap(), (3, &5));\n-        assert_eq!(it.next().unwrap(), (1, &2));\n-        assert_eq!(it.next().unwrap(), (0, &1));\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_mut_rev_iterator() {\n-        let mut m = VecMap::new();\n-\n-        assert!(m.insert(0, 1).is_none());\n-        assert!(m.insert(1, 2).is_none());\n-        assert!(m.insert(3, 5).is_none());\n-        assert!(m.insert(6, 10).is_none());\n-        assert!(m.insert(10, 11).is_none());\n-\n-        for (k, v) in m.iter_mut().rev() {\n-            *v += k as isize;\n-        }\n-\n-        let mut it = m.iter();\n-        assert_eq!(it.next().unwrap(), (0, &1));\n-        assert_eq!(it.next().unwrap(), (1, &3));\n-        assert_eq!(it.next().unwrap(), (3, &8));\n-        assert_eq!(it.next().unwrap(), (6, &16));\n-        assert_eq!(it.next().unwrap(), (10, &21));\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_move_iter() {\n-        let mut m: VecMap<Box<_>> = VecMap::new();\n-        m.insert(1, box 2);\n-        let mut called = false;\n-        for (k, v) in m {\n-            assert!(!called);\n-            called = true;\n-            assert_eq!(k, 1);\n-            assert_eq!(v, box 2);\n-        }\n-        assert!(called);\n-    }\n-\n-    #[test]\n-    fn test_drain_iterator() {\n-        let mut map = VecMap::new();\n-        map.insert(1, \"a\");\n-        map.insert(3, \"c\");\n-        map.insert(2, \"b\");\n-\n-        let vec: Vec<_> = map.drain().collect();\n-\n-        assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n-        assert_eq!(map.len(), 0);\n-    }\n-\n-    #[test]\n-    fn test_append() {\n-        let mut a = VecMap::new();\n-        a.insert(1, \"a\");\n-        a.insert(2, \"b\");\n-        a.insert(3, \"c\");\n-\n-        let mut b = VecMap::new();\n-        b.insert(3, \"d\");  // Overwrite element from a\n-        b.insert(4, \"e\");\n-        b.insert(5, \"f\");\n-\n-        a.append(&mut b);\n-\n-        assert_eq!(a.len(), 5);\n-        assert_eq!(b.len(), 0);\n-        // Capacity shouldn't change for possible reuse\n-        assert!(b.capacity() >= 4);\n-\n-        assert_eq!(a[1], \"a\");\n-        assert_eq!(a[2], \"b\");\n-        assert_eq!(a[3], \"d\");\n-        assert_eq!(a[4], \"e\");\n-        assert_eq!(a[5], \"f\");\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        // Split within the key range\n-        let mut a = VecMap::new();\n-        a.insert(1, \"a\");\n-        a.insert(2, \"b\");\n-        a.insert(3, \"c\");\n-        a.insert(4, \"d\");\n-\n-        let b = a.split_off(3);\n-\n-        assert_eq!(a.len(), 2);\n-        assert_eq!(b.len(), 2);\n-\n-        assert_eq!(a[1], \"a\");\n-        assert_eq!(a[2], \"b\");\n-\n-        assert_eq!(b[3], \"c\");\n-        assert_eq!(b[4], \"d\");\n-\n-        // Split at 0\n-        a.clear();\n-        a.insert(1, \"a\");\n-        a.insert(2, \"b\");\n-        a.insert(3, \"c\");\n-        a.insert(4, \"d\");\n-\n-        let b = a.split_off(0);\n-\n-        assert_eq!(a.len(), 0);\n-        assert_eq!(b.len(), 4);\n-        assert_eq!(b[1], \"a\");\n-        assert_eq!(b[2], \"b\");\n-        assert_eq!(b[3], \"c\");\n-        assert_eq!(b[4], \"d\");\n-\n-        // Split behind max_key\n-        a.clear();\n-        a.insert(1, \"a\");\n-        a.insert(2, \"b\");\n-        a.insert(3, \"c\");\n-        a.insert(4, \"d\");\n-\n-        let b = a.split_off(5);\n-\n-        assert_eq!(a.len(), 4);\n-        assert_eq!(b.len(), 0);\n-        assert_eq!(a[1], \"a\");\n-        assert_eq!(a[2], \"b\");\n-        assert_eq!(a[3], \"c\");\n-        assert_eq!(a[4], \"d\");\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut map = VecMap::new();\n-        let empty = VecMap::<i32>::new();\n-\n-        map.insert(1, 2);\n-        map.insert(3, 4);\n-\n-        let map_str = format!(\"{:?}\", map);\n-        assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"{}\");\n-    }\n-\n-    #[test]\n-    fn test_clone() {\n-        let mut a = VecMap::new();\n-\n-        a.insert(1, 'x');\n-        a.insert(4, 'y');\n-        a.insert(6, 'z');\n-\n-        assert!(a.clone() == a);\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        let mut a = VecMap::new();\n-        let mut b = VecMap::new();\n-\n-        assert!(a == b);\n-        assert!(a.insert(0, 5).is_none());\n-        assert!(a != b);\n-        assert!(b.insert(0, 4).is_none());\n-        assert!(a != b);\n-        assert!(a.insert(5, 19).is_none());\n-        assert!(a != b);\n-        assert!(!b.insert(0, 5).is_none());\n-        assert!(a != b);\n-        assert!(b.insert(5, 19).is_none());\n-        assert!(a == b);\n-\n-        a = VecMap::new();\n-        b = VecMap::with_capacity(1);\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_lt() {\n-        let mut a = VecMap::new();\n-        let mut b = VecMap::new();\n-\n-        assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2, 5).is_none());\n-        assert!(a < b);\n-        assert!(a.insert(2, 7).is_none());\n-        assert!(!(a < b) && b < a);\n-        assert!(b.insert(1, 0).is_none());\n-        assert!(b < a);\n-        assert!(a.insert(0, 6).is_none());\n-        assert!(a < b);\n-        assert!(a.insert(6, 2).is_none());\n-        assert!(a < b && !(b < a));\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = VecMap::new();\n-        let mut b = VecMap::new();\n-\n-        assert!(a <= b && a >= b);\n-        assert!(a.insert(1, 1).is_none());\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        assert!(b.insert(2, 2).is_none());\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        let mut x = VecMap::new();\n-        let mut y = VecMap::new();\n-\n-        assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n-        x.insert(1, 'a');\n-        x.insert(2, 'b');\n-        x.insert(3, 'c');\n-\n-        y.insert(3, 'c');\n-        y.insert(2, 'b');\n-        y.insert(1, 'a');\n-\n-        assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n-\n-        x.insert(1000, 'd');\n-        x.remove(&1000);\n-\n-        assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')];\n-\n-        let map: VecMap<_> = xs.iter().cloned().collect();\n-\n-        for &(k, v) in &xs {\n-            assert_eq!(map.get(&k), Some(&v));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_index() {\n-        let mut map = VecMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(2, 1);\n-        map.insert(3, 4);\n-\n-        assert_eq!(map[3], 4);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_index_nonexistent() {\n-        let mut map = VecMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(2, 1);\n-        map.insert(3, 4);\n-\n-        map[4];\n-    }\n-\n-    #[test]\n-    fn test_entry(){\n-        let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n-\n-        let mut map: VecMap<_> = xs.iter().cloned().collect();\n-\n-        // Existing key (insert)\n-        match map.entry(1) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                assert_eq!(view.get(), &10);\n-                assert_eq!(view.insert(100), 10);\n-            }\n-        }\n-        assert_eq!(map.get(&1).unwrap(), &100);\n-        assert_eq!(map.len(), 6);\n-\n-\n-        // Existing key (update)\n-        match map.entry(2) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                let v = view.get_mut();\n-                *v *= 10;\n-            }\n-        }\n-        assert_eq!(map.get(&2).unwrap(), &200);\n-        assert_eq!(map.len(), 6);\n-\n-        // Existing key (take)\n-        match map.entry(3) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(view) => {\n-                assert_eq!(view.remove(), 30);\n-            }\n-        }\n-        assert_eq!(map.get(&3), None);\n-        assert_eq!(map.len(), 5);\n-\n-\n-        // Inexistent key (insert)\n-        match map.entry(10) {\n-            Occupied(_) => unreachable!(),\n-            Vacant(view) => {\n-                assert_eq!(*view.insert(1000), 1000);\n-            }\n-        }\n-        assert_eq!(map.get(&10).unwrap(), &1000);\n-        assert_eq!(map.len(), 6);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    use super::VecMap;\n-\n-    map_insert_rand_bench!{insert_rand_100,    100,    VecMap}\n-    map_insert_rand_bench!{insert_rand_10_000, 10_000, VecMap}\n-\n-    map_insert_seq_bench!{insert_seq_100,    100,    VecMap}\n-    map_insert_seq_bench!{insert_seq_10_000, 10_000, VecMap}\n-\n-    map_find_rand_bench!{find_rand_100,    100,    VecMap}\n-    map_find_rand_bench!{find_rand_10_000, 10_000, VecMap}\n-\n-    map_find_seq_bench!{find_seq_100,    100,    VecMap}\n-    map_find_seq_bench!{find_seq_10_000, 10_000, VecMap}\n-}"}, {"sha": "2396a577589f2ee94f7a847372b68c4263bc3fd3", "filename": "src/libcollectionstest/bench.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbench.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -66,11 +66,11 @@ macro_rules! map_find_rand_bench {\n     ($name: ident, $n: expr, $map: ident) => (\n         #[bench]\n         pub fn $name(b: &mut ::test::Bencher) {\n-            use std::rand;\n             use std::iter::IteratorExt;\n             use std::rand::Rng;\n+            use std::rand;\n+            use std::vec::Vec;\n             use test::black_box;\n-            use vec::Vec;\n \n             let mut map = $map::new();\n             let n: usize = $n;", "previous_filename": "src/libcollections/bench.rs"}, {"sha": "47a366bb1e2e0dd937eac062be37bfd06c208391", "filename": "src/libcollectionstest/binary_heap.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbinary_heap.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,219 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::BinaryHeap;\n+\n+#[test]\n+fn test_iterator() {\n+    let data = vec![5, 9, 3];\n+    let iterout = [9, 5, 3];\n+    let heap = BinaryHeap::from_vec(data);\n+    let mut i = 0;\n+    for el in &heap {\n+        assert_eq!(*el, iterout[i]);\n+        i += 1;\n+    }\n+}\n+\n+#[test]\n+fn test_iterator_reverse() {\n+    let data = vec![5, 9, 3];\n+    let iterout = vec![3, 5, 9];\n+    let pq = BinaryHeap::from_vec(data);\n+\n+    let v: Vec<_> = pq.iter().rev().cloned().collect();\n+    assert_eq!(v, iterout);\n+}\n+\n+#[test]\n+fn test_move_iter() {\n+    let data = vec![5, 9, 3];\n+    let iterout = vec![9, 5, 3];\n+    let pq = BinaryHeap::from_vec(data);\n+\n+    let v: Vec<_> = pq.into_iter().collect();\n+    assert_eq!(v, iterout);\n+}\n+\n+#[test]\n+fn test_move_iter_size_hint() {\n+    let data = vec![5, 9];\n+    let pq = BinaryHeap::from_vec(data);\n+\n+    let mut it = pq.into_iter();\n+\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+    assert_eq!(it.next(), Some(9));\n+\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next(), Some(5));\n+\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_move_iter_reverse() {\n+    let data = vec![5, 9, 3];\n+    let iterout = vec![3, 5, 9];\n+    let pq = BinaryHeap::from_vec(data);\n+\n+    let v: Vec<_> = pq.into_iter().rev().collect();\n+    assert_eq!(v, iterout);\n+}\n+\n+#[test]\n+fn test_peek_and_pop() {\n+    let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n+    let mut sorted = data.clone();\n+    sorted.sort();\n+    let mut heap = BinaryHeap::from_vec(data);\n+    while !heap.is_empty() {\n+        assert_eq!(heap.peek().unwrap(), sorted.last().unwrap());\n+        assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n+    }\n+}\n+\n+#[test]\n+fn test_push() {\n+    let mut heap = BinaryHeap::from_vec(vec![2, 4, 9]);\n+    assert_eq!(heap.len(), 3);\n+    assert!(*heap.peek().unwrap() == 9);\n+    heap.push(11);\n+    assert_eq!(heap.len(), 4);\n+    assert!(*heap.peek().unwrap() == 11);\n+    heap.push(5);\n+    assert_eq!(heap.len(), 5);\n+    assert!(*heap.peek().unwrap() == 11);\n+    heap.push(27);\n+    assert_eq!(heap.len(), 6);\n+    assert!(*heap.peek().unwrap() == 27);\n+    heap.push(3);\n+    assert_eq!(heap.len(), 7);\n+    assert!(*heap.peek().unwrap() == 27);\n+    heap.push(103);\n+    assert_eq!(heap.len(), 8);\n+    assert!(*heap.peek().unwrap() == 103);\n+}\n+\n+#[test]\n+fn test_push_unique() {\n+    let mut heap = BinaryHeap::<Box<_>>::from_vec(vec![box 2, box 4, box 9]);\n+    assert_eq!(heap.len(), 3);\n+    assert!(*heap.peek().unwrap() == box 9);\n+    heap.push(box 11);\n+    assert_eq!(heap.len(), 4);\n+    assert!(*heap.peek().unwrap() == box 11);\n+    heap.push(box 5);\n+    assert_eq!(heap.len(), 5);\n+    assert!(*heap.peek().unwrap() == box 11);\n+    heap.push(box 27);\n+    assert_eq!(heap.len(), 6);\n+    assert!(*heap.peek().unwrap() == box 27);\n+    heap.push(box 3);\n+    assert_eq!(heap.len(), 7);\n+    assert!(*heap.peek().unwrap() == box 27);\n+    heap.push(box 103);\n+    assert_eq!(heap.len(), 8);\n+    assert!(*heap.peek().unwrap() == box 103);\n+}\n+\n+#[test]\n+fn test_push_pop() {\n+    let mut heap = BinaryHeap::from_vec(vec![5, 5, 2, 1, 3]);\n+    assert_eq!(heap.len(), 5);\n+    assert_eq!(heap.push_pop(6), 6);\n+    assert_eq!(heap.len(), 5);\n+    assert_eq!(heap.push_pop(0), 5);\n+    assert_eq!(heap.len(), 5);\n+    assert_eq!(heap.push_pop(4), 5);\n+    assert_eq!(heap.len(), 5);\n+    assert_eq!(heap.push_pop(1), 4);\n+    assert_eq!(heap.len(), 5);\n+}\n+\n+#[test]\n+fn test_replace() {\n+    let mut heap = BinaryHeap::from_vec(vec![5, 5, 2, 1, 3]);\n+    assert_eq!(heap.len(), 5);\n+    assert_eq!(heap.replace(6).unwrap(), 5);\n+    assert_eq!(heap.len(), 5);\n+    assert_eq!(heap.replace(0).unwrap(), 6);\n+    assert_eq!(heap.len(), 5);\n+    assert_eq!(heap.replace(4).unwrap(), 5);\n+    assert_eq!(heap.len(), 5);\n+    assert_eq!(heap.replace(1).unwrap(), 4);\n+    assert_eq!(heap.len(), 5);\n+}\n+\n+fn check_to_vec(mut data: Vec<i32>) {\n+    let heap = BinaryHeap::from_vec(data.clone());\n+    let mut v = heap.clone().into_vec();\n+    v.sort();\n+    data.sort();\n+\n+    assert_eq!(v, data);\n+    assert_eq!(heap.into_sorted_vec(), data);\n+}\n+\n+#[test]\n+fn test_to_vec() {\n+    check_to_vec(vec![]);\n+    check_to_vec(vec![5]);\n+    check_to_vec(vec![3, 2]);\n+    check_to_vec(vec![2, 3]);\n+    check_to_vec(vec![5, 1, 2]);\n+    check_to_vec(vec![1, 100, 2, 3]);\n+    check_to_vec(vec![1, 3, 5, 7, 9, 2, 4, 6, 8, 0]);\n+    check_to_vec(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    check_to_vec(vec![9, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0]);\n+    check_to_vec(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+    check_to_vec(vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]);\n+    check_to_vec(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2]);\n+    check_to_vec(vec![5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1]);\n+}\n+\n+#[test]\n+fn test_empty_pop() {\n+    let mut heap = BinaryHeap::<i32>::new();\n+    assert!(heap.pop().is_none());\n+}\n+\n+#[test]\n+fn test_empty_peek() {\n+    let empty = BinaryHeap::<i32>::new();\n+    assert!(empty.peek().is_none());\n+}\n+\n+#[test]\n+fn test_empty_replace() {\n+    let mut heap = BinaryHeap::new();\n+    assert!(heap.replace(5).is_none());\n+}\n+\n+#[test]\n+fn test_from_iter() {\n+    let xs = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n+\n+    let mut q: BinaryHeap<_> = xs.iter().rev().cloned().collect();\n+\n+    for &x in &xs {\n+        assert_eq!(q.pop().unwrap(), x);\n+    }\n+}\n+\n+#[test]\n+fn test_drain() {\n+    let mut q: BinaryHeap<_> = [9, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n+\n+    assert_eq!(q.drain().take(5).count(), 5);\n+\n+    assert!(q.is_empty());\n+}"}, {"sha": "8e06524f2e5ae539c315cb4205979715990037b1", "filename": "src/libcollectionstest/bit/mod.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fmod.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod set;\n+mod vec;"}, {"sha": "4b4995d5fa7d9dc0bbfb20960dfdf6252db108af", "filename": "src/libcollectionstest/bit/set.rs", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbit%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbit%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fset.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,441 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp::Ordering::{Equal, Greater, Less};\n+use std::collections::{BitSet, BitVec};\n+use std::iter::range_step;\n+\n+#[test]\n+fn test_bit_set_show() {\n+    let mut s = BitSet::new();\n+    s.insert(1);\n+    s.insert(10);\n+    s.insert(50);\n+    s.insert(2);\n+    assert_eq!(\"{1, 2, 10, 50}\", format!(\"{:?}\", s));\n+}\n+\n+#[test]\n+fn test_bit_set_from_usizes() {\n+    let usizes = vec![0, 2, 2, 3];\n+    let a: BitSet = usizes.into_iter().collect();\n+    let mut b = BitSet::new();\n+    b.insert(0);\n+    b.insert(2);\n+    b.insert(3);\n+    assert_eq!(a, b);\n+}\n+\n+#[test]\n+fn test_bit_set_iterator() {\n+    let usizes = vec![0, 2, 2, 3];\n+    let bit_vec: BitSet = usizes.into_iter().collect();\n+\n+    let idxs: Vec<_> = bit_vec.iter().collect();\n+    assert_eq!(idxs, [0, 2, 3]);\n+\n+    let long: BitSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n+    let real: Vec<_> = range_step(0, 10000, 2).collect();\n+\n+    let idxs: Vec<_> = long.iter().collect();\n+    assert_eq!(idxs, real);\n+}\n+\n+#[test]\n+fn test_bit_set_frombit_vec_init() {\n+    let bools = [true, false];\n+    let lengths = [10, 64, 100];\n+    for &b in &bools {\n+        for &l in &lengths {\n+            let bitset = BitSet::from_bit_vec(BitVec::from_elem(l, b));\n+            assert_eq!(bitset.contains(&1), b);\n+            assert_eq!(bitset.contains(&(l-1)), b);\n+            assert!(!bitset.contains(&l));\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_bit_vec_masking() {\n+    let b = BitVec::from_elem(140, true);\n+    let mut bs = BitSet::from_bit_vec(b);\n+    assert!(bs.contains(&139));\n+    assert!(!bs.contains(&140));\n+    assert!(bs.insert(150));\n+    assert!(!bs.contains(&140));\n+    assert!(!bs.contains(&149));\n+    assert!(bs.contains(&150));\n+    assert!(!bs.contains(&151));\n+}\n+\n+#[test]\n+fn test_bit_set_basic() {\n+    let mut b = BitSet::new();\n+    assert!(b.insert(3));\n+    assert!(!b.insert(3));\n+    assert!(b.contains(&3));\n+    assert!(b.insert(4));\n+    assert!(!b.insert(4));\n+    assert!(b.contains(&3));\n+    assert!(b.insert(400));\n+    assert!(!b.insert(400));\n+    assert!(b.contains(&400));\n+    assert_eq!(b.len(), 3);\n+}\n+\n+#[test]\n+fn test_bit_set_intersection() {\n+    let mut a = BitSet::new();\n+    let mut b = BitSet::new();\n+\n+    assert!(a.insert(11));\n+    assert!(a.insert(1));\n+    assert!(a.insert(3));\n+    assert!(a.insert(77));\n+    assert!(a.insert(103));\n+    assert!(a.insert(5));\n+\n+    assert!(b.insert(2));\n+    assert!(b.insert(11));\n+    assert!(b.insert(77));\n+    assert!(b.insert(5));\n+    assert!(b.insert(3));\n+\n+    let expected = [3, 5, 11, 77];\n+    let actual: Vec<_> = a.intersection(&b).collect();\n+    assert_eq!(actual, expected);\n+}\n+\n+#[test]\n+fn test_bit_set_difference() {\n+    let mut a = BitSet::new();\n+    let mut b = BitSet::new();\n+\n+    assert!(a.insert(1));\n+    assert!(a.insert(3));\n+    assert!(a.insert(5));\n+    assert!(a.insert(200));\n+    assert!(a.insert(500));\n+\n+    assert!(b.insert(3));\n+    assert!(b.insert(200));\n+\n+    let expected = [1, 5, 500];\n+    let actual: Vec<_> = a.difference(&b).collect();\n+    assert_eq!(actual, expected);\n+}\n+\n+#[test]\n+fn test_bit_set_symmetric_difference() {\n+    let mut a = BitSet::new();\n+    let mut b = BitSet::new();\n+\n+    assert!(a.insert(1));\n+    assert!(a.insert(3));\n+    assert!(a.insert(5));\n+    assert!(a.insert(9));\n+    assert!(a.insert(11));\n+\n+    assert!(b.insert(3));\n+    assert!(b.insert(9));\n+    assert!(b.insert(14));\n+    assert!(b.insert(220));\n+\n+    let expected = [1, 5, 11, 14, 220];\n+    let actual: Vec<_> = a.symmetric_difference(&b).collect();\n+    assert_eq!(actual, expected);\n+}\n+\n+#[test]\n+fn test_bit_set_union() {\n+    let mut a = BitSet::new();\n+    let mut b = BitSet::new();\n+    assert!(a.insert(1));\n+    assert!(a.insert(3));\n+    assert!(a.insert(5));\n+    assert!(a.insert(9));\n+    assert!(a.insert(11));\n+    assert!(a.insert(160));\n+    assert!(a.insert(19));\n+    assert!(a.insert(24));\n+    assert!(a.insert(200));\n+\n+    assert!(b.insert(1));\n+    assert!(b.insert(5));\n+    assert!(b.insert(9));\n+    assert!(b.insert(13));\n+    assert!(b.insert(19));\n+\n+    let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160, 200];\n+    let actual: Vec<_> = a.union(&b).collect();\n+    assert_eq!(actual, expected);\n+}\n+\n+#[test]\n+fn test_bit_set_subset() {\n+    let mut set1 = BitSet::new();\n+    let mut set2 = BitSet::new();\n+\n+    assert!(set1.is_subset(&set2)); //  {}  {}\n+    set2.insert(100);\n+    assert!(set1.is_subset(&set2)); //  {}  { 1 }\n+    set2.insert(200);\n+    assert!(set1.is_subset(&set2)); //  {}  { 1, 2 }\n+    set1.insert(200);\n+    assert!(set1.is_subset(&set2)); //  { 2 }  { 1, 2 }\n+    set1.insert(300);\n+    assert!(!set1.is_subset(&set2)); // { 2, 3 }  { 1, 2 }\n+    set2.insert(300);\n+    assert!(set1.is_subset(&set2)); // { 2, 3 }  { 1, 2, 3 }\n+    set2.insert(400);\n+    assert!(set1.is_subset(&set2)); // { 2, 3 }  { 1, 2, 3, 4 }\n+    set2.remove(&100);\n+    assert!(set1.is_subset(&set2)); // { 2, 3 }  { 2, 3, 4 }\n+    set2.remove(&300);\n+    assert!(!set1.is_subset(&set2)); // { 2, 3 }  { 2, 4 }\n+    set1.remove(&300);\n+    assert!(set1.is_subset(&set2)); // { 2 }  { 2, 4 }\n+}\n+\n+#[test]\n+fn test_bit_set_is_disjoint() {\n+    let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+    let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01000000]));\n+    let c = BitSet::new();\n+    let d = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00110000]));\n+\n+    assert!(!a.is_disjoint(&d));\n+    assert!(!d.is_disjoint(&a));\n+\n+    assert!(a.is_disjoint(&b));\n+    assert!(a.is_disjoint(&c));\n+    assert!(b.is_disjoint(&a));\n+    assert!(b.is_disjoint(&c));\n+    assert!(c.is_disjoint(&a));\n+    assert!(c.is_disjoint(&b));\n+}\n+\n+#[test]\n+fn test_bit_set_union_with() {\n+    //a should grow to include larger elements\n+    let mut a = BitSet::new();\n+    a.insert(0);\n+    let mut b = BitSet::new();\n+    b.insert(5);\n+    let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n+    a.union_with(&b);\n+    assert_eq!(a, expected);\n+\n+    // Standard\n+    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+    let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n+    let c = a.clone();\n+    a.union_with(&b);\n+    b.union_with(&c);\n+    assert_eq!(a.len(), 4);\n+    assert_eq!(b.len(), 4);\n+}\n+\n+#[test]\n+fn test_bit_set_intersect_with() {\n+    // Explicitly 0'ed bits\n+    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+    let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+    let c = a.clone();\n+    a.intersect_with(&b);\n+    b.intersect_with(&c);\n+    assert!(a.is_empty());\n+    assert!(b.is_empty());\n+\n+    // Uninitialized bits should behave like 0's\n+    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+    let mut b = BitSet::new();\n+    let c = a.clone();\n+    a.intersect_with(&b);\n+    b.intersect_with(&c);\n+    assert!(a.is_empty());\n+    assert!(b.is_empty());\n+\n+    // Standard\n+    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+    let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n+    let c = a.clone();\n+    a.intersect_with(&b);\n+    b.intersect_with(&c);\n+    assert_eq!(a.len(), 2);\n+    assert_eq!(b.len(), 2);\n+}\n+\n+#[test]\n+fn test_bit_set_difference_with() {\n+    // Explicitly 0'ed bits\n+    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+    let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+    a.difference_with(&b);\n+    assert!(a.is_empty());\n+\n+    // Uninitialized bits should behave like 0's\n+    let mut a = BitSet::new();\n+    let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11111111]));\n+    a.difference_with(&b);\n+    assert!(a.is_empty());\n+\n+    // Standard\n+    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+    let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n+    let c = a.clone();\n+    a.difference_with(&b);\n+    b.difference_with(&c);\n+    assert_eq!(a.len(), 1);\n+    assert_eq!(b.len(), 1);\n+}\n+\n+#[test]\n+fn test_bit_set_symmetric_difference_with() {\n+    //a should grow to include larger elements\n+    let mut a = BitSet::new();\n+    a.insert(0);\n+    a.insert(1);\n+    let mut b = BitSet::new();\n+    b.insert(1);\n+    b.insert(5);\n+    let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n+    a.symmetric_difference_with(&b);\n+    assert_eq!(a, expected);\n+\n+    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+    let b = BitSet::new();\n+    let c = a.clone();\n+    a.symmetric_difference_with(&b);\n+    assert_eq!(a, c);\n+\n+    // Standard\n+    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11100010]));\n+    let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101010]));\n+    let c = a.clone();\n+    a.symmetric_difference_with(&b);\n+    b.symmetric_difference_with(&c);\n+    assert_eq!(a.len(), 2);\n+    assert_eq!(b.len(), 2);\n+}\n+\n+#[test]\n+fn test_bit_set_eq() {\n+    let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+    let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+    let c = BitSet::new();\n+\n+    assert!(a == a);\n+    assert!(a != b);\n+    assert!(a != c);\n+    assert!(b == b);\n+    assert!(b == c);\n+    assert!(c == c);\n+}\n+\n+#[test]\n+fn test_bit_set_cmp() {\n+    let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+    let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+    let c = BitSet::new();\n+\n+    assert_eq!(a.cmp(&b), Greater);\n+    assert_eq!(a.cmp(&c), Greater);\n+    assert_eq!(b.cmp(&a), Less);\n+    assert_eq!(b.cmp(&c), Equal);\n+    assert_eq!(c.cmp(&a), Less);\n+    assert_eq!(c.cmp(&b), Equal);\n+}\n+\n+#[test]\n+fn test_bit_vec_remove() {\n+    let mut a = BitSet::new();\n+\n+    assert!(a.insert(1));\n+    assert!(a.remove(&1));\n+\n+    assert!(a.insert(100));\n+    assert!(a.remove(&100));\n+\n+    assert!(a.insert(1000));\n+    assert!(a.remove(&1000));\n+    a.shrink_to_fit();\n+}\n+\n+#[test]\n+fn test_bit_vec_clone() {\n+    let mut a = BitSet::new();\n+\n+    assert!(a.insert(1));\n+    assert!(a.insert(100));\n+    assert!(a.insert(1000));\n+\n+    let mut b = a.clone();\n+\n+    assert!(a == b);\n+\n+    assert!(b.remove(&1));\n+    assert!(a.contains(&1));\n+\n+    assert!(a.remove(&1000));\n+    assert!(b.contains(&1000));\n+}\n+\n+mod bench {\n+    use std::collections::{BitSet, BitVec};\n+    use std::rand::{Rng, self};\n+    use std::u32;\n+\n+    use test::{Bencher, black_box};\n+\n+    const BENCH_BITS : usize = 1 << 14;\n+\n+    fn rng() -> rand::IsaacRng {\n+        let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n+        rand::SeedableRng::from_seed(seed)\n+    }\n+\n+    #[bench]\n+    fn bench_bit_vecset_small(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bit_vec = BitSet::new();\n+        b.iter(|| {\n+            for _ in 0..100 {\n+                bit_vec.insert((r.next_u32() as usize) % u32::BITS as usize);\n+            }\n+            black_box(&bit_vec);\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bit_vecset_big(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bit_vec = BitSet::new();\n+        b.iter(|| {\n+            for _ in 0..100 {\n+                bit_vec.insert((r.next_u32() as usize) % BENCH_BITS);\n+            }\n+            black_box(&bit_vec);\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bit_vecset_iter(b: &mut Bencher) {\n+        let bit_vec = BitSet::from_bit_vec(BitVec::from_fn(BENCH_BITS,\n+                                              |idx| {idx % 3 == 0}));\n+        b.iter(|| {\n+            let mut sum = 0;\n+            for idx in &bit_vec {\n+                sum += idx as usize;\n+            }\n+            sum\n+        })\n+    }\n+}"}, {"sha": "3826974d1ad6b13ff374e8694fa86ea2255277ff", "filename": "src/libcollectionstest/bit/vec.rs", "status": "added", "additions": 729, "deletions": 0, "changes": 729, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fvec.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,729 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::BitVec;\n+use std::u32;\n+\n+#[test]\n+fn test_to_str() {\n+    let zerolen = BitVec::new();\n+    assert_eq!(format!(\"{:?}\", zerolen), \"\");\n+\n+    let eightbits = BitVec::from_elem(8, false);\n+    assert_eq!(format!(\"{:?}\", eightbits), \"00000000\")\n+}\n+\n+#[test]\n+fn test_0_elements() {\n+    let act = BitVec::new();\n+    let exp = Vec::new();\n+    assert!(act.eq_vec(&exp));\n+    assert!(act.none() && act.all());\n+}\n+\n+#[test]\n+fn test_1_element() {\n+    let mut act = BitVec::from_elem(1, false);\n+    assert!(act.eq_vec(&[false]));\n+    assert!(act.none() && !act.all());\n+    act = BitVec::from_elem(1, true);\n+    assert!(act.eq_vec(&[true]));\n+    assert!(!act.none() && act.all());\n+}\n+\n+#[test]\n+fn test_2_elements() {\n+    let mut b = BitVec::from_elem(2, false);\n+    b.set(0, true);\n+    b.set(1, false);\n+    assert_eq!(format!(\"{:?}\", b), \"10\");\n+    assert!(!b.none() && !b.all());\n+}\n+\n+#[test]\n+fn test_10_elements() {\n+    let mut act;\n+    // all 0\n+\n+    act = BitVec::from_elem(10, false);\n+    assert!((act.eq_vec(\n+                &[false, false, false, false, false, false, false, false, false, false])));\n+    assert!(act.none() && !act.all());\n+    // all 1\n+\n+    act = BitVec::from_elem(10, true);\n+    assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n+    assert!(!act.none() && act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(10, false);\n+    act.set(0, true);\n+    act.set(1, true);\n+    act.set(2, true);\n+    act.set(3, true);\n+    act.set(4, true);\n+    assert!((act.eq_vec(&[true, true, true, true, true, false, false, false, false, false])));\n+    assert!(!act.none() && !act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(10, false);\n+    act.set(5, true);\n+    act.set(6, true);\n+    act.set(7, true);\n+    act.set(8, true);\n+    act.set(9, true);\n+    assert!((act.eq_vec(&[false, false, false, false, false, true, true, true, true, true])));\n+    assert!(!act.none() && !act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(10, false);\n+    act.set(0, true);\n+    act.set(3, true);\n+    act.set(6, true);\n+    act.set(9, true);\n+    assert!((act.eq_vec(&[true, false, false, true, false, false, true, false, false, true])));\n+    assert!(!act.none() && !act.all());\n+}\n+\n+#[test]\n+fn test_31_elements() {\n+    let mut act;\n+    // all 0\n+\n+    act = BitVec::from_elem(31, false);\n+    assert!(act.eq_vec(\n+            &[false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false]));\n+    assert!(act.none() && !act.all());\n+    // all 1\n+\n+    act = BitVec::from_elem(31, true);\n+    assert!(act.eq_vec(\n+            &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n+              true, true, true, true, true, true, true, true, true, true, true, true, true,\n+              true, true, true, true, true]));\n+    assert!(!act.none() && act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(31, false);\n+    act.set(0, true);\n+    act.set(1, true);\n+    act.set(2, true);\n+    act.set(3, true);\n+    act.set(4, true);\n+    act.set(5, true);\n+    act.set(6, true);\n+    act.set(7, true);\n+    assert!(act.eq_vec(\n+            &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false]));\n+    assert!(!act.none() && !act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(31, false);\n+    act.set(16, true);\n+    act.set(17, true);\n+    act.set(18, true);\n+    act.set(19, true);\n+    act.set(20, true);\n+    act.set(21, true);\n+    act.set(22, true);\n+    act.set(23, true);\n+    assert!(act.eq_vec(\n+            &[false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, true, true, true, true, true, true, true, true,\n+              false, false, false, false, false, false, false]));\n+    assert!(!act.none() && !act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(31, false);\n+    act.set(24, true);\n+    act.set(25, true);\n+    act.set(26, true);\n+    act.set(27, true);\n+    act.set(28, true);\n+    act.set(29, true);\n+    act.set(30, true);\n+    assert!(act.eq_vec(\n+            &[false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, true, true, true, true, true, true, true]));\n+    assert!(!act.none() && !act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(31, false);\n+    act.set(3, true);\n+    act.set(17, true);\n+    act.set(30, true);\n+    assert!(act.eq_vec(\n+            &[false, false, false, true, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, true, false, false, false, false, false, false,\n+              false, false, false, false, false, false, true]));\n+    assert!(!act.none() && !act.all());\n+}\n+\n+#[test]\n+fn test_32_elements() {\n+    let mut act;\n+    // all 0\n+\n+    act = BitVec::from_elem(32, false);\n+    assert!(act.eq_vec(\n+            &[false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false, false]));\n+    assert!(act.none() && !act.all());\n+    // all 1\n+\n+    act = BitVec::from_elem(32, true);\n+    assert!(act.eq_vec(\n+            &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n+              true, true, true, true, true, true, true, true, true, true, true, true, true,\n+              true, true, true, true, true, true]));\n+    assert!(!act.none() && act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(32, false);\n+    act.set(0, true);\n+    act.set(1, true);\n+    act.set(2, true);\n+    act.set(3, true);\n+    act.set(4, true);\n+    act.set(5, true);\n+    act.set(6, true);\n+    act.set(7, true);\n+    assert!(act.eq_vec(\n+            &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false]));\n+    assert!(!act.none() && !act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(32, false);\n+    act.set(16, true);\n+    act.set(17, true);\n+    act.set(18, true);\n+    act.set(19, true);\n+    act.set(20, true);\n+    act.set(21, true);\n+    act.set(22, true);\n+    act.set(23, true);\n+    assert!(act.eq_vec(\n+            &[false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, true, true, true, true, true, true, true, true,\n+              false, false, false, false, false, false, false, false]));\n+    assert!(!act.none() && !act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(32, false);\n+    act.set(24, true);\n+    act.set(25, true);\n+    act.set(26, true);\n+    act.set(27, true);\n+    act.set(28, true);\n+    act.set(29, true);\n+    act.set(30, true);\n+    act.set(31, true);\n+    assert!(act.eq_vec(\n+            &[false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, true, true, true, true, true, true, true, true]));\n+    assert!(!act.none() && !act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(32, false);\n+    act.set(3, true);\n+    act.set(17, true);\n+    act.set(30, true);\n+    act.set(31, true);\n+    assert!(act.eq_vec(\n+            &[false, false, false, true, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, true, false, false, false, false, false, false,\n+              false, false, false, false, false, false, true, true]));\n+    assert!(!act.none() && !act.all());\n+}\n+\n+#[test]\n+fn test_33_elements() {\n+    let mut act;\n+    // all 0\n+\n+    act = BitVec::from_elem(33, false);\n+    assert!(act.eq_vec(\n+            &[false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false, false, false]));\n+    assert!(act.none() && !act.all());\n+    // all 1\n+\n+    act = BitVec::from_elem(33, true);\n+    assert!(act.eq_vec(\n+            &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n+              true, true, true, true, true, true, true, true, true, true, true, true, true,\n+              true, true, true, true, true, true, true]));\n+    assert!(!act.none() && act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(33, false);\n+    act.set(0, true);\n+    act.set(1, true);\n+    act.set(2, true);\n+    act.set(3, true);\n+    act.set(4, true);\n+    act.set(5, true);\n+    act.set(6, true);\n+    act.set(7, true);\n+    assert!(act.eq_vec(\n+            &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false]));\n+    assert!(!act.none() && !act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(33, false);\n+    act.set(16, true);\n+    act.set(17, true);\n+    act.set(18, true);\n+    act.set(19, true);\n+    act.set(20, true);\n+    act.set(21, true);\n+    act.set(22, true);\n+    act.set(23, true);\n+    assert!(act.eq_vec(\n+            &[false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, true, true, true, true, true, true, true, true,\n+              false, false, false, false, false, false, false, false, false]));\n+    assert!(!act.none() && !act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(33, false);\n+    act.set(24, true);\n+    act.set(25, true);\n+    act.set(26, true);\n+    act.set(27, true);\n+    act.set(28, true);\n+    act.set(29, true);\n+    act.set(30, true);\n+    act.set(31, true);\n+    assert!(act.eq_vec(\n+            &[false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, false, false, false, false, false, false,\n+              false, false, true, true, true, true, true, true, true, true, false]));\n+    assert!(!act.none() && !act.all());\n+    // mixed\n+\n+    act = BitVec::from_elem(33, false);\n+    act.set(3, true);\n+    act.set(17, true);\n+    act.set(30, true);\n+    act.set(31, true);\n+    act.set(32, true);\n+    assert!(act.eq_vec(\n+            &[false, false, false, true, false, false, false, false, false, false, false, false,\n+              false, false, false, false, false, true, false, false, false, false, false, false,\n+              false, false, false, false, false, false, true, true, true]));\n+    assert!(!act.none() && !act.all());\n+}\n+\n+#[test]\n+fn test_equal_differing_sizes() {\n+    let v0 = BitVec::from_elem(10, false);\n+    let v1 = BitVec::from_elem(11, false);\n+    assert!(v0 != v1);\n+}\n+\n+#[test]\n+fn test_equal_greatly_differing_sizes() {\n+    let v0 = BitVec::from_elem(10, false);\n+    let v1 = BitVec::from_elem(110, false);\n+    assert!(v0 != v1);\n+}\n+\n+#[test]\n+fn test_equal_sneaky_small() {\n+    let mut a = BitVec::from_elem(1, false);\n+    a.set(0, true);\n+\n+    let mut b = BitVec::from_elem(1, true);\n+    b.set(0, true);\n+\n+    assert_eq!(a, b);\n+}\n+\n+#[test]\n+fn test_equal_sneaky_big() {\n+    let mut a = BitVec::from_elem(100, false);\n+    for i in 0..100 {\n+        a.set(i, true);\n+    }\n+\n+    let mut b = BitVec::from_elem(100, true);\n+    for i in 0..100 {\n+        b.set(i, true);\n+    }\n+\n+    assert_eq!(a, b);\n+}\n+\n+#[test]\n+fn test_from_bytes() {\n+    let bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+    let str = concat!(\"10110110\", \"00000000\", \"11111111\");\n+    assert_eq!(format!(\"{:?}\", bit_vec), str);\n+}\n+\n+#[test]\n+fn test_to_bytes() {\n+    let mut bv = BitVec::from_elem(3, true);\n+    bv.set(1, false);\n+    assert_eq!(bv.to_bytes(), [0b10100000]);\n+\n+    let mut bv = BitVec::from_elem(9, false);\n+    bv.set(2, true);\n+    bv.set(8, true);\n+    assert_eq!(bv.to_bytes(), [0b00100000, 0b10000000]);\n+}\n+\n+#[test]\n+fn test_from_bools() {\n+    let bools = vec![true, false, true, true];\n+    let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n+    assert_eq!(format!(\"{:?}\", bit_vec), \"1011\");\n+}\n+\n+#[test]\n+fn test_to_bools() {\n+    let bools = vec![false, false, true, false, false, true, true, false];\n+    assert_eq!(BitVec::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n+}\n+\n+#[test]\n+fn test_bit_vec_iterator() {\n+    let bools = vec![true, false, true, true];\n+    let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n+\n+    assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), bools);\n+\n+    let long: Vec<_> = (0..10000).map(|i| i % 2 == 0).collect();\n+    let bit_vec: BitVec = long.iter().map(|n| *n).collect();\n+    assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), long)\n+}\n+\n+#[test]\n+fn test_small_difference() {\n+    let mut b1 = BitVec::from_elem(3, false);\n+    let mut b2 = BitVec::from_elem(3, false);\n+    b1.set(0, true);\n+    b1.set(1, true);\n+    b2.set(1, true);\n+    b2.set(2, true);\n+    assert!(b1.difference(&b2));\n+    assert!(b1[0]);\n+    assert!(!b1[1]);\n+    assert!(!b1[2]);\n+}\n+\n+#[test]\n+fn test_big_difference() {\n+    let mut b1 = BitVec::from_elem(100, false);\n+    let mut b2 = BitVec::from_elem(100, false);\n+    b1.set(0, true);\n+    b1.set(40, true);\n+    b2.set(40, true);\n+    b2.set(80, true);\n+    assert!(b1.difference(&b2));\n+    assert!(b1[0]);\n+    assert!(!b1[40]);\n+    assert!(!b1[80]);\n+}\n+\n+#[test]\n+fn test_small_clear() {\n+    let mut b = BitVec::from_elem(14, true);\n+    assert!(!b.none() && b.all());\n+    b.clear();\n+    assert!(b.none() && !b.all());\n+}\n+\n+#[test]\n+fn test_big_clear() {\n+    let mut b = BitVec::from_elem(140, true);\n+    assert!(!b.none() && b.all());\n+    b.clear();\n+    assert!(b.none() && !b.all());\n+}\n+\n+#[test]\n+fn test_bit_vec_lt() {\n+    let mut a = BitVec::from_elem(5, false);\n+    let mut b = BitVec::from_elem(5, false);\n+\n+    assert!(!(a < b) && !(b < a));\n+    b.set(2, true);\n+    assert!(a < b);\n+    a.set(3, true);\n+    assert!(a < b);\n+    a.set(2, true);\n+    assert!(!(a < b) && b < a);\n+    b.set(0, true);\n+    assert!(a < b);\n+}\n+\n+#[test]\n+fn test_ord() {\n+    let mut a = BitVec::from_elem(5, false);\n+    let mut b = BitVec::from_elem(5, false);\n+\n+    assert!(a <= b && a >= b);\n+    a.set(1, true);\n+    assert!(a > b && a >= b);\n+    assert!(b < a && b <= a);\n+    b.set(1, true);\n+    b.set(2, true);\n+    assert!(b > a && b >= a);\n+    assert!(a < b && a <= b);\n+}\n+\n+\n+#[test]\n+fn test_small_bit_vec_tests() {\n+    let v = BitVec::from_bytes(&[0]);\n+    assert!(!v.all());\n+    assert!(!v.any());\n+    assert!(v.none());\n+\n+    let v = BitVec::from_bytes(&[0b00010100]);\n+    assert!(!v.all());\n+    assert!(v.any());\n+    assert!(!v.none());\n+\n+    let v = BitVec::from_bytes(&[0xFF]);\n+    assert!(v.all());\n+    assert!(v.any());\n+    assert!(!v.none());\n+}\n+\n+#[test]\n+fn test_big_bit_vec_tests() {\n+    let v = BitVec::from_bytes(&[ // 88 bits\n+        0, 0, 0, 0,\n+        0, 0, 0, 0,\n+        0, 0, 0]);\n+    assert!(!v.all());\n+    assert!(!v.any());\n+    assert!(v.none());\n+\n+    let v = BitVec::from_bytes(&[ // 88 bits\n+        0, 0, 0b00010100, 0,\n+        0, 0, 0, 0b00110100,\n+        0, 0, 0]);\n+    assert!(!v.all());\n+    assert!(v.any());\n+    assert!(!v.none());\n+\n+    let v = BitVec::from_bytes(&[ // 88 bits\n+        0xFF, 0xFF, 0xFF, 0xFF,\n+        0xFF, 0xFF, 0xFF, 0xFF,\n+        0xFF, 0xFF, 0xFF]);\n+    assert!(v.all());\n+    assert!(v.any());\n+    assert!(!v.none());\n+}\n+\n+#[test]\n+fn test_bit_vec_push_pop() {\n+    let mut s = BitVec::from_elem(5 * u32::BITS as usize - 2, false);\n+    assert_eq!(s.len(), 5 * u32::BITS as usize - 2);\n+    assert_eq!(s[5 * u32::BITS as usize - 3], false);\n+    s.push(true);\n+    s.push(true);\n+    assert_eq!(s[5 * u32::BITS as usize - 2], true);\n+    assert_eq!(s[5 * u32::BITS as usize - 1], true);\n+    // Here the internal vector will need to be extended\n+    s.push(false);\n+    assert_eq!(s[5 * u32::BITS as usize], false);\n+    s.push(false);\n+    assert_eq!(s[5 * u32::BITS as usize + 1], false);\n+    assert_eq!(s.len(), 5 * u32::BITS as usize + 2);\n+    // Pop it all off\n+    assert_eq!(s.pop(), Some(false));\n+    assert_eq!(s.pop(), Some(false));\n+    assert_eq!(s.pop(), Some(true));\n+    assert_eq!(s.pop(), Some(true));\n+    assert_eq!(s.len(), 5 * u32::BITS as usize - 2);\n+}\n+\n+#[test]\n+fn test_bit_vec_truncate() {\n+    let mut s = BitVec::from_elem(5 * u32::BITS as usize, true);\n+\n+    assert_eq!(s, BitVec::from_elem(5 * u32::BITS as usize, true));\n+    assert_eq!(s.len(), 5 * u32::BITS as usize);\n+    s.truncate(4 * u32::BITS as usize);\n+    assert_eq!(s, BitVec::from_elem(4 * u32::BITS as usize, true));\n+    assert_eq!(s.len(), 4 * u32::BITS as usize);\n+    // Truncating to a size > s.len() should be a noop\n+    s.truncate(5 * u32::BITS as usize);\n+    assert_eq!(s, BitVec::from_elem(4 * u32::BITS as usize, true));\n+    assert_eq!(s.len(), 4 * u32::BITS as usize);\n+    s.truncate(3 * u32::BITS as usize - 10);\n+    assert_eq!(s, BitVec::from_elem(3 * u32::BITS as usize - 10, true));\n+    assert_eq!(s.len(), 3 * u32::BITS as usize - 10);\n+    s.truncate(0);\n+    assert_eq!(s, BitVec::from_elem(0, true));\n+    assert_eq!(s.len(), 0);\n+}\n+\n+#[test]\n+fn test_bit_vec_reserve() {\n+    let mut s = BitVec::from_elem(5 * u32::BITS as usize, true);\n+    // Check capacity\n+    assert!(s.capacity() >= 5 * u32::BITS as usize);\n+    s.reserve(2 * u32::BITS as usize);\n+    assert!(s.capacity() >= 7 * u32::BITS as usize);\n+    s.reserve(7 * u32::BITS as usize);\n+    assert!(s.capacity() >= 12 * u32::BITS as usize);\n+    s.reserve_exact(7 * u32::BITS as usize);\n+    assert!(s.capacity() >= 12 * u32::BITS as usize);\n+    s.reserve(7 * u32::BITS as usize + 1);\n+    assert!(s.capacity() >= 12 * u32::BITS as usize + 1);\n+    // Check that length hasn't changed\n+    assert_eq!(s.len(), 5 * u32::BITS as usize);\n+    s.push(true);\n+    s.push(false);\n+    s.push(true);\n+    assert_eq!(s[5 * u32::BITS as usize - 1], true);\n+    assert_eq!(s[5 * u32::BITS as usize - 0], true);\n+    assert_eq!(s[5 * u32::BITS as usize + 1], false);\n+    assert_eq!(s[5 * u32::BITS as usize + 2], true);\n+}\n+\n+#[test]\n+fn test_bit_vec_grow() {\n+    let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n+    bit_vec.grow(32, true);\n+    assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+                                 0xFF, 0xFF, 0xFF, 0xFF]));\n+    bit_vec.grow(64, false);\n+    assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+                                 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n+    bit_vec.grow(16, true);\n+    assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+                                 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n+}\n+\n+#[test]\n+fn test_bit_vec_extend() {\n+    let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+    let ext = BitVec::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n+    bit_vec.extend(ext.iter());\n+    assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n+                                 0b01001001, 0b10010010, 0b10111101]));\n+}\n+\n+mod bench {\n+    use std::collections::BitVec;\n+    use std::u32;\n+    use std::rand::{Rng, self};\n+\n+    use test::{Bencher, black_box};\n+\n+    const BENCH_BITS : usize = 1 << 14;\n+\n+    fn rng() -> rand::IsaacRng {\n+        let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n+        rand::SeedableRng::from_seed(seed)\n+    }\n+\n+    #[bench]\n+    fn bench_usize_small(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bit_vec = 0 as usize;\n+        b.iter(|| {\n+            for _ in 0..100 {\n+                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS as usize);\n+            }\n+            black_box(&bit_vec);\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bit_set_big_fixed(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            for _ in 0..100 {\n+                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, true);\n+            }\n+            black_box(&bit_vec);\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bit_set_big_variable(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            for _ in 0..100 {\n+                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n+            }\n+            black_box(&bit_vec);\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bit_set_small(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bit_vec = BitVec::from_elem(u32::BITS as usize, false);\n+        b.iter(|| {\n+            for _ in 0..100 {\n+                bit_vec.set((r.next_u32() as usize) % u32::BITS as usize, true);\n+            }\n+            black_box(&bit_vec);\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bit_vec_big_union(b: &mut Bencher) {\n+        let mut b1 = BitVec::from_elem(BENCH_BITS, false);\n+        let b2 = BitVec::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            b1.union(&b2)\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_bit_vec_small_iter(b: &mut Bencher) {\n+        let bit_vec = BitVec::from_elem(u32::BITS as usize, false);\n+        b.iter(|| {\n+            let mut sum = 0;\n+            for _ in 0..10 {\n+                for pres in &bit_vec {\n+                    sum += pres as usize;\n+                }\n+            }\n+            sum\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_bit_vec_big_iter(b: &mut Bencher) {\n+        let bit_vec = BitVec::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            let mut sum = 0;\n+            for pres in &bit_vec {\n+                sum += pres as usize;\n+            }\n+            sum\n+        })\n+    }\n+}"}, {"sha": "10d69c9f5ece6549e28b9d9e98d25b77a0e0f481", "filename": "src/libcollectionstest/btree/map.rs", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,299 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::BTreeMap;\n+use std::collections::Bound::{Excluded, Included, Unbounded, self};\n+use std::collections::btree_map::Entry::{Occupied, Vacant};\n+use std::iter::range_inclusive;\n+\n+#[test]\n+fn test_basic_large() {\n+    let mut map = BTreeMap::new();\n+    let size = 10000;\n+    assert_eq!(map.len(), 0);\n+\n+    for i in 0..size {\n+        assert_eq!(map.insert(i, 10*i), None);\n+        assert_eq!(map.len(), i + 1);\n+    }\n+\n+    for i in 0..size {\n+        assert_eq!(map.get(&i).unwrap(), &(i*10));\n+    }\n+\n+    for i in size..size*2 {\n+        assert_eq!(map.get(&i), None);\n+    }\n+\n+    for i in 0..size {\n+        assert_eq!(map.insert(i, 100*i), Some(10*i));\n+        assert_eq!(map.len(), size);\n+    }\n+\n+    for i in 0..size {\n+        assert_eq!(map.get(&i).unwrap(), &(i*100));\n+    }\n+\n+    for i in 0..size/2 {\n+        assert_eq!(map.remove(&(i*2)), Some(i*200));\n+        assert_eq!(map.len(), size - i - 1);\n+    }\n+\n+    for i in 0..size/2 {\n+        assert_eq!(map.get(&(2*i)), None);\n+        assert_eq!(map.get(&(2*i+1)).unwrap(), &(i*200 + 100));\n+    }\n+\n+    for i in 0..size/2 {\n+        assert_eq!(map.remove(&(2*i)), None);\n+        assert_eq!(map.remove(&(2*i+1)), Some(i*200 + 100));\n+        assert_eq!(map.len(), size/2 - i - 1);\n+    }\n+}\n+\n+#[test]\n+fn test_basic_small() {\n+    let mut map = BTreeMap::new();\n+    assert_eq!(map.remove(&1), None);\n+    assert_eq!(map.get(&1), None);\n+    assert_eq!(map.insert(1, 1), None);\n+    assert_eq!(map.get(&1), Some(&1));\n+    assert_eq!(map.insert(1, 2), Some(1));\n+    assert_eq!(map.get(&1), Some(&2));\n+    assert_eq!(map.insert(2, 4), None);\n+    assert_eq!(map.get(&2), Some(&4));\n+    assert_eq!(map.remove(&1), Some(2));\n+    assert_eq!(map.remove(&2), Some(4));\n+    assert_eq!(map.remove(&1), None);\n+}\n+\n+#[test]\n+fn test_iter() {\n+    let size = 10000;\n+\n+    // Forwards\n+    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+\n+    fn test<T>(size: usize, mut iter: T) where T: Iterator<Item=(usize, usize)> {\n+        for i in 0..size {\n+            assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n+            assert_eq!(iter.next().unwrap(), (i, i));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+    }\n+    test(size, map.iter().map(|(&k, &v)| (k, v)));\n+    test(size, map.iter_mut().map(|(&k, &mut v)| (k, v)));\n+    test(size, map.into_iter());\n+}\n+\n+#[test]\n+fn test_iter_rev() {\n+    let size = 10000;\n+\n+    // Forwards\n+    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+\n+    fn test<T>(size: usize, mut iter: T) where T: Iterator<Item=(usize, usize)> {\n+        for i in 0..size {\n+            assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n+            assert_eq!(iter.next().unwrap(), (size - i - 1, size - i - 1));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+    }\n+    test(size, map.iter().rev().map(|(&k, &v)| (k, v)));\n+    test(size, map.iter_mut().rev().map(|(&k, &mut v)| (k, v)));\n+    test(size, map.into_iter().rev());\n+}\n+\n+#[test]\n+fn test_iter_mixed() {\n+    let size = 10000;\n+\n+    // Forwards\n+    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+\n+    fn test<T>(size: usize, mut iter: T)\n+            where T: Iterator<Item=(usize, usize)> + DoubleEndedIterator {\n+        for i in 0..size / 4 {\n+            assert_eq!(iter.size_hint(), (size - i * 2, Some(size - i * 2)));\n+            assert_eq!(iter.next().unwrap(), (i, i));\n+            assert_eq!(iter.next_back().unwrap(), (size - i - 1, size - i - 1));\n+        }\n+        for i in size / 4..size * 3 / 4 {\n+            assert_eq!(iter.size_hint(), (size * 3 / 4 - i, Some(size * 3 / 4 - i)));\n+            assert_eq!(iter.next().unwrap(), (i, i));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+    }\n+    test(size, map.iter().map(|(&k, &v)| (k, v)));\n+    test(size, map.iter_mut().map(|(&k, &mut v)| (k, v)));\n+    test(size, map.into_iter());\n+}\n+\n+#[test]\n+fn test_range_small() {\n+    let size = 5;\n+\n+    // Forwards\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+\n+    let mut j = 0;\n+    for ((&k, &v), i) in map.range(Included(&2), Unbounded).zip(2..size) {\n+        assert_eq!(k, i);\n+        assert_eq!(v, i);\n+        j += 1;\n+    }\n+    assert_eq!(j, size - 2);\n+}\n+\n+#[test]\n+fn test_range_1000() {\n+    let size = 1000;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+\n+    fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n+        let mut kvs = map.range(min, max).map(|(&k, &v)| (k, v));\n+        let mut pairs = (0..size).map(|i| (i, i));\n+\n+        for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n+            assert_eq!(kv, pair);\n+        }\n+        assert_eq!(kvs.next(), None);\n+        assert_eq!(pairs.next(), None);\n+    }\n+    test(&map, size, Included(&0), Excluded(&size));\n+    test(&map, size, Unbounded, Excluded(&size));\n+    test(&map, size, Included(&0), Included(&(size - 1)));\n+    test(&map, size, Unbounded, Included(&(size - 1)));\n+    test(&map, size, Included(&0), Unbounded);\n+    test(&map, size, Unbounded, Unbounded);\n+}\n+\n+#[test]\n+fn test_range() {\n+    let size = 200;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+\n+    for i in 0..size {\n+        for j in i..size {\n+            let mut kvs = map.range(Included(&i), Included(&j)).map(|(&k, &v)| (k, v));\n+            let mut pairs = range_inclusive(i, j).map(|i| (i, i));\n+\n+            for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n+                assert_eq!(kv, pair);\n+            }\n+            assert_eq!(kvs.next(), None);\n+            assert_eq!(pairs.next(), None);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_entry(){\n+    let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+    let mut map: BTreeMap<_, _> = xs.iter().cloned().collect();\n+\n+    // Existing key (insert)\n+    match map.entry(1) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(mut view) => {\n+            assert_eq!(view.get(), &10);\n+            assert_eq!(view.insert(100), 10);\n+        }\n+    }\n+    assert_eq!(map.get(&1).unwrap(), &100);\n+    assert_eq!(map.len(), 6);\n+\n+\n+    // Existing key (update)\n+    match map.entry(2) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(mut view) => {\n+            let v = view.get_mut();\n+            *v *= 10;\n+        }\n+    }\n+    assert_eq!(map.get(&2).unwrap(), &200);\n+    assert_eq!(map.len(), 6);\n+\n+    // Existing key (take)\n+    match map.entry(3) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(view) => {\n+            assert_eq!(view.remove(), 30);\n+        }\n+    }\n+    assert_eq!(map.get(&3), None);\n+    assert_eq!(map.len(), 5);\n+\n+\n+    // Inexistent key (insert)\n+    match map.entry(10) {\n+        Occupied(_) => unreachable!(),\n+        Vacant(view) => {\n+            assert_eq!(*view.insert(1000), 1000);\n+        }\n+    }\n+    assert_eq!(map.get(&10).unwrap(), &1000);\n+    assert_eq!(map.len(), 6);\n+}\n+\n+mod bench {\n+    use std::collections::BTreeMap;\n+    use std::rand::{Rng, weak_rng};\n+\n+    use test::{Bencher, black_box};\n+\n+    map_insert_rand_bench!{insert_rand_100,    100,    BTreeMap}\n+    map_insert_rand_bench!{insert_rand_10_000, 10_000, BTreeMap}\n+\n+    map_insert_seq_bench!{insert_seq_100,    100,    BTreeMap}\n+    map_insert_seq_bench!{insert_seq_10_000, 10_000, BTreeMap}\n+\n+    map_find_rand_bench!{find_rand_100,    100,    BTreeMap}\n+    map_find_rand_bench!{find_rand_10_000, 10_000, BTreeMap}\n+\n+    map_find_seq_bench!{find_seq_100,    100,    BTreeMap}\n+    map_find_seq_bench!{find_seq_10_000, 10_000, BTreeMap}\n+\n+    fn bench_iter(b: &mut Bencher, size: i32) {\n+        let mut map = BTreeMap::<i32, i32>::new();\n+        let mut rng = weak_rng();\n+\n+        for _ in 0..size {\n+            map.insert(rng.gen(), rng.gen());\n+        }\n+\n+        b.iter(|| {\n+            for entry in &map {\n+                black_box(entry);\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    pub fn iter_20(b: &mut Bencher) {\n+        bench_iter(b, 20);\n+    }\n+\n+    #[bench]\n+    pub fn iter_1000(b: &mut Bencher) {\n+        bench_iter(b, 1000);\n+    }\n+\n+    #[bench]\n+    pub fn iter_100000(b: &mut Bencher) {\n+        bench_iter(b, 100000);\n+    }\n+}"}, {"sha": "0db48f3ce9edb4bac58c1b4f2596a48f5eca20da", "filename": "src/libcollectionstest/btree/mod.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmod.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod map;\n+mod set;"}, {"sha": "488f0d756d329ef2374a097a83315ec99077298c", "filename": "src/libcollectionstest/btree/set.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fset.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,180 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::BTreeSet;\n+use std::hash::{SipHasher, self};\n+\n+#[test]\n+fn test_clone_eq() {\n+  let mut m = BTreeSet::new();\n+\n+  m.insert(1);\n+  m.insert(2);\n+\n+  assert!(m.clone() == m);\n+}\n+\n+#[test]\n+fn test_hash() {\n+  let mut x = BTreeSet::new();\n+  let mut y = BTreeSet::new();\n+\n+  x.insert(1);\n+  x.insert(2);\n+  x.insert(3);\n+\n+  y.insert(3);\n+  y.insert(2);\n+  y.insert(1);\n+\n+  assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n+}\n+\n+struct Counter<'a, 'b> {\n+    i: &'a mut usize,\n+    expected: &'b [i32],\n+}\n+\n+impl<'a, 'b, 'c> FnMut<(&'c i32,)> for Counter<'a, 'b> {\n+    type Output = bool;\n+\n+    extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c i32,)) -> bool {\n+        assert_eq!(x, self.expected[*self.i]);\n+        *self.i += 1;\n+        true\n+    }\n+}\n+\n+fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F) where\n+    // FIXME Replace Counter with `Box<FnMut(_) -> _>`\n+    F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, Counter) -> bool,\n+{\n+    let mut set_a = BTreeSet::new();\n+    let mut set_b = BTreeSet::new();\n+\n+    for x in a { assert!(set_a.insert(*x)) }\n+    for y in b { assert!(set_b.insert(*y)) }\n+\n+    let mut i = 0;\n+    f(&set_a, &set_b, Counter { i: &mut i, expected: expected });\n+    assert_eq!(i, expected.len());\n+}\n+\n+#[test]\n+fn test_intersection() {\n+    fn check_intersection(a: &[i32], b: &[i32], expected: &[i32]) {\n+        check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n+    }\n+\n+    check_intersection(&[], &[], &[]);\n+    check_intersection(&[1, 2, 3], &[], &[]);\n+    check_intersection(&[], &[1, 2, 3], &[]);\n+    check_intersection(&[2], &[1, 2, 3], &[2]);\n+    check_intersection(&[1, 2, 3], &[2], &[2]);\n+    check_intersection(&[11, 1, 3, 77, 103, 5, -5],\n+                       &[2, 11, 77, -9, -42, 5, 3],\n+                       &[3, 5, 11, 77]);\n+}\n+\n+#[test]\n+fn test_difference() {\n+    fn check_difference(a: &[i32], b: &[i32], expected: &[i32]) {\n+        check(a, b, expected, |x, y, f| x.difference(y).all(f))\n+    }\n+\n+    check_difference(&[], &[], &[]);\n+    check_difference(&[1, 12], &[], &[1, 12]);\n+    check_difference(&[], &[1, 2, 3, 9], &[]);\n+    check_difference(&[1, 3, 5, 9, 11],\n+                     &[3, 9],\n+                     &[1, 5, 11]);\n+    check_difference(&[-5, 11, 22, 33, 40, 42],\n+                     &[-12, -5, 14, 23, 34, 38, 39, 50],\n+                     &[11, 22, 33, 40, 42]);\n+}\n+\n+#[test]\n+fn test_symmetric_difference() {\n+    fn check_symmetric_difference(a: &[i32], b: &[i32], expected: &[i32]) {\n+        check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n+    }\n+\n+    check_symmetric_difference(&[], &[], &[]);\n+    check_symmetric_difference(&[1, 2, 3], &[2], &[1, 3]);\n+    check_symmetric_difference(&[2], &[1, 2, 3], &[1, 3]);\n+    check_symmetric_difference(&[1, 3, 5, 9, 11],\n+                               &[-2, 3, 9, 14, 22],\n+                               &[-2, 1, 5, 11, 14, 22]);\n+}\n+\n+#[test]\n+fn test_union() {\n+    fn check_union(a: &[i32], b: &[i32], expected: &[i32]) {\n+        check(a, b, expected, |x, y, f| x.union(y).all(f))\n+    }\n+\n+    check_union(&[], &[], &[]);\n+    check_union(&[1, 2, 3], &[2], &[1, 2, 3]);\n+    check_union(&[2], &[1, 2, 3], &[1, 2, 3]);\n+    check_union(&[1, 3, 5, 9, 11, 16, 19, 24],\n+                &[-2, 1, 5, 9, 13, 19],\n+                &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n+}\n+\n+#[test]\n+fn test_zip() {\n+    let mut x = BTreeSet::new();\n+    x.insert(5);\n+    x.insert(12);\n+    x.insert(11);\n+\n+    let mut y = BTreeSet::new();\n+    y.insert(\"foo\");\n+    y.insert(\"bar\");\n+\n+    let x = x;\n+    let y = y;\n+    let mut z = x.iter().zip(y.iter());\n+\n+    // FIXME: #5801: this needs a type hint to compile...\n+    let result: Option<(&usize, & &'static str)> = z.next();\n+    assert_eq!(result.unwrap(), (&5, &(\"bar\")));\n+\n+    let result: Option<(&usize, & &'static str)> = z.next();\n+    assert_eq!(result.unwrap(), (&11, &(\"foo\")));\n+\n+    let result: Option<(&usize, & &'static str)> = z.next();\n+    assert!(result.is_none());\n+}\n+\n+#[test]\n+fn test_from_iter() {\n+    let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n+\n+    let set: BTreeSet<_> = xs.iter().cloned().collect();\n+\n+    for x in &xs {\n+        assert!(set.contains(x));\n+    }\n+}\n+\n+#[test]\n+fn test_show() {\n+    let mut set = BTreeSet::new();\n+    let empty = BTreeSet::<i32>::new();\n+\n+    set.insert(1);\n+    set.insert(2);\n+\n+    let set_str = format!(\"{:?}\", set);\n+\n+    assert_eq!(set_str, \"{1, 2}\");\n+    assert_eq!(format!(\"{:?}\", empty), \"{}\");\n+}"}, {"sha": "a740c531c89d2e4915f92a3baff83b640bc1b270", "filename": "src/libcollectionstest/enum_set.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fenum_set.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,240 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::EnumSet;\n+\n+#[derive(Copy, PartialEq, Debug)]\n+#[repr(usize)]\n+enum Foo {\n+    A, B, C\n+}\n+\n+impl CLike for Foo {\n+    fn to_usize(&self) -> usize {\n+        *self as usize\n+    }\n+\n+    fn from_usize(v: usize) -> Foo {\n+        unsafe { mem::transmute(v) }\n+    }\n+}\n+\n+#[test]\n+fn test_new() {\n+    let e: EnumSet<Foo> = EnumSet::new();\n+    assert!(e.is_empty());\n+}\n+\n+#[test]\n+fn test_show() {\n+    let mut e = EnumSet::new();\n+    assert!(format!(\"{:?}\", e) == \"{}\");\n+    e.insert(A);\n+    assert!(format!(\"{:?}\", e) == \"{A}\");\n+    e.insert(C);\n+    assert!(format!(\"{:?}\", e) == \"{A, C}\");\n+}\n+\n+#[test]\n+fn test_len() {\n+    let mut e = EnumSet::new();\n+    assert_eq!(e.len(), 0);\n+    e.insert(A);\n+    e.insert(B);\n+    e.insert(C);\n+    assert_eq!(e.len(), 3);\n+    e.remove(&A);\n+    assert_eq!(e.len(), 2);\n+    e.clear();\n+    assert_eq!(e.len(), 0);\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// intersect\n+\n+#[test]\n+fn test_two_empties_do_not_intersect() {\n+    let e1: EnumSet<Foo> = EnumSet::new();\n+    let e2: EnumSet<Foo> = EnumSet::new();\n+    assert!(e1.is_disjoint(&e2));\n+}\n+\n+#[test]\n+fn test_empty_does_not_intersect_with_full() {\n+    let e1: EnumSet<Foo> = EnumSet::new();\n+\n+    let mut e2: EnumSet<Foo> = EnumSet::new();\n+    e2.insert(A);\n+    e2.insert(B);\n+    e2.insert(C);\n+\n+    assert!(e1.is_disjoint(&e2));\n+}\n+\n+#[test]\n+fn test_disjoint_intersects() {\n+    let mut e1: EnumSet<Foo> = EnumSet::new();\n+    e1.insert(A);\n+\n+    let mut e2: EnumSet<Foo> = EnumSet::new();\n+    e2.insert(B);\n+\n+    assert!(e1.is_disjoint(&e2));\n+}\n+\n+#[test]\n+fn test_overlapping_intersects() {\n+    let mut e1: EnumSet<Foo> = EnumSet::new();\n+    e1.insert(A);\n+\n+    let mut e2: EnumSet<Foo> = EnumSet::new();\n+    e2.insert(A);\n+    e2.insert(B);\n+\n+    assert!(!e1.is_disjoint(&e2));\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// contains and contains_elem\n+\n+#[test]\n+fn test_superset() {\n+    let mut e1: EnumSet<Foo> = EnumSet::new();\n+    e1.insert(A);\n+\n+    let mut e2: EnumSet<Foo> = EnumSet::new();\n+    e2.insert(A);\n+    e2.insert(B);\n+\n+    let mut e3: EnumSet<Foo> = EnumSet::new();\n+    e3.insert(C);\n+\n+    assert!(e1.is_subset(&e2));\n+    assert!(e2.is_superset(&e1));\n+    assert!(!e3.is_superset(&e2));\n+    assert!(!e2.is_superset(&e3))\n+}\n+\n+#[test]\n+fn test_contains() {\n+    let mut e1: EnumSet<Foo> = EnumSet::new();\n+    e1.insert(A);\n+    assert!(e1.contains(&A));\n+    assert!(!e1.contains(&B));\n+    assert!(!e1.contains(&C));\n+\n+    e1.insert(A);\n+    e1.insert(B);\n+    assert!(e1.contains(&A));\n+    assert!(e1.contains(&B));\n+    assert!(!e1.contains(&C));\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// iter\n+\n+#[test]\n+fn test_iterator() {\n+    let mut e1: EnumSet<Foo> = EnumSet::new();\n+\n+    let elems: ::vec::Vec<Foo> = e1.iter().collect();\n+    assert!(elems.is_empty());\n+\n+    e1.insert(A);\n+    let elems: ::vec::Vec<_> = e1.iter().collect();\n+    assert_eq!([A], elems);\n+\n+    e1.insert(C);\n+    let elems: ::vec::Vec<_> = e1.iter().collect();\n+    assert_eq!([A,C], elems);\n+\n+    e1.insert(C);\n+    let elems: ::vec::Vec<_> = e1.iter().collect();\n+    assert_eq!([A,C], elems);\n+\n+    e1.insert(B);\n+    let elems: ::vec::Vec<_> = e1.iter().collect();\n+    assert_eq!([A,B,C], elems);\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// operators\n+\n+#[test]\n+fn test_operators() {\n+    let mut e1: EnumSet<Foo> = EnumSet::new();\n+    e1.insert(A);\n+    e1.insert(C);\n+\n+    let mut e2: EnumSet<Foo> = EnumSet::new();\n+    e2.insert(B);\n+    e2.insert(C);\n+\n+    let e_union = e1 | e2;\n+    let elems: ::vec::Vec<_> = e_union.iter().collect();\n+    assert_eq!([A,B,C], elems);\n+\n+    let e_intersection = e1 & e2;\n+    let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n+    assert_eq!([C], elems);\n+\n+    // Another way to express intersection\n+    let e_intersection = e1 - (e1 - e2);\n+    let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n+    assert_eq!([C], elems);\n+\n+    let e_subtract = e1 - e2;\n+    let elems: ::vec::Vec<_> = e_subtract.iter().collect();\n+    assert_eq!([A], elems);\n+\n+    // Bitwise XOR of two sets, aka symmetric difference\n+    let e_symmetric_diff = e1 ^ e2;\n+    let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n+    assert_eq!([A,B], elems);\n+\n+    // Another way to express symmetric difference\n+    let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n+    let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n+    assert_eq!([A,B], elems);\n+\n+    // Yet another way to express symmetric difference\n+    let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n+    let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n+    assert_eq!([A,B], elems);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_overflow() {\n+    #[allow(dead_code)]\n+    #[derive(Copy)]\n+    #[repr(usize)]\n+    enum Bar {\n+        V00, V01, V02, V03, V04, V05, V06, V07, V08, V09,\n+        V10, V11, V12, V13, V14, V15, V16, V17, V18, V19,\n+        V20, V21, V22, V23, V24, V25, V26, V27, V28, V29,\n+        V30, V31, V32, V33, V34, V35, V36, V37, V38, V39,\n+        V40, V41, V42, V43, V44, V45, V46, V47, V48, V49,\n+        V50, V51, V52, V53, V54, V55, V56, V57, V58, V59,\n+        V60, V61, V62, V63, V64, V65, V66, V67, V68, V69,\n+    }\n+\n+    impl CLike for Bar {\n+        fn to_usize(&self) -> usize {\n+            *self as usize\n+        }\n+\n+        fn from_usize(v: usize) -> Bar {\n+            unsafe { mem::transmute(v) }\n+        }\n+    }\n+    let mut set = EnumSet::new();\n+    set.insert(Bar::V64);\n+}"}, {"sha": "9a9aa71b58bfaa7ac82f845a7fae3898bb235a95", "filename": "src/libcollectionstest/fmt.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Ffmt.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+#[test]\n+fn test_format() {\n+    let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n+    assert_eq!(s.as_slice(), \"Hello, world!\");\n+}"}, {"sha": "4cf1d01a4ee2a3922c7cd4053eb02a021dac8bcd", "filename": "src/libcollectionstest/lib.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(deprecated)]\n+#![feature(box_syntax)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(hash)]\n+#![feature(rand)]\n+#![feature(rustc_private)]\n+#![feature(str_words)]\n+#![feature(test)]\n+#![feature(unboxed_closures)]\n+#![feature(unicode)]\n+#![feature(unsafe_destructor)]\n+\n+#[macro_use] extern crate log;\n+\n+extern crate collections;\n+extern crate test;\n+extern crate unicode;\n+\n+#[cfg(test)] #[macro_use] mod bench;\n+\n+mod binary_heap;\n+mod bit;\n+mod btree;\n+// FIXME(japaric) privacy\n+//mod enum_set;\n+mod fmt;\n+mod linked_list;\n+mod slice;\n+mod str;\n+mod string;\n+mod vec_deque;\n+mod vec_map;\n+mod vec;"}, {"sha": "95d49885b3b2da0b368daaefd8aee271fbf73a54", "filename": "src/libcollectionstest/linked_list.rs", "status": "added", "additions": 589, "deletions": 0, "changes": 589, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flinked_list.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,589 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::LinkedList;\n+use std::hash::{SipHasher, self};\n+\n+use test;\n+\n+// FIXME(japaric) privacy\n+/*\n+pub fn check_links<T>(list: &LinkedList<T>) {\n+    let mut len = 0;\n+    let mut last_ptr: Option<&Node<T>> = None;\n+    let mut node_ptr: &Node<T>;\n+    match list.list_head {\n+        None => { assert_eq!(0, list.length); return }\n+        Some(ref node) => node_ptr = &**node,\n+    }\n+    loop {\n+        match (last_ptr, node_ptr.prev.resolve_immut()) {\n+            (None   , None      ) => {}\n+            (None   , _         ) => panic!(\"prev link for list_head\"),\n+            (Some(p), Some(pptr)) => {\n+                assert_eq!(p as *const Node<T>, pptr as *const Node<T>);\n+            }\n+            _ => panic!(\"prev link is none, not good\"),\n+        }\n+        match node_ptr.next {\n+            Some(ref next) => {\n+                last_ptr = Some(node_ptr);\n+                node_ptr = &**next;\n+                len += 1;\n+            }\n+            None => {\n+                len += 1;\n+                break;\n+            }\n+        }\n+    }\n+    assert_eq!(len, list.length);\n+}\n+*/\n+\n+#[test]\n+fn test_basic() {\n+    let mut m = LinkedList::<Box<_>>::new();\n+    assert_eq!(m.pop_front(), None);\n+    assert_eq!(m.pop_back(), None);\n+    assert_eq!(m.pop_front(), None);\n+    m.push_front(box 1);\n+    assert_eq!(m.pop_front(), Some(box 1));\n+    m.push_back(box 2);\n+    m.push_back(box 3);\n+    assert_eq!(m.len(), 2);\n+    assert_eq!(m.pop_front(), Some(box 2));\n+    assert_eq!(m.pop_front(), Some(box 3));\n+    assert_eq!(m.len(), 0);\n+    assert_eq!(m.pop_front(), None);\n+    m.push_back(box 1);\n+    m.push_back(box 3);\n+    m.push_back(box 5);\n+    m.push_back(box 7);\n+    assert_eq!(m.pop_front(), Some(box 1));\n+\n+    let mut n = LinkedList::new();\n+    n.push_front(2);\n+    n.push_front(3);\n+    {\n+        assert_eq!(n.front().unwrap(), &3);\n+        let x = n.front_mut().unwrap();\n+        assert_eq!(*x, 3);\n+        *x = 0;\n+    }\n+    {\n+        assert_eq!(n.back().unwrap(), &2);\n+        let y = n.back_mut().unwrap();\n+        assert_eq!(*y, 2);\n+        *y = 1;\n+    }\n+    assert_eq!(n.pop_front(), Some(0));\n+    assert_eq!(n.pop_front(), Some(1));\n+}\n+\n+#[cfg(test)]\n+fn generate_test() -> LinkedList<i32> {\n+    list_from(&[0,1,2,3,4,5,6])\n+}\n+\n+#[cfg(test)]\n+fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n+    v.iter().cloned().collect()\n+}\n+\n+// FIXME(japaric) privacy\n+/*\n+#[test]\n+fn test_append() {\n+    // Empty to empty\n+    {\n+        let mut m = LinkedList::<i32>::new();\n+        let mut n = LinkedList::new();\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(n.len(), 0);\n+    }\n+    // Non-empty to empty\n+    {\n+        let mut m = LinkedList::new();\n+        let mut n = LinkedList::new();\n+        n.push_back(2);\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        assert_eq!(n.len(), 0);\n+        check_links(&m);\n+    }\n+    // Empty to non-empty\n+    {\n+        let mut m = LinkedList::new();\n+        let mut n = LinkedList::new();\n+        m.push_back(2);\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        check_links(&m);\n+    }\n+\n+    // Non-empty to non-empty\n+    let v = vec![1,2,3,4,5];\n+    let u = vec![9,8,1,2,3,4,5];\n+    let mut m = list_from(&v);\n+    let mut n = list_from(&u);\n+    m.append(&mut n);\n+    check_links(&m);\n+    let mut sum = v;\n+    sum.push_all(&u);\n+    assert_eq!(sum.len(), m.len());\n+    for elt in sum {\n+        assert_eq!(m.pop_front(), Some(elt))\n+    }\n+    assert_eq!(n.len(), 0);\n+    // let's make sure it's working properly, since we\n+    // did some direct changes to private members\n+    n.push_back(3);\n+    assert_eq!(n.len(), 1);\n+    assert_eq!(n.pop_front(), Some(3));\n+    check_links(&n);\n+}\n+*/\n+\n+#[test]\n+fn test_split_off() {\n+    // singleton\n+    {\n+        let mut m = LinkedList::new();\n+        m.push_back(1);\n+\n+        let p = m.split_off(0);\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(p.len(), 1);\n+        assert_eq!(p.back(), Some(&1));\n+        assert_eq!(p.front(), Some(&1));\n+    }\n+\n+    // not singleton, forwards\n+    {\n+        let u = vec![1,2,3,4,5];\n+        let mut m = list_from(&u);\n+        let mut n = m.split_off(2);\n+        assert_eq!(m.len(), 2);\n+        assert_eq!(n.len(), 3);\n+        for elt in 1..3 {\n+            assert_eq!(m.pop_front(), Some(elt));\n+        }\n+        for elt in 3..6 {\n+            assert_eq!(n.pop_front(), Some(elt));\n+        }\n+    }\n+    // not singleton, backwards\n+    {\n+        let u = vec![1,2,3,4,5];\n+        let mut m = list_from(&u);\n+        let mut n = m.split_off(4);\n+        assert_eq!(m.len(), 4);\n+        assert_eq!(n.len(), 1);\n+        for elt in 1..5 {\n+            assert_eq!(m.pop_front(), Some(elt));\n+        }\n+        for elt in 5..6 {\n+            assert_eq!(n.pop_front(), Some(elt));\n+        }\n+    }\n+\n+    // no-op on the last index\n+    {\n+        let mut m = LinkedList::new();\n+        m.push_back(1);\n+\n+        let p = m.split_off(1);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(p.len(), 0);\n+        assert_eq!(m.back(), Some(&1));\n+        assert_eq!(m.front(), Some(&1));\n+    }\n+\n+}\n+\n+#[test]\n+fn test_iterator() {\n+    let m = generate_test();\n+    for (i, elt) in m.iter().enumerate() {\n+        assert_eq!(i as i32, *elt);\n+    }\n+    let mut n = LinkedList::new();\n+    assert_eq!(n.iter().next(), None);\n+    n.push_front(4);\n+    let mut it = n.iter();\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next().unwrap(), &4);\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_iterator_clone() {\n+    let mut n = LinkedList::new();\n+    n.push_back(2);\n+    n.push_back(3);\n+    n.push_back(4);\n+    let mut it = n.iter();\n+    it.next();\n+    let mut jt = it.clone();\n+    assert_eq!(it.next(), jt.next());\n+    assert_eq!(it.next_back(), jt.next_back());\n+    assert_eq!(it.next(), jt.next());\n+}\n+\n+#[test]\n+fn test_iterator_double_end() {\n+    let mut n = LinkedList::new();\n+    assert_eq!(n.iter().next(), None);\n+    n.push_front(4);\n+    n.push_front(5);\n+    n.push_front(6);\n+    let mut it = n.iter();\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+    assert_eq!(it.next().unwrap(), &6);\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+    assert_eq!(it.next_back().unwrap(), &4);\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next_back().unwrap(), &5);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_rev_iter() {\n+    let m = generate_test();\n+    for (i, elt) in m.iter().rev().enumerate() {\n+        assert_eq!((6 - i) as i32, *elt);\n+    }\n+    let mut n = LinkedList::new();\n+    assert_eq!(n.iter().rev().next(), None);\n+    n.push_front(4);\n+    let mut it = n.iter().rev();\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next().unwrap(), &4);\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_mut_iter() {\n+    let mut m = generate_test();\n+    let mut len = m.len();\n+    for (i, elt) in m.iter_mut().enumerate() {\n+        assert_eq!(i as i32, *elt);\n+        len -= 1;\n+    }\n+    assert_eq!(len, 0);\n+    let mut n = LinkedList::new();\n+    assert!(n.iter_mut().next().is_none());\n+    n.push_front(4);\n+    n.push_back(5);\n+    let mut it = n.iter_mut();\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+    assert!(it.next().is_some());\n+    assert!(it.next().is_some());\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_iterator_mut_double_end() {\n+    let mut n = LinkedList::new();\n+    assert!(n.iter_mut().next_back().is_none());\n+    n.push_front(4);\n+    n.push_front(5);\n+    n.push_front(6);\n+    let mut it = n.iter_mut();\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+    assert_eq!(*it.next().unwrap(), 6);\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+    assert_eq!(*it.next_back().unwrap(), 4);\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(*it.next_back().unwrap(), 5);\n+    assert!(it.next_back().is_none());\n+    assert!(it.next().is_none());\n+}\n+\n+// FIXME(japaric) privacy\n+/*\n+#[test]\n+fn test_insert_prev() {\n+    let mut m = list_from(&[0,2,4,6,8]);\n+    let len = m.len();\n+    {\n+        let mut it = m.iter_mut();\n+        it.insert_next(-2);\n+        loop {\n+            match it.next() {\n+                None => break,\n+                Some(elt) => {\n+                    it.insert_next(*elt + 1);\n+                    match it.peek_next() {\n+                        Some(x) => assert_eq!(*x, *elt + 2),\n+                        None => assert_eq!(8, *elt),\n+                    }\n+                }\n+            }\n+        }\n+        it.insert_next(0);\n+        it.insert_next(1);\n+    }\n+    check_links(&m);\n+    assert_eq!(m.len(), 3 + len * 2);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n+}\n+*/\n+\n+#[test]\n+fn test_mut_rev_iter() {\n+    let mut m = generate_test();\n+    for (i, elt) in m.iter_mut().rev().enumerate() {\n+        assert_eq!((6 - i) as i32, *elt);\n+    }\n+    let mut n = LinkedList::new();\n+    assert!(n.iter_mut().rev().next().is_none());\n+    n.push_front(4);\n+    let mut it = n.iter_mut().rev();\n+    assert!(it.next().is_some());\n+    assert!(it.next().is_none());\n+}\n+\n+// FIXME(japaric) privacy\n+/*\n+#[test]\n+fn test_send() {\n+    let n = list_from(&[1,2,3]);\n+    thread::spawn(move || {\n+        check_links(&n);\n+        let a: &[_] = &[&1,&2,&3];\n+        assert_eq!(a, n.iter().collect::<Vec<_>>());\n+    }).join().ok().unwrap();\n+}\n+*/\n+\n+#[test]\n+fn test_eq() {\n+    let mut n = list_from(&[]);\n+    let mut m = list_from(&[]);\n+    assert!(n == m);\n+    n.push_front(1);\n+    assert!(n != m);\n+    m.push_back(1);\n+    assert!(n == m);\n+\n+    let n = list_from(&[2,3,4]);\n+    let m = list_from(&[1,2,3]);\n+    assert!(n != m);\n+}\n+\n+#[test]\n+fn test_hash() {\n+  let mut x = LinkedList::new();\n+  let mut y = LinkedList::new();\n+\n+  assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n+\n+  x.push_back(1);\n+  x.push_back(2);\n+  x.push_back(3);\n+\n+  y.push_front(3);\n+  y.push_front(2);\n+  y.push_front(1);\n+\n+  assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n+}\n+\n+#[test]\n+fn test_ord() {\n+    let n = list_from(&[]);\n+    let m = list_from(&[1,2,3]);\n+    assert!(n < m);\n+    assert!(m > n);\n+    assert!(n <= n);\n+    assert!(n >= n);\n+}\n+\n+#[test]\n+fn test_ord_nan() {\n+    let nan = 0.0f64/0.0;\n+    let n = list_from(&[nan]);\n+    let m = list_from(&[nan]);\n+    assert!(!(n < m));\n+    assert!(!(n > m));\n+    assert!(!(n <= m));\n+    assert!(!(n >= m));\n+\n+    let n = list_from(&[nan]);\n+    let one = list_from(&[1.0f64]);\n+    assert!(!(n < one));\n+    assert!(!(n > one));\n+    assert!(!(n <= one));\n+    assert!(!(n >= one));\n+\n+    let u = list_from(&[1.0f64,2.0,nan]);\n+    let v = list_from(&[1.0f64,2.0,3.0]);\n+    assert!(!(u < v));\n+    assert!(!(u > v));\n+    assert!(!(u <= v));\n+    assert!(!(u >= v));\n+\n+    let s = list_from(&[1.0f64,2.0,4.0,2.0]);\n+    let t = list_from(&[1.0f64,2.0,3.0,2.0]);\n+    assert!(!(s < t));\n+    assert!(s > one);\n+    assert!(!(s <= one));\n+    assert!(s >= one);\n+}\n+\n+// FIXME(japaric) privacy\n+/*\n+#[test]\n+fn test_fuzz() {\n+    for _ in 0..25 {\n+        fuzz_test(3);\n+        fuzz_test(16);\n+        fuzz_test(189);\n+    }\n+}\n+*/\n+\n+#[test]\n+fn test_show() {\n+    let list: LinkedList<_> = (0..10).collect();\n+    assert_eq!(format!(\"{:?}\", list), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+\n+    let list: LinkedList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n+    assert_eq!(format!(\"{:?}\", list), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+}\n+\n+// FIXME(japaric) privacy\n+/*\n+#[cfg(test)]\n+fn fuzz_test(sz: i32) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    let mut v = vec![];\n+    for i in 0..sz {\n+        check_links(&m);\n+        let r: u8 = rand::random();\n+        match r % 6 {\n+            0 => {\n+                m.pop_back();\n+                v.pop();\n+            }\n+            1 => {\n+                if !v.is_empty() {\n+                    m.pop_front();\n+                    v.remove(0);\n+                }\n+            }\n+            2 | 4 =>  {\n+                m.push_front(-i);\n+                v.insert(0, -i);\n+            }\n+            3 | 5 | _ => {\n+                m.push_back(i);\n+                v.push(i);\n+            }\n+        }\n+    }\n+\n+    check_links(&m);\n+\n+    let mut i = 0;\n+    for (a, &b) in m.into_iter().zip(v.iter()) {\n+        i += 1;\n+        assert_eq!(a, b);\n+    }\n+    assert_eq!(i, v.len());\n+}\n+*/\n+\n+#[bench]\n+fn bench_collect_into(b: &mut test::Bencher) {\n+    let v = &[0; 64];\n+    b.iter(|| {\n+        let _: LinkedList<_> = v.iter().cloned().collect();\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_front(b: &mut test::Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_front(0);\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_back(b: &mut test::Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_back(0);\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_back_pop_back(b: &mut test::Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_back(0);\n+        m.pop_back();\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_front_pop_front(b: &mut test::Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_front(0);\n+        m.pop_front();\n+    })\n+}\n+\n+#[bench]\n+fn bench_iter(b: &mut test::Bencher) {\n+    let v = &[0; 128];\n+    let m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter().count() == 128);\n+    })\n+}\n+#[bench]\n+fn bench_iter_mut(b: &mut test::Bencher) {\n+    let v = &[0; 128];\n+    let mut m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter_mut().count() == 128);\n+    })\n+}\n+#[bench]\n+fn bench_iter_rev(b: &mut test::Bencher) {\n+    let v = &[0; 128];\n+    let m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter().rev().count() == 128);\n+    })\n+}\n+#[bench]\n+fn bench_iter_mut_rev(b: &mut test::Bencher) {\n+    let v = &[0; 128];\n+    let mut m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter_mut().rev().count() == 128);\n+    })\n+}"}, {"sha": "7d50a1a13f2abc5bf59fd64240b3d6ed3ac08c11", "filename": "src/libcollectionstest/slice.rs", "status": "added", "additions": 1627, "deletions": 0, "changes": 1627, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,1627 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp::Ordering::{Equal, Greater, Less};\n+use std::default::Default;\n+use std::iter::RandomAccessIterator;\n+use std::mem;\n+use std::rand::{Rng, thread_rng};\n+use std::rc::Rc;\n+use std::slice::ElementSwaps;\n+\n+fn square(n: usize) -> usize { n * n }\n+\n+fn is_odd(n: &usize) -> bool { *n % 2 == 1 }\n+\n+#[test]\n+fn test_from_fn() {\n+    // Test on-stack from_fn.\n+    let mut v: Vec<_> = (0..3).map(square).collect();\n+    {\n+        let v = v;\n+        assert_eq!(v.len(), 3);\n+        assert_eq!(v[0], 0);\n+        assert_eq!(v[1], 1);\n+        assert_eq!(v[2], 4);\n+    }\n+\n+    // Test on-heap from_fn.\n+    v = (0..5).map(square).collect();\n+    {\n+        let v = v;\n+        assert_eq!(v.len(), 5);\n+        assert_eq!(v[0], 0);\n+        assert_eq!(v[1], 1);\n+        assert_eq!(v[2], 4);\n+        assert_eq!(v[3], 9);\n+        assert_eq!(v[4], 16);\n+    }\n+}\n+\n+#[test]\n+fn test_from_elem() {\n+    // Test on-stack from_elem.\n+    let mut v = vec![10, 10];\n+    {\n+        let v = v;\n+        assert_eq!(v.len(), 2);\n+        assert_eq!(v[0], 10);\n+        assert_eq!(v[1], 10);\n+    }\n+\n+    // Test on-heap from_elem.\n+    v = vec![20; 6];\n+    {\n+        let v = v.as_slice();\n+        assert_eq!(v[0], 20);\n+        assert_eq!(v[1], 20);\n+        assert_eq!(v[2], 20);\n+        assert_eq!(v[3], 20);\n+        assert_eq!(v[4], 20);\n+        assert_eq!(v[5], 20);\n+    }\n+}\n+\n+#[test]\n+fn test_is_empty() {\n+    let xs: [i32; 0] = [];\n+    assert!(xs.is_empty());\n+    assert!(![0].is_empty());\n+}\n+\n+#[test]\n+fn test_len_divzero() {\n+    type Z = [i8; 0];\n+    let v0 : &[Z] = &[];\n+    let v1 : &[Z] = &[[]];\n+    let v2 : &[Z] = &[[], []];\n+    assert_eq!(mem::size_of::<Z>(), 0);\n+    assert_eq!(v0.len(), 0);\n+    assert_eq!(v1.len(), 1);\n+    assert_eq!(v2.len(), 2);\n+}\n+\n+#[test]\n+fn test_get() {\n+    let mut a = vec![11];\n+    assert_eq!(a.get(1), None);\n+    a = vec![11, 12];\n+    assert_eq!(a.get(1).unwrap(), &12);\n+    a = vec![11, 12, 13];\n+    assert_eq!(a.get(1).unwrap(), &12);\n+}\n+\n+#[test]\n+fn test_first() {\n+    let mut a = vec![];\n+    assert_eq!(a.first(), None);\n+    a = vec![11];\n+    assert_eq!(a.first().unwrap(), &11);\n+    a = vec![11, 12];\n+    assert_eq!(a.first().unwrap(), &11);\n+}\n+\n+#[test]\n+fn test_first_mut() {\n+    let mut a = vec![];\n+    assert_eq!(a.first_mut(), None);\n+    a = vec![11];\n+    assert_eq!(*a.first_mut().unwrap(), 11);\n+    a = vec![11, 12];\n+    assert_eq!(*a.first_mut().unwrap(), 11);\n+}\n+\n+#[test]\n+fn test_tail() {\n+    let mut a = vec![11];\n+    let b: &[i32] = &[];\n+    assert_eq!(a.tail(), b);\n+    a = vec![11, 12];\n+    let b: &[i32] = &[12];\n+    assert_eq!(a.tail(), b);\n+}\n+\n+#[test]\n+fn test_tail_mut() {\n+    let mut a = vec![11];\n+    let b: &mut [i32] = &mut [];\n+    assert!(a.tail_mut() == b);\n+    a = vec![11, 12];\n+    let b: &mut [_] = &mut [12];\n+    assert!(a.tail_mut() == b);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_tail_empty() {\n+    let a = Vec::<i32>::new();\n+    a.tail();\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_tail_mut_empty() {\n+    let mut a = Vec::<i32>::new();\n+    a.tail_mut();\n+}\n+\n+#[test]\n+fn test_init() {\n+    let mut a = vec![11];\n+    let b: &[i32] = &[];\n+    assert_eq!(a.init(), b);\n+    a = vec![11, 12];\n+    let b: &[_] = &[11];\n+    assert_eq!(a.init(), b);\n+}\n+\n+#[test]\n+fn test_init_mut() {\n+    let mut a = vec![11];\n+    let b: &mut [i32] = &mut [];\n+    assert!(a.init_mut() == b);\n+    a = vec![11, 12];\n+    let b: &mut [_] = &mut [11];\n+    assert!(a.init_mut() == b);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_init_empty() {\n+    let a = Vec::<i32>::new();\n+    a.init();\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_init_mut_empty() {\n+    let mut a = Vec::<i32>::new();\n+    a.init_mut();\n+}\n+\n+#[test]\n+fn test_last() {\n+    let mut a = vec![];\n+    assert_eq!(a.last(), None);\n+    a = vec![11];\n+    assert_eq!(a.last().unwrap(), &11);\n+    a = vec![11, 12];\n+    assert_eq!(a.last().unwrap(), &12);\n+}\n+\n+#[test]\n+fn test_last_mut() {\n+    let mut a = vec![];\n+    assert_eq!(a.last_mut(), None);\n+    a = vec![11];\n+    assert_eq!(*a.last_mut().unwrap(), 11);\n+    a = vec![11, 12];\n+    assert_eq!(*a.last_mut().unwrap(), 12);\n+}\n+\n+#[test]\n+fn test_slice() {\n+    // Test fixed length vector.\n+    let vec_fixed = [1, 2, 3, 4];\n+    let v_a = vec_fixed[1..vec_fixed.len()].to_vec();\n+    assert_eq!(v_a.len(), 3);\n+\n+    assert_eq!(v_a[0], 2);\n+    assert_eq!(v_a[1], 3);\n+    assert_eq!(v_a[2], 4);\n+\n+    // Test on stack.\n+    let vec_stack: &[_] = &[1, 2, 3];\n+    let v_b = vec_stack[1..3].to_vec();\n+    assert_eq!(v_b.len(), 2);\n+\n+    assert_eq!(v_b[0], 2);\n+    assert_eq!(v_b[1], 3);\n+\n+    // Test `Box<[T]>`\n+    let vec_unique = vec![1, 2, 3, 4, 5, 6];\n+    let v_d = vec_unique[1..6].to_vec();\n+    assert_eq!(v_d.len(), 5);\n+\n+    assert_eq!(v_d[0], 2);\n+    assert_eq!(v_d[1], 3);\n+    assert_eq!(v_d[2], 4);\n+    assert_eq!(v_d[3], 5);\n+    assert_eq!(v_d[4], 6);\n+}\n+\n+#[test]\n+fn test_slice_from() {\n+    let vec: &[_] = &[1, 2, 3, 4];\n+    assert_eq!(&vec[..], vec);\n+    let b: &[_] = &[3, 4];\n+    assert_eq!(&vec[2..], b);\n+    let b: &[_] = &[];\n+    assert_eq!(&vec[4..], b);\n+}\n+\n+#[test]\n+fn test_slice_to() {\n+    let vec: &[_] = &[1, 2, 3, 4];\n+    assert_eq!(&vec[..4], vec);\n+    let b: &[_] = &[1, 2];\n+    assert_eq!(&vec[..2], b);\n+    let b: &[_] = &[];\n+    assert_eq!(&vec[..0], b);\n+}\n+\n+\n+#[test]\n+fn test_pop() {\n+    let mut v = vec![5];\n+    let e = v.pop();\n+    assert_eq!(v.len(), 0);\n+    assert_eq!(e, Some(5));\n+    let f = v.pop();\n+    assert_eq!(f, None);\n+    let g = v.pop();\n+    assert_eq!(g, None);\n+}\n+\n+#[test]\n+fn test_swap_remove() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let mut e = v.swap_remove(0);\n+    assert_eq!(e, 1);\n+    assert_eq!(v, [5, 2, 3, 4]);\n+    e = v.swap_remove(3);\n+    assert_eq!(e, 4);\n+    assert_eq!(v, [5, 2, 3]);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_swap_remove_fail() {\n+    let mut v = vec![1];\n+    let _ = v.swap_remove(0);\n+    let _ = v.swap_remove(0);\n+}\n+\n+#[test]\n+fn test_swap_remove_noncopyable() {\n+    // Tests that we don't accidentally run destructors twice.\n+    let mut v: Vec<Box<_>> = Vec::new();\n+    v.push(box 0u8);\n+    v.push(box 0u8);\n+    v.push(box 0u8);\n+    let mut _e = v.swap_remove(0);\n+    assert_eq!(v.len(), 2);\n+    _e = v.swap_remove(1);\n+    assert_eq!(v.len(), 1);\n+    _e = v.swap_remove(0);\n+    assert_eq!(v.len(), 0);\n+}\n+\n+#[test]\n+fn test_push() {\n+    // Test on-stack push().\n+    let mut v = vec![];\n+    v.push(1);\n+    assert_eq!(v.len(), 1);\n+    assert_eq!(v[0], 1);\n+\n+    // Test on-heap push().\n+    v.push(2);\n+    assert_eq!(v.len(), 2);\n+    assert_eq!(v[0], 1);\n+    assert_eq!(v[1], 2);\n+}\n+\n+#[test]\n+fn test_truncate() {\n+    let mut v: Vec<Box<_>> = vec![box 6,box 5,box 4];\n+    v.truncate(1);\n+    let v = v;\n+    assert_eq!(v.len(), 1);\n+    assert_eq!(*(v[0]), 6);\n+    // If the unsafe block didn't drop things properly, we blow up here.\n+}\n+\n+#[test]\n+fn test_clear() {\n+    let mut v: Vec<Box<_>> = vec![box 6,box 5,box 4];\n+    v.clear();\n+    assert_eq!(v.len(), 0);\n+    // If the unsafe block didn't drop things properly, we blow up here.\n+}\n+\n+#[test]\n+fn test_dedup() {\n+    fn case(a: Vec<i32>, b: Vec<i32>) {\n+        let mut v = a;\n+        v.dedup();\n+        assert_eq!(v, b);\n+    }\n+    case(vec![], vec![]);\n+    case(vec![1], vec![1]);\n+    case(vec![1,1], vec![1]);\n+    case(vec![1,2,3], vec![1,2,3]);\n+    case(vec![1,1,2,3], vec![1,2,3]);\n+    case(vec![1,2,2,3], vec![1,2,3]);\n+    case(vec![1,2,3,3], vec![1,2,3]);\n+    case(vec![1,1,2,2,2,3,3], vec![1,2,3]);\n+}\n+\n+#[test]\n+fn test_dedup_unique() {\n+    let mut v0: Vec<Box<_>> = vec![box 1, box 1, box 2, box 3];\n+    v0.dedup();\n+    let mut v1: Vec<Box<_>> = vec![box 1, box 2, box 2, box 3];\n+    v1.dedup();\n+    let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n+    v2.dedup();\n+    /*\n+     * If the boxed pointers were leaked or otherwise misused, valgrind\n+     * and/or rt should raise errors.\n+     */\n+}\n+\n+#[test]\n+fn test_dedup_shared() {\n+    let mut v0: Vec<Box<_>> = vec![box 1, box 1, box 2, box 3];\n+    v0.dedup();\n+    let mut v1: Vec<Box<_>> = vec![box 1, box 2, box 2, box 3];\n+    v1.dedup();\n+    let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n+    v2.dedup();\n+    /*\n+     * If the pointers were leaked or otherwise misused, valgrind and/or\n+     * rt should raise errors.\n+     */\n+}\n+\n+#[test]\n+fn test_retain() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    v.retain(is_odd);\n+    assert_eq!(v, [1, 3, 5]);\n+}\n+\n+#[test]\n+fn test_element_swaps() {\n+    let mut v = [1, 2, 3];\n+    for (i, (a, b)) in ElementSwaps::new(v.len()).enumerate() {\n+        v.swap(a, b);\n+        match i {\n+            0 => assert!(v == [1, 3, 2]),\n+            1 => assert!(v == [3, 1, 2]),\n+            2 => assert!(v == [3, 2, 1]),\n+            3 => assert!(v == [2, 3, 1]),\n+            4 => assert!(v == [2, 1, 3]),\n+            5 => assert!(v == [1, 2, 3]),\n+            _ => panic!(),\n+        }\n+    }\n+}\n+\n+// FIXME(japaric) privacy\n+/*\n+#[test]\n+fn test_permutations() {\n+    {\n+        let v: [i32; 0] = [];\n+        let mut it = v.permutations();\n+        let (min_size, max_opt) = it.size_hint();\n+        assert_eq!(min_size, 1);\n+        assert_eq!(max_opt.unwrap(), 1);\n+        assert_eq!(it.next(), Some(v.to_vec()));\n+        assert_eq!(it.next(), None);\n+    }\n+    {\n+        let v = [\"Hello\".to_string()];\n+        let mut it = v.permutations();\n+        let (min_size, max_opt) = it.size_hint();\n+        assert_eq!(min_size, 1);\n+        assert_eq!(max_opt.unwrap(), 1);\n+        assert_eq!(it.next(), Some(v.to_vec()));\n+        assert_eq!(it.next(), None);\n+    }\n+    {\n+        let v = [1, 2, 3];\n+        let mut it = v.permutations();\n+        let (min_size, max_opt) = it.size_hint();\n+        assert_eq!(min_size, 3*2);\n+        assert_eq!(max_opt.unwrap(), 3*2);\n+        assert_eq!(it.next(), Some(vec![1,2,3]));\n+        assert_eq!(it.next(), Some(vec![1,3,2]));\n+        assert_eq!(it.next(), Some(vec![3,1,2]));\n+        let (min_size, max_opt) = it.size_hint();\n+        assert_eq!(min_size, 3);\n+        assert_eq!(max_opt.unwrap(), 3);\n+        assert_eq!(it.next(), Some(vec![3,2,1]));\n+        assert_eq!(it.next(), Some(vec![2,3,1]));\n+        assert_eq!(it.next(), Some(vec![2,1,3]));\n+        assert_eq!(it.next(), None);\n+    }\n+    {\n+        // check that we have N! permutations\n+        let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n+        let mut amt = 0;\n+        let mut it = v.permutations();\n+        let (min_size, max_opt) = it.size_hint();\n+        for _perm in it.by_ref() {\n+            amt += 1;\n+        }\n+        assert_eq!(amt, it.swaps.swaps_made);\n+        assert_eq!(amt, min_size);\n+        assert_eq!(amt, 2 * 3 * 4 * 5 * 6);\n+        assert_eq!(amt, max_opt.unwrap());\n+    }\n+}\n+*/\n+\n+#[test]\n+fn test_lexicographic_permutations() {\n+    let v : &mut[_] = &mut[1, 2, 3, 4, 5];\n+    assert!(v.prev_permutation() == false);\n+    assert!(v.next_permutation());\n+    let b: &mut[_] = &mut[1, 2, 3, 5, 4];\n+    assert!(v == b);\n+    assert!(v.prev_permutation());\n+    let b: &mut[_] = &mut[1, 2, 3, 4, 5];\n+    assert!(v == b);\n+    assert!(v.next_permutation());\n+    assert!(v.next_permutation());\n+    let b: &mut[_] = &mut[1, 2, 4, 3, 5];\n+    assert!(v == b);\n+    assert!(v.next_permutation());\n+    let b: &mut[_] = &mut[1, 2, 4, 5, 3];\n+    assert!(v == b);\n+\n+    let v : &mut[_] = &mut[1, 0, 0, 0];\n+    assert!(v.next_permutation() == false);\n+    assert!(v.prev_permutation());\n+    let b: &mut[_] = &mut[0, 1, 0, 0];\n+    assert!(v == b);\n+    assert!(v.prev_permutation());\n+    let b: &mut[_] = &mut[0, 0, 1, 0];\n+    assert!(v == b);\n+    assert!(v.prev_permutation());\n+    let b: &mut[_] = &mut[0, 0, 0, 1];\n+    assert!(v == b);\n+    assert!(v.prev_permutation() == false);\n+}\n+\n+#[test]\n+fn test_lexicographic_permutations_empty_and_short() {\n+    let empty : &mut[i32] = &mut[];\n+    assert!(empty.next_permutation() == false);\n+    let b: &mut[i32] = &mut[];\n+    assert!(empty == b);\n+    assert!(empty.prev_permutation() == false);\n+    assert!(empty == b);\n+\n+    let one_elem : &mut[_] = &mut[4];\n+    assert!(one_elem.prev_permutation() == false);\n+    let b: &mut[_] = &mut[4];\n+    assert!(one_elem == b);\n+    assert!(one_elem.next_permutation() == false);\n+    assert!(one_elem == b);\n+\n+    let two_elem : &mut[_] = &mut[1, 2];\n+    assert!(two_elem.prev_permutation() == false);\n+    let b : &mut[_] = &mut[1, 2];\n+    let c : &mut[_] = &mut[2, 1];\n+    assert!(two_elem == b);\n+    assert!(two_elem.next_permutation());\n+    assert!(two_elem == c);\n+    assert!(two_elem.next_permutation() == false);\n+    assert!(two_elem == c);\n+    assert!(two_elem.prev_permutation());\n+    assert!(two_elem == b);\n+    assert!(two_elem.prev_permutation() == false);\n+    assert!(two_elem == b);\n+}\n+\n+#[test]\n+fn test_position_elem() {\n+    assert!([].position_elem(&1).is_none());\n+\n+    let v1 = vec![1, 2, 3, 3, 2, 5];\n+    assert_eq!(v1.position_elem(&1), Some(0));\n+    assert_eq!(v1.position_elem(&2), Some(1));\n+    assert_eq!(v1.position_elem(&5), Some(5));\n+    assert!(v1.position_elem(&4).is_none());\n+}\n+\n+#[test]\n+fn test_binary_search() {\n+    assert_eq!([1,2,3,4,5].binary_search(&5).ok(), Some(4));\n+    assert_eq!([1,2,3,4,5].binary_search(&4).ok(), Some(3));\n+    assert_eq!([1,2,3,4,5].binary_search(&3).ok(), Some(2));\n+    assert_eq!([1,2,3,4,5].binary_search(&2).ok(), Some(1));\n+    assert_eq!([1,2,3,4,5].binary_search(&1).ok(), Some(0));\n+\n+    assert_eq!([2,4,6,8,10].binary_search(&1).ok(), None);\n+    assert_eq!([2,4,6,8,10].binary_search(&5).ok(), None);\n+    assert_eq!([2,4,6,8,10].binary_search(&4).ok(), Some(1));\n+    assert_eq!([2,4,6,8,10].binary_search(&10).ok(), Some(4));\n+\n+    assert_eq!([2,4,6,8].binary_search(&1).ok(), None);\n+    assert_eq!([2,4,6,8].binary_search(&5).ok(), None);\n+    assert_eq!([2,4,6,8].binary_search(&4).ok(), Some(1));\n+    assert_eq!([2,4,6,8].binary_search(&8).ok(), Some(3));\n+\n+    assert_eq!([2,4,6].binary_search(&1).ok(), None);\n+    assert_eq!([2,4,6].binary_search(&5).ok(), None);\n+    assert_eq!([2,4,6].binary_search(&4).ok(), Some(1));\n+    assert_eq!([2,4,6].binary_search(&6).ok(), Some(2));\n+\n+    assert_eq!([2,4].binary_search(&1).ok(), None);\n+    assert_eq!([2,4].binary_search(&5).ok(), None);\n+    assert_eq!([2,4].binary_search(&2).ok(), Some(0));\n+    assert_eq!([2,4].binary_search(&4).ok(), Some(1));\n+\n+    assert_eq!([2].binary_search(&1).ok(), None);\n+    assert_eq!([2].binary_search(&5).ok(), None);\n+    assert_eq!([2].binary_search(&2).ok(), Some(0));\n+\n+    assert_eq!([].binary_search(&1).ok(), None);\n+    assert_eq!([].binary_search(&5).ok(), None);\n+\n+    assert!([1,1,1,1,1].binary_search(&1).ok() != None);\n+    assert!([1,1,1,1,2].binary_search(&1).ok() != None);\n+    assert!([1,1,1,2,2].binary_search(&1).ok() != None);\n+    assert!([1,1,2,2,2].binary_search(&1).ok() != None);\n+    assert_eq!([1,2,2,2,2].binary_search(&1).ok(), Some(0));\n+\n+    assert_eq!([1,2,3,4,5].binary_search(&6).ok(), None);\n+    assert_eq!([1,2,3,4,5].binary_search(&0).ok(), None);\n+}\n+\n+#[test]\n+fn test_reverse() {\n+    let mut v = vec![10, 20];\n+    assert_eq!(v[0], 10);\n+    assert_eq!(v[1], 20);\n+    v.reverse();\n+    assert_eq!(v[0], 20);\n+    assert_eq!(v[1], 10);\n+\n+    let mut v3 = Vec::<i32>::new();\n+    v3.reverse();\n+    assert!(v3.is_empty());\n+}\n+\n+#[test]\n+fn test_sort() {\n+    for len in 4..25 {\n+        for _ in 0..100 {\n+            let mut v: Vec<_> = thread_rng().gen_iter::<i32>().take(len).collect();\n+            let mut v1 = v.clone();\n+\n+            v.sort();\n+            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+            v1.sort_by(|a, b| a.cmp(b));\n+            assert!(v1.windows(2).all(|w| w[0] <= w[1]));\n+\n+            v1.sort_by(|a, b| b.cmp(a));\n+            assert!(v1.windows(2).all(|w| w[0] >= w[1]));\n+        }\n+    }\n+\n+    // shouldn't panic\n+    let mut v: [i32; 0] = [];\n+    v.sort();\n+\n+    let mut v = [0xDEADBEEFu64];\n+    v.sort();\n+    assert!(v == [0xDEADBEEF]);\n+}\n+\n+#[test]\n+fn test_sort_stability() {\n+    for len in 4..25 {\n+        for _ in 0..10 {\n+            let mut counts = [0; 10];\n+\n+            // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n+            // where the first item of each tuple is random, but\n+            // the second item represents which occurrence of that\n+            // number this element is, i.e. the second elements\n+            // will occur in sorted order.\n+            let mut v: Vec<_> = (0..len).map(|_| {\n+                    let n = thread_rng().gen::<usize>() % 10;\n+                    counts[n] += 1;\n+                    (n, counts[n])\n+                }).collect();\n+\n+            // only sort on the first element, so an unstable sort\n+            // may mix up the counts.\n+            v.sort_by(|&(a,_), &(b,_)| a.cmp(&b));\n+\n+            // this comparison includes the count (the second item\n+            // of the tuple), so elements with equal first items\n+            // will need to be ordered with increasing\n+            // counts... i.e. exactly asserting that this sort is\n+            // stable.\n+            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_concat() {\n+    let v: [Vec<i32>; 0] = [];\n+    let c = v.concat();\n+    assert_eq!(c, []);\n+    let d = [vec![1], vec![2, 3]].concat();\n+    assert_eq!(d, [1, 2, 3]);\n+\n+    let v: &[&[_]] = &[&[1], &[2, 3]];\n+    assert_eq!(v.connect(&0), [1, 0, 2, 3]);\n+    let v: &[&[_]] = &[&[1], &[2], &[3]];\n+    assert_eq!(v.connect(&0), [1, 0, 2, 0, 3]);\n+}\n+\n+#[test]\n+fn test_connect() {\n+    let v: [Vec<i32>; 0] = [];\n+    assert_eq!(v.connect(&0), []);\n+    assert_eq!([vec![1], vec![2, 3]].connect(&0), [1, 0, 2, 3]);\n+    assert_eq!([vec![1], vec![2], vec![3]].connect(&0), [1, 0, 2, 0, 3]);\n+\n+    let v: [&[_]; 2] = [&[1], &[2, 3]];\n+    assert_eq!(v.connect(&0), [1, 0, 2, 3]);\n+    let v: [&[_]; 3] = [&[1], &[2], &[3]];\n+    assert_eq!(v.connect(&0), [1, 0, 2, 0, 3]);\n+}\n+\n+#[test]\n+fn test_insert() {\n+    let mut a = vec![1, 2, 4];\n+    a.insert(2, 3);\n+    assert_eq!(a, [1, 2, 3, 4]);\n+\n+    let mut a = vec![1, 2, 3];\n+    a.insert(0, 0);\n+    assert_eq!(a, [0, 1, 2, 3]);\n+\n+    let mut a = vec![1, 2, 3];\n+    a.insert(3, 4);\n+    assert_eq!(a, [1, 2, 3, 4]);\n+\n+    let mut a = vec![];\n+    a.insert(0, 1);\n+    assert_eq!(a, [1]);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_insert_oob() {\n+    let mut a = vec![1, 2, 3];\n+    a.insert(4, 5);\n+}\n+\n+#[test]\n+fn test_remove() {\n+    let mut a = vec![1, 2, 3, 4];\n+\n+    assert_eq!(a.remove(2), 3);\n+    assert_eq!(a, [1, 2, 4]);\n+\n+    assert_eq!(a.remove(2), 4);\n+    assert_eq!(a, [1, 2]);\n+\n+    assert_eq!(a.remove(0), 1);\n+    assert_eq!(a, [2]);\n+\n+    assert_eq!(a.remove(0), 2);\n+    assert_eq!(a, []);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_remove_fail() {\n+    let mut a = vec![1];\n+    let _ = a.remove(0);\n+    let _ = a.remove(0);\n+}\n+\n+#[test]\n+fn test_capacity() {\n+    let mut v = vec![0];\n+    v.reserve_exact(10);\n+    assert!(v.capacity() >= 11);\n+}\n+\n+#[test]\n+fn test_slice_2() {\n+    let v = vec![1, 2, 3, 4, 5];\n+    let v = v.slice(1, 3);\n+    assert_eq!(v.len(), 2);\n+    assert_eq!(v[0], 2);\n+    assert_eq!(v[1], 3);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_permute_fail() {\n+    let v: [(Box<_>, Rc<_>); 4] =\n+        [(box 0, Rc::new(0)), (box 0, Rc::new(0)),\n+         (box 0, Rc::new(0)), (box 0, Rc::new(0))];\n+    let mut i = 0;\n+    for _ in v.permutations() {\n+        if i == 2 {\n+            panic!()\n+        }\n+        i += 1;\n+    }\n+}\n+\n+#[test]\n+fn test_total_ord() {\n+    let c = &[1, 2, 3];\n+    [1, 2, 3, 4][..].cmp(c) == Greater;\n+    let c = &[1, 2, 3, 4];\n+    [1, 2, 3][..].cmp(c) == Less;\n+    let c = &[1, 2, 3, 6];\n+    [1, 2, 3, 4][..].cmp(c) == Equal;\n+    let c = &[1, 2, 3, 4, 5, 6];\n+    [1, 2, 3, 4, 5, 5, 5, 5][..].cmp(c) == Less;\n+    let c = &[1, 2, 3, 4];\n+    [2, 2][..].cmp(c) == Greater;\n+}\n+\n+#[test]\n+fn test_iterator() {\n+    let xs = [1, 2, 5, 10, 11];\n+    let mut it = xs.iter();\n+    assert_eq!(it.size_hint(), (5, Some(5)));\n+    assert_eq!(it.next().unwrap(), &1);\n+    assert_eq!(it.size_hint(), (4, Some(4)));\n+    assert_eq!(it.next().unwrap(), &2);\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+    assert_eq!(it.next().unwrap(), &5);\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+    assert_eq!(it.next().unwrap(), &10);\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next().unwrap(), &11);\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_random_access_iterator() {\n+    let xs = [1, 2, 5, 10, 11];\n+    let mut it = xs.iter();\n+\n+    assert_eq!(it.indexable(), 5);\n+    assert_eq!(it.idx(0).unwrap(), &1);\n+    assert_eq!(it.idx(2).unwrap(), &5);\n+    assert_eq!(it.idx(4).unwrap(), &11);\n+    assert!(it.idx(5).is_none());\n+\n+    assert_eq!(it.next().unwrap(), &1);\n+    assert_eq!(it.indexable(), 4);\n+    assert_eq!(it.idx(0).unwrap(), &2);\n+    assert_eq!(it.idx(3).unwrap(), &11);\n+    assert!(it.idx(4).is_none());\n+\n+    assert_eq!(it.next().unwrap(), &2);\n+    assert_eq!(it.indexable(), 3);\n+    assert_eq!(it.idx(1).unwrap(), &10);\n+    assert!(it.idx(3).is_none());\n+\n+    assert_eq!(it.next().unwrap(), &5);\n+    assert_eq!(it.indexable(), 2);\n+    assert_eq!(it.idx(1).unwrap(), &11);\n+\n+    assert_eq!(it.next().unwrap(), &10);\n+    assert_eq!(it.indexable(), 1);\n+    assert_eq!(it.idx(0).unwrap(), &11);\n+    assert!(it.idx(1).is_none());\n+\n+    assert_eq!(it.next().unwrap(), &11);\n+    assert_eq!(it.indexable(), 0);\n+    assert!(it.idx(0).is_none());\n+\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_iter_size_hints() {\n+    let mut xs = [1, 2, 5, 10, 11];\n+    assert_eq!(xs.iter().size_hint(), (5, Some(5)));\n+    assert_eq!(xs.iter_mut().size_hint(), (5, Some(5)));\n+}\n+\n+#[test]\n+fn test_iter_clone() {\n+    let xs = [1, 2, 5];\n+    let mut it = xs.iter();\n+    it.next();\n+    let mut jt = it.clone();\n+    assert_eq!(it.next(), jt.next());\n+    assert_eq!(it.next(), jt.next());\n+    assert_eq!(it.next(), jt.next());\n+}\n+\n+#[test]\n+fn test_mut_iterator() {\n+    let mut xs = [1, 2, 3, 4, 5];\n+    for x in &mut xs {\n+        *x += 1;\n+    }\n+    assert!(xs == [2, 3, 4, 5, 6])\n+}\n+\n+#[test]\n+fn test_rev_iterator() {\n+\n+    let xs = [1, 2, 5, 10, 11];\n+    let ys = [11, 10, 5, 2, 1];\n+    let mut i = 0;\n+    for &x in xs.iter().rev() {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, 5);\n+}\n+\n+#[test]\n+fn test_mut_rev_iterator() {\n+    let mut xs = [1, 2, 3, 4, 5];\n+    for (i,x) in xs.iter_mut().rev().enumerate() {\n+        *x += i;\n+    }\n+    assert!(xs == [5, 5, 5, 5, 5])\n+}\n+\n+#[test]\n+fn test_move_iterator() {\n+    let xs = vec![1,2,3,4,5];\n+    assert_eq!(xs.into_iter().fold(0, |a: usize, b: usize| 10*a + b), 12345);\n+}\n+\n+#[test]\n+fn test_move_rev_iterator() {\n+    let xs = vec![1,2,3,4,5];\n+    assert_eq!(xs.into_iter().rev().fold(0, |a: usize, b: usize| 10*a + b), 54321);\n+}\n+\n+#[test]\n+fn test_splitator() {\n+    let xs = &[1,2,3,4,5];\n+\n+    let splits: &[&[_]] = &[&[1], &[3], &[5]];\n+    assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&[_]] = &[&[], &[2,3,4,5]];\n+    assert_eq!(xs.split(|x| *x == 1).collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&[_]] = &[&[1,2,3,4], &[]];\n+    assert_eq!(xs.split(|x| *x == 5).collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+    assert_eq!(xs.split(|x| *x == 10).collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&[_]] = &[&[], &[], &[], &[], &[], &[]];\n+    assert_eq!(xs.split(|_| true).collect::<Vec<&[i32]>>(),\n+               splits);\n+\n+    let xs: &[i32] = &[];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n+}\n+\n+#[test]\n+fn test_splitnator() {\n+    let xs = &[1,2,3,4,5];\n+\n+    let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+    assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&[_]] = &[&[1], &[3,4,5]];\n+    assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&[_]] = &[&[], &[], &[], &[4,5]];\n+    assert_eq!(xs.splitn(3, |_| true).collect::<Vec<_>>(),\n+               splits);\n+\n+    let xs: &[i32] = &[];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<_>>(), splits);\n+}\n+\n+#[test]\n+fn test_splitnator_mut() {\n+    let xs = &mut [1,2,3,4,5];\n+\n+    let splits: &[&mut[_]] = &[&mut [1,2,3,4,5]];\n+    assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&mut[_]] = &[&mut [1], &mut [3,4,5]];\n+    assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&mut[_]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n+    assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<_>>(),\n+               splits);\n+\n+    let xs: &mut [i32] = &mut [];\n+    let splits: &[&mut[i32]] = &[&mut []];\n+    assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<_>>(),\n+               splits);\n+}\n+\n+#[test]\n+fn test_rsplitator() {\n+    let xs = &[1,2,3,4,5];\n+\n+    let splits: &[&[_]] = &[&[5], &[3], &[1]];\n+    assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&[_]] = &[&[2,3,4,5], &[]];\n+    assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&[_]] = &[&[], &[1,2,3,4]];\n+    assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+    assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<_>>(),\n+               splits);\n+\n+    let xs: &[i32] = &[];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[i32]>>(), splits);\n+}\n+\n+#[test]\n+fn test_rsplitnator() {\n+    let xs = &[1,2,3,4,5];\n+\n+    let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+    assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&[_]] = &[&[5], &[1,2,3]];\n+    assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+               splits);\n+    let splits: &[&[_]] = &[&[], &[], &[], &[1,2]];\n+    assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<_>>(),\n+               splits);\n+\n+    let xs: &[i32]  = &[];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n+}\n+\n+#[test]\n+fn test_windowsator() {\n+    let v = &[1,2,3,4];\n+\n+    let wins: &[&[_]] = &[&[1,2], &[2,3], &[3,4]];\n+    assert_eq!(v.windows(2).collect::<Vec<_>>(), wins);\n+\n+    let wins: &[&[_]] = &[&[1,2,3], &[2,3,4]];\n+    assert_eq!(v.windows(3).collect::<Vec<_>>(), wins);\n+    assert!(v.windows(6).next().is_none());\n+\n+    let wins: &[&[_]] = &[&[3,4], &[2,3], &[1,2]];\n+    assert_eq!(v.windows(2).rev().collect::<Vec<&[_]>>(), wins);\n+    let mut it = v.windows(2);\n+    assert_eq!(it.indexable(), 3);\n+    let win: &[_] = &[1,2];\n+    assert_eq!(it.idx(0).unwrap(), win);\n+    let win: &[_] = &[2,3];\n+    assert_eq!(it.idx(1).unwrap(), win);\n+    let win: &[_] = &[3,4];\n+    assert_eq!(it.idx(2).unwrap(), win);\n+    assert_eq!(it.idx(3), None);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_windowsator_0() {\n+    let v = &[1,2,3,4];\n+    let _it = v.windows(0);\n+}\n+\n+#[test]\n+fn test_chunksator() {\n+    let v = &[1,2,3,4,5];\n+\n+    assert_eq!(v.chunks(2).len(), 3);\n+\n+    let chunks: &[&[_]] = &[&[1,2], &[3,4], &[5]];\n+    assert_eq!(v.chunks(2).collect::<Vec<_>>(), chunks);\n+    let chunks: &[&[_]] = &[&[1,2,3], &[4,5]];\n+    assert_eq!(v.chunks(3).collect::<Vec<_>>(), chunks);\n+    let chunks: &[&[_]] = &[&[1,2,3,4,5]];\n+    assert_eq!(v.chunks(6).collect::<Vec<_>>(), chunks);\n+\n+    let chunks: &[&[_]] = &[&[5], &[3,4], &[1,2]];\n+    assert_eq!(v.chunks(2).rev().collect::<Vec<_>>(), chunks);\n+    let mut it = v.chunks(2);\n+    assert_eq!(it.indexable(), 3);\n+\n+    let chunk: &[_] = &[1,2];\n+    assert_eq!(it.idx(0).unwrap(), chunk);\n+    let chunk: &[_] = &[3,4];\n+    assert_eq!(it.idx(1).unwrap(), chunk);\n+    let chunk: &[_] = &[5];\n+    assert_eq!(it.idx(2).unwrap(), chunk);\n+    assert_eq!(it.idx(3), None);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_chunksator_0() {\n+    let v = &[1,2,3,4];\n+    let _it = v.chunks(0);\n+}\n+\n+#[test]\n+fn test_move_from() {\n+    let mut a = [1,2,3,4,5];\n+    let b = vec![6,7,8];\n+    assert_eq!(a.move_from(b, 0, 3), 3);\n+    assert!(a == [6,7,8,4,5]);\n+    let mut a = [7,2,8,1];\n+    let b = vec![3,1,4,1,5,9];\n+    assert_eq!(a.move_from(b, 0, 6), 4);\n+    assert!(a == [3,1,4,1]);\n+    let mut a = [1,2,3,4];\n+    let b = vec![5,6,7,8,9,0];\n+    assert_eq!(a.move_from(b, 2, 3), 1);\n+    assert!(a == [7,2,3,4]);\n+    let mut a = [1,2,3,4,5];\n+    let b = vec![5,6,7,8,9,0];\n+    assert_eq!(a[2..4].move_from(b,1,6), 2);\n+    assert!(a == [1,2,6,7,5]);\n+}\n+\n+#[test]\n+fn test_reverse_part() {\n+    let mut values = [1,2,3,4,5];\n+    values[1..4].reverse();\n+    assert!(values == [1,4,3,2,5]);\n+}\n+\n+#[test]\n+fn test_show() {\n+    macro_rules! test_show_vec {\n+        ($x:expr, $x_str:expr) => ({\n+            let (x, x_str) = ($x, $x_str);\n+            assert_eq!(format!(\"{:?}\", x), x_str);\n+            assert_eq!(format!(\"{:?}\", x), x_str);\n+        })\n+    }\n+    let empty = Vec::<i32>::new();\n+    test_show_vec!(empty, \"[]\");\n+    test_show_vec!(vec![1], \"[1]\");\n+    test_show_vec!(vec![1, 2, 3], \"[1, 2, 3]\");\n+    test_show_vec!(vec![vec![], vec![1], vec![1, 1]],\n+                   \"[[], [1], [1, 1]]\");\n+\n+    let empty_mut: &mut [i32] = &mut[];\n+    test_show_vec!(empty_mut, \"[]\");\n+    let v = &mut[1];\n+    test_show_vec!(v, \"[1]\");\n+    let v = &mut[1, 2, 3];\n+    test_show_vec!(v, \"[1, 2, 3]\");\n+    let v: &mut[&mut[_]] = &mut[&mut[], &mut[1], &mut[1, 1]];\n+    test_show_vec!(v, \"[[], [1], [1, 1]]\");\n+}\n+\n+#[test]\n+fn test_vec_default() {\n+    macro_rules! t {\n+        ($ty:ty) => {{\n+            let v: $ty = Default::default();\n+            assert!(v.is_empty());\n+        }}\n+    }\n+\n+    t!(&[i32]);\n+    t!(Vec<i32>);\n+}\n+\n+#[test]\n+fn test_bytes_set_memory() {\n+    use std::slice::bytes::MutableByteVector;\n+\n+    let mut values = [1,2,3,4,5];\n+    values[0..5].set_memory(0xAB);\n+    assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n+    values[2..4].set_memory(0xFF);\n+    assert!(values == [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_overflow_does_not_cause_segfault() {\n+    let mut v = vec![];\n+    v.reserve_exact(-1);\n+    v.push(1);\n+    v.push(2);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_overflow_does_not_cause_segfault_managed() {\n+    let mut v = vec![Rc::new(1)];\n+    v.reserve_exact(-1);\n+    v.push(Rc::new(2));\n+}\n+\n+#[test]\n+fn test_mut_split_at() {\n+    let mut values = [1u8,2,3,4,5];\n+    {\n+        let (left, right) = values.split_at_mut(2);\n+        {\n+            let left: &[_] = left;\n+            assert!(left[..left.len()] == [1, 2]);\n+        }\n+        for p in left {\n+            *p += 1;\n+        }\n+\n+        {\n+            let right: &[_] = right;\n+            assert!(right[..right.len()] == [3, 4, 5]);\n+        }\n+        for p in right {\n+            *p += 2;\n+        }\n+    }\n+\n+    assert!(values == [2, 3, 5, 6, 7]);\n+}\n+\n+#[derive(Clone, PartialEq)]\n+struct Foo;\n+\n+#[test]\n+fn test_iter_zero_sized() {\n+    let mut v = vec![Foo, Foo, Foo];\n+    assert_eq!(v.len(), 3);\n+    let mut cnt = 0;\n+\n+    for f in &v {\n+        assert!(*f == Foo);\n+        cnt += 1;\n+    }\n+    assert_eq!(cnt, 3);\n+\n+    for f in &v[1..3] {\n+        assert!(*f == Foo);\n+        cnt += 1;\n+    }\n+    assert_eq!(cnt, 5);\n+\n+    for f in &mut v {\n+        assert!(*f == Foo);\n+        cnt += 1;\n+    }\n+    assert_eq!(cnt, 8);\n+\n+    for f in v {\n+        assert!(f == Foo);\n+        cnt += 1;\n+    }\n+    assert_eq!(cnt, 11);\n+\n+    let xs: [Foo; 3] = [Foo, Foo, Foo];\n+    cnt = 0;\n+    for f in &xs {\n+        assert!(*f == Foo);\n+        cnt += 1;\n+    }\n+    assert!(cnt == 3);\n+}\n+\n+#[test]\n+fn test_shrink_to_fit() {\n+    let mut xs = vec![0, 1, 2, 3];\n+    for i in 4..100 {\n+        xs.push(i)\n+    }\n+    assert_eq!(xs.capacity(), 128);\n+    xs.shrink_to_fit();\n+    assert_eq!(xs.capacity(), 100);\n+    assert_eq!(xs, (0..100).collect::<Vec<_>>());\n+}\n+\n+#[test]\n+fn test_starts_with() {\n+    assert!(b\"foobar\".starts_with(b\"foo\"));\n+    assert!(!b\"foobar\".starts_with(b\"oob\"));\n+    assert!(!b\"foobar\".starts_with(b\"bar\"));\n+    assert!(!b\"foo\".starts_with(b\"foobar\"));\n+    assert!(!b\"bar\".starts_with(b\"foobar\"));\n+    assert!(b\"foobar\".starts_with(b\"foobar\"));\n+    let empty: &[u8] = &[];\n+    assert!(empty.starts_with(empty));\n+    assert!(!empty.starts_with(b\"foo\"));\n+    assert!(b\"foobar\".starts_with(empty));\n+}\n+\n+#[test]\n+fn test_ends_with() {\n+    assert!(b\"foobar\".ends_with(b\"bar\"));\n+    assert!(!b\"foobar\".ends_with(b\"oba\"));\n+    assert!(!b\"foobar\".ends_with(b\"foo\"));\n+    assert!(!b\"foo\".ends_with(b\"foobar\"));\n+    assert!(!b\"bar\".ends_with(b\"foobar\"));\n+    assert!(b\"foobar\".ends_with(b\"foobar\"));\n+    let empty: &[u8] = &[];\n+    assert!(empty.ends_with(empty));\n+    assert!(!empty.ends_with(b\"foo\"));\n+    assert!(b\"foobar\".ends_with(empty));\n+}\n+\n+#[test]\n+fn test_mut_splitator() {\n+    let mut xs = [0,1,0,2,3,0,0,4,5,0];\n+    assert_eq!(xs.split_mut(|x| *x == 0).count(), 6);\n+    for slice in xs.split_mut(|x| *x == 0) {\n+        slice.reverse();\n+    }\n+    assert!(xs == [0,1,0,3,2,0,0,5,4,0]);\n+\n+    let mut xs = [0,1,0,2,3,0,0,4,5,0,6,7];\n+    for slice in xs.split_mut(|x| *x == 0).take(5) {\n+        slice.reverse();\n+    }\n+    assert!(xs == [0,1,0,3,2,0,0,5,4,0,6,7]);\n+}\n+\n+#[test]\n+fn test_mut_splitator_rev() {\n+    let mut xs = [1,2,0,3,4,0,0,5,6,0];\n+    for slice in xs.split_mut(|x| *x == 0).rev().take(4) {\n+        slice.reverse();\n+    }\n+    assert!(xs == [1,2,0,4,3,0,0,6,5,0]);\n+}\n+\n+#[test]\n+fn test_get_mut() {\n+    let mut v = [0,1,2];\n+    assert_eq!(v.get_mut(3), None);\n+    v.get_mut(1).map(|e| *e = 7);\n+    assert_eq!(v[1], 7);\n+    let mut x = 2;\n+    assert_eq!(v.get_mut(2), Some(&mut x));\n+}\n+\n+#[test]\n+fn test_mut_chunks() {\n+    let mut v = [0, 1, 2, 3, 4, 5, 6];\n+    assert_eq!(v.chunks_mut(2).len(), 4);\n+    for (i, chunk) in v.chunks_mut(3).enumerate() {\n+        for x in chunk {\n+            *x = i as u8;\n+        }\n+    }\n+    let result = [0, 0, 0, 1, 1, 1, 2];\n+    assert!(v == result);\n+}\n+\n+#[test]\n+fn test_mut_chunks_rev() {\n+    let mut v = [0, 1, 2, 3, 4, 5, 6];\n+    for (i, chunk) in v.chunks_mut(3).rev().enumerate() {\n+        for x in chunk {\n+            *x = i as u8;\n+        }\n+    }\n+    let result = [2, 2, 2, 1, 1, 1, 0];\n+    assert!(v == result);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mut_chunks_0() {\n+    let mut v = [1, 2, 3, 4];\n+    let _it = v.chunks_mut(0);\n+}\n+\n+#[test]\n+fn test_mut_last() {\n+    let mut x = [1, 2, 3, 4, 5];\n+    let h = x.last_mut();\n+    assert_eq!(*h.unwrap(), 5);\n+\n+    let y: &mut [i32] = &mut [];\n+    assert!(y.last_mut().is_none());\n+}\n+\n+#[test]\n+fn test_to_vec() {\n+    let xs: Box<_> = box [1, 2, 3];\n+    let ys = xs.to_vec();\n+    assert_eq!(ys, [1, 2, 3]);\n+}\n+\n+mod bench {\n+    use std::iter::repeat;\n+    use std::{mem, ptr};\n+    use std::rand::{Rng, weak_rng};\n+\n+    use test::{Bencher, black_box};\n+\n+    #[bench]\n+    fn iterator(b: &mut Bencher) {\n+        // peculiar numbers to stop LLVM from optimising the summation\n+        // out.\n+        let v: Vec<_> = (0..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect();\n+\n+        b.iter(|| {\n+            let mut sum = 0;\n+            for x in &v {\n+                sum += *x;\n+            }\n+            // sum == 11806, to stop dead code elimination.\n+            if sum == 0 {panic!()}\n+        })\n+    }\n+\n+    #[bench]\n+    fn mut_iterator(b: &mut Bencher) {\n+        let mut v: Vec<_> = repeat(0).take(100).collect();\n+\n+        b.iter(|| {\n+            let mut i = 0;\n+            for x in &mut v {\n+                *x = i;\n+                i += 1;\n+            }\n+        })\n+    }\n+\n+    #[bench]\n+    fn concat(b: &mut Bencher) {\n+        let xss: Vec<Vec<i32>> =\n+            (0..100).map(|i| (0..i).collect()).collect();\n+        b.iter(|| {\n+            xss.concat();\n+        });\n+    }\n+\n+    #[bench]\n+    fn connect(b: &mut Bencher) {\n+        let xss: Vec<Vec<i32>> =\n+            (0..100).map(|i| (0..i).collect()).collect();\n+        b.iter(|| {\n+            xss.connect(&0)\n+        });\n+    }\n+\n+    #[bench]\n+    fn push(b: &mut Bencher) {\n+        let mut vec = Vec::<i32>::new();\n+        b.iter(|| {\n+            vec.push(0);\n+            black_box(&vec);\n+        });\n+    }\n+\n+    #[bench]\n+    fn starts_with_same_vector(b: &mut Bencher) {\n+        let vec: Vec<_> = (0..100).collect();\n+        b.iter(|| {\n+            vec.starts_with(&vec)\n+        })\n+    }\n+\n+    #[bench]\n+    fn starts_with_single_element(b: &mut Bencher) {\n+        let vec: Vec<_> = vec![0];\n+        b.iter(|| {\n+            vec.starts_with(&vec)\n+        })\n+    }\n+\n+    #[bench]\n+    fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n+        let vec: Vec<_> = (0..100).collect();\n+        let mut match_vec: Vec<_> = (0..99).collect();\n+        match_vec.push(0);\n+        b.iter(|| {\n+            vec.starts_with(&match_vec)\n+        })\n+    }\n+\n+    #[bench]\n+    fn ends_with_same_vector(b: &mut Bencher) {\n+        let vec: Vec<_> = (0..100).collect();\n+        b.iter(|| {\n+            vec.ends_with(&vec)\n+        })\n+    }\n+\n+    #[bench]\n+    fn ends_with_single_element(b: &mut Bencher) {\n+        let vec: Vec<_> = vec![0];\n+        b.iter(|| {\n+            vec.ends_with(&vec)\n+        })\n+    }\n+\n+    #[bench]\n+    fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n+        let vec: Vec<_> = (0..100).collect();\n+        let mut match_vec: Vec<_> = (0..100).collect();\n+        match_vec[0] = 200;\n+        b.iter(|| {\n+            vec.starts_with(&match_vec)\n+        })\n+    }\n+\n+    #[bench]\n+    fn contains_last_element(b: &mut Bencher) {\n+        let vec: Vec<_> = (0..100).collect();\n+        b.iter(|| {\n+            vec.contains(&99)\n+        })\n+    }\n+\n+    #[bench]\n+    fn zero_1kb_from_elem(b: &mut Bencher) {\n+        b.iter(|| {\n+            repeat(0u8).take(1024).collect::<Vec<_>>()\n+        });\n+    }\n+\n+    #[bench]\n+    fn zero_1kb_set_memory(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut v = Vec::<u8>::with_capacity(1024);\n+            unsafe {\n+                let vp = v.as_mut_ptr();\n+                ptr::set_memory(vp, 0, 1024);\n+                v.set_len(1024);\n+            }\n+            v\n+        });\n+    }\n+\n+    #[bench]\n+    fn zero_1kb_loop_set(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut v = Vec::<u8>::with_capacity(1024);\n+            unsafe {\n+                v.set_len(1024);\n+            }\n+            for i in 0..1024 {\n+                v[i] = 0;\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn zero_1kb_mut_iter(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut v = Vec::<u8>::with_capacity(1024);\n+            unsafe {\n+                v.set_len(1024);\n+            }\n+            for x in &mut v {\n+                *x = 0;\n+            }\n+            v\n+        });\n+    }\n+\n+    #[bench]\n+    fn random_inserts(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| {\n+            let mut v: Vec<_> = repeat((0, 0)).take(30).collect();\n+            for _ in 0..100 {\n+                let l = v.len();\n+                v.insert(rng.gen::<usize>() % (l + 1),\n+                         (1, 1));\n+            }\n+        })\n+    }\n+    #[bench]\n+    fn random_removes(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| {\n+            let mut v: Vec<_> = repeat((0, 0)).take(130).collect();\n+            for _ in 0..100 {\n+                let l = v.len();\n+                v.remove(rng.gen::<usize>() % l);\n+            }\n+        })\n+    }\n+\n+    #[bench]\n+    fn sort_random_small(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| {\n+            let mut v: Vec<_> = rng.gen_iter::<u64>().take(5).collect();\n+            v.sort();\n+        });\n+        b.bytes = 5 * mem::size_of::<u64>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_random_medium(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| {\n+            let mut v: Vec<_> = rng.gen_iter::<u64>().take(100).collect();\n+            v.sort();\n+        });\n+        b.bytes = 100 * mem::size_of::<u64>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_random_large(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| {\n+            let mut v: Vec<_> = rng.gen_iter::<u64>().take(10000).collect();\n+            v.sort();\n+        });\n+        b.bytes = 10000 * mem::size_of::<u64>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_sorted(b: &mut Bencher) {\n+        let mut v: Vec<_> = (0..10000).collect();\n+        b.iter(|| {\n+            v.sort();\n+        });\n+        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+    }\n+\n+    type BigSortable = (u64, u64, u64, u64);\n+\n+    #[bench]\n+    fn sort_big_random_small(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| {\n+            let mut v = rng.gen_iter::<BigSortable>().take(5)\n+                           .collect::<Vec<BigSortable>>();\n+            v.sort();\n+        });\n+        b.bytes = 5 * mem::size_of::<BigSortable>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_big_random_medium(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| {\n+            let mut v = rng.gen_iter::<BigSortable>().take(100)\n+                           .collect::<Vec<BigSortable>>();\n+            v.sort();\n+        });\n+        b.bytes = 100 * mem::size_of::<BigSortable>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_big_random_large(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| {\n+            let mut v = rng.gen_iter::<BigSortable>().take(10000)\n+                           .collect::<Vec<BigSortable>>();\n+            v.sort();\n+        });\n+        b.bytes = 10000 * mem::size_of::<BigSortable>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_big_sorted(b: &mut Bencher) {\n+        let mut v: Vec<BigSortable> = (0..10000).map(|i| (i, i, i, i)).collect();\n+        b.iter(|| {\n+            v.sort();\n+        });\n+        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+    }\n+}"}, {"sha": "79c2d719862a9e014849518573432df247c6a32c", "filename": "src/libcollectionstest/str.rs", "status": "added", "additions": 1668, "deletions": 0, "changes": 1668, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,1668 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp::Ordering::{Equal, Greater, Less};\n+use std::iter::AdditiveIterator;\n+use std::str::{Utf8Error, from_utf8};\n+\n+#[test]\n+fn test_le() {\n+    assert!(\"\" <= \"\");\n+    assert!(\"\" <= \"foo\");\n+    assert!(\"foo\" <= \"foo\");\n+    assert!(\"foo\" != \"bar\");\n+}\n+\n+#[test]\n+fn test_len() {\n+    assert_eq!(\"\".len(), 0);\n+    assert_eq!(\"hello world\".len(), 11);\n+    assert_eq!(\"\\x63\".len(), 1);\n+    assert_eq!(\"\\u{a2}\".len(), 2);\n+    assert_eq!(\"\\u{3c0}\".len(), 2);\n+    assert_eq!(\"\\u{2620}\".len(), 3);\n+    assert_eq!(\"\\u{1d11e}\".len(), 4);\n+\n+    assert_eq!(\"\".chars().count(), 0);\n+    assert_eq!(\"hello world\".chars().count(), 11);\n+    assert_eq!(\"\\x63\".chars().count(), 1);\n+    assert_eq!(\"\\u{a2}\".chars().count(), 1);\n+    assert_eq!(\"\\u{3c0}\".chars().count(), 1);\n+    assert_eq!(\"\\u{2620}\".chars().count(), 1);\n+    assert_eq!(\"\\u{1d11e}\".chars().count(), 1);\n+    assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().count(), 19);\n+\n+    assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(false), 10);\n+    assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(true), 10);\n+    assert_eq!(\"\\0\\0\\0\\0\\0\".width(false), 0);\n+    assert_eq!(\"\\0\\0\\0\\0\\0\".width(true), 0);\n+    assert_eq!(\"\".width(false), 0);\n+    assert_eq!(\"\".width(true), 0);\n+    assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(false), 4);\n+    assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(true), 8);\n+}\n+\n+#[test]\n+fn test_find() {\n+    assert_eq!(\"hello\".find('l'), Some(2));\n+    assert_eq!(\"hello\".find(|c:char| c == 'o'), Some(4));\n+    assert!(\"hello\".find('x').is_none());\n+    assert!(\"hello\".find(|c:char| c == 'x').is_none());\n+    assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find('\u534e'), Some(30));\n+    assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find(|c: char| c == '\u534e'), Some(30));\n+}\n+\n+#[test]\n+fn test_rfind() {\n+    assert_eq!(\"hello\".rfind('l'), Some(3));\n+    assert_eq!(\"hello\".rfind(|c:char| c == 'o'), Some(4));\n+    assert!(\"hello\".rfind('x').is_none());\n+    assert!(\"hello\".rfind(|c:char| c == 'x').is_none());\n+    assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind('\u534e'), Some(30));\n+    assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|c: char| c == '\u534e'), Some(30));\n+}\n+\n+#[test]\n+fn test_collect() {\n+    let empty = String::from_str(\"\");\n+    let s: String = empty.chars().collect();\n+    assert_eq!(empty, s);\n+    let data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n+    let s: String = data.chars().collect();\n+    assert_eq!(data, s);\n+}\n+\n+#[test]\n+fn test_into_bytes() {\n+    let data = String::from_str(\"asdf\");\n+    let buf = data.into_bytes();\n+    assert_eq!(b\"asdf\", buf);\n+}\n+\n+#[test]\n+fn test_find_str() {\n+    // byte positions\n+    assert_eq!(\"\".find_str(\"\"), Some(0));\n+    assert!(\"banana\".find_str(\"apple pie\").is_none());\n+\n+    let data = \"abcabc\";\n+    assert_eq!(data[0..6].find_str(\"ab\"), Some(0));\n+    assert_eq!(data[2..6].find_str(\"ab\"), Some(3 - 2));\n+    assert!(data[2..4].find_str(\"ab\").is_none());\n+\n+    let string = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let mut data = String::from_str(string);\n+    data.push_str(string);\n+    assert!(data.find_str(\"\u0e44\u0e17\u534e\").is_none());\n+    assert_eq!(data[0..43].find_str(\"\"), Some(0));\n+    assert_eq!(data[6..43].find_str(\"\"), Some(6 - 6));\n+\n+    assert_eq!(data[0..43].find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0));\n+    assert_eq!(data[0..43].find_str(\"\u0e17\u0e28\u0e44\"), Some(12));\n+    assert_eq!(data[0..43].find_str(\"\u0e22\u4e2d\"), Some(24));\n+    assert_eq!(data[0..43].find_str(\"i\u1ec7t\"), Some(34));\n+    assert_eq!(data[0..43].find_str(\"Nam\"), Some(40));\n+\n+    assert_eq!(data[43..86].find_str(\"\u0e1b\u0e23\u0e30\"), Some(43 - 43));\n+    assert_eq!(data[43..86].find_str(\"\u0e17\u0e28\u0e44\"), Some(55 - 43));\n+    assert_eq!(data[43..86].find_str(\"\u0e22\u4e2d\"), Some(67 - 43));\n+    assert_eq!(data[43..86].find_str(\"i\u1ec7t\"), Some(77 - 43));\n+    assert_eq!(data[43..86].find_str(\"Nam\"), Some(83 - 43));\n+}\n+\n+#[test]\n+fn test_slice_chars() {\n+    fn t(a: &str, b: &str, start: usize) {\n+        assert_eq!(a.slice_chars(start, start + b.chars().count()), b);\n+    }\n+    t(\"\", \"\", 0);\n+    t(\"hello\", \"llo\", 2);\n+    t(\"hello\", \"el\", 1);\n+    t(\"\u03b1\u03b2\u03bb\", \"\u03b2\", 1);\n+    t(\"\u03b1\u03b2\u03bb\", \"\", 3);\n+    assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".slice_chars(2, 8));\n+}\n+\n+fn s(x: &str) -> String { x.to_string() }\n+\n+macro_rules! test_concat {\n+    ($expected: expr, $string: expr) => {\n+        {\n+            let s: String = $string.concat();\n+            assert_eq!($expected, s);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_concat_for_different_types() {\n+    test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n+    test_concat!(\"ab\", vec![\"a\", \"b\"]);\n+    test_concat!(\"ab\", vec![\"a\", \"b\"]);\n+    test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n+}\n+\n+#[test]\n+fn test_concat_for_different_lengths() {\n+    let empty: &[&str] = &[];\n+    test_concat!(\"\", empty);\n+    test_concat!(\"a\", [\"a\"]);\n+    test_concat!(\"ab\", [\"a\", \"b\"]);\n+    test_concat!(\"abc\", [\"\", \"a\", \"bc\"]);\n+}\n+\n+macro_rules! test_connect {\n+    ($expected: expr, $string: expr, $delim: expr) => {\n+        {\n+            let s = $string.connect($delim);\n+            assert_eq!($expected, s);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_connect_for_different_types() {\n+    test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n+    let hyphen = \"-\".to_string();\n+    test_connect!(\"a-b\", [s(\"a\"), s(\"b\")], &*hyphen);\n+    test_connect!(\"a-b\", vec![\"a\", \"b\"], &*hyphen);\n+    test_connect!(\"a-b\", &*vec![\"a\", \"b\"], \"-\");\n+    test_connect!(\"a-b\", vec![s(\"a\"), s(\"b\")], \"-\");\n+}\n+\n+#[test]\n+fn test_connect_for_different_lengths() {\n+    let empty: &[&str] = &[];\n+    test_connect!(\"\", empty, \"-\");\n+    test_connect!(\"a\", [\"a\"], \"-\");\n+    test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n+    test_connect!(\"-a-bc\", [\"\", \"a\", \"bc\"], \"-\");\n+}\n+\n+#[test]\n+fn test_unsafe_slice() {\n+    assert_eq!(\"ab\", unsafe {\"abc\".slice_unchecked(0, 2)});\n+    assert_eq!(\"bc\", unsafe {\"abc\".slice_unchecked(1, 3)});\n+    assert_eq!(\"\", unsafe {\"abc\".slice_unchecked(1, 1)});\n+    fn a_million_letter_a() -> String {\n+        let mut i = 0;\n+        let mut rs = String::new();\n+        while i < 100000 {\n+            rs.push_str(\"aaaaaaaaaa\");\n+            i += 1;\n+        }\n+        rs\n+    }\n+    fn half_a_million_letter_a() -> String {\n+        let mut i = 0;\n+        let mut rs = String::new();\n+        while i < 100000 {\n+            rs.push_str(\"aaaaa\");\n+            i += 1;\n+        }\n+        rs\n+    }\n+    let letters = a_million_letter_a();\n+    assert!(half_a_million_letter_a() ==\n+        unsafe {String::from_str(letters.slice_unchecked(\n+                                 0,\n+                                 500000))});\n+}\n+\n+#[test]\n+fn test_starts_with() {\n+    assert!((\"\".starts_with(\"\")));\n+    assert!((\"abc\".starts_with(\"\")));\n+    assert!((\"abc\".starts_with(\"a\")));\n+    assert!((!\"a\".starts_with(\"abc\")));\n+    assert!((!\"\".starts_with(\"abc\")));\n+    assert!((!\"\u00f6dd\".starts_with(\"-\")));\n+    assert!((\"\u00f6dd\".starts_with(\"\u00f6d\")));\n+}\n+\n+#[test]\n+fn test_ends_with() {\n+    assert!((\"\".ends_with(\"\")));\n+    assert!((\"abc\".ends_with(\"\")));\n+    assert!((\"abc\".ends_with(\"c\")));\n+    assert!((!\"a\".ends_with(\"abc\")));\n+    assert!((!\"\".ends_with(\"abc\")));\n+    assert!((!\"dd\u00f6\".ends_with(\"-\")));\n+    assert!((\"dd\u00f6\".ends_with(\"d\u00f6\")));\n+}\n+\n+#[test]\n+fn test_is_empty() {\n+    assert!(\"\".is_empty());\n+    assert!(!\"a\".is_empty());\n+}\n+\n+#[test]\n+fn test_replace() {\n+    let a = \"a\";\n+    assert_eq!(\"\".replace(a, \"b\"), String::from_str(\"\"));\n+    assert_eq!(\"a\".replace(a, \"b\"), String::from_str(\"b\"));\n+    assert_eq!(\"ab\".replace(a, \"b\"), String::from_str(\"bb\"));\n+    let test = \"test\";\n+    assert!(\" test test \".replace(test, \"toast\") ==\n+        String::from_str(\" toast toast \"));\n+    assert_eq!(\" test test \".replace(test, \"\"), String::from_str(\"   \"));\n+}\n+\n+#[test]\n+fn test_replace_2a() {\n+    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+    let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+\n+    let a = \"\u0e1b\u0e23\u0e30\u0e40\";\n+    let a2 = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+    assert_eq!(data.replace(a, repl), a2);\n+}\n+\n+#[test]\n+fn test_replace_2b() {\n+    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+    let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+\n+    let b = \"\u0e30\u0e40\";\n+    let b2 = \"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+    assert_eq!(data.replace(b, repl), b2);\n+}\n+\n+#[test]\n+fn test_replace_2c() {\n+    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+    let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+\n+    let c = \"\u4e2d\u534e\";\n+    let c2 = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+    assert_eq!(data.replace(c, repl), c2);\n+}\n+\n+#[test]\n+fn test_replace_2d() {\n+    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+    let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+\n+    let d = \"\u0e44\u0e17\u534e\";\n+    assert_eq!(data.replace(d, repl), data);\n+}\n+\n+#[test]\n+fn test_slice() {\n+    assert_eq!(\"ab\", \"abc\".slice(0, 2));\n+    assert_eq!(\"bc\", \"abc\".slice(1, 3));\n+    assert_eq!(\"\", \"abc\".slice(1, 1));\n+    assert_eq!(\"\\u{65e5}\", \"\\u{65e5}\\u{672c}\".slice(0, 3));\n+\n+    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+    assert_eq!(\"\u0e1b\", data.slice(0, 3));\n+    assert_eq!(\"\u0e23\", data.slice(3, 6));\n+    assert_eq!(\"\", data.slice(3, 3));\n+    assert_eq!(\"\u534e\", data.slice(30, 33));\n+\n+    fn a_million_letter_x() -> String {\n+        let mut i = 0;\n+        let mut rs = String::new();\n+        while i < 100000 {\n+            rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n+            i += 1;\n+        }\n+        rs\n+    }\n+    fn half_a_million_letter_x() -> String {\n+        let mut i = 0;\n+        let mut rs = String::new();\n+        while i < 100000 {\n+            rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n+            i += 1;\n+        }\n+        rs\n+    }\n+    let letters = a_million_letter_x();\n+    assert!(half_a_million_letter_x() ==\n+        String::from_str(letters.slice(0, 3 * 500000)));\n+}\n+\n+#[test]\n+fn test_slice_2() {\n+    let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+\n+    assert_eq!(\"\u534e\", ss.slice(3, 6));\n+    assert_eq!(\"Vi\u1ec7t Nam\", ss.slice(6, 16));\n+\n+    assert_eq!(\"ab\", \"abc\".slice(0, 2));\n+    assert_eq!(\"bc\", \"abc\".slice(1, 3));\n+    assert_eq!(\"\", \"abc\".slice(1, 1));\n+\n+    assert_eq!(\"\u4e2d\", ss.slice(0, 3));\n+    assert_eq!(\"\u534eV\", ss.slice(3, 7));\n+    assert_eq!(\"\", ss.slice(3, 3));\n+    /*0: \u4e2d\n+      3: \u534e\n+      6: V\n+      7: i\n+      8: \u1ec7\n+     11: t\n+     12:\n+     13: N\n+     14: a\n+     15: m */\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_slice_fail() {\n+    \"\u4e2d\u534eVi\u1ec7t Nam\".slice(0, 2);\n+}\n+\n+#[test]\n+fn test_slice_from() {\n+    assert_eq!(\"abcd\".slice_from(0), \"abcd\");\n+    assert_eq!(\"abcd\".slice_from(2), \"cd\");\n+    assert_eq!(\"abcd\".slice_from(4), \"\");\n+}\n+#[test]\n+fn test_slice_to() {\n+    assert_eq!(\"abcd\".slice_to(0), \"\");\n+    assert_eq!(\"abcd\".slice_to(2), \"ab\");\n+    assert_eq!(\"abcd\".slice_to(4), \"abcd\");\n+}\n+\n+#[test]\n+fn test_trim_left_matches() {\n+    let v: &[char] = &[];\n+    assert_eq!(\" *** foo *** \".trim_left_matches(v), \" *** foo *** \");\n+    let chars: &[char] = &['*', ' '];\n+    assert_eq!(\" *** foo *** \".trim_left_matches(chars), \"foo *** \");\n+    assert_eq!(\" ***  *** \".trim_left_matches(chars), \"\");\n+    assert_eq!(\"foo *** \".trim_left_matches(chars), \"foo *** \");\n+\n+    assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n+    let chars: &[char] = &['1', '2'];\n+    assert_eq!(\"12foo1bar12\".trim_left_matches(chars), \"foo1bar12\");\n+    assert_eq!(\"123foo1bar123\".trim_left_matches(|c: char| c.is_numeric()), \"foo1bar123\");\n+}\n+\n+#[test]\n+fn test_trim_right_matches() {\n+    let v: &[char] = &[];\n+    assert_eq!(\" *** foo *** \".trim_right_matches(v), \" *** foo *** \");\n+    let chars: &[char] = &['*', ' '];\n+    assert_eq!(\" *** foo *** \".trim_right_matches(chars), \" *** foo\");\n+    assert_eq!(\" ***  *** \".trim_right_matches(chars), \"\");\n+    assert_eq!(\" *** foo\".trim_right_matches(chars), \" *** foo\");\n+\n+    assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n+    let chars: &[char] = &['1', '2'];\n+    assert_eq!(\"12foo1bar12\".trim_right_matches(chars), \"12foo1bar\");\n+    assert_eq!(\"123foo1bar123\".trim_right_matches(|c: char| c.is_numeric()), \"123foo1bar\");\n+}\n+\n+#[test]\n+fn test_trim_matches() {\n+    let v: &[char] = &[];\n+    assert_eq!(\" *** foo *** \".trim_matches(v), \" *** foo *** \");\n+    let chars: &[char] = &['*', ' '];\n+    assert_eq!(\" *** foo *** \".trim_matches(chars), \"foo\");\n+    assert_eq!(\" ***  *** \".trim_matches(chars), \"\");\n+    assert_eq!(\"foo\".trim_matches(chars), \"foo\");\n+\n+    assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n+    let chars: &[char] = &['1', '2'];\n+    assert_eq!(\"12foo1bar12\".trim_matches(chars), \"foo1bar\");\n+    assert_eq!(\"123foo1bar123\".trim_matches(|c: char| c.is_numeric()), \"foo1bar\");\n+}\n+\n+#[test]\n+fn test_trim_left() {\n+    assert_eq!(\"\".trim_left(), \"\");\n+    assert_eq!(\"a\".trim_left(), \"a\");\n+    assert_eq!(\"    \".trim_left(), \"\");\n+    assert_eq!(\"     blah\".trim_left(), \"blah\");\n+    assert_eq!(\"   \\u{3000}  wut\".trim_left(), \"wut\");\n+    assert_eq!(\"hey \".trim_left(), \"hey \");\n+}\n+\n+#[test]\n+fn test_trim_right() {\n+    assert_eq!(\"\".trim_right(), \"\");\n+    assert_eq!(\"a\".trim_right(), \"a\");\n+    assert_eq!(\"    \".trim_right(), \"\");\n+    assert_eq!(\"blah     \".trim_right(), \"blah\");\n+    assert_eq!(\"wut   \\u{3000}  \".trim_right(), \"wut\");\n+    assert_eq!(\" hey\".trim_right(), \" hey\");\n+}\n+\n+#[test]\n+fn test_trim() {\n+    assert_eq!(\"\".trim(), \"\");\n+    assert_eq!(\"a\".trim(), \"a\");\n+    assert_eq!(\"    \".trim(), \"\");\n+    assert_eq!(\"    blah     \".trim(), \"blah\");\n+    assert_eq!(\"\\nwut   \\u{3000}  \".trim(), \"wut\");\n+    assert_eq!(\" hey dude \".trim(), \"hey dude\");\n+}\n+\n+#[test]\n+fn test_is_whitespace() {\n+    assert!(\"\".chars().all(|c| c.is_whitespace()));\n+    assert!(\" \".chars().all(|c| c.is_whitespace()));\n+    assert!(\"\\u{2009}\".chars().all(|c| c.is_whitespace())); // Thin space\n+    assert!(\"  \\n\\t   \".chars().all(|c| c.is_whitespace()));\n+    assert!(!\"   _   \".chars().all(|c| c.is_whitespace()));\n+}\n+\n+#[test]\n+fn test_slice_shift_char() {\n+    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+    assert_eq!(data.slice_shift_char(), Some(('\u0e1b', \"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\")));\n+}\n+\n+#[test]\n+fn test_slice_shift_char_2() {\n+    let empty = \"\";\n+    assert_eq!(empty.slice_shift_char(), None);\n+}\n+\n+#[test]\n+fn test_is_utf8() {\n+    // deny overlong encodings\n+    assert!(from_utf8(&[0xc0, 0x80]).is_err());\n+    assert!(from_utf8(&[0xc0, 0xae]).is_err());\n+    assert!(from_utf8(&[0xe0, 0x80, 0x80]).is_err());\n+    assert!(from_utf8(&[0xe0, 0x80, 0xaf]).is_err());\n+    assert!(from_utf8(&[0xe0, 0x81, 0x81]).is_err());\n+    assert!(from_utf8(&[0xf0, 0x82, 0x82, 0xac]).is_err());\n+    assert!(from_utf8(&[0xf4, 0x90, 0x80, 0x80]).is_err());\n+\n+    // deny surrogates\n+    assert!(from_utf8(&[0xED, 0xA0, 0x80]).is_err());\n+    assert!(from_utf8(&[0xED, 0xBF, 0xBF]).is_err());\n+\n+    assert!(from_utf8(&[0xC2, 0x80]).is_ok());\n+    assert!(from_utf8(&[0xDF, 0xBF]).is_ok());\n+    assert!(from_utf8(&[0xE0, 0xA0, 0x80]).is_ok());\n+    assert!(from_utf8(&[0xED, 0x9F, 0xBF]).is_ok());\n+    assert!(from_utf8(&[0xEE, 0x80, 0x80]).is_ok());\n+    assert!(from_utf8(&[0xEF, 0xBF, 0xBF]).is_ok());\n+    assert!(from_utf8(&[0xF0, 0x90, 0x80, 0x80]).is_ok());\n+    assert!(from_utf8(&[0xF4, 0x8F, 0xBF, 0xBF]).is_ok());\n+}\n+\n+#[test]\n+fn test_is_utf16() {\n+    use unicode::str::is_utf16;\n+\n+    macro_rules! pos {\n+        ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } }\n+    }\n+\n+    // non-surrogates\n+    pos!(&[0x0000],\n+         &[0x0001, 0x0002],\n+         &[0xD7FF],\n+         &[0xE000]);\n+\n+    // surrogate pairs (randomly generated with Python 3's\n+    // .encode('utf-16be'))\n+    pos!(&[0xdb54, 0xdf16, 0xd880, 0xdee0, 0xdb6a, 0xdd45],\n+         &[0xd91f, 0xdeb1, 0xdb31, 0xdd84, 0xd8e2, 0xde14],\n+         &[0xdb9f, 0xdc26, 0xdb6f, 0xde58, 0xd850, 0xdfae]);\n+\n+    // mixtures (also random)\n+    pos!(&[0xd921, 0xdcc2, 0x002d, 0x004d, 0xdb32, 0xdf65],\n+         &[0xdb45, 0xdd2d, 0x006a, 0xdacd, 0xddfe, 0x0006],\n+         &[0x0067, 0xd8ff, 0xddb7, 0x000f, 0xd900, 0xdc80]);\n+\n+    // negative tests\n+    macro_rules! neg {\n+        ($($e:expr),*) => { { $(assert!(!is_utf16($e));)* } }\n+    }\n+\n+    neg!(\n+        // surrogate + regular unit\n+        &[0xdb45, 0x0000],\n+        // surrogate + lead surrogate\n+        &[0xd900, 0xd900],\n+        // unterminated surrogate\n+        &[0xd8ff],\n+        // trail surrogate without a lead\n+        &[0xddb7]);\n+\n+    // random byte sequences that Python 3's .decode('utf-16be')\n+    // failed on\n+    neg!(&[0x5b3d, 0x0141, 0xde9e, 0x8fdc, 0xc6e7],\n+         &[0xdf5a, 0x82a5, 0x62b9, 0xb447, 0x92f3],\n+         &[0xda4e, 0x42bc, 0x4462, 0xee98, 0xc2ca],\n+         &[0xbe00, 0xb04a, 0x6ecb, 0xdd89, 0xe278],\n+         &[0x0465, 0xab56, 0xdbb6, 0xa893, 0x665e],\n+         &[0x6b7f, 0x0a19, 0x40f4, 0xa657, 0xdcc5],\n+         &[0x9b50, 0xda5e, 0x24ec, 0x03ad, 0x6dee],\n+         &[0x8d17, 0xcaa7, 0xf4ae, 0xdf6e, 0xbed7],\n+         &[0xdaee, 0x2584, 0x7d30, 0xa626, 0x121a],\n+         &[0xd956, 0x4b43, 0x7570, 0xccd6, 0x4f4a],\n+         &[0x9dcf, 0x1b49, 0x4ba5, 0xfce9, 0xdffe],\n+         &[0x6572, 0xce53, 0xb05a, 0xf6af, 0xdacf],\n+         &[0x1b90, 0x728c, 0x9906, 0xdb68, 0xf46e],\n+         &[0x1606, 0xbeca, 0xbe76, 0x860f, 0xdfa5],\n+         &[0x8b4f, 0xde7a, 0xd220, 0x9fac, 0x2b6f],\n+         &[0xb8fe, 0xebbe, 0xda32, 0x1a5f, 0x8b8b],\n+         &[0x934b, 0x8956, 0xc434, 0x1881, 0xddf7],\n+         &[0x5a95, 0x13fc, 0xf116, 0xd89b, 0x93f9],\n+         &[0xd640, 0x71f1, 0xdd7d, 0x77eb, 0x1cd8],\n+         &[0x348b, 0xaef0, 0xdb2c, 0xebf1, 0x1282],\n+         &[0x50d7, 0xd824, 0x5010, 0xb369, 0x22ea]);\n+}\n+\n+#[test]\n+fn test_as_bytes() {\n+    // no null\n+    let v = [\n+        224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+        184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+        109\n+    ];\n+    let b: &[u8] = &[];\n+    assert_eq!(\"\".as_bytes(), b);\n+    assert_eq!(\"abc\".as_bytes(), b\"abc\");\n+    assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_as_bytes_fail() {\n+    // Don't double free. (I'm not sure if this exercises the\n+    // original problem code path anymore.)\n+    let s = String::from_str(\"\");\n+    let _bytes = s.as_bytes();\n+    panic!();\n+}\n+\n+#[test]\n+fn test_as_ptr() {\n+    let buf = \"hello\".as_ptr();\n+    unsafe {\n+        assert_eq!(*buf.offset(0), b'h');\n+        assert_eq!(*buf.offset(1), b'e');\n+        assert_eq!(*buf.offset(2), b'l');\n+        assert_eq!(*buf.offset(3), b'l');\n+        assert_eq!(*buf.offset(4), b'o');\n+    }\n+}\n+\n+#[test]\n+fn test_subslice_offset() {\n+    let a = \"kernelsprite\";\n+    let b = &a[7..a.len()];\n+    let c = &a[0..a.len() - 6];\n+    assert_eq!(a.subslice_offset(b), 7);\n+    assert_eq!(a.subslice_offset(c), 0);\n+\n+    let string = \"a\\nb\\nc\";\n+    let lines: Vec<&str> = string.lines().collect();\n+    assert_eq!(string.subslice_offset(lines[0]), 0);\n+    assert_eq!(string.subslice_offset(lines[1]), 2);\n+    assert_eq!(string.subslice_offset(lines[2]), 4);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_subslice_offset_2() {\n+    let a = \"alchemiter\";\n+    let b = \"cruxtruder\";\n+    a.subslice_offset(b);\n+}\n+\n+#[test]\n+fn vec_str_conversions() {\n+    let s1: String = String::from_str(\"All mimsy were the borogoves\");\n+\n+    let v: Vec<u8> = s1.as_bytes().to_vec();\n+    let s2: String = String::from_str(from_utf8(&v).unwrap());\n+    let mut i = 0;\n+    let n1 = s1.len();\n+    let n2 = v.len();\n+    assert_eq!(n1, n2);\n+    while i < n1 {\n+        let a: u8 = s1.as_bytes()[i];\n+        let b: u8 = s2.as_bytes()[i];\n+        debug!(\"{}\", a);\n+        debug!(\"{}\", b);\n+        assert_eq!(a, b);\n+        i += 1;\n+    }\n+}\n+\n+#[test]\n+fn test_contains() {\n+    assert!(\"abcde\".contains(\"bcd\"));\n+    assert!(\"abcde\".contains(\"abcd\"));\n+    assert!(\"abcde\".contains(\"bcde\"));\n+    assert!(\"abcde\".contains(\"\"));\n+    assert!(\"\".contains(\"\"));\n+    assert!(!\"abcde\".contains(\"def\"));\n+    assert!(!\"\".contains(\"a\"));\n+\n+    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    assert!(data.contains(\"\u0e1b\u0e23\u0e30\u0e40\"));\n+    assert!(data.contains(\"\u0e30\u0e40\"));\n+    assert!(data.contains(\"\u4e2d\u534e\"));\n+    assert!(!data.contains(\"\u0e44\u0e17\u534e\"));\n+}\n+\n+#[test]\n+fn test_contains_char() {\n+    assert!(\"abc\".contains_char('b'));\n+    assert!(\"a\".contains_char('a'));\n+    assert!(!\"abc\".contains_char('d'));\n+    assert!(!\"\".contains_char('a'));\n+}\n+\n+#[test]\n+fn test_char_at() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+    let mut pos = 0;\n+    for ch in &v {\n+        assert!(s.char_at(pos) == *ch);\n+        pos += ch.to_string().len();\n+    }\n+}\n+\n+#[test]\n+fn test_char_at_reverse() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+    let mut pos = s.len();\n+    for ch in v.iter().rev() {\n+        assert!(s.char_at_reverse(pos) == *ch);\n+        pos -= ch.to_string().len();\n+    }\n+}\n+\n+#[test]\n+fn test_escape_unicode() {\n+    assert_eq!(\"abc\".escape_unicode(),\n+               String::from_str(\"\\\\u{61}\\\\u{62}\\\\u{63}\"));\n+    assert_eq!(\"a c\".escape_unicode(),\n+               String::from_str(\"\\\\u{61}\\\\u{20}\\\\u{63}\"));\n+    assert_eq!(\"\\r\\n\\t\".escape_unicode(),\n+               String::from_str(\"\\\\u{d}\\\\u{a}\\\\u{9}\"));\n+    assert_eq!(\"'\\\"\\\\\".escape_unicode(),\n+               String::from_str(\"\\\\u{27}\\\\u{22}\\\\u{5c}\"));\n+    assert_eq!(\"\\x00\\x01\\u{fe}\\u{ff}\".escape_unicode(),\n+               String::from_str(\"\\\\u{0}\\\\u{1}\\\\u{fe}\\\\u{ff}\"));\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode(),\n+               String::from_str(\"\\\\u{100}\\\\u{ffff}\"));\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_unicode(),\n+               String::from_str(\"\\\\u{10000}\\\\u{10ffff}\"));\n+    assert_eq!(\"ab\\u{fb00}\".escape_unicode(),\n+               String::from_str(\"\\\\u{61}\\\\u{62}\\\\u{fb00}\"));\n+    assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode(),\n+               String::from_str(\"\\\\u{1d4ea}\\\\u{d}\"));\n+}\n+\n+#[test]\n+fn test_escape_default() {\n+    assert_eq!(\"abc\".escape_default(), String::from_str(\"abc\"));\n+    assert_eq!(\"a c\".escape_default(), String::from_str(\"a c\"));\n+    assert_eq!(\"\\r\\n\\t\".escape_default(), String::from_str(\"\\\\r\\\\n\\\\t\"));\n+    assert_eq!(\"'\\\"\\\\\".escape_default(), String::from_str(\"\\\\'\\\\\\\"\\\\\\\\\"));\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_default(),\n+               String::from_str(\"\\\\u{100}\\\\u{ffff}\"));\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_default(),\n+               String::from_str(\"\\\\u{10000}\\\\u{10ffff}\"));\n+    assert_eq!(\"ab\\u{fb00}\".escape_default(),\n+               String::from_str(\"ab\\\\u{fb00}\"));\n+    assert_eq!(\"\\u{1d4ea}\\r\".escape_default(),\n+               String::from_str(\"\\\\u{1d4ea}\\\\r\"));\n+}\n+\n+#[test]\n+fn test_total_ord() {\n+    \"1234\".cmp(\"123\") == Greater;\n+    \"123\".cmp(\"1234\") == Less;\n+    \"1234\".cmp(\"1234\") == Equal;\n+    \"12345555\".cmp(\"123456\") == Less;\n+    \"22\".cmp(\"1234\") == Greater;\n+}\n+\n+#[test]\n+fn test_char_range_at() {\n+    let data = \"b\u00a2\u20ac\ud852\udf62\ud852\udf62\u20ac\u00a2b\";\n+    assert_eq!('b', data.char_range_at(0).ch);\n+    assert_eq!('\u00a2', data.char_range_at(1).ch);\n+    assert_eq!('\u20ac', data.char_range_at(3).ch);\n+    assert_eq!('\ud852\udf62', data.char_range_at(6).ch);\n+    assert_eq!('\ud852\udf62', data.char_range_at(10).ch);\n+    assert_eq!('\u20ac', data.char_range_at(14).ch);\n+    assert_eq!('\u00a2', data.char_range_at(17).ch);\n+    assert_eq!('b', data.char_range_at(19).ch);\n+}\n+\n+#[test]\n+fn test_char_range_at_reverse_underflow() {\n+    assert_eq!(\"abc\".char_range_at_reverse(0).next, 0);\n+}\n+\n+#[test]\n+fn test_iterator() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+\n+    let mut pos = 0;\n+    let it = s.chars();\n+\n+    for c in it {\n+        assert_eq!(c, v[pos]);\n+        pos += 1;\n+    }\n+    assert_eq!(pos, v.len());\n+}\n+\n+#[test]\n+fn test_rev_iterator() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n+\n+    let mut pos = 0;\n+    let it = s.chars().rev();\n+\n+    for c in it {\n+        assert_eq!(c, v[pos]);\n+        pos += 1;\n+    }\n+    assert_eq!(pos, v.len());\n+}\n+\n+#[test]\n+fn test_chars_decoding() {\n+    let mut bytes = [0; 4];\n+    for c in (0..0x110000).filter_map(::std::char::from_u32) {\n+        let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n+        let s = ::std::str::from_utf8(&bytes[..len]).unwrap();\n+        if Some(c) != s.chars().next() {\n+            panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_chars_rev_decoding() {\n+    let mut bytes = [0; 4];\n+    for c in (0..0x110000).filter_map(::std::char::from_u32) {\n+        let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n+        let s = ::std::str::from_utf8(&bytes[..len]).unwrap();\n+        if Some(c) != s.chars().rev().next() {\n+            panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_iterator_clone() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let mut it = s.chars();\n+    it.next();\n+    assert!(it.clone().zip(it).all(|(x,y)| x == y));\n+}\n+\n+#[test]\n+fn test_bytesator() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let v = [\n+        224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+        184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+        109\n+    ];\n+    let mut pos = 0;\n+\n+    for b in s.bytes() {\n+        assert_eq!(b, v[pos]);\n+        pos += 1;\n+    }\n+}\n+\n+#[test]\n+fn test_bytes_revator() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let v = [\n+        224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+        184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+        109\n+    ];\n+    let mut pos = v.len();\n+\n+    for b in s.bytes().rev() {\n+        pos -= 1;\n+        assert_eq!(b, v[pos]);\n+    }\n+}\n+\n+#[test]\n+fn test_char_indicesator() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let p = [0, 3, 6, 9, 12, 15, 18, 19, 20, 23, 24, 25, 26, 27];\n+    let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+\n+    let mut pos = 0;\n+    let it = s.char_indices();\n+\n+    for c in it {\n+        assert_eq!(c, (p[pos], v[pos]));\n+        pos += 1;\n+    }\n+    assert_eq!(pos, v.len());\n+    assert_eq!(pos, p.len());\n+}\n+\n+#[test]\n+fn test_char_indices_revator() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let p = [27, 26, 25, 24, 23, 20, 19, 18, 15, 12, 9, 6, 3, 0];\n+    let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n+\n+    let mut pos = 0;\n+    let it = s.char_indices().rev();\n+\n+    for c in it {\n+        assert_eq!(c, (p[pos], v[pos]));\n+        pos += 1;\n+    }\n+    assert_eq!(pos, v.len());\n+    assert_eq!(pos, p.len());\n+}\n+\n+#[test]\n+fn test_splitn_char_iterator() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.splitn(3, ' ').collect();\n+    assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+\n+    let split: Vec<&str> = data.splitn(3, |c: char| c == ' ').collect();\n+    assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+\n+    // Unicode\n+    let split: Vec<&str> = data.splitn(3, '\u00e4').collect();\n+    assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+\n+    let split: Vec<&str> = data.splitn(3, |c: char| c == '\u00e4').collect();\n+    assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+}\n+\n+#[test]\n+fn test_split_char_iterator_no_trailing() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.split('\\n').collect();\n+    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+\n+    let split: Vec<&str> = data.split_terminator('\\n').collect();\n+    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+}\n+\n+#[test]\n+fn test_words() {\n+    let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+    let words: Vec<&str> = data.words().collect();\n+    assert_eq!(words, [\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n+}\n+\n+#[test]\n+fn test_nfd_chars() {\n+    macro_rules! t {\n+        ($input: expr, $expected: expr) => {\n+            assert_eq!($input.nfd_chars().collect::<String>(), $expected);\n+        }\n+    }\n+    t!(\"abc\", \"abc\");\n+    t!(\"\\u{1e0b}\\u{1c4}\", \"d\\u{307}\\u{1c4}\");\n+    t!(\"\\u{2026}\", \"\\u{2026}\");\n+    t!(\"\\u{2126}\", \"\\u{3a9}\");\n+    t!(\"\\u{1e0b}\\u{323}\", \"d\\u{323}\\u{307}\");\n+    t!(\"\\u{1e0d}\\u{307}\", \"d\\u{323}\\u{307}\");\n+    t!(\"a\\u{301}\", \"a\\u{301}\");\n+    t!(\"\\u{301}a\", \"\\u{301}a\");\n+    t!(\"\\u{d4db}\", \"\\u{1111}\\u{1171}\\u{11b6}\");\n+    t!(\"\\u{ac1c}\", \"\\u{1100}\\u{1162}\");\n+}\n+\n+#[test]\n+fn test_nfkd_chars() {\n+    macro_rules! t {\n+        ($input: expr, $expected: expr) => {\n+            assert_eq!($input.nfkd_chars().collect::<String>(), $expected);\n+        }\n+    }\n+    t!(\"abc\", \"abc\");\n+    t!(\"\\u{1e0b}\\u{1c4}\", \"d\\u{307}DZ\\u{30c}\");\n+    t!(\"\\u{2026}\", \"...\");\n+    t!(\"\\u{2126}\", \"\\u{3a9}\");\n+    t!(\"\\u{1e0b}\\u{323}\", \"d\\u{323}\\u{307}\");\n+    t!(\"\\u{1e0d}\\u{307}\", \"d\\u{323}\\u{307}\");\n+    t!(\"a\\u{301}\", \"a\\u{301}\");\n+    t!(\"\\u{301}a\", \"\\u{301}a\");\n+    t!(\"\\u{d4db}\", \"\\u{1111}\\u{1171}\\u{11b6}\");\n+    t!(\"\\u{ac1c}\", \"\\u{1100}\\u{1162}\");\n+}\n+\n+#[test]\n+fn test_nfc_chars() {\n+    macro_rules! t {\n+        ($input: expr, $expected: expr) => {\n+            assert_eq!($input.nfc_chars().collect::<String>(), $expected);\n+        }\n+    }\n+    t!(\"abc\", \"abc\");\n+    t!(\"\\u{1e0b}\\u{1c4}\", \"\\u{1e0b}\\u{1c4}\");\n+    t!(\"\\u{2026}\", \"\\u{2026}\");\n+    t!(\"\\u{2126}\", \"\\u{3a9}\");\n+    t!(\"\\u{1e0b}\\u{323}\", \"\\u{1e0d}\\u{307}\");\n+    t!(\"\\u{1e0d}\\u{307}\", \"\\u{1e0d}\\u{307}\");\n+    t!(\"a\\u{301}\", \"\\u{e1}\");\n+    t!(\"\\u{301}a\", \"\\u{301}a\");\n+    t!(\"\\u{d4db}\", \"\\u{d4db}\");\n+    t!(\"\\u{ac1c}\", \"\\u{ac1c}\");\n+    t!(\"a\\u{300}\\u{305}\\u{315}\\u{5ae}b\", \"\\u{e0}\\u{5ae}\\u{305}\\u{315}b\");\n+}\n+\n+#[test]\n+fn test_nfkc_chars() {\n+    macro_rules! t {\n+        ($input: expr, $expected: expr) => {\n+            assert_eq!($input.nfkc_chars().collect::<String>(), $expected);\n+        }\n+    }\n+    t!(\"abc\", \"abc\");\n+    t!(\"\\u{1e0b}\\u{1c4}\", \"\\u{1e0b}D\\u{17d}\");\n+    t!(\"\\u{2026}\", \"...\");\n+    t!(\"\\u{2126}\", \"\\u{3a9}\");\n+    t!(\"\\u{1e0b}\\u{323}\", \"\\u{1e0d}\\u{307}\");\n+    t!(\"\\u{1e0d}\\u{307}\", \"\\u{1e0d}\\u{307}\");\n+    t!(\"a\\u{301}\", \"\\u{e1}\");\n+    t!(\"\\u{301}a\", \"\\u{301}a\");\n+    t!(\"\\u{d4db}\", \"\\u{d4db}\");\n+    t!(\"\\u{ac1c}\", \"\\u{ac1c}\");\n+    t!(\"a\\u{300}\\u{305}\\u{315}\\u{5ae}b\", \"\\u{e0}\\u{5ae}\\u{305}\\u{315}b\");\n+}\n+\n+#[test]\n+fn test_lines() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let lines: Vec<&str> = data.lines().collect();\n+    assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\"; // no trailing \\n\n+    let lines: Vec<&str> = data.lines().collect();\n+    assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+}\n+\n+#[test]\n+fn test_graphemes() {\n+    use std::iter::order;\n+\n+    // official Unicode test data\n+    // from http://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n+    let test_same: [(_, &[_]); 325] = [\n+        (\"\\u{20}\\u{20}\", &[\"\\u{20}\", \"\\u{20}\"]),\n+        (\"\\u{20}\\u{308}\\u{20}\", &[\"\\u{20}\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{20}\\u{D}\", &[\"\\u{20}\", \"\\u{D}\"]),\n+        (\"\\u{20}\\u{308}\\u{D}\", &[\"\\u{20}\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{20}\\u{A}\", &[\"\\u{20}\", \"\\u{A}\"]),\n+        (\"\\u{20}\\u{308}\\u{A}\", &[\"\\u{20}\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{20}\\u{1}\", &[\"\\u{20}\", \"\\u{1}\"]),\n+        (\"\\u{20}\\u{308}\\u{1}\", &[\"\\u{20}\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{20}\\u{300}\", &[\"\\u{20}\\u{300}\"]),\n+        (\"\\u{20}\\u{308}\\u{300}\", &[\"\\u{20}\\u{308}\\u{300}\"]),\n+        (\"\\u{20}\\u{1100}\", &[\"\\u{20}\", \"\\u{1100}\"]),\n+        (\"\\u{20}\\u{308}\\u{1100}\", &[\"\\u{20}\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{20}\\u{1160}\", &[\"\\u{20}\", \"\\u{1160}\"]),\n+        (\"\\u{20}\\u{308}\\u{1160}\", &[\"\\u{20}\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{20}\\u{11A8}\", &[\"\\u{20}\", \"\\u{11A8}\"]),\n+        (\"\\u{20}\\u{308}\\u{11A8}\", &[\"\\u{20}\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{20}\\u{AC00}\", &[\"\\u{20}\", \"\\u{AC00}\"]),\n+        (\"\\u{20}\\u{308}\\u{AC00}\", &[\"\\u{20}\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{20}\\u{AC01}\", &[\"\\u{20}\", \"\\u{AC01}\"]),\n+        (\"\\u{20}\\u{308}\\u{AC01}\", &[\"\\u{20}\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{20}\\u{1F1E6}\", &[\"\\u{20}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{20}\\u{308}\\u{1F1E6}\", &[\"\\u{20}\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{20}\\u{378}\", &[\"\\u{20}\", \"\\u{378}\"]),\n+        (\"\\u{20}\\u{308}\\u{378}\", &[\"\\u{20}\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{D}\\u{20}\", &[\"\\u{D}\", \"\\u{20}\"]),\n+        (\"\\u{D}\\u{308}\\u{20}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{D}\\u{D}\", &[\"\\u{D}\", \"\\u{D}\"]),\n+        (\"\\u{D}\\u{308}\\u{D}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{D}\\u{A}\", &[\"\\u{D}\\u{A}\"]),\n+        (\"\\u{D}\\u{308}\\u{A}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{D}\\u{1}\", &[\"\\u{D}\", \"\\u{1}\"]),\n+        (\"\\u{D}\\u{308}\\u{1}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{D}\\u{300}\", &[\"\\u{D}\", \"\\u{300}\"]),\n+        (\"\\u{D}\\u{308}\\u{300}\", &[\"\\u{D}\", \"\\u{308}\\u{300}\"]),\n+        (\"\\u{D}\\u{903}\", &[\"\\u{D}\", \"\\u{903}\"]),\n+        (\"\\u{D}\\u{1100}\", &[\"\\u{D}\", \"\\u{1100}\"]),\n+        (\"\\u{D}\\u{308}\\u{1100}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{D}\\u{1160}\", &[\"\\u{D}\", \"\\u{1160}\"]),\n+        (\"\\u{D}\\u{308}\\u{1160}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{D}\\u{11A8}\", &[\"\\u{D}\", \"\\u{11A8}\"]),\n+        (\"\\u{D}\\u{308}\\u{11A8}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{D}\\u{AC00}\", &[\"\\u{D}\", \"\\u{AC00}\"]),\n+        (\"\\u{D}\\u{308}\\u{AC00}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{D}\\u{AC01}\", &[\"\\u{D}\", \"\\u{AC01}\"]),\n+        (\"\\u{D}\\u{308}\\u{AC01}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{D}\\u{1F1E6}\", &[\"\\u{D}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{D}\\u{308}\\u{1F1E6}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{D}\\u{378}\", &[\"\\u{D}\", \"\\u{378}\"]),\n+        (\"\\u{D}\\u{308}\\u{378}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{A}\\u{20}\", &[\"\\u{A}\", \"\\u{20}\"]),\n+        (\"\\u{A}\\u{308}\\u{20}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{A}\\u{D}\", &[\"\\u{A}\", \"\\u{D}\"]),\n+        (\"\\u{A}\\u{308}\\u{D}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{A}\\u{A}\", &[\"\\u{A}\", \"\\u{A}\"]),\n+        (\"\\u{A}\\u{308}\\u{A}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{A}\\u{1}\", &[\"\\u{A}\", \"\\u{1}\"]),\n+        (\"\\u{A}\\u{308}\\u{1}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{A}\\u{300}\", &[\"\\u{A}\", \"\\u{300}\"]),\n+        (\"\\u{A}\\u{308}\\u{300}\", &[\"\\u{A}\", \"\\u{308}\\u{300}\"]),\n+        (\"\\u{A}\\u{903}\", &[\"\\u{A}\", \"\\u{903}\"]),\n+        (\"\\u{A}\\u{1100}\", &[\"\\u{A}\", \"\\u{1100}\"]),\n+        (\"\\u{A}\\u{308}\\u{1100}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{A}\\u{1160}\", &[\"\\u{A}\", \"\\u{1160}\"]),\n+        (\"\\u{A}\\u{308}\\u{1160}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{A}\\u{11A8}\", &[\"\\u{A}\", \"\\u{11A8}\"]),\n+        (\"\\u{A}\\u{308}\\u{11A8}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{A}\\u{AC00}\", &[\"\\u{A}\", \"\\u{AC00}\"]),\n+        (\"\\u{A}\\u{308}\\u{AC00}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{A}\\u{AC01}\", &[\"\\u{A}\", \"\\u{AC01}\"]),\n+        (\"\\u{A}\\u{308}\\u{AC01}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{A}\\u{1F1E6}\", &[\"\\u{A}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{A}\\u{308}\\u{1F1E6}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{A}\\u{378}\", &[\"\\u{A}\", \"\\u{378}\"]),\n+        (\"\\u{A}\\u{308}\\u{378}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{1}\\u{20}\", &[\"\\u{1}\", \"\\u{20}\"]),\n+        (\"\\u{1}\\u{308}\\u{20}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{1}\\u{D}\", &[\"\\u{1}\", \"\\u{D}\"]),\n+        (\"\\u{1}\\u{308}\\u{D}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{1}\\u{A}\", &[\"\\u{1}\", \"\\u{A}\"]),\n+        (\"\\u{1}\\u{308}\\u{A}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{1}\\u{1}\", &[\"\\u{1}\", \"\\u{1}\"]),\n+        (\"\\u{1}\\u{308}\\u{1}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{1}\\u{300}\", &[\"\\u{1}\", \"\\u{300}\"]),\n+        (\"\\u{1}\\u{308}\\u{300}\", &[\"\\u{1}\", \"\\u{308}\\u{300}\"]),\n+        (\"\\u{1}\\u{903}\", &[\"\\u{1}\", \"\\u{903}\"]),\n+        (\"\\u{1}\\u{1100}\", &[\"\\u{1}\", \"\\u{1100}\"]),\n+        (\"\\u{1}\\u{308}\\u{1100}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{1}\\u{1160}\", &[\"\\u{1}\", \"\\u{1160}\"]),\n+        (\"\\u{1}\\u{308}\\u{1160}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{1}\\u{11A8}\", &[\"\\u{1}\", \"\\u{11A8}\"]),\n+        (\"\\u{1}\\u{308}\\u{11A8}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{1}\\u{AC00}\", &[\"\\u{1}\", \"\\u{AC00}\"]),\n+        (\"\\u{1}\\u{308}\\u{AC00}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{1}\\u{AC01}\", &[\"\\u{1}\", \"\\u{AC01}\"]),\n+        (\"\\u{1}\\u{308}\\u{AC01}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{1}\\u{1F1E6}\", &[\"\\u{1}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{1}\\u{308}\\u{1F1E6}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{1}\\u{378}\", &[\"\\u{1}\", \"\\u{378}\"]),\n+        (\"\\u{1}\\u{308}\\u{378}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{300}\\u{20}\", &[\"\\u{300}\", \"\\u{20}\"]),\n+        (\"\\u{300}\\u{308}\\u{20}\", &[\"\\u{300}\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{300}\\u{D}\", &[\"\\u{300}\", \"\\u{D}\"]),\n+        (\"\\u{300}\\u{308}\\u{D}\", &[\"\\u{300}\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{300}\\u{A}\", &[\"\\u{300}\", \"\\u{A}\"]),\n+        (\"\\u{300}\\u{308}\\u{A}\", &[\"\\u{300}\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{300}\\u{1}\", &[\"\\u{300}\", \"\\u{1}\"]),\n+        (\"\\u{300}\\u{308}\\u{1}\", &[\"\\u{300}\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{300}\\u{300}\", &[\"\\u{300}\\u{300}\"]),\n+        (\"\\u{300}\\u{308}\\u{300}\", &[\"\\u{300}\\u{308}\\u{300}\"]),\n+        (\"\\u{300}\\u{1100}\", &[\"\\u{300}\", \"\\u{1100}\"]),\n+        (\"\\u{300}\\u{308}\\u{1100}\", &[\"\\u{300}\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{300}\\u{1160}\", &[\"\\u{300}\", \"\\u{1160}\"]),\n+        (\"\\u{300}\\u{308}\\u{1160}\", &[\"\\u{300}\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{300}\\u{11A8}\", &[\"\\u{300}\", \"\\u{11A8}\"]),\n+        (\"\\u{300}\\u{308}\\u{11A8}\", &[\"\\u{300}\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{300}\\u{AC00}\", &[\"\\u{300}\", \"\\u{AC00}\"]),\n+        (\"\\u{300}\\u{308}\\u{AC00}\", &[\"\\u{300}\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{300}\\u{AC01}\", &[\"\\u{300}\", \"\\u{AC01}\"]),\n+        (\"\\u{300}\\u{308}\\u{AC01}\", &[\"\\u{300}\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{300}\\u{1F1E6}\", &[\"\\u{300}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{300}\\u{308}\\u{1F1E6}\", &[\"\\u{300}\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{300}\\u{378}\", &[\"\\u{300}\", \"\\u{378}\"]),\n+        (\"\\u{300}\\u{308}\\u{378}\", &[\"\\u{300}\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{903}\\u{20}\", &[\"\\u{903}\", \"\\u{20}\"]),\n+        (\"\\u{903}\\u{308}\\u{20}\", &[\"\\u{903}\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{903}\\u{D}\", &[\"\\u{903}\", \"\\u{D}\"]),\n+        (\"\\u{903}\\u{308}\\u{D}\", &[\"\\u{903}\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{903}\\u{A}\", &[\"\\u{903}\", \"\\u{A}\"]),\n+        (\"\\u{903}\\u{308}\\u{A}\", &[\"\\u{903}\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{903}\\u{1}\", &[\"\\u{903}\", \"\\u{1}\"]),\n+        (\"\\u{903}\\u{308}\\u{1}\", &[\"\\u{903}\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{903}\\u{300}\", &[\"\\u{903}\\u{300}\"]),\n+        (\"\\u{903}\\u{308}\\u{300}\", &[\"\\u{903}\\u{308}\\u{300}\"]),\n+        (\"\\u{903}\\u{1100}\", &[\"\\u{903}\", \"\\u{1100}\"]),\n+        (\"\\u{903}\\u{308}\\u{1100}\", &[\"\\u{903}\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{903}\\u{1160}\", &[\"\\u{903}\", \"\\u{1160}\"]),\n+        (\"\\u{903}\\u{308}\\u{1160}\", &[\"\\u{903}\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{903}\\u{11A8}\", &[\"\\u{903}\", \"\\u{11A8}\"]),\n+        (\"\\u{903}\\u{308}\\u{11A8}\", &[\"\\u{903}\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{903}\\u{AC00}\", &[\"\\u{903}\", \"\\u{AC00}\"]),\n+        (\"\\u{903}\\u{308}\\u{AC00}\", &[\"\\u{903}\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{903}\\u{AC01}\", &[\"\\u{903}\", \"\\u{AC01}\"]),\n+        (\"\\u{903}\\u{308}\\u{AC01}\", &[\"\\u{903}\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{903}\\u{1F1E6}\", &[\"\\u{903}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{903}\\u{308}\\u{1F1E6}\", &[\"\\u{903}\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{903}\\u{378}\", &[\"\\u{903}\", \"\\u{378}\"]),\n+        (\"\\u{903}\\u{308}\\u{378}\", &[\"\\u{903}\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{1100}\\u{20}\", &[\"\\u{1100}\", \"\\u{20}\"]),\n+        (\"\\u{1100}\\u{308}\\u{20}\", &[\"\\u{1100}\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{1100}\\u{D}\", &[\"\\u{1100}\", \"\\u{D}\"]),\n+        (\"\\u{1100}\\u{308}\\u{D}\", &[\"\\u{1100}\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{1100}\\u{A}\", &[\"\\u{1100}\", \"\\u{A}\"]),\n+        (\"\\u{1100}\\u{308}\\u{A}\", &[\"\\u{1100}\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{1100}\\u{1}\", &[\"\\u{1100}\", \"\\u{1}\"]),\n+        (\"\\u{1100}\\u{308}\\u{1}\", &[\"\\u{1100}\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{1100}\\u{300}\", &[\"\\u{1100}\\u{300}\"]),\n+        (\"\\u{1100}\\u{308}\\u{300}\", &[\"\\u{1100}\\u{308}\\u{300}\"]),\n+        (\"\\u{1100}\\u{1100}\", &[\"\\u{1100}\\u{1100}\"]),\n+        (\"\\u{1100}\\u{308}\\u{1100}\", &[\"\\u{1100}\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{1100}\\u{1160}\", &[\"\\u{1100}\\u{1160}\"]),\n+        (\"\\u{1100}\\u{308}\\u{1160}\", &[\"\\u{1100}\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{1100}\\u{11A8}\", &[\"\\u{1100}\", \"\\u{11A8}\"]),\n+        (\"\\u{1100}\\u{308}\\u{11A8}\", &[\"\\u{1100}\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{1100}\\u{AC00}\", &[\"\\u{1100}\\u{AC00}\"]),\n+        (\"\\u{1100}\\u{308}\\u{AC00}\", &[\"\\u{1100}\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{1100}\\u{AC01}\", &[\"\\u{1100}\\u{AC01}\"]),\n+        (\"\\u{1100}\\u{308}\\u{AC01}\", &[\"\\u{1100}\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{1100}\\u{1F1E6}\", &[\"\\u{1100}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{1100}\\u{308}\\u{1F1E6}\", &[\"\\u{1100}\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{1100}\\u{378}\", &[\"\\u{1100}\", \"\\u{378}\"]),\n+        (\"\\u{1100}\\u{308}\\u{378}\", &[\"\\u{1100}\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{1160}\\u{20}\", &[\"\\u{1160}\", \"\\u{20}\"]),\n+        (\"\\u{1160}\\u{308}\\u{20}\", &[\"\\u{1160}\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{1160}\\u{D}\", &[\"\\u{1160}\", \"\\u{D}\"]),\n+        (\"\\u{1160}\\u{308}\\u{D}\", &[\"\\u{1160}\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{1160}\\u{A}\", &[\"\\u{1160}\", \"\\u{A}\"]),\n+        (\"\\u{1160}\\u{308}\\u{A}\", &[\"\\u{1160}\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{1160}\\u{1}\", &[\"\\u{1160}\", \"\\u{1}\"]),\n+        (\"\\u{1160}\\u{308}\\u{1}\", &[\"\\u{1160}\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{1160}\\u{300}\", &[\"\\u{1160}\\u{300}\"]),\n+        (\"\\u{1160}\\u{308}\\u{300}\", &[\"\\u{1160}\\u{308}\\u{300}\"]),\n+        (\"\\u{1160}\\u{1100}\", &[\"\\u{1160}\", \"\\u{1100}\"]),\n+        (\"\\u{1160}\\u{308}\\u{1100}\", &[\"\\u{1160}\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{1160}\\u{1160}\", &[\"\\u{1160}\\u{1160}\"]),\n+        (\"\\u{1160}\\u{308}\\u{1160}\", &[\"\\u{1160}\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{1160}\\u{11A8}\", &[\"\\u{1160}\\u{11A8}\"]),\n+        (\"\\u{1160}\\u{308}\\u{11A8}\", &[\"\\u{1160}\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{1160}\\u{AC00}\", &[\"\\u{1160}\", \"\\u{AC00}\"]),\n+        (\"\\u{1160}\\u{308}\\u{AC00}\", &[\"\\u{1160}\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{1160}\\u{AC01}\", &[\"\\u{1160}\", \"\\u{AC01}\"]),\n+        (\"\\u{1160}\\u{308}\\u{AC01}\", &[\"\\u{1160}\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{1160}\\u{1F1E6}\", &[\"\\u{1160}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{1160}\\u{308}\\u{1F1E6}\", &[\"\\u{1160}\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{1160}\\u{378}\", &[\"\\u{1160}\", \"\\u{378}\"]),\n+        (\"\\u{1160}\\u{308}\\u{378}\", &[\"\\u{1160}\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{11A8}\\u{20}\", &[\"\\u{11A8}\", \"\\u{20}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{20}\", &[\"\\u{11A8}\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{11A8}\\u{D}\", &[\"\\u{11A8}\", \"\\u{D}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{D}\", &[\"\\u{11A8}\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{11A8}\\u{A}\", &[\"\\u{11A8}\", \"\\u{A}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{A}\", &[\"\\u{11A8}\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{11A8}\\u{1}\", &[\"\\u{11A8}\", \"\\u{1}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{1}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{11A8}\\u{300}\", &[\"\\u{11A8}\\u{300}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{300}\", &[\"\\u{11A8}\\u{308}\\u{300}\"]),\n+        (\"\\u{11A8}\\u{1100}\", &[\"\\u{11A8}\", \"\\u{1100}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{1100}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{11A8}\\u{1160}\", &[\"\\u{11A8}\", \"\\u{1160}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{1160}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{11A8}\\u{11A8}\", &[\"\\u{11A8}\\u{11A8}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{11A8}\", &[\"\\u{11A8}\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{11A8}\\u{AC00}\", &[\"\\u{11A8}\", \"\\u{AC00}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{AC00}\", &[\"\\u{11A8}\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{11A8}\\u{AC01}\", &[\"\\u{11A8}\", \"\\u{AC01}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{AC01}\", &[\"\\u{11A8}\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{11A8}\\u{1F1E6}\", &[\"\\u{11A8}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{1F1E6}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{11A8}\\u{378}\", &[\"\\u{11A8}\", \"\\u{378}\"]),\n+        (\"\\u{11A8}\\u{308}\\u{378}\", &[\"\\u{11A8}\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{AC00}\\u{20}\", &[\"\\u{AC00}\", \"\\u{20}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{20}\", &[\"\\u{AC00}\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{AC00}\\u{D}\", &[\"\\u{AC00}\", \"\\u{D}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{D}\", &[\"\\u{AC00}\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{AC00}\\u{A}\", &[\"\\u{AC00}\", \"\\u{A}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{A}\", &[\"\\u{AC00}\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{AC00}\\u{1}\", &[\"\\u{AC00}\", \"\\u{1}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{1}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{AC00}\\u{300}\", &[\"\\u{AC00}\\u{300}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{300}\", &[\"\\u{AC00}\\u{308}\\u{300}\"]),\n+        (\"\\u{AC00}\\u{1100}\", &[\"\\u{AC00}\", \"\\u{1100}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{1100}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{AC00}\\u{1160}\", &[\"\\u{AC00}\\u{1160}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{1160}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{AC00}\\u{11A8}\", &[\"\\u{AC00}\\u{11A8}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{11A8}\", &[\"\\u{AC00}\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{AC00}\\u{AC00}\", &[\"\\u{AC00}\", \"\\u{AC00}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{AC00}\", &[\"\\u{AC00}\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{AC00}\\u{AC01}\", &[\"\\u{AC00}\", \"\\u{AC01}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{AC01}\", &[\"\\u{AC00}\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{AC00}\\u{1F1E6}\", &[\"\\u{AC00}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{1F1E6}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{AC00}\\u{378}\", &[\"\\u{AC00}\", \"\\u{378}\"]),\n+        (\"\\u{AC00}\\u{308}\\u{378}\", &[\"\\u{AC00}\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{AC01}\\u{20}\", &[\"\\u{AC01}\", \"\\u{20}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{20}\", &[\"\\u{AC01}\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{AC01}\\u{D}\", &[\"\\u{AC01}\", \"\\u{D}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{D}\", &[\"\\u{AC01}\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{AC01}\\u{A}\", &[\"\\u{AC01}\", \"\\u{A}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{A}\", &[\"\\u{AC01}\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{AC01}\\u{1}\", &[\"\\u{AC01}\", \"\\u{1}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{1}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{AC01}\\u{300}\", &[\"\\u{AC01}\\u{300}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{300}\", &[\"\\u{AC01}\\u{308}\\u{300}\"]),\n+        (\"\\u{AC01}\\u{1100}\", &[\"\\u{AC01}\", \"\\u{1100}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{1100}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{AC01}\\u{1160}\", &[\"\\u{AC01}\", \"\\u{1160}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{1160}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{AC01}\\u{11A8}\", &[\"\\u{AC01}\\u{11A8}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{11A8}\", &[\"\\u{AC01}\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{AC01}\\u{AC00}\", &[\"\\u{AC01}\", \"\\u{AC00}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{AC00}\", &[\"\\u{AC01}\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{AC01}\\u{AC01}\", &[\"\\u{AC01}\", \"\\u{AC01}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{AC01}\", &[\"\\u{AC01}\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{AC01}\\u{1F1E6}\", &[\"\\u{AC01}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{1F1E6}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{AC01}\\u{378}\", &[\"\\u{AC01}\", \"\\u{378}\"]),\n+        (\"\\u{AC01}\\u{308}\\u{378}\", &[\"\\u{AC01}\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{1F1E6}\\u{20}\", &[\"\\u{1F1E6}\", \"\\u{20}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{20}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{1F1E6}\\u{D}\", &[\"\\u{1F1E6}\", \"\\u{D}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{D}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{1F1E6}\\u{A}\", &[\"\\u{1F1E6}\", \"\\u{A}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{A}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{1F1E6}\\u{1}\", &[\"\\u{1F1E6}\", \"\\u{1}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{1}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{1F1E6}\\u{300}\", &[\"\\u{1F1E6}\\u{300}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{300}\", &[\"\\u{1F1E6}\\u{308}\\u{300}\"]),\n+        (\"\\u{1F1E6}\\u{1100}\", &[\"\\u{1F1E6}\", \"\\u{1100}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{1100}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{1F1E6}\\u{1160}\", &[\"\\u{1F1E6}\", \"\\u{1160}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{1160}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{1F1E6}\\u{11A8}\", &[\"\\u{1F1E6}\", \"\\u{11A8}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{11A8}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{1F1E6}\\u{AC00}\", &[\"\\u{1F1E6}\", \"\\u{AC00}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{AC00}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{1F1E6}\\u{AC01}\", &[\"\\u{1F1E6}\", \"\\u{AC01}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{AC01}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{1F1E6}\\u{1F1E6}\", &[\"\\u{1F1E6}\\u{1F1E6}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{1F1E6}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{1F1E6}\\u{378}\", &[\"\\u{1F1E6}\", \"\\u{378}\"]),\n+        (\"\\u{1F1E6}\\u{308}\\u{378}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{378}\\u{20}\", &[\"\\u{378}\", \"\\u{20}\"]),\n+        (\"\\u{378}\\u{308}\\u{20}\", &[\"\\u{378}\\u{308}\", \"\\u{20}\"]),\n+        (\"\\u{378}\\u{D}\", &[\"\\u{378}\", \"\\u{D}\"]),\n+        (\"\\u{378}\\u{308}\\u{D}\", &[\"\\u{378}\\u{308}\", \"\\u{D}\"]),\n+        (\"\\u{378}\\u{A}\", &[\"\\u{378}\", \"\\u{A}\"]),\n+        (\"\\u{378}\\u{308}\\u{A}\", &[\"\\u{378}\\u{308}\", \"\\u{A}\"]),\n+        (\"\\u{378}\\u{1}\", &[\"\\u{378}\", \"\\u{1}\"]),\n+        (\"\\u{378}\\u{308}\\u{1}\", &[\"\\u{378}\\u{308}\", \"\\u{1}\"]),\n+        (\"\\u{378}\\u{300}\", &[\"\\u{378}\\u{300}\"]),\n+        (\"\\u{378}\\u{308}\\u{300}\", &[\"\\u{378}\\u{308}\\u{300}\"]),\n+        (\"\\u{378}\\u{1100}\", &[\"\\u{378}\", \"\\u{1100}\"]),\n+        (\"\\u{378}\\u{308}\\u{1100}\", &[\"\\u{378}\\u{308}\", \"\\u{1100}\"]),\n+        (\"\\u{378}\\u{1160}\", &[\"\\u{378}\", \"\\u{1160}\"]),\n+        (\"\\u{378}\\u{308}\\u{1160}\", &[\"\\u{378}\\u{308}\", \"\\u{1160}\"]),\n+        (\"\\u{378}\\u{11A8}\", &[\"\\u{378}\", \"\\u{11A8}\"]),\n+        (\"\\u{378}\\u{308}\\u{11A8}\", &[\"\\u{378}\\u{308}\", \"\\u{11A8}\"]),\n+        (\"\\u{378}\\u{AC00}\", &[\"\\u{378}\", \"\\u{AC00}\"]),\n+        (\"\\u{378}\\u{308}\\u{AC00}\", &[\"\\u{378}\\u{308}\", \"\\u{AC00}\"]),\n+        (\"\\u{378}\\u{AC01}\", &[\"\\u{378}\", \"\\u{AC01}\"]),\n+        (\"\\u{378}\\u{308}\\u{AC01}\", &[\"\\u{378}\\u{308}\", \"\\u{AC01}\"]),\n+        (\"\\u{378}\\u{1F1E6}\", &[\"\\u{378}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{378}\\u{308}\\u{1F1E6}\", &[\"\\u{378}\\u{308}\", \"\\u{1F1E6}\"]),\n+        (\"\\u{378}\\u{378}\", &[\"\\u{378}\", \"\\u{378}\"]),\n+        (\"\\u{378}\\u{308}\\u{378}\", &[\"\\u{378}\\u{308}\", \"\\u{378}\"]),\n+        (\"\\u{61}\\u{1F1E6}\\u{62}\", &[\"\\u{61}\", \"\\u{1F1E6}\", \"\\u{62}\"]),\n+        (\"\\u{1F1F7}\\u{1F1FA}\", &[\"\\u{1F1F7}\\u{1F1FA}\"]),\n+        (\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\", &[\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\"]),\n+        (\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\\u{1F1EA}\",\n+        &[\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\\u{1F1EA}\"]),\n+        (\"\\u{1F1F7}\\u{1F1FA}\\u{200B}\\u{1F1F8}\\u{1F1EA}\",\n+         &[\"\\u{1F1F7}\\u{1F1FA}\", \"\\u{200B}\", \"\\u{1F1F8}\\u{1F1EA}\"]),\n+        (\"\\u{1F1E6}\\u{1F1E7}\\u{1F1E8}\", &[\"\\u{1F1E6}\\u{1F1E7}\\u{1F1E8}\"]),\n+        (\"\\u{1F1E6}\\u{200D}\\u{1F1E7}\\u{1F1E8}\", &[\"\\u{1F1E6}\\u{200D}\",\n+         \"\\u{1F1E7}\\u{1F1E8}\"]),\n+        (\"\\u{1F1E6}\\u{1F1E7}\\u{200D}\\u{1F1E8}\",\n+         &[\"\\u{1F1E6}\\u{1F1E7}\\u{200D}\", \"\\u{1F1E8}\"]),\n+        (\"\\u{20}\\u{200D}\\u{646}\", &[\"\\u{20}\\u{200D}\", \"\\u{646}\"]),\n+        (\"\\u{646}\\u{200D}\\u{20}\", &[\"\\u{646}\\u{200D}\", \"\\u{20}\"]),\n+    ];\n+\n+    let test_diff: [(_, &[_], &[_]); 23] = [\n+        (\"\\u{20}\\u{903}\", &[\"\\u{20}\\u{903}\"], &[\"\\u{20}\", \"\\u{903}\"]), (\"\\u{20}\\u{308}\\u{903}\",\n+        &[\"\\u{20}\\u{308}\\u{903}\"], &[\"\\u{20}\\u{308}\", \"\\u{903}\"]), (\"\\u{D}\\u{308}\\u{903}\",\n+        &[\"\\u{D}\", \"\\u{308}\\u{903}\"], &[\"\\u{D}\", \"\\u{308}\", \"\\u{903}\"]), (\"\\u{A}\\u{308}\\u{903}\",\n+        &[\"\\u{A}\", \"\\u{308}\\u{903}\"], &[\"\\u{A}\", \"\\u{308}\", \"\\u{903}\"]), (\"\\u{1}\\u{308}\\u{903}\",\n+        &[\"\\u{1}\", \"\\u{308}\\u{903}\"], &[\"\\u{1}\", \"\\u{308}\", \"\\u{903}\"]), (\"\\u{300}\\u{903}\",\n+        &[\"\\u{300}\\u{903}\"], &[\"\\u{300}\", \"\\u{903}\"]), (\"\\u{300}\\u{308}\\u{903}\",\n+        &[\"\\u{300}\\u{308}\\u{903}\"], &[\"\\u{300}\\u{308}\", \"\\u{903}\"]), (\"\\u{903}\\u{903}\",\n+        &[\"\\u{903}\\u{903}\"], &[\"\\u{903}\", \"\\u{903}\"]), (\"\\u{903}\\u{308}\\u{903}\",\n+        &[\"\\u{903}\\u{308}\\u{903}\"], &[\"\\u{903}\\u{308}\", \"\\u{903}\"]), (\"\\u{1100}\\u{903}\",\n+        &[\"\\u{1100}\\u{903}\"], &[\"\\u{1100}\", \"\\u{903}\"]), (\"\\u{1100}\\u{308}\\u{903}\",\n+        &[\"\\u{1100}\\u{308}\\u{903}\"], &[\"\\u{1100}\\u{308}\", \"\\u{903}\"]), (\"\\u{1160}\\u{903}\",\n+        &[\"\\u{1160}\\u{903}\"], &[\"\\u{1160}\", \"\\u{903}\"]), (\"\\u{1160}\\u{308}\\u{903}\",\n+        &[\"\\u{1160}\\u{308}\\u{903}\"], &[\"\\u{1160}\\u{308}\", \"\\u{903}\"]), (\"\\u{11A8}\\u{903}\",\n+        &[\"\\u{11A8}\\u{903}\"], &[\"\\u{11A8}\", \"\\u{903}\"]), (\"\\u{11A8}\\u{308}\\u{903}\",\n+        &[\"\\u{11A8}\\u{308}\\u{903}\"], &[\"\\u{11A8}\\u{308}\", \"\\u{903}\"]), (\"\\u{AC00}\\u{903}\",\n+        &[\"\\u{AC00}\\u{903}\"], &[\"\\u{AC00}\", \"\\u{903}\"]), (\"\\u{AC00}\\u{308}\\u{903}\",\n+        &[\"\\u{AC00}\\u{308}\\u{903}\"], &[\"\\u{AC00}\\u{308}\", \"\\u{903}\"]), (\"\\u{AC01}\\u{903}\",\n+        &[\"\\u{AC01}\\u{903}\"], &[\"\\u{AC01}\", \"\\u{903}\"]), (\"\\u{AC01}\\u{308}\\u{903}\",\n+        &[\"\\u{AC01}\\u{308}\\u{903}\"], &[\"\\u{AC01}\\u{308}\", \"\\u{903}\"]), (\"\\u{1F1E6}\\u{903}\",\n+        &[\"\\u{1F1E6}\\u{903}\"], &[\"\\u{1F1E6}\", \"\\u{903}\"]), (\"\\u{1F1E6}\\u{308}\\u{903}\",\n+        &[\"\\u{1F1E6}\\u{308}\\u{903}\"], &[\"\\u{1F1E6}\\u{308}\", \"\\u{903}\"]), (\"\\u{378}\\u{903}\",\n+        &[\"\\u{378}\\u{903}\"], &[\"\\u{378}\", \"\\u{903}\"]), (\"\\u{378}\\u{308}\\u{903}\",\n+        &[\"\\u{378}\\u{308}\\u{903}\"], &[\"\\u{378}\\u{308}\", \"\\u{903}\"]),\n+    ];\n+\n+    for &(s, g) in &test_same[..] {\n+        // test forward iterator\n+        assert!(order::equals(s.graphemes(true), g.iter().cloned()));\n+        assert!(order::equals(s.graphemes(false), g.iter().cloned()));\n+\n+        // test reverse iterator\n+        assert!(order::equals(s.graphemes(true).rev(), g.iter().rev().cloned()));\n+        assert!(order::equals(s.graphemes(false).rev(), g.iter().rev().cloned()));\n+    }\n+\n+    for &(s, gt, gf) in &test_diff {\n+        // test forward iterator\n+        assert!(order::equals(s.graphemes(true), gt.iter().cloned()));\n+        assert!(order::equals(s.graphemes(false), gf.iter().cloned()));\n+\n+        // test reverse iterator\n+        assert!(order::equals(s.graphemes(true).rev(), gt.iter().rev().cloned()));\n+        assert!(order::equals(s.graphemes(false).rev(), gf.iter().rev().cloned()));\n+    }\n+\n+    // test the indices iterators\n+    let s = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n+    let gr_inds = s.grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n+    let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+    assert_eq!(gr_inds, b);\n+    let gr_inds = s.grapheme_indices(true).rev().collect::<Vec<(usize, &str)>>();\n+    let b: &[_] = &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0, \"a\u0310\")];\n+    assert_eq!(gr_inds, b);\n+    let mut gr_inds_iter = s.grapheme_indices(true);\n+    {\n+        let gr_inds = gr_inds_iter.by_ref();\n+        let e1 = gr_inds.size_hint();\n+        assert_eq!(e1, (1, Some(13)));\n+        let c = gr_inds.count();\n+        assert_eq!(c, 4);\n+    }\n+    let e2 = gr_inds_iter.size_hint();\n+    assert_eq!(e2, (0, Some(0)));\n+\n+    // make sure the reverse iterator does the right thing with \"\\n\" at beginning of string\n+    let s = \"\\n\\r\\n\\r\";\n+    let gr = s.graphemes(true).rev().collect::<Vec<&str>>();\n+    let b: &[_] = &[\"\\r\", \"\\r\\n\", \"\\n\"];\n+    assert_eq!(gr, b);\n+}\n+\n+#[test]\n+fn test_split_strator() {\n+    fn t(s: &str, sep: &str, u: &[&str]) {\n+        let v: Vec<&str> = s.split_str(sep).collect();\n+        assert_eq!(v, u);\n+    }\n+    t(\"--1233345--\", \"12345\", &[\"--1233345--\"]);\n+    t(\"abc::hello::there\", \"::\", &[\"abc\", \"hello\", \"there\"]);\n+    t(\"::hello::there\", \"::\", &[\"\", \"hello\", \"there\"]);\n+    t(\"hello::there::\", \"::\", &[\"hello\", \"there\", \"\"]);\n+    t(\"::hello::there::\", \"::\", &[\"\", \"hello\", \"there\", \"\"]);\n+    t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", &[\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]);\n+    t(\"zzXXXzzYYYzz\", \"zz\", &[\"\", \"XXX\", \"YYY\", \"\"]);\n+    t(\"zzXXXzYYYz\", \"XXX\", &[\"zz\", \"zYYYz\"]);\n+    t(\".XXX.YYY.\", \".\", &[\"\", \"XXX\", \"YYY\", \"\"]);\n+    t(\"\", \".\", &[\"\"]);\n+    t(\"zz\", \"zz\", &[\"\",\"\"]);\n+    t(\"ok\", \"z\", &[\"ok\"]);\n+    t(\"zzz\", \"zz\", &[\"\",\"z\"]);\n+    t(\"zzzzz\", \"zz\", &[\"\",\"\",\"z\"]);\n+}\n+\n+#[test]\n+fn test_str_default() {\n+    use std::default::Default;\n+\n+    fn t<S: Default + Str>() {\n+        let s: S = Default::default();\n+        assert_eq!(s.as_slice(), \"\");\n+    }\n+\n+    t::<&str>();\n+    t::<String>();\n+}\n+\n+#[test]\n+fn test_str_container() {\n+    fn sum_len(v: &[&str]) -> usize {\n+        v.iter().map(|x| x.len()).sum()\n+    }\n+\n+    let s = String::from_str(\"01234\");\n+    assert_eq!(5, sum_len(&[\"012\", \"\", \"34\"]));\n+    assert_eq!(5, sum_len(&[&String::from_str(\"01\"),\n+                            &String::from_str(\"2\"),\n+                            &String::from_str(\"34\"),\n+                            &String::from_str(\"\")]));\n+    assert_eq!(5, sum_len(&[&s]));\n+}\n+\n+#[test]\n+fn test_str_from_utf8() {\n+    let xs = b\"hello\";\n+    assert_eq!(from_utf8(xs), Ok(\"hello\"));\n+\n+    let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n+    assert_eq!(from_utf8(xs), Ok(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+\n+    let xs = b\"hello\\xFF\";\n+    assert_eq!(from_utf8(xs), Err(Utf8Error::TooShort));\n+}\n+\n+mod bench {\n+    use test::{Bencher, black_box};\n+\n+    #[bench]\n+    fn char_iterator(b: &mut Bencher) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+        b.iter(|| s.chars().count());\n+    }\n+\n+    #[bench]\n+    fn char_iterator_for(b: &mut Bencher) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+        b.iter(|| {\n+            for ch in s.chars() { black_box(ch); }\n+        });\n+    }\n+\n+    #[bench]\n+    fn char_iterator_ascii(b: &mut Bencher) {\n+        let s = \"Mary had a little lamb, Little lamb\n+        Mary had a little lamb, Little lamb\n+        Mary had a little lamb, Little lamb\n+        Mary had a little lamb, Little lamb\n+        Mary had a little lamb, Little lamb\n+        Mary had a little lamb, Little lamb\";\n+\n+        b.iter(|| s.chars().count());\n+    }\n+\n+    #[bench]\n+    fn char_iterator_rev(b: &mut Bencher) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+        b.iter(|| s.chars().rev().count());\n+    }\n+\n+    #[bench]\n+    fn char_iterator_rev_for(b: &mut Bencher) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+        b.iter(|| {\n+            for ch in s.chars().rev() { black_box(ch); }\n+        });\n+    }\n+\n+    #[bench]\n+    fn char_indicesator(b: &mut Bencher) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        let len = s.chars().count();\n+\n+        b.iter(|| assert_eq!(s.char_indices().count(), len));\n+    }\n+\n+    #[bench]\n+    fn char_indicesator_rev(b: &mut Bencher) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        let len = s.chars().count();\n+\n+        b.iter(|| assert_eq!(s.char_indices().rev().count(), len));\n+    }\n+\n+    #[bench]\n+    fn split_unicode_ascii(b: &mut Bencher) {\n+        let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+\n+        b.iter(|| assert_eq!(s.split('V').count(), 3));\n+    }\n+\n+    #[bench]\n+    fn split_ascii(b: &mut Bencher) {\n+        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+        let len = s.split(' ').count();\n+\n+        b.iter(|| assert_eq!(s.split(' ').count(), len));\n+    }\n+\n+    #[bench]\n+    fn split_extern_fn(b: &mut Bencher) {\n+        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+        let len = s.split(' ').count();\n+        fn pred(c: char) -> bool { c == ' ' }\n+\n+        b.iter(|| assert_eq!(s.split(pred).count(), len));\n+    }\n+\n+    #[bench]\n+    fn split_closure(b: &mut Bencher) {\n+        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+        let len = s.split(' ').count();\n+\n+        b.iter(|| assert_eq!(s.split(|c: char| c == ' ').count(), len));\n+    }\n+\n+    #[bench]\n+    fn split_slice(b: &mut Bencher) {\n+        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+        let len = s.split(' ').count();\n+\n+        let c: &[char] = &[' '];\n+        b.iter(|| assert_eq!(s.split(c).count(), len));\n+    }\n+\n+    #[bench]\n+    fn bench_connect(b: &mut Bencher) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        let sep = \"\u2192\";\n+        let v = vec![s, s, s, s, s, s, s, s, s, s];\n+        b.iter(|| {\n+            assert_eq!(v.connect(sep).len(), s.len() * 10 + sep.len() * 9);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_contains_short_short(b: &mut Bencher) {\n+        let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+        let needle = \"sit\";\n+\n+        b.iter(|| {\n+            assert!(haystack.contains(needle));\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_contains_short_long(b: &mut Bencher) {\n+        let haystack = \"\\\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n+ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n+eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n+sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n+tempus vel, gravida nec quam.\n+\n+In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n+sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n+diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n+lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n+eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n+interdum. Curabitur ut nisi justo.\n+\n+Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n+mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n+lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n+est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n+felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n+ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n+feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n+Aliquam sit amet placerat lorem.\n+\n+Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n+mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n+Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n+lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n+suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n+cursus accumsan.\n+\n+Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n+feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n+vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n+leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n+malesuada sollicitudin quam eu fermentum.\";\n+        let needle = \"english\";\n+\n+        b.iter(|| {\n+            assert!(!haystack.contains(needle));\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_contains_bad_naive(b: &mut Bencher) {\n+        let haystack = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n+        let needle = \"aaaaaaaab\";\n+\n+        b.iter(|| {\n+            assert!(!haystack.contains(needle));\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_contains_equal(b: &mut Bencher) {\n+        let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+        let needle = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+\n+        b.iter(|| {\n+            assert!(haystack.contains(needle));\n+        })\n+    }\n+}"}, {"sha": "4768d5e92ac30057643b6b680edd322e05f6beff", "filename": "src/libcollectionstest/string.rs", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,453 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::borrow::IntoCow;\n+use std::iter::repeat;\n+use std::str::Utf8Error;\n+use std::string::{CowString, as_string};\n+\n+use test::Bencher;\n+\n+#[test]\n+fn test_as_string() {\n+    let x = \"foo\";\n+    assert_eq!(x, &**as_string(x));\n+}\n+\n+#[test]\n+fn test_from_str() {\n+  let owned: Option<::std::string::String> = \"string\".parse().ok();\n+  assert_eq!(owned.as_ref().map(|s| &**s), Some(\"string\"));\n+}\n+\n+#[test]\n+fn test_unsized_to_string() {\n+    let s: &str = \"abc\";\n+    let _: String = (*s).to_string();\n+}\n+\n+#[test]\n+fn test_from_utf8() {\n+    let xs = b\"hello\".to_vec();\n+    assert_eq!(String::from_utf8(xs).unwrap(),\n+               String::from_str(\"hello\"));\n+\n+    let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes().to_vec();\n+    assert_eq!(String::from_utf8(xs).unwrap(),\n+               String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+\n+    let xs = b\"hello\\xFF\".to_vec();\n+    let err = String::from_utf8(xs).err().unwrap();\n+    assert_eq!(err.utf8_error(), Utf8Error::TooShort);\n+    assert_eq!(err.into_bytes(), b\"hello\\xff\".to_vec());\n+}\n+\n+#[test]\n+fn test_from_utf8_lossy() {\n+    let xs = b\"hello\";\n+    let ys: CowString = \"hello\".into_cow();\n+    assert_eq!(String::from_utf8_lossy(xs), ys);\n+\n+    let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n+    let ys: CowString = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow();\n+    assert_eq!(String::from_utf8_lossy(xs), ys);\n+\n+    let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n+    assert_eq!(String::from_utf8_lossy(xs),\n+               String::from_str(\"Hello\\u{FFFD} There\\u{FFFD} Goodbye\").into_cow());\n+\n+    let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n+    assert_eq!(String::from_utf8_lossy(xs),\n+               String::from_str(\"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\").into_cow());\n+\n+    let xs = b\"\\xF5foo\\xF5\\x80bar\";\n+    assert_eq!(String::from_utf8_lossy(xs),\n+               String::from_str(\"\\u{FFFD}foo\\u{FFFD}\\u{FFFD}bar\").into_cow());\n+\n+    let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n+    assert_eq!(String::from_utf8_lossy(xs),\n+               String::from_str(\"\\u{FFFD}foo\\u{FFFD}bar\\u{FFFD}baz\").into_cow());\n+\n+    let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n+    assert_eq!(String::from_utf8_lossy(xs),\n+               String::from_str(\"\\u{FFFD}foo\\u{FFFD}bar\\u{FFFD}\\u{FFFD}baz\").into_cow());\n+\n+    let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n+    assert_eq!(String::from_utf8_lossy(xs), String::from_str(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}\\u{FFFD}\\\n+                                           foo\\u{10000}bar\").into_cow());\n+\n+    // surrogates\n+    let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n+    assert_eq!(String::from_utf8_lossy(xs), String::from_str(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}foo\\\n+                                           \\u{FFFD}\\u{FFFD}\\u{FFFD}bar\").into_cow());\n+}\n+\n+#[test]\n+fn test_from_utf16() {\n+    let pairs =\n+        [(String::from_str(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\"),\n+          vec![0xd800, 0xdf45, 0xd800, 0xdf3f,\n+            0xd800, 0xdf3b, 0xd800, 0xdf46,\n+            0xd800, 0xdf39, 0xd800, 0xdf3b,\n+            0xd800, 0xdf30, 0x000a]),\n+\n+         (String::from_str(\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\"),\n+          vec![0xd801, 0xdc12, 0xd801,\n+            0xdc49, 0xd801, 0xdc2e, 0xd801,\n+            0xdc40, 0xd801, 0xdc32, 0xd801,\n+            0xdc4b, 0x0020, 0xd801, 0xdc0f,\n+            0xd801, 0xdc32, 0xd801, 0xdc4d,\n+            0x000a]),\n+\n+         (String::from_str(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\"),\n+          vec![0xd800, 0xdf00, 0xd800, 0xdf16,\n+            0xd800, 0xdf0b, 0xd800, 0xdf04,\n+            0xd800, 0xdf11, 0xd800, 0xdf09,\n+            0x00b7, 0xd800, 0xdf0c, 0xd800,\n+            0xdf04, 0xd800, 0xdf15, 0xd800,\n+            0xdf04, 0xd800, 0xdf0b, 0xd800,\n+            0xdf09, 0xd800, 0xdf11, 0x000a ]),\n+\n+         (String::from_str(\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\"),\n+          vec![0xd801, 0xdc8b, 0xd801, 0xdc98,\n+            0xd801, 0xdc88, 0xd801, 0xdc91,\n+            0xd801, 0xdc9b, 0xd801, 0xdc92,\n+            0x0020, 0xd801, 0xdc95, 0xd801,\n+            0xdc93, 0x0020, 0xd801, 0xdc88,\n+            0xd801, 0xdc9a, 0xd801, 0xdc8d,\n+            0x0020, 0xd801, 0xdc8f, 0xd801,\n+            0xdc9c, 0xd801, 0xdc92, 0xd801,\n+            0xdc96, 0xd801, 0xdc86, 0x0020,\n+            0xd801, 0xdc95, 0xd801, 0xdc86,\n+            0x000a ]),\n+         // Issue #12318, even-numbered non-BMP planes\n+         (String::from_str(\"\\u{20000}\"),\n+          vec![0xD840, 0xDC00])];\n+\n+    for p in &pairs {\n+        let (s, u) = (*p).clone();\n+        let s_as_utf16 = s.utf16_units().collect::<Vec<u16>>();\n+        let u_as_string = String::from_utf16(&u).unwrap();\n+\n+        assert!(::unicode::str::is_utf16(&u));\n+        assert_eq!(s_as_utf16, u);\n+\n+        assert_eq!(u_as_string, s);\n+        assert_eq!(String::from_utf16_lossy(&u), s);\n+\n+        assert_eq!(String::from_utf16(&s_as_utf16).unwrap(), s);\n+        assert_eq!(u_as_string.utf16_units().collect::<Vec<u16>>(), u);\n+    }\n+}\n+\n+#[test]\n+fn test_utf16_invalid() {\n+    // completely positive cases tested above.\n+    // lead + eof\n+    assert!(String::from_utf16(&[0xD800]).is_err());\n+    // lead + lead\n+    assert!(String::from_utf16(&[0xD800, 0xD800]).is_err());\n+\n+    // isolated trail\n+    assert!(String::from_utf16(&[0x0061, 0xDC00]).is_err());\n+\n+    // general\n+    assert!(String::from_utf16(&[0xD800, 0xd801, 0xdc8b, 0xD800]).is_err());\n+}\n+\n+#[test]\n+fn test_from_utf16_lossy() {\n+    // completely positive cases tested above.\n+    // lead + eof\n+    assert_eq!(String::from_utf16_lossy(&[0xD800]), String::from_str(\"\\u{FFFD}\"));\n+    // lead + lead\n+    assert_eq!(String::from_utf16_lossy(&[0xD800, 0xD800]),\n+               String::from_str(\"\\u{FFFD}\\u{FFFD}\"));\n+\n+    // isolated trail\n+    assert_eq!(String::from_utf16_lossy(&[0x0061, 0xDC00]), String::from_str(\"a\\u{FFFD}\"));\n+\n+    // general\n+    assert_eq!(String::from_utf16_lossy(&[0xD800, 0xd801, 0xdc8b, 0xD800]),\n+               String::from_str(\"\\u{FFFD}\ud801\udc8b\\u{FFFD}\"));\n+}\n+\n+#[test]\n+fn test_push_bytes() {\n+    let mut s = String::from_str(\"ABC\");\n+    unsafe {\n+        let mv = s.as_mut_vec();\n+        mv.push_all(&[b'D']);\n+    }\n+    assert_eq!(s, \"ABCD\");\n+}\n+\n+#[test]\n+fn test_push_str() {\n+    let mut s = String::new();\n+    s.push_str(\"\");\n+    assert_eq!(&s[0..], \"\");\n+    s.push_str(\"abc\");\n+    assert_eq!(&s[0..], \"abc\");\n+    s.push_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+    assert_eq!(&s[0..], \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+}\n+\n+#[test]\n+fn test_push() {\n+    let mut data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n+    data.push('\u534e');\n+    data.push('b'); // 1 byte\n+    data.push('\u00a2'); // 2 byte\n+    data.push('\u20ac'); // 3 byte\n+    data.push('\ud852\udf62'); // 4 byte\n+    assert_eq!(data, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n+}\n+\n+#[test]\n+fn test_pop() {\n+    let mut data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n+    assert_eq!(data.pop().unwrap(), '\ud852\udf62'); // 4 bytes\n+    assert_eq!(data.pop().unwrap(), '\u20ac'); // 3 bytes\n+    assert_eq!(data.pop().unwrap(), '\u00a2'); // 2 bytes\n+    assert_eq!(data.pop().unwrap(), 'b'); // 1 bytes\n+    assert_eq!(data.pop().unwrap(), '\u534e');\n+    assert_eq!(data, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n+}\n+\n+#[test]\n+fn test_str_truncate() {\n+    let mut s = String::from_str(\"12345\");\n+    s.truncate(5);\n+    assert_eq!(s, \"12345\");\n+    s.truncate(3);\n+    assert_eq!(s, \"123\");\n+    s.truncate(0);\n+    assert_eq!(s, \"\");\n+\n+    let mut s = String::from_str(\"12345\");\n+    let p = s.as_ptr();\n+    s.truncate(3);\n+    s.push_str(\"6\");\n+    let p_ = s.as_ptr();\n+    assert_eq!(p_, p);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_str_truncate_invalid_len() {\n+    let mut s = String::from_str(\"12345\");\n+    s.truncate(6);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_str_truncate_split_codepoint() {\n+    let mut s = String::from_str(\"\\u{FC}\"); // \u00fc\n+    s.truncate(1);\n+}\n+\n+#[test]\n+fn test_str_clear() {\n+    let mut s = String::from_str(\"12345\");\n+    s.clear();\n+    assert_eq!(s.len(), 0);\n+    assert_eq!(s, \"\");\n+}\n+\n+#[test]\n+fn test_str_add() {\n+    let a = String::from_str(\"12345\");\n+    let b = a + \"2\";\n+    let b = b + \"2\";\n+    assert_eq!(b.len(), 7);\n+    assert_eq!(b, \"1234522\");\n+}\n+\n+#[test]\n+fn remove() {\n+    let mut s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\".to_string();;\n+    assert_eq!(s.remove(0), '\u0e28');\n+    assert_eq!(s.len(), 33);\n+    assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n+    assert_eq!(s.remove(17), '\u1ec7');\n+    assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n+}\n+\n+#[test] #[should_panic]\n+fn remove_bad() {\n+    \"\u0e28\".to_string().remove(1);\n+}\n+\n+#[test]\n+fn insert() {\n+    let mut s = \"foobar\".to_string();\n+    s.insert(0, '\u1ec7');\n+    assert_eq!(s, \"\u1ec7foobar\");\n+    s.insert(6, '\u0e22');\n+    assert_eq!(s, \"\u1ec7foo\u0e22bar\");\n+}\n+\n+#[test] #[should_panic] fn insert_bad1() { \"\".to_string().insert(1, 't'); }\n+#[test] #[should_panic] fn insert_bad2() { \"\u1ec7\".to_string().insert(1, 't'); }\n+\n+#[test]\n+fn test_slicing() {\n+    let s = \"foobar\".to_string();\n+    assert_eq!(\"foobar\", &s[..]);\n+    assert_eq!(\"foo\", &s[..3]);\n+    assert_eq!(\"bar\", &s[3..]);\n+    assert_eq!(\"oob\", &s[1..4]);\n+}\n+\n+#[test]\n+fn test_simple_types() {\n+    assert_eq!(1.to_string(), \"1\");\n+    assert_eq!((-1).to_string(), \"-1\");\n+    assert_eq!(200.to_string(), \"200\");\n+    assert_eq!(2.to_string(), \"2\");\n+    assert_eq!(true.to_string(), \"true\");\n+    assert_eq!(false.to_string(), \"false\");\n+    assert_eq!((\"hi\".to_string()).to_string(), \"hi\");\n+}\n+\n+#[test]\n+fn test_vectors() {\n+    let x: Vec<i32> = vec![];\n+    assert_eq!(format!(\"{:?}\", x), \"[]\");\n+    assert_eq!(format!(\"{:?}\", vec![1]), \"[1]\");\n+    assert_eq!(format!(\"{:?}\", vec![1, 2, 3]), \"[1, 2, 3]\");\n+    assert!(format!(\"{:?}\", vec![vec![], vec![1], vec![1, 1]]) ==\n+           \"[[], [1], [1, 1]]\");\n+}\n+\n+#[test]\n+fn test_from_iterator() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_string();\n+    let t = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+    let u = \"Vi\u1ec7t Nam\";\n+\n+    let a: String = s.chars().collect();\n+    assert_eq!(s, a);\n+\n+    let mut b = t.to_string();\n+    b.extend(u.chars());\n+    assert_eq!(s, b);\n+\n+    let c: String = vec![t, u].into_iter().collect();\n+    assert_eq!(s, c);\n+\n+    let mut d = t.to_string();\n+    d.extend(vec![u].into_iter());\n+    assert_eq!(s, d);\n+}\n+\n+#[bench]\n+fn bench_with_capacity(b: &mut Bencher) {\n+    b.iter(|| {\n+        String::with_capacity(100)\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_str(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+    b.iter(|| {\n+        let mut r = String::new();\n+        r.push_str(s);\n+    });\n+}\n+\n+const REPETITIONS: u64 = 10_000;\n+\n+#[bench]\n+fn bench_push_str_one_byte(b: &mut Bencher) {\n+    b.bytes = REPETITIONS;\n+    b.iter(|| {\n+        let mut r = String::new();\n+        for _ in 0..REPETITIONS {\n+            r.push_str(\"a\")\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_char_one_byte(b: &mut Bencher) {\n+    b.bytes = REPETITIONS;\n+    b.iter(|| {\n+        let mut r = String::new();\n+        for _ in 0..REPETITIONS {\n+            r.push('a')\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_char_two_bytes(b: &mut Bencher) {\n+    b.bytes = REPETITIONS * 2;\n+    b.iter(|| {\n+        let mut r = String::new();\n+        for _ in 0..REPETITIONS {\n+            r.push('\u00e2')\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n+    let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n+              Lorem ipsum dolor sit amet, consectetur. \";\n+\n+    assert_eq!(100, s.len());\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(s);\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n+    let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n+    assert_eq!(100, s.len());\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(s);\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_invalid(b: &mut Bencher) {\n+    let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(s);\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n+    let s = repeat(0xf5).take(100).collect::<Vec<_>>();\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(&s);\n+    });\n+}\n+\n+#[bench]\n+fn bench_exact_size_shrink_to_fit(b: &mut Bencher) {\n+    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n+             Lorem ipsum dolor sit amet, consectetur. \";\n+    // ensure our operation produces an exact-size string before we benchmark it\n+    let mut r = String::with_capacity(s.len());\n+    r.push_str(s);\n+    assert_eq!(r.len(), r.capacity());\n+    b.iter(|| {\n+        let mut r = String::with_capacity(s.len());\n+        r.push_str(s);\n+        r.shrink_to_fit();\n+        r\n+    });\n+}"}, {"sha": "2923bea982845e25139c8377ceca3e3d2aa03f6e", "filename": "src/libcollectionstest/vec.rs", "status": "added", "additions": 994, "deletions": 0, "changes": 994, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,994 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter::{FromIterator, repeat};\n+use std::mem::size_of;\n+use std::vec::as_vec;\n+\n+use test::Bencher;\n+\n+struct DropCounter<'a> {\n+    count: &'a mut u32\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for DropCounter<'a> {\n+    fn drop(&mut self) {\n+        *self.count += 1;\n+    }\n+}\n+\n+#[test]\n+fn test_as_vec() {\n+    let xs = [1u8, 2u8, 3u8];\n+    assert_eq!(&**as_vec(&xs), xs);\n+}\n+\n+#[test]\n+fn test_as_vec_dtor() {\n+    let (mut count_x, mut count_y) = (0, 0);\n+    {\n+        let xs = &[DropCounter { count: &mut count_x }, DropCounter { count: &mut count_y }];\n+        assert_eq!(as_vec(xs).len(), 2);\n+    }\n+    assert_eq!(count_x, 1);\n+    assert_eq!(count_y, 1);\n+}\n+\n+#[test]\n+fn test_small_vec_struct() {\n+    assert!(size_of::<Vec<u8>>() == size_of::<usize>() * 3);\n+}\n+\n+#[test]\n+fn test_double_drop() {\n+    struct TwoVec<T> {\n+        x: Vec<T>,\n+        y: Vec<T>\n+    }\n+\n+    let (mut count_x, mut count_y) = (0, 0);\n+    {\n+        let mut tv = TwoVec {\n+            x: Vec::new(),\n+            y: Vec::new()\n+        };\n+        tv.x.push(DropCounter {count: &mut count_x});\n+        tv.y.push(DropCounter {count: &mut count_y});\n+\n+        // If Vec had a drop flag, here is where it would be zeroed.\n+        // Instead, it should rely on its internal state to prevent\n+        // doing anything significant when dropped multiple times.\n+        drop(tv.x);\n+\n+        // Here tv goes out of scope, tv.y should be dropped, but not tv.x.\n+    }\n+\n+    assert_eq!(count_x, 1);\n+    assert_eq!(count_y, 1);\n+}\n+\n+#[test]\n+fn test_reserve() {\n+    let mut v = Vec::new();\n+    assert_eq!(v.capacity(), 0);\n+\n+    v.reserve(2);\n+    assert!(v.capacity() >= 2);\n+\n+    for i in 0..16 {\n+        v.push(i);\n+    }\n+\n+    assert!(v.capacity() >= 16);\n+    v.reserve(16);\n+    assert!(v.capacity() >= 32);\n+\n+    v.push(16);\n+\n+    v.reserve(16);\n+    assert!(v.capacity() >= 33)\n+}\n+\n+#[test]\n+fn test_extend() {\n+    let mut v = Vec::new();\n+    let mut w = Vec::new();\n+\n+    v.extend(0..3);\n+    for i in 0..3 { w.push(i) }\n+\n+    assert_eq!(v, w);\n+\n+    v.extend(3..10);\n+    for i in 3..10 { w.push(i) }\n+\n+    assert_eq!(v, w);\n+}\n+\n+#[test]\n+fn test_slice_from_mut() {\n+    let mut values = vec![1, 2, 3, 4, 5];\n+    {\n+        let slice = &mut values[2 ..];\n+        assert!(slice == [3, 4, 5]);\n+        for p in slice {\n+            *p += 2;\n+        }\n+    }\n+\n+    assert!(values == [1, 2, 5, 6, 7]);\n+}\n+\n+#[test]\n+fn test_slice_to_mut() {\n+    let mut values = vec![1, 2, 3, 4, 5];\n+    {\n+        let slice = &mut values[.. 2];\n+        assert!(slice == [1, 2]);\n+        for p in slice {\n+            *p += 1;\n+        }\n+    }\n+\n+    assert!(values == [2, 3, 3, 4, 5]);\n+}\n+\n+#[test]\n+fn test_split_at_mut() {\n+    let mut values = vec![1, 2, 3, 4, 5];\n+    {\n+        let (left, right) = values.split_at_mut(2);\n+        {\n+            let left: &[_] = left;\n+            assert!(&left[..left.len()] == &[1, 2]);\n+        }\n+        for p in left {\n+            *p += 1;\n+        }\n+\n+        {\n+            let right: &[_] = right;\n+            assert!(&right[..right.len()] == &[3, 4, 5]);\n+        }\n+        for p in right {\n+            *p += 2;\n+        }\n+    }\n+\n+    assert_eq!(values, [2, 3, 5, 6, 7]);\n+}\n+\n+#[test]\n+fn test_clone() {\n+    let v: Vec<i32> = vec![];\n+    let w = vec!(1, 2, 3);\n+\n+    assert_eq!(v, v.clone());\n+\n+    let z = w.clone();\n+    assert_eq!(w, z);\n+    // they should be disjoint in memory.\n+    assert!(w.as_ptr() != z.as_ptr())\n+}\n+\n+#[test]\n+fn test_clone_from() {\n+    let mut v = vec!();\n+    let three: Vec<Box<_>> = vec!(box 1, box 2, box 3);\n+    let two: Vec<Box<_>> = vec!(box 4, box 5);\n+    // zero, long\n+    v.clone_from(&three);\n+    assert_eq!(v, three);\n+\n+    // equal\n+    v.clone_from(&three);\n+    assert_eq!(v, three);\n+\n+    // long, short\n+    v.clone_from(&two);\n+    assert_eq!(v, two);\n+\n+    // short, long\n+    v.clone_from(&three);\n+    assert_eq!(v, three)\n+}\n+\n+#[test]\n+fn test_retain() {\n+    let mut vec = vec![1, 2, 3, 4];\n+    vec.retain(|&x| x % 2 == 0);\n+    assert_eq!(vec, [2, 4]);\n+}\n+\n+#[test]\n+fn zero_sized_values() {\n+    let mut v = Vec::new();\n+    assert_eq!(v.len(), 0);\n+    v.push(());\n+    assert_eq!(v.len(), 1);\n+    v.push(());\n+    assert_eq!(v.len(), 2);\n+    assert_eq!(v.pop(), Some(()));\n+    assert_eq!(v.pop(), Some(()));\n+    assert_eq!(v.pop(), None);\n+\n+    assert_eq!(v.iter().count(), 0);\n+    v.push(());\n+    assert_eq!(v.iter().count(), 1);\n+    v.push(());\n+    assert_eq!(v.iter().count(), 2);\n+\n+    for &() in &v {}\n+\n+    assert_eq!(v.iter_mut().count(), 2);\n+    v.push(());\n+    assert_eq!(v.iter_mut().count(), 3);\n+    v.push(());\n+    assert_eq!(v.iter_mut().count(), 4);\n+\n+    for &mut () in &mut v {}\n+    unsafe { v.set_len(0); }\n+    assert_eq!(v.iter_mut().count(), 0);\n+}\n+\n+#[test]\n+fn test_partition() {\n+    assert_eq!(vec![].into_iter().partition(|x: &i32| *x < 3), (vec![], vec![]));\n+    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 4), (vec![1, 2, 3], vec![]));\n+    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 2), (vec![1], vec![2, 3]));\n+    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 0), (vec![], vec![1, 2, 3]));\n+}\n+\n+#[test]\n+fn test_zip_unzip() {\n+    let z1 = vec![(1, 4), (2, 5), (3, 6)];\n+\n+    let (left, right): (Vec<_>, Vec<_>) = z1.iter().cloned().unzip();\n+\n+    assert_eq!((1, 4), (left[0], right[0]));\n+    assert_eq!((2, 5), (left[1], right[1]));\n+    assert_eq!((3, 6), (left[2], right[2]));\n+}\n+\n+#[test]\n+fn test_unsafe_ptrs() {\n+    unsafe {\n+        // Test on-stack copy-from-buf.\n+        let a = [1, 2, 3];\n+        let ptr = a.as_ptr();\n+        let b = Vec::from_raw_buf(ptr, 3);\n+        assert_eq!(b, [1, 2, 3]);\n+\n+        // Test on-heap copy-from-buf.\n+        let c = vec![1, 2, 3, 4, 5];\n+        let ptr = c.as_ptr();\n+        let d = Vec::from_raw_buf(ptr, 5);\n+        assert_eq!(d, [1, 2, 3, 4, 5]);\n+    }\n+}\n+\n+#[test]\n+fn test_vec_truncate_drop() {\n+    static mut drops: u32 = 0;\n+    struct Elem(i32);\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe { drops += 1; }\n+        }\n+    }\n+\n+    let mut v = vec![Elem(1), Elem(2), Elem(3), Elem(4), Elem(5)];\n+    assert_eq!(unsafe { drops }, 0);\n+    v.truncate(3);\n+    assert_eq!(unsafe { drops }, 2);\n+    v.truncate(0);\n+    assert_eq!(unsafe { drops }, 5);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_vec_truncate_fail() {\n+    struct BadElem(i32);\n+    impl Drop for BadElem {\n+        fn drop(&mut self) {\n+            let BadElem(ref mut x) = *self;\n+            if *x == 0xbadbeef {\n+                panic!(\"BadElem panic: 0xbadbeef\")\n+            }\n+        }\n+    }\n+\n+    let mut v = vec![BadElem(1), BadElem(2), BadElem(0xbadbeef), BadElem(4)];\n+    v.truncate(0);\n+}\n+\n+#[test]\n+fn test_index() {\n+    let vec = vec![1, 2, 3];\n+    assert!(vec[1] == 2);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_index_out_of_bounds() {\n+    let vec = vec![1, 2, 3];\n+    let _ = vec[3];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_slice_out_of_bounds_1() {\n+    let x = vec![1, 2, 3, 4, 5];\n+    &x[-1..];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_slice_out_of_bounds_2() {\n+    let x = vec![1, 2, 3, 4, 5];\n+    &x[..6];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_slice_out_of_bounds_3() {\n+    let x = vec![1, 2, 3, 4, 5];\n+    &x[-1..4];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_slice_out_of_bounds_4() {\n+    let x = vec![1, 2, 3, 4, 5];\n+    &x[1..6];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_slice_out_of_bounds_5() {\n+    let x = vec![1, 2, 3, 4, 5];\n+    &x[3..2];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_swap_remove_empty() {\n+    let mut vec= Vec::<i32>::new();\n+    vec.swap_remove(0);\n+}\n+\n+#[test]\n+fn test_move_iter_unwrap() {\n+    let mut vec = Vec::with_capacity(7);\n+    vec.push(1);\n+    vec.push(2);\n+    let ptr = vec.as_ptr();\n+    vec = vec.into_iter().into_inner();\n+    assert_eq!(vec.as_ptr(), ptr);\n+    assert_eq!(vec.capacity(), 7);\n+    assert_eq!(vec.len(), 0);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_map_in_place_incompatible_types_fail() {\n+    let v = vec![0, 1, 2];\n+    v.map_in_place(|_| ());\n+}\n+\n+#[test]\n+fn test_map_in_place() {\n+    let v = vec![0, 1, 2];\n+    assert_eq!(v.map_in_place(|i: u32| i as i32 - 1), [-1, 0, 1]);\n+}\n+\n+#[test]\n+fn test_map_in_place_zero_sized() {\n+    let v = vec![(), ()];\n+    #[derive(PartialEq, Debug)]\n+    struct ZeroSized;\n+    assert_eq!(v.map_in_place(|_| ZeroSized), [ZeroSized, ZeroSized]);\n+}\n+\n+#[test]\n+fn test_map_in_place_zero_drop_count() {\n+    use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n+\n+    #[derive(Clone, PartialEq, Debug)]\n+    struct Nothing;\n+    impl Drop for Nothing { fn drop(&mut self) { } }\n+\n+    #[derive(Clone, PartialEq, Debug)]\n+    struct ZeroSized;\n+    impl Drop for ZeroSized {\n+        fn drop(&mut self) {\n+            DROP_COUNTER.fetch_add(1, Ordering::Relaxed);\n+        }\n+    }\n+    const NUM_ELEMENTS: usize = 2;\n+    static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+    let v = repeat(Nothing).take(NUM_ELEMENTS).collect::<Vec<_>>();\n+\n+    DROP_COUNTER.store(0, Ordering::Relaxed);\n+\n+    let v = v.map_in_place(|_| ZeroSized);\n+    assert_eq!(DROP_COUNTER.load(Ordering::Relaxed), 0);\n+    drop(v);\n+    assert_eq!(DROP_COUNTER.load(Ordering::Relaxed), NUM_ELEMENTS);\n+}\n+\n+#[test]\n+fn test_move_items() {\n+    let vec = vec![1, 2, 3];\n+    let mut vec2 = vec![];\n+    for i in vec {\n+        vec2.push(i);\n+    }\n+    assert_eq!(vec2, [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_move_items_reverse() {\n+    let vec = vec![1, 2, 3];\n+    let mut vec2 = vec![];\n+    for i in vec.into_iter().rev() {\n+        vec2.push(i);\n+    }\n+    assert_eq!(vec2, [3, 2, 1]);\n+}\n+\n+#[test]\n+fn test_move_items_zero_sized() {\n+    let vec = vec![(), (), ()];\n+    let mut vec2 = vec![];\n+    for i in vec {\n+        vec2.push(i);\n+    }\n+    assert_eq!(vec2, [(), (), ()]);\n+}\n+\n+#[test]\n+fn test_drain_items() {\n+    let mut vec = vec![1, 2, 3];\n+    let mut vec2 = vec![];\n+    for i in vec.drain() {\n+        vec2.push(i);\n+    }\n+    assert_eq!(vec, []);\n+    assert_eq!(vec2, [ 1, 2, 3 ]);\n+}\n+\n+#[test]\n+fn test_drain_items_reverse() {\n+    let mut vec = vec![1, 2, 3];\n+    let mut vec2 = vec![];\n+    for i in vec.drain().rev() {\n+        vec2.push(i);\n+    }\n+    assert_eq!(vec, []);\n+    assert_eq!(vec2, [3, 2, 1]);\n+}\n+\n+#[test]\n+fn test_drain_items_zero_sized() {\n+    let mut vec = vec![(), (), ()];\n+    let mut vec2 = vec![];\n+    for i in vec.drain() {\n+        vec2.push(i);\n+    }\n+    assert_eq!(vec, []);\n+    assert_eq!(vec2, [(), (), ()]);\n+}\n+\n+#[test]\n+fn test_into_boxed_slice() {\n+    let xs = vec![1, 2, 3];\n+    let ys = xs.into_boxed_slice();\n+    assert_eq!(&*ys, [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_append() {\n+    let mut vec = vec![1, 2, 3];\n+    let mut vec2 = vec![4, 5, 6];\n+    vec.append(&mut vec2);\n+    assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n+    assert_eq!(vec2, []);\n+}\n+\n+#[test]\n+fn test_split_off() {\n+    let mut vec = vec![1, 2, 3, 4, 5, 6];\n+    let vec2 = vec.split_off(4);\n+    assert_eq!(vec, [1, 2, 3, 4]);\n+    assert_eq!(vec2, [5, 6]);\n+}\n+\n+#[bench]\n+fn bench_new(b: &mut Bencher) {\n+    b.iter(|| {\n+        let v: Vec<u32> = Vec::new();\n+        assert_eq!(v.len(), 0);\n+        assert_eq!(v.capacity(), 0);\n+    })\n+}\n+\n+fn do_bench_with_capacity(b: &mut Bencher, src_len: usize) {\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let v: Vec<u32> = Vec::with_capacity(src_len);\n+        assert_eq!(v.len(), 0);\n+        assert_eq!(v.capacity(), src_len);\n+    })\n+}\n+\n+#[bench]\n+fn bench_with_capacity_0000(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 0)\n+}\n+\n+#[bench]\n+fn bench_with_capacity_0010(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 10)\n+}\n+\n+#[bench]\n+fn bench_with_capacity_0100(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 100)\n+}\n+\n+#[bench]\n+fn bench_with_capacity_1000(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 1000)\n+}\n+\n+fn do_bench_from_fn(b: &mut Bencher, src_len: usize) {\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst = (0..src_len).collect::<Vec<_>>();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    })\n+}\n+\n+#[bench]\n+fn bench_from_fn_0000(b: &mut Bencher) {\n+    do_bench_from_fn(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_fn_0010(b: &mut Bencher) {\n+    do_bench_from_fn(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_fn_0100(b: &mut Bencher) {\n+    do_bench_from_fn(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_fn_1000(b: &mut Bencher) {\n+    do_bench_from_fn(b, 1000)\n+}\n+\n+fn do_bench_from_elem(b: &mut Bencher, src_len: usize) {\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst: Vec<usize> = repeat(5).take(src_len).collect();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().all(|x| *x == 5));\n+    })\n+}\n+\n+#[bench]\n+fn bench_from_elem_0000(b: &mut Bencher) {\n+    do_bench_from_elem(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_elem_0010(b: &mut Bencher) {\n+    do_bench_from_elem(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_elem_0100(b: &mut Bencher) {\n+    do_bench_from_elem(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_elem_1000(b: &mut Bencher) {\n+    do_bench_from_elem(b, 1000)\n+}\n+\n+fn do_bench_from_slice(b: &mut Bencher, src_len: usize) {\n+    let src: Vec<_> = FromIterator::from_iter(0..src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst = src.clone()[..].to_vec();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_from_slice_0000(b: &mut Bencher) {\n+    do_bench_from_slice(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_slice_0010(b: &mut Bencher) {\n+    do_bench_from_slice(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_slice_0100(b: &mut Bencher) {\n+    do_bench_from_slice(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_slice_1000(b: &mut Bencher) {\n+    do_bench_from_slice(b, 1000)\n+}\n+\n+fn do_bench_from_iter(b: &mut Bencher, src_len: usize) {\n+    let src: Vec<_> = FromIterator::from_iter(0..src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst: Vec<_> = FromIterator::from_iter(src.clone().into_iter());\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_from_iter_0000(b: &mut Bencher) {\n+    do_bench_from_iter(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_iter_0010(b: &mut Bencher) {\n+    do_bench_from_iter(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_iter_0100(b: &mut Bencher) {\n+    do_bench_from_iter(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_iter_1000(b: &mut Bencher) {\n+    do_bench_from_iter(b, 1000)\n+}\n+\n+fn do_bench_extend(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+        dst.extend(src.clone().into_iter());\n+        assert_eq!(dst.len(), dst_len + src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_extend_0000_0000(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_extend_0000_0010(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_extend_0000_0100(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_extend_0000_1000(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_extend_0010_0010(b: &mut Bencher) {\n+    do_bench_extend(b, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_extend_0100_0100(b: &mut Bencher) {\n+    do_bench_extend(b, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_extend_1000_1000(b: &mut Bencher) {\n+    do_bench_extend(b, 1000, 1000)\n+}\n+\n+fn do_bench_push_all(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+        dst.push_all(&src);\n+        assert_eq!(dst.len(), dst_len + src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_0000(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_0010(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_0100(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_1000(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_push_all_0010_0010(b: &mut Bencher) {\n+    do_bench_push_all(b, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_0100_0100(b: &mut Bencher) {\n+    do_bench_push_all(b, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_1000_1000(b: &mut Bencher) {\n+    do_bench_push_all(b, 1000, 1000)\n+}\n+\n+fn do_bench_push_all_move(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+        dst.extend(src.clone().into_iter());\n+        assert_eq!(dst.len(), dst_len + src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_0000(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_0010(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_0100(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_1000(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0010_0010(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0100_0100(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_1000_1000(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 1000, 1000)\n+}\n+\n+fn do_bench_clone(b: &mut Bencher, src_len: usize) {\n+    let src: Vec<usize> = FromIterator::from_iter(0..src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst = src.clone();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_clone_0000(b: &mut Bencher) {\n+    do_bench_clone(b, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_0010(b: &mut Bencher) {\n+    do_bench_clone(b, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_0100(b: &mut Bencher) {\n+    do_bench_clone(b, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_1000(b: &mut Bencher) {\n+    do_bench_clone(b, 1000)\n+}\n+\n+fn do_bench_clone_from(b: &mut Bencher, times: usize, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..src_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = (times * src_len) as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+\n+        for _ in 0..times {\n+            dst.clone_from(&src);\n+\n+            assert_eq!(dst.len(), src_len);\n+            assert!(dst.iter().enumerate().all(|(i, x)| dst_len + i == *x));\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0010_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0100_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_1000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 1000, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0010_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 10, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0100_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 100, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0010_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 10, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0100_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 100, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_1000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 1000, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0010_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0100_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_1000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 1000, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0010_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 10, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0100_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 100, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0010_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 10, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0100_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 100, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_1000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 1000, 100)\n+}"}, {"sha": "ba2ed36de21105130b530ec74173af6f9b678501", "filename": "src/libcollectionstest/vec_deque.rs", "status": "added", "additions": 1150, "deletions": 0, "changes": 1150, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,1150 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::VecDeque;\n+use std::fmt::Debug;\n+use std::hash::{SipHasher, self};\n+\n+use test;\n+\n+use self::Taggy::*;\n+use self::Taggypar::*;\n+\n+#[test]\n+#[allow(deprecated)]\n+fn test_simple() {\n+    let mut d = VecDeque::new();\n+    assert_eq!(d.len(), 0);\n+    d.push_front(17);\n+    d.push_front(42);\n+    d.push_back(137);\n+    assert_eq!(d.len(), 3);\n+    d.push_back(137);\n+    assert_eq!(d.len(), 4);\n+    assert_eq!(*d.front().unwrap(), 42);\n+    assert_eq!(*d.back().unwrap(), 137);\n+    let mut i = d.pop_front();\n+    assert_eq!(i, Some(42));\n+    i = d.pop_back();\n+    assert_eq!(i, Some(137));\n+    i = d.pop_back();\n+    assert_eq!(i, Some(137));\n+    i = d.pop_back();\n+    assert_eq!(i, Some(17));\n+    assert_eq!(d.len(), 0);\n+    d.push_back(3);\n+    assert_eq!(d.len(), 1);\n+    d.push_front(2);\n+    assert_eq!(d.len(), 2);\n+    d.push_back(4);\n+    assert_eq!(d.len(), 3);\n+    d.push_front(1);\n+    assert_eq!(d.len(), 4);\n+    debug!(\"{}\", d[0]);\n+    debug!(\"{}\", d[1]);\n+    debug!(\"{}\", d[2]);\n+    debug!(\"{}\", d[3]);\n+    assert_eq!(d[0], 1);\n+    assert_eq!(d[1], 2);\n+    assert_eq!(d[2], 3);\n+    assert_eq!(d[3], 4);\n+}\n+\n+#[cfg(test)]\n+fn test_parameterized<T:Clone + PartialEq + Debug>(a: T, b: T, c: T, d: T) {\n+    let mut deq = VecDeque::new();\n+    assert_eq!(deq.len(), 0);\n+    deq.push_front(a.clone());\n+    deq.push_front(b.clone());\n+    deq.push_back(c.clone());\n+    assert_eq!(deq.len(), 3);\n+    deq.push_back(d.clone());\n+    assert_eq!(deq.len(), 4);\n+    assert_eq!((*deq.front().unwrap()).clone(), b.clone());\n+    assert_eq!((*deq.back().unwrap()).clone(), d.clone());\n+    assert_eq!(deq.pop_front().unwrap(), b.clone());\n+    assert_eq!(deq.pop_back().unwrap(), d.clone());\n+    assert_eq!(deq.pop_back().unwrap(), c.clone());\n+    assert_eq!(deq.pop_back().unwrap(), a.clone());\n+    assert_eq!(deq.len(), 0);\n+    deq.push_back(c.clone());\n+    assert_eq!(deq.len(), 1);\n+    deq.push_front(b.clone());\n+    assert_eq!(deq.len(), 2);\n+    deq.push_back(d.clone());\n+    assert_eq!(deq.len(), 3);\n+    deq.push_front(a.clone());\n+    assert_eq!(deq.len(), 4);\n+    assert_eq!(deq[0].clone(), a.clone());\n+    assert_eq!(deq[1].clone(), b.clone());\n+    assert_eq!(deq[2].clone(), c.clone());\n+    assert_eq!(deq[3].clone(), d.clone());\n+}\n+\n+#[test]\n+fn test_push_front_grow() {\n+    let mut deq = VecDeque::new();\n+    for i in 0..66 {\n+        deq.push_front(i);\n+    }\n+    assert_eq!(deq.len(), 66);\n+\n+    for i in 0..66 {\n+        assert_eq!(deq[i], 65 - i);\n+    }\n+\n+    let mut deq = VecDeque::new();\n+    for i in 0..66 {\n+        deq.push_back(i);\n+    }\n+\n+    for i in 0..66 {\n+        assert_eq!(deq[i], i);\n+    }\n+}\n+\n+#[test]\n+fn test_index() {\n+    let mut deq = VecDeque::new();\n+    for i in 1..4 {\n+        deq.push_front(i);\n+    }\n+    assert_eq!(deq[1], 2);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_index_out_of_bounds() {\n+    let mut deq = VecDeque::new();\n+    for i in 1..4 {\n+        deq.push_front(i);\n+    }\n+    deq[3];\n+}\n+\n+#[bench]\n+fn bench_new(b: &mut test::Bencher) {\n+    b.iter(|| {\n+        let ring: VecDeque<i32> = VecDeque::new();\n+        test::black_box(ring);\n+    })\n+}\n+\n+// FIXME(japaric) privacy\n+/*\n+#[bench]\n+fn bench_push_back_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::with_capacity(101);\n+    b.iter(|| {\n+        for i in 0..100 {\n+            deq.push_back(i);\n+        }\n+        deq.head = 0;\n+        deq.tail = 0;\n+    })\n+}\n+*/\n+\n+// FIXME(japaric) privacy\n+/*\n+#[bench]\n+fn bench_push_front_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::with_capacity(101);\n+    b.iter(|| {\n+        for i in 0..100 {\n+            deq.push_front(i);\n+        }\n+        deq.head = 0;\n+        deq.tail = 0;\n+    })\n+}\n+*/\n+\n+// FIXME(japaric) privacy\n+/*\n+#[bench]\n+fn bench_pop_back_100(b: &mut test::Bencher) {\n+    let mut deq= VecDeque::<i32>::with_capacity(101);\n+\n+    b.iter(|| {\n+        deq.head = 100;\n+        deq.tail = 0;\n+        while !deq.is_empty() {\n+            test::black_box(deq.pop_back());\n+        }\n+    })\n+}\n+*/\n+\n+// FIXME(japaric) privacy\n+/*\n+#[bench]\n+fn bench_pop_front_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::<i32>::with_capacity(101);\n+\n+    b.iter(|| {\n+        deq.head = 100;\n+        deq.tail = 0;\n+        while !deq.is_empty() {\n+            test::black_box(deq.pop_front());\n+        }\n+    })\n+}\n+*/\n+\n+#[bench]\n+fn bench_grow_1025(b: &mut test::Bencher) {\n+    b.iter(|| {\n+        let mut deq = VecDeque::new();\n+        for i in 0..1025 {\n+            deq.push_front(i);\n+        }\n+        test::black_box(deq);\n+    })\n+}\n+\n+#[bench]\n+fn bench_iter_1000(b: &mut test::Bencher) {\n+    let ring: VecDeque<_> = (0..1000).collect();\n+\n+    b.iter(|| {\n+        let mut sum = 0;\n+        for &i in &ring {\n+            sum += i;\n+        }\n+        test::black_box(sum);\n+    })\n+}\n+\n+#[bench]\n+fn bench_mut_iter_1000(b: &mut test::Bencher) {\n+    let mut ring: VecDeque<_> = (0..1000).collect();\n+\n+    b.iter(|| {\n+        let mut sum = 0;\n+        for i in &mut ring {\n+            sum += *i;\n+        }\n+        test::black_box(sum);\n+    })\n+}\n+\n+#[derive(Clone, PartialEq, Debug)]\n+enum Taggy {\n+    One(i32),\n+    Two(i32, i32),\n+    Three(i32, i32, i32),\n+}\n+\n+#[derive(Clone, PartialEq, Debug)]\n+enum Taggypar<T> {\n+    Onepar(T),\n+    Twopar(T, T),\n+    Threepar(T, T, T),\n+}\n+\n+#[derive(Clone, PartialEq, Debug)]\n+struct RecCy {\n+    x: i32,\n+    y: i32,\n+    t: Taggy\n+}\n+\n+#[test]\n+fn test_param_int() {\n+    test_parameterized::<i32>(5, 72, 64, 175);\n+}\n+\n+#[test]\n+fn test_param_taggy() {\n+    test_parameterized::<Taggy>(One(1), Two(1, 2), Three(1, 2, 3), Two(17, 42));\n+}\n+\n+#[test]\n+fn test_param_taggypar() {\n+    test_parameterized::<Taggypar<i32>>(Onepar::<i32>(1),\n+                                        Twopar::<i32>(1, 2),\n+                                        Threepar::<i32>(1, 2, 3),\n+                                        Twopar::<i32>(17, 42));\n+}\n+\n+#[test]\n+fn test_param_reccy() {\n+    let reccy1 = RecCy { x: 1, y: 2, t: One(1) };\n+    let reccy2 = RecCy { x: 345, y: 2, t: Two(1, 2) };\n+    let reccy3 = RecCy { x: 1, y: 777, t: Three(1, 2, 3) };\n+    let reccy4 = RecCy { x: 19, y: 252, t: Two(17, 42) };\n+    test_parameterized::<RecCy>(reccy1, reccy2, reccy3, reccy4);\n+}\n+\n+#[test]\n+fn test_with_capacity() {\n+    let mut d = VecDeque::with_capacity(0);\n+    d.push_back(1);\n+    assert_eq!(d.len(), 1);\n+    let mut d = VecDeque::with_capacity(50);\n+    d.push_back(1);\n+    assert_eq!(d.len(), 1);\n+}\n+\n+#[test]\n+fn test_with_capacity_non_power_two() {\n+    let mut d3 = VecDeque::with_capacity(3);\n+    d3.push_back(1);\n+\n+    // X = None, | = lo\n+    // [|1, X, X]\n+    assert_eq!(d3.pop_front(), Some(1));\n+    // [X, |X, X]\n+    assert_eq!(d3.front(), None);\n+\n+    // [X, |3, X]\n+    d3.push_back(3);\n+    // [X, |3, 6]\n+    d3.push_back(6);\n+    // [X, X, |6]\n+    assert_eq!(d3.pop_front(), Some(3));\n+\n+    // Pushing the lo past half way point to trigger\n+    // the 'B' scenario for growth\n+    // [9, X, |6]\n+    d3.push_back(9);\n+    // [9, 12, |6]\n+    d3.push_back(12);\n+\n+    d3.push_back(15);\n+    // There used to be a bug here about how the\n+    // VecDeque made growth assumptions about the\n+    // underlying Vec which didn't hold and lead\n+    // to corruption.\n+    // (Vec grows to next power of two)\n+    //good- [9, 12, 15, X, X, X, X, |6]\n+    //bug-  [15, 12, X, X, X, |6, X, X]\n+    assert_eq!(d3.pop_front(), Some(6));\n+\n+    // Which leads us to the following state which\n+    // would be a failure case.\n+    //bug-  [15, 12, X, X, X, X, |X, X]\n+    assert_eq!(d3.front(), Some(&9));\n+}\n+\n+#[test]\n+fn test_reserve_exact() {\n+    let mut d = VecDeque::new();\n+    d.push_back(0);\n+    d.reserve_exact(50);\n+    assert!(d.capacity() >= 51);\n+}\n+\n+#[test]\n+fn test_reserve() {\n+    let mut d = VecDeque::new();\n+    d.push_back(0);\n+    d.reserve(50);\n+    assert!(d.capacity() >= 51);\n+}\n+\n+#[test]\n+fn test_swap() {\n+    let mut d: VecDeque<_> = (0..5).collect();\n+    d.pop_front();\n+    d.swap(0, 3);\n+    assert_eq!(d.iter().cloned().collect::<Vec<_>>(), [4, 2, 3, 1]);\n+}\n+\n+#[test]\n+fn test_iter() {\n+    let mut d = VecDeque::new();\n+    assert_eq!(d.iter().next(), None);\n+    assert_eq!(d.iter().size_hint(), (0, Some(0)));\n+\n+    for i in 0..5 {\n+        d.push_back(i);\n+    }\n+    {\n+        let b: &[_] = &[&0,&1,&2,&3,&4];\n+        assert_eq!(d.iter().collect::<Vec<_>>(), b);\n+    }\n+\n+    for i in 6..9 {\n+        d.push_front(i);\n+    }\n+    {\n+        let b: &[_] = &[&8,&7,&6,&0,&1,&2,&3,&4];\n+        assert_eq!(d.iter().collect::<Vec<_>>(), b);\n+    }\n+\n+    let mut it = d.iter();\n+    let mut len = d.len();\n+    loop {\n+        match it.next() {\n+            None => break,\n+            _ => { len -= 1; assert_eq!(it.size_hint(), (len, Some(len))) }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_rev_iter() {\n+    let mut d = VecDeque::new();\n+    assert_eq!(d.iter().rev().next(), None);\n+\n+    for i in 0..5 {\n+        d.push_back(i);\n+    }\n+    {\n+        let b: &[_] = &[&4,&3,&2,&1,&0];\n+        assert_eq!(d.iter().rev().collect::<Vec<_>>(), b);\n+    }\n+\n+    for i in 6..9 {\n+        d.push_front(i);\n+    }\n+    let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n+    assert_eq!(d.iter().rev().collect::<Vec<_>>(), b);\n+}\n+\n+#[test]\n+fn test_mut_rev_iter_wrap() {\n+    let mut d = VecDeque::with_capacity(3);\n+    assert!(d.iter_mut().rev().next().is_none());\n+\n+    d.push_back(1);\n+    d.push_back(2);\n+    d.push_back(3);\n+    assert_eq!(d.pop_front(), Some(1));\n+    d.push_back(4);\n+\n+    assert_eq!(d.iter_mut().rev().cloned().collect::<Vec<_>>(),\n+               vec![4, 3, 2]);\n+}\n+\n+#[test]\n+fn test_mut_iter() {\n+    let mut d = VecDeque::new();\n+    assert!(d.iter_mut().next().is_none());\n+\n+    for i in 0..3 {\n+        d.push_front(i);\n+    }\n+\n+    for (i, elt) in d.iter_mut().enumerate() {\n+        assert_eq!(*elt, 2 - i);\n+        *elt = i;\n+    }\n+\n+    {\n+        let mut it = d.iter_mut();\n+        assert_eq!(*it.next().unwrap(), 0);\n+        assert_eq!(*it.next().unwrap(), 1);\n+        assert_eq!(*it.next().unwrap(), 2);\n+        assert!(it.next().is_none());\n+    }\n+}\n+\n+#[test]\n+fn test_mut_rev_iter() {\n+    let mut d = VecDeque::new();\n+    assert!(d.iter_mut().rev().next().is_none());\n+\n+    for i in 0..3 {\n+        d.push_front(i);\n+    }\n+\n+    for (i, elt) in d.iter_mut().rev().enumerate() {\n+        assert_eq!(*elt, i);\n+        *elt = i;\n+    }\n+\n+    {\n+        let mut it = d.iter_mut().rev();\n+        assert_eq!(*it.next().unwrap(), 0);\n+        assert_eq!(*it.next().unwrap(), 1);\n+        assert_eq!(*it.next().unwrap(), 2);\n+        assert!(it.next().is_none());\n+    }\n+}\n+\n+#[test]\n+fn test_into_iter() {\n+\n+    // Empty iter\n+    {\n+        let d: VecDeque<i32> = VecDeque::new();\n+        let mut iter = d.into_iter();\n+\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    // simple iter\n+    {\n+        let mut d = VecDeque::new();\n+        for i in 0..5 {\n+            d.push_back(i);\n+        }\n+\n+        let b = vec![0,1,2,3,4];\n+        assert_eq!(d.into_iter().collect::<Vec<_>>(), b);\n+    }\n+\n+    // wrapped iter\n+    {\n+        let mut d = VecDeque::new();\n+        for i in 0..5 {\n+            d.push_back(i);\n+        }\n+        for i in 6..9 {\n+            d.push_front(i);\n+        }\n+\n+        let b = vec![8,7,6,0,1,2,3,4];\n+        assert_eq!(d.into_iter().collect::<Vec<_>>(), b);\n+    }\n+\n+    // partially used\n+    {\n+        let mut d = VecDeque::new();\n+        for i in 0..5 {\n+            d.push_back(i);\n+        }\n+        for i in 6..9 {\n+            d.push_front(i);\n+        }\n+\n+        let mut it = d.into_iter();\n+        assert_eq!(it.size_hint(), (8, Some(8)));\n+        assert_eq!(it.next(), Some(8));\n+        assert_eq!(it.size_hint(), (7, Some(7)));\n+        assert_eq!(it.next_back(), Some(4));\n+        assert_eq!(it.size_hint(), (6, Some(6)));\n+        assert_eq!(it.next(), Some(7));\n+        assert_eq!(it.size_hint(), (5, Some(5)));\n+    }\n+}\n+\n+#[test]\n+fn test_drain() {\n+\n+    // Empty iter\n+    {\n+        let mut d: VecDeque<i32> = VecDeque::new();\n+\n+        {\n+            let mut iter = d.drain();\n+\n+            assert_eq!(iter.size_hint(), (0, Some(0)));\n+            assert_eq!(iter.next(), None);\n+            assert_eq!(iter.size_hint(), (0, Some(0)));\n+        }\n+\n+        assert!(d.is_empty());\n+    }\n+\n+    // simple iter\n+    {\n+        let mut d = VecDeque::new();\n+        for i in 0..5 {\n+            d.push_back(i);\n+        }\n+\n+        assert_eq!(d.drain().collect::<Vec<_>>(), [0, 1, 2, 3, 4]);\n+        assert!(d.is_empty());\n+    }\n+\n+    // wrapped iter\n+    {\n+        let mut d = VecDeque::new();\n+        for i in 0..5 {\n+            d.push_back(i);\n+        }\n+        for i in 6..9 {\n+            d.push_front(i);\n+        }\n+\n+        assert_eq!(d.drain().collect::<Vec<_>>(), [8,7,6,0,1,2,3,4]);\n+        assert!(d.is_empty());\n+    }\n+\n+    // partially used\n+    {\n+        let mut d: VecDeque<_> = VecDeque::new();\n+        for i in 0..5 {\n+            d.push_back(i);\n+        }\n+        for i in 6..9 {\n+            d.push_front(i);\n+        }\n+\n+        {\n+            let mut it = d.drain();\n+            assert_eq!(it.size_hint(), (8, Some(8)));\n+            assert_eq!(it.next(), Some(8));\n+            assert_eq!(it.size_hint(), (7, Some(7)));\n+            assert_eq!(it.next_back(), Some(4));\n+            assert_eq!(it.size_hint(), (6, Some(6)));\n+            assert_eq!(it.next(), Some(7));\n+            assert_eq!(it.size_hint(), (5, Some(5)));\n+        }\n+        assert!(d.is_empty());\n+    }\n+}\n+\n+#[test]\n+fn test_from_iter() {\n+    use std::iter;\n+\n+    let v = vec!(1,2,3,4,5,6,7);\n+    let deq: VecDeque<_> = v.iter().cloned().collect();\n+    let u: Vec<_> = deq.iter().cloned().collect();\n+    assert_eq!(u, v);\n+\n+    let seq = iter::count(0, 2).take(256);\n+    let deq: VecDeque<_> = seq.collect();\n+    for (i, &x) in deq.iter().enumerate() {\n+        assert_eq!(2*i, x);\n+    }\n+    assert_eq!(deq.len(), 256);\n+}\n+\n+#[test]\n+fn test_clone() {\n+    let mut d = VecDeque::new();\n+    d.push_front(17);\n+    d.push_front(42);\n+    d.push_back(137);\n+    d.push_back(137);\n+    assert_eq!(d.len(), 4);\n+    let mut e = d.clone();\n+    assert_eq!(e.len(), 4);\n+    while !d.is_empty() {\n+        assert_eq!(d.pop_back(), e.pop_back());\n+    }\n+    assert_eq!(d.len(), 0);\n+    assert_eq!(e.len(), 0);\n+}\n+\n+#[test]\n+fn test_eq() {\n+    let mut d = VecDeque::new();\n+    assert!(d == VecDeque::with_capacity(0));\n+    d.push_front(137);\n+    d.push_front(17);\n+    d.push_front(42);\n+    d.push_back(137);\n+    let mut e = VecDeque::with_capacity(0);\n+    e.push_back(42);\n+    e.push_back(17);\n+    e.push_back(137);\n+    e.push_back(137);\n+    assert!(&e == &d);\n+    e.pop_back();\n+    e.push_back(0);\n+    assert!(e != d);\n+    e.clear();\n+    assert!(e == VecDeque::new());\n+}\n+\n+#[test]\n+fn test_hash() {\n+  let mut x = VecDeque::new();\n+  let mut y = VecDeque::new();\n+\n+  x.push_back(1);\n+  x.push_back(2);\n+  x.push_back(3);\n+\n+  y.push_back(0);\n+  y.push_back(1);\n+  y.pop_front();\n+  y.push_back(2);\n+  y.push_back(3);\n+\n+  assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n+}\n+\n+#[test]\n+fn test_ord() {\n+    let x = VecDeque::new();\n+    let mut y = VecDeque::new();\n+    y.push_back(1);\n+    y.push_back(2);\n+    y.push_back(3);\n+    assert!(x < y);\n+    assert!(y > x);\n+    assert!(x <= x);\n+    assert!(x >= x);\n+}\n+\n+#[test]\n+fn test_show() {\n+    let ringbuf: VecDeque<_> = (0..10).collect();\n+    assert_eq!(format!(\"{:?}\", ringbuf), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+\n+    let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n+                                                                    .cloned()\n+                                                                    .collect();\n+    assert_eq!(format!(\"{:?}\", ringbuf), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+}\n+\n+#[test]\n+fn test_drop() {\n+    static mut drops: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe { drops += 1; }\n+        }\n+    }\n+\n+    let mut ring = VecDeque::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    drop(ring);\n+\n+    assert_eq!(unsafe {drops}, 4);\n+}\n+\n+#[test]\n+fn test_drop_with_pop() {\n+    static mut drops: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe { drops += 1; }\n+        }\n+    }\n+\n+    let mut ring = VecDeque::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+\n+    drop(ring.pop_back());\n+    drop(ring.pop_front());\n+    assert_eq!(unsafe {drops}, 2);\n+\n+    drop(ring);\n+    assert_eq!(unsafe {drops}, 4);\n+}\n+\n+#[test]\n+fn test_drop_clear() {\n+    static mut drops: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe { drops += 1; }\n+        }\n+    }\n+\n+    let mut ring = VecDeque::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.clear();\n+    assert_eq!(unsafe {drops}, 4);\n+\n+    drop(ring);\n+    assert_eq!(unsafe {drops}, 4);\n+}\n+\n+#[test]\n+fn test_reserve_grow() {\n+    // test growth path A\n+    // [T o o H] -> [T o o H . . . . ]\n+    let mut ring = VecDeque::with_capacity(4);\n+    for i in 0..3 {\n+        ring.push_back(i);\n+    }\n+    ring.reserve(7);\n+    for i in 0..3 {\n+        assert_eq!(ring.pop_front(), Some(i));\n+    }\n+\n+    // test growth path B\n+    // [H T o o] -> [. T o o H . . . ]\n+    let mut ring = VecDeque::with_capacity(4);\n+    for i in 0..1 {\n+        ring.push_back(i);\n+        assert_eq!(ring.pop_front(), Some(i));\n+    }\n+    for i in 0..3 {\n+        ring.push_back(i);\n+    }\n+    ring.reserve(7);\n+    for i in 0..3 {\n+        assert_eq!(ring.pop_front(), Some(i));\n+    }\n+\n+    // test growth path C\n+    // [o o H T] -> [o o H . . . . T ]\n+    let mut ring = VecDeque::with_capacity(4);\n+    for i in 0..3 {\n+        ring.push_back(i);\n+        assert_eq!(ring.pop_front(), Some(i));\n+    }\n+    for i in 0..3 {\n+        ring.push_back(i);\n+    }\n+    ring.reserve(7);\n+    for i in 0..3 {\n+        assert_eq!(ring.pop_front(), Some(i));\n+    }\n+}\n+\n+#[test]\n+fn test_get() {\n+    let mut ring = VecDeque::new();\n+    ring.push_back(0);\n+    assert_eq!(ring.get(0), Some(&0));\n+    assert_eq!(ring.get(1), None);\n+\n+    ring.push_back(1);\n+    assert_eq!(ring.get(0), Some(&0));\n+    assert_eq!(ring.get(1), Some(&1));\n+    assert_eq!(ring.get(2), None);\n+\n+    ring.push_back(2);\n+    assert_eq!(ring.get(0), Some(&0));\n+    assert_eq!(ring.get(1), Some(&1));\n+    assert_eq!(ring.get(2), Some(&2));\n+    assert_eq!(ring.get(3), None);\n+\n+    assert_eq!(ring.pop_front(), Some(0));\n+    assert_eq!(ring.get(0), Some(&1));\n+    assert_eq!(ring.get(1), Some(&2));\n+    assert_eq!(ring.get(2), None);\n+\n+    assert_eq!(ring.pop_front(), Some(1));\n+    assert_eq!(ring.get(0), Some(&2));\n+    assert_eq!(ring.get(1), None);\n+\n+    assert_eq!(ring.pop_front(), Some(2));\n+    assert_eq!(ring.get(0), None);\n+    assert_eq!(ring.get(1), None);\n+}\n+\n+#[test]\n+fn test_get_mut() {\n+    let mut ring = VecDeque::new();\n+    for i in 0..3 {\n+        ring.push_back(i);\n+    }\n+\n+    match ring.get_mut(1) {\n+        Some(x) => *x = -1,\n+        None => ()\n+    };\n+\n+    assert_eq!(ring.get_mut(0), Some(&mut 0));\n+    assert_eq!(ring.get_mut(1), Some(&mut -1));\n+    assert_eq!(ring.get_mut(2), Some(&mut 2));\n+    assert_eq!(ring.get_mut(3), None);\n+\n+    assert_eq!(ring.pop_front(), Some(0));\n+    assert_eq!(ring.get_mut(0), Some(&mut -1));\n+    assert_eq!(ring.get_mut(1), Some(&mut 2));\n+    assert_eq!(ring.get_mut(2), None);\n+}\n+\n+// FIXME(japaric) privacy\n+/*\n+#[test]\n+fn test_swap_front_back_remove() {\n+    fn test(back: bool) {\n+        // This test checks that every single combination of tail position and length is tested.\n+        // Capacity 15 should be large enough to cover every case.\n+        let mut tester = VecDeque::with_capacity(15);\n+        let usable_cap = tester.capacity();\n+        let final_len = usable_cap / 2;\n+\n+        for len in 0..final_len {\n+            let expected = if back {\n+                (0..len).collect()\n+            } else {\n+                (0..len).rev().collect()\n+            };\n+            for tail_pos in 0..usable_cap {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                if back {\n+                    for i in 0..len * 2 {\n+                        tester.push_front(i);\n+                    }\n+                    for i in 0..len {\n+                        assert_eq!(tester.swap_back_remove(i), Some(len * 2 - 1 - i));\n+                    }\n+                } else {\n+                    for i in 0..len * 2 {\n+                        tester.push_back(i);\n+                    }\n+                    for i in 0..len {\n+                        let idx = tester.len() - 1 - i;\n+                        assert_eq!(tester.swap_front_remove(idx), Some(len * 2 - 1 - i));\n+                    }\n+                }\n+                assert!(tester.tail < tester.cap);\n+                assert!(tester.head < tester.cap);\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+    test(true);\n+    test(false);\n+}\n+*/\n+\n+// FIXME(japaric) privacy\n+/*\n+#[test]\n+fn test_insert() {\n+    // This test checks that every single combination of tail position, length, and\n+    // insertion position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+\n+    // len is the length *after* insertion\n+    for len in 1..cap {\n+        // 0, 1, 2, .., len - 1\n+        let expected = iter::count(0, 1).take(len).collect();\n+        for tail_pos in 0..cap {\n+            for to_insert in 0..len {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    if i != to_insert {\n+                        tester.push_back(i);\n+                    }\n+                }\n+                tester.insert(to_insert, to_insert);\n+                assert!(tester.tail < tester.cap);\n+                assert!(tester.head < tester.cap);\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+}\n+*/\n+\n+// FIXME(japaric) privacy\n+/*\n+#[test]\n+fn test_remove() {\n+    // This test checks that every single combination of tail position, length, and\n+    // removal position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+    // len is the length *after* removal\n+    for len in 0..cap - 1 {\n+        // 0, 1, 2, .., len - 1\n+        let expected = iter::count(0, 1).take(len).collect();\n+        for tail_pos in 0..cap {\n+            for to_remove in 0..len + 1 {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    if i == to_remove {\n+                        tester.push_back(1234);\n+                    }\n+                    tester.push_back(i);\n+                }\n+                if to_remove == len {\n+                    tester.push_back(1234);\n+                }\n+                tester.remove(to_remove);\n+                assert!(tester.tail < tester.cap);\n+                assert!(tester.head < tester.cap);\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+}\n+*/\n+\n+// FIXME(japaric) privacy\n+/*\n+#[test]\n+fn test_shrink_to_fit() {\n+    // This test checks that every single combination of head and tail position,\n+    // is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+    tester.reserve(63);\n+    let max_cap = tester.capacity();\n+\n+    for len in 0..cap + 1 {\n+        // 0, 1, 2, .., len - 1\n+        let expected = iter::count(0, 1).take(len).collect();\n+        for tail_pos in 0..max_cap + 1 {\n+            tester.tail = tail_pos;\n+            tester.head = tail_pos;\n+            tester.reserve(63);\n+            for i in 0..len {\n+                tester.push_back(i);\n+            }\n+            tester.shrink_to_fit();\n+            assert!(tester.capacity() <= cap);\n+            assert!(tester.tail < tester.cap);\n+            assert!(tester.head < tester.cap);\n+            assert_eq!(tester, expected);\n+        }\n+    }\n+}\n+*/\n+\n+#[test]\n+fn test_front() {\n+    let mut ring = VecDeque::new();\n+    ring.push_back(10);\n+    ring.push_back(20);\n+    assert_eq!(ring.front(), Some(&10));\n+    ring.pop_front();\n+    assert_eq!(ring.front(), Some(&20));\n+    ring.pop_front();\n+    assert_eq!(ring.front(), None);\n+}\n+\n+#[test]\n+fn test_as_slices() {\n+    let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n+    let cap = ring.capacity() as i32;\n+    let first = cap/2;\n+    let last  = cap - first;\n+    for i in 0..first {\n+        ring.push_back(i);\n+\n+        let (left, right) = ring.as_slices();\n+        let expected: Vec<_> = (0..i+1).collect();\n+        assert_eq!(left, expected);\n+        assert_eq!(right, []);\n+    }\n+\n+    for j in -last..0 {\n+        ring.push_front(j);\n+        let (left, right) = ring.as_slices();\n+        let expected_left: Vec<_> = (-last..j+1).rev().collect();\n+        let expected_right: Vec<_> = (0..first).collect();\n+        assert_eq!(left, expected_left);\n+        assert_eq!(right, expected_right);\n+    }\n+\n+    assert_eq!(ring.len() as i32, cap);\n+    assert_eq!(ring.capacity() as i32, cap);\n+}\n+\n+#[test]\n+fn test_as_mut_slices() {\n+    let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n+    let cap = ring.capacity() as i32;\n+    let first = cap/2;\n+    let last  = cap - first;\n+    for i in 0..first {\n+        ring.push_back(i);\n+\n+        let (left, right) = ring.as_mut_slices();\n+        let expected: Vec<_> = (0..i+1).collect();\n+        assert_eq!(left, expected);\n+        assert_eq!(right, []);\n+    }\n+\n+    for j in -last..0 {\n+        ring.push_front(j);\n+        let (left, right) = ring.as_mut_slices();\n+        let expected_left: Vec<_> = (-last..j+1).rev().collect();\n+        let expected_right: Vec<_> = (0..first).collect();\n+        assert_eq!(left, expected_left);\n+        assert_eq!(right, expected_right);\n+    }\n+\n+    assert_eq!(ring.len() as i32, cap);\n+    assert_eq!(ring.capacity() as i32, cap);\n+}\n+\n+// FIXME(japaric) privacy\n+/*\n+#[test]\n+fn test_split_off() {\n+    // This test checks that every single combination of tail position, length, and\n+    // split position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+    // len is the length *before* splitting\n+    for len in 0..cap {\n+        // index to split at\n+        for at in 0..len + 1 {\n+            // 0, 1, 2, .., at - 1 (may be empty)\n+            let expected_self = iter::count(0, 1).take(at).collect();\n+            // at, at + 1, .., len - 1 (may be empty)\n+            let expected_other = iter::count(at, 1).take(len - at).collect();\n+\n+            for tail_pos in 0..cap {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    tester.push_back(i);\n+                }\n+                let result = tester.split_off(at);\n+                assert!(tester.tail < tester.cap);\n+                assert!(tester.head < tester.cap);\n+                assert!(result.tail < result.cap);\n+                assert!(result.head < result.cap);\n+                assert_eq!(tester, expected_self);\n+                assert_eq!(result, expected_other);\n+            }\n+        }\n+    }\n+}\n+*/\n+\n+#[test]\n+fn test_append() {\n+    let mut a: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n+    let mut b: VecDeque<_> = vec![4, 5, 6].into_iter().collect();\n+\n+    // normal append\n+    a.append(&mut b);\n+    assert_eq!(a.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n+    assert_eq!(b.iter().cloned().collect::<Vec<_>>(), []);\n+\n+    // append nothing to something\n+    a.append(&mut b);\n+    assert_eq!(a.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n+    assert_eq!(b.iter().cloned().collect::<Vec<_>>(), []);\n+\n+    // append something to nothing\n+    b.append(&mut a);\n+    assert_eq!(b.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n+    assert_eq!(a.iter().cloned().collect::<Vec<_>>(), []);\n+}"}, {"sha": "112b4c03e20e5c354b335d50e8fab0879c842a23", "filename": "src/libcollectionstest/vec_map.rs", "status": "added", "additions": 510, "deletions": 0, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6453fcd4ccaa84cf8a21b5991bae23a5923df98b/src%2Flibcollectionstest%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_map.rs?ref=6453fcd4ccaa84cf8a21b5991bae23a5923df98b", "patch": "@@ -0,0 +1,510 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::VecMap;\n+use std::collections::vec_map::Entry::{Occupied, Vacant};\n+use std::hash::{SipHasher, hash};\n+\n+#[test]\n+fn test_get_mut() {\n+    let mut m = VecMap::new();\n+    assert!(m.insert(1, 12).is_none());\n+    assert!(m.insert(2, 8).is_none());\n+    assert!(m.insert(5, 14).is_none());\n+    let new = 100;\n+    match m.get_mut(&5) {\n+        None => panic!(), Some(x) => *x = new\n+    }\n+    assert_eq!(m.get(&5), Some(&new));\n+}\n+\n+#[test]\n+fn test_len() {\n+    let mut map = VecMap::new();\n+    assert_eq!(map.len(), 0);\n+    assert!(map.is_empty());\n+    assert!(map.insert(5, 20).is_none());\n+    assert_eq!(map.len(), 1);\n+    assert!(!map.is_empty());\n+    assert!(map.insert(11, 12).is_none());\n+    assert_eq!(map.len(), 2);\n+    assert!(!map.is_empty());\n+    assert!(map.insert(14, 22).is_none());\n+    assert_eq!(map.len(), 3);\n+    assert!(!map.is_empty());\n+}\n+\n+#[test]\n+fn test_clear() {\n+    let mut map = VecMap::new();\n+    assert!(map.insert(5, 20).is_none());\n+    assert!(map.insert(11, 12).is_none());\n+    assert!(map.insert(14, 22).is_none());\n+    map.clear();\n+    assert!(map.is_empty());\n+    assert!(map.get(&5).is_none());\n+    assert!(map.get(&11).is_none());\n+    assert!(map.get(&14).is_none());\n+}\n+\n+#[test]\n+fn test_insert() {\n+    let mut m = VecMap::new();\n+    assert_eq!(m.insert(1, 2), None);\n+    assert_eq!(m.insert(1, 3), Some(2));\n+    assert_eq!(m.insert(1, 4), Some(3));\n+}\n+\n+#[test]\n+fn test_remove() {\n+    let mut m = VecMap::new();\n+    m.insert(1, 2);\n+    assert_eq!(m.remove(&1), Some(2));\n+    assert_eq!(m.remove(&1), None);\n+}\n+\n+#[test]\n+fn test_keys() {\n+    let mut map = VecMap::new();\n+    map.insert(1, 'a');\n+    map.insert(2, 'b');\n+    map.insert(3, 'c');\n+    let keys: Vec<_> = map.keys().collect();\n+    assert_eq!(keys.len(), 3);\n+    assert!(keys.contains(&1));\n+    assert!(keys.contains(&2));\n+    assert!(keys.contains(&3));\n+}\n+\n+#[test]\n+fn test_values() {\n+    let mut map = VecMap::new();\n+    map.insert(1, 'a');\n+    map.insert(2, 'b');\n+    map.insert(3, 'c');\n+    let values: Vec<_> = map.values().cloned().collect();\n+    assert_eq!(values.len(), 3);\n+    assert!(values.contains(&'a'));\n+    assert!(values.contains(&'b'));\n+    assert!(values.contains(&'c'));\n+}\n+\n+#[test]\n+fn test_iterator() {\n+    let mut m = VecMap::new();\n+\n+    assert!(m.insert(0, 1).is_none());\n+    assert!(m.insert(1, 2).is_none());\n+    assert!(m.insert(3, 5).is_none());\n+    assert!(m.insert(6, 10).is_none());\n+    assert!(m.insert(10, 11).is_none());\n+\n+    let mut it = m.iter();\n+    assert_eq!(it.size_hint(), (0, Some(11)));\n+    assert_eq!(it.next().unwrap(), (0, &1));\n+    assert_eq!(it.size_hint(), (0, Some(10)));\n+    assert_eq!(it.next().unwrap(), (1, &2));\n+    assert_eq!(it.size_hint(), (0, Some(9)));\n+    assert_eq!(it.next().unwrap(), (3, &5));\n+    assert_eq!(it.size_hint(), (0, Some(7)));\n+    assert_eq!(it.next().unwrap(), (6, &10));\n+    assert_eq!(it.size_hint(), (0, Some(4)));\n+    assert_eq!(it.next().unwrap(), (10, &11));\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_iterator_size_hints() {\n+    let mut m = VecMap::new();\n+\n+    assert!(m.insert(0, 1).is_none());\n+    assert!(m.insert(1, 2).is_none());\n+    assert!(m.insert(3, 5).is_none());\n+    assert!(m.insert(6, 10).is_none());\n+    assert!(m.insert(10, 11).is_none());\n+\n+    assert_eq!(m.iter().size_hint(), (0, Some(11)));\n+    assert_eq!(m.iter().rev().size_hint(), (0, Some(11)));\n+    assert_eq!(m.iter_mut().size_hint(), (0, Some(11)));\n+    assert_eq!(m.iter_mut().rev().size_hint(), (0, Some(11)));\n+}\n+\n+#[test]\n+fn test_mut_iterator() {\n+    let mut m = VecMap::new();\n+\n+    assert!(m.insert(0, 1).is_none());\n+    assert!(m.insert(1, 2).is_none());\n+    assert!(m.insert(3, 5).is_none());\n+    assert!(m.insert(6, 10).is_none());\n+    assert!(m.insert(10, 11).is_none());\n+\n+    for (k, v) in &mut m {\n+        *v += k as isize;\n+    }\n+\n+    let mut it = m.iter();\n+    assert_eq!(it.next().unwrap(), (0, &1));\n+    assert_eq!(it.next().unwrap(), (1, &3));\n+    assert_eq!(it.next().unwrap(), (3, &8));\n+    assert_eq!(it.next().unwrap(), (6, &16));\n+    assert_eq!(it.next().unwrap(), (10, &21));\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_rev_iterator() {\n+    let mut m = VecMap::new();\n+\n+    assert!(m.insert(0, 1).is_none());\n+    assert!(m.insert(1, 2).is_none());\n+    assert!(m.insert(3, 5).is_none());\n+    assert!(m.insert(6, 10).is_none());\n+    assert!(m.insert(10, 11).is_none());\n+\n+    let mut it = m.iter().rev();\n+    assert_eq!(it.next().unwrap(), (10, &11));\n+    assert_eq!(it.next().unwrap(), (6, &10));\n+    assert_eq!(it.next().unwrap(), (3, &5));\n+    assert_eq!(it.next().unwrap(), (1, &2));\n+    assert_eq!(it.next().unwrap(), (0, &1));\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_mut_rev_iterator() {\n+    let mut m = VecMap::new();\n+\n+    assert!(m.insert(0, 1).is_none());\n+    assert!(m.insert(1, 2).is_none());\n+    assert!(m.insert(3, 5).is_none());\n+    assert!(m.insert(6, 10).is_none());\n+    assert!(m.insert(10, 11).is_none());\n+\n+    for (k, v) in m.iter_mut().rev() {\n+        *v += k as isize;\n+    }\n+\n+    let mut it = m.iter();\n+    assert_eq!(it.next().unwrap(), (0, &1));\n+    assert_eq!(it.next().unwrap(), (1, &3));\n+    assert_eq!(it.next().unwrap(), (3, &8));\n+    assert_eq!(it.next().unwrap(), (6, &16));\n+    assert_eq!(it.next().unwrap(), (10, &21));\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_move_iter() {\n+    let mut m: VecMap<Box<_>> = VecMap::new();\n+    m.insert(1, box 2);\n+    let mut called = false;\n+    for (k, v) in m {\n+        assert!(!called);\n+        called = true;\n+        assert_eq!(k, 1);\n+        assert_eq!(v, box 2);\n+    }\n+    assert!(called);\n+}\n+\n+#[test]\n+fn test_drain_iterator() {\n+    let mut map = VecMap::new();\n+    map.insert(1, \"a\");\n+    map.insert(3, \"c\");\n+    map.insert(2, \"b\");\n+\n+    let vec: Vec<_> = map.drain().collect();\n+\n+    assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+    assert_eq!(map.len(), 0);\n+}\n+\n+#[test]\n+fn test_append() {\n+    let mut a = VecMap::new();\n+    a.insert(1, \"a\");\n+    a.insert(2, \"b\");\n+    a.insert(3, \"c\");\n+\n+    let mut b = VecMap::new();\n+    b.insert(3, \"d\");  // Overwrite element from a\n+    b.insert(4, \"e\");\n+    b.insert(5, \"f\");\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.len(), 5);\n+    assert_eq!(b.len(), 0);\n+    // Capacity shouldn't change for possible reuse\n+    assert!(b.capacity() >= 4);\n+\n+    assert_eq!(a[1], \"a\");\n+    assert_eq!(a[2], \"b\");\n+    assert_eq!(a[3], \"d\");\n+    assert_eq!(a[4], \"e\");\n+    assert_eq!(a[5], \"f\");\n+}\n+\n+#[test]\n+fn test_split_off() {\n+    // Split within the key range\n+    let mut a = VecMap::new();\n+    a.insert(1, \"a\");\n+    a.insert(2, \"b\");\n+    a.insert(3, \"c\");\n+    a.insert(4, \"d\");\n+\n+    let b = a.split_off(3);\n+\n+    assert_eq!(a.len(), 2);\n+    assert_eq!(b.len(), 2);\n+\n+    assert_eq!(a[1], \"a\");\n+    assert_eq!(a[2], \"b\");\n+\n+    assert_eq!(b[3], \"c\");\n+    assert_eq!(b[4], \"d\");\n+\n+    // Split at 0\n+    a.clear();\n+    a.insert(1, \"a\");\n+    a.insert(2, \"b\");\n+    a.insert(3, \"c\");\n+    a.insert(4, \"d\");\n+\n+    let b = a.split_off(0);\n+\n+    assert_eq!(a.len(), 0);\n+    assert_eq!(b.len(), 4);\n+    assert_eq!(b[1], \"a\");\n+    assert_eq!(b[2], \"b\");\n+    assert_eq!(b[3], \"c\");\n+    assert_eq!(b[4], \"d\");\n+\n+    // Split behind max_key\n+    a.clear();\n+    a.insert(1, \"a\");\n+    a.insert(2, \"b\");\n+    a.insert(3, \"c\");\n+    a.insert(4, \"d\");\n+\n+    let b = a.split_off(5);\n+\n+    assert_eq!(a.len(), 4);\n+    assert_eq!(b.len(), 0);\n+    assert_eq!(a[1], \"a\");\n+    assert_eq!(a[2], \"b\");\n+    assert_eq!(a[3], \"c\");\n+    assert_eq!(a[4], \"d\");\n+}\n+\n+#[test]\n+fn test_show() {\n+    let mut map = VecMap::new();\n+    let empty = VecMap::<i32>::new();\n+\n+    map.insert(1, 2);\n+    map.insert(3, 4);\n+\n+    let map_str = format!(\"{:?}\", map);\n+    assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n+    assert_eq!(format!(\"{:?}\", empty), \"{}\");\n+}\n+\n+#[test]\n+fn test_clone() {\n+    let mut a = VecMap::new();\n+\n+    a.insert(1, 'x');\n+    a.insert(4, 'y');\n+    a.insert(6, 'z');\n+\n+    assert!(a.clone() == a);\n+}\n+\n+#[test]\n+fn test_eq() {\n+    let mut a = VecMap::new();\n+    let mut b = VecMap::new();\n+\n+    assert!(a == b);\n+    assert!(a.insert(0, 5).is_none());\n+    assert!(a != b);\n+    assert!(b.insert(0, 4).is_none());\n+    assert!(a != b);\n+    assert!(a.insert(5, 19).is_none());\n+    assert!(a != b);\n+    assert!(!b.insert(0, 5).is_none());\n+    assert!(a != b);\n+    assert!(b.insert(5, 19).is_none());\n+    assert!(a == b);\n+\n+    a = VecMap::new();\n+    b = VecMap::with_capacity(1);\n+    assert!(a == b);\n+}\n+\n+#[test]\n+fn test_lt() {\n+    let mut a = VecMap::new();\n+    let mut b = VecMap::new();\n+\n+    assert!(!(a < b) && !(b < a));\n+    assert!(b.insert(2, 5).is_none());\n+    assert!(a < b);\n+    assert!(a.insert(2, 7).is_none());\n+    assert!(!(a < b) && b < a);\n+    assert!(b.insert(1, 0).is_none());\n+    assert!(b < a);\n+    assert!(a.insert(0, 6).is_none());\n+    assert!(a < b);\n+    assert!(a.insert(6, 2).is_none());\n+    assert!(a < b && !(b < a));\n+}\n+\n+#[test]\n+fn test_ord() {\n+    let mut a = VecMap::new();\n+    let mut b = VecMap::new();\n+\n+    assert!(a <= b && a >= b);\n+    assert!(a.insert(1, 1).is_none());\n+    assert!(a > b && a >= b);\n+    assert!(b < a && b <= a);\n+    assert!(b.insert(2, 2).is_none());\n+    assert!(b > a && b >= a);\n+    assert!(a < b && a <= b);\n+}\n+\n+#[test]\n+fn test_hash() {\n+    let mut x = VecMap::new();\n+    let mut y = VecMap::new();\n+\n+    assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n+    x.insert(1, 'a');\n+    x.insert(2, 'b');\n+    x.insert(3, 'c');\n+\n+    y.insert(3, 'c');\n+    y.insert(2, 'b');\n+    y.insert(1, 'a');\n+\n+    assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n+\n+    x.insert(1000, 'd');\n+    x.remove(&1000);\n+\n+    assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n+}\n+\n+#[test]\n+fn test_from_iter() {\n+    let xs = vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')];\n+\n+    let map: VecMap<_> = xs.iter().cloned().collect();\n+\n+    for &(k, v) in &xs {\n+        assert_eq!(map.get(&k), Some(&v));\n+    }\n+}\n+\n+#[test]\n+fn test_index() {\n+    let mut map = VecMap::new();\n+\n+    map.insert(1, 2);\n+    map.insert(2, 1);\n+    map.insert(3, 4);\n+\n+    assert_eq!(map[3], 4);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_index_nonexistent() {\n+    let mut map = VecMap::new();\n+\n+    map.insert(1, 2);\n+    map.insert(2, 1);\n+    map.insert(3, 4);\n+\n+    map[4];\n+}\n+\n+#[test]\n+fn test_entry(){\n+    let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+    let mut map: VecMap<_> = xs.iter().cloned().collect();\n+\n+    // Existing key (insert)\n+    match map.entry(1) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(mut view) => {\n+            assert_eq!(view.get(), &10);\n+            assert_eq!(view.insert(100), 10);\n+        }\n+    }\n+    assert_eq!(map.get(&1).unwrap(), &100);\n+    assert_eq!(map.len(), 6);\n+\n+\n+    // Existing key (update)\n+    match map.entry(2) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(mut view) => {\n+            let v = view.get_mut();\n+            *v *= 10;\n+        }\n+    }\n+    assert_eq!(map.get(&2).unwrap(), &200);\n+    assert_eq!(map.len(), 6);\n+\n+    // Existing key (take)\n+    match map.entry(3) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(view) => {\n+            assert_eq!(view.remove(), 30);\n+        }\n+    }\n+    assert_eq!(map.get(&3), None);\n+    assert_eq!(map.len(), 5);\n+\n+\n+    // Inexistent key (insert)\n+    match map.entry(10) {\n+        Occupied(_) => unreachable!(),\n+        Vacant(view) => {\n+            assert_eq!(*view.insert(1000), 1000);\n+        }\n+    }\n+    assert_eq!(map.get(&10).unwrap(), &1000);\n+    assert_eq!(map.len(), 6);\n+}\n+\n+mod bench {\n+    use std::collections::VecMap;\n+\n+    map_insert_rand_bench!{insert_rand_100,    100,    VecMap}\n+    map_insert_rand_bench!{insert_rand_10_000, 10_000, VecMap}\n+\n+    map_insert_seq_bench!{insert_seq_100,    100,    VecMap}\n+    map_insert_seq_bench!{insert_seq_10_000, 10_000, VecMap}\n+\n+    map_find_rand_bench!{find_rand_100,    100,    VecMap}\n+    map_find_rand_bench!{find_rand_10_000, 10_000, VecMap}\n+\n+    map_find_seq_bench!{find_seq_100,    100,    VecMap}\n+    map_find_seq_bench!{find_seq_10_000, 10_000, VecMap}\n+}"}]}