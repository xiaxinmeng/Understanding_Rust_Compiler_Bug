{"sha": "d88b9b7543756afef81dcb2e2c37a11603d513d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4OGI5Yjc1NDM3NTZhZmVmODFkY2IyZTJjMzdhMTE2MDNkNTEzZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-18T14:34:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-18T14:34:04Z"}, "message": "Auto merge of #6046 - rail-rain:change_criteria_non_copy_const, r=flip1995\n\nChange the criteria of `interior_mutable_const`\n\nThis implements my suggestion [here](https://github.com/rust-lang/rust-clippy/issues/5050#issuecomment-680310889), and so hopefully fixes #5050.\n\n* stop linting associated types and generic type parameters\n* start linting ones in trait impls\n  whose corresponding definitions in the traits are generic\n* remove the `is_copy` check\n  as presumably the only purpose of it is to allow\n  generics with `Copy` bounds as `Freeze` is internal\n  and generics are no longer linted\n* remove the term 'copy' from the tests\n  as being `Copy` no longer have meaning\n\n---\n\nchangelog: Change the criteria of `declare_interior_mutable_const` and `borrow_interior_mutable_const` to narrow the lints to only lint things that defenitly is a interior mutable type, not potentially.", "tree": {"sha": "8dc61ee72e3ac402bc7b8c6fbd208dc5b5a31840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dc61ee72e3ac402bc7b8c6fbd208dc5b5a31840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d88b9b7543756afef81dcb2e2c37a11603d513d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d88b9b7543756afef81dcb2e2c37a11603d513d5", "html_url": "https://github.com/rust-lang/rust/commit/d88b9b7543756afef81dcb2e2c37a11603d513d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d88b9b7543756afef81dcb2e2c37a11603d513d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5af88e3c2d8cc4fb74a0e455381669930ee3a31a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5af88e3c2d8cc4fb74a0e455381669930ee3a31a", "html_url": "https://github.com/rust-lang/rust/commit/5af88e3c2d8cc4fb74a0e455381669930ee3a31a"}, {"sha": "d5af360bb2de24235d2873e926d0b6f21135ae38", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5af360bb2de24235d2873e926d0b6f21135ae38", "html_url": "https://github.com/rust-lang/rust/commit/d5af360bb2de24235d2873e926d0b6f21135ae38"}], "stats": {"total": 404, "additions": 269, "deletions": 135}, "files": [{"sha": "bb44eeb6adc51b30b056e80306b4448479161427", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 63, "deletions": 32, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d88b9b7543756afef81dcb2e2c37a11603d513d5/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d88b9b7543756afef81dcb2e2c37a11603d513d5/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=d88b9b7543756afef81dcb2e2c37a11603d513d5", "patch": "@@ -6,14 +6,16 @@ use std::ptr;\n \n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp};\n+use rustc_infer::traits::specialization_graph;\n use rustc_lint::{LateContext, LateLintPass, Lint};\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_middle::ty::{Ty, TypeFlags};\n+use rustc_middle::ty::{AssocKind, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use rustc_typeck::hir_ty_to_ty;\n \n-use crate::utils::{in_constant, is_copy, qpath_res, span_lint_and_then};\n+use crate::utils::{in_constant, qpath_res, span_lint_and_then};\n+use if_chain::if_chain;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for declaration of `const` items which is interior\n@@ -83,11 +85,10 @@ declare_clippy_lint! {\n     \"referencing `const` with interior mutability\"\n }\n \n-#[allow(dead_code)]\n #[derive(Copy, Clone)]\n enum Source {\n     Item { item: Span },\n-    Assoc { item: Span, ty: Span },\n+    Assoc { item: Span },\n     Expr { expr: Span },\n }\n \n@@ -110,10 +111,15 @@ impl Source {\n }\n \n fn verify_ty_bound<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, source: Source) {\n-    if ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env) || is_copy(cx, ty) {\n-        // An `UnsafeCell` is `!Copy`, and an `UnsafeCell` is also the only type which\n-        // is `!Freeze`, thus if our type is `Copy` we can be sure it must be `Freeze`\n-        // as well.\n+    // Ignore types whose layout is unknown since `is_freeze` reports every generic types as `!Freeze`,\n+    // making it indistinguishable from `UnsafeCell`. i.e. it isn't a tool to prove a type is\n+    // 'unfrozen'. However, this code causes a false negative in which\n+    // a type contains a layout-unknown type, but also a unsafe cell like `const CELL: Cell<T>`.\n+    // Yet, it's better than `ty.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_PROJECTION)`\n+    // since it works when a pointer indirection involves (`Cell<*const T>`).\n+    // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n+    // but I'm not sure whether it's a decent way, if possible.\n+    if cx.tcx.layout_of(cx.param_env.and(ty)).is_err() || ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env) {\n         return;\n     }\n \n@@ -127,11 +133,7 @@ fn verify_ty_bound<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, source: Source) {\n                 let const_kw_span = span.from_inner(InnerSpan::new(0, 5));\n                 diag.span_label(const_kw_span, \"make this a static item (maybe with lazy_static)\");\n             },\n-            Source::Assoc { ty: ty_span, .. } => {\n-                if ty.flags().intersects(TypeFlags::HAS_FREE_LOCAL_NAMES) {\n-                    diag.span_label(ty_span, &format!(\"consider requiring `{}` to be `Copy`\", ty));\n-                }\n-            },\n+            Source::Assoc { .. } => (),\n             Source::Expr { .. } => {\n                 diag.help(\"assign this const to a local or static variable, and use the variable here\");\n             },\n@@ -152,32 +154,61 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx TraitItem<'_>) {\n         if let TraitItemKind::Const(hir_ty, ..) = &trait_item.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            verify_ty_bound(\n-                cx,\n-                ty,\n-                Source::Assoc {\n-                    ty: hir_ty.span,\n-                    item: trait_item.span,\n-                },\n-            );\n+            // Normalize assoc types because ones originated from generic params\n+            // bounded other traits could have their bound.\n+            let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+            verify_ty_bound(cx, normalized, Source::Assoc { item: trait_item.span });\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Const(hir_ty, ..) = &impl_item.kind {\n             let item_hir_id = cx.tcx.hir().get_parent_node(impl_item.hir_id);\n             let item = cx.tcx.hir().expect_item(item_hir_id);\n-            // Ensure the impl is an inherent impl.\n-            if let ItemKind::Impl { of_trait: None, .. } = item.kind {\n-                let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-                verify_ty_bound(\n-                    cx,\n-                    ty,\n-                    Source::Assoc {\n-                        ty: hir_ty.span,\n-                        item: impl_item.span,\n-                    },\n-                );\n+\n+            match &item.kind {\n+                ItemKind::Impl {\n+                    of_trait: Some(of_trait_ref),\n+                    ..\n+                } => {\n+                    if_chain! {\n+                        // Lint a trait impl item only when the definition is a generic type,\n+                        // assuming a assoc const is not meant to be a interior mutable type.\n+                        if let Some(of_trait_def_id) = of_trait_ref.trait_def_id();\n+                        if let Some(of_assoc_item) = specialization_graph::Node::Trait(of_trait_def_id)\n+                            .item(cx.tcx, impl_item.ident, AssocKind::Const, of_trait_def_id);\n+                        if cx\n+                            .tcx\n+                            .layout_of(cx.tcx.param_env(of_trait_def_id).and(\n+                                // Normalize assoc types because ones originated from generic params\n+                                // bounded other traits could have their bound at the trait defs;\n+                                // and, in that case, the definition is *not* generic.\n+                                cx.tcx.normalize_erasing_regions(\n+                                    cx.tcx.param_env(of_trait_def_id),\n+                                    cx.tcx.type_of(of_assoc_item.def_id),\n+                                ),\n+                            ))\n+                            .is_err();\n+                        then {\n+                            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+                            let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+                            verify_ty_bound(\n+                                cx,\n+                                normalized,\n+                                Source::Assoc {\n+                                    item: impl_item.span,\n+                                },\n+                            );\n+                        }\n+                    }\n+                },\n+                ItemKind::Impl { of_trait: None, .. } => {\n+                    let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+                    // Normalize assoc types originated from generic params.\n+                    let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+                    verify_ty_bound(cx, normalized, Source::Assoc { item: impl_item.span });\n+                },\n+                _ => (),\n             }\n         }\n     }"}, {"sha": "9fcc9ece49bb7e78840a34078d960e342e466329", "filename": "tests/ui/borrow_interior_mutable_const.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d88b9b7543756afef81dcb2e2c37a11603d513d5/tests%2Fui%2Fborrow_interior_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d88b9b7543756afef81dcb2e2c37a11603d513d5/tests%2Fui%2Fborrow_interior_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const.rs?ref=d88b9b7543756afef81dcb2e2c37a11603d513d5", "patch": "@@ -19,16 +19,30 @@ const NO_ANN: &dyn Display = &70;\n static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n const ONCE_INIT: Once = Once::new();\n \n-trait Trait<T>: Copy {\n-    type NonCopyType;\n+trait Trait<T> {\n+    type AssocType;\n \n     const ATOMIC: AtomicUsize;\n+    const INPUT: T;\n+    const ASSOC: Self::AssocType;\n+\n+    fn function() {\n+        let _ = &Self::INPUT;\n+        let _ = &Self::ASSOC;\n+    }\n }\n \n impl Trait<u32> for u64 {\n-    type NonCopyType = u16;\n+    type AssocType = AtomicUsize;\n \n     const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n+    const INPUT: u32 = 10;\n+    const ASSOC: Self::AssocType = AtomicUsize::new(11);\n+\n+    fn function() {\n+        let _ = &Self::INPUT;\n+        let _ = &Self::ASSOC; //~ ERROR interior mutability\n+    }\n }\n \n // This is just a pointer that can be safely dereferended,"}, {"sha": "ed726a6b46e64b9e4b62cab9bc18f1c93baf93ba", "filename": "tests/ui/borrow_interior_mutable_const.stderr", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d88b9b7543756afef81dcb2e2c37a11603d513d5/tests%2Fui%2Fborrow_interior_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d88b9b7543756afef81dcb2e2c37a11603d513d5/tests%2Fui%2Fborrow_interior_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const.stderr?ref=d88b9b7543756afef81dcb2e2c37a11603d513d5", "patch": "@@ -1,131 +1,139 @@\n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:66:5\n+  --> $DIR/borrow_interior_mutable_const.rs:44:18\n+   |\n+LL |         let _ = &Self::ASSOC; //~ ERROR interior mutability\n+   |                  ^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/borrow_interior_mutable_const.rs:80:5\n    |\n LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^\n    |\n-   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:67:16\n+  --> $DIR/borrow_interior_mutable_const.rs:81:16\n    |\n LL |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n    |                ^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:70:22\n+  --> $DIR/borrow_interior_mutable_const.rs:84:22\n    |\n LL |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n    |                      ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:71:25\n+  --> $DIR/borrow_interior_mutable_const.rs:85:25\n    |\n LL |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n    |                         ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:72:27\n+  --> $DIR/borrow_interior_mutable_const.rs:86:27\n    |\n LL |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n    |                           ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:73:26\n+  --> $DIR/borrow_interior_mutable_const.rs:87:26\n    |\n LL |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n    |                          ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:84:14\n+  --> $DIR/borrow_interior_mutable_const.rs:98:14\n    |\n LL |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:85:14\n+  --> $DIR/borrow_interior_mutable_const.rs:99:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:86:19\n+  --> $DIR/borrow_interior_mutable_const.rs:100:19\n    |\n LL |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n    |                   ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:87:14\n+  --> $DIR/borrow_interior_mutable_const.rs:101:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:88:13\n+  --> $DIR/borrow_interior_mutable_const.rs:102:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:94:13\n+  --> $DIR/borrow_interior_mutable_const.rs:108:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:99:5\n+  --> $DIR/borrow_interior_mutable_const.rs:113:5\n    |\n LL |     CELL.set(2); //~ ERROR interior mutability\n    |     ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:100:16\n+  --> $DIR/borrow_interior_mutable_const.rs:114:16\n    |\n LL |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n    |                ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:113:5\n+  --> $DIR/borrow_interior_mutable_const.rs:127:5\n    |\n LL |     u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:114:16\n+  --> $DIR/borrow_interior_mutable_const.rs:128:16\n    |\n LL |     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n    |                ^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "3afcdca2f04dd165b03f7fb7fcdf0e12d0867073", "filename": "tests/ui/declare_interior_mutable_const.rs", "status": "modified", "additions": 121, "deletions": 40, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/d88b9b7543756afef81dcb2e2c37a11603d513d5/tests%2Fui%2Fdeclare_interior_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d88b9b7543756afef81dcb2e2c37a11603d513d5/tests%2Fui%2Fdeclare_interior_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const.rs?ref=d88b9b7543756afef81dcb2e2c37a11603d513d5", "patch": "@@ -34,60 +34,141 @@ static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n #[allow(clippy::declare_interior_mutable_const)]\n const ONCE_INIT: Once = Once::new();\n \n-trait Trait<T>: Copy {\n-    type NonCopyType;\n-\n+// a constant whose type is a concrete type should be linted at the definition site.\n+trait ConcreteTypes {\n     const ATOMIC: AtomicUsize; //~ ERROR interior mutable\n     const INTEGER: u64;\n     const STRING: String;\n-    const SELF: Self; // (no error)\n-    const INPUT: T;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `T` to be `Copy`\n-    const ASSOC: Self::NonCopyType;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `<Self as Trait<T>>::NonCopyType` to be `Copy`\n+    declare_const!(ANOTHER_ATOMIC: AtomicUsize = Self::ATOMIC); //~ ERROR interior mutable\n+}\n \n-    const AN_INPUT: T = Self::INPUT;\n-    //~^ ERROR interior mutable\n-    //~| ERROR consider requiring `T` to be `Copy`\n-    declare_const!(ANOTHER_INPUT: T = Self::INPUT); //~ ERROR interior mutable\n+impl ConcreteTypes for u64 {\n+    const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n+    const INTEGER: u64 = 10;\n+    const STRING: String = String::new();\n }\n \n-trait Trait2 {\n-    type CopyType: Copy;\n+// a helper trait used below\n+trait ConstDefault {\n+    const DEFAULT: Self;\n+}\n+\n+// a constant whose type is a generic type should be linted at the implementation site.\n+trait GenericTypes<T, U> {\n+    const TO_REMAIN_GENERIC: T;\n+    const TO_BE_CONCRETE: U;\n \n-    const SELF_2: Self;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `Self` to be `Copy`\n-    const ASSOC_2: Self::CopyType; // (no error)\n+    const HAVING_DEFAULT: T = Self::TO_REMAIN_GENERIC;\n+    declare_const!(IN_MACRO: T = Self::TO_REMAIN_GENERIC);\n }\n \n-// we don't lint impl of traits, because an impl has no power to change the interface.\n-impl Trait<u32> for u64 {\n-    type NonCopyType = u16;\n+impl<T: ConstDefault> GenericTypes<T, AtomicUsize> for u64 {\n+    const TO_REMAIN_GENERIC: T = T::DEFAULT;\n+    const TO_BE_CONCRETE: AtomicUsize = AtomicUsize::new(11); //~ ERROR interior mutable\n+}\n \n-    const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n-    const INTEGER: u64 = 10;\n-    const STRING: String = String::new();\n-    const SELF: Self = 11;\n-    const INPUT: u32 = 12;\n-    const ASSOC: Self::NonCopyType = 13;\n+// a helper type used below\n+struct Wrapper<T>(T);\n+\n+// a constant whose type is an associated type should be linted at the implementation site, too.\n+trait AssocTypes {\n+    type ToBeFrozen;\n+    type ToBeUnfrozen;\n+    type ToBeGenericParam;\n+\n+    const TO_BE_FROZEN: Self::ToBeFrozen;\n+    const TO_BE_UNFROZEN: Self::ToBeUnfrozen;\n+    const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen>;\n+    // to ensure it can handle things when a generic type remains after normalization.\n+    const WRAPPED_TO_BE_GENERIC_PARAM: Wrapper<Self::ToBeGenericParam>;\n }\n \n-struct Local<T, U>(T, U);\n+impl<T: ConstDefault> AssocTypes for Vec<T> {\n+    type ToBeFrozen = u16;\n+    type ToBeUnfrozen = AtomicUsize;\n+    type ToBeGenericParam = T;\n+\n+    const TO_BE_FROZEN: Self::ToBeFrozen = 12;\n+    const TO_BE_UNFROZEN: Self::ToBeUnfrozen = AtomicUsize::new(13); //~ ERROR interior mutable\n+    const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen> = Wrapper(AtomicUsize::new(14)); //~ ERROR interior mutable\n+    const WRAPPED_TO_BE_GENERIC_PARAM: Wrapper<Self::ToBeGenericParam> = Wrapper(T::DEFAULT);\n+}\n+\n+// a helper trait used below\n+trait AssocTypesHelper {\n+    type NotToBeBounded;\n+    type ToBeBounded;\n+\n+    const NOT_TO_BE_BOUNDED: Self::NotToBeBounded;\n+}\n \n-impl<T: Trait2 + Trait<u32>, U: Trait2> Local<T, U> {\n-    const ASSOC_3: AtomicUsize = AtomicUsize::new(14); //~ ERROR interior mutable\n+// a constant whose type is an assoc type originated from a generic param bounded at the definition\n+// site should be linted at there.\n+trait AssocTypesFromGenericParam<T>\n+where\n+    T: AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    const NOT_BOUNDED: T::NotToBeBounded;\n+    const BOUNDED: T::ToBeBounded; //~ ERROR interior mutable\n+}\n+\n+impl<T> AssocTypesFromGenericParam<T> for u64\n+where\n+    T: AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    // an associated type could remain unknown in a trait impl.\n+    const NOT_BOUNDED: T::NotToBeBounded = T::NOT_TO_BE_BOUNDED;\n+    const BOUNDED: T::ToBeBounded = AtomicUsize::new(15);\n+}\n+\n+// a constant whose type is `Self` should be linted at the implementation site as well.\n+// (`Option` requires `Sized` bound.)\n+trait SelfType: Sized {\n+    const SELF: Self;\n+    // this was the one in the original issue (#5050).\n+    const WRAPPED_SELF: Option<Self>;\n+}\n+\n+impl SelfType for u64 {\n+    const SELF: Self = 16;\n+    const WRAPPED_SELF: Option<Self> = Some(20);\n+}\n+\n+impl SelfType for AtomicUsize {\n+    // this (interior mutable `Self` const) exists in `parking_lot`.\n+    // `const_trait_impl` will replace it in the future, hopefully.\n+    const SELF: Self = AtomicUsize::new(17); //~ ERROR interior mutable\n+    const WRAPPED_SELF: Option<Self> = Some(AtomicUsize::new(21)); //~ ERROR interior mutable\n+}\n+\n+// Even though a constant contains a generic type, if it also have a interior mutable type,\n+// it should be linted at the definition site.\n+trait BothOfCellAndGeneric<T> {\n+    // this is a false negative in the current implementation.\n+    const DIRECT: Cell<T>;\n+    const INDIRECT: Cell<*const T>; //~ ERROR interior mutable\n+}\n+\n+impl<T: ConstDefault> BothOfCellAndGeneric<T> for u64 {\n+    const DIRECT: Cell<T> = Cell::new(T::DEFAULT);\n+    const INDIRECT: Cell<*const T> = Cell::new(std::ptr::null());\n+}\n+\n+struct Local<T>(T);\n+\n+// a constant in an inherent impl are essentially the same as a normal const item\n+// except there can be a generic or associated type.\n+impl<T> Local<T>\n+where\n+    T: ConstDefault + AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    const ATOMIC: AtomicUsize = AtomicUsize::new(18); //~ ERROR interior mutable\n     const COW: Cow<'static, str> = Cow::Borrowed(\"tuvwxy\");\n-    const T_SELF: T = T::SELF_2;\n-    const U_SELF: U = U::SELF_2;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `U` to be `Copy`\n-    const T_ASSOC: T::NonCopyType = T::ASSOC;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `<T as Trait<u32>>::NonCopyType` to be `Copy`\n-    const U_ASSOC: U::CopyType = U::ASSOC_2;\n+\n+    const GENERIC_TYPE: T = T::DEFAULT;\n+\n+    const ASSOC_TYPE: T::NotToBeBounded = T::NOT_TO_BE_BOUNDED;\n+    const BOUNDED_ASSOC_TYPE: T::ToBeBounded = AtomicUsize::new(19); //~ ERROR interior mutable\n }\n \n fn main() {}"}, {"sha": "5cb10be88d89cde900cfaa62c2861852dd7bde8a", "filename": "tests/ui/declare_interior_mutable_const.stderr", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d88b9b7543756afef81dcb2e2c37a11603d513d5/tests%2Fui%2Fdeclare_interior_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d88b9b7543756afef81dcb2e2c37a11603d513d5/tests%2Fui%2Fdeclare_interior_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const.stderr?ref=d88b9b7543756afef81dcb2e2c37a11603d513d5", "patch": "@@ -36,75 +36,75 @@ LL | declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:40:5\n+  --> $DIR/declare_interior_mutable_const.rs:39:5\n    |\n LL |     const ATOMIC: AtomicUsize; //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:44:5\n+  --> $DIR/declare_interior_mutable_const.rs:16:9\n+   |\n+LL |         const $name: $ty = $e;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     declare_const!(ANOTHER_ATOMIC: AtomicUsize = Self::ATOMIC); //~ ERROR interior mutable\n+   |     ----------------------------------------------------------- in this macro invocation\n    |\n-LL |     const INPUT: T;\n-   |     ^^^^^^^^^^^^^-^\n-   |                  |\n-   |                  consider requiring `T` to be `Copy`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:47:5\n+  --> $DIR/declare_interior_mutable_const.rs:67:5\n    |\n-LL |     const ASSOC: Self::NonCopyType;\n-   |     ^^^^^^^^^^^^^-----------------^\n-   |                  |\n-   |                  consider requiring `<Self as Trait<T>>::NonCopyType` to be `Copy`\n+LL |     const TO_BE_CONCRETE: AtomicUsize = AtomicUsize::new(11); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:51:5\n+  --> $DIR/declare_interior_mutable_const.rs:92:5\n    |\n-LL |     const AN_INPUT: T = Self::INPUT;\n-   |     ^^^^^^^^^^^^^^^^-^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     consider requiring `T` to be `Copy`\n+LL |     const TO_BE_UNFROZEN: Self::ToBeUnfrozen = AtomicUsize::new(13); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:16:9\n+  --> $DIR/declare_interior_mutable_const.rs:93:5\n    |\n-LL |         const $name: $ty = $e;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^\n-...\n-LL |     declare_const!(ANOTHER_INPUT: T = Self::INPUT); //~ ERROR interior mutable\n-   |     ----------------------------------------------- in this macro invocation\n+LL |     const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen> = Wrapper(AtomicUsize::new(14)); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/declare_interior_mutable_const.rs:112:5\n    |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL |     const BOUNDED: T::ToBeBounded; //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/declare_interior_mutable_const.rs:140:5\n+   |\n+LL |     const SELF: Self = AtomicUsize::new(17); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:60:5\n+  --> $DIR/declare_interior_mutable_const.rs:141:5\n    |\n-LL |     const SELF_2: Self;\n-   |     ^^^^^^^^^^^^^^----^\n-   |                   |\n-   |                   consider requiring `Self` to be `Copy`\n+LL |     const WRAPPED_SELF: Option<Self> = Some(AtomicUsize::new(21)); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:81:5\n+  --> $DIR/declare_interior_mutable_const.rs:149:5\n    |\n-LL |     const ASSOC_3: AtomicUsize = AtomicUsize::new(14); //~ ERROR interior mutable\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     const INDIRECT: Cell<*const T>; //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:84:5\n+  --> $DIR/declare_interior_mutable_const.rs:165:5\n    |\n-LL |     const U_SELF: U = U::SELF_2;\n-   |     ^^^^^^^^^^^^^^-^^^^^^^^^^^^^\n-   |                   |\n-   |                   consider requiring `U` to be `Copy`\n+LL |     const ATOMIC: AtomicUsize = AtomicUsize::new(18); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:87:5\n+  --> $DIR/declare_interior_mutable_const.rs:171:5\n    |\n-LL |     const T_ASSOC: T::NonCopyType = T::ASSOC;\n-   |     ^^^^^^^^^^^^^^^--------------^^^^^^^^^^^^\n-   |                    |\n-   |                    consider requiring `<T as Trait<u32>>::NonCopyType` to be `Copy`\n+LL |     const BOUNDED_ASSOC_TYPE: T::ToBeBounded = AtomicUsize::new(19); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 15 previous errors\n "}]}