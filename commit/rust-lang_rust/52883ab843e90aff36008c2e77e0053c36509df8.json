{"sha": "52883ab843e90aff36008c2e77e0053c36509df8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyODgzYWI4NDNlOTBhZmYzNjAwOGMyZTc3ZTAwNTNjMzY1MDlkZjg=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-12-23T02:57:48Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-12-23T03:07:36Z"}, "message": "BinaryHeap: Use full sift down in .pop()\n\n.sift_down can either choose to compare the element on the way down (and\nplace it during descent), or to sift down an element fully, then sift\nback up to place it.\n\nA previous PR changed .sift_down() to the former behavior, which is much\nfaster for relatively small heaps and for elements that are cheap to\ncompare.\n\nA benchmarking run suggested that BinaryHeap::pop() suffers\nimproportionally from this, and that it should use the second strategy\ninstead. It's logical since .pop() brings last element from the\nheapified vector into index 0, it's very likely that this element will\nend up at the bottom again.", "tree": {"sha": "8ffa2dceb501485573b68dd5cd49f979c33e1f91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ffa2dceb501485573b68dd5cd49f979c33e1f91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52883ab843e90aff36008c2e77e0053c36509df8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52883ab843e90aff36008c2e77e0053c36509df8", "html_url": "https://github.com/rust-lang/rust/commit/52883ab843e90aff36008c2e77e0053c36509df8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52883ab843e90aff36008c2e77e0053c36509df8/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42c3ef8f9fd4b0dd1f881c49323bad456163f202", "url": "https://api.github.com/repos/rust-lang/rust/commits/42c3ef8f9fd4b0dd1f881c49323bad456163f202", "html_url": "https://github.com/rust-lang/rust/commit/42c3ef8f9fd4b0dd1f881c49323bad456163f202"}], "stats": {"total": 27, "additions": 26, "deletions": 1}, "files": [{"sha": "bd329949618e5f4376860f8b3af77db4a041be75", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/52883ab843e90aff36008c2e77e0053c36509df8/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52883ab843e90aff36008c2e77e0053c36509df8/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=52883ab843e90aff36008c2e77e0053c36509df8", "patch": "@@ -354,7 +354,7 @@ impl<T: Ord> BinaryHeap<T> {\n         self.data.pop().map(|mut item| {\n             if !self.is_empty() {\n                 swap(&mut item, &mut self.data[0]);\n-                self.sift_down(0);\n+                self.sift_down_to_bottom(0);\n             }\n             item\n         })\n@@ -545,6 +545,31 @@ impl<T: Ord> BinaryHeap<T> {\n         self.sift_down_range(pos, len);\n     }\n \n+    /// Take an element at `pos` and move it all the way down the heap,\n+    /// then sift it up to its position.\n+    ///\n+    /// Note: This is faster when the element is known to be large / should\n+    /// be closer to the bottom.\n+    fn sift_down_to_bottom(&mut self, mut pos: usize) {\n+        let end = self.len();\n+        let start = pos;\n+        unsafe {\n+            let mut hole = Hole::new(&mut self.data, pos);\n+            let mut child = 2 * pos + 1;\n+            while child < end {\n+                let right = child + 1;\n+                // compare with the greater of the two children\n+                if right < end && !(hole.get(child) > hole.get(right)) {\n+                    child = right;\n+                }\n+                hole.move_to(child);\n+                child = 2 * hole.pos() + 1;\n+            }\n+            pos = hole.pos;\n+        }\n+        self.sift_up(start, pos);\n+    }\n+\n     /// Returns the length of the binary heap.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {"}]}