{"sha": "a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "node_id": "C_kwDOAAsO6NoAKGE4YTMzY2YyNzE2NmQzZWFiYWZmYzU4ZWQzNzk5ZTA1NGFmM2IwYzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T11:39:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T11:39:53Z"}, "message": "Auto merge of #99702 - SparrowLii:transtive_relation, r=oli-obk\n\nget rid of `RefCell` in `TransitiveRelation`\n\nThis is one of the jobs in `Pending refactorings` in #48685. The parallel-compiler's work has been suspended for quite some time, but I think I can pick it up gradually. I think this PR should be a start.\n\nRegarding the refactoring of `TransitiveRelation`, `@nikomatsakis`  has proposed [two(three?) schemes](https://github.com/rust-lang/rust/pull/48587#issuecomment-369336651). In order to satisfy both compilation efficiency and robustness, I think adding the `freeze` method may be the best solution, although it requires relatively more code changes.", "tree": {"sha": "38f1b1f29bc4b05bcf97c9f2c2fb7b3266f4f80d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38f1b1f29bc4b05bcf97c9f2c2fb7b3266f4f80d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "html_url": "https://github.com/rust-lang/rust/commit/a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "html_url": "https://github.com/rust-lang/rust/commit/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b"}, {"sha": "a01ac5a6996f4fad346a6ff07edb197f74612aa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a01ac5a6996f4fad346a6ff07edb197f74612aa8", "html_url": "https://github.com/rust-lang/rust/commit/a01ac5a6996f4fad346a6ff07edb197f74612aa8"}], "stats": {"total": 403, "additions": 224, "deletions": 179}, "files": [{"sha": "7c10047e9dc83c5ddeaa599d1ab4e3c2582b82a2", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -1,5 +1,5 @@\n use rustc_data_structures::frozen::Frozen;\n-use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use rustc_data_structures::transitive_relation::{TransitiveRelation, TransitiveRelationBuilder};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n@@ -61,25 +61,13 @@ pub(crate) fn create<'tcx>(\n         constraints,\n         universal_regions: universal_regions.clone(),\n         region_bound_pairs: Default::default(),\n-        relations: UniversalRegionRelations {\n-            universal_regions: universal_regions.clone(),\n-            outlives: Default::default(),\n-            inverse_outlives: Default::default(),\n-        },\n+        outlives: Default::default(),\n+        inverse_outlives: Default::default(),\n     }\n     .create()\n }\n \n impl UniversalRegionRelations<'_> {\n-    /// Records in the `outlives_relation` (and\n-    /// `inverse_outlives_relation`) that `fr_a: fr_b`. Invoked by the\n-    /// builder below.\n-    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n-        debug!(\"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\", fr_a, fr_b);\n-        self.outlives.add(fr_a, fr_b);\n-        self.inverse_outlives.add(fr_b, fr_a);\n-    }\n-\n     /// Given two universal regions, returns the postdominating\n     /// upper-bound (effectively the least upper bound).\n     ///\n@@ -216,11 +204,20 @@ struct UniversalRegionRelationsBuilder<'this, 'tcx> {\n     constraints: &'this mut MirTypeckRegionConstraints<'tcx>,\n \n     // outputs:\n-    relations: UniversalRegionRelations<'tcx>,\n+    outlives: TransitiveRelationBuilder<RegionVid>,\n+    inverse_outlives: TransitiveRelationBuilder<RegionVid>,\n     region_bound_pairs: RegionBoundPairs<'tcx>,\n }\n \n impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n+    /// Records in the `outlives_relation` (and\n+    /// `inverse_outlives_relation`) that `fr_a: fr_b`.\n+    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n+        debug!(\"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\", fr_a, fr_b);\n+        self.outlives.add(fr_a, fr_b);\n+        self.inverse_outlives.add(fr_b, fr_a);\n+    }\n+\n     pub(crate) fn create(mut self) -> CreateResult<'tcx> {\n         let unnormalized_input_output_tys = self\n             .universal_regions\n@@ -292,9 +289,9 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         let fr_fn_body = self.universal_regions.fr_fn_body;\n         for fr in self.universal_regions.universal_regions() {\n             debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n-            self.relations.relate_universal_regions(fr, fr);\n-            self.relations.relate_universal_regions(fr_static, fr);\n-            self.relations.relate_universal_regions(fr, fr_fn_body);\n+            self.relate_universal_regions(fr, fr);\n+            self.relate_universal_regions(fr_static, fr);\n+            self.relate_universal_regions(fr, fr_fn_body);\n         }\n \n         for data in &constraint_sets {\n@@ -313,7 +310,11 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         }\n \n         CreateResult {\n-            universal_region_relations: Frozen::freeze(self.relations),\n+            universal_region_relations: Frozen::freeze(UniversalRegionRelations {\n+                universal_regions: self.universal_regions,\n+                outlives: self.outlives.freeze(),\n+                inverse_outlives: self.inverse_outlives.freeze(),\n+            }),\n             region_bound_pairs: self.region_bound_pairs,\n             normalized_inputs_and_output,\n         }\n@@ -356,7 +357,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                     // The bound says that `r1 <= r2`; we store `r2: r1`.\n                     let r1 = self.universal_regions.to_region_vid(r1);\n                     let r2 = self.universal_regions.to_region_vid(r2);\n-                    self.relations.relate_universal_regions(r2, r1);\n+                    self.relate_universal_regions(r2, r1);\n                 }\n \n                 OutlivesBound::RegionSubParam(r_a, param_b) => {"}, {"sha": "f016c391fe777cfc83c21e317c080db6440086e2", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 67, "deletions": 54, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -1,45 +1,57 @@\n+use crate::frozen::Frozen;\n use crate::fx::FxIndexSet;\n-use crate::sync::Lock;\n use rustc_index::bit_set::BitMatrix;\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::mem;\n+use std::ops::Deref;\n \n #[cfg(test)]\n mod tests;\n \n #[derive(Clone, Debug)]\n-pub struct TransitiveRelation<T> {\n+pub struct TransitiveRelationBuilder<T> {\n     // List of elements. This is used to map from a T to a usize.\n     elements: FxIndexSet<T>,\n \n     // List of base edges in the graph. Require to compute transitive\n     // closure.\n     edges: Vec<Edge>,\n+}\n+\n+#[derive(Debug)]\n+pub struct TransitiveRelation<T> {\n+    // Frozen transitive relation elements and edges.\n+    builder: Frozen<TransitiveRelationBuilder<T>>,\n \n-    // This is a cached transitive closure derived from the edges.\n-    // Currently, we build it lazily and just throw out any existing\n-    // copy whenever a new edge is added. (The Lock is to permit\n-    // the lazy computation.) This is kind of silly, except for the\n-    // fact its size is tied to `self.elements.len()`, so I wanted to\n-    // wait before building it up to avoid reallocating as new edges\n-    // are added with new elements. Perhaps better would be to ask the\n-    // user for a batch of edges to minimize this effect, but I\n-    // already wrote the code this way. :P -nmatsakis\n-    closure: Lock<Option<BitMatrix<usize, usize>>>,\n+    // Cached transitive closure derived from the edges.\n+    closure: Frozen<BitMatrix<usize, usize>>,\n }\n \n-// HACK(eddyb) manual impl avoids `Default` bound on `T`.\n-impl<T: Eq + Hash> Default for TransitiveRelation<T> {\n-    fn default() -> Self {\n+impl<T> Deref for TransitiveRelation<T> {\n+    type Target = Frozen<TransitiveRelationBuilder<T>>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.builder\n+    }\n+}\n+\n+impl<T: Clone> Clone for TransitiveRelation<T> {\n+    fn clone(&self) -> Self {\n         TransitiveRelation {\n-            elements: Default::default(),\n-            edges: Default::default(),\n-            closure: Default::default(),\n+            builder: Frozen::freeze(self.builder.deref().clone()),\n+            closure: Frozen::freeze(self.closure.deref().clone()),\n         }\n     }\n }\n \n+// HACK(eddyb) manual impl avoids `Default` bound on `T`.\n+impl<T: Eq + Hash> Default for TransitiveRelationBuilder<T> {\n+    fn default() -> Self {\n+        TransitiveRelationBuilder { elements: Default::default(), edges: Default::default() }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n struct Index(usize);\n \n@@ -49,7 +61,7 @@ struct Edge {\n     target: Index,\n }\n \n-impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n+impl<T: Eq + Hash + Copy> TransitiveRelationBuilder<T> {\n     pub fn is_empty(&self) -> bool {\n         self.edges.is_empty()\n     }\n@@ -63,23 +75,19 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n     }\n \n     fn add_index(&mut self, a: T) -> Index {\n-        let (index, added) = self.elements.insert_full(a);\n-        if added {\n-            // if we changed the dimensions, clear the cache\n-            *self.closure.get_mut() = None;\n-        }\n+        let (index, _added) = self.elements.insert_full(a);\n         Index(index)\n     }\n \n     /// Applies the (partial) function to each edge and returns a new\n-    /// relation. If `f` returns `None` for any end-point, returns\n-    /// `None`.\n-    pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelation<U>>\n+    /// relation builder. If `f` returns `None` for any end-point,\n+    /// returns `None`.\n+    pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelationBuilder<U>>\n     where\n         F: FnMut(T) -> Option<U>,\n         U: Clone + Debug + Eq + Hash + Copy,\n     {\n-        let mut result = TransitiveRelation::default();\n+        let mut result = TransitiveRelationBuilder::default();\n         for edge in &self.edges {\n             result.add(f(self.elements[edge.source.0])?, f(self.elements[edge.target.0])?);\n         }\n@@ -93,10 +101,38 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n         let edge = Edge { source: a, target: b };\n         if !self.edges.contains(&edge) {\n             self.edges.push(edge);\n+        }\n+    }\n+\n+    /// Compute the transitive closure derived from the edges, and converted to\n+    /// the final result. After this, all elements will be immutable to maintain\n+    /// the correctness of the result.\n+    pub fn freeze(self) -> TransitiveRelation<T> {\n+        let mut matrix = BitMatrix::new(self.elements.len(), self.elements.len());\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            for edge in &self.edges {\n+                // add an edge from S -> T\n+                changed |= matrix.insert(edge.source.0, edge.target.0);\n \n-            // added an edge, clear the cache\n-            *self.closure.get_mut() = None;\n+                // add all outgoing edges from T into S\n+                changed |= matrix.union_rows(edge.target.0, edge.source.0);\n+            }\n         }\n+        TransitiveRelation { builder: Frozen::freeze(self), closure: Frozen::freeze(matrix) }\n+    }\n+}\n+\n+impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n+    /// Applies the (partial) function to each edge and returns a new\n+    /// relation including transitive closures.\n+    pub fn maybe_map<F, U>(&self, f: F) -> Option<TransitiveRelation<U>>\n+    where\n+        F: FnMut(T) -> Option<U>,\n+        U: Clone + Debug + Eq + Hash + Copy,\n+    {\n+        Some(self.builder.maybe_map(f)?.freeze())\n     }\n \n     /// Checks whether `a < target` (transitively)\n@@ -322,30 +358,7 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n     where\n         OP: FnOnce(&BitMatrix<usize, usize>) -> R,\n     {\n-        let mut closure_cell = self.closure.borrow_mut();\n-        let mut closure = closure_cell.take();\n-        if closure.is_none() {\n-            closure = Some(self.compute_closure());\n-        }\n-        let result = op(closure.as_ref().unwrap());\n-        *closure_cell = closure;\n-        result\n-    }\n-\n-    fn compute_closure(&self) -> BitMatrix<usize, usize> {\n-        let mut matrix = BitMatrix::new(self.elements.len(), self.elements.len());\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-            for edge in &self.edges {\n-                // add an edge from S -> T\n-                changed |= matrix.insert(edge.source.0, edge.target.0);\n-\n-                // add all outgoing edges from T into S\n-                changed |= matrix.union_rows(edge.target.0, edge.source.0);\n-            }\n-        }\n-        matrix\n+        op(&self.closure)\n     }\n \n     /// Lists all the base edges in the graph: the initial _non-transitive_ set of element"}, {"sha": "e756c546e41ba705f0b6fe4a839199acd8633d23", "filename": "compiler/rustc_data_structures/src/transitive_relation/tests.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -10,9 +10,10 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n \n #[test]\n fn test_one_step() {\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"b\");\n     relation.add(\"a\", \"c\");\n+    let relation = relation.freeze();\n     assert!(relation.contains(\"a\", \"c\"));\n     assert!(relation.contains(\"a\", \"b\"));\n     assert!(!relation.contains(\"b\", \"a\"));\n@@ -21,7 +22,7 @@ fn test_one_step() {\n \n #[test]\n fn test_many_steps() {\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"b\");\n     relation.add(\"a\", \"c\");\n     relation.add(\"a\", \"f\");\n@@ -31,6 +32,7 @@ fn test_many_steps() {\n     relation.add(\"b\", \"e\");\n \n     relation.add(\"e\", \"g\");\n+    let relation = relation.freeze();\n \n     assert!(relation.contains(\"a\", \"b\"));\n     assert!(relation.contains(\"a\", \"c\"));\n@@ -51,9 +53,10 @@ fn mubs_triangle() {\n     //      ^\n     //      |\n     //      b\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"tcx\");\n     relation.add(\"b\", \"tcx\");\n+    let relation = relation.freeze();\n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"tcx\"]);\n     assert_eq!(relation.parents(\"a\"), vec![\"tcx\"]);\n     assert_eq!(relation.parents(\"b\"), vec![\"tcx\"]);\n@@ -72,14 +75,15 @@ fn mubs_best_choice1() {\n     // need the second pare down call to get the right result (after\n     // intersection, we have [1, 2], but 2 -> 1).\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n     relation.add(\"2\", \"1\");\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"2\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"2\"]);\n@@ -99,14 +103,15 @@ fn mubs_best_choice2() {\n     // Like the preceding test, but in this case intersection is [2,\n     // 1], and hence we rely on the first pare down call.\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n     relation.add(\"1\", \"2\");\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"1\"]);\n@@ -118,12 +123,13 @@ fn mubs_best_choice2() {\n fn mubs_no_best_choice() {\n     // in this case, the intersection yields [1, 2], and the \"pare\n     // down\" calls find nothing to remove.\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\", \"2\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"1\", \"2\"]);\n@@ -135,7 +141,7 @@ fn mubs_best_choice_scc() {\n     // in this case, 1 and 2 form a cycle; we pick arbitrarily (but\n     // consistently).\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n@@ -144,6 +150,7 @@ fn mubs_best_choice_scc() {\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"1\"]);\n@@ -157,13 +164,14 @@ fn pdub_crisscross() {\n     //   /\\       |\n     // b -> b1 ---+\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"a1\");\n     relation.add(\"a\", \"b1\");\n     relation.add(\"b\", \"a1\");\n     relation.add(\"b\", \"b1\");\n     relation.add(\"a1\", \"x\");\n     relation.add(\"b1\", \"x\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"a1\", \"b1\"]);\n     assert_eq!(relation.postdom_upper_bound(\"a\", \"b\"), Some(\"x\"));\n@@ -179,7 +187,7 @@ fn pdub_crisscross_more() {\n     //   /\\    /\\             |\n     // b -> b1 -> b2 ---------+\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"a1\");\n     relation.add(\"a\", \"b1\");\n     relation.add(\"b\", \"a1\");\n@@ -194,6 +202,7 @@ fn pdub_crisscross_more() {\n \n     relation.add(\"a3\", \"x\");\n     relation.add(\"b2\", \"x\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"a1\", \"b1\"]);\n     assert_eq!(relation.minimal_upper_bounds(\"a1\", \"b1\"), vec![\"a2\", \"b2\"]);\n@@ -210,11 +219,12 @@ fn pdub_lub() {\n     //            |\n     // b -> b1 ---+\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"a1\");\n     relation.add(\"b\", \"b1\");\n     relation.add(\"a1\", \"x\");\n     relation.add(\"b1\", \"x\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"x\"]);\n     assert_eq!(relation.postdom_upper_bound(\"a\", \"b\"), Some(\"x\"));\n@@ -233,10 +243,11 @@ fn mubs_intermediate_node_on_one_side_only() {\n     //           b\n \n     // \"digraph { a -> c -> d; b -> d; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"b\", \"d\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"d\"]);\n }\n@@ -252,12 +263,13 @@ fn mubs_scc_1() {\n     //           b\n \n     // \"digraph { a -> c -> d; d -> c; a -> d; b -> d; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"c\");\n     relation.add(\"a\", \"d\");\n     relation.add(\"b\", \"d\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -272,12 +284,13 @@ fn mubs_scc_2() {\n     //      +--- b\n \n     // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"c\");\n     relation.add(\"b\", \"d\");\n     relation.add(\"b\", \"c\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -292,13 +305,14 @@ fn mubs_scc_3() {\n     //           b ---+\n \n     // \"digraph { a -> c -> d -> e -> c; b -> d; b -> e; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"e\");\n     relation.add(\"e\", \"c\");\n     relation.add(\"b\", \"d\");\n     relation.add(\"b\", \"e\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -314,13 +328,14 @@ fn mubs_scc_4() {\n     //           b ---+\n \n     // \"digraph { a -> c -> d -> e -> c; a -> d; b -> e; }\"\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"e\");\n     relation.add(\"e\", \"c\");\n     relation.add(\"a\", \"d\");\n     relation.add(\"b\", \"e\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -352,10 +367,11 @@ fn parent() {\n         (1, /*->*/ 3),\n     ];\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     for (a, b) in pairs {\n         relation.add(a, b);\n     }\n+    let relation = relation.freeze();\n \n     let p = relation.postdom_parent(3);\n     assert_eq!(p, Some(0));"}, {"sha": "728d691a2be7d27bc42121264409fe23e33a6138", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -27,13 +27,13 @@ impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, Default)]\n+#[derive(Clone, Debug)]\n pub struct FreeRegionMap<'tcx> {\n     // Stores the relation `a < b`, where `a` and `b` are regions.\n     //\n     // Invariant: only free regions like `'x` or `'static` are stored\n     // in this relation, not scopes.\n-    relation: TransitiveRelation<Region<'tcx>>,\n+    pub(crate) relation: TransitiveRelation<Region<'tcx>>,\n }\n \n impl<'tcx> FreeRegionMap<'tcx> {\n@@ -45,15 +45,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         self.relation.is_empty()\n     }\n \n-    // Record that `'sup:'sub`. Or, put another way, `'sub <= 'sup`.\n-    // (with the exception that `'static: 'x` is not notable)\n-    pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n-        debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n-        if sub.is_free_or_static() && sup.is_free() {\n-            self.relation.add(sub, sup)\n-        }\n-    }\n-\n     /// Tests whether `r_a <= r_b`.\n     ///\n     /// Both regions must meet `is_free_or_static`."}, {"sha": "872886da3626108ca370bfb942d650bced1a1775", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -2,6 +2,7 @@ use crate::infer::free_regions::FreeRegionMap;\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxIndexSet;\n+use rustc_data_structures::transitive_relation::TransitiveRelationBuilder;\n use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n \n use super::explicit_outlives_bounds;\n@@ -51,23 +52,48 @@ pub struct OutlivesEnvironment<'tcx> {\n     region_bound_pairs: RegionBoundPairs<'tcx>,\n }\n \n+/// Builder of OutlivesEnvironment.\n+struct OutlivesEnvironmentBuilder<'tcx> {\n+    param_env: ty::ParamEnv<'tcx>,\n+    region_relation: TransitiveRelationBuilder<Region<'tcx>>,\n+    region_bound_pairs: RegionBoundPairs<'tcx>,\n+}\n+\n /// \"Region-bound pairs\" tracks outlives relations that are known to\n /// be true, either because of explicit where-clauses like `T: 'a` or\n /// because of implied bounds.\n pub type RegionBoundPairs<'tcx> =\n     FxIndexSet<ty::OutlivesPredicate<GenericKind<'tcx>, Region<'tcx>>>;\n \n-impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n-    pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n-        let mut env = OutlivesEnvironment {\n+impl<'tcx> OutlivesEnvironment<'tcx> {\n+    /// Create a builder using `ParamEnv` and add explicit outlives bounds into it.\n+    fn builder(param_env: ty::ParamEnv<'tcx>) -> OutlivesEnvironmentBuilder<'tcx> {\n+        let mut builder = OutlivesEnvironmentBuilder {\n             param_env,\n-            free_region_map: Default::default(),\n+            region_relation: Default::default(),\n             region_bound_pairs: Default::default(),\n         };\n \n-        env.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n+        builder.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n \n-        env\n+        builder\n+    }\n+\n+    #[inline]\n+    /// Create a new `OutlivesEnvironment` without extra outlives bounds.\n+    pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n+        Self::builder(param_env).build()\n+    }\n+\n+    /// Create a new `OutlivesEnvironment` with extra outlives bounds.\n+    pub fn with_bounds<'a>(\n+        param_env: ty::ParamEnv<'tcx>,\n+        infcx: Option<&InferCtxt<'a, 'tcx>>,\n+        extra_bounds: impl IntoIterator<Item = OutlivesBound<'tcx>>,\n+    ) -> Self {\n+        let mut builder = Self::builder(param_env);\n+        builder.add_outlives_bounds(infcx, extra_bounds);\n+        builder.build()\n     }\n \n     /// Borrows current value of the `free_region_map`.\n@@ -79,18 +105,26 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n     pub fn region_bound_pairs(&self) -> &RegionBoundPairs<'tcx> {\n         &self.region_bound_pairs\n     }\n+}\n+\n+impl<'a, 'tcx> OutlivesEnvironmentBuilder<'tcx> {\n+    #[inline]\n+    fn build(self) -> OutlivesEnvironment<'tcx> {\n+        OutlivesEnvironment {\n+            param_env: self.param_env,\n+            free_region_map: FreeRegionMap { relation: self.region_relation.freeze() },\n+            region_bound_pairs: self.region_bound_pairs,\n+        }\n+    }\n \n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n     ///\n     /// The `infcx` parameter is optional; if the implied bounds may\n     /// contain inference variables, it must be supplied, in which\n     /// case we will register \"givens\" on the inference context. (See\n     /// `RegionConstraintData`.)\n-    pub fn add_outlives_bounds<I>(\n-        &mut self,\n-        infcx: Option<&InferCtxt<'a, 'tcx>>,\n-        outlives_bounds: I,\n-    ) where\n+    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'a, 'tcx>>, outlives_bounds: I)\n+    where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n         // Record relationships such as `T:'x` that don't go into the\n@@ -122,7 +156,9 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n                         // system to be more general and to make use\n                         // of *every* relationship that arises here,\n                         // but presently we do not.)\n-                        self.free_region_map.relate_regions(r_a, r_b);\n+                        if r_a.is_free_or_static() && r_b.is_free() {\n+                            self.region_relation.add(r_a, r_b)\n+                        }\n                     }\n                 }\n             }"}, {"sha": "d9aff94fef2f9f28ddd97ebb01a6528d40a7f038", "filename": "compiler/rustc_mir_dataflow/src/framework/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fmod.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -256,6 +256,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     ///     .iterate_to_fixpoint()\n     ///     .into_results_cursor(body);\n     /// ```\n+    #[inline]\n     fn into_engine<'mir>(\n         self,\n         tcx: TyCtxt<'tcx>,\n@@ -413,7 +414,7 @@ where\n     }\n \n     /* Extension methods */\n-\n+    #[inline]\n     fn into_engine<'mir>(\n         self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "dfef924f6993a568478d3ce864ac609a8da0f3b9", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -1,6 +1,6 @@\n use super::potentially_plural_count;\n-use crate::check::regionck::OutlivesEnvironmentExt;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n+use crate::outlives::outlives_bounds::InferCtxtExt as _;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n use rustc_hir as hir;\n@@ -401,8 +401,11 @@ fn compare_predicate_entailment<'tcx>(\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(infcx, wf_tys, impl_m_hir_id);\n+        let outlives_environment = OutlivesEnvironment::with_bounds(\n+            param_env,\n+            Some(infcx),\n+            infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n+        );\n         infcx.check_region_obligations_and_report_errors(\n             impl_m.def_id.expect_local(),\n             &outlives_environment,\n@@ -1513,8 +1516,10 @@ pub fn check_type_bounds<'tcx>(\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(&infcx, assumed_wf_types, impl_ty_hir_id);\n+        let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_hir_id, assumed_wf_types);\n+        let outlives_environment =\n+            OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n+\n         infcx.check_region_obligations_and_report_errors(\n             impl_ty.def_id.expect_local(),\n             &outlives_environment,"}, {"sha": "fb675212e3ffb4607215ddc7ff0f9003f2e63e87", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -87,7 +87,6 @@ mod op;\n mod pat;\n mod place_op;\n mod region;\n-pub mod regionck;\n pub mod rvalue_scopes;\n mod upvar;\n pub mod wfcheck;"}, {"sha": "d49a6138f7a0271128718b66884f982da012d198", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c31e64d229cac4eba6d8f03bb70e16f34a14b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=ee8c31e64d229cac4eba6d8f03bb70e16f34a14b", "patch": "@@ -1,47 +0,0 @@\n-use crate::outlives::outlives_bounds::InferCtxtExt as _;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir as hir;\n-use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::InferCtxt;\n-use rustc_middle::ty::Ty;\n-\n-pub(crate) trait OutlivesEnvironmentExt<'tcx> {\n-    fn add_implied_bounds(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        fn_sig_tys: FxHashSet<Ty<'tcx>>,\n-        body_id: hir::HirId,\n-    );\n-}\n-\n-impl<'tcx> OutlivesEnvironmentExt<'tcx> for OutlivesEnvironment<'tcx> {\n-    /// This method adds \"implied bounds\" into the outlives environment.\n-    /// Implied bounds are outlives relationships that we can deduce\n-    /// on the basis that certain types must be well-formed -- these are\n-    /// either the types that appear in the function signature or else\n-    /// the input types to an impl. For example, if you have a function\n-    /// like\n-    ///\n-    /// ```\n-    /// fn foo<'a, 'b, T>(x: &'a &'b [T]) { }\n-    /// ```\n-    ///\n-    /// we can assume in the caller's body that `'b: 'a` and that `T:\n-    /// 'b` (and hence, transitively, that `T: 'a`). This method would\n-    /// add those assumptions into the outlives-environment.\n-    ///\n-    /// Tests: `src/test/ui/regions/regions-free-region-ordering-*.rs`\n-    #[instrument(level = \"debug\", skip(self, infcx))]\n-    fn add_implied_bounds<'a>(\n-        &mut self,\n-        infcx: &InferCtxt<'a, 'tcx>,\n-        fn_sig_tys: FxHashSet<Ty<'tcx>>,\n-        body_id: hir::HirId,\n-    ) {\n-        for ty in fn_sig_tys {\n-            let ty = infcx.resolve_vars_if_possible(ty);\n-            let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty);\n-            self.add_outlives_bounds(Some(infcx), implied_bounds)\n-        }\n-    }\n-}"}, {"sha": "b4b6fe8eeada3bd569e502b1efec9b91b20ab118", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -1,5 +1,5 @@\n-use crate::check::regionck::OutlivesEnvironmentExt;\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n+use crate::outlives::outlives_bounds::InferCtxtExt as _;\n use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n@@ -104,8 +104,10 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n             return;\n         }\n \n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(infcx, assumed_wf_types, body_id);\n+        let implied_bounds = infcx.implied_bounds_tys(param_env, body_id, assumed_wf_types);\n+        let outlives_environment =\n+            OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+\n         infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n     })\n }\n@@ -694,8 +696,11 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     // region constraints get added and solved there and we need to test each\n     // call individually.\n     tcx.infer_ctxt().enter(|infcx| {\n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id);\n+        let outlives_environment = OutlivesEnvironment::with_bounds(\n+            param_env,\n+            Some(&infcx),\n+            infcx.implied_bounds_tys(param_env, id, wf_tys.clone()),\n+        );\n         let region_bound_pairs = outlives_environment.region_bound_pairs();\n \n         add_constraints(&infcx, region_bound_pairs);"}, {"sha": "6240024d49c74eb47c2eae2952f37a23eb667c18", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -65,9 +65,9 @@\n //! cause use after frees with purely safe code in the same way as specializing\n //! on traits with methods can.\n \n-use crate::check::regionck::OutlivesEnvironmentExt;\n use crate::constrained_generic_params as cgp;\n use crate::errors::SubstsOnOverriddenImpl;\n+use crate::outlives::outlives_bounds::InferCtxtExt as _;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -157,8 +157,8 @@ fn get_impl_substs<'tcx>(\n             return None;\n         }\n \n-        let mut outlives_env = OutlivesEnvironment::new(param_env);\n-        outlives_env.add_implied_bounds(infcx, assumed_wf_types, impl1_hir_id);\n+        let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_hir_id, assumed_wf_types);\n+        let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n         infcx.check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n         let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n             let span = tcx.def_span(impl1_def_id);"}, {"sha": "1ff9c6271316ab3afecb10400857c57a0341ffc6", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -72,6 +72,7 @@ This API is completely unstable and subject to change.\n #![feature(slice_partition_dedup)]\n #![feature(try_blocks)]\n #![feature(is_some_with)]\n+#![feature(type_alias_impl_trait)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "024e20d92234b6ab36ee3820586a70769031721e", "filename": "compiler/rustc_typeck/src/outlives/outlives_bounds.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a33cf27166d3eabaffc58ed3799e054af3b0c6/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs?ref=a8a33cf27166d3eabaffc58ed3799e054af3b0c6", "patch": "@@ -1,22 +1,32 @@\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_hir::HirId;\n+use rustc_middle::ty::{self, ParamEnv, Ty};\n use rustc_trait_selection::infer::InferCtxt;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use rustc_trait_selection::traits::query::NoSolution;\n use rustc_trait_selection::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n \n pub use rustc_middle::traits::query::OutlivesBound;\n \n-pub trait InferCtxtExt<'tcx> {\n+type Bounds<'a, 'tcx: 'a> = impl Iterator<Item = OutlivesBound<'tcx>> + 'a;\n+pub trait InferCtxtExt<'a, 'tcx> {\n     fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         body_id: hir::HirId,\n         ty: Ty<'tcx>,\n     ) -> Vec<OutlivesBound<'tcx>>;\n+\n+    fn implied_bounds_tys(\n+        &'a self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: hir::HirId,\n+        tys: FxHashSet<Ty<'tcx>>,\n+    ) -> Bounds<'a, 'tcx>;\n }\n \n-impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n+impl<'a, 'cx, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'cx, 'tcx> {\n     /// Implied bounds are region relationships that we deduce\n     /// automatically. The idea is that (e.g.) a caller must check that a\n     /// function's argument types are well-formed immediately before\n@@ -87,4 +97,18 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n \n         output\n     }\n+\n+    fn implied_bounds_tys(\n+        &'a self,\n+        param_env: ParamEnv<'tcx>,\n+        body_id: HirId,\n+        tys: FxHashSet<Ty<'tcx>>,\n+    ) -> Bounds<'a, 'tcx> {\n+        tys.into_iter()\n+            .map(move |ty| {\n+                let ty = self.resolve_vars_if_possible(ty);\n+                self.implied_outlives_bounds(param_env, body_id, ty)\n+            })\n+            .flatten()\n+    }\n }"}]}