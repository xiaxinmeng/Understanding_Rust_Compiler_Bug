{"sha": "953c4dcc30636d477505f4e397c63d57a760dffa", "node_id": "C_kwDOAAsO6NoAKDk1M2M0ZGNjMzA2MzZkNDc3NTA1ZjRlMzk3YzYzZDU3YTc2MGRmZmE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-13T05:44:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-13T05:44:13Z"}, "message": "Rollup merge of #90532 - fee1-dead:improve-const-fn-err-msg, r=oli-obk\n\nMore informative error message for E0015\n\nHelps with #92380", "tree": {"sha": "d879dcce54156abd6bc27925d2ddd6da4d291ea0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d879dcce54156abd6bc27925d2ddd6da4d291ea0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/953c4dcc30636d477505f4e397c63d57a760dffa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiCJqtCRBK7hj4Ov3rIwAAa38IAKW4JRxX0Cnn5DvACB4Yz9zM\nS6pQkYgFh+U6yu9RmKGfetZrBtJucw0XiQX4yzg9XnLPpfm0nF1FfsOzB/6QAJ/Q\nWJXifHGpDWg7pXwEWrhekt3jErnbhdskyHTFKyrsk4XMLJgHbADk9Am4MdWTDYgS\nrBSruscFv7sipOuHrqc0eJANXLaoTZGko74/4XhJsjwYgVxh7xt+imkLSjlo7jLR\nhWZRZjiIYRCYCt/0IJQ19aPSjq509/AB5Ancz119dM2AbRmypnwotgFYu8mrucGG\nFI4/47i1bJ1GkwifZ4Qv7GavrqRrvVc2TxgsYPCnXWiAvIbtImX910p0agKhu+k=\n=+8QE\n-----END PGP SIGNATURE-----\n", "payload": "tree d879dcce54156abd6bc27925d2ddd6da4d291ea0\nparent 92613a25fc2c3a8f563025050c082f49b8a38019\nparent 88d433e56fb6b9d94780e03d325d0f4d5260546a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1644731053 +0100\ncommitter GitHub <noreply@github.com> 1644731053 +0100\n\nRollup merge of #90532 - fee1-dead:improve-const-fn-err-msg, r=oli-obk\n\nMore informative error message for E0015\n\nHelps with #92380\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/953c4dcc30636d477505f4e397c63d57a760dffa", "html_url": "https://github.com/rust-lang/rust/commit/953c4dcc30636d477505f4e397c63d57a760dffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/953c4dcc30636d477505f4e397c63d57a760dffa/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92613a25fc2c3a8f563025050c082f49b8a38019", "url": "https://api.github.com/repos/rust-lang/rust/commits/92613a25fc2c3a8f563025050c082f49b8a38019", "html_url": "https://github.com/rust-lang/rust/commit/92613a25fc2c3a8f563025050c082f49b8a38019"}, {"sha": "88d433e56fb6b9d94780e03d325d0f4d5260546a", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d433e56fb6b9d94780e03d325d0f4d5260546a", "html_url": "https://github.com/rust-lang/rust/commit/88d433e56fb6b9d94780e03d325d0f4d5260546a"}], "stats": {"total": 1303, "additions": 896, "deletions": 407}, "files": [{"sha": "f6d21f879ff5868e75e09ddd00c9ba47bb9b7cf2", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,4 +1,5 @@\n use either::Either;\n+use rustc_const_eval::util::{CallDesugaringKind, CallKind};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -26,7 +27,7 @@ use crate::{\n \n use super::{\n     explain_borrow::{BorrowExplanation, LaterUseKind},\n-    FnSelfUseKind, IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n+    IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n };\n \n #[derive(Debug)]\n@@ -195,7 +196,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         .map(|n| format!(\"`{}`\", n))\n                         .unwrap_or_else(|| \"value\".to_owned());\n                     match kind {\n-                        FnSelfUseKind::FnOnceCall => {\n+                        CallKind::FnCall { fn_trait_id, .. }\n+                            if Some(fn_trait_id) == self.infcx.tcx.lang_items().fn_once_trait() =>\n+                        {\n                             err.span_label(\n                                 fn_call_span,\n                                 &format!(\n@@ -208,7 +211,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 \"this value implements `FnOnce`, which causes it to be moved when called\",\n                             );\n                         }\n-                        FnSelfUseKind::Operator { self_arg } => {\n+                        CallKind::Operator { self_arg, .. } => {\n+                            let self_arg = self_arg.unwrap();\n                             err.span_label(\n                                 fn_call_span,\n                                 &format!(\n@@ -235,12 +239,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 );\n                             }\n                         }\n-                        FnSelfUseKind::Normal {\n-                            self_arg,\n-                            implicit_into_iter,\n-                            is_option_or_result,\n-                        } => {\n-                            if implicit_into_iter {\n+                        CallKind::Normal { self_arg, desugaring, is_option_or_result } => {\n+                            let self_arg = self_arg.unwrap();\n+                            if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n                                 err.span_label(\n                                     fn_call_span,\n                                     &format!(\n@@ -305,8 +306,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     );\n                             }\n                         }\n-                        // Deref::deref takes &self, which cannot cause a move\n-                        FnSelfUseKind::DerefCoercion { .. } => unreachable!(),\n+                        // Other desugarings takes &self, which cannot cause a move\n+                        _ => unreachable!(),\n                     }\n                 } else {\n                     err.span_label(\n@@ -433,7 +434,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             if let UseSpans::FnSelfUse {\n-                kind: FnSelfUseKind::DerefCoercion { deref_target, deref_target_ty },\n+                kind: CallKind::DerefCoercion { deref_target, deref_target_ty, .. },\n                 ..\n             } = use_spans\n             {"}, {"sha": "4400fed13b741ef8abe5339941f2183f44083747", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 22, "deletions": 93, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,10 +1,10 @@\n //! Borrow checker diagnostics.\n \n+use rustc_const_eval::util::call_kind;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::LangItemGroup;\n use rustc_hir::GeneratorKind;\n use rustc_middle::mir::{\n     AggregateKind, Constant, FakeReadCause, Field, Local, LocalInfo, LocalKind, Location, Operand,\n@@ -13,7 +13,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n-use rustc_span::{hygiene::DesugaringKind, symbol::sym, Span};\n+use rustc_span::{symbol::sym, Span};\n use rustc_target::abi::VariantIdx;\n \n use super::borrow_set::BorrowData;\n@@ -37,7 +37,7 @@ crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n crate use region_name::{RegionName, RegionNameSource};\n-use rustc_span::symbol::Ident;\n+crate use rustc_const_eval::util::CallKind;\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -563,46 +563,23 @@ pub(super) enum UseSpans<'tcx> {\n         fn_call_span: Span,\n         /// The definition span of the method being called\n         fn_span: Span,\n-        kind: FnSelfUseKind<'tcx>,\n+        kind: CallKind<'tcx>,\n     },\n     /// This access is caused by a `match` or `if let` pattern.\n     PatUse(Span),\n     /// This access has a single span associated to it: common case.\n     OtherUse(Span),\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub(super) enum FnSelfUseKind<'tcx> {\n-    /// A normal method call of the form `receiver.foo(a, b, c)`\n-    Normal {\n-        self_arg: Ident,\n-        implicit_into_iter: bool,\n-        /// Whether the self type of the method call has an `.as_ref()` method.\n-        /// Used for better diagnostics.\n-        is_option_or_result: bool,\n-    },\n-    /// A call to `FnOnce::call_once`, desugared from `my_closure(a, b, c)`\n-    FnOnceCall,\n-    /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n-    Operator { self_arg: Ident },\n-    DerefCoercion {\n-        /// The `Span` of the `Target` associated type\n-        /// in the `Deref` impl we are using.\n-        deref_target: Span,\n-        /// The type `T::Deref` we are dereferencing to\n-        deref_target_ty: Ty<'tcx>,\n-    },\n-}\n-\n impl UseSpans<'_> {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n             UseSpans::ClosureUse { args_span: span, .. }\n             | UseSpans::PatUse(span)\n             | UseSpans::OtherUse(span) => span,\n-            UseSpans::FnSelfUse {\n-                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n-            } => fn_call_span,\n+            UseSpans::FnSelfUse { fn_call_span, kind: CallKind::DerefCoercion { .. }, .. } => {\n+                fn_call_span\n+            }\n             UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n@@ -613,9 +590,9 @@ impl UseSpans<'_> {\n             UseSpans::ClosureUse { path_span: span, .. }\n             | UseSpans::PatUse(span)\n             | UseSpans::OtherUse(span) => span,\n-            UseSpans::FnSelfUse {\n-                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n-            } => fn_call_span,\n+            UseSpans::FnSelfUse { fn_call_span, kind: CallKind::DerefCoercion { .. }, .. } => {\n+                fn_call_span\n+            }\n             UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n@@ -626,9 +603,9 @@ impl UseSpans<'_> {\n             UseSpans::ClosureUse { capture_kind_span: span, .. }\n             | UseSpans::PatUse(span)\n             | UseSpans::OtherUse(span) => span,\n-            UseSpans::FnSelfUse {\n-                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n-            } => fn_call_span,\n+            UseSpans::FnSelfUse { fn_call_span, kind: CallKind::DerefCoercion { .. }, .. } => {\n+                fn_call_span\n+            }\n             UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n@@ -904,67 +881,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 return normal_ret;\n             };\n \n-            let tcx = self.infcx.tcx;\n-            let parent = tcx.parent(method_did);\n-            let is_fn_once = parent == tcx.lang_items().fn_once_trait();\n-            let is_operator = !from_hir_call\n-                && parent.map_or(false, |p| tcx.lang_items().group(LangItemGroup::Op).contains(&p));\n-            let is_deref = !from_hir_call && tcx.is_diagnostic_item(sym::deref_method, method_did);\n-            let fn_call_span = *fn_span;\n-\n-            let self_arg = tcx.fn_arg_names(method_did)[0];\n-\n-            debug!(\n-                \"terminator = {:?} from_hir_call={:?}\",\n-                self.body[location.block].terminator, from_hir_call\n+            let kind = call_kind(\n+                self.infcx.tcx,\n+                self.param_env,\n+                method_did,\n+                method_substs,\n+                *fn_span,\n+                *from_hir_call,\n+                Some(self.infcx.tcx.fn_arg_names(method_did)[0]),\n             );\n \n-            // Check for a 'special' use of 'self' -\n-            // an FnOnce call, an operator (e.g. `<<`), or a\n-            // deref coercion.\n-            let kind = if is_fn_once {\n-                Some(FnSelfUseKind::FnOnceCall)\n-            } else if is_operator {\n-                Some(FnSelfUseKind::Operator { self_arg })\n-            } else if is_deref {\n-                let deref_target =\n-                    tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {\n-                        Instance::resolve(tcx, self.param_env, deref_target, method_substs)\n-                            .transpose()\n-                    });\n-                if let Some(Ok(instance)) = deref_target {\n-                    let deref_target_ty = instance.ty(tcx, self.param_env);\n-                    Some(FnSelfUseKind::DerefCoercion {\n-                        deref_target: tcx.def_span(instance.def_id()),\n-                        deref_target_ty,\n-                    })\n-                } else {\n-                    None\n-                }\n-            } else {\n-                None\n-            };\n-\n-            let kind = kind.unwrap_or_else(|| {\n-                // This isn't a 'special' use of `self`\n-                debug!(\"move_spans: method_did={:?}, fn_call_span={:?}\", method_did, fn_call_span);\n-                let implicit_into_iter = Some(method_did) == tcx.lang_items().into_iter_fn()\n-                    && fn_call_span.desugaring_kind() == Some(DesugaringKind::ForLoop);\n-                let parent_self_ty = parent\n-                    .filter(|did| tcx.def_kind(*did) == rustc_hir::def::DefKind::Impl)\n-                    .and_then(|did| match tcx.type_of(did).kind() {\n-                        ty::Adt(def, ..) => Some(def.did),\n-                        _ => None,\n-                    });\n-                let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n-                    matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n-                });\n-                FnSelfUseKind::Normal { self_arg, implicit_into_iter, is_option_or_result }\n-            });\n-\n             return FnSelfUse {\n                 var_span: stmt.source_info.span,\n-                fn_call_span,\n+                fn_call_span: *fn_span,\n                 fn_span: self\n                     .infcx\n                     .tcx"}, {"sha": "b33b779eddaddb30f49f6b4fda8d0d112d45595a", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,3 +1,4 @@\n+use rustc_const_eval::util::CallDesugaringKind;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::*;\n@@ -8,7 +9,7 @@ use rustc_mir_dataflow::move_paths::{\n use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions;\n \n-use crate::diagnostics::{FnSelfUseKind, UseSpans};\n+use crate::diagnostics::{CallKind, UseSpans};\n use crate::prefixes::PrefixSet;\n use crate::MirBorrowckCtxt;\n \n@@ -410,7 +411,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 Applicability::MaybeIncorrect,\n             );\n         } else if let Some(UseSpans::FnSelfUse {\n-            kind: FnSelfUseKind::Normal { implicit_into_iter: true, .. },\n+            kind:\n+                CallKind::Normal { desugaring: Some((CallDesugaringKind::ForLoopIntoIter, _)), .. },\n             ..\n         }) = use_spans\n         {"}, {"sha": "095c8f84f41adb28eb8e1c3e97f7651fb1d19f1f", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 71, "deletions": 25, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty,\n use rustc_middle::ty::{Binder, TraitPredicate, TraitRef};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::SelectionContext;\n \n use std::mem;\n@@ -293,13 +294,13 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n     }\n \n     /// Emits an error if an expression cannot be evaluated in the current context.\n-    pub fn check_op(&mut self, op: impl NonConstOp) {\n+    pub fn check_op(&mut self, op: impl NonConstOp<'tcx>) {\n         self.check_op_spanned(op, self.span);\n     }\n \n     /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n     /// context.\n-    pub fn check_op_spanned<O: NonConstOp>(&mut self, op: O, span: Span) {\n+    pub fn check_op_spanned<O: NonConstOp<'tcx>>(&mut self, op: O, span: Span) {\n         let gate = match op.status_in_item(self.ccx) {\n             Status::Allowed => return,\n \n@@ -773,7 +774,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n         self.super_terminator(terminator, location);\n \n         match &terminator.kind {\n-            TerminatorKind::Call { func, args, .. } => {\n+            TerminatorKind::Call { func, args, fn_span, from_hir_call, .. } => {\n                 let ConstCx { tcx, body, param_env, .. } = *self.ccx;\n                 let caller = self.def_id().to_def_id();\n \n@@ -797,20 +798,24 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 if let Some(trait_id) = tcx.trait_of_item(callee) {\n                     trace!(\"attempting to call a trait method\");\n                     if !self.tcx.features().const_trait_impl {\n-                        self.check_op(ops::FnCallNonConst(Some((callee, substs))));\n+                        self.check_op(ops::FnCallNonConst {\n+                            caller,\n+                            callee,\n+                            substs,\n+                            span: *fn_span,\n+                            from_hir_call: *from_hir_call,\n+                        });\n                         return;\n                     }\n \n                     let trait_ref = TraitRef::from_method(tcx, trait_id, substs);\n-                    let obligation = Obligation::new(\n-                        ObligationCause::dummy(),\n-                        param_env,\n-                        Binder::dummy(TraitPredicate {\n-                            trait_ref,\n-                            constness: ty::BoundConstness::NotConst,\n-                            polarity: ty::ImplPolarity::Positive,\n-                        }),\n-                    );\n+                    let poly_trait_pred = Binder::dummy(TraitPredicate {\n+                        trait_ref,\n+                        constness: ty::BoundConstness::ConstIfConst,\n+                        polarity: ty::ImplPolarity::Positive,\n+                    });\n+                    let obligation =\n+                        Obligation::new(ObligationCause::dummy(), param_env, poly_trait_pred);\n \n                     let implsrc = tcx.infer_ctxt().enter(|infcx| {\n                         let mut selcx = SelectionContext::new(&infcx);\n@@ -826,10 +831,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             return;\n                         }\n                         Ok(Some(ImplSource::UserDefined(data))) => {\n-                            if let hir::Constness::NotConst = tcx.impl_constness(data.impl_def_id) {\n-                                self.check_op(ops::FnCallNonConst(None));\n-                                return;\n-                            }\n                             let callee_name = tcx.item_name(callee);\n                             if let Some(&did) = tcx\n                                 .associated_item_def_ids(data.impl_def_id)\n@@ -841,22 +842,61 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                                 substs = InternalSubsts::identity_for_item(tcx, did);\n                                 callee = did;\n                             }\n+\n+                            if let hir::Constness::NotConst = tcx.impl_constness(data.impl_def_id) {\n+                                self.check_op(ops::FnCallNonConst {\n+                                    caller,\n+                                    callee,\n+                                    substs,\n+                                    span: *fn_span,\n+                                    from_hir_call: *from_hir_call,\n+                                });\n+                                return;\n+                            }\n                         }\n                         _ if !tcx.is_const_fn_raw(callee) => {\n                             // At this point, it is only legal when the caller is marked with\n                             // #[default_method_body_is_const], and the callee is in the same\n                             // trait.\n                             let callee_trait = tcx.trait_of_item(callee);\n-                            if callee_trait.is_some() {\n-                                if tcx.has_attr(caller, sym::default_method_body_is_const) {\n-                                    if tcx.trait_of_item(caller) == callee_trait {\n-                                        nonconst_call_permission = true;\n-                                    }\n-                                }\n+                            if callee_trait.is_some()\n+                                && tcx.has_attr(caller, sym::default_method_body_is_const)\n+                                && callee_trait == tcx.trait_of_item(caller)\n+                                // Can only call methods when it's `<Self as TheTrait>::f`.\n+                                && tcx.types.self_param == substs.type_at(0)\n+                            {\n+                                nonconst_call_permission = true;\n                             }\n \n                             if !nonconst_call_permission {\n-                                self.check_op(ops::FnCallNonConst(None));\n+                                let obligation = Obligation::new(\n+                                    ObligationCause::dummy_with_span(*fn_span),\n+                                    param_env,\n+                                    tcx.mk_predicate(\n+                                        poly_trait_pred.map_bound(ty::PredicateKind::Trait),\n+                                    ),\n+                                );\n+\n+                                // improve diagnostics by showing what failed. Our requirements are stricter this time\n+                                // as we are going to error again anyways.\n+                                tcx.infer_ctxt().enter(|infcx| {\n+                                    if let Err(e) = implsrc {\n+                                        infcx.report_selection_error(\n+                                            obligation.clone(),\n+                                            &obligation,\n+                                            &e,\n+                                            false,\n+                                        );\n+                                    }\n+                                });\n+\n+                                self.check_op(ops::FnCallNonConst {\n+                                    caller,\n+                                    callee,\n+                                    substs,\n+                                    span: *fn_span,\n+                                    from_hir_call: *from_hir_call,\n+                                });\n                                 return;\n                             }\n                         }\n@@ -925,7 +965,13 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     }\n \n                     if !nonconst_call_permission {\n-                        self.check_op(ops::FnCallNonConst(None));\n+                        self.check_op(ops::FnCallNonConst {\n+                            caller,\n+                            callee,\n+                            substs,\n+                            span: *fn_span,\n+                            from_hir_call: *from_hir_call,\n+                        });\n                         return;\n                     }\n                 }"}, {"sha": "519b4c02b61e6bd75f17241eda852620430526d4", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 285, "deletions": 149, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -3,14 +3,22 @@\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::{ImplSource, Obligation, ObligationCause};\n+use rustc_middle::mir;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::{mir, ty::AssocKind};\n+use rustc_middle::ty::{\n+    suggest_constraining_type_param, Adt, Closure, FnDef, FnPtr, Param, TraitPredicate, Ty,\n+};\n+use rustc_middle::ty::{Binder, BoundConstness, ImplPolarity, TraitRef};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n-use rustc_span::{symbol::Ident, Span, Symbol};\n-use rustc_span::{BytePos, Pos};\n+use rustc_span::{BytePos, Pos, Span, Symbol};\n+use rustc_trait_selection::traits::SelectionContext;\n \n use super::ConstCx;\n+use crate::util::{call_kind, CallDesugaringKind, CallKind};\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum Status {\n@@ -29,31 +37,31 @@ pub enum DiagnosticImportance {\n }\n \n /// An operation that is not *always* allowed in a const context.\n-pub trait NonConstOp: std::fmt::Debug {\n+pub trait NonConstOp<'tcx>: std::fmt::Debug {\n     /// Returns an enum indicating whether this operation is allowed within the given item.\n-    fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+    fn status_in_item(&self, _ccx: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Forbidden\n     }\n \n     fn importance(&self) -> DiagnosticImportance {\n         DiagnosticImportance::Primary\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx>;\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx>;\n }\n \n #[derive(Debug)]\n pub struct FloatingPointOp;\n-impl NonConstOp for FloatingPointOp {\n-    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for FloatingPointOp {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n         if ccx.const_kind() == hir::ConstContext::ConstFn {\n             Status::Unstable(sym::const_fn_floating_point_arithmetic)\n         } else {\n             Status::Allowed\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_fn_floating_point_arithmetic,\n@@ -66,77 +74,229 @@ impl NonConstOp for FloatingPointOp {\n /// A function call where the callee is a pointer.\n #[derive(Debug)]\n pub struct FnCallIndirect;\n-impl NonConstOp for FnCallIndirect {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for FnCallIndirect {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         ccx.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\")\n     }\n }\n \n /// A function call where the callee is not marked as `const`.\n-#[derive(Debug)]\n-pub struct FnCallNonConst<'tcx>(pub Option<(DefId, SubstsRef<'tcx>)>);\n-impl<'a> NonConstOp for FnCallNonConst<'a> {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0015,\n-            \"calls in {}s are limited to constant functions, \\\n-             tuple structs and tuple variants\",\n-            ccx.const_kind(),\n-        );\n+#[derive(Debug, Clone, Copy)]\n+pub struct FnCallNonConst<'tcx> {\n+    pub caller: DefId,\n+    pub callee: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    pub span: Span,\n+    pub from_hir_call: bool,\n+}\n \n-        if let FnCallNonConst(Some((callee, substs))) = *self {\n-            if let Some(trait_def_id) = ccx.tcx.lang_items().eq_trait() {\n-                if let Some(eq_item) = ccx.tcx.associated_items(trait_def_id).find_by_name_and_kind(\n-                    ccx.tcx,\n-                    Ident::with_dummy_span(sym::eq),\n-                    AssocKind::Fn,\n-                    trait_def_id,\n-                ) {\n-                    if callee == eq_item.def_id && substs.len() == 2 {\n-                        match (substs[0].unpack(), substs[1].unpack()) {\n-                            (GenericArgKind::Type(self_ty), GenericArgKind::Type(rhs_ty))\n-                                if self_ty == rhs_ty\n-                                    && self_ty.is_ref()\n-                                    && self_ty.peel_refs().is_primitive() =>\n-                            {\n-                                let mut num_refs = 0;\n-                                let mut tmp_ty = self_ty;\n-                                while let rustc_middle::ty::Ref(_, inner_ty, _) = tmp_ty.kind() {\n-                                    num_refs += 1;\n-                                    tmp_ty = inner_ty;\n-                                }\n-                                let deref = \"*\".repeat(num_refs);\n-\n-                                if let Ok(call_str) =\n-                                    ccx.tcx.sess.source_map().span_to_snippet(span)\n-                                {\n-                                    if let Some(eq_idx) = call_str.find(\"==\") {\n-                                        if let Some(rhs_idx) = call_str[(eq_idx + 2)..]\n-                                            .find(|c: char| !c.is_whitespace())\n-                                        {\n-                                            let rhs_pos = span.lo()\n-                                                + BytePos::from_usize(eq_idx + 2 + rhs_idx);\n-                                            let rhs_span = span.with_lo(rhs_pos).with_hi(rhs_pos);\n-                                            err.multipart_suggestion(\n-                                                \"consider dereferencing here\",\n-                                                vec![\n-                                                    (span.shrink_to_lo(), deref.clone()),\n-                                                    (rhs_span, deref),\n-                                                ],\n-                                                Applicability::MachineApplicable,\n-                                            );\n-                                        }\n+impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, _: Span) -> DiagnosticBuilder<'tcx> {\n+        let FnCallNonConst { caller, callee, substs, span, from_hir_call } = *self;\n+        let ConstCx { tcx, param_env, .. } = *ccx;\n+\n+        let diag_trait = |mut err, self_ty: Ty<'_>, trait_id| {\n+            let trait_ref = TraitRef::from_method(tcx, trait_id, substs);\n+\n+            match self_ty.kind() {\n+                Param(param_ty) => {\n+                    debug!(?param_ty);\n+                    if let Some(generics) = caller\n+                        .as_local()\n+                        .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n+                        .map(|id| tcx.hir().get(id))\n+                        .as_ref()\n+                        .and_then(|node| node.generics())\n+                    {\n+                        let constraint = with_no_trimmed_paths(|| {\n+                            format!(\"~const {}\", trait_ref.print_only_trait_path())\n+                        });\n+                        suggest_constraining_type_param(\n+                            tcx,\n+                            generics,\n+                            &mut err,\n+                            &param_ty.name.as_str(),\n+                            &constraint,\n+                            None,\n+                        );\n+                    }\n+                }\n+                Adt(..) => {\n+                    let obligation = Obligation::new(\n+                        ObligationCause::dummy(),\n+                        param_env,\n+                        Binder::dummy(TraitPredicate {\n+                            trait_ref,\n+                            constness: BoundConstness::NotConst,\n+                            polarity: ImplPolarity::Positive,\n+                        }),\n+                    );\n+\n+                    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n+                        let mut selcx = SelectionContext::new(&infcx);\n+                        selcx.select(&obligation)\n+                    });\n+\n+                    if let Ok(Some(ImplSource::UserDefined(data))) = implsrc {\n+                        let span =\n+                            tcx.sess.source_map().guess_head_span(tcx.def_span(data.impl_def_id));\n+                        err.span_note(span, \"impl defined here, but it is not `const`\");\n+                    }\n+                }\n+                _ => {}\n+            }\n+\n+            err\n+        };\n+\n+        let call_kind = call_kind(tcx, ccx.param_env, callee, substs, span, from_hir_call, None);\n+\n+        debug!(?call_kind);\n+\n+        let mut err = match call_kind {\n+            CallKind::Normal { desugaring: Some((kind, self_ty)), .. } => {\n+                macro_rules! error {\n+                    ($fmt:literal) => {\n+                        struct_span_err!(tcx.sess, span, E0015, $fmt, self_ty, ccx.const_kind())\n+                    };\n+                }\n+\n+                let err = match kind {\n+                    CallDesugaringKind::ForLoopIntoIter => {\n+                        error!(\"cannot convert `{}` into an iterator in {}s\")\n+                    }\n+                    CallDesugaringKind::QuestionBranch => {\n+                        error!(\"`?` cannot determine the branch of `{}` in {}s\")\n+                    }\n+                    CallDesugaringKind::QuestionFromResidual => {\n+                        error!(\"`?` cannot convert from residual of `{}` in {}s\")\n+                    }\n+                    CallDesugaringKind::TryBlockFromOutput => {\n+                        error!(\"`try` block cannot convert `{}` to the result in {}s\")\n+                    }\n+                };\n+\n+                diag_trait(err, self_ty, kind.trait_def_id(tcx))\n+            }\n+            CallKind::FnCall { fn_trait_id, self_ty } => {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0015,\n+                    \"cannot call non-const closure in {}s\",\n+                    ccx.const_kind(),\n+                );\n+\n+                match self_ty.kind() {\n+                    FnDef(def_id, ..) => {\n+                        let span = tcx.sess.source_map().guess_head_span(tcx.def_span(*def_id));\n+                        if ccx.tcx.is_const_fn_raw(*def_id) {\n+                            span_bug!(span, \"calling const FnDef errored when it shouldn't\");\n+                        }\n+\n+                        err.span_note(span, \"function defined here, but it is not `const`\");\n+                    }\n+                    FnPtr(..) => {\n+                        err.note(&format!(\n+                            \"function pointers need an RFC before allowed to be called in {}s\",\n+                            ccx.const_kind()\n+                        ));\n+                    }\n+                    Closure(..) => {\n+                        err.note(&format!(\n+                            \"closures need an RFC before allowed to be called in {}s\",\n+                            ccx.const_kind()\n+                        ));\n+                    }\n+                    _ => {}\n+                }\n+\n+                diag_trait(err, self_ty, fn_trait_id)\n+            }\n+            CallKind::Operator { trait_id, self_ty, .. } => {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0015,\n+                    \"cannot call non-const operator in {}s\",\n+                    ccx.const_kind()\n+                );\n+\n+                if Some(trait_id) == ccx.tcx.lang_items().eq_trait() {\n+                    match (substs[0].unpack(), substs[1].unpack()) {\n+                        (GenericArgKind::Type(self_ty), GenericArgKind::Type(rhs_ty))\n+                            if self_ty == rhs_ty\n+                                && self_ty.is_ref()\n+                                && self_ty.peel_refs().is_primitive() =>\n+                        {\n+                            let mut num_refs = 0;\n+                            let mut tmp_ty = self_ty;\n+                            while let rustc_middle::ty::Ref(_, inner_ty, _) = tmp_ty.kind() {\n+                                num_refs += 1;\n+                                tmp_ty = inner_ty;\n+                            }\n+                            let deref = \"*\".repeat(num_refs);\n+\n+                            if let Ok(call_str) = ccx.tcx.sess.source_map().span_to_snippet(span) {\n+                                if let Some(eq_idx) = call_str.find(\"==\") {\n+                                    if let Some(rhs_idx) =\n+                                        call_str[(eq_idx + 2)..].find(|c: char| !c.is_whitespace())\n+                                    {\n+                                        let rhs_pos =\n+                                            span.lo() + BytePos::from_usize(eq_idx + 2 + rhs_idx);\n+                                        let rhs_span = span.with_lo(rhs_pos).with_hi(rhs_pos);\n+                                        err.multipart_suggestion(\n+                                            \"consider dereferencing here\",\n+                                            vec![\n+                                                (span.shrink_to_lo(), deref.clone()),\n+                                                (rhs_span, deref),\n+                                            ],\n+                                            Applicability::MachineApplicable,\n+                                        );\n                                     }\n                                 }\n                             }\n-                            _ => {}\n                         }\n+                        _ => {}\n                     }\n                 }\n+\n+                diag_trait(err, self_ty, trait_id)\n             }\n-        }\n+            CallKind::DerefCoercion { deref_target, deref_target_ty, self_ty } => {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0015,\n+                    \"cannot perform deref coercion on `{}` in {}s\",\n+                    self_ty,\n+                    ccx.const_kind()\n+                );\n+\n+                err.note(&format!(\"attempting to deref into `{}`\", deref_target_ty));\n+\n+                // Check first whether the source is accessible (issue #87060)\n+                if tcx.sess.source_map().span_to_snippet(deref_target).is_ok() {\n+                    err.span_note(deref_target, \"deref defined here\");\n+                }\n+\n+                diag_trait(err, self_ty, tcx.lang_items().deref_trait().unwrap())\n+            }\n+            _ => struct_span_err!(\n+                ccx.tcx.sess,\n+                span,\n+                E0015,\n+                \"cannot call non-const fn `{}` in {}s\",\n+                ccx.tcx.def_path_str_with_substs(callee, substs),\n+                ccx.const_kind(),\n+            ),\n+        };\n+\n+        err.note(&format!(\n+            \"calls in {}s are limited to constant functions, \\\n+             tuple structs and tuple variants\",\n+            ccx.const_kind(),\n+        ));\n \n         err\n     }\n@@ -148,8 +308,8 @@ impl<'a> NonConstOp for FnCallNonConst<'a> {\n #[derive(Debug)]\n pub struct FnCallUnstable(pub DefId, pub Option<Symbol>);\n \n-impl NonConstOp for FnCallUnstable {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for FnCallUnstable {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let FnCallUnstable(def_id, feature) = *self;\n \n         let mut err = ccx.tcx.sess.struct_span_err(\n@@ -174,16 +334,16 @@ impl NonConstOp for FnCallUnstable {\n \n #[derive(Debug)]\n pub struct FnPtrCast;\n-impl NonConstOp for FnPtrCast {\n-    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for FnPtrCast {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n         if ccx.const_kind() != hir::ConstContext::ConstFn {\n             Status::Allowed\n         } else {\n             Status::Unstable(sym::const_fn_fn_ptr_basics)\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_fn_fn_ptr_basics,\n@@ -195,16 +355,16 @@ impl NonConstOp for FnPtrCast {\n \n #[derive(Debug)]\n pub struct Generator(pub hir::GeneratorKind);\n-impl NonConstOp for Generator {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for Generator {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n             Status::Unstable(sym::const_async_blocks)\n         } else {\n             Status::Forbidden\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let msg = format!(\"{}s are not allowed in {}s\", self.0, ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n             feature_err(&ccx.tcx.sess.parse_sess, sym::const_async_blocks, span, &msg)\n@@ -216,8 +376,8 @@ impl NonConstOp for Generator {\n \n #[derive(Debug)]\n pub struct HeapAllocation;\n-impl NonConstOp for HeapAllocation {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for HeapAllocation {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -240,8 +400,8 @@ impl NonConstOp for HeapAllocation {\n \n #[derive(Debug)]\n pub struct InlineAsm;\n-impl NonConstOp for InlineAsm {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -256,8 +416,8 @@ impl NonConstOp for InlineAsm {\n pub struct LiveDrop {\n     pub dropped_at: Option<Span>,\n }\n-impl NonConstOp for LiveDrop {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for LiveDrop {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -276,16 +436,16 @@ impl NonConstOp for LiveDrop {\n /// A borrow of a type that contains an `UnsafeCell` somewhere. The borrow never escapes to\n /// the final value of the constant.\n pub struct TransientCellBorrow;\n-impl NonConstOp for TransientCellBorrow {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for TransientCellBorrow {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Unstable(sym::const_refs_to_cell)\n     }\n     fn importance(&self) -> DiagnosticImportance {\n         // The cases that cannot possibly work will already emit a `CellBorrow`, so we should\n         // not additionally emit a feature gate error if activating the feature gate won't work.\n         DiagnosticImportance::Secondary\n     }\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_refs_to_cell,\n@@ -300,8 +460,8 @@ impl NonConstOp for TransientCellBorrow {\n /// the final value of the constant, and thus we cannot allow this (for now). We may allow\n /// it in the future for static items.\n pub struct CellBorrow;\n-impl NonConstOp for CellBorrow {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for CellBorrow {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -337,8 +497,8 @@ impl NonConstOp for CellBorrow {\n /// static or const items.\n pub struct MutBorrow(pub hir::BorrowKind);\n \n-impl NonConstOp for MutBorrow {\n-    fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for MutBorrow {\n+    fn status_in_item(&self, _ccx: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Forbidden\n     }\n \n@@ -348,7 +508,7 @@ impl NonConstOp for MutBorrow {\n         DiagnosticImportance::Secondary\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let raw = match self.0 {\n             hir::BorrowKind::Raw => \"raw \",\n             hir::BorrowKind::Ref => \"\",\n@@ -382,12 +542,12 @@ impl NonConstOp for MutBorrow {\n #[derive(Debug)]\n pub struct TransientMutBorrow(pub hir::BorrowKind);\n \n-impl NonConstOp for TransientMutBorrow {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for TransientMutBorrow {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let raw = match self.0 {\n             hir::BorrowKind::Raw => \"raw \",\n             hir::BorrowKind::Ref => \"\",\n@@ -404,8 +564,8 @@ impl NonConstOp for TransientMutBorrow {\n \n #[derive(Debug)]\n pub struct MutDeref;\n-impl NonConstOp for MutDeref {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for MutDeref {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n@@ -414,7 +574,7 @@ impl NonConstOp for MutDeref {\n         DiagnosticImportance::Secondary\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n@@ -427,8 +587,8 @@ impl NonConstOp for MutDeref {\n /// A call to a `panic()` lang item where the first argument is _not_ a `&str`.\n #[derive(Debug)]\n pub struct PanicNonStr;\n-impl NonConstOp for PanicNonStr {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for PanicNonStr {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         ccx.tcx.sess.struct_span_err(\n             span,\n             \"argument to `panic!()` in a const context must have type `&str`\",\n@@ -441,8 +601,8 @@ impl NonConstOp for PanicNonStr {\n /// allocation base addresses that are not known at compile-time.\n #[derive(Debug)]\n pub struct RawPtrComparison;\n-impl NonConstOp for RawPtrComparison {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for RawPtrComparison {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = ccx\n             .tcx\n             .sess\n@@ -457,12 +617,12 @@ impl NonConstOp for RawPtrComparison {\n \n #[derive(Debug)]\n pub struct RawMutPtrDeref;\n-impl NonConstOp for RawMutPtrDeref {\n+impl<'tcx> NonConstOp<'tcx> for RawMutPtrDeref {\n     fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n@@ -477,8 +637,8 @@ impl NonConstOp for RawMutPtrDeref {\n /// allocation base addresses that are not known at compile-time.\n #[derive(Debug)]\n pub struct RawPtrToIntCast;\n-impl NonConstOp for RawPtrToIntCast {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for RawPtrToIntCast {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = ccx\n             .tcx\n             .sess\n@@ -494,16 +654,16 @@ impl NonConstOp for RawPtrToIntCast {\n /// An access to a (non-thread-local) `static`.\n #[derive(Debug)]\n pub struct StaticAccess;\n-impl NonConstOp for StaticAccess {\n-    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for StaticAccess {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n         if let hir::ConstContext::Static(_) = ccx.const_kind() {\n             Status::Allowed\n         } else {\n             Status::Forbidden\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -528,8 +688,8 @@ impl NonConstOp for StaticAccess {\n /// An access to a thread-local `static`.\n #[derive(Debug)]\n pub struct ThreadLocalAccess;\n-impl NonConstOp for ThreadLocalAccess {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for ThreadLocalAccess {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -546,8 +706,8 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct MutRef(pub mir::LocalKind);\n-    impl NonConstOp for MutRef {\n-        fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+    impl<'tcx> NonConstOp<'tcx> for MutRef {\n+        fn status_in_item(&self, _ccx: &ConstCx<'_, 'tcx>) -> Status {\n             Status::Unstable(sym::const_mut_refs)\n         }\n \n@@ -560,11 +720,7 @@ pub mod ty {\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_mut_refs,\n@@ -576,7 +732,7 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct FnPtr(pub mir::LocalKind);\n-    impl NonConstOp for FnPtr {\n+    impl<'tcx> NonConstOp<'tcx> for FnPtr {\n         fn importance(&self) -> DiagnosticImportance {\n             match self.0 {\n                 mir::LocalKind::Var | mir::LocalKind::Temp => DiagnosticImportance::Secondary,\n@@ -586,19 +742,15 @@ pub mod ty {\n             }\n         }\n \n-        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n             if ccx.const_kind() != hir::ConstContext::ConstFn {\n                 Status::Allowed\n             } else {\n                 Status::Unstable(sym::const_fn_fn_ptr_basics)\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_fn_ptr_basics,\n@@ -610,16 +762,12 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct ImplTrait;\n-    impl NonConstOp for ImplTrait {\n+    impl<'tcx> NonConstOp<'tcx> for ImplTrait {\n         fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n             Status::Unstable(sym::const_impl_trait)\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_impl_trait,\n@@ -631,7 +779,7 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct TraitBound(pub mir::LocalKind);\n-    impl NonConstOp for TraitBound {\n+    impl<'tcx> NonConstOp<'tcx> for TraitBound {\n         fn importance(&self) -> DiagnosticImportance {\n             match self.0 {\n                 mir::LocalKind::Var | mir::LocalKind::Temp => DiagnosticImportance::Secondary,\n@@ -641,19 +789,15 @@ pub mod ty {\n             }\n         }\n \n-        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n             if ccx.const_kind() != hir::ConstContext::ConstFn {\n                 Status::Allowed\n             } else {\n                 Status::Unstable(sym::const_fn_trait_bound)\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             let mut err = feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_trait_bound,\n@@ -674,7 +818,7 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct DynTrait(pub mir::LocalKind);\n-    impl NonConstOp for DynTrait {\n+    impl<'tcx> NonConstOp<'tcx> for DynTrait {\n         fn importance(&self) -> DiagnosticImportance {\n             match self.0 {\n                 mir::LocalKind::Var | mir::LocalKind::Temp => DiagnosticImportance::Secondary,\n@@ -684,19 +828,15 @@ pub mod ty {\n             }\n         }\n \n-        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n             if ccx.const_kind() != hir::ConstContext::ConstFn {\n                 Status::Allowed\n             } else {\n                 Status::Unstable(sym::const_fn_trait_bound)\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             let mut err = feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_trait_bound,\n@@ -718,16 +858,12 @@ pub mod ty {\n     /// A trait bound with the `?const Trait` opt-out\n     #[derive(Debug)]\n     pub struct TraitBoundNotConst;\n-    impl NonConstOp for TraitBoundNotConst {\n-        fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+    impl<'tcx> NonConstOp<'tcx> for TraitBoundNotConst {\n+        fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n             Status::Unstable(sym::const_trait_bound_opt_out)\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_trait_bound_opt_out,"}, {"sha": "11bb9508a1f8626ac347f33f45d7fb9ab9232630", "filename": "compiler/rustc_const_eval/src/util/call_kind.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -0,0 +1,143 @@\n+//! Common logic for borrowck use-after-move errors when moved into a `fn(self)`,\n+//! as well as errors when attempting to call a non-const function in a const\n+//! context.\n+\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItemGroup;\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{self, AssocItemContainer, DefIdTree, Instance, ParamEnv, Ty, TyCtxt};\n+use rustc_span::symbol::Ident;\n+use rustc_span::{sym, DesugaringKind, Span};\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum CallDesugaringKind {\n+    /// for _ in x {} calls x.into_iter()\n+    ForLoopIntoIter,\n+    /// x? calls x.branch()\n+    QuestionBranch,\n+    /// x? calls type_of(x)::from_residual()\n+    QuestionFromResidual,\n+    /// try { ..; x } calls type_of(x)::from_output(x)\n+    TryBlockFromOutput,\n+}\n+\n+impl CallDesugaringKind {\n+    pub fn trait_def_id(self, tcx: TyCtxt<'_>) -> DefId {\n+        match self {\n+            Self::ForLoopIntoIter => tcx.get_diagnostic_item(sym::IntoIterator).unwrap(),\n+            Self::QuestionBranch | Self::TryBlockFromOutput => {\n+                tcx.lang_items().try_trait().unwrap()\n+            }\n+            Self::QuestionFromResidual => tcx.get_diagnostic_item(sym::FromResidual).unwrap(),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum CallKind<'tcx> {\n+    /// A normal method call of the form `receiver.foo(a, b, c)`\n+    Normal {\n+        self_arg: Option<Ident>,\n+        desugaring: Option<(CallDesugaringKind, Ty<'tcx>)>,\n+        /// Whether the self type of the method call has an `.as_ref()` method.\n+        /// Used for better diagnostics.\n+        is_option_or_result: bool,\n+    },\n+    /// A call to `Fn(..)::call(..)`, desugared from `my_closure(a, b, c)`\n+    FnCall { fn_trait_id: DefId, self_ty: Ty<'tcx> },\n+    /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n+    Operator { self_arg: Option<Ident>, trait_id: DefId, self_ty: Ty<'tcx> },\n+    DerefCoercion {\n+        /// The `Span` of the `Target` associated type\n+        /// in the `Deref` impl we are using.\n+        deref_target: Span,\n+        /// The type `T::Deref` we are dereferencing to\n+        deref_target_ty: Ty<'tcx>,\n+        self_ty: Ty<'tcx>,\n+    },\n+}\n+\n+pub fn call_kind<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    method_did: DefId,\n+    method_substs: SubstsRef<'tcx>,\n+    fn_call_span: Span,\n+    from_hir_call: bool,\n+    self_arg: Option<Ident>,\n+) -> CallKind<'tcx> {\n+    let parent = tcx.opt_associated_item(method_did).and_then(|assoc| match assoc.container {\n+        AssocItemContainer::ImplContainer(impl_did) => tcx.trait_id_of_impl(impl_did),\n+        AssocItemContainer::TraitContainer(trait_did) => Some(trait_did),\n+    });\n+\n+    let fn_call = parent\n+        .and_then(|p| tcx.lang_items().group(LangItemGroup::Fn).iter().find(|did| **did == p));\n+\n+    let operator = (!from_hir_call)\n+        .then(|| parent)\n+        .flatten()\n+        .and_then(|p| tcx.lang_items().group(LangItemGroup::Op).iter().find(|did| **did == p));\n+\n+    let is_deref = !from_hir_call && tcx.is_diagnostic_item(sym::deref_method, method_did);\n+\n+    // Check for a 'special' use of 'self' -\n+    // an FnOnce call, an operator (e.g. `<<`), or a\n+    // deref coercion.\n+    let kind = if let Some(&trait_id) = fn_call {\n+        Some(CallKind::FnCall { fn_trait_id: trait_id, self_ty: method_substs.type_at(0) })\n+    } else if let Some(&trait_id) = operator {\n+        Some(CallKind::Operator { self_arg, trait_id, self_ty: method_substs.type_at(0) })\n+    } else if is_deref {\n+        let deref_target = tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {\n+            Instance::resolve(tcx, param_env, deref_target, method_substs).transpose()\n+        });\n+        if let Some(Ok(instance)) = deref_target {\n+            let deref_target_ty = instance.ty(tcx, param_env);\n+            Some(CallKind::DerefCoercion {\n+                deref_target: tcx.def_span(instance.def_id()),\n+                deref_target_ty,\n+                self_ty: method_substs.type_at(0),\n+            })\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    };\n+\n+    kind.unwrap_or_else(|| {\n+        // This isn't a 'special' use of `self`\n+        debug!(?method_did, ?fn_call_span);\n+        let desugaring = if Some(method_did) == tcx.lang_items().into_iter_fn()\n+            && fn_call_span.desugaring_kind() == Some(DesugaringKind::ForLoop)\n+        {\n+            Some((CallDesugaringKind::ForLoopIntoIter, method_substs.type_at(0)))\n+        } else if fn_call_span.desugaring_kind() == Some(DesugaringKind::QuestionMark) {\n+            if Some(method_did) == tcx.lang_items().branch_fn() {\n+                Some((CallDesugaringKind::QuestionBranch, method_substs.type_at(0)))\n+            } else if Some(method_did) == tcx.lang_items().from_residual_fn() {\n+                Some((CallDesugaringKind::QuestionFromResidual, method_substs.type_at(0)))\n+            } else {\n+                None\n+            }\n+        } else if Some(method_did) == tcx.lang_items().from_output_fn()\n+            && fn_call_span.desugaring_kind() == Some(DesugaringKind::TryBlock)\n+        {\n+            Some((CallDesugaringKind::TryBlockFromOutput, method_substs.type_at(0)))\n+        } else {\n+            None\n+        };\n+        let parent_self_ty = tcx\n+            .parent(method_did)\n+            .filter(|did| tcx.def_kind(*did) == rustc_hir::def::DefKind::Impl)\n+            .and_then(|did| match tcx.type_of(did).kind() {\n+                ty::Adt(def, ..) => Some(def.did),\n+                _ => None,\n+            });\n+        let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n+            matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n+        });\n+        CallKind::Normal { self_arg, desugaring, is_option_or_result }\n+    })\n+}"}, {"sha": "a1876bed83eca4a1bfac1eb0d781e1b707ea50de", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n pub mod aggregate;\n mod alignment;\n+mod call_kind;\n pub mod collect_writes;\n mod find_self_call;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n+pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n pub use self::find_self_call::find_self_call;"}, {"sha": "b299e71c9c4c45f4d78fc95f6cba527b6fe07b75", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -21,9 +21,10 @@ use std::lazy::SyncLazy;\n \n pub enum LangItemGroup {\n     Op,\n+    Fn,\n }\n \n-const NUM_GROUPS: usize = 1;\n+const NUM_GROUPS: usize = 2;\n \n macro_rules! expand_group {\n     () => {\n@@ -98,11 +99,12 @@ macro_rules! language_item_table {\n             /// Construct an empty collection of lang items and no missing ones.\n             pub fn new() -> Self {\n                 fn init_none(_: LangItem) -> Option<DefId> { None }\n+                const EMPTY: Vec<DefId> = Vec::new();\n \n                 Self {\n                     items: vec![$(init_none(LangItem::$variant)),*],\n                     missing: Vec::new(),\n-                    groups: [vec![]; NUM_GROUPS],\n+                    groups: [EMPTY; NUM_GROUPS],\n                 }\n             }\n \n@@ -251,9 +253,9 @@ language_item_table! {\n     DerefTarget,             sym::deref_target,        deref_target,               Target::AssocTy,        GenericRequirement::None;\n     Receiver,                sym::receiver,            receiver_trait,             Target::Trait,          GenericRequirement::None;\n \n-    Fn,                      kw::Fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    FnMut,                   sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    FnOnce,                  sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n+    Fn(Fn),                  kw::Fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    FnMut(Fn),               sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    FnOnce(Fn),              sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n \n     FnOnceOutput,            sym::fn_once_output,      fn_once_output,             Target::AssocTy,        GenericRequirement::None;\n \n@@ -264,8 +266,8 @@ language_item_table! {\n     Unpin,                   sym::unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n     Pin,                     sym::pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n \n-    PartialEq,               sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    PartialOrd,              sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n+    PartialEq(Op),           sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    PartialOrd(Op),          sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n \n     // A number of panic-related lang items. The `panic` item corresponds to divide-by-zero and\n     // various panic cases with `match`. The `panic_bounds_check` item is for indexing arrays."}, {"sha": "2e4515022636639ff158255341df74ff35290fff", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -184,6 +184,7 @@ symbols! {\n         Formatter,\n         From,\n         FromIterator,\n+        FromResidual,\n         Future,\n         FxHashMap,\n         FxHashSet,"}, {"sha": "ba369e7f3aaa0a2af92477588d6e36e4500405d7", "filename": "library/core/src/ops/try_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -302,6 +302,7 @@ pub trait Try: FromResidual {\n         enclosing_scope = \"this function should return `Result` or `Option` to accept `?`\"\n     ),\n )]\n+#[rustc_diagnostic_item = \"FromResidual\"]\n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n pub trait FromResidual<R = <Self as Try>::Residual> {\n     /// Constructs the type from a compatible `Residual` type."}, {"sha": "33d55be5812e78822b18d7e8472195b5b789c9fc", "filename": "src/test/ui/borrowck/issue-64453.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -2,7 +2,7 @@ struct Project;\n struct Value;\n \n static settings_dir: String = format!(\"\");\n-//~^ ERROR calls in statics are limited to constant functions\n+//~^ ERROR cannot call non-const fn\n //~| ERROR is not yet stable as a const\n \n fn from_string(_: String) -> Value {"}, {"sha": "f3436fbec66a605327139855744a48cc66f327dc", "filename": "src/test/ui/borrowck/issue-64453.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -7,12 +7,13 @@ LL | static settings_dir: String = format!(\"\");\n    = help: add `#![feature(const_fmt_arguments_new)]` to the crate attributes to enable\n    = note: this error originates in the macro `$crate::__export::format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `format` in statics\n   --> $DIR/issue-64453.rs:4:31\n    |\n LL | static settings_dir: String = format!(\"\");\n    |                               ^^^^^^^^^^^\n    |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0507]: cannot move out of static item `settings_dir`"}, {"sha": "eb4ecd8baca965e97ecc4d5fc75c291f7021a2b3", "filename": "src/test/ui/check-static-values-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-static-values-constraints.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -87,7 +87,7 @@ static mut STATIC13: SafeStruct = SafeStruct{field1: SafeEnum::Variant1,\n static mut STATIC14: SafeStruct = SafeStruct {\n     field1: SafeEnum::Variant1,\n     field2: SafeEnum::Variant4(\"str\".to_string())\n-//~^ ERROR calls in statics are limited to constant functions\n+//~^ ERROR cannot call non-const fn\n };\n \n static STATIC15: &'static [Box<MyOwned>] = &["}, {"sha": "b28cf0d6bd0f582808a27f90823e8595d040ee16", "filename": "src/test/ui/check-static-values-constraints.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -15,11 +15,13 @@ error[E0010]: allocations are not allowed in statics\n LL | static STATIC11: Box<MyOwned> = box MyOwned;\n    |                                 ^^^^^^^^^^^ allocation not allowed in statics\n \n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/check-static-values-constraints.rs:89:32\n+error[E0015]: cannot call non-const fn `<str as ToString>::to_string` in statics\n+  --> $DIR/check-static-values-constraints.rs:89:38\n    |\n LL |     field2: SafeEnum::Variant4(\"str\".to_string())\n-   |                                ^^^^^^^^^^^^^^^^^\n+   |                                      ^^^^^^^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error[E0010]: allocations are not allowed in statics\n   --> $DIR/check-static-values-constraints.rs:94:5"}, {"sha": "c1a6bf6e34d0bb643585e58cbeaa4805dd2a4deb", "filename": "src/test/ui/const-generics/issue-93647.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,6 +1,6 @@\n struct X<const N: usize = {\n     (||1usize)()\n-    //~^ ERROR calls in constants are limited to\n+    //~^ ERROR cannot call\n }>;\n \n fn main() {}"}, {"sha": "e2048ecd60f6d6e6974e136925de0f9f3ba09cfc", "filename": "src/test/ui/const-generics/issue-93647.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,11 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const closure in constants\n   --> $DIR/issue-93647.rs:2:5\n    |\n LL |     (||1usize)()\n    |     ^^^^^^^^^^^^\n+   |\n+   = note: closures need an RFC before allowed to be called in constants\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "bebd0c6ac1202d656c67299d2dac1f19a105a02c", "filename": "src/test/ui/const-generics/issues/issue-90318.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -13,15 +13,15 @@ fn consume<T: 'static>(_val: T)\n where\n     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n     //~^ ERROR: overly complex generic constant\n-    //~| ERROR: calls in constants are limited to constant functions\n+    //~| ERROR: cannot call non-const operator in constants\n {\n }\n \n fn test<T: 'static>()\n where\n     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n     //~^ ERROR: overly complex generic constant\n-    //~| ERROR: calls in constants are limited to constant functions\n+    //~| ERROR: cannot call non-const operator in constants\n {\n }\n "}, {"sha": "c8690ecd0da7e84434306962292eb922f7abe4b8", "filename": "src/test/ui/const-generics/issues/issue-90318.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -9,11 +9,19 @@ LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n    = help: consider moving this anonymous constant into a `const` function\n    = note: this operation may be supported in the future\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const operator in constants\n   --> $DIR/issue-90318.rs:14:10\n    |\n LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/any.rs:LL:COL\n+   |\n+LL | #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+   |                       ^^^^^^^^^\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: overly complex generic constant\n   --> $DIR/issue-90318.rs:22:8\n@@ -26,11 +34,19 @@ LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n    = help: consider moving this anonymous constant into a `const` function\n    = note: this operation may be supported in the future\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const operator in constants\n   --> $DIR/issue-90318.rs:22:10\n    |\n LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/any.rs:LL:COL\n+   |\n+LL | #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+   |                       ^^^^^^^^^\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 4 previous errors\n "}, {"sha": "52f1c588258235db49b315efeea2a1034e26887c", "filename": "src/test/ui/const-generics/nested-type.full.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `Foo::{constant#0}::Foo::<17_usize>::value` in constants\n   --> $DIR/nested-type.rs:15:5\n    |\n LL |     Foo::<17>::value()\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "0e3c988ae4d8c9f34e285cc9b188953bffc74d28", "filename": "src/test/ui/const-generics/nested-type.min.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -14,11 +14,13 @@ LL | | }]>;\n    = note: the only supported types are integers, `bool` and `char`\n    = help: more complex types are supported with `#![feature(adt_const_params)]`\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `Foo::{constant#0}::Foo::<17_usize>::value` in constants\n   --> $DIR/nested-type.rs:15:5\n    |\n LL |     Foo::<17>::value()\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5240f5c3b0b64b8d4cc3919b3cd167ecdfb3ce15", "filename": "src/test/ui/const-generics/nested-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -13,7 +13,7 @@ struct Foo<const N: [u8; { //[min]~ ERROR `[u8; _]` is forbidden\n     }\n \n     Foo::<17>::value()\n-    //~^ ERROR calls in constants are limited to constant functions\n+    //~^ ERROR cannot call non-const fn\n }]>;\n \n fn main() {}"}, {"sha": "28e89559fe538653a62da22f7b34313c18828d7e", "filename": "src/test/ui/consts/const-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-call.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -4,5 +4,5 @@ fn f(x: usize) -> usize {\n \n fn main() {\n     let _ = [0; f(2)];\n-    //~^ ERROR calls in constants are limited to constant functions\n+    //~^ ERROR cannot call non-const fn\n }"}, {"sha": "e46bcad0e1d0ea48dff0ea76cfce951496bdc8aa", "filename": "src/test/ui/consts/const-call.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-call.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `f` in constants\n   --> $DIR/const-call.rs:6:17\n    |\n LL |     let _ = [0; f(2)];\n    |                 ^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "eccda49db3eb54481ffd581cd0c07b0206c00960", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-call-extern-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -7,7 +7,7 @@ extern \"C\" {\n const extern \"C\" fn bar() {\n     unsafe {\n         regular_in_block();\n-        //~^ ERROR: calls in constant functions\n+        //~^ ERROR: cannot call non-const fn\n     }\n }\n \n@@ -16,7 +16,7 @@ extern \"C\" fn regular() {}\n const extern \"C\" fn foo() {\n     unsafe {\n         regular();\n-        //~^ ERROR: calls in constant functions\n+        //~^ ERROR: cannot call non-const fn\n     }\n }\n "}, {"sha": "5acf22e4bc66e3591d94240f25ecee1e4f52b5dc", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-call-extern-fn.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,14 +1,18 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `regular_in_block` in constant functions\n   --> $DIR/const-extern-fn-call-extern-fn.rs:9:9\n    |\n LL |         regular_in_block();\n    |         ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `regular` in constant functions\n   --> $DIR/const-extern-fn-call-extern-fn.rs:18:9\n    |\n LL |         regular();\n    |         ^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 2 previous errors\n "}, {"sha": "abe68c17a0d7f1c0b7062547968dbf2d2db2bdb7", "filename": "src/test/ui/consts/const-fn-error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -4,8 +4,8 @@ const fn f(x: usize) -> usize {\n     let mut sum = 0;\n     for i in 0..x {\n         //~^ ERROR mutable references\n-        //~| ERROR calls in constant functions\n-        //~| ERROR calls in constant functions\n+        //~| ERROR cannot convert\n+        //~| ERROR cannot call non-const fn\n         //~| ERROR `for` is not allowed in a `const fn`\n         sum += i;\n     }"}, {"sha": "4d53cfc35e1c4ab88db8e8b0bca1e545a23c99b2", "filename": "src/test/ui/consts/const-fn-error.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -13,11 +13,18 @@ LL | |     }\n    = note: see issue #87575 <https://github.com/rust-lang/rust/issues/87575> for more information\n    = help: add `#![feature(const_for)]` to the crate attributes to enable\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot convert `std::ops::Range<usize>` into an iterator in constant functions\n   --> $DIR/const-fn-error.rs:5:14\n    |\n LL |     for i in 0..x {\n    |              ^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+   |\n+LL | impl<I: Iterator> IntoIterator for I {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error[E0658]: mutable references are not allowed in constant functions\n   --> $DIR/const-fn-error.rs:5:14\n@@ -28,11 +35,13 @@ LL |     for i in 0..x {\n    = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n    = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<std::ops::Range<usize> as Iterator>::next` in constant functions\n   --> $DIR/const-fn-error.rs:5:14\n    |\n LL |     for i in 0..x {\n    |              ^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 4 previous errors\n "}, {"sha": "4c7effc0d158657594810410aa6a1ef27eecbc20", "filename": "src/test/ui/consts/const-fn-not-safe-for-const.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `random` in constant functions\n   --> $DIR/const-fn-not-safe-for-const.rs:14:5\n    |\n LL |     random()\n    |     ^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error[E0013]: constant functions cannot refer to statics\n   --> $DIR/const-fn-not-safe-for-const.rs:20:5"}, {"sha": "58bcb5f74ccf6254f2e9f538ea35e3a46e94ba12", "filename": "src/test/ui/consts/const-for.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-for.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -3,8 +3,8 @@\n \n const _: () = {\n     for _ in 0..5 {}\n-    //~^ error: calls in constants are limited to\n-    //~| error: calls in constants are limited to\n+    //~^ error: cannot convert\n+    //~| error: cannot call non-const fn\n };\n \n fn main() {}"}, {"sha": "b0dc43eb8e8508f0d23cb136faa64e168408afb2", "filename": "src/test/ui/consts/const-for.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-for.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fconst-for.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-for.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,14 +1,23 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot convert `std::ops::Range<i32>` into an iterator in constants\n   --> $DIR/const-for.rs:5:14\n    |\n LL |     for _ in 0..5 {}\n    |              ^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+   |\n+LL | impl<I: Iterator> IntoIterator for I {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<std::ops::Range<i32> as Iterator>::next` in constants\n   --> $DIR/const-for.rs:5:14\n    |\n LL |     for _ in 0..5 {}\n    |              ^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ddddc8505c635102ec743013828870f80be4d7ee", "filename": "src/test/ui/consts/control-flow/issue-46843.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -8,7 +8,7 @@ fn non_const() -> Thing {\n }\n \n pub const Q: i32 = match non_const() {\n-    //~^ ERROR calls in constants are limited to constant functions\n+    //~^ ERROR cannot call non-const fn\n     Thing::This => 1,\n     Thing::That => 0\n };"}, {"sha": "66227f61e35638e985e8d10b59d8d31a9e68e4ee", "filename": "src/test/ui/consts/control-flow/issue-46843.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `non_const` in constants\n   --> $DIR/issue-46843.rs:10:26\n    |\n LL | pub const Q: i32 = match non_const() {\n    |                          ^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "d5f694986fc8997ad7048118407af6b563a86fe5", "filename": "src/test/ui/consts/intrinsic_without_const_stab.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -11,7 +11,7 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n     }\n \n     unsafe { copy(src, dst, count) }\n-    //~^ ERROR calls in constant functions are limited to constant functions\n+    //~^ ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "b32b6398ece62b1e2e2a2892b81dc7c0d496444d", "filename": "src/test/ui/consts/intrinsic_without_const_stab.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `copy::copy::<T>` in constant functions\n   --> $DIR/intrinsic_without_const_stab.rs:13:14\n    |\n LL |     unsafe { copy(src, dst, count) }\n    |              ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "8b37268b0b205c5c8e29f276be7bc0ec395bb645", "filename": "src/test/ui/consts/intrinsic_without_const_stab_fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -9,7 +9,7 @@ extern \"rust-intrinsic\" {\n #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n #[inline]\n pub const unsafe fn stuff<T>(src: *const T, dst: *mut T, count: usize) {\n-    unsafe { copy(src, dst, count) } //~ ERROR calls in constant functions are limited\n+    unsafe { copy(src, dst, count) } //~ ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "fcbb3724567fef5a252657bbc11d7b8030eb9815", "filename": "src/test/ui/consts/intrinsic_without_const_stab_fail.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `copy::<T>` in constant functions\n   --> $DIR/intrinsic_without_const_stab_fail.rs:12:14\n    |\n LL |     unsafe { copy(src, dst, count) }\n    |              ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "f8131c9f3b717107d5d2530b29490d79adfdc163", "filename": "src/test/ui/consts/issue-28113.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -2,7 +2,7 @@\n \n const X: u8 =\n     || -> u8 { 5 }()\n-    //~^ ERROR calls in constants are limited to constant functions\n+    //~^ ERROR cannot call non-const closure\n ;\n \n fn main() {}"}, {"sha": "7ad1f752eb085fd56dececf014f75d64e81fc0fe", "filename": "src/test/ui/consts/issue-28113.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,11 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const closure in constants\n   --> $DIR/issue-28113.rs:4:5\n    |\n LL |     || -> u8 { 5 }()\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+   = note: closures need an RFC before allowed to be called in constants\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "d70b5a8c4e13af3e93a90c00e65c03b0a00b49e1", "filename": "src/test/ui/consts/issue-32829-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -8,7 +8,7 @@ const bad : u32 = {\n const bad_two : u32 = {\n     {\n         invalid();\n-        //~^ ERROR: calls in constants are limited to constant functions, tuple structs and tuple variants\n+        //~^ ERROR: cannot call non-const fn `invalid`\n         0\n     }\n };\n@@ -30,7 +30,7 @@ static bad_four : u32 = {\n static bad_five : u32 = {\n     {\n         invalid();\n-        //~^ ERROR: calls in statics are limited to constant functions, tuple structs and tuple variants\n+        //~^ ERROR: cannot call non-const fn `invalid`\n         0\n     }\n };\n@@ -52,7 +52,7 @@ static mut bad_seven : u32 = {\n static mut bad_eight : u32 = {\n     {\n         invalid();\n-        //~^ ERROR: calls in statics are limited to constant functions, tuple structs and tuple variants\n+        //~^ ERROR: cannot call non-const fn `invalid`\n         0\n     }\n };"}, {"sha": "b94bdc0e3df1181f6499be8f5dc9f0c52861d3a8", "filename": "src/test/ui/consts/issue-32829-2.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,20 +1,26 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `invalid` in constants\n   --> $DIR/issue-32829-2.rs:10:9\n    |\n LL |         invalid();\n    |         ^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `invalid` in statics\n   --> $DIR/issue-32829-2.rs:32:9\n    |\n LL |         invalid();\n    |         ^^^^^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `invalid` in statics\n   --> $DIR/issue-32829-2.rs:54:9\n    |\n LL |         invalid();\n    |         ^^^^^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 3 previous errors\n "}, {"sha": "cac12b90970fe78b3f1ad19a1cb46c34f061ab00", "filename": "src/test/ui/consts/issue-43105.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,7 +1,7 @@\n fn xyz() -> u8 { 42 }\n \n const NUM: u8 = xyz();\n-//~^ ERROR calls in constants are limited to constant functions, tuple structs and tuple variants\n+//~^ ERROR cannot call non-const fn\n \n fn main() {\n     match 1 {"}, {"sha": "2d1174af71c86218ccdbb0020539c0a29bfe9ed4", "filename": "src/test/ui/consts/issue-43105.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `xyz` in constants\n   --> $DIR/issue-43105.rs:3:17\n    |\n LL | const NUM: u8 = xyz();\n    |                 ^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: could not evaluate constant pattern\n   --> $DIR/issue-43105.rs:8:9"}, {"sha": "9c673d20b2a9565549532cd4ac1df0d0cab8cfba", "filename": "src/test/ui/consts/issue-56164.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,7 +1,7 @@\n #![feature(const_fn_fn_ptr_basics)]\n \n const fn foo() { (||{})() }\n-//~^ ERROR calls in constant functions\n+//~^ ERROR cannot call non-const closure\n \n const fn bad(input: fn()) {\n     input()"}, {"sha": "62a7c7db6b83ae0311894706e2ec70bcb2f69f3a", "filename": "src/test/ui/consts/issue-56164.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,11 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const closure in constant functions\n   --> $DIR/issue-56164.rs:3:18\n    |\n LL | const fn foo() { (||{})() }\n    |                  ^^^^^^^^\n+   |\n+   = note: closures need an RFC before allowed to be called in constant functions\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: function pointers are not allowed in const fn\n   --> $DIR/issue-56164.rs:7:5"}, {"sha": "37958e7919d64890ddfd2df5d5c9e1ec8949d513", "filename": "src/test/ui/consts/issue-68542-closure-in-array-len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -3,7 +3,7 @@\n // in the length part of an array.\n \n struct Bug {\n-    a: [(); (|| { 0 })()] //~ ERROR calls in constants are limited to\n+    a: [(); (|| { 0 })()] //~ ERROR cannot call non-const closure\n }\n \n fn main() {}"}, {"sha": "74fbbc680f7e413ad6f6a07fdc759260e554e253", "filename": "src/test/ui/consts/issue-68542-closure-in-array-len.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,11 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const closure in constants\n   --> $DIR/issue-68542-closure-in-array-len.rs:6:13\n    |\n LL |     a: [(); (|| { 0 })()]\n    |             ^^^^^^^^^^^^\n+   |\n+   = note: closures need an RFC before allowed to be called in constants\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "0d28e06e53258cc592a104c01be868b0208f1b92", "filename": "src/test/ui/consts/issue-90870.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.fixed?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -6,20 +6,20 @@\n \n const fn f(a: &u8, b: &u8) -> bool {\n     *a == *b\n-    //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+    //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n     //~| HELP: consider dereferencing here\n }\n \n const fn g(a: &&&&i64, b: &&&&i64) -> bool {\n     ****a == ****b\n-    //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+    //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n     //~| HELP: consider dereferencing here\n }\n \n const fn h(mut a: &[u8], mut b: &[u8]) -> bool {\n     while let ([l, at @ ..], [r, bt @ ..]) = (a, b) {\n         if *l == *r {\n-        //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+        //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n         //~| HELP: consider dereferencing here\n             a = at;\n             b = bt;"}, {"sha": "c6bfffd2c5c1567d17da4213ffbe59143140882f", "filename": "src/test/ui/consts/issue-90870.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -6,20 +6,20 @@\n \n const fn f(a: &u8, b: &u8) -> bool {\n     a == b\n-    //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+    //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n     //~| HELP: consider dereferencing here\n }\n \n const fn g(a: &&&&i64, b: &&&&i64) -> bool {\n     a == b\n-    //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+    //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n     //~| HELP: consider dereferencing here\n }\n \n const fn h(mut a: &[u8], mut b: &[u8]) -> bool {\n     while let ([l, at @ ..], [r, bt @ ..]) = (a, b) {\n         if l == r {\n-        //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+        //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n         //~| HELP: consider dereferencing here\n             a = at;\n             b = bt;"}, {"sha": "478445cfb39c5f9c356ee5297636e005210ff5aa", "filename": "src/test/ui/consts/issue-90870.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,31 +1,34 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const operator in constant functions\n   --> $DIR/issue-90870.rs:8:5\n    |\n LL |     a == b\n    |     ^^^^^^\n    |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n help: consider dereferencing here\n    |\n LL |     *a == *b\n    |     +     +\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const operator in constant functions\n   --> $DIR/issue-90870.rs:14:5\n    |\n LL |     a == b\n    |     ^^^^^^\n    |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n help: consider dereferencing here\n    |\n LL |     ****a == ****b\n    |     ++++     ++++\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const operator in constant functions\n   --> $DIR/issue-90870.rs:21:12\n    |\n LL |         if l == r {\n    |            ^^^^^^\n    |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n help: consider dereferencing here\n    |\n LL |         if *l == *r {"}, {"sha": "258997597ea9d91f8228ac5c61bbaf4e6bbb233e", "filename": "src/test/ui/consts/min_const_fn/bad_const_fn_body_ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,7 +1,7 @@\n const fn foo(a: i32) -> Vec<i32> {\n     vec![1, 2, 3]\n     //~^ ERROR allocations are not allowed\n-    //~| ERROR calls in constant functions\n+    //~| ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "74234108911dd198d40880018decf6baddbc0384", "filename": "src/test/ui/consts/min_const_fn/bad_const_fn_body_ice.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -6,12 +6,13 @@ LL |     vec![1, 2, 3]\n    |\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `slice::<impl [i32]>::into_vec::<std::alloc::Global>` in constant functions\n   --> $DIR/bad_const_fn_body_ice.rs:2:5\n    |\n LL |     vec![1, 2, 3]\n    |     ^^^^^^^^^^^^^\n    |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors"}, {"sha": "b6f34b922fae51548a3956459853637246e7a67a", "filename": "src/test/ui/consts/mir_check_nonconst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -6,6 +6,6 @@ fn bar() -> Foo {\n }\n \n static foo: Foo = bar();\n-//~^ ERROR calls in statics are limited to constant functions, tuple structs and tuple variants\n+//~^ ERROR cannot call non-const fn\n \n fn main() {}"}, {"sha": "2bac995eebf090244cd229eb05479cabb795eec3", "filename": "src/test/ui/consts/mir_check_nonconst.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `bar` in statics\n   --> $DIR/mir_check_nonconst.rs:8:19\n    |\n LL | static foo: Foo = bar();\n    |                   ^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "4ef25bd1334f3b30a85d5a086f270d0435a9acf7", "filename": "src/test/ui/consts/unstable-const-fn-in-libcore.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,14 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const closure in constant functions\n   --> $DIR/unstable-const-fn-in-libcore.rs:24:26\n    |\n LL |             Opt::None => f(),\n    |                          ^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+help: consider further restricting this bound\n+   |\n+LL |     const fn unwrap_or_else<F: FnOnce() -> T + ~const std::ops::FnOnce<()>>(self, f: F) -> T {\n+   |                                              +++++++++++++++++++++++++++++\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/unstable-const-fn-in-libcore.rs:19:53"}, {"sha": "60a2bf1e2d66083485e4539df7124141a9523d69", "filename": "src/test/ui/issues/issue-16538.mir.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fissues%2Fissue-16538.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fissues%2Fissue-16538.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16538.mir.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `Y::foo` in statics\n   --> $DIR/issue-16538.rs:15:23\n    |\n LL | static foo: &Y::X = &*Y::foo(Y::x as *const Y::X);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error[E0133]: use of extern static is unsafe and requires unsafe function or block\n   --> $DIR/issue-16538.rs:15:30"}, {"sha": "2ba9dfa2bc5f844c62d484d8b4b80db45b1e37be", "filename": "src/test/ui/issues/issue-16538.thir.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fissues%2Fissue-16538.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fissues%2Fissue-16538.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16538.thir.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -14,11 +14,13 @@ LL | static foo: &Y::X = &*Y::foo(Y::x as *const Y::X);\n    |\n    = note: extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n \n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `Y::foo` in statics\n   --> $DIR/issue-16538.rs:15:23\n    |\n LL | static foo: &Y::X = &*Y::foo(Y::x as *const Y::X);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 3 previous errors\n "}, {"sha": "ba12e1ad0211bffcbd8d9beff612c91d2749cccd", "filename": "src/test/ui/issues/issue-25901.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fissues%2Fissue-25901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fissues%2Fissue-25901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25901.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -2,7 +2,7 @@ struct A;\n struct B;\n \n static S: &'static B = &A;\n-//~^ ERROR calls in statics are limited to constant functions\n+//~^ ERROR cannot perform deref coercion on `A` in statics\n \n use std::ops::Deref;\n "}, {"sha": "5c35250bc3f39e86454a4b4a3ed4f4c0749d39b1", "filename": "src/test/ui/issues/issue-25901.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fissues%2Fissue-25901.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fissues%2Fissue-25901.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25901.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,21 @@\n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot perform deref coercion on `A` in statics\n   --> $DIR/issue-25901.rs:4:24\n    |\n LL | static S: &'static B = &A;\n    |                        ^^\n+   |\n+   = note: attempting to deref into `B`\n+note: deref defined here\n+  --> $DIR/issue-25901.rs:10:5\n+   |\n+LL |     type Target = B;\n+   |     ^^^^^^^^^^^^^^^^\n+note: impl defined here, but it is not `const`\n+  --> $DIR/issue-25901.rs:9:1\n+   |\n+LL | impl Deref for A {\n+   | ^^^^^^^^^^^^^^^^\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "ea27e7bd2508f9ecc26f7bf14dd65577c2dcd5ba", "filename": "src/test/ui/issues/issue-39559-2.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,14 +1,18 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<Dim3 as Dim>::dim` in constants\n   --> $DIR/issue-39559-2.rs:14:24\n    |\n LL |     let array: [usize; Dim3::dim()]\n    |                        ^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<Dim3 as Dim>::dim` in constants\n   --> $DIR/issue-39559-2.rs:16:15\n    |\n LL |         = [0; Dim3::dim()];\n    |               ^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 2 previous errors\n "}, {"sha": "cebcca944af82b9ef1524ed622476f6dc393e080", "filename": "src/test/ui/never_type/issue-52443.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -8,7 +8,7 @@ fn main() {\n \n     [(); { for _ in 0usize.. {}; 0}];\n     //~^ ERROR `for` is not allowed in a `const`\n-    //~| ERROR calls in constants are limited to constant functions\n+    //~| ERROR cannot convert\n     //~| ERROR mutable references are not allowed in constants\n-    //~| ERROR calls in constants are limited to constant functions\n+    //~| ERROR cannot call non-const fn\n }"}, {"sha": "8c1755205f0253b82f6026b5d05f2508c4d831f0", "filename": "src/test/ui/never_type/issue-52443.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -38,11 +38,18 @@ LL |     [(); loop { break }];\n    |                 expected `usize`, found `()`\n    |                 help: give it a value of the expected type: `break 42`\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot convert `RangeFrom<usize>` into an iterator in constants\n   --> $DIR/issue-52443.rs:9:21\n    |\n LL |     [(); { for _ in 0usize.. {}; 0}];\n    |                     ^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+   |\n+LL | impl<I: Iterator> IntoIterator for I {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error[E0658]: mutable references are not allowed in constants\n   --> $DIR/issue-52443.rs:9:21\n@@ -53,11 +60,13 @@ LL |     [(); { for _ in 0usize.. {}; 0}];\n    = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n    = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<RangeFrom<usize> as Iterator>::next` in constants\n   --> $DIR/issue-52443.rs:9:21\n    |\n LL |     [(); { for _ in 0usize.. {}; 0}];\n    |                     ^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 6 previous errors; 1 warning emitted\n "}, {"sha": "24b9235bb9a76fe28359c1bbaa9604b367e53a44", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-const-trait-method-fail.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -22,7 +22,8 @@ pub const fn add_i32(a: i32, b: i32) -> i32 {\n \n pub const fn add_u32(a: u32, b: u32) -> u32 {\n     a.plus(b)\n-    //~^ ERROR calls in constant functions are limited to constant functions\n+    //~^ ERROR the trait bound\n+    //~| ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "1fc9db277610e5a45c483fe8ef6f8e04274816b6", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-const-trait-method-fail.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,9 +1,24 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/call-const-trait-method-fail.rs:24:5\n+error[E0277]: the trait bound `u32: ~const Plus` is not satisfied\n+  --> $DIR/call-const-trait-method-fail.rs:24:7\n    |\n LL |     a.plus(b)\n-   |     ^^^^^^^^^\n+   |       ^^^^^^^ the trait `~const Plus` is not implemented for `u32`\n+   |\n+note: the trait `Plus` is implemented for `u32`, but that implementation is not `const`\n+  --> $DIR/call-const-trait-method-fail.rs:24:7\n+   |\n+LL |     a.plus(b)\n+   |       ^^^^^^^\n+\n+error[E0015]: cannot call non-const fn `<u32 as Plus>::plus` in constant functions\n+  --> $DIR/call-const-trait-method-fail.rs:24:7\n+   |\n+LL |     a.plus(b)\n+   |       ^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "e81e0d1e571c32283e6ad127683f2c8fb97d363c", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-generic-method-fail.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -3,7 +3,8 @@\n \n pub const fn equals_self<T: PartialEq>(t: &T) -> bool {\n     *t == *t\n-    //~^ ERROR calls in constant functions are limited to constant functions\n+    //~^ ERROR can't compare\n+    //~| ERROR cannot call non-const\n }\n \n fn main() {}"}, {"sha": "3963f64ad32b3b90b59cb9f2b9ae9b7588012b38", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-generic-method-fail.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,9 +1,28 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0277]: can't compare `T` with `T` in const contexts\n+  --> $DIR/call-generic-method-fail.rs:5:5\n+   |\n+LL |     *t == *t\n+   |     ^^^^^^^^ no implementation for `T == T`\n+   |\n+note: the trait `PartialEq` is implemented for `T`, but that implementation is not `const`\n   --> $DIR/call-generic-method-fail.rs:5:5\n    |\n LL |     *t == *t\n    |     ^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0015]: cannot call non-const operator in constant functions\n+  --> $DIR/call-generic-method-fail.rs:5:5\n+   |\n+LL |     *t == *t\n+   |     ^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+help: consider further restricting this bound\n+   |\n+LL | pub const fn equals_self<T: PartialEq + ~const std::cmp::PartialEq>(t: &T) -> bool {\n+   |                                       ++++++++++++++++++++++++++++\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "b3e3dd62be804bfa406e7e432f989e2486499cd0", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-check-fns-in-const-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -9,7 +9,7 @@ fn non_const() {}\n \n impl const T for S {\n     fn foo() { non_const() }\n-    //~^ ERROR calls in constant functions\n+    //~^ ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "9e49785c589e16516a6aaa5ea2cfe1213de21061", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-check-fns-in-const-impl.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `non_const` in constant functions\n   --> $DIR/const-check-fns-in-const-impl.rs:11:16\n    |\n LL |     fn foo() { non_const() }\n    |                ^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "3e87787a09195aedbdbc0fe420f33aad50a95663", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-default-method-bodies.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -23,7 +23,8 @@ impl const ConstDefaultFn for ConstImpl {\n \n const fn test() {\n     NonConstImpl.a();\n-    //~^ ERROR calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+    //~^ ERROR the trait bound\n+    //~| ERROR cannot call non-const fn\n     ConstImpl.a();\n }\n "}, {"sha": "948830d6def58f7388ccf8d5859f74fe410947cd", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-default-method-bodies.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,9 +1,24 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/const-default-method-bodies.rs:25:5\n+error[E0277]: the trait bound `NonConstImpl: ~const ConstDefaultFn` is not satisfied\n+  --> $DIR/const-default-method-bodies.rs:25:18\n    |\n LL |     NonConstImpl.a();\n-   |     ^^^^^^^^^^^^^^^^\n+   |                  ^^^ the trait `~const ConstDefaultFn` is not implemented for `NonConstImpl`\n+   |\n+note: the trait `ConstDefaultFn` is implemented for `NonConstImpl`, but that implementation is not `const`\n+  --> $DIR/const-default-method-bodies.rs:25:18\n+   |\n+LL |     NonConstImpl.a();\n+   |                  ^^^\n+\n+error[E0015]: cannot call non-const fn `<NonConstImpl as ConstDefaultFn>::a` in constant functions\n+  --> $DIR/const-default-method-bodies.rs:25:18\n+   |\n+LL |     NonConstImpl.a();\n+   |                  ^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "3ca9abb139b86e03753ef05983a639b40360af8b", "filename": "src/test/ui/rfc-2632-const-trait-impl/cross-crate.gated.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gated.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,9 +1,24 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/cross-crate.rs:15:5\n+error[E0277]: the trait bound `cross_crate::NonConst: ~const cross_crate::MyTrait` is not satisfied\n+  --> $DIR/cross-crate.rs:15:14\n    |\n LL |     NonConst.func();\n-   |     ^^^^^^^^^^^^^^^\n+   |              ^^^^^^ the trait `~const cross_crate::MyTrait` is not implemented for `cross_crate::NonConst`\n+   |\n+note: the trait `cross_crate::MyTrait` is implemented for `cross_crate::NonConst`, but that implementation is not `const`\n+  --> $DIR/cross-crate.rs:15:14\n+   |\n+LL |     NonConst.func();\n+   |              ^^^^^^\n+\n+error[E0015]: cannot call non-const fn `<cross_crate::NonConst as cross_crate::MyTrait>::func` in constant functions\n+  --> $DIR/cross-crate.rs:15:14\n+   |\n+LL |     NonConst.func();\n+   |              ^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "fa049ab86ff49c0b1016760e0e3618e7cf4b5463", "filename": "src/test/ui/rfc-2632-const-trait-impl/cross-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -12,10 +12,10 @@ fn non_const_context() {\n }\n \n const fn const_context() {\n-    NonConst.func();\n-    //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+    NonConst.func(); //~ ERROR: cannot call non-const fn\n+    //[gated]~^ ERROR: the trait bound\n     Const.func();\n-    //[stock]~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+    //[stock]~^ ERROR: cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "ea75ad0aeaf8c2eba9b92532aa86fa856f9a9833", "filename": "src/test/ui/rfc-2632-const-trait-impl/cross-crate.stock.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stock.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,14 +1,18 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/cross-crate.rs:15:5\n+error[E0015]: cannot call non-const fn `<cross_crate::NonConst as cross_crate::MyTrait>::func` in constant functions\n+  --> $DIR/cross-crate.rs:15:14\n    |\n LL |     NonConst.func();\n-   |     ^^^^^^^^^^^^^^^\n+   |              ^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/cross-crate.rs:17:5\n+error[E0015]: cannot call non-const fn `<cross_crate::Const as cross_crate::MyTrait>::func` in constant functions\n+  --> $DIR/cross-crate.rs:17:11\n    |\n LL |     Const.func();\n-   |     ^^^^^^^^^^^^\n+   |           ^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4d087b5180be4c29cf259a646ecf83181eae0eaf", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-same-trait-ck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -8,7 +8,8 @@ pub trait Tr {\n     #[default_method_body_is_const]\n     fn b(&self) {\n         ().a()\n-        //~^ ERROR calls in constant functions are limited\n+        //~^ ERROR the trait bound\n+        //~| ERROR cannot call\n     }\n }\n "}, {"sha": "db4d61f88ab2f08a85e66bae320e31da06633aa5", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-same-trait-ck.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,9 +1,24 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/default-method-body-is-const-same-trait-ck.rs:10:9\n+error[E0277]: the trait bound `(): ~const Tr` is not satisfied\n+  --> $DIR/default-method-body-is-const-same-trait-ck.rs:10:12\n    |\n LL |         ().a()\n-   |         ^^^^^^\n+   |            ^^^ the trait `~const Tr` is not implemented for `()`\n+   |\n+note: the trait `Tr` is implemented for `()`, but that implementation is not `const`\n+  --> $DIR/default-method-body-is-const-same-trait-ck.rs:10:12\n+   |\n+LL |         ().a()\n+   |            ^^^\n+\n+error[E0015]: cannot call non-const fn `<() as Tr>::a` in constant functions\n+  --> $DIR/default-method-body-is-const-same-trait-ck.rs:10:12\n+   |\n+LL |         ().a()\n+   |            ^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "cbe3fe0ce5f3f461be5606e7687de5ef0ce92459", "filename": "src/test/ui/rfc-2632-const-trait-impl/issue-88155.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -7,7 +7,8 @@ pub trait A {\n \n pub const fn foo<T: A>() -> bool {\n     T::assoc()\n-    //~^ ERROR calls in constant functions are limited\n+    //~^ ERROR the trait bound\n+    //~| ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "931c0b3658fd9d4f0d26e30a29ca46fbc36b0256", "filename": "src/test/ui/rfc-2632-const-trait-impl/issue-88155.stderr", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,9 +1,24 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0277]: the trait bound `T: ~const A` is not satisfied\n+  --> $DIR/issue-88155.rs:9:5\n+   |\n+LL |     T::assoc()\n+   |     ^^^^^^^^^^ the trait `~const A` is not implemented for `T`\n+   |\n+note: the trait `A` is implemented for `T`, but that implementation is not `const`\n+  --> $DIR/issue-88155.rs:9:5\n+   |\n+LL |     T::assoc()\n+   |     ^^^^^^^^^^\n+\n+error[E0015]: cannot call non-const fn `<T as A>::assoc` in constant functions\n   --> $DIR/issue-88155.rs:9:5\n    |\n LL |     T::assoc()\n    |     ^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "2f54c09e31c9e023d5e31966b3f89f72762e8727", "filename": "src/test/ui/rfc-2632-const-trait-impl/std-impl-gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.rs?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -11,7 +11,7 @@ fn non_const_context() -> Vec<usize> {\n \n const fn const_context() -> Vec<usize> {\n     Default::default()\n-    //[stock]~^ ERROR calls in constant functions are limited\n+    //[stock]~^ ERROR cannot call non-const fn\n }\n \n fn main() {"}, {"sha": "0b450a9474282bc5502f9ec2333e585b089da1cd", "filename": "src/test/ui/rfc-2632-const-trait-impl/std-impl-gate.stock.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.stock.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<Vec<usize> as Default>::default` in constant functions\n   --> $DIR/std-impl-gate.rs:13:5\n    |\n LL |     Default::default()\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "84fc638a973cb58a1b3582138e59e81addc3b7fc", "filename": "src/test/ui/static/static-vec-repeat-not-constant.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fstatic%2Fstatic-vec-repeat-not-constant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/953c4dcc30636d477505f4e397c63d57a760dffa/src%2Ftest%2Fui%2Fstatic%2Fstatic-vec-repeat-not-constant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-vec-repeat-not-constant.stderr?ref=953c4dcc30636d477505f4e397c63d57a760dffa", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `foo` in statics\n   --> $DIR/static-vec-repeat-not-constant.rs:3:25\n    |\n LL | static a: [isize; 2] = [foo(); 2];\n    |                         ^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}]}