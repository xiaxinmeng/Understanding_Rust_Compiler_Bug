{"sha": "fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOTE2ZmI5ZjA0OTYwOTdmNWVkYzJjMGZiNmMzMGViMGUxYzRhNWQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-07T07:36:53Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-07T07:56:12Z"}, "message": "Give up on providing a by-value version of map, convert fold over to\npassing pointers by ref\n\nIssue #1008", "tree": {"sha": "5f5a7da431a07fada931cca5898c3e462b8f0f7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f5a7da431a07fada931cca5898c3e462b8f0f7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "html_url": "https://github.com/rust-lang/rust/commit/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "html_url": "https://github.com/rust-lang/rust/commit/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286"}], "stats": {"total": 213, "additions": 98, "deletions": 115}, "files": [{"sha": "7d1c6eea7aea8bd737fa105a4b8c14ea14181bd3", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "patch": "@@ -29,8 +29,8 @@ fn fold_mod(cfg: ast::crate_cfg, m: ast::_mod, fld: fold::ast_fold) ->\n    ast::_mod {\n     let filter = bind filter_item(cfg, _);\n     let filtered_items = vec::filter_map(filter, m.items);\n-    ret {view_items: vec::map_imm(fld.fold_view_item, m.view_items),\n-         items: vec::map_imm(fld.fold_item, filtered_items)};\n+    ret {view_items: vec::map(fld.fold_view_item, m.view_items),\n+         items: vec::map(fld.fold_item, filtered_items)};\n }\n \n fn filter_native_item(cfg: ast::crate_cfg, &&item: @ast::native_item) ->\n@@ -46,7 +46,7 @@ fn fold_native_mod(cfg: ast::crate_cfg, nm: ast::native_mod,\n     let filtered_items = vec::filter_map(filter, nm.items);\n     ret {native_name: nm.native_name,\n          abi: nm.abi,\n-         view_items: vec::map_imm(fld.fold_view_item, nm.view_items),\n+         view_items: vec::map(fld.fold_view_item, nm.view_items),\n          items: filtered_items};\n }\n \n@@ -71,8 +71,8 @@ fn fold_block(cfg: ast::crate_cfg, b: ast::blk_, fld: fold::ast_fold) ->\n    ast::blk_ {\n     let filter = bind filter_stmt(cfg, _);\n     let filtered_stmts = vec::filter_map(filter, b.stmts);\n-    ret {stmts: vec::map_imm(fld.fold_stmt, filtered_stmts),\n-         expr: option::map_imm(fld.fold_expr, b.expr),\n+    ret {stmts: vec::map(fld.fold_stmt, filtered_stmts),\n+         expr: option::map(fld.fold_expr, b.expr),\n          id: b.id,\n          rules: b.rules};\n }"}, {"sha": "78b6388b17a296947b88b0ff6fea812c48572b8d", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "patch": "@@ -82,7 +82,7 @@ fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n }\n \n \n-fn fold_item(cx: test_ctxt, i: @ast::item, fld: fold::ast_fold) ->\n+fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n    @ast::item {\n \n     cx.path += [i.ident];"}, {"sha": "9500b8b11280b63797135cd0e2d864240cc25da6", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "patch": "@@ -70,9 +70,9 @@ fn empty_ann(num_vars: uint) -> ts_ann {\n           states: empty_states(num_vars)};\n }\n \n-fn get_pre(p: pre_and_post) -> precond { ret p.precondition; }\n+fn get_pre(&&p: pre_and_post) -> precond { ret p.precondition; }\n \n-fn get_post(p: pre_and_post) -> postcond { ret p.postcondition; }\n+fn get_post(&&p: pre_and_post) -> postcond { ret p.postcondition; }\n \n fn difference(p1: precond, p2: precond) -> bool {\n     ret tritv_difference(p1, p2);"}, {"sha": "3a7973e5e458b0f1fdd9a4e35cf9b595003a2c69", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "patch": "@@ -96,13 +96,13 @@ fn find_pre_post_exprs(fcx: fn_ctxt, args: [@expr], id: node_id) {\n     fn do_one(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n     for e: @expr in args { do_one(fcx, e); }\n \n-    fn get_pp(ccx: crate_ctxt, e: @expr) -> pre_and_post {\n+    fn get_pp(ccx: crate_ctxt, &&e: @expr) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n-    let pps = vec::map_imm(bind get_pp(fcx.ccx, _), args);\n+    let pps = vec::map(bind get_pp(fcx.ccx, _), args);\n \n     set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n-                     seq_postconds(fcx, vec::map_imm(get_post, pps)));\n+                     seq_postconds(fcx, vec::map(get_post, pps)));\n }\n \n fn find_pre_post_loop(fcx: fn_ctxt, l: @local, index: @expr, body: blk,"}, {"sha": "d284ffdadca1ef98389c7883bc06a099467e00b0", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "patch": "@@ -239,7 +239,8 @@ fn default_arg_mode_for_ty(tcx: ty::ctxt, m: ast::mode,\n       _ { m }\n     }\n }\n-fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, ast_ty: @ast::ty) -> ty::t {\n+fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, &&ast_ty: @ast::ty)\n+    -> ty::t {\n     fn ast_arg_to_arg(tcx: ty::ctxt, getter: ty_getter, arg: ast::ty_arg)\n         -> {mode: ty::mode, ty: ty::t} {\n         let ty = ast_ty_to_ty(tcx, getter, arg.node.ty);\n@@ -311,7 +312,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, ast_ty: @ast::ty) -> ty::t {\n         typ = ty::mk_ptr(tcx, ast_mt_to_mt(tcx, getter, mt));\n       }\n       ast::ty_tup(fields) {\n-        let flds = vec::map_imm(bind ast_ty_to_ty(tcx, getter, _), fields);\n+        let flds = vec::map(bind ast_ty_to_ty(tcx, getter, _), fields);\n         typ = ty::mk_tup(tcx, flds);\n       }\n       ast::ty_rec(fields) {\n@@ -398,7 +399,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, ast_ty: @ast::ty) -> ty::t {\n \n // A convenience function to use a crate_ctxt to resolve names for\n // ast_ty_to_ty.\n-fn ast_ty_to_ty_crate(ccx: @crate_ctxt, ast_ty: @ast::ty) -> ty::t {\n+fn ast_ty_to_ty_crate(ccx: @crate_ctxt, &&ast_ty: @ast::ty) -> ty::t {\n     fn getter(ccx: @crate_ctxt, id: ast::def_id) ->\n        ty::ty_param_kinds_and_ty {\n         ret ty::lookup_item_type(ccx.tcx, id);\n@@ -408,7 +409,7 @@ fn ast_ty_to_ty_crate(ccx: @crate_ctxt, ast_ty: @ast::ty) -> ty::t {\n }\n \n // A wrapper around ast_ty_to_ty_crate that handles ty_infer.\n-fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, ast_ty: @ast::ty) ->\n+fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, &&ast_ty: @ast::ty) ->\n    option::t<ty::t> {\n     alt ast_ty.node {\n       ast::ty_infer. { none }\n@@ -417,7 +418,7 @@ fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, ast_ty: @ast::ty) ->\n }\n // A wrapper around ast_ty_to_ty_infer that generates a new type variable if\n // there isn't a fixed type.\n-fn ast_ty_to_ty_crate_tyvar(fcx: @fn_ctxt, ast_ty: @ast::ty) -> ty::t {\n+fn ast_ty_to_ty_crate_tyvar(fcx: @fn_ctxt, &&ast_ty: @ast::ty) -> ty::t {\n     alt ast_ty_to_ty_crate_infer(fcx.ccx, ast_ty) {\n       some(ty) { ty }\n       none. { next_ty_var(fcx) }\n@@ -515,7 +516,7 @@ mod collect {\n         ret k;\n     }\n \n-    fn ty_of_fn_decl(cx: @ctxt, convert: fn(@ast::ty) -> ty::t,\n+    fn ty_of_fn_decl(cx: @ctxt, convert: fn(&&@ast::ty) -> ty::t,\n                      ty_of_arg: fn(ast::arg) -> arg, decl: ast::fn_decl,\n                      proto: ast::proto, ty_params: [ast::ty_param],\n                      def_id: option::t<ast::def_id>) ->\n@@ -535,7 +536,7 @@ mod collect {\n         alt def_id { some(did) { cx.tcx.tcache.insert(did, tpt); } _ { } }\n         ret tpt;\n     }\n-    fn ty_of_native_fn_decl(cx: @ctxt, convert: fn(@ast::ty) -> ty::t,\n+    fn ty_of_native_fn_decl(cx: @ctxt, convert: fn(&&@ast::ty) -> ty::t,\n                             ty_of_arg: fn(ast::arg) -> arg,\n                             decl: ast::fn_decl, abi: ast::native_abi,\n                             ty_params: [ast::ty_param], def_id: ast::def_id)"}, {"sha": "966d1f95c006be6324444bc1593c666db1004f19", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "patch": "@@ -263,10 +263,10 @@ iter free_vars(b: bindings, e: @expr) -> ident {\n \n /* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n-                    recur: fn(@expr) -> @expr, exprs: [@expr]) -> [@expr] {\n+                    recur: fn(&&@expr) -> @expr, exprs: [@expr]) -> [@expr] {\n     alt elts_to_ell(cx, exprs) {\n       {pre: pre, rep: repeat_me_maybe, post: post} {\n-        let res = vec::map_imm(recur, pre);\n+        let res = vec::map(recur, pre);\n         alt repeat_me_maybe {\n           none. { }\n           some(repeat_me) {\n@@ -315,7 +315,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n             }\n           }\n         }\n-        res += vec::map_imm(recur, post);\n+        res += vec::map(recur, post);\n         ret res;\n       }\n     }"}, {"sha": "2249cf66147b80b9c174c927cb8bee28c153f1ee", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 76, "deletions": 78, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "patch": "@@ -23,8 +23,8 @@ type ast_fold_precursor =\n     {fold_crate: fn(crate_, ast_fold) -> crate_,\n      fold_crate_directive: fn(crate_directive_, ast_fold) -> crate_directive_,\n      fold_view_item: fn(view_item_, ast_fold) -> view_item_,\n-     fold_native_item: fn(@native_item, ast_fold) -> @native_item,\n-     fold_item: fn(@item, ast_fold) -> @item,\n+     fold_native_item: fn(&&@native_item, ast_fold) -> @native_item,\n+     fold_item: fn(&&@item, ast_fold) -> @item,\n      fold_item_underscore: fn(item_, ast_fold) -> item_,\n      fold_method: fn(method_, ast_fold) -> method_,\n      fold_block: fn(blk_, ast_fold) -> blk_,\n@@ -42,75 +42,75 @@ type ast_fold_precursor =\n      fold_ident: fn(ident, ast_fold) -> ident,\n      fold_path: fn(path_, ast_fold) -> path_,\n      fold_local: fn(local_, ast_fold) -> local_,\n-     map_exprs: fn(fn(@expr) -> @expr, [@expr]) -> [@expr],\n+     map_exprs: fn(fn(&&@expr) -> @expr, [@expr]) -> [@expr],\n      new_id: fn(node_id) -> node_id,\n      new_span: fn(span) -> span};\n \n type a_f =\n     {fold_crate: fn(crate) -> crate,\n-     fold_crate_directive: fn(@crate_directive) -> @crate_directive,\n-     fold_view_item: fn(@view_item) -> @view_item,\n-     fold_native_item: fn(@native_item) -> @native_item,\n-     fold_item: fn(@item) -> @item,\n+     fold_crate_directive: fn(&&@crate_directive) -> @crate_directive,\n+     fold_view_item: fn(&&@view_item) -> @view_item,\n+     fold_native_item: fn(&&@native_item) -> @native_item,\n+     fold_item: fn(&&@item) -> @item,\n      fold_item_underscore: fn(item_) -> item_,\n-     fold_method: fn(@method) -> @method,\n+     fold_method: fn(&&@method) -> @method,\n      fold_block: fn(blk) -> blk,\n-     fold_stmt: fn(@stmt) -> @stmt,\n+     fold_stmt: fn(&&@stmt) -> @stmt,\n      fold_arm: fn(arm) -> arm,\n-     fold_pat: fn(@pat) -> @pat,\n-     fold_decl: fn(@decl) -> @decl,\n-     fold_expr: fn(@expr) -> @expr,\n-     fold_ty: fn(@ty) -> @ty,\n-     fold_constr: fn(@constr) -> @constr,\n+     fold_pat: fn(&&@pat) -> @pat,\n+     fold_decl: fn(&&@decl) -> @decl,\n+     fold_expr: fn(&&@expr) -> @expr,\n+     fold_ty: fn(&&@ty) -> @ty,\n+     fold_constr: fn(&&@constr) -> @constr,\n      fold_fn: fn(_fn) -> _fn,\n      fold_mod: fn(_mod) -> _mod,\n      fold_native_mod: fn(native_mod) -> native_mod,\n      fold_variant: fn(variant) -> variant,\n      fold_ident: fn(ident) -> ident,\n      fold_path: fn(path) -> path,\n-     fold_local: fn(@local) -> @local,\n-     map_exprs: fn(fn(@expr) -> @expr, [@expr]) -> [@expr],\n+     fold_local: fn(&&@local) -> @local,\n+     map_exprs: fn(fn(&&@expr) -> @expr, [@expr]) -> [@expr],\n      new_id: fn(node_id) -> node_id,\n      new_span: fn(span) -> span};\n \n \n //fn nf_dummy<T>(&T node) -> T { fail; }\n fn nf_crate_dummy(_c: crate) -> crate { fail; }\n-fn nf_crate_directive_dummy(_c: @crate_directive) -> @crate_directive {\n+fn nf_crate_directive_dummy(&&_c: @crate_directive) -> @crate_directive {\n     fail;\n }\n-fn nf_view_item_dummy(_v: @view_item) -> @view_item { fail; }\n-fn nf_native_item_dummy(_n: @native_item) -> @native_item { fail; }\n-fn nf_item_dummy(_i: @item) -> @item { fail; }\n+fn nf_view_item_dummy(&&_v: @view_item) -> @view_item { fail; }\n+fn nf_native_item_dummy(&&_n: @native_item) -> @native_item { fail; }\n+fn nf_item_dummy(&&_i: @item) -> @item { fail; }\n fn nf_item_underscore_dummy(_i: item_) -> item_ { fail; }\n-fn nf_method_dummy(_m: @method) -> @method { fail; }\n+fn nf_method_dummy(&&_m: @method) -> @method { fail; }\n fn nf_blk_dummy(_b: blk) -> blk { fail; }\n-fn nf_stmt_dummy(_s: @stmt) -> @stmt { fail; }\n+fn nf_stmt_dummy(&&_s: @stmt) -> @stmt { fail; }\n fn nf_arm_dummy(_a: arm) -> arm { fail; }\n-fn nf_pat_dummy(_p: @pat) -> @pat { fail; }\n-fn nf_decl_dummy(_d: @decl) -> @decl { fail; }\n-fn nf_expr_dummy(_e: @expr) -> @expr { fail; }\n-fn nf_ty_dummy(_t: @ty) -> @ty { fail; }\n-fn nf_constr_dummy(_c: @constr) -> @constr { fail; }\n+fn nf_pat_dummy(&&_p: @pat) -> @pat { fail; }\n+fn nf_decl_dummy(&&_d: @decl) -> @decl { fail; }\n+fn nf_expr_dummy(&&_e: @expr) -> @expr { fail; }\n+fn nf_ty_dummy(&&_t: @ty) -> @ty { fail; }\n+fn nf_constr_dummy(&&_c: @constr) -> @constr { fail; }\n fn nf_fn_dummy(_f: _fn) -> _fn { fail; }\n fn nf_mod_dummy(_m: _mod) -> _mod { fail; }\n fn nf_native_mod_dummy(_n: native_mod) -> native_mod { fail; }\n fn nf_variant_dummy(_v: variant) -> variant { fail; }\n fn nf_ident_dummy(_i: ident) -> ident { fail; }\n fn nf_path_dummy(_p: path) -> path { fail; }\n fn nf_obj_field_dummy(_o: obj_field) -> obj_field { fail; }\n-fn nf_local_dummy(_o: @local) -> @local { fail; }\n+fn nf_local_dummy(&&_o: @local) -> @local { fail; }\n \n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_(mi: @meta_item, fld: ast_fold) -> @meta_item {\n+fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n     ret @{node:\n               alt mi.node {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n                 meta_list(id, mis) {\n                   let fold_meta_item = bind fold_meta_item_(_, fld);\n-                  meta_list(id, vec::map_imm(fold_meta_item, mis))\n+                  meta_list(id, vec::map(fold_meta_item, mis))\n                 }\n                 meta_name_value(id, s) {\n                   meta_name_value(fld.fold_ident(id), s)\n@@ -119,7 +119,7 @@ fn fold_meta_item_(mi: @meta_item, fld: ast_fold) -> @meta_item {\n           span: mi.span};\n }\n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_(at: attribute, fmi: fn(@meta_item) -> @meta_item) ->\n+fn fold_attribute_(at: attribute, fmi: fn(&&@meta_item) -> @meta_item) ->\n    attribute {\n     ret {node: {style: at.node.style, value: *fmi(@at.node.value)},\n          span: at.span};\n@@ -146,17 +146,14 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n }\n \n \n-\n-\n-\n fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n \n-    ret {directives: vec::map_imm(fld.fold_crate_directive, c.directives),\n+    ret {directives: vec::map(fld.fold_crate_directive, c.directives),\n          module: fld.fold_mod(c.module),\n          attrs: vec::map(fold_attribute, c.attrs),\n-         config: vec::map_imm(fold_meta_item, c.config)};\n+         config: vec::map(fold_meta_item, c.config)};\n }\n \n fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n@@ -167,7 +164,7 @@ fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n           }\n           cdir_dir_mod(id, fname, cds, attrs) {\n             cdir_dir_mod(fld.fold_ident(id), fname,\n-                         vec::map_imm(fld.fold_crate_directive, cds), attrs)\n+                         vec::map(fld.fold_crate_directive, cds), attrs)\n           }\n           cdir_view_item(vi) { cdir_view_item(fld.fold_view_item(vi)) }\n           cdir_syntax(_) { cd }\n@@ -180,7 +177,7 @@ fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n }\n \n \n-fn noop_fold_native_item(ni: @native_item, fld: ast_fold) -> @native_item {\n+fn noop_fold_native_item(&&ni: @native_item, fld: ast_fold) -> @native_item {\n     let fold_arg = bind fold_arg_(_, fld);\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n@@ -198,15 +195,15 @@ fn noop_fold_native_item(ni: @native_item, fld: ast_fold) -> @native_item {\n                                   il: fdec.il,\n                                   cf: fdec.cf,\n                                   constraints:\n-                                      vec::map_imm(fld.fold_constr,\n+                                      vec::map(fld.fold_constr,\n                                                    fdec.constraints)}, typms)\n                 }\n               },\n           id: ni.id,\n           span: ni.span};\n }\n \n-fn noop_fold_item(i: @item, fld: ast_fold) -> @item {\n+fn noop_fold_item(&&i: @item, fld: ast_fold) -> @item {\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n \n@@ -237,7 +234,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           }\n           item_obj(o, typms, d) {\n             item_obj({fields: vec::map(fold_obj_field, o.fields),\n-                      methods: vec::map_imm(fld.fold_method, o.methods)},\n+                      methods: vec::map(fld.fold_method, o.methods)},\n                      typms, d)\n           }\n           item_res(dtor, did, typms, cid) {\n@@ -252,8 +249,8 @@ fn noop_fold_method(m: method_, fld: ast_fold) -> method_ {\n \n \n fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n-    ret {stmts: vec::map_imm(fld.fold_stmt, b.stmts),\n-         expr: option::map_imm(fld.fold_expr, b.expr),\n+    ret {stmts: vec::map(fld.fold_stmt, b.stmts),\n+         expr: option::map(fld.fold_expr, b.expr),\n          id: b.id,\n          rules: b.rules};\n }\n@@ -269,8 +266,8 @@ fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n }\n \n fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n-    ret {pats: vec::map_imm(fld.fold_pat, a.pats),\n-         guard: option::map_imm(fld.fold_expr, a.guard),\n+    ret {pats: vec::map(fld.fold_pat, a.pats),\n+         guard: option::map(fld.fold_expr, a.guard),\n          body: fld.fold_block(a.body)};\n }\n \n@@ -280,7 +277,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_bind(ident) { pat_bind(fld.fold_ident(ident)) }\n           pat_lit(_) { p }\n           pat_tag(pth, pats) {\n-            pat_tag(fld.fold_path(pth), vec::map_imm(fld.fold_pat, pats))\n+            pat_tag(fld.fold_path(pth), vec::map(fld.fold_pat, pats))\n           }\n           pat_rec(fields, etc) {\n             let fs = [];\n@@ -289,7 +286,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n             }\n             pat_rec(fs, etc)\n           }\n-          pat_tup(elts) { pat_tup(vec::map_imm(fld.fold_pat, elts)) }\n+          pat_tup(elts) { pat_tup(vec::map(fld.fold_pat, elts)) }\n           pat_box(inner) { pat_box(fld.fold_pat(inner)) }\n           pat_uniq(inner) { pat_uniq(fld.fold_pat(inner)) }\n           pat_range(_, _) { p }\n@@ -334,8 +331,8 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n                      option::some(vec::map(fold_anon_obj_field, v))\n                    }\n                  },\n-             methods: vec::map_imm(fld.fold_method, ao.methods),\n-             inner_obj: option::map_imm(fld.fold_expr, ao.inner_obj)}\n+             methods: vec::map(fld.fold_method, ao.methods),\n+             inner_obj: option::map(fld.fold_expr, ao.inner_obj)}\n     }\n     let fold_anon_obj = bind fold_anon_obj_(_, fld);\n \n@@ -347,15 +344,15 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_rec(fields, maybe_expr) {\n             expr_rec(vec::map(fold_field, fields),\n-                     option::map_imm(fld.fold_expr, maybe_expr))\n+                     option::map(fld.fold_expr, maybe_expr))\n           }\n-          expr_tup(elts) { expr_tup(vec::map_imm(fld.fold_expr, elts)) }\n+          expr_tup(elts) { expr_tup(vec::map(fld.fold_expr, elts)) }\n           expr_call(f, args) {\n             expr_call(fld.fold_expr(f), fld.map_exprs(fld.fold_expr, args))\n           }\n           expr_self_method(id) { expr_self_method(fld.fold_ident(id)) }\n           expr_bind(f, args) {\n-            let opt_map_se = bind option::map_imm(fld.fold_expr, _);\n+            let opt_map_se = bind option::map(fld.fold_expr, _);\n             expr_bind(fld.fold_expr(f), vec::map(opt_map_se, args))\n           }\n           expr_binary(binop, lhs, rhs) {\n@@ -366,7 +363,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_cast(expr, ty) { expr_cast(fld.fold_expr(expr), ty) }\n           expr_if(cond, tr, fl) {\n             expr_if(fld.fold_expr(cond), fld.fold_block(tr),\n-                    option::map_imm(fld.fold_expr, fl))\n+                    option::map(fld.fold_expr, fl))\n           }\n           expr_ternary(cond, tr, fl) {\n             expr_ternary(fld.fold_expr(cond), fld.fold_expr(tr),\n@@ -411,18 +408,18 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n           }\n           expr_path(pth) { expr_path(fld.fold_path(pth)) }\n-          expr_fail(e) { expr_fail(option::map_imm(fld.fold_expr, e)) }\n+          expr_fail(e) { expr_fail(option::map(fld.fold_expr, e)) }\n           expr_break. { e }\n           expr_cont. { e }\n-          expr_ret(e) { expr_ret(option::map_imm(fld.fold_expr, e)) }\n-          expr_put(e) { expr_put(option::map_imm(fld.fold_expr, e)) }\n+          expr_ret(e) { expr_ret(option::map(fld.fold_expr, e)) }\n+          expr_put(e) { expr_put(option::map(fld.fold_expr, e)) }\n           expr_be(e) { expr_be(fld.fold_expr(e)) }\n           expr_log(lv, e) { expr_log(lv, fld.fold_expr(e)) }\n           expr_assert(e) { expr_assert(fld.fold_expr(e)) }\n           expr_check(m, e) { expr_check(m, fld.fold_expr(e)) }\n           expr_if_check(cond, tr, fl) {\n             expr_if_check(fld.fold_expr(cond), fld.fold_block(tr),\n-                          option::map_imm(fld.fold_expr, fl))\n+                          option::map(fld.fold_expr, fl))\n           }\n           expr_anon_obj(ao) { expr_anon_obj(fold_anon_obj(ao)) }\n           expr_mac(mac) { expr_mac(fold_mac(mac)) }\n@@ -448,22 +445,22 @@ fn noop_fold_fn(f: _fn, fld: ast_fold) -> _fn {\n               purity: f.decl.purity,\n               il: f.decl.il,\n               cf: f.decl.cf,\n-              constraints: vec::map_imm(fld.fold_constr, f.decl.constraints)},\n+              constraints: vec::map(fld.fold_constr, f.decl.constraints)},\n          proto: f.proto,\n          body: fld.fold_block(f.body)};\n }\n \n // ...nor do modules\n fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n-    ret {view_items: vec::map_imm(fld.fold_view_item, m.view_items),\n-         items: vec::map_imm(fld.fold_item, m.items)};\n+    ret {view_items: vec::map(fld.fold_view_item, m.view_items),\n+         items: vec::map(fld.fold_item, m.items)};\n }\n \n fn noop_fold_native_mod(nm: native_mod, fld: ast_fold) -> native_mod {\n     ret {native_name: nm.native_name,\n          abi: nm.abi,\n-         view_items: vec::map_imm(fld.fold_view_item, nm.view_items),\n-         items: vec::map_imm(fld.fold_native_item, nm.items)}\n+         view_items: vec::map(fld.fold_view_item, nm.view_items),\n+         items: vec::map(fld.fold_native_item, nm.items)}\n }\n \n fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n@@ -479,7 +476,7 @@ fn noop_fold_ident(i: ident, _fld: ast_fold) -> ident { ret i; }\n fn noop_fold_path(p: path_, fld: ast_fold) -> path_ {\n     ret {global: p.global,\n          idents: vec::map(fld.fold_ident, p.idents),\n-         types: vec::map_imm(fld.fold_ty, p.types)};\n+         types: vec::map(fld.fold_ty, p.types)};\n }\n \n fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n@@ -498,8 +495,8 @@ fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n \n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n-fn noop_map_exprs(f: fn(@expr) -> @expr, es: [@expr]) -> [@expr] {\n-    ret vec::map_imm(f, es);\n+fn noop_map_exprs(f: fn(&&@expr) -> @expr, es: [@expr]) -> [@expr] {\n+    ret vec::map(f, es);\n }\n \n fn noop_id(i: node_id) -> node_id { ret i; }\n@@ -603,55 +600,56 @@ fn make_fold(afp: ast_fold_precursor) -> @foldres {\n         ret {node: afp.fold_crate(c.node, f), span: afp.new_span(c.span)};\n     }\n     fn f_crate_directive(afp: ast_fold_precursor, f: ast_fold,\n-                         c: @crate_directive) -> @crate_directive {\n+                         &&c: @crate_directive) -> @crate_directive {\n         ret @{node: afp.fold_crate_directive(c.node, f),\n               span: afp.new_span(c.span)};\n     }\n-    fn f_view_item(afp: ast_fold_precursor, f: ast_fold, x: @view_item) ->\n+    fn f_view_item(afp: ast_fold_precursor, f: ast_fold, &&x: @view_item) ->\n        @view_item {\n         ret @{node: afp.fold_view_item(x.node, f),\n               span: afp.new_span(x.span)};\n     }\n-    fn f_native_item(afp: ast_fold_precursor, f: ast_fold, x: @native_item) ->\n-       @native_item {\n+    fn f_native_item(afp: ast_fold_precursor, f: ast_fold, &&x: @native_item)\n+        -> @native_item {\n         ret afp.fold_native_item(x, f);\n     }\n-    fn f_item(afp: ast_fold_precursor, f: ast_fold, i: @item) -> @item {\n+    fn f_item(afp: ast_fold_precursor, f: ast_fold, &&i: @item) -> @item {\n         ret afp.fold_item(i, f);\n     }\n     fn f_item_underscore(afp: ast_fold_precursor, f: ast_fold, i: item_) ->\n        item_ {\n         ret afp.fold_item_underscore(i, f);\n     }\n-    fn f_method(afp: ast_fold_precursor, f: ast_fold, x: @method) -> @method {\n+    fn f_method(afp: ast_fold_precursor, f: ast_fold, &&x: @method)\n+        -> @method {\n         ret @{node: afp.fold_method(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_block(afp: ast_fold_precursor, f: ast_fold, x: blk) -> blk {\n         ret {node: afp.fold_block(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_stmt(afp: ast_fold_precursor, f: ast_fold, x: @stmt) -> @stmt {\n+    fn f_stmt(afp: ast_fold_precursor, f: ast_fold, &&x: @stmt) -> @stmt {\n         ret @{node: afp.fold_stmt(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_arm(afp: ast_fold_precursor, f: ast_fold, x: arm) -> arm {\n         ret afp.fold_arm(x, f);\n     }\n-    fn f_pat(afp: ast_fold_precursor, f: ast_fold, x: @pat) -> @pat {\n+    fn f_pat(afp: ast_fold_precursor, f: ast_fold, &&x: @pat) -> @pat {\n         ret @{id: afp.new_id(x.id),\n               node: afp.fold_pat(x.node, f),\n               span: afp.new_span(x.span)};\n     }\n-    fn f_decl(afp: ast_fold_precursor, f: ast_fold, x: @decl) -> @decl {\n+    fn f_decl(afp: ast_fold_precursor, f: ast_fold, &&x: @decl) -> @decl {\n         ret @{node: afp.fold_decl(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_expr(afp: ast_fold_precursor, f: ast_fold, x: @expr) -> @expr {\n+    fn f_expr(afp: ast_fold_precursor, f: ast_fold, &&x: @expr) -> @expr {\n         ret @{id: afp.new_id(x.id),\n               node: afp.fold_expr(x.node, f),\n               span: afp.new_span(x.span)};\n     }\n-    fn f_ty(afp: ast_fold_precursor, f: ast_fold, x: @ty) -> @ty {\n+    fn f_ty(afp: ast_fold_precursor, f: ast_fold, &&x: @ty) -> @ty {\n         ret @{node: afp.fold_ty(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_constr(afp: ast_fold_precursor, f: ast_fold, x: @ast::constr) ->\n+    fn f_constr(afp: ast_fold_precursor, f: ast_fold, &&x: @ast::constr) ->\n        @ast::constr {\n         ret @{node: afp.fold_constr(x.node, f), span: afp.new_span(x.span)};\n     }\n@@ -675,7 +673,7 @@ fn make_fold(afp: ast_fold_precursor) -> @foldres {\n     fn f_path(afp: ast_fold_precursor, f: ast_fold, x: path) -> path {\n         ret {node: afp.fold_path(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_local(afp: ast_fold_precursor, f: ast_fold, x: @local) -> @local {\n+    fn f_local(afp: ast_fold_precursor, f: ast_fold, &&x: @local) -> @local {\n         ret @{node: afp.fold_local(x.node, f), span: afp.new_span(x.span)};\n     }\n "}, {"sha": "53c19ba8c0ab55929dd24678207f2809327d17a5", "filename": "src/lib/option.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "patch": "@@ -9,11 +9,6 @@ fn get<@T>(opt: t<T>) -> &T {\n fn map<@T, @U>(f: block(T) -> U, opt: t<T>) -> t<U> {\n     alt opt { some(x) { some(f(x)) } none. { none } }\n }\n-// FIXME This is needed to make working with by-value functions a bit less\n-// painful. We should come up with a better solution.\n-fn map_imm<@T, @U>(f: block(+T) -> U, opt: t<T>) -> t<U> {\n-    alt opt { some(x) { some(f(x)) } none. { none } }\n-}\n \n fn is_none<@T>(opt: t<T>) -> bool {\n     alt opt { none. { true } some(_) { false } }"}, {"sha": "59f29d40d7c1f751d45ef75056a4948b82faf8cf", "filename": "src/lib/vec.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=fe916fb9f0496097f5edc2c0fb6c30eb0e1c4a5d", "patch": "@@ -191,17 +191,6 @@ fn map<@T, @U>(f: block(T) -> U, v: [mutable? T]) -> [U] {\n     }\n     ret result;\n }\n-// FIXME This is needed to make working with by-value functions a bit less\n-// painful. We should come up with a better solution.\n-fn map_imm<@T, @U>(f: block(+T) -> U, v: [mutable? T]) -> [U] {\n-    let result = [];\n-    reserve(result, len(v));\n-    for elem: T in v {\n-        let elem2 = elem; // satisfies alias checker\n-        result += [f(elem2)];\n-    }\n-    ret result;\n-}\n \n fn map2<@T, @U, @V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n     let v0_len = len::<T>(v0);"}]}