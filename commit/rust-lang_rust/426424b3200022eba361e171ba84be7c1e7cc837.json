{"sha": "426424b3200022eba361e171ba84be7c1e7cc837", "node_id": "C_kwDOAAsO6NoAKDQyNjQyNGIzMjAwMDIyZWJhMzYxZTE3MWJhODRiZTdjMWU3Y2M4Mzc", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-10-02T05:45:15Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-10-02T19:50:19Z"}, "message": "Make it a lint for all opaque types", "tree": {"sha": "67b494b4d9bf17ce783dae2887655738ebcfe996", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67b494b4d9bf17ce783dae2887655738ebcfe996"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/426424b3200022eba361e171ba84be7c1e7cc837", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/426424b3200022eba361e171ba84be7c1e7cc837", "html_url": "https://github.com/rust-lang/rust/commit/426424b3200022eba361e171ba84be7c1e7cc837", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/426424b3200022eba361e171ba84be7c1e7cc837/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0d6af91467ef60f12396f5d40a09eb4de8cb8b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d6af91467ef60f12396f5d40a09eb4de8cb8b7", "html_url": "https://github.com/rust-lang/rust/commit/d0d6af91467ef60f12396f5d40a09eb4de8cb8b7"}], "stats": {"total": 384, "additions": 237, "deletions": 147}, "files": [{"sha": "0fd9b0ead167c31eccd5e0bfe0e2a9c55cded87b", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -434,6 +434,6 @@ lint_check_name_warning = {$msg}\n \n lint_check_name_deprecated = lint name `{$lint_name}` is deprecated and does not have an effect anymore. Use: {$new_name}\n \n-lint_rpit_hidden_inferred_bound = return-position `{$ty}` does not satisfy its associated type bounds\n+lint_opaque_hidden_inferred_bound = opaque type `{$ty}` does not satisfy its associated type bounds\n     .specifically = this associated type bound is unsatisfied for `{$proj_ty}`\n     .suggestion = add this bound"}, {"sha": "9148c42195fbed1156064a2163c1e03498f8b345", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -62,10 +62,10 @@ mod non_ascii_idents;\n mod non_fmt_panic;\n mod nonstandard_style;\n mod noop_method_call;\n+mod opaque_hidden_inferred_bound;\n mod pass_by_value;\n mod passes;\n mod redundant_semicolon;\n-mod rpit_hidden_inferred_bound;\n mod traits;\n mod types;\n mod unused;\n@@ -94,9 +94,9 @@ use non_ascii_idents::*;\n use non_fmt_panic::NonPanicFmt;\n use nonstandard_style::*;\n use noop_method_call::*;\n+use opaque_hidden_inferred_bound::*;\n use pass_by_value::*;\n use redundant_semicolon::*;\n-use rpit_hidden_inferred_bound::*;\n use traits::*;\n use types::*;\n use unused::*;\n@@ -225,7 +225,7 @@ macro_rules! late_lint_mod_passes {\n                 EnumIntrinsicsNonEnums: EnumIntrinsicsNonEnums,\n                 InvalidAtomicOrdering: InvalidAtomicOrdering,\n                 NamedAsmLabels: NamedAsmLabels,\n-                RpitHiddenInferredBound: RpitHiddenInferredBound,\n+                OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n             ]\n         );\n     };"}, {"sha": "7f18bf0018f6ff20b2278fd10caece9429fc5456", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -0,0 +1,125 @@\n+use rustc_hir as hir;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_macros::LintDiagnostic;\n+use rustc_middle::ty::{self, fold::BottomUpFolder, Ty, TypeFoldable};\n+use rustc_span::Span;\n+use rustc_trait_selection::traits;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+\n+use crate::{LateContext, LateLintPass, LintContext};\n+\n+declare_lint! {\n+    /// The `opaque_hidden_inferred_bound` lint detects cases in which nested\n+    /// `impl Trait` in associated type bounds are not written generally enough\n+    /// to satisfy the bounds of the associated type. This functionality was\n+    /// removed in #97346, but then rolled back in #99860 because it was made\n+    /// into a hard error too quickly.\n+    ///\n+    /// We plan on reintroducing this as a hard error, but in the mean time, this\n+    /// lint serves to warn and suggest fixes for any use-cases which rely on this\n+    /// behavior.\n+    pub OPAQUE_HIDDEN_INFERRED_BOUND,\n+    Warn,\n+    \"detects the use of nested `impl Trait` types in associated type bounds that are not general enough\"\n+}\n+\n+declare_lint_pass!(OpaqueHiddenInferredBound => [OPAQUE_HIDDEN_INFERRED_BOUND]);\n+\n+impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n+        let hir::ItemKind::OpaqueTy(_) = &item.kind else { return; };\n+        let def_id = item.def_id.def_id.to_def_id();\n+        cx.tcx.infer_ctxt().enter(|ref infcx| {\n+            // For every projection predicate in the opaque type's explicit bounds,\n+            // check that the type that we're assigning actually satisfies the bounds\n+            // of the associated type.\n+            for &(pred, pred_span) in cx.tcx.explicit_item_bounds(def_id) {\n+                // Liberate bound regions in the predicate since we\n+                // don't actually care about lifetimes in this check.\n+                let predicate = cx.tcx.liberate_late_bound_regions(\n+                    def_id,\n+                    pred.kind(),\n+                );\n+                let ty::PredicateKind::Projection(proj) = predicate else {\n+                    continue;\n+                };\n+                // Only check types, since those are the only things that may\n+                // have opaques in them anyways.\n+                let Some(proj_term) = proj.term.ty() else { continue };\n+\n+                let proj_ty =\n+                    cx\n+                    .tcx\n+                    .mk_projection(proj.projection_ty.item_def_id, proj.projection_ty.substs);\n+                // For every instance of the projection type in the bounds,\n+                // replace them with the term we're assigning to the associated\n+                // type in our opaque type.\n+                let proj_replacer = &mut BottomUpFolder {\n+                    tcx: cx.tcx,\n+                    ty_op: |ty| if ty == proj_ty { proj_term } else { ty },\n+                    lt_op: |lt| lt,\n+                    ct_op: |ct| ct,\n+                };\n+                // For example, in `impl Trait<Assoc = impl Send>`, for all of the bounds on `Assoc`,\n+                // e.g. `type Assoc: OtherTrait`, replace `<impl Trait as Trait>::Assoc: OtherTrait`\n+                // with `impl Send: OtherTrait`.\n+                for assoc_pred_and_span in cx\n+                    .tcx\n+                    .bound_explicit_item_bounds(proj.projection_ty.item_def_id)\n+                    .transpose_iter()\n+                {\n+                    let assoc_pred_span = assoc_pred_and_span.0.1;\n+                    let assoc_pred = assoc_pred_and_span\n+                        .map_bound(|(pred, _)| *pred)\n+                        .subst(cx.tcx, &proj.projection_ty.substs)\n+                        .fold_with(proj_replacer);\n+                    let Ok(assoc_pred) = traits::fully_normalize(infcx, traits::ObligationCause::dummy(), cx.param_env, assoc_pred) else {\n+                        continue;\n+                    };\n+                    // If that predicate doesn't hold modulo regions (but passed during type-check),\n+                    // then we must've taken advantage of the hack in `project_and_unify_types` where\n+                    // we replace opaques with inference vars. Emit a warning!\n+                    if !infcx.predicate_must_hold_modulo_regions(&traits::Obligation::new(\n+                        traits::ObligationCause::dummy(),\n+                        cx.param_env,\n+                        assoc_pred,\n+                    )) {\n+                        // If it's a trait bound and an opaque that doesn't satisfy it,\n+                        // then we can emit a suggestion to add the bound.\n+                        let (suggestion, suggest_span) =\n+                            match (proj_term.kind(), assoc_pred.kind().skip_binder()) {\n+                                (ty::Opaque(def_id, _), ty::PredicateKind::Trait(trait_pred)) => (\n+                                    format!(\" + {}\", trait_pred.print_modifiers_and_trait_path()),\n+                                    Some(cx.tcx.def_span(def_id).shrink_to_hi()),\n+                                ),\n+                                _ => (String::new(), None),\n+                            };\n+                        cx.emit_spanned_lint(\n+                            OPAQUE_HIDDEN_INFERRED_BOUND,\n+                            pred_span,\n+                            OpaqueHiddenInferredBoundLint {\n+                                ty: cx.tcx.mk_opaque(def_id, ty::InternalSubsts::identity_for_item(cx.tcx, def_id)),\n+                                proj_ty: proj_term,\n+                                assoc_pred_span,\n+                                suggestion,\n+                                suggest_span,\n+                            },\n+                        );\n+                    }\n+                }\n+            }\n+        });\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint::opaque_hidden_inferred_bound)]\n+struct OpaqueHiddenInferredBoundLint<'tcx> {\n+    ty: Ty<'tcx>,\n+    proj_ty: Ty<'tcx>,\n+    #[label(lint::specifically)]\n+    assoc_pred_span: Span,\n+    #[suggestion_verbose(applicability = \"machine-applicable\", code = \"{suggestion}\")]\n+    suggest_span: Option<Span>,\n+    suggestion: String,\n+}"}, {"sha": "fd9872c80a945725049598dd7ee7b7d8d808b7e1", "filename": "compiler/rustc_lint/src/rpit_hidden_inferred_bound.rs", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/d0d6af91467ef60f12396f5d40a09eb4de8cb8b7/compiler%2Frustc_lint%2Fsrc%2Frpit_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d6af91467ef60f12396f5d40a09eb4de8cb8b7/compiler%2Frustc_lint%2Fsrc%2Frpit_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Frpit_hidden_inferred_bound.rs?ref=d0d6af91467ef60f12396f5d40a09eb4de8cb8b7", "patch": "@@ -1,143 +0,0 @@\n-use hir::def_id::LocalDefId;\n-use rustc_hir as hir;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n-use rustc_macros::LintDiagnostic;\n-use rustc_middle::ty::{\n-    self, fold::BottomUpFolder, Ty, TypeFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n-};\n-use rustc_span::Span;\n-use rustc_trait_selection::traits;\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n-\n-use crate::{LateContext, LateLintPass, LintContext};\n-\n-declare_lint! {\n-    /// The `rpit_hidden_inferred_bound` lint detects cases in which nested RPITs\n-    /// in associated type bounds are not written generally enough to satisfy the\n-    /// bounds of the associated type. This functionality was removed in #97346,\n-    /// but then rolled back in #99860 because it was made into a hard error too\n-    /// quickly.\n-    ///\n-    /// We plan on reintroducing this as a hard error, but in the mean time, this\n-    /// lint serves to warn and suggest fixes for any use-cases which rely on this\n-    /// behavior.\n-    pub RPIT_HIDDEN_INFERRED_BOUND,\n-    Warn,\n-    \"detects the use of nested RPITs in associated type bounds that are not general enough\"\n-}\n-\n-declare_lint_pass!(RpitHiddenInferredBound => [RPIT_HIDDEN_INFERRED_BOUND]);\n-\n-impl<'tcx> LateLintPass<'tcx> for RpitHiddenInferredBound {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        kind: hir::intravisit::FnKind<'tcx>,\n-        _: &'tcx hir::FnDecl<'tcx>,\n-        _: &'tcx hir::Body<'tcx>,\n-        _: rustc_span::Span,\n-        id: hir::HirId,\n-    ) {\n-        if matches!(kind, hir::intravisit::FnKind::Closure) {\n-            return;\n-        }\n-\n-        let fn_def_id = cx.tcx.hir().local_def_id(id);\n-        let sig: ty::FnSig<'tcx> =\n-            cx.tcx.liberate_late_bound_regions(fn_def_id.to_def_id(), cx.tcx.fn_sig(fn_def_id));\n-        cx.tcx.infer_ctxt().enter(|ref infcx| {\n-            sig.output().visit_with(&mut VisitOpaqueBounds { infcx, cx, fn_def_id });\n-        });\n-    }\n-}\n-\n-struct VisitOpaqueBounds<'a, 'cx, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    cx: &'cx LateContext<'tcx>,\n-    fn_def_id: LocalDefId,\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for VisitOpaqueBounds<'_, '_, 'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n-        if let ty::Opaque(def_id, substs) = *ty.kind()\n-            && let Some(hir::Node::Item(item)) = self.cx.tcx.hir().get_if_local(def_id)\n-            && let hir::ItemKind::OpaqueTy(opaque) = &item.kind\n-            && let hir::OpaqueTyOrigin::FnReturn(origin_def_id) = opaque.origin\n-            && origin_def_id == self.fn_def_id\n-        {\n-            for pred_and_span in self.cx.tcx.bound_explicit_item_bounds(def_id).transpose_iter() {\n-                let pred_span = pred_and_span.0.1;\n-                let predicate = self.cx.tcx.liberate_late_bound_regions(\n-                    def_id,\n-                    pred_and_span.map_bound(|(pred, _)| *pred).subst(self.cx.tcx, substs).kind(),\n-                );\n-                let ty::PredicateKind::Projection(proj) = predicate else {\n-                    continue;\n-                };\n-                let Some(proj_term) = proj.term.ty() else { continue };\n-\n-                let proj_ty = self\n-                    .cx\n-                    .tcx\n-                    .mk_projection(proj.projection_ty.item_def_id, proj.projection_ty.substs);\n-                let proj_replacer = &mut BottomUpFolder {\n-                    tcx: self.cx.tcx,\n-                    ty_op: |ty| if ty == proj_ty { proj_term } else { ty },\n-                    lt_op: |lt| lt,\n-                    ct_op: |ct| ct,\n-                };\n-                for assoc_pred_and_span in self\n-                    .cx\n-                    .tcx\n-                    .bound_explicit_item_bounds(proj.projection_ty.item_def_id)\n-                    .transpose_iter()\n-                {\n-                    let assoc_pred_span = assoc_pred_and_span.0.1;\n-                    let assoc_pred = assoc_pred_and_span\n-                        .map_bound(|(pred, _)| *pred)\n-                        .subst(self.cx.tcx, &proj.projection_ty.substs)\n-                        .fold_with(proj_replacer);\n-                    if !self.infcx.predicate_must_hold_modulo_regions(&traits::Obligation::new(\n-                        traits::ObligationCause::dummy(),\n-                        self.cx.param_env,\n-                        assoc_pred,\n-                    )) {\n-                        let (suggestion, suggest_span) =\n-                            match (proj_term.kind(), assoc_pred.kind().skip_binder()) {\n-                                (ty::Opaque(def_id, _), ty::PredicateKind::Trait(trait_pred)) => (\n-                                    format!(\" + {}\", trait_pred.print_modifiers_and_trait_path()),\n-                                    Some(self.cx.tcx.def_span(def_id).shrink_to_hi()),\n-                                ),\n-                                _ => (String::new(), None),\n-                            };\n-                        self.cx.emit_spanned_lint(\n-                            RPIT_HIDDEN_INFERRED_BOUND,\n-                            pred_span,\n-                            RpitHiddenInferredBoundLint {\n-                                ty,\n-                                proj_ty: proj_term,\n-                                assoc_pred_span,\n-                                suggestion,\n-                                suggest_span,\n-                            },\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-\n-        ty.super_visit_with(self)\n-    }\n-}\n-\n-#[derive(LintDiagnostic)]\n-#[diag(lint::rpit_hidden_inferred_bound)]\n-struct RpitHiddenInferredBoundLint<'tcx> {\n-    ty: Ty<'tcx>,\n-    proj_ty: Ty<'tcx>,\n-    #[label(lint::specifically)]\n-    assoc_pred_span: Span,\n-    #[suggestion_verbose(applicability = \"machine-applicable\", code = \"{suggestion}\")]\n-    suggest_span: Option<Span>,\n-    suggestion: String,\n-}"}, {"sha": "089018a1cdf0106497c33188f7fe7c7452250046", "filename": "src/test/ui/impl-trait/nested-return-type2-tait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.rs?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -26,6 +26,7 @@ type Sendable = impl Send;\n // var to make it uphold the `: Duh` bound on `Trait::Assoc`. The opaque\n // type does not implement `Duh`, but if its hidden type does.\n fn foo() -> impl Trait<Assoc = Sendable> {\n+    //~^ WARN opaque type `impl Trait<Assoc = Sendable>` does not satisfy its associated type bounds\n     || 42\n }\n "}, {"sha": "a8eb69cfcb736cd80b1d727bcd97f6d28a96ec88", "filename": "src/test/ui/impl-trait/nested-return-type2-tait.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.stderr?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -0,0 +1,17 @@\n+warning: opaque type `impl Trait<Assoc = Sendable>` does not satisfy its associated type bounds\n+  --> $DIR/nested-return-type2-tait.rs:28:24\n+   |\n+LL |     type Assoc: Duh;\n+   |                 --- this associated type bound is unsatisfied for `Sendable`\n+...\n+LL | fn foo() -> impl Trait<Assoc = Sendable> {\n+   |                        ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n+help: add this bound\n+   |\n+LL | type Sendable = impl Send + Duh;\n+   |                           +++++\n+\n+warning: 1 warning emitted\n+"}, {"sha": "cc1f1f4ec44c895ee50f4e423b9733ed28f66a6d", "filename": "src/test/ui/impl-trait/nested-return-type2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.rs?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -23,6 +23,7 @@ impl<R: Duh, F: FnMut() -> R> Trait for F {\n // Lazy TAIT would error out, but we inserted a hack to make it work again,\n // keeping backwards compatibility.\n fn foo() -> impl Trait<Assoc = impl Send> {\n+    //~^ WARN opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n     || 42\n }\n "}, {"sha": "3aed05ca1329883e3661b6ac6ac0a81624e7381e", "filename": "src/test/ui/impl-trait/nested-return-type2.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -0,0 +1,17 @@\n+warning: opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n+  --> $DIR/nested-return-type2.rs:25:24\n+   |\n+LL |     type Assoc: Duh;\n+   |                 --- this associated type bound is unsatisfied for `impl Send`\n+...\n+LL | fn foo() -> impl Trait<Assoc = impl Send> {\n+   |                        ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n+help: add this bound\n+   |\n+LL | fn foo() -> impl Trait<Assoc = impl Send + Duh> {\n+   |                                          +++++\n+\n+warning: 1 warning emitted\n+"}, {"sha": "3a97e35b4c400b705e4a383c82d4ceca09d3dd37", "filename": "src/test/ui/impl-trait/nested-return-type3-tait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait.rs?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -17,6 +17,7 @@ impl<F: Duh> Trait for F {\n type Sendable = impl Send;\n \n fn foo() -> impl Trait<Assoc = Sendable> {\n+    //~^ WARN opaque type `impl Trait<Assoc = Sendable>` does not satisfy its associated type bounds\n     42\n }\n "}, {"sha": "5f58c8dca4ad4a7c94289acb866498bc503fc81a", "filename": "src/test/ui/impl-trait/nested-return-type3-tait.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait.stderr?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -0,0 +1,17 @@\n+warning: opaque type `impl Trait<Assoc = Sendable>` does not satisfy its associated type bounds\n+  --> $DIR/nested-return-type3-tait.rs:19:24\n+   |\n+LL |     type Assoc: Duh;\n+   |                 --- this associated type bound is unsatisfied for `Sendable`\n+...\n+LL | fn foo() -> impl Trait<Assoc = Sendable> {\n+   |                        ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n+help: add this bound\n+   |\n+LL | type Sendable = impl Send + Duh;\n+   |                           +++++\n+\n+warning: 1 warning emitted\n+"}, {"sha": "5b6f78a9896876d07fd344b220525cc82205b57b", "filename": "src/test/ui/impl-trait/nested-return-type3-tait2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait2.rs?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -16,6 +16,7 @@ impl<F: Duh> Trait for F {\n \n type Sendable = impl Send;\n type Traitable = impl Trait<Assoc = Sendable>;\n+//~^ WARN opaque type `Traitable` does not satisfy its associated type bounds\n \n fn foo() -> Traitable {\n     42"}, {"sha": "c07f6ead750282fa1169ef975432304bbc750ae2", "filename": "src/test/ui/impl-trait/nested-return-type3-tait2.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait2.stderr?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -0,0 +1,17 @@\n+warning: opaque type `Traitable` does not satisfy its associated type bounds\n+  --> $DIR/nested-return-type3-tait2.rs:18:29\n+   |\n+LL |     type Assoc: Duh;\n+   |                 --- this associated type bound is unsatisfied for `Sendable`\n+...\n+LL | type Traitable = impl Trait<Assoc = Sendable>;\n+   |                             ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n+help: add this bound\n+   |\n+LL | type Sendable = impl Send + Duh;\n+   |                           +++++\n+\n+warning: 1 warning emitted\n+"}, {"sha": "394d8f581102f9da70342586db40fdf4bcbbe489", "filename": "src/test/ui/impl-trait/nested-return-type3-tait3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait3.rs?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -15,6 +15,7 @@ impl<F: Duh> Trait for F {\n }\n \n type Traitable = impl Trait<Assoc = impl Send>;\n+//~^ WARN opaque type `Traitable` does not satisfy its associated type bounds\n \n fn foo() -> Traitable {\n     42"}, {"sha": "d98ad89222fa7eb9ae4d05c264b56b1ebaf35266", "filename": "src/test/ui/impl-trait/nested-return-type3-tait3.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait3.stderr?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -0,0 +1,17 @@\n+warning: opaque type `Traitable` does not satisfy its associated type bounds\n+  --> $DIR/nested-return-type3-tait3.rs:17:29\n+   |\n+LL |     type Assoc: Duh;\n+   |                 --- this associated type bound is unsatisfied for `impl Send`\n+...\n+LL | type Traitable = impl Trait<Assoc = impl Send>;\n+   |                             ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n+help: add this bound\n+   |\n+LL | type Traitable = impl Trait<Assoc = impl Send + Duh>;\n+   |                                               +++++\n+\n+warning: 1 warning emitted\n+"}, {"sha": "5a764fc4c285a697cde2a553832f40edf3e51ff2", "filename": "src/test/ui/impl-trait/nested-return-type3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3.rs?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -13,6 +13,7 @@ impl<F: Duh> Trait for F {\n }\n \n fn foo() -> impl Trait<Assoc = impl Send> {\n+    //~^ WARN opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n     42\n }\n "}, {"sha": "632de71aa4c880246ad942242eae3b6ab01f4beb", "filename": "src/test/ui/impl-trait/nested-return-type3.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/426424b3200022eba361e171ba84be7c1e7cc837/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3.stderr?ref=426424b3200022eba361e171ba84be7c1e7cc837", "patch": "@@ -0,0 +1,17 @@\n+warning: opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n+  --> $DIR/nested-return-type3.rs:15:24\n+   |\n+LL |     type Assoc: Duh;\n+   |                 --- this associated type bound is unsatisfied for `impl Send`\n+...\n+LL | fn foo() -> impl Trait<Assoc = impl Send> {\n+   |                        ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n+help: add this bound\n+   |\n+LL | fn foo() -> impl Trait<Assoc = impl Send + Duh> {\n+   |                                          +++++\n+\n+warning: 1 warning emitted\n+"}]}