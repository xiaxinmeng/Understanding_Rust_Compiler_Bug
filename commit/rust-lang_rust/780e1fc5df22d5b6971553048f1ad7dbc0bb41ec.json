{"sha": "780e1fc5df22d5b6971553048f1ad7dbc0bb41ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MGUxZmM1ZGYyMmQ1YjY5NzE1NTMwNDhmMWFkN2RiYzBiYjQxZWM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-24T18:20:55Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-02T20:48:07Z"}, "message": "use From to convert scalars to immediates", "tree": {"sha": "bdd911c78c28c13c70bcd31f64391da7cefdc809", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdd911c78c28c13c70bcd31f64391da7cefdc809"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/780e1fc5df22d5b6971553048f1ad7dbc0bb41ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/780e1fc5df22d5b6971553048f1ad7dbc0bb41ec", "html_url": "https://github.com/rust-lang/rust/commit/780e1fc5df22d5b6971553048f1ad7dbc0bb41ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/780e1fc5df22d5b6971553048f1ad7dbc0bb41ec/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b318bcfa784cead43a8b5aa553dcc4999e46b32e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b318bcfa784cead43a8b5aa553dcc4999e46b32e", "html_url": "https://github.com/rust-lang/rust/commit/b318bcfa784cead43a8b5aa553dcc4999e46b32e"}], "stats": {"total": 25, "additions": 10, "deletions": 15}, "files": [{"sha": "7b75627ee140060014e5ccb3e2aaabc51b682fcf", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/780e1fc5df22d5b6971553048f1ad7dbc0bb41ec/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780e1fc5df22d5b6971553048f1ad7dbc0bb41ec/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=780e1fc5df22d5b6971553048f1ad7dbc0bb41ec", "patch": "@@ -47,11 +47,6 @@ impl<Tag> From<Scalar<Tag>> for Immediate<Tag> {\n }\n \n impl<'tcx, Tag> Immediate<Tag> {\n-    #[inline]\n-    pub fn from_scalar(val: Scalar<Tag>) -> Self {\n-        Immediate::Scalar(ScalarMaybeUndef::Scalar(val))\n-    }\n-\n     pub fn new_slice(\n         val: Scalar<Tag>,\n         len: u64,\n@@ -196,7 +191,7 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n {\n     #[inline]\n     pub fn from_scalar(val: Scalar<Tag>, layout: TyLayout<'tcx>) -> Self {\n-        ImmTy { imm: Immediate::from_scalar(val), layout }\n+        ImmTy { imm: val.into(), layout }\n     }\n \n     #[inline]\n@@ -254,7 +249,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let ptr = match self.check_mplace_access(mplace, None)? {\n             Some(ptr) => ptr,\n             None => return Ok(Some(ImmTy { // zero-sized type\n-                imm: Immediate::Scalar(Scalar::zst().into()),\n+                imm: Scalar::zst().into(),\n                 layout: mplace.layout,\n             })),\n         };\n@@ -265,7 +260,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, ptr, mplace.layout.size)?;\n                 Ok(Some(ImmTy {\n-                    imm: Immediate::Scalar(scalar),\n+                    imm: scalar.into(),\n                     layout: mplace.layout,\n                 }))\n             }\n@@ -368,7 +363,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let field = field.try_into().unwrap();\n         let field_layout = op.layout.field(self, field)?;\n         if field_layout.is_zst() {\n-            let immediate = Immediate::Scalar(Scalar::zst().into());\n+            let immediate = Scalar::zst().into();\n             return Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout });\n         }\n         let offset = op.layout.fields.offset(field);\n@@ -378,7 +373,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // extract fields from types with `ScalarPair` ABI\n             Immediate::ScalarPair(a, b) => {\n                 let val = if offset.bytes() == 0 { a } else { b };\n-                Immediate::Scalar(val)\n+                Immediate::from(val)\n             },\n             Immediate::Scalar(val) =>\n                 bug!(\"field access on non aggregate {:#?}, {:#?}\", val, op.layout),\n@@ -415,7 +410,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Deref => self.deref_operand(base)?.into(),\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => if base.layout.is_zst() {\n                 OpTy {\n-                    op: Operand::Immediate(Immediate::Scalar(Scalar::zst().into())),\n+                    op: Operand::Immediate(Scalar::zst().into()),\n                     // the actual index doesn't matter, so we just pick a convenient one like 0\n                     layout: base.layout.field(self, 0)?,\n                 }\n@@ -439,7 +434,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let layout = self.layout_of_local(frame, local, layout)?;\n         let op = if layout.is_zst() {\n             // Do not read from ZST, they might not be initialized\n-            Operand::Immediate(Immediate::Scalar(Scalar::zst().into()))\n+            Operand::Immediate(Scalar::zst().into())\n         } else {\n             frame.locals[local].access()?\n         };\n@@ -570,7 +565,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Operand::Indirect(MemPlace::from_ptr(ptr, align))\n             },\n             ConstValue::Scalar(x) =>\n-                Operand::Immediate(Immediate::Scalar(tag_scalar(x).into())),\n+                Operand::Immediate(tag_scalar(x).into()),\n             ConstValue::Slice { data, start, end } => {\n                 // We rely on mutability being set correctly in `data` to prevent writes\n                 // where none should happen."}, {"sha": "4282687dad0f7b5f9f5f70a4f2e172818a67c831", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/780e1fc5df22d5b6971553048f1ad7dbc0bb41ec/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780e1fc5df22d5b6971553048f1ad7dbc0bb41ec/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=780e1fc5df22d5b6971553048f1ad7dbc0bb41ec", "patch": "@@ -8,7 +8,7 @@ use rustc_target::spec::abi::Abi;\n \n use super::{\n     InterpResult, PointerArithmetic, Scalar,\n-    InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n+    InterpCx, Machine, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -460,7 +460,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Adjust receiver argument.\n                 args[0] = OpTy::from(ImmTy {\n                     layout: this_receiver_ptr,\n-                    imm: Immediate::Scalar(receiver_place.ptr.into())\n+                    imm: receiver_place.ptr.into()\n                 });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function"}]}