{"sha": "d4d0144bcf3a3cf3e76651cc886d4a0b25350324", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZDAxNDRiY2YzYTNjZjNlNzY2NTFjYzg4NmQ0YTBiMjUzNTAzMjQ=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-04-11T23:52:36Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-04-12T01:51:23Z"}, "message": "Move extfmt parsing into standard library", "tree": {"sha": "643278db8c63f2b3ed35bbe8f69fe492514765cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/643278db8c63f2b3ed35bbe8f69fe492514765cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4d0144bcf3a3cf3e76651cc886d4a0b25350324", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d0144bcf3a3cf3e76651cc886d4a0b25350324", "html_url": "https://github.com/rust-lang/rust/commit/d4d0144bcf3a3cf3e76651cc886d4a0b25350324", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4d0144bcf3a3cf3e76651cc886d4a0b25350324/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a367866349b54b648f41e9ddd9efd4cfe88a649", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a367866349b54b648f41e9ddd9efd4cfe88a649", "html_url": "https://github.com/rust-lang/rust/commit/5a367866349b54b648f41e9ddd9efd4cfe88a649"}], "stats": {"total": 424, "additions": 214, "deletions": 210}, "files": [{"sha": "aecd793413aa5cdb87011a51e1e5ae44c14caa28", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 1, "deletions": 210, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/d4d0144bcf3a3cf3e76651cc886d4a0b25350324/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d0144bcf3a3cf3e76651cc886d4a0b25350324/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=d4d0144bcf3a3cf3e76651cc886d4a0b25350324", "patch": "@@ -50,6 +50,7 @@ import std.ExtFmt.conv;\n import std.ExtFmt.piece;\n import std.ExtFmt.piece_string;\n import std.ExtFmt.piece_conv;\n+import std.ExtFmt.parse_fmt_string;\n \n export expand_syntax_ext;\n \n@@ -87,216 +88,6 @@ fn expr_to_str(@ast.expr expr) -> str {\n     fail;\n }\n \n-fn parse_fmt_string(str s) -> vec[piece] {\n-    let vec[piece] pieces = vec();\n-    auto lim = _str.byte_len(s);\n-    auto buf = \"\";\n-\n-    fn flush_buf(str buf, &vec[piece] pieces) -> str {\n-        if (_str.byte_len(buf) > 0u) {\n-            auto piece = piece_string(buf);\n-            pieces += vec(piece);\n-        }\n-        ret \"\";\n-    }\n-\n-    auto i = 0u;\n-    while (i < lim) {\n-        auto curr = _str.substr(s, i, 1u);\n-        if (_str.eq(curr, \"%\")) {\n-            i += 1u;\n-            if (i >= lim) {\n-                log \"unterminated conversion at end of string\";\n-                fail;\n-            }\n-            auto curr2 = _str.substr(s, i, 1u);\n-            if (_str.eq(curr2, \"%\")) {\n-                i += 1u;\n-            } else {\n-                buf = flush_buf(buf, pieces);\n-                auto res = parse_conversion(s, i, lim);\n-                pieces += vec(res._0);\n-                i = res._1;\n-            }\n-        } else {\n-            buf += curr;\n-            i += 1u;\n-        }\n-    }\n-    buf = flush_buf(buf, pieces);\n-    ret pieces;\n-}\n-\n-fn peek_num(str s, uint i, uint lim) -> option.t[tup(uint, uint)] {\n-    if (i >= lim) {\n-        ret none[tup(uint, uint)];\n-    }\n-\n-    auto c = s.(i);\n-    if (!('0' as u8 <= c && c <= '9' as u8)) {\n-        ret option.none[tup(uint, uint)];\n-    }\n-\n-    auto n = (c - ('0' as u8)) as uint;\n-    alt (peek_num(s, i + 1u, lim)) {\n-        case (none[tup(uint, uint)]) {\n-            ret some[tup(uint, uint)](tup(n, i + 1u));\n-        }\n-        case (some[tup(uint, uint)](?next)) {\n-            auto m = next._0;\n-            auto j = next._1;\n-            ret some[tup(uint, uint)](tup(n * 10u + m, j));\n-        }\n-    }\n-\n-}\n-\n-fn parse_conversion(str s, uint i, uint lim) -> tup(piece, uint) {\n-    auto parm = parse_parameter(s, i, lim);\n-    auto flags = parse_flags(s, parm._1, lim);\n-    auto width = parse_count(s, flags._1, lim);\n-    auto prec = parse_precision(s, width._1, lim);\n-    auto ty = parse_type(s, prec._1, lim);\n-    ret tup(piece_conv(rec(param = parm._0,\n-                           flags = flags._0,\n-                           width = width._0,\n-                           precision = prec._0,\n-                           ty = ty._0)),\n-            ty._1);\n-}\n-\n-fn parse_parameter(str s, uint i, uint lim) -> tup(option.t[int], uint) {\n-    if (i >= lim) {\n-        ret tup(none[int], i);\n-    }\n-\n-    auto num = peek_num(s, i, lim);\n-    alt (num) {\n-        case (none[tup(uint, uint)]) {\n-            ret tup(none[int], i);\n-        }\n-        case (some[tup(uint, uint)](?t)) {\n-            auto n = t._0;\n-            auto j = t._1;\n-            if (j < lim && s.(j) == '$' as u8) {\n-                ret tup(some[int](n as int), j + 1u);\n-            }\n-            else {\n-                ret tup(none[int], i);\n-            }\n-        }\n-    }\n-}\n-\n-fn parse_flags(str s, uint i, uint lim) -> tup(vec[flag], uint) {\n-    let vec[flag] noflags = vec();\n-\n-    if (i >= lim) {\n-        ret tup(noflags, i);\n-    }\n-\n-    fn more_(flag f, str s, uint i, uint lim) -> tup(vec[flag], uint) {\n-        auto next = parse_flags(s, i + 1u, lim);\n-        auto rest = next._0;\n-        auto j = next._1;\n-        let vec[flag] curr = vec(f);\n-        ret tup(curr + rest, j);\n-    }\n-\n-    auto more = bind more_(_, s, i, lim);\n-\n-    auto f = s.(i);\n-    if (f == ('-' as u8)) {\n-        ret more(flag_left_justify);\n-    } else if (f == ('0' as u8)) {\n-        ret more(flag_left_zero_pad);\n-    } else if (f == (' ' as u8)) {\n-        ret more(flag_left_space_pad);\n-    } else if (f == ('+' as u8)) {\n-        ret more(flag_plus_if_positive);\n-    } else if (f == ('#' as u8)) {\n-        ret more(flag_alternate);\n-    } else {\n-        ret tup(noflags, i);\n-    }\n-}\n-\n-fn parse_count(str s, uint i, uint lim) -> tup(count, uint) {\n-    if (i >= lim) {\n-        ret tup(count_implied, i);\n-    }\n-\n-    if (s.(i) == ('*' as u8)) {\n-        auto param = parse_parameter(s, i + 1u, lim);\n-        auto j = param._1;\n-        alt (param._0) {\n-            case (none[int]) {\n-                ret tup(count_is_next_param, j);\n-            }\n-            case (some[int](?n)) {\n-                ret tup(count_is_param(n), j);\n-            }\n-        }\n-    } else {\n-        auto num = peek_num(s, i, lim);\n-        alt (num) {\n-            case (none[tup(uint, uint)]) {\n-                ret tup(count_implied, i);\n-            }\n-            case (some[tup(uint, uint)](?num)) {\n-                ret tup(count_is(num._0 as int), num._1);\n-            }\n-        }\n-    }\n-}\n-\n-fn parse_precision(str s, uint i, uint lim) -> tup(count, uint) {\n-    if (i >= lim) {\n-        ret tup(count_implied, i);\n-    }\n-\n-    if (s.(i) == '.' as u8) {\n-        ret parse_count(s, i + 1u, lim);\n-    } else {\n-        ret tup(count_implied, i);\n-    }\n-}\n-\n-fn parse_type(str s, uint i, uint lim) -> tup(ty, uint) {\n-    if (i >= lim) {\n-        log \"missing type in conversion\";\n-        fail;\n-    }\n-\n-    auto t;\n-    auto tstr = _str.substr(s, i, 1u);\n-    if (_str.eq(tstr, \"b\")) {\n-        t = ty_bool;\n-    } else if (_str.eq(tstr, \"s\")) {\n-        t = ty_str;\n-    } else if (_str.eq(tstr, \"c\")) {\n-        t = ty_char;\n-    } else if (_str.eq(tstr, \"d\")\n-               || _str.eq(tstr, \"i\")) {\n-        // TODO: Do we really want two signed types here?\n-        // How important is it to be printf compatible?\n-        t = ty_int(signed);\n-    } else if (_str.eq(tstr, \"u\")) {\n-        t = ty_int(unsigned);\n-    } else if (_str.eq(tstr, \"x\")) {\n-        t = ty_hex(case_lower);\n-    } else if (_str.eq(tstr, \"X\")) {\n-        t = ty_hex(case_upper);\n-    } else if (_str.eq(tstr, \"t\")) {\n-        t = ty_bits;\n-    } else {\n-        log \"unknown type in conversion\";\n-        fail;\n-    }\n-\n-    ret tup(t, i + 1u);\n-}\n-\n fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n \n     fn make_new_lit(common.span sp, ast.lit_ lit) -> @ast.expr {"}, {"sha": "f7487eec3839cd2ad11589afaef3c48ebf26bb91", "filename": "src/lib/ExtFmt.rs", "status": "modified", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/d4d0144bcf3a3cf3e76651cc886d4a0b25350324/src%2Flib%2FExtFmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d0144bcf3a3cf3e76651cc886d4a0b25350324/src%2Flib%2FExtFmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FExtFmt.rs?ref=d4d0144bcf3a3cf3e76651cc886d4a0b25350324", "patch": "@@ -1,3 +1,6 @@\n+import option.none;\n+import option.some;\n+\n tag signedness {\n     signed;\n     unsigned;\n@@ -45,3 +48,213 @@ tag piece {\n     piece_string(str);\n     piece_conv(conv);\n }\n+\n+fn parse_fmt_string(str s) -> vec[piece] {\n+    let vec[piece] pieces = vec();\n+    auto lim = _str.byte_len(s);\n+    auto buf = \"\";\n+\n+    fn flush_buf(str buf, &vec[piece] pieces) -> str {\n+        if (_str.byte_len(buf) > 0u) {\n+            auto piece = piece_string(buf);\n+            pieces += vec(piece);\n+        }\n+        ret \"\";\n+    }\n+\n+    auto i = 0u;\n+    while (i < lim) {\n+        auto curr = _str.substr(s, i, 1u);\n+        if (_str.eq(curr, \"%\")) {\n+            i += 1u;\n+            if (i >= lim) {\n+                log \"unterminated conversion at end of string\";\n+                fail;\n+            }\n+            auto curr2 = _str.substr(s, i, 1u);\n+            if (_str.eq(curr2, \"%\")) {\n+                i += 1u;\n+            } else {\n+                buf = flush_buf(buf, pieces);\n+                auto res = parse_conversion(s, i, lim);\n+                pieces += vec(res._0);\n+                i = res._1;\n+            }\n+        } else {\n+            buf += curr;\n+            i += 1u;\n+        }\n+    }\n+    buf = flush_buf(buf, pieces);\n+    ret pieces;\n+}\n+\n+fn peek_num(str s, uint i, uint lim) -> option.t[tup(uint, uint)] {\n+    if (i >= lim) {\n+        ret none[tup(uint, uint)];\n+    }\n+\n+    auto c = s.(i);\n+    if (!('0' as u8 <= c && c <= '9' as u8)) {\n+        ret option.none[tup(uint, uint)];\n+    }\n+\n+    auto n = (c - ('0' as u8)) as uint;\n+    alt (peek_num(s, i + 1u, lim)) {\n+        case (none[tup(uint, uint)]) {\n+            ret some[tup(uint, uint)](tup(n, i + 1u));\n+        }\n+        case (some[tup(uint, uint)](?next)) {\n+            auto m = next._0;\n+            auto j = next._1;\n+            ret some[tup(uint, uint)](tup(n * 10u + m, j));\n+        }\n+    }\n+\n+}\n+\n+fn parse_conversion(str s, uint i, uint lim) -> tup(piece, uint) {\n+    auto parm = parse_parameter(s, i, lim);\n+    auto flags = parse_flags(s, parm._1, lim);\n+    auto width = parse_count(s, flags._1, lim);\n+    auto prec = parse_precision(s, width._1, lim);\n+    auto ty = parse_type(s, prec._1, lim);\n+    ret tup(piece_conv(rec(param = parm._0,\n+                           flags = flags._0,\n+                           width = width._0,\n+                           precision = prec._0,\n+                           ty = ty._0)),\n+            ty._1);\n+}\n+\n+fn parse_parameter(str s, uint i, uint lim) -> tup(option.t[int], uint) {\n+    if (i >= lim) {\n+        ret tup(none[int], i);\n+    }\n+\n+    auto num = peek_num(s, i, lim);\n+    alt (num) {\n+        case (none[tup(uint, uint)]) {\n+            ret tup(none[int], i);\n+        }\n+        case (some[tup(uint, uint)](?t)) {\n+            auto n = t._0;\n+            auto j = t._1;\n+            if (j < lim && s.(j) == '$' as u8) {\n+                ret tup(some[int](n as int), j + 1u);\n+            }\n+            else {\n+                ret tup(none[int], i);\n+            }\n+        }\n+    }\n+}\n+\n+fn parse_flags(str s, uint i, uint lim) -> tup(vec[flag], uint) {\n+    let vec[flag] noflags = vec();\n+\n+    if (i >= lim) {\n+        ret tup(noflags, i);\n+    }\n+\n+    fn more_(flag f, str s, uint i, uint lim) -> tup(vec[flag], uint) {\n+        auto next = parse_flags(s, i + 1u, lim);\n+        auto rest = next._0;\n+        auto j = next._1;\n+        let vec[flag] curr = vec(f);\n+        ret tup(curr + rest, j);\n+    }\n+\n+    auto more = bind more_(_, s, i, lim);\n+\n+    auto f = s.(i);\n+    if (f == ('-' as u8)) {\n+        ret more(flag_left_justify);\n+    } else if (f == ('0' as u8)) {\n+        ret more(flag_left_zero_pad);\n+    } else if (f == (' ' as u8)) {\n+        ret more(flag_left_space_pad);\n+    } else if (f == ('+' as u8)) {\n+        ret more(flag_plus_if_positive);\n+    } else if (f == ('#' as u8)) {\n+        ret more(flag_alternate);\n+    } else {\n+        ret tup(noflags, i);\n+    }\n+}\n+\n+fn parse_count(str s, uint i, uint lim) -> tup(count, uint) {\n+    if (i >= lim) {\n+        ret tup(count_implied, i);\n+    }\n+\n+    if (s.(i) == ('*' as u8)) {\n+        auto param = parse_parameter(s, i + 1u, lim);\n+        auto j = param._1;\n+        alt (param._0) {\n+            case (none[int]) {\n+                ret tup(count_is_next_param, j);\n+            }\n+            case (some[int](?n)) {\n+                ret tup(count_is_param(n), j);\n+            }\n+        }\n+    } else {\n+        auto num = peek_num(s, i, lim);\n+        alt (num) {\n+            case (none[tup(uint, uint)]) {\n+                ret tup(count_implied, i);\n+            }\n+            case (some[tup(uint, uint)](?num)) {\n+                ret tup(count_is(num._0 as int), num._1);\n+            }\n+        }\n+    }\n+}\n+\n+fn parse_precision(str s, uint i, uint lim) -> tup(count, uint) {\n+    if (i >= lim) {\n+        ret tup(count_implied, i);\n+    }\n+\n+    if (s.(i) == '.' as u8) {\n+        ret parse_count(s, i + 1u, lim);\n+    } else {\n+        ret tup(count_implied, i);\n+    }\n+}\n+\n+fn parse_type(str s, uint i, uint lim) -> tup(ty, uint) {\n+    if (i >= lim) {\n+        log \"missing type in conversion\";\n+        fail;\n+    }\n+\n+    auto t;\n+    auto tstr = _str.substr(s, i, 1u);\n+    if (_str.eq(tstr, \"b\")) {\n+        t = ty_bool;\n+    } else if (_str.eq(tstr, \"s\")) {\n+        t = ty_str;\n+    } else if (_str.eq(tstr, \"c\")) {\n+        t = ty_char;\n+    } else if (_str.eq(tstr, \"d\")\n+               || _str.eq(tstr, \"i\")) {\n+        // TODO: Do we really want two signed types here?\n+        // How important is it to be printf compatible?\n+        t = ty_int(signed);\n+    } else if (_str.eq(tstr, \"u\")) {\n+        t = ty_int(unsigned);\n+    } else if (_str.eq(tstr, \"x\")) {\n+        t = ty_hex(case_lower);\n+    } else if (_str.eq(tstr, \"X\")) {\n+        t = ty_hex(case_upper);\n+    } else if (_str.eq(tstr, \"t\")) {\n+        t = ty_bits;\n+    } else {\n+        log \"unknown type in conversion\";\n+        fail;\n+    }\n+\n+    ret tup(t, i + 1u);\n+}"}]}