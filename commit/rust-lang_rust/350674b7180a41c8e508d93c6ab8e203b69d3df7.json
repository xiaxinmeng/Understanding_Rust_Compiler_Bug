{"sha": "350674b7180a41c8e508d93c6ab8e203b69d3df7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MDY3NGI3MTgwYTQxYzhlNTA4ZDkzYzZhYjhlMjAzYjY5ZDNkZjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-28T21:02:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-28T21:02:12Z"}, "message": "Auto merge of #58250 - Zoxc:rustc-interface-1, r=oli-obk\n\nIntroduce rustc_interface and move some methods there\n\nSplit out from https://github.com/rust-lang/rust/pull/56732\n\nr? @oli-obk", "tree": {"sha": "e27a82e677e472550536820a8af2390d8f1da364", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e27a82e677e472550536820a8af2390d8f1da364"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/350674b7180a41c8e508d93c6ab8e203b69d3df7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/350674b7180a41c8e508d93c6ab8e203b69d3df7", "html_url": "https://github.com/rust-lang/rust/commit/350674b7180a41c8e508d93c6ab8e203b69d3df7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/350674b7180a41c8e508d93c6ab8e203b69d3df7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1999a2288123173b2e487865c9a04386173025f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1999a2288123173b2e487865c9a04386173025f7", "html_url": "https://github.com/rust-lang/rust/commit/1999a2288123173b2e487865c9a04386173025f7"}, {"sha": "23a51f91c928a4ff2cbf39218e6e991365e5f562", "url": "https://api.github.com/repos/rust-lang/rust/commits/23a51f91c928a4ff2cbf39218e6e991365e5f562", "html_url": "https://github.com/rust-lang/rust/commit/23a51f91c928a4ff2cbf39218e6e991365e5f562"}], "stats": {"total": 2389, "additions": 1334, "deletions": 1055}, "files": [{"sha": "381322bc421d4b5ad872b1cfca8972e19d59c06e", "filename": "Cargo.lock", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -2699,6 +2699,7 @@ dependencies = [\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n+ \"rustc_interface 0.0.0\",\n  \"rustc_lint 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n@@ -2751,6 +2752,36 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_interface\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc 0.0.0\",\n+ \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_allocator 0.0.0\",\n+ \"rustc_borrowck 0.0.0\",\n+ \"rustc_codegen_utils 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_incremental 0.0.0\",\n+ \"rustc_lint 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"rustc_passes 0.0.0\",\n+ \"rustc_plugin 0.0.0\",\n+ \"rustc_privacy 0.0.0\",\n+ \"rustc_resolve 0.0.0\",\n+ \"rustc_traits 0.0.0\",\n+ \"rustc_typeck 0.0.0\",\n+ \"scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serialize 0.0.0\",\n+ \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntax 0.0.0\",\n+ \"syntax_ext 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_lint\"\n version = \"0.0.0\""}, {"sha": "70e4a69a07d440169b041ce6f4faf93a4f71fc66", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -107,6 +107,8 @@ fn main() {\n         // actually downloaded, so we just always pass the `--sysroot` option.\n         cmd.arg(\"--sysroot\").arg(&sysroot);\n \n+        cmd.arg(\"-Zexternal-macro-backtrace\");\n+\n         // When we build Rust dylibs they're all intended for intermediate\n         // usage, so make sure we pass the -Cprefer-dynamic flag instead of\n         // linking all deps statically into the dylib."}, {"sha": "c607eb5906e605122d54f9aa51523a534930c58e", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -456,6 +456,7 @@ define_dep_nodes!( <'tcx>\n     [eval_always] CoherenceInherentImplOverlapCheck,\n     [] CoherenceCheckTrait(DefId),\n     [eval_always] PrivacyAccessLevels(CrateNum),\n+    [eval_always] Analysis(CrateNum),\n \n     // Represents the MIR for a fn; also used as the task node for\n     // things read/modify that MIR."}, {"sha": "99eee4b559a5cc93af4543c0b17a71bb229b72b5", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -499,6 +499,13 @@ impl Input {\n             Input::Str { ref mut input, .. } => Some(input),\n         }\n     }\n+\n+    pub fn source_name(&self) -> FileName {\n+        match *self {\n+            Input::File(ref ifile) => ifile.clone().into(),\n+            Input::Str { ref name, .. } => name.clone(),\n+        }\n+    }\n }\n \n #[derive(Clone, Hash)]"}, {"sha": "5b9b70edc680990be7dc55ea7d950b5a164bd532", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 66, "deletions": 43, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -899,14 +899,14 @@ impl Session {\n \n     /// Returns the number of query threads that should be used for this\n     /// compilation\n-    pub fn threads_from_opts(opts: &config::Options) -> usize {\n-        opts.debugging_opts.threads.unwrap_or(::num_cpus::get())\n+    pub fn threads_from_count(query_threads: Option<usize>) -> usize {\n+        query_threads.unwrap_or(::num_cpus::get())\n     }\n \n     /// Returns the number of query threads that should be used for this\n     /// compilation\n     pub fn threads(&self) -> usize {\n-        Self::threads_from_opts(&self.opts)\n+        Self::threads_from_count(self.opts.debugging_opts.threads)\n     }\n \n     /// Returns the number of codegen units that should be used for this\n@@ -1023,16 +1023,67 @@ pub fn build_session(\n         local_crate_source_file,\n         registry,\n         Lrc::new(source_map::SourceMap::new(file_path_mapping)),\n-        None,\n+        DiagnosticOutput::Default,\n+        Default::default(),\n     )\n }\n \n+fn default_emitter(\n+    sopts: &config::Options,\n+    registry: errors::registry::Registry,\n+    source_map: &Lrc<source_map::SourceMap>,\n+    emitter_dest: Option<Box<dyn Write + Send>>,\n+) -> Box<dyn Emitter + sync::Send> {\n+    match (sopts.error_format, emitter_dest) {\n+        (config::ErrorOutputType::HumanReadable(color_config), None) => Box::new(\n+            EmitterWriter::stderr(\n+                color_config,\n+                Some(source_map.clone()),\n+                false,\n+                sopts.debugging_opts.teach,\n+            ).ui_testing(sopts.debugging_opts.ui_testing),\n+        ),\n+        (config::ErrorOutputType::HumanReadable(_), Some(dst)) => Box::new(\n+            EmitterWriter::new(dst, Some(source_map.clone()), false, false)\n+                .ui_testing(sopts.debugging_opts.ui_testing),\n+        ),\n+        (config::ErrorOutputType::Json(pretty), None) => Box::new(\n+            JsonEmitter::stderr(\n+                Some(registry),\n+                source_map.clone(),\n+                pretty,\n+            ).ui_testing(sopts.debugging_opts.ui_testing),\n+        ),\n+        (config::ErrorOutputType::Json(pretty), Some(dst)) => Box::new(\n+            JsonEmitter::new(\n+                dst,\n+                Some(registry),\n+                source_map.clone(),\n+                pretty,\n+            ).ui_testing(sopts.debugging_opts.ui_testing),\n+        ),\n+        (config::ErrorOutputType::Short(color_config), None) => Box::new(\n+            EmitterWriter::stderr(color_config, Some(source_map.clone()), true, false),\n+        ),\n+        (config::ErrorOutputType::Short(_), Some(dst)) => {\n+            Box::new(EmitterWriter::new(dst, Some(source_map.clone()), true, false))\n+        }\n+    }\n+}\n+\n+pub enum DiagnosticOutput {\n+    Default,\n+    Raw(Box<dyn Write + Send>),\n+    Emitter(Box<dyn Emitter + Send + sync::Send>)\n+}\n+\n pub fn build_session_with_source_map(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     registry: errors::registry::Registry,\n     source_map: Lrc<source_map::SourceMap>,\n-    emitter_dest: Option<Box<dyn Write + Send>>,\n+    diagnostics_output: DiagnosticOutput,\n+    lint_caps: FxHashMap<lint::LintId, lint::Level>,\n ) -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n     // normal diagnostic warnings, since the warning lint can also be denied and changed\n@@ -1054,42 +1105,13 @@ pub fn build_session_with_source_map(\n \n     let external_macro_backtrace = sopts.debugging_opts.external_macro_backtrace;\n \n-    let emitter: Box<dyn Emitter + sync::Send> =\n-        match (sopts.error_format, emitter_dest) {\n-            (config::ErrorOutputType::HumanReadable(color_config), None) => Box::new(\n-                EmitterWriter::stderr(\n-                    color_config,\n-                    Some(source_map.clone()),\n-                    false,\n-                    sopts.debugging_opts.teach,\n-                ).ui_testing(sopts.debugging_opts.ui_testing),\n-            ),\n-            (config::ErrorOutputType::HumanReadable(_), Some(dst)) => Box::new(\n-                EmitterWriter::new(dst, Some(source_map.clone()), false, false)\n-                    .ui_testing(sopts.debugging_opts.ui_testing),\n-            ),\n-            (config::ErrorOutputType::Json(pretty), None) => Box::new(\n-                JsonEmitter::stderr(\n-                    Some(registry),\n-                    source_map.clone(),\n-                    pretty,\n-                ).ui_testing(sopts.debugging_opts.ui_testing),\n-            ),\n-            (config::ErrorOutputType::Json(pretty), Some(dst)) => Box::new(\n-                JsonEmitter::new(\n-                    dst,\n-                    Some(registry),\n-                    source_map.clone(),\n-                    pretty,\n-                ).ui_testing(sopts.debugging_opts.ui_testing),\n-            ),\n-            (config::ErrorOutputType::Short(color_config), None) => Box::new(\n-                EmitterWriter::stderr(color_config, Some(source_map.clone()), true, false),\n-            ),\n-            (config::ErrorOutputType::Short(_), Some(dst)) => {\n-                Box::new(EmitterWriter::new(dst, Some(source_map.clone()), true, false))\n-            }\n-        };\n+    let emitter = match diagnostics_output {\n+        DiagnosticOutput::Default => default_emitter(&sopts, registry, &source_map, None),\n+        DiagnosticOutput::Raw(write) => {\n+            default_emitter(&sopts, registry, &source_map, Some(write))\n+        }\n+        DiagnosticOutput::Emitter(emitter) => emitter,\n+    };\n \n     let diagnostic_handler = errors::Handler::with_emitter_and_flags(\n         emitter,\n@@ -1103,14 +1125,15 @@ pub fn build_session_with_source_map(\n         },\n     );\n \n-    build_session_(sopts, local_crate_source_file, diagnostic_handler, source_map)\n+    build_session_(sopts, local_crate_source_file, diagnostic_handler, source_map, lint_caps)\n }\n \n pub fn build_session_(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     span_diagnostic: errors::Handler,\n     source_map: Lrc<source_map::SourceMap>,\n+    driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n ) -> Session {\n     let host_triple = TargetTriple::from_triple(config::host_triple());\n     let host = Target::search(&host_triple).unwrap_or_else(|e|\n@@ -1235,7 +1258,7 @@ pub fn build_session_(\n         },\n         has_global_allocator: Once::new(),\n         has_panic_handler: Once::new(),\n-        driver_lint_caps: Default::default(),\n+        driver_lint_caps,\n     };\n \n     validate_commandline_args_with_session_available(&sess);"}, {"sha": "d02c9fc174c6e07bb2ada04368a092aa2276afd4", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -50,7 +50,7 @@ use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableVec};\n use arena::{TypedArena, SyncDroplessArena};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::sync::{self, Lrc, Lock, WorkerLocal};\n+use rustc_data_structures::sync::{Lrc, Lock, WorkerLocal};\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n@@ -1285,8 +1285,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let gcx = arenas.global_ctxt.as_ref().unwrap();\n \n-        sync::assert_send_val(&gcx);\n-\n         let r = tls::enter_global(gcx, f);\n \n         gcx.queries.record_computed_queries(s);"}, {"sha": "feca0f7170ef3d11b5d7dd3444dcd01001cce48c", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -611,6 +611,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::extern_crate<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"running analysis passes on this crate\".into()\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::lint_levels<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n         \"computing the lint levels for items in this crate\".into()"}, {"sha": "197b9a71b0ac0f31b83b34a7de9a683fcfd959af", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -19,7 +19,7 @@ use crate::mir::interpret::{ConstEvalRawResult, ConstEvalResult};\n use crate::mir::mono::CodegenUnit;\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n-use crate::session::{CompileResult, CrateDisambiguator};\n+use crate::session::CrateDisambiguator;\n use crate::session::config::{EntryFnType, OutputFilenames, OptLevel};\n use crate::traits::{self, Vtable};\n use crate::traits::query::{\n@@ -99,6 +99,9 @@ pub use self::on_disk_cache::OnDiskCache;\n // as they will raise an fatal error on query cycles instead.\n define_queries! { <'tcx>\n     Other {\n+        /// Run analysis passes on the crate\n+        [] fn analysis: Analysis(CrateNum) -> Result<(), ErrorReported>,\n+\n         /// Records the type of every item.\n         [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n \n@@ -290,7 +293,8 @@ define_queries! { <'tcx>\n     },\n \n     TypeChecking {\n-        [] fn typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n+        [] fn typeck_item_bodies:\n+                typeck_item_bodies_dep_node(CrateNum) -> Result<(), ErrorReported>,\n \n         [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n     },"}, {"sha": "ebaa31d703f8e0195fa969b8cb1364fd0b83665d", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -1357,6 +1357,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::CrateHash => { force!(crate_hash, krate!()); }\n         DepKind::OriginalCrateName => { force!(original_crate_name, krate!()); }\n         DepKind::ExtraFileName => { force!(extra_filename, krate!()); }\n+        DepKind::Analysis => { force!(analysis, krate!()); }\n \n         DepKind::AllTraitImplementations => {\n             force!(all_trait_implementations, krate!());"}, {"sha": "0b379ef662dde06dc6d7c2c502972d148fce100a", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -33,6 +33,7 @@ rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_traits = { path = \"../librustc_traits\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n+rustc_interface = { path = \"../librustc_interface\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "f87a809e6c6eb1e3d6c7301892b1d8ff062a85ee", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 25, "deletions": 463, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -2,42 +2,39 @@ use rustc::dep_graph::DepGraph;\n use rustc::hir;\n use rustc::hir::lowering::lower_crate;\n use rustc::hir::map as hir_map;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::lint;\n use rustc::middle::{self, reachable, resolve_lifetime, stability};\n use rustc::ty::{self, AllArenas, Resolutions, TyCtxt};\n use rustc::traits;\n use rustc::util::common::{install_panic_hook, time, ErrorReported};\n use rustc::util::profiling::ProfileCategory;\n-use rustc::session::{CompileResult, CrateDisambiguator, Session};\n+use rustc::session::{CompileResult, Session};\n use rustc::session::CompileIncomplete;\n use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n-use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{self, Lock};\n use rustc_incremental;\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n use rustc_mir as mir;\n-use rustc_passes::{self, ast_validation, hir_stats, loops, rvalue_promotion, layout_test};\n+use rustc_passes::{self, ast_validation, hir_stats};\n use rustc_plugin as plugin;\n use rustc_plugin::registry::Registry;\n use rustc_privacy;\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_traits;\n use rustc_typeck as typeck;\n-use syntax::{self, ast, attr, diagnostics, visit};\n+use syntax::{self, ast, diagnostics, visit};\n use syntax::early_buffered_lints::BufferedEarlyLint;\n use syntax::ext::base::ExtCtxt;\n use syntax::mut_visit::MutVisitor;\n use syntax::parse::{self, PResult};\n use syntax::util::node_count::NodeCounter;\n-use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax::symbol::Symbol;\n-use syntax_pos::{FileName, hygiene};\n+use syntax_pos::hygiene;\n use syntax_ext;\n \n use serialize::json;\n@@ -46,14 +43,11 @@ use std::any::Any;\n use std::env;\n use std::ffi::OsString;\n use std::fs;\n-use std::io::{self, Write};\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::sync::mpsc;\n \n-use pretty::ReplaceBodyWithLoop;\n-use proc_macro_decls;\n-use profile;\n+use rustc_interface::{util, profile, passes};\n use super::Compilation;\n \n #[cfg(not(parallel_compiler))]\n@@ -78,7 +72,7 @@ pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::\n     let gcx_ptr = &Lock::new(0);\n \n     let config = ThreadPoolBuilder::new()\n-        .num_threads(Session::threads_from_opts(&opts))\n+        .num_threads(Session::threads_from_count(opts.debugging_opts.threads))\n         .deadlock_handler(|| unsafe { ty::query::handle_deadlock() })\n         .stack_size(::STACK_SIZE);\n \n@@ -160,7 +154,7 @@ pub fn compile_input(\n             (compile_state.krate.unwrap(), compile_state.registry)\n         };\n \n-        let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n+        let outputs = util::build_output_filenames(input, outdir, output, &krate.attrs, sess);\n         let crate_name =\n             ::rustc_codegen_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n         install_panic_hook();\n@@ -194,20 +188,25 @@ pub fn compile_input(\n             )?\n         };\n \n-        let output_paths = generated_output_paths(sess, &outputs, output.is_some(), &crate_name);\n+        let output_paths = passes::generated_output_paths(\n+            sess,\n+            &outputs,\n+            output.is_some(),\n+            &crate_name\n+        );\n \n         // Ensure the source file isn't accidentally overwritten during compilation.\n         if let Some(ref input_path) = *input_path {\n             if sess.opts.will_create_output_file() {\n-                if output_contains_path(&output_paths, input_path) {\n+                if passes::output_contains_path(&output_paths, input_path) {\n                     sess.err(&format!(\n                         \"the input file \\\"{}\\\" would be overwritten by the generated \\\n                          executable\",\n                         input_path.display()\n                     ));\n                     return Err(CompileIncomplete::Stopped);\n                 }\n-                if let Some(dir_path) = output_conflicts_with_dir(&output_paths) {\n+                if let Some(dir_path) = passes::output_conflicts_with_dir(&output_paths) {\n                     sess.err(&format!(\n                         \"the generated executable for the input file \\\"{}\\\" conflicts with the \\\n                          existing directory \\\"{}\\\"\",\n@@ -219,7 +218,7 @@ pub fn compile_input(\n             }\n         }\n \n-        write_out_deps(sess, &outputs, &output_paths);\n+        passes::write_out_deps(sess, &outputs, &output_paths);\n         if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n             && sess.opts.output_types.len() == 1\n         {\n@@ -333,7 +332,7 @@ pub fn compile_input(\n \n                 Ok((outputs.clone(), ongoing_codegen, tcx.dep_graph.clone()))\n             },\n-        )??\n+        )?\n     };\n \n     if sess.opts.debugging_opts.print_type_sizes {\n@@ -364,13 +363,6 @@ pub fn compile_input(\n     Ok(())\n }\n \n-pub fn source_name(input: &Input) -> FileName {\n-    match *input {\n-        Input::File(ref ifile) => ifile.clone().into(),\n-        Input::Str { ref name, .. } => name.clone(),\n-    }\n-}\n-\n /// CompileController is used to customize compilation, it allows compilation to\n /// be stopped and/or to call arbitrary code at various points in compilation.\n /// It also allows for various flags to be set to influence what information gets\n@@ -806,10 +798,10 @@ where\n     // these need to be set \"early\" so that expansion sees `quote` if enabled.\n     sess.init_features(features);\n \n-    let crate_types = collect_crate_types(sess, &krate.attrs);\n+    let crate_types = util::collect_crate_types(sess, &krate.attrs);\n     sess.crate_types.set(crate_types);\n \n-    let disambiguator = compute_crate_disambiguator(sess);\n+    let disambiguator = util::compute_crate_disambiguator(sess);\n     sess.crate_disambiguator.set(disambiguator);\n     rustc_incremental::prepare_session_directory(sess, &crate_name, disambiguator);\n \n@@ -1019,7 +1011,7 @@ where\n     // If we're actually rustdoc then there's no need to actually compile\n     // anything, so switch everything to just looping\n     if sess.opts.actually_rustdoc {\n-        ReplaceBodyWithLoop::new(sess).visit_crate(&mut krate);\n+        util::ReplaceBodyWithLoop::new(sess).visit_crate(&mut krate);\n     }\n \n     let (has_proc_macro_decls, has_global_allocator) = time(sess, \"AST validation\", || {\n@@ -1145,7 +1137,7 @@ where\n }\n \n pub fn default_provide(providers: &mut ty::query::Providers) {\n-    proc_macro_decls::provide(providers);\n+    rustc_interface::passes::provide(providers);\n     plugin::build::provide(providers);\n     hir::provide(providers);\n     borrowck::provide(providers);\n@@ -1186,7 +1178,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(\n     name: &str,\n     output_filenames: &OutputFilenames,\n     f: F,\n-) -> Result<R, CompileIncomplete>\n+) -> R\n where\n     F: for<'a> FnOnce(\n         TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1227,114 +1219,9 @@ where\n             // tcx available.\n             time(sess, \"dep graph tcx init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n \n-            parallel!({\n-                time(sess, \"looking for entry point\", || {\n-                    middle::entry::find_entry_point(tcx)\n-                });\n-\n-                time(sess, \"looking for plugin registrar\", || {\n-                    plugin::build::find_plugin_registrar(tcx)\n-                });\n-\n-                time(sess, \"looking for derive registrar\", || {\n-                    proc_macro_decls::find(tcx)\n-                });\n-            }, {\n-                time(sess, \"loop checking\", || loops::check_crate(tcx));\n-            }, {\n-                time(sess, \"attribute checking\", || {\n-                    hir::check_attr::check_crate(tcx)\n-                });\n-            }, {\n-                time(sess, \"stability checking\", || {\n-                    stability::check_unstable_api_usage(tcx)\n-                });\n-            });\n-\n-            // passes are timed inside typeck\n-            match typeck::check_crate(tcx) {\n-                Ok(x) => x,\n-                Err(x) => {\n-                    f(tcx, rx, Err(x));\n-                    return Err(x);\n-                }\n-            }\n+            tcx.analysis(LOCAL_CRATE).ok();\n \n-            time(sess, \"misc checking\", || {\n-                parallel!({\n-                    time(sess, \"rvalue promotion\", || {\n-                        rvalue_promotion::check_crate(tcx)\n-                    });\n-                }, {\n-                    time(sess, \"intrinsic checking\", || {\n-                        middle::intrinsicck::check_crate(tcx)\n-                    });\n-                }, {\n-                    time(sess, \"match checking\", || mir::matchck_crate(tcx));\n-                }, {\n-                    // this must run before MIR dump, because\n-                    // \"not all control paths return a value\" is reported here.\n-                    //\n-                    // maybe move the check to a MIR pass?\n-                    time(sess, \"liveness checking\", || {\n-                        middle::liveness::check_crate(tcx)\n-                    });\n-                });\n-            });\n-\n-            // Abort so we don't try to construct MIR with liveness errors.\n-            // We also won't want to continue with errors from rvalue promotion\n-            tcx.sess.abort_if_errors();\n-\n-            time(sess, \"borrow checking\", || {\n-                if tcx.use_ast_borrowck() {\n-                    borrowck::check_crate(tcx);\n-                }\n-            });\n-\n-            time(sess,\n-                 \"MIR borrow checking\",\n-                 || tcx.par_body_owners(|def_id| { tcx.ensure().mir_borrowck(def_id); }));\n-\n-            time(sess, \"dumping chalk-like clauses\", || {\n-                rustc_traits::lowering::dump_program_clauses(tcx);\n-            });\n-\n-            time(sess, \"MIR effect checking\", || {\n-                for def_id in tcx.body_owners() {\n-                    mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n-                }\n-            });\n-\n-            time(sess, \"layout testing\", || layout_test::test_layout(tcx));\n-\n-            // Avoid overwhelming user with errors if borrow checking failed.\n-            // I'm not sure how helpful this is, to be honest, but it avoids\n-            // a\n-            // lot of annoying errors in the compile-fail tests (basically,\n-            // lint warnings and so on -- kindck used to do this abort, but\n-            // kindck is gone now). -nmatsakis\n-            if sess.err_count() > 0 {\n-                return Ok(f(tcx, rx, sess.compile_status()));\n-            }\n-\n-            time(sess, \"misc checking\", || {\n-                parallel!({\n-                    time(sess, \"privacy checking\", || {\n-                        rustc_privacy::check_crate(tcx)\n-                    });\n-                }, {\n-                    time(sess, \"death checking\", || middle::dead::check_crate(tcx));\n-                },  {\n-                    time(sess, \"unused lib feature checking\", || {\n-                        stability::check_unused_or_stable_features(tcx)\n-                    });\n-                }, {\n-                    time(sess, \"lint checking\", || lint::check_crate(tcx));\n-                });\n-            });\n-\n-            return Ok(f(tcx, rx, tcx.sess.compile_status()));\n+            f(tcx, rx, tcx.sess.compile_status())\n         },\n     )\n }\n@@ -1359,328 +1246,3 @@ pub fn phase_4_codegen<'a, 'tcx>(\n \n     codegen\n }\n-\n-fn escape_dep_filename(filename: &FileName) -> String {\n-    // Apparently clang and gcc *only* escape spaces:\n-    // http://llvm.org/klaus/clang/commit/9d50634cfc268ecc9a7250226dd5ca0e945240d4\n-    filename.to_string().replace(\" \", \"\\\\ \")\n-}\n-\n-// Returns all the paths that correspond to generated files.\n-fn generated_output_paths(\n-    sess: &Session,\n-    outputs: &OutputFilenames,\n-    exact_name: bool,\n-    crate_name: &str,\n-) -> Vec<PathBuf> {\n-    let mut out_filenames = Vec::new();\n-    for output_type in sess.opts.output_types.keys() {\n-        let file = outputs.path(*output_type);\n-        match *output_type {\n-            // If the filename has been overridden using `-o`, it will not be modified\n-            // by appending `.rlib`, `.exe`, etc., so we can skip this transformation.\n-            OutputType::Exe if !exact_name => for crate_type in sess.crate_types.borrow().iter() {\n-                let p = ::rustc_codegen_utils::link::filename_for_input(\n-                    sess,\n-                    *crate_type,\n-                    crate_name,\n-                    outputs,\n-                );\n-                out_filenames.push(p);\n-            },\n-            OutputType::DepInfo if sess.opts.debugging_opts.dep_info_omit_d_target => {\n-                // Don't add the dep-info output when omitting it from dep-info targets\n-            }\n-            _ => {\n-                out_filenames.push(file);\n-            }\n-        }\n-    }\n-    out_filenames\n-}\n-\n-// Runs `f` on every output file path and returns the first non-None result, or None if `f`\n-// returns None for every file path.\n-fn check_output<F, T>(output_paths: &[PathBuf], f: F) -> Option<T>\n-where\n-    F: Fn(&PathBuf) -> Option<T>,\n-{\n-    for output_path in output_paths {\n-        if let Some(result) = f(output_path) {\n-            return Some(result);\n-        }\n-    }\n-    None\n-}\n-\n-pub fn output_contains_path(output_paths: &[PathBuf], input_path: &PathBuf) -> bool {\n-    let input_path = input_path.canonicalize().ok();\n-    if input_path.is_none() {\n-        return false;\n-    }\n-    let check = |output_path: &PathBuf| {\n-        if output_path.canonicalize().ok() == input_path {\n-            Some(())\n-        } else {\n-            None\n-        }\n-    };\n-    check_output(output_paths, check).is_some()\n-}\n-\n-pub fn output_conflicts_with_dir(output_paths: &[PathBuf]) -> Option<PathBuf> {\n-    let check = |output_path: &PathBuf| {\n-        if output_path.is_dir() {\n-            Some(output_path.clone())\n-        } else {\n-            None\n-        }\n-    };\n-    check_output(output_paths, check)\n-}\n-\n-fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames: &[PathBuf]) {\n-    // Write out dependency rules to the dep-info file if requested\n-    if !sess.opts.output_types.contains_key(&OutputType::DepInfo) {\n-        return;\n-    }\n-    let deps_filename = outputs.path(OutputType::DepInfo);\n-\n-    let result = (|| -> io::Result<()> {\n-        // Build a list of files used to compile the output and\n-        // write Makefile-compatible dependency rules\n-        let files: Vec<String> = sess.source_map()\n-            .files()\n-            .iter()\n-            .filter(|fmap| fmap.is_real_file())\n-            .filter(|fmap| !fmap.is_imported())\n-            .map(|fmap| escape_dep_filename(&fmap.name))\n-            .collect();\n-        let mut file = fs::File::create(&deps_filename)?;\n-        for path in out_filenames {\n-            writeln!(file, \"{}: {}\\n\", path.display(), files.join(\" \"))?;\n-        }\n-\n-        // Emit a fake target for each input file to the compilation. This\n-        // prevents `make` from spitting out an error if a file is later\n-        // deleted. For more info see #28735\n-        for path in files {\n-            writeln!(file, \"{}:\", path)?;\n-        }\n-        Ok(())\n-    })();\n-\n-    if let Err(e) = result {\n-        sess.fatal(&format!(\n-            \"error writing dependencies to `{}`: {}\",\n-            deps_filename.display(),\n-            e\n-        ));\n-    }\n-}\n-\n-pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n-    // Unconditionally collect crate types from attributes to make them used\n-    let attr_types: Vec<config::CrateType> = attrs\n-        .iter()\n-        .filter_map(|a| {\n-            if a.check_name(\"crate_type\") {\n-                match a.value_str() {\n-                    Some(ref n) if *n == \"rlib\" => Some(config::CrateType::Rlib),\n-                    Some(ref n) if *n == \"dylib\" => Some(config::CrateType::Dylib),\n-                    Some(ref n) if *n == \"cdylib\" => Some(config::CrateType::Cdylib),\n-                    Some(ref n) if *n == \"lib\" => Some(config::default_lib_output()),\n-                    Some(ref n) if *n == \"staticlib\" => Some(config::CrateType::Staticlib),\n-                    Some(ref n) if *n == \"proc-macro\" => Some(config::CrateType::ProcMacro),\n-                    Some(ref n) if *n == \"bin\" => Some(config::CrateType::Executable),\n-                    Some(ref n) => {\n-                        let crate_types = vec![\n-                            Symbol::intern(\"rlib\"),\n-                            Symbol::intern(\"dylib\"),\n-                            Symbol::intern(\"cdylib\"),\n-                            Symbol::intern(\"lib\"),\n-                            Symbol::intern(\"staticlib\"),\n-                            Symbol::intern(\"proc-macro\"),\n-                            Symbol::intern(\"bin\")\n-                        ];\n-\n-                        if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().node {\n-                            let span = spanned.span;\n-                            let lev_candidate = find_best_match_for_name(\n-                                crate_types.iter(),\n-                                &n.as_str(),\n-                                None\n-                            );\n-                            if let Some(candidate) = lev_candidate {\n-                                session.buffer_lint_with_diagnostic(\n-                                    lint::builtin::UNKNOWN_CRATE_TYPES,\n-                                    ast::CRATE_NODE_ID,\n-                                    span,\n-                                    \"invalid `crate_type` value\",\n-                                    lint::builtin::BuiltinLintDiagnostics::\n-                                        UnknownCrateTypes(\n-                                            span,\n-                                            \"did you mean\".to_string(),\n-                                            format!(\"\\\"{}\\\"\", candidate)\n-                                        )\n-                                );\n-                            } else {\n-                                session.buffer_lint(\n-                                    lint::builtin::UNKNOWN_CRATE_TYPES,\n-                                    ast::CRATE_NODE_ID,\n-                                    span,\n-                                    \"invalid `crate_type` value\"\n-                                );\n-                            }\n-                        }\n-                        None\n-                    }\n-                    None => None\n-                }\n-            } else {\n-                None\n-            }\n-        })\n-        .collect();\n-\n-    // If we're generating a test executable, then ignore all other output\n-    // styles at all other locations\n-    if session.opts.test {\n-        return vec![config::CrateType::Executable];\n-    }\n-\n-    // Only check command line flags if present. If no types are specified by\n-    // command line, then reuse the empty `base` Vec to hold the types that\n-    // will be found in crate attributes.\n-    let mut base = session.opts.crate_types.clone();\n-    if base.is_empty() {\n-        base.extend(attr_types);\n-        if base.is_empty() {\n-            base.push(::rustc_codegen_utils::link::default_output_for_target(\n-                session,\n-            ));\n-        } else {\n-            base.sort();\n-            base.dedup();\n-        }\n-    }\n-\n-    base.retain(|crate_type| {\n-        let res = !::rustc_codegen_utils::link::invalid_output_for_target(session, *crate_type);\n-\n-        if !res {\n-            session.warn(&format!(\n-                \"dropping unsupported crate type `{}` for target `{}`\",\n-                *crate_type, session.opts.target_triple\n-            ));\n-        }\n-\n-        res\n-    });\n-\n-    base\n-}\n-\n-pub fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguator {\n-    use std::hash::Hasher;\n-\n-    // The crate_disambiguator is a 128 bit hash. The disambiguator is fed\n-    // into various other hashes quite a bit (symbol hashes, incr. comp. hashes,\n-    // debuginfo type IDs, etc), so we don't want it to be too wide. 128 bits\n-    // should still be safe enough to avoid collisions in practice.\n-    let mut hasher = StableHasher::<Fingerprint>::new();\n-\n-    let mut metadata = session.opts.cg.metadata.clone();\n-    // We don't want the crate_disambiguator to dependent on the order\n-    // -C metadata arguments, so sort them:\n-    metadata.sort();\n-    // Every distinct -C metadata value is only incorporated once:\n-    metadata.dedup();\n-\n-    hasher.write(b\"metadata\");\n-    for s in &metadata {\n-        // Also incorporate the length of a metadata string, so that we generate\n-        // different values for `-Cmetadata=ab -Cmetadata=c` and\n-        // `-Cmetadata=a -Cmetadata=bc`\n-        hasher.write_usize(s.len());\n-        hasher.write(s.as_bytes());\n-    }\n-\n-    // Also incorporate crate type, so that we don't get symbol conflicts when\n-    // linking against a library of the same name, if this is an executable.\n-    let is_exe = session\n-        .crate_types\n-        .borrow()\n-        .contains(&config::CrateType::Executable);\n-    hasher.write(if is_exe { b\"exe\" } else { b\"lib\" });\n-\n-    CrateDisambiguator::from(hasher.finish())\n-}\n-\n-pub fn build_output_filenames(\n-    input: &Input,\n-    odir: &Option<PathBuf>,\n-    ofile: &Option<PathBuf>,\n-    attrs: &[ast::Attribute],\n-    sess: &Session,\n-) -> OutputFilenames {\n-    match *ofile {\n-        None => {\n-            // \"-\" as input file will cause the parser to read from stdin so we\n-            // have to make up a name\n-            // We want to toss everything after the final '.'\n-            let dirpath = (*odir).as_ref().cloned().unwrap_or_default();\n-\n-            // If a crate name is present, we use it as the link name\n-            let stem = sess.opts\n-                .crate_name\n-                .clone()\n-                .or_else(|| attr::find_crate_name(attrs).map(|n| n.to_string()))\n-                .unwrap_or_else(|| input.filestem().to_owned());\n-\n-            OutputFilenames {\n-                out_directory: dirpath,\n-                out_filestem: stem,\n-                single_output_file: None,\n-                extra: sess.opts.cg.extra_filename.clone(),\n-                outputs: sess.opts.output_types.clone(),\n-            }\n-        }\n-\n-        Some(ref out_file) => {\n-            let unnamed_output_types = sess.opts\n-                .output_types\n-                .values()\n-                .filter(|a| a.is_none())\n-                .count();\n-            let ofile = if unnamed_output_types > 1 {\n-                sess.warn(\n-                    \"due to multiple output types requested, the explicitly specified \\\n-                     output file name will be adapted for each output type\",\n-                );\n-                None\n-            } else {\n-                Some(out_file.clone())\n-            };\n-            if *odir != None {\n-                sess.warn(\"ignoring --out-dir flag due to -o flag\");\n-            }\n-            if !sess.opts.cg.extra_filename.is_empty() {\n-                sess.warn(\"ignoring -C extra-filename flag due to -o flag\");\n-            }\n-\n-            OutputFilenames {\n-                out_directory: out_file.parent().unwrap_or_else(|| Path::new(\"\")).to_path_buf(),\n-                out_filestem: out_file\n-                    .file_stem()\n-                    .unwrap_or_default()\n-                    .to_str()\n-                    .unwrap()\n-                    .to_string(),\n-                single_output_file: ofile,\n-                extra: sess.opts.cg.extra_filename.clone(),\n-                outputs: sess.opts.output_types.clone(),\n-            }\n-        }\n-    }\n-}"}, {"sha": "52dbb618d0d11ac5420bafb57e0ca936437869af", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 25, "deletions": 274, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -27,7 +27,6 @@ extern crate rustc;\n extern crate rustc_allocator;\n extern crate rustc_target;\n extern crate rustc_borrowck;\n-#[macro_use]\n extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n extern crate rustc_passes;\n@@ -42,6 +41,7 @@ extern crate rustc_save_analysis;\n extern crate rustc_traits;\n extern crate rustc_codegen_utils;\n extern crate rustc_typeck;\n+extern crate rustc_interface;\n extern crate scoped_tls;\n extern crate serialize;\n extern crate smallvec;\n@@ -58,39 +58,34 @@ use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n use rustc_data_structures::sync::{self, Lrc, Ordering::SeqCst};\n use rustc_data_structures::OnDrop;\n-use rustc::session::{self, config, Session, build_session, CompileResult};\n+use rustc::session::{self, config, Session, build_session, CompileResult, DiagnosticOutput};\n use rustc::session::CompileIncomplete;\n use rustc::session::config::{Input, PrintRequest, ErrorOutputType};\n use rustc::session::config::nightly_options;\n-use rustc::session::filesearch;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n-use rustc_metadata::dynamic_lib::DynamicLibrary;\n use rustc::util::common::{time, ErrorReported};\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_interface::util::{self, get_codegen_sysroot};\n \n use serialize::json::ToJson;\n \n use std::any::Any;\n use std::borrow::Cow;\n use std::cmp::max;\n use std::default::Default;\n-use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n use std::env;\n use std::error::Error;\n use std::ffi::OsString;\n use std::fmt::{self, Display};\n use std::io::{self, Read, Write};\n-use std::mem;\n use std::panic;\n-use std::path::{PathBuf, Path};\n+use std::path::PathBuf;\n use std::process::{self, Command, Stdio};\n use std::str;\n-use std::sync::atomic::{AtomicBool, Ordering};\n-use std::sync::{Once, ONCE_INIT};\n use std::thread;\n \n use syntax::ast;\n@@ -102,34 +97,8 @@ use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n #[cfg(test)]\n mod test;\n \n-pub mod profile;\n pub mod driver;\n pub mod pretty;\n-mod proc_macro_decls;\n-\n-pub mod target_features {\n-    use syntax::ast;\n-    use syntax::symbol::Symbol;\n-    use rustc::session::Session;\n-    use rustc_codegen_utils::codegen_backend::CodegenBackend;\n-\n-    /// Adds `target_feature = \"...\"` cfgs for a variety of platform\n-    /// specific features (SSE, NEON etc.).\n-    ///\n-    /// This is performed by checking whether a whitelisted set of\n-    /// features is available on the target machine, by querying LLVM.\n-    pub fn add_configuration(cfg: &mut ast::CrateConfig,\n-                             sess: &Session,\n-                             codegen_backend: &dyn CodegenBackend) {\n-        let tf = Symbol::intern(\"target_feature\");\n-\n-        cfg.extend(codegen_backend.target_features(sess).into_iter().map(|feat| (tf, Some(feat))));\n-\n-        if sess.crt_static_feature() {\n-            cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n-        }\n-    }\n-}\n \n /// Exit status code used for successful compilation and help output.\n pub const EXIT_SUCCESS: isize = 0;\n@@ -196,235 +165,6 @@ pub fn run<F>(run_compiler: F) -> isize\n     }\n }\n \n-fn load_backend_from_dylib(path: &Path) -> fn() -> Box<dyn CodegenBackend> {\n-    let lib = DynamicLibrary::open(Some(path)).unwrap_or_else(|err| {\n-        let err = format!(\"couldn't load codegen backend {:?}: {:?}\", path, err);\n-        early_error(ErrorOutputType::default(), &err);\n-    });\n-    unsafe {\n-        match lib.symbol(\"__rustc_codegen_backend\") {\n-            Ok(f) => {\n-                mem::forget(lib);\n-                mem::transmute::<*mut u8, _>(f)\n-            }\n-            Err(e) => {\n-                let err = format!(\"couldn't load codegen backend as it \\\n-                                   doesn't export the `__rustc_codegen_backend` \\\n-                                   symbol: {:?}\", e);\n-                early_error(ErrorOutputType::default(), &err);\n-            }\n-        }\n-    }\n-}\n-\n-pub fn get_codegen_backend(sess: &Session) -> Box<dyn CodegenBackend> {\n-    static INIT: Once = ONCE_INIT;\n-\n-    #[allow(deprecated)]\n-    #[no_debug]\n-    static mut LOAD: fn() -> Box<dyn CodegenBackend> = || unreachable!();\n-\n-    INIT.call_once(|| {\n-        let codegen_name = sess.opts.debugging_opts.codegen_backend.as_ref()\n-            .unwrap_or(&sess.target.target.options.codegen_backend);\n-        let backend = match &codegen_name[..] {\n-            \"metadata_only\" => {\n-                rustc_codegen_utils::codegen_backend::MetadataOnlyCodegenBackend::boxed\n-            }\n-            filename if filename.contains(\".\") => {\n-                load_backend_from_dylib(filename.as_ref())\n-            }\n-            codegen_name => get_codegen_sysroot(codegen_name),\n-        };\n-\n-        unsafe {\n-            LOAD = backend;\n-        }\n-    });\n-    let backend = unsafe { LOAD() };\n-    backend.init(sess);\n-    backend\n-}\n-\n-fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n-    // For now we only allow this function to be called once as it'll dlopen a\n-    // few things, which seems to work best if we only do that once. In\n-    // general this assertion never trips due to the once guard in `get_codegen_backend`,\n-    // but there's a few manual calls to this function in this file we protect\n-    // against.\n-    static LOADED: AtomicBool = AtomicBool::new(false);\n-    assert!(!LOADED.fetch_or(true, Ordering::SeqCst),\n-            \"cannot load the default codegen backend twice\");\n-\n-    // When we're compiling this library with `--test` it'll run as a binary but\n-    // not actually exercise much functionality. As a result most of the logic\n-    // here is defunkt (it assumes we're a dynamic library in a sysroot) so\n-    // let's just return a dummy creation function which won't be used in\n-    // general anyway.\n-    if cfg!(test) {\n-        return rustc_codegen_utils::codegen_backend::MetadataOnlyCodegenBackend::boxed\n-    }\n-\n-    let target = session::config::host_triple();\n-    let mut sysroot_candidates = vec![filesearch::get_or_default_sysroot()];\n-    let path = current_dll_path()\n-        .and_then(|s| s.canonicalize().ok());\n-    if let Some(dll) = path {\n-        // use `parent` twice to chop off the file name and then also the\n-        // directory containing the dll which should be either `lib` or `bin`.\n-        if let Some(path) = dll.parent().and_then(|p| p.parent()) {\n-            // The original `path` pointed at the `rustc_driver` crate's dll.\n-            // Now that dll should only be in one of two locations. The first is\n-            // in the compiler's libdir, for example `$sysroot/lib/*.dll`. The\n-            // other is the target's libdir, for example\n-            // `$sysroot/lib/rustlib/$target/lib/*.dll`.\n-            //\n-            // We don't know which, so let's assume that if our `path` above\n-            // ends in `$target` we *could* be in the target libdir, and always\n-            // assume that we may be in the main libdir.\n-            sysroot_candidates.push(path.to_owned());\n-\n-            if path.ends_with(target) {\n-                sysroot_candidates.extend(path.parent() // chop off `$target`\n-                    .and_then(|p| p.parent())           // chop off `rustlib`\n-                    .and_then(|p| p.parent())           // chop off `lib`\n-                    .map(|s| s.to_owned()));\n-            }\n-        }\n-    }\n-\n-    let sysroot = sysroot_candidates.iter()\n-        .map(|sysroot| {\n-            let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n-            sysroot.join(libdir).with_file_name(\n-                option_env!(\"CFG_CODEGEN_BACKENDS_DIR\").unwrap_or(\"codegen-backends\"))\n-        })\n-        .filter(|f| {\n-            info!(\"codegen backend candidate: {}\", f.display());\n-            f.exists()\n-        })\n-        .next();\n-    let sysroot = sysroot.unwrap_or_else(|| {\n-        let candidates = sysroot_candidates.iter()\n-            .map(|p| p.display().to_string())\n-            .collect::<Vec<_>>()\n-            .join(\"\\n* \");\n-        let err = format!(\"failed to find a `codegen-backends` folder \\\n-                           in the sysroot candidates:\\n* {}\", candidates);\n-        early_error(ErrorOutputType::default(), &err);\n-    });\n-    info!(\"probing {} for a codegen backend\", sysroot.display());\n-\n-    let d = sysroot.read_dir().unwrap_or_else(|e| {\n-        let err = format!(\"failed to load default codegen backend, couldn't \\\n-                           read `{}`: {}\", sysroot.display(), e);\n-        early_error(ErrorOutputType::default(), &err);\n-    });\n-\n-    let mut file: Option<PathBuf> = None;\n-\n-    let expected_name = format!(\"rustc_codegen_llvm-{}\", backend_name);\n-    for entry in d.filter_map(|e| e.ok()) {\n-        let path = entry.path();\n-        let filename = match path.file_name().and_then(|s| s.to_str()) {\n-            Some(s) => s,\n-            None => continue,\n-        };\n-        if !(filename.starts_with(DLL_PREFIX) && filename.ends_with(DLL_SUFFIX)) {\n-            continue\n-        }\n-        let name = &filename[DLL_PREFIX.len() .. filename.len() - DLL_SUFFIX.len()];\n-        if name != expected_name {\n-            continue\n-        }\n-        if let Some(ref prev) = file {\n-            let err = format!(\"duplicate codegen backends found\\n\\\n-                               first:  {}\\n\\\n-                               second: {}\\n\\\n-            \", prev.display(), path.display());\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-        file = Some(path.clone());\n-    }\n-\n-    match file {\n-        Some(ref s) => return load_backend_from_dylib(s),\n-        None => {\n-            let err = format!(\"failed to load default codegen backend for `{}`, \\\n-                               no appropriate codegen dylib found in `{}`\",\n-                              backend_name, sysroot.display());\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn current_dll_path() -> Option<PathBuf> {\n-        use std::ffi::{OsStr, CStr};\n-        use std::os::unix::prelude::*;\n-\n-        unsafe {\n-            let addr = current_dll_path as usize as *mut _;\n-            let mut info = mem::zeroed();\n-            if libc::dladdr(addr, &mut info) == 0 {\n-                info!(\"dladdr failed\");\n-                return None\n-            }\n-            if info.dli_fname.is_null() {\n-                info!(\"dladdr returned null pointer\");\n-                return None\n-            }\n-            let bytes = CStr::from_ptr(info.dli_fname).to_bytes();\n-            let os = OsStr::from_bytes(bytes);\n-            Some(PathBuf::from(os))\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn current_dll_path() -> Option<PathBuf> {\n-        use std::ffi::OsString;\n-        use std::os::windows::prelude::*;\n-\n-        extern \"system\" {\n-            fn GetModuleHandleExW(dwFlags: u32,\n-                                  lpModuleName: usize,\n-                                  phModule: *mut usize) -> i32;\n-            fn GetModuleFileNameW(hModule: usize,\n-                                  lpFilename: *mut u16,\n-                                  nSize: u32) -> u32;\n-        }\n-\n-        const GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS: u32 = 0x00000004;\n-\n-        unsafe {\n-            let mut module = 0;\n-            let r = GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n-                                       current_dll_path as usize,\n-                                       &mut module);\n-            if r == 0 {\n-                info!(\"GetModuleHandleExW failed: {}\", io::Error::last_os_error());\n-                return None\n-            }\n-            let mut space = Vec::with_capacity(1024);\n-            let r = GetModuleFileNameW(module,\n-                                       space.as_mut_ptr(),\n-                                       space.capacity() as u32);\n-            if r == 0 {\n-                info!(\"GetModuleFileNameW failed: {}\", io::Error::last_os_error());\n-                return None\n-            }\n-            let r = r as usize;\n-            if r >= space.capacity() {\n-                info!(\"our buffer was too small? {}\",\n-                      io::Error::last_os_error());\n-                return None\n-            }\n-            space.set_len(r);\n-            let os = OsString::from_wide(&space);\n-            Some(PathBuf::from(os))\n-        }\n-    }\n-}\n-\n // Parse args and run the compiler. This is the primary entry point for rustc.\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n@@ -485,7 +225,12 @@ fn run_compiler_with_pool<'a>(\n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let source_map = Lrc::new(SourceMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_source_map(\n-        sopts, input_file_path.clone(), descriptions, source_map, emitter_dest,\n+        sopts,\n+        input_file_path.clone(),\n+        descriptions,\n+        source_map,\n+        emitter_dest.map(|e| DiagnosticOutput::Raw(e)).unwrap_or(DiagnosticOutput::Default),\n+        Default::default(),\n     );\n \n     if let Some(err) = input_err {\n@@ -495,12 +240,12 @@ fn run_compiler_with_pool<'a>(\n         return (Err(CompileIncomplete::Stopped), Some(sess));\n     }\n \n-    let codegen_backend = get_codegen_backend(&sess);\n+    let codegen_backend = util::get_codegen_backend(&sess);\n \n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, cfg);\n-    target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n+    util::add_configuration(&mut cfg, &sess, &*codegen_backend);\n     sess.parse_sess.config = cfg;\n \n     let result = {\n@@ -710,8 +455,8 @@ fn stdout_isatty() -> bool {\n }\n \n fn handle_explain(code: &str,\n-                  descriptions: &errors::registry::Registry,\n                   output: ErrorOutputType) {\n+    let descriptions = rustc_interface::util::diagnostics_registry();\n     let normalised = if code.starts_with(\"E\") {\n         code.to_string()\n     } else {\n@@ -788,11 +533,11 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                       matches: &getopts::Matches,\n                       _: &config::Options,\n                       _: &ast::CrateConfig,\n-                      descriptions: &errors::registry::Registry,\n+                      _: &errors::registry::Registry,\n                       output: ErrorOutputType)\n                       -> Compilation {\n         if let Some(ref code) = matches.opt_str(\"explain\") {\n-            handle_explain(code, descriptions, output);\n+            handle_explain(code, output);\n             return Compilation::Stop;\n         }\n \n@@ -820,8 +565,8 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 }\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n-                let codegen_backend = get_codegen_backend(&sess);\n-                target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n+                let codegen_backend = util::get_codegen_backend(&sess);\n+                util::add_configuration(&mut cfg, &sess, &*codegen_backend);\n                 sess.parse_sess.config = cfg;\n                 let should_stop = RustcDefaultCalls::print_crate_info(\n                     &*codegen_backend,\n@@ -1024,13 +769,19 @@ impl RustcDefaultCalls {\n                     let input = input.unwrap_or_else(||\n                         early_error(ErrorOutputType::default(), \"no input file provided\"));\n                     let attrs = attrs.as_ref().unwrap();\n-                    let t_outputs = driver::build_output_filenames(input, odir, ofile, attrs, sess);\n+                    let t_outputs = rustc_interface::util::build_output_filenames(\n+                        input,\n+                        odir,\n+                        ofile,\n+                        attrs,\n+                        sess\n+                    );\n                     let id = rustc_codegen_utils::link::find_crate_name(Some(sess), attrs, input);\n                     if *req == PrintRequest::CrateName {\n                         println!(\"{}\", id);\n                         continue;\n                     }\n-                    let crate_types = driver::collect_crate_types(sess, attrs);\n+                    let crate_types = rustc_interface::util::collect_crate_types(sess, attrs);\n                     for &style in &crate_types {\n                         let fname = rustc_codegen_utils::link::filename_for_input(\n                             sess,"}, {"sha": "ac2f6da0c608472f609485473f3817afbc14f21d", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 34, "deletions": 236, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -9,36 +9,33 @@ use rustc::hir::print as pprust_hir;\n use rustc::session::Session;\n use rustc::session::config::{Input, OutputFilenames};\n use rustc::ty::{self, TyCtxt, Resolutions, AllArenas};\n+use rustc_interface::util;\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_metadata::cstore::CStore;\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n-use syntax::ast::{self, BlockCheckMode};\n-use syntax::mut_visit::{*, MutVisitor, visit_clobber};\n+use syntax::ast;\n+use syntax::mut_visit::MutVisitor;\n use syntax::print::{pprust};\n use syntax::print::pprust::PrintState;\n-use syntax::ptr::P;\n-use syntax_pos::{self, FileName};\n+use syntax_pos::FileName;\n \n use graphviz as dot;\n-use smallvec::SmallVec;\n \n use std::cell::Cell;\n use std::fs::File;\n use std::io::{self, Write};\n-use std::ops::DerefMut;\n use std::option;\n use std::path::Path;\n use std::str::FromStr;\n-use std::mem;\n \n pub use self::UserIdentifiedItem::*;\n pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n use self::NodesMatchingUII::*;\n-use {abort_on_err, driver};\n+use abort_on_err;\n+use driver;\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {\n@@ -217,18 +214,19 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let control = &driver::CompileController::basic();\n-                let codegen_backend = ::get_codegen_backend(sess);\n+                let codegen_backend = util::get_codegen_backend(sess);\n                 let mut arenas = AllArenas::new();\n-                abort_on_err(driver::phase_3_run_analysis_passes(&*codegen_backend,\n-                                                                 control,\n-                                                                 sess,\n-                                                                 cstore,\n-                                                                 hir_map.clone(),\n-                                                                 resolutions.clone(),\n-                                                                 &mut arenas,\n-                                                                 id,\n-                                                                 output_filenames,\n-                                                                 |tcx, _, _| {\n+                driver::phase_3_run_analysis_passes(&*codegen_backend,\n+                                                    control,\n+                                                    sess,\n+                                                    cstore,\n+                                                    hir_map.clone(),\n+                                                    resolutions.clone(),\n+                                                    &mut arenas,\n+                                                    id,\n+                                                    output_filenames,\n+                                                    |tcx, _, result| {\n+                    abort_on_err(result, tcx.sess);\n                     let empty_tables = ty::TypeckTables::empty(None);\n                     let annotation = TypedAnnotation {\n                         tcx,\n@@ -237,8 +235,7 @@ impl PpSourceMode {\n                     tcx.dep_graph.with_ignore(|| {\n                         f(&annotation, hir_map.forest.krate())\n                     })\n-                }),\n-                             sess)\n+                })\n             }\n             _ => panic!(\"Should use call_with_pp_support\"),\n         }\n@@ -627,204 +624,6 @@ impl UserIdentifiedItem {\n     }\n }\n \n-// Note: Also used by librustdoc, see PR #43348. Consider moving this struct elsewhere.\n-//\n-// FIXME: Currently the `everybody_loops` transformation is not applied to:\n-//  * `const fn`, due to issue #43636 that `loop` is not supported for const evaluation. We are\n-//    waiting for miri to fix that.\n-//  * `impl Trait`, due to issue #43869 that functions returning impl Trait cannot be diverging.\n-//    Solving this may require `!` to implement every trait, which relies on the an even more\n-//    ambitious form of the closed RFC #1637. See also [#34511].\n-//\n-// [#34511]: https://github.com/rust-lang/rust/issues/34511#issuecomment-322340401\n-pub struct ReplaceBodyWithLoop<'a> {\n-    within_static_or_const: bool,\n-    nested_blocks: Option<Vec<ast::Block>>,\n-    sess: &'a Session,\n-}\n-\n-impl<'a> ReplaceBodyWithLoop<'a> {\n-    pub fn new(sess: &'a Session) -> ReplaceBodyWithLoop<'a> {\n-        ReplaceBodyWithLoop {\n-            within_static_or_const: false,\n-            nested_blocks: None,\n-            sess\n-        }\n-    }\n-\n-    fn run<R, F: FnOnce(&mut Self) -> R>(&mut self, is_const: bool, action: F) -> R {\n-        let old_const = mem::replace(&mut self.within_static_or_const, is_const);\n-        let old_blocks = self.nested_blocks.take();\n-        let ret = action(self);\n-        self.within_static_or_const = old_const;\n-        self.nested_blocks = old_blocks;\n-        ret\n-    }\n-\n-    fn should_ignore_fn(ret_ty: &ast::FnDecl) -> bool {\n-        if let ast::FunctionRetTy::Ty(ref ty) = ret_ty.output {\n-            fn involves_impl_trait(ty: &ast::Ty) -> bool {\n-                match ty.node {\n-                    ast::TyKind::ImplTrait(..) => true,\n-                    ast::TyKind::Slice(ref subty) |\n-                    ast::TyKind::Array(ref subty, _) |\n-                    ast::TyKind::Ptr(ast::MutTy { ty: ref subty, .. }) |\n-                    ast::TyKind::Rptr(_, ast::MutTy { ty: ref subty, .. }) |\n-                    ast::TyKind::Paren(ref subty) => involves_impl_trait(subty),\n-                    ast::TyKind::Tup(ref tys) => any_involves_impl_trait(tys.iter()),\n-                    ast::TyKind::Path(_, ref path) => path.segments.iter().any(|seg| {\n-                        match seg.args.as_ref().map(|generic_arg| &**generic_arg) {\n-                            None => false,\n-                            Some(&ast::GenericArgs::AngleBracketed(ref data)) => {\n-                                let types = data.args.iter().filter_map(|arg| match arg {\n-                                    ast::GenericArg::Type(ty) => Some(ty),\n-                                    _ => None,\n-                                });\n-                                any_involves_impl_trait(types.into_iter()) ||\n-                                any_involves_impl_trait(data.bindings.iter().map(|b| &b.ty))\n-                            },\n-                            Some(&ast::GenericArgs::Parenthesized(ref data)) => {\n-                                any_involves_impl_trait(data.inputs.iter()) ||\n-                                any_involves_impl_trait(data.output.iter())\n-                            }\n-                        }\n-                    }),\n-                    _ => false,\n-                }\n-            }\n-\n-            fn any_involves_impl_trait<'a, I: Iterator<Item = &'a P<ast::Ty>>>(mut it: I) -> bool {\n-                it.any(|subty| involves_impl_trait(subty))\n-            }\n-\n-            involves_impl_trait(ty)\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n-    fn visit_item_kind(&mut self, i: &mut ast::ItemKind) {\n-        let is_const = match i {\n-            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => true,\n-            ast::ItemKind::Fn(ref decl, ref header, _, _) =>\n-                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n-            _ => false,\n-        };\n-        self.run(is_const, |s| noop_visit_item_kind(i, s))\n-    }\n-\n-    fn flat_map_trait_item(&mut self, i: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n-        let is_const = match i.node {\n-            ast::TraitItemKind::Const(..) => true,\n-            ast::TraitItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n-                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n-            _ => false,\n-        };\n-        self.run(is_const, |s| noop_flat_map_trait_item(i, s))\n-    }\n-\n-    fn flat_map_impl_item(&mut self, i: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n-        let is_const = match i.node {\n-            ast::ImplItemKind::Const(..) => true,\n-            ast::ImplItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n-                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n-            _ => false,\n-        };\n-        self.run(is_const, |s| noop_flat_map_impl_item(i, s))\n-    }\n-\n-    fn visit_anon_const(&mut self, c: &mut ast::AnonConst) {\n-        self.run(true, |s| noop_visit_anon_const(c, s))\n-    }\n-\n-    fn visit_block(&mut self, b: &mut P<ast::Block>) {\n-        fn stmt_to_block(rules: ast::BlockCheckMode,\n-                         s: Option<ast::Stmt>,\n-                         sess: &Session) -> ast::Block {\n-            ast::Block {\n-                stmts: s.into_iter().collect(),\n-                rules,\n-                id: sess.next_node_id(),\n-                span: syntax_pos::DUMMY_SP,\n-            }\n-        }\n-\n-        fn block_to_stmt(b: ast::Block, sess: &Session) -> ast::Stmt {\n-            let expr = P(ast::Expr {\n-                id: sess.next_node_id(),\n-                node: ast::ExprKind::Block(P(b), None),\n-                span: syntax_pos::DUMMY_SP,\n-                attrs: ThinVec::new(),\n-            });\n-\n-            ast::Stmt {\n-                id: sess.next_node_id(),\n-                node: ast::StmtKind::Expr(expr),\n-                span: syntax_pos::DUMMY_SP,\n-            }\n-        }\n-\n-        let empty_block = stmt_to_block(BlockCheckMode::Default, None, self.sess);\n-        let loop_expr = P(ast::Expr {\n-            node: ast::ExprKind::Loop(P(empty_block), None),\n-            id: self.sess.next_node_id(),\n-            span: syntax_pos::DUMMY_SP,\n-                attrs: ThinVec::new(),\n-        });\n-\n-        let loop_stmt = ast::Stmt {\n-            id: self.sess.next_node_id(),\n-            span: syntax_pos::DUMMY_SP,\n-            node: ast::StmtKind::Expr(loop_expr),\n-        };\n-\n-        if self.within_static_or_const {\n-            noop_visit_block(b, self)\n-        } else {\n-            visit_clobber(b.deref_mut(), |b| {\n-                let mut stmts = vec![];\n-                for s in b.stmts {\n-                    let old_blocks = self.nested_blocks.replace(vec![]);\n-\n-                    stmts.extend(self.flat_map_stmt(s).into_iter().filter(|s| s.is_item()));\n-\n-                    // we put a Some in there earlier with that replace(), so this is valid\n-                    let new_blocks = self.nested_blocks.take().unwrap();\n-                    self.nested_blocks = old_blocks;\n-                    stmts.extend(new_blocks.into_iter().map(|b| block_to_stmt(b, &self.sess)));\n-                }\n-\n-                let mut new_block = ast::Block {\n-                    stmts,\n-                    ..b\n-                };\n-\n-                if let Some(old_blocks) = self.nested_blocks.as_mut() {\n-                    //push our fresh block onto the cache and yield an empty block with `loop {}`\n-                    if !new_block.stmts.is_empty() {\n-                        old_blocks.push(new_block);\n-                    }\n-\n-                    stmt_to_block(b.rules, Some(loop_stmt), self.sess)\n-                } else {\n-                    //push `loop {}` onto the end of our fresh block and yield that\n-                    new_block.stmts.push(loop_stmt);\n-\n-                    new_block\n-                }\n-            })\n-        }\n-    }\n-\n-    // in general the pretty printer processes unexpanded code, so\n-    // we override the default `visit_mac` method which panics.\n-    fn visit_mac(&mut self, mac: &mut ast::Mac) {\n-        noop_visit_mac(mac, self)\n-    }\n-}\n-\n fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n                                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        code: blocks::Code<'tcx>,\n@@ -892,12 +691,12 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n \n pub fn visit_crate(sess: &Session, krate: &mut ast::Crate, ppm: PpMode) {\n     if let PpmSource(PpmEveryBodyLoops) = ppm {\n-        ReplaceBodyWithLoop::new(sess).visit_crate(krate);\n+        util::ReplaceBodyWithLoop::new(sess).visit_crate(krate);\n     }\n }\n \n fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, FileName) {\n-    let src_name = driver::source_name(input);\n+    let src_name = input.source_name();\n     let src = sess.source_map()\n         .get_source_file(&src_name)\n         .unwrap()\n@@ -1117,18 +916,19 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let mut out = Vec::new();\n \n     let control = &driver::CompileController::basic();\n-    let codegen_backend = ::get_codegen_backend(sess);\n+    let codegen_backend = util::get_codegen_backend(sess);\n     let mut arenas = AllArenas::new();\n-    abort_on_err(driver::phase_3_run_analysis_passes(&*codegen_backend,\n-                                                     control,\n-                                                     sess,\n-                                                     cstore,\n-                                                     hir_map.clone(),\n-                                                     resolutions.clone(),\n-                                                     &mut arenas,\n-                                                     crate_name,\n-                                                     output_filenames,\n-                                                     |tcx, _, _| {\n+    driver::phase_3_run_analysis_passes(&*codegen_backend,\n+                                        control,\n+                                        sess,\n+                                        cstore,\n+                                        hir_map.clone(),\n+                                        resolutions.clone(),\n+                                        &mut arenas,\n+                                        crate_name,\n+                                        output_filenames,\n+                                        |tcx, _, result| {\n+        abort_on_err(result, tcx.sess);\n         match ppm {\n             PpmMir | PpmMirCFG => {\n                 if let Some(nodeid) = nodeid {\n@@ -1174,9 +974,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n             }\n             _ => unreachable!(),\n         }\n-    }),\n-                 sess)\n-        .unwrap();\n+    }).unwrap();\n \n     write_output(out, ofile);\n }"}, {"sha": "309a9f7b5252253d8b974f95f6cb624fcb4118a2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -16,6 +16,7 @@ use rustc::ty::query::OnDiskCache;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::sync::{self, Lrc};\n+use rustc_interface::util;\n use rustc_lint;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::abi::Abi;\n@@ -91,6 +92,13 @@ where\n         options.debugging_opts.verbose = true;\n         options.unstable_features = UnstableFeatures::Allow;\n \n+        // When we're compiling this library with `--test` it'll run as a binary but\n+        // not actually exercise much functionality.\n+        // As a result most of the logic loading the codegen backend is defunkt\n+        // (it assumes we're a dynamic library in a sysroot)\n+        // so let's just use the metadata only backend which doesn't need to load any libraries.\n+        options.debugging_opts.codegen_backend = Some(\"metadata_only\".to_owned());\n+\n         driver::spawn_thread_pool(options, |options| {\n             test_env_with_pool(options, source_string, args, body)\n         })\n@@ -111,8 +119,9 @@ fn test_env_with_pool<F>(\n         None,\n         diagnostic_handler,\n         Lrc::new(SourceMap::new(FilePathMapping::empty())),\n+        Default::default(),\n     );\n-    let cstore = CStore::new(::get_codegen_backend(&sess).metadata_loader());\n+    let cstore = CStore::new(util::get_codegen_backend(&sess).metadata_loader());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: FileName::anon_source_code(&source_string),"}, {"sha": "1acd3dfc7656a86f36a38d8e20bc1675e2bf03e0", "filename": "src/librustc_interface/Cargo.toml", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -0,0 +1,35 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_interface\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_interface\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = \"0.4\"\n+rustc-rayon = \"0.1.1\"\n+smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+scoped-tls = { version = \"0.1.1\", features = [\"nightly\"] }\n+syntax = { path = \"../libsyntax\" }\n+syntax_ext = { path = \"../libsyntax_ext\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+serialize = { path = \"../libserialize\" }\n+rustc = { path = \"../librustc\" }\n+rustc_allocator = { path = \"../librustc_allocator\" }\n+rustc_borrowck = { path = \"../librustc_borrowck\" }\n+rustc_incremental = { path = \"../librustc_incremental\" }\n+rustc_traits = { path = \"../librustc_traits\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n+rustc_metadata = { path = \"../librustc_metadata\" }\n+rustc_mir = { path = \"../librustc_mir\" }\n+rustc_passes = { path = \"../librustc_passes\" }\n+rustc_typeck = { path = \"../librustc_typeck\" }\n+rustc_lint = { path = \"../librustc_lint\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+rustc_plugin = { path = \"../librustc_plugin\" }\n+rustc_privacy = { path = \"../librustc_privacy\" }\n+rustc_resolve = { path = \"../librustc_resolve\" }"}, {"sha": "e5c7c35a36d75f7cf410ac7ab6988a23e3bdf566", "filename": "src/librustc_interface/lib.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -0,0 +1,43 @@\n+#![feature(box_syntax)]\n+#![feature(set_stdio)]\n+#![feature(nll)]\n+#![feature(arbitrary_self_types)]\n+#![feature(generator_trait)]\n+#![cfg_attr(unix, feature(libc))]\n+\n+#![allow(unused_imports)]\n+\n+#![recursion_limit=\"256\"]\n+\n+#[cfg(unix)]\n+extern crate libc;\n+#[macro_use]\n+extern crate log;\n+extern crate rustc;\n+extern crate rustc_codegen_utils;\n+extern crate rustc_allocator;\n+extern crate rustc_borrowck;\n+extern crate rustc_incremental;\n+extern crate rustc_traits;\n+#[macro_use]\n+extern crate rustc_data_structures;\n+extern crate rustc_errors;\n+extern crate rustc_lint;\n+extern crate rustc_metadata;\n+extern crate rustc_mir;\n+extern crate rustc_passes;\n+extern crate rustc_plugin;\n+extern crate rustc_privacy;\n+extern crate rustc_rayon as rayon;\n+extern crate rustc_resolve;\n+extern crate rustc_typeck;\n+extern crate smallvec;\n+extern crate serialize;\n+extern crate syntax;\n+extern crate syntax_pos;\n+extern crate syntax_ext;\n+\n+pub mod passes;\n+pub mod profile;\n+pub mod util;\n+pub mod proc_macro_decls;"}, {"sha": "16ced6956380bc4303dacc688df7633255faa036", "filename": "src/librustc_interface/passes.rs", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -0,0 +1,296 @@\n+use util;\n+use proc_macro_decls;\n+\n+use rustc::dep_graph::DepGraph;\n+use rustc::hir;\n+use rustc::hir::lowering::lower_crate;\n+use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc::lint;\n+use rustc::middle::{self, reachable, resolve_lifetime, stability};\n+use rustc::middle::privacy::AccessLevels;\n+use rustc::ty::{self, AllArenas, Resolutions, TyCtxt};\n+use rustc::ty::steal::Steal;\n+use rustc::traits;\n+use rustc::util::common::{time, ErrorReported};\n+use rustc::util::profiling::ProfileCategory;\n+use rustc::session::{CompileResult, CrateDisambiguator, Session};\n+use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n+use rustc::session::search_paths::PathKind;\n+use rustc_allocator as allocator;\n+use rustc_borrowck as borrowck;\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_incremental;\n+use rustc_metadata::creader::CrateLoader;\n+use rustc_metadata::cstore::{self, CStore};\n+use rustc_mir as mir;\n+use rustc_passes::{self, ast_validation, hir_stats, loops, rvalue_promotion, layout_test};\n+use rustc_plugin as plugin;\n+use rustc_plugin::registry::Registry;\n+use rustc_privacy;\n+use rustc_resolve::{Resolver, ResolverArenas};\n+use rustc_traits;\n+use rustc_typeck as typeck;\n+use syntax::{self, ast, attr, diagnostics, visit};\n+use syntax::early_buffered_lints::BufferedEarlyLint;\n+use syntax::ext::base::ExtCtxt;\n+use syntax::mut_visit::MutVisitor;\n+use syntax::parse::{self, PResult};\n+use syntax::util::node_count::NodeCounter;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::symbol::Symbol;\n+use syntax_pos::{FileName, hygiene};\n+use syntax_ext;\n+\n+use serialize::json;\n+\n+use std::any::Any;\n+use std::env;\n+use std::ffi::OsString;\n+use std::fs;\n+use std::io::{self, Write};\n+use std::iter;\n+use std::path::{Path, PathBuf};\n+use std::sync::mpsc;\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+use std::mem;\n+use std::ops::Generator;\n+\n+/// Returns all the paths that correspond to generated files.\n+pub fn generated_output_paths(\n+    sess: &Session,\n+    outputs: &OutputFilenames,\n+    exact_name: bool,\n+    crate_name: &str,\n+) -> Vec<PathBuf> {\n+    let mut out_filenames = Vec::new();\n+    for output_type in sess.opts.output_types.keys() {\n+        let file = outputs.path(*output_type);\n+        match *output_type {\n+            // If the filename has been overridden using `-o`, it will not be modified\n+            // by appending `.rlib`, `.exe`, etc., so we can skip this transformation.\n+            OutputType::Exe if !exact_name => for crate_type in sess.crate_types.borrow().iter() {\n+                let p = ::rustc_codegen_utils::link::filename_for_input(\n+                    sess,\n+                    *crate_type,\n+                    crate_name,\n+                    outputs,\n+                );\n+                out_filenames.push(p);\n+            },\n+            OutputType::DepInfo if sess.opts.debugging_opts.dep_info_omit_d_target => {\n+                // Don't add the dep-info output when omitting it from dep-info targets\n+            }\n+            _ => {\n+                out_filenames.push(file);\n+            }\n+        }\n+    }\n+    out_filenames\n+}\n+\n+// Runs `f` on every output file path and returns the first non-None result, or None if `f`\n+// returns None for every file path.\n+fn check_output<F, T>(output_paths: &[PathBuf], f: F) -> Option<T>\n+where\n+    F: Fn(&PathBuf) -> Option<T>,\n+{\n+    for output_path in output_paths {\n+        if let Some(result) = f(output_path) {\n+            return Some(result);\n+        }\n+    }\n+    None\n+}\n+\n+pub fn output_contains_path(output_paths: &[PathBuf], input_path: &PathBuf) -> bool {\n+    let input_path = input_path.canonicalize().ok();\n+    if input_path.is_none() {\n+        return false;\n+    }\n+    let check = |output_path: &PathBuf| {\n+        if output_path.canonicalize().ok() == input_path {\n+            Some(())\n+        } else {\n+            None\n+        }\n+    };\n+    check_output(output_paths, check).is_some()\n+}\n+\n+pub fn output_conflicts_with_dir(output_paths: &[PathBuf]) -> Option<PathBuf> {\n+    let check = |output_path: &PathBuf| {\n+        if output_path.is_dir() {\n+            Some(output_path.clone())\n+        } else {\n+            None\n+        }\n+    };\n+    check_output(output_paths, check)\n+}\n+\n+fn escape_dep_filename(filename: &FileName) -> String {\n+    // Apparently clang and gcc *only* escape spaces:\n+    // http://llvm.org/klaus/clang/commit/9d50634cfc268ecc9a7250226dd5ca0e945240d4\n+    filename.to_string().replace(\" \", \"\\\\ \")\n+}\n+\n+pub fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames: &[PathBuf]) {\n+    // Write out dependency rules to the dep-info file if requested\n+    if !sess.opts.output_types.contains_key(&OutputType::DepInfo) {\n+        return;\n+    }\n+    let deps_filename = outputs.path(OutputType::DepInfo);\n+\n+    let result = (|| -> io::Result<()> {\n+        // Build a list of files used to compile the output and\n+        // write Makefile-compatible dependency rules\n+        let files: Vec<String> = sess.source_map()\n+            .files()\n+            .iter()\n+            .filter(|fmap| fmap.is_real_file())\n+            .filter(|fmap| !fmap.is_imported())\n+            .map(|fmap| escape_dep_filename(&fmap.name))\n+            .collect();\n+        let mut file = fs::File::create(&deps_filename)?;\n+        for path in out_filenames {\n+            writeln!(file, \"{}: {}\\n\", path.display(), files.join(\" \"))?;\n+        }\n+\n+        // Emit a fake target for each input file to the compilation. This\n+        // prevents `make` from spitting out an error if a file is later\n+        // deleted. For more info see #28735\n+        for path in files {\n+            writeln!(file, \"{}:\", path)?;\n+        }\n+        Ok(())\n+    })();\n+\n+    if let Err(e) = result {\n+        sess.fatal(&format!(\n+            \"error writing dependencies to `{}`: {}\",\n+            deps_filename.display(),\n+            e\n+        ));\n+    }\n+}\n+\n+pub fn provide(providers: &mut ty::query::Providers) {\n+    providers.analysis = analysis;\n+    proc_macro_decls::provide(providers);\n+}\n+\n+fn analysis<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    cnum: CrateNum,\n+) -> Result<(), ErrorReported> {\n+    assert_eq!(cnum, LOCAL_CRATE);\n+\n+    let sess = tcx.sess;\n+\n+    parallel!({\n+        time(sess, \"looking for entry point\", || {\n+            middle::entry::find_entry_point(tcx)\n+        });\n+\n+        time(sess, \"looking for plugin registrar\", || {\n+            plugin::build::find_plugin_registrar(tcx)\n+        });\n+\n+        time(sess, \"looking for derive registrar\", || {\n+            proc_macro_decls::find(tcx)\n+        });\n+    }, {\n+        time(sess, \"loop checking\", || loops::check_crate(tcx));\n+    }, {\n+        time(sess, \"attribute checking\", || {\n+            hir::check_attr::check_crate(tcx)\n+        });\n+    }, {\n+        time(sess, \"stability checking\", || {\n+            stability::check_unstable_api_usage(tcx)\n+        });\n+    });\n+\n+    // passes are timed inside typeck\n+    typeck::check_crate(tcx)?;\n+\n+    time(sess, \"misc checking\", || {\n+        parallel!({\n+            time(sess, \"rvalue promotion\", || {\n+                rvalue_promotion::check_crate(tcx)\n+            });\n+        }, {\n+            time(sess, \"intrinsic checking\", || {\n+                middle::intrinsicck::check_crate(tcx)\n+            });\n+        }, {\n+            time(sess, \"match checking\", || mir::matchck_crate(tcx));\n+        }, {\n+            // this must run before MIR dump, because\n+            // \"not all control paths return a value\" is reported here.\n+            //\n+            // maybe move the check to a MIR pass?\n+            time(sess, \"liveness checking\", || {\n+                middle::liveness::check_crate(tcx)\n+            });\n+        });\n+    });\n+\n+    // Abort so we don't try to construct MIR with liveness errors.\n+    // We also won't want to continue with errors from rvalue promotion\n+    tcx.sess.abort_if_errors();\n+\n+    time(sess, \"borrow checking\", || {\n+        if tcx.use_ast_borrowck() {\n+            borrowck::check_crate(tcx);\n+        }\n+    });\n+\n+    time(sess,\n+            \"MIR borrow checking\",\n+            || tcx.par_body_owners(|def_id| { tcx.ensure().mir_borrowck(def_id); }));\n+\n+    time(sess, \"dumping chalk-like clauses\", || {\n+        rustc_traits::lowering::dump_program_clauses(tcx);\n+    });\n+\n+    time(sess, \"MIR effect checking\", || {\n+        for def_id in tcx.body_owners() {\n+            mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n+        }\n+    });\n+\n+    time(sess, \"layout testing\", || layout_test::test_layout(tcx));\n+\n+    // Avoid overwhelming user with errors if borrow checking failed.\n+    // I'm not sure how helpful this is, to be honest, but it avoids\n+    // a\n+    // lot of annoying errors in the compile-fail tests (basically,\n+    // lint warnings and so on -- kindck used to do this abort, but\n+    // kindck is gone now). -nmatsakis\n+    if sess.err_count() > 0 {\n+        return Err(ErrorReported);\n+    }\n+\n+    time(sess, \"misc checking\", || {\n+        parallel!({\n+            time(sess, \"privacy checking\", || {\n+                rustc_privacy::check_crate(tcx)\n+            });\n+        }, {\n+            time(sess, \"death checking\", || middle::dead::check_crate(tcx));\n+        },  {\n+            time(sess, \"unused lib feature checking\", || {\n+                stability::check_unused_or_stable_features(tcx)\n+            });\n+        }, {\n+            time(sess, \"lint checking\", || lint::check_crate(tcx));\n+        });\n+    });\n+\n+    Ok(())\n+}"}, {"sha": "093d15b7e3c577c4c9212bf4b1b658ff21057708", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "previous_filename": "src/librustc_driver/proc_macro_decls.rs"}, {"sha": "eb13a5668f927f7d680349ad8628971e2c7f8896", "filename": "src/librustc_interface/profile/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fprofile%2Fmod.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "previous_filename": "src/librustc_driver/profile/mod.rs"}, {"sha": "95c4ea6ff23478ffd6868c06238be7d7e94d5190", "filename": "src/librustc_interface/profile/trace.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "previous_filename": "src/librustc_driver/profile/trace.rs"}, {"sha": "6f92c3044621557e9a98a34a076724d65a73a5c6", "filename": "src/librustc_interface/util.rs", "status": "added", "additions": 702, "deletions": 0, "changes": 702, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -0,0 +1,702 @@\n+use rustc::session::config::{Input, OutputFilenames, ErrorOutputType};\n+use rustc::session::{self, config, early_error, filesearch, Session, DiagnosticOutput};\n+use rustc::session::CrateDisambiguator;\n+use rustc::ty;\n+use rustc::lint;\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_errors::registry::Registry;\n+use rustc_lint;\n+use rustc_metadata::dynamic_lib::DynamicLibrary;\n+use rustc_mir;\n+use rustc_passes;\n+use rustc_plugin;\n+use rustc_privacy;\n+use rustc_resolve;\n+use rustc_typeck;\n+use std::collections::HashSet;\n+use std::env;\n+use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n+use std::io::{self, Write};\n+use std::mem;\n+use std::path::{Path, PathBuf};\n+use std::sync::atomic::{AtomicBool, Ordering};\n+use std::sync::{Arc, Mutex, Once};\n+use std::ops::DerefMut;\n+use smallvec::SmallVec;\n+use syntax::ptr::P;\n+use syntax::mut_visit::{*, MutVisitor, visit_clobber};\n+use syntax::ast::BlockCheckMode;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::source_map::{FileLoader, RealFileLoader, SourceMap};\n+use syntax::symbol::Symbol;\n+use syntax::{self, ast, attr};\n+#[cfg(not(parallel_compiler))]\n+use std::{thread, panic};\n+\n+pub fn diagnostics_registry() -> Registry {\n+    let mut all_errors = Vec::new();\n+    all_errors.extend_from_slice(&rustc::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_typeck::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n+    // FIXME: need to figure out a way to get these back in here\n+    // all_errors.extend_from_slice(get_codegen_backend(sess).diagnostics());\n+    all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_passes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_plugin::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_mir::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&syntax::DIAGNOSTICS);\n+\n+    Registry::new(&all_errors)\n+}\n+\n+/// Adds `target_feature = \"...\"` cfgs for a variety of platform\n+/// specific features (SSE, NEON etc.).\n+///\n+/// This is performed by checking whether a whitelisted set of\n+/// features is available on the target machine, by querying LLVM.\n+pub fn add_configuration(\n+    cfg: &mut ast::CrateConfig,\n+    sess: &Session,\n+    codegen_backend: &dyn CodegenBackend,\n+) {\n+    let tf = Symbol::intern(\"target_feature\");\n+\n+    cfg.extend(\n+        codegen_backend\n+            .target_features(sess)\n+            .into_iter()\n+            .map(|feat| (tf, Some(feat))),\n+    );\n+\n+    if sess.crt_static_feature() {\n+        cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n+    }\n+}\n+\n+fn load_backend_from_dylib(path: &Path) -> fn() -> Box<dyn CodegenBackend> {\n+    let lib = DynamicLibrary::open(Some(path)).unwrap_or_else(|err| {\n+        let err = format!(\"couldn't load codegen backend {:?}: {:?}\", path, err);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n+    unsafe {\n+        match lib.symbol(\"__rustc_codegen_backend\") {\n+            Ok(f) => {\n+                mem::forget(lib);\n+                mem::transmute::<*mut u8, _>(f)\n+            }\n+            Err(e) => {\n+                let err = format!(\"couldn't load codegen backend as it \\\n+                                   doesn't export the `__rustc_codegen_backend` \\\n+                                   symbol: {:?}\", e);\n+                early_error(ErrorOutputType::default(), &err);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn get_codegen_backend(sess: &Session) -> Box<dyn CodegenBackend> {\n+    static INIT: Once = Once::new();\n+\n+    static mut LOAD: fn() -> Box<dyn CodegenBackend> = || unreachable!();\n+\n+    INIT.call_once(|| {\n+        let codegen_name = sess.opts.debugging_opts.codegen_backend.as_ref()\n+            .unwrap_or(&sess.target.target.options.codegen_backend);\n+        let backend = match &codegen_name[..] {\n+            \"metadata_only\" => {\n+                rustc_codegen_utils::codegen_backend::MetadataOnlyCodegenBackend::boxed\n+            }\n+            filename if filename.contains(\".\") => {\n+                load_backend_from_dylib(filename.as_ref())\n+            }\n+            codegen_name => get_codegen_sysroot(codegen_name),\n+        };\n+\n+        unsafe {\n+            LOAD = backend;\n+        }\n+    });\n+    let backend = unsafe { LOAD() };\n+    backend.init(sess);\n+    backend\n+}\n+\n+pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n+    // For now we only allow this function to be called once as it'll dlopen a\n+    // few things, which seems to work best if we only do that once. In\n+    // general this assertion never trips due to the once guard in `get_codegen_backend`,\n+    // but there's a few manual calls to this function in this file we protect\n+    // against.\n+    static LOADED: AtomicBool = AtomicBool::new(false);\n+    assert!(!LOADED.fetch_or(true, Ordering::SeqCst),\n+            \"cannot load the default codegen backend twice\");\n+\n+    let target = session::config::host_triple();\n+    let mut sysroot_candidates = vec![filesearch::get_or_default_sysroot()];\n+    let path = current_dll_path()\n+        .and_then(|s| s.canonicalize().ok());\n+    if let Some(dll) = path {\n+        // use `parent` twice to chop off the file name and then also the\n+        // directory containing the dll which should be either `lib` or `bin`.\n+        if let Some(path) = dll.parent().and_then(|p| p.parent()) {\n+            // The original `path` pointed at the `rustc_driver` crate's dll.\n+            // Now that dll should only be in one of two locations. The first is\n+            // in the compiler's libdir, for example `$sysroot/lib/*.dll`. The\n+            // other is the target's libdir, for example\n+            // `$sysroot/lib/rustlib/$target/lib/*.dll`.\n+            //\n+            // We don't know which, so let's assume that if our `path` above\n+            // ends in `$target` we *could* be in the target libdir, and always\n+            // assume that we may be in the main libdir.\n+            sysroot_candidates.push(path.to_owned());\n+\n+            if path.ends_with(target) {\n+                sysroot_candidates.extend(path.parent() // chop off `$target`\n+                    .and_then(|p| p.parent())           // chop off `rustlib`\n+                    .and_then(|p| p.parent())           // chop off `lib`\n+                    .map(|s| s.to_owned()));\n+            }\n+        }\n+    }\n+\n+    let sysroot = sysroot_candidates.iter()\n+        .map(|sysroot| {\n+            let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n+            sysroot.join(libdir).with_file_name(\n+                option_env!(\"CFG_CODEGEN_BACKENDS_DIR\").unwrap_or(\"codegen-backends\"))\n+        })\n+        .filter(|f| {\n+            info!(\"codegen backend candidate: {}\", f.display());\n+            f.exists()\n+        })\n+        .next();\n+    let sysroot = sysroot.unwrap_or_else(|| {\n+        let candidates = sysroot_candidates.iter()\n+            .map(|p| p.display().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n* \");\n+        let err = format!(\"failed to find a `codegen-backends` folder \\\n+                           in the sysroot candidates:\\n* {}\", candidates);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n+    info!(\"probing {} for a codegen backend\", sysroot.display());\n+\n+    let d = sysroot.read_dir().unwrap_or_else(|e| {\n+        let err = format!(\"failed to load default codegen backend, couldn't \\\n+                           read `{}`: {}\", sysroot.display(), e);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n+\n+    let mut file: Option<PathBuf> = None;\n+\n+    let expected_name = format!(\"rustc_codegen_llvm-{}\", backend_name);\n+    for entry in d.filter_map(|e| e.ok()) {\n+        let path = entry.path();\n+        let filename = match path.file_name().and_then(|s| s.to_str()) {\n+            Some(s) => s,\n+            None => continue,\n+        };\n+        if !(filename.starts_with(DLL_PREFIX) && filename.ends_with(DLL_SUFFIX)) {\n+            continue\n+        }\n+        let name = &filename[DLL_PREFIX.len() .. filename.len() - DLL_SUFFIX.len()];\n+        if name != expected_name {\n+            continue\n+        }\n+        if let Some(ref prev) = file {\n+            let err = format!(\"duplicate codegen backends found\\n\\\n+                               first:  {}\\n\\\n+                               second: {}\\n\\\n+            \", prev.display(), path.display());\n+            early_error(ErrorOutputType::default(), &err);\n+        }\n+        file = Some(path.clone());\n+    }\n+\n+    match file {\n+        Some(ref s) => return load_backend_from_dylib(s),\n+        None => {\n+            let err = format!(\"failed to load default codegen backend for `{}`, \\\n+                               no appropriate codegen dylib found in `{}`\",\n+                              backend_name, sysroot.display());\n+            early_error(ErrorOutputType::default(), &err);\n+        }\n+    }\n+\n+    #[cfg(unix)]\n+    fn current_dll_path() -> Option<PathBuf> {\n+        use std::ffi::{OsStr, CStr};\n+        use std::os::unix::prelude::*;\n+\n+        unsafe {\n+            let addr = current_dll_path as usize as *mut _;\n+            let mut info = mem::zeroed();\n+            if libc::dladdr(addr, &mut info) == 0 {\n+                info!(\"dladdr failed\");\n+                return None\n+            }\n+            if info.dli_fname.is_null() {\n+                info!(\"dladdr returned null pointer\");\n+                return None\n+            }\n+            let bytes = CStr::from_ptr(info.dli_fname).to_bytes();\n+            let os = OsStr::from_bytes(bytes);\n+            Some(PathBuf::from(os))\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    fn current_dll_path() -> Option<PathBuf> {\n+        use std::ffi::OsString;\n+        use std::os::windows::prelude::*;\n+\n+        extern \"system\" {\n+            fn GetModuleHandleExW(dwFlags: u32,\n+                                  lpModuleName: usize,\n+                                  phModule: *mut usize) -> i32;\n+            fn GetModuleFileNameW(hModule: usize,\n+                                  lpFilename: *mut u16,\n+                                  nSize: u32) -> u32;\n+        }\n+\n+        const GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS: u32 = 0x00000004;\n+\n+        unsafe {\n+            let mut module = 0;\n+            let r = GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n+                                       current_dll_path as usize,\n+                                       &mut module);\n+            if r == 0 {\n+                info!(\"GetModuleHandleExW failed: {}\", io::Error::last_os_error());\n+                return None\n+            }\n+            let mut space = Vec::with_capacity(1024);\n+            let r = GetModuleFileNameW(module,\n+                                       space.as_mut_ptr(),\n+                                       space.capacity() as u32);\n+            if r == 0 {\n+                info!(\"GetModuleFileNameW failed: {}\", io::Error::last_os_error());\n+                return None\n+            }\n+            let r = r as usize;\n+            if r >= space.capacity() {\n+                info!(\"our buffer was too small? {}\",\n+                      io::Error::last_os_error());\n+                return None\n+            }\n+            space.set_len(r);\n+            let os = OsString::from_wide(&space);\n+            Some(PathBuf::from(os))\n+        }\n+    }\n+}\n+\n+pub fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguator {\n+    use std::hash::Hasher;\n+\n+    // The crate_disambiguator is a 128 bit hash. The disambiguator is fed\n+    // into various other hashes quite a bit (symbol hashes, incr. comp. hashes,\n+    // debuginfo type IDs, etc), so we don't want it to be too wide. 128 bits\n+    // should still be safe enough to avoid collisions in practice.\n+    let mut hasher = StableHasher::<Fingerprint>::new();\n+\n+    let mut metadata = session.opts.cg.metadata.clone();\n+    // We don't want the crate_disambiguator to dependent on the order\n+    // -C metadata arguments, so sort them:\n+    metadata.sort();\n+    // Every distinct -C metadata value is only incorporated once:\n+    metadata.dedup();\n+\n+    hasher.write(b\"metadata\");\n+    for s in &metadata {\n+        // Also incorporate the length of a metadata string, so that we generate\n+        // different values for `-Cmetadata=ab -Cmetadata=c` and\n+        // `-Cmetadata=a -Cmetadata=bc`\n+        hasher.write_usize(s.len());\n+        hasher.write(s.as_bytes());\n+    }\n+\n+    // Also incorporate crate type, so that we don't get symbol conflicts when\n+    // linking against a library of the same name, if this is an executable.\n+    let is_exe = session\n+        .crate_types\n+        .borrow()\n+        .contains(&config::CrateType::Executable);\n+    hasher.write(if is_exe { b\"exe\" } else { b\"lib\" });\n+\n+    CrateDisambiguator::from(hasher.finish())\n+}\n+\n+pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n+    // Unconditionally collect crate types from attributes to make them used\n+    let attr_types: Vec<config::CrateType> = attrs\n+        .iter()\n+        .filter_map(|a| {\n+            if a.check_name(\"crate_type\") {\n+                match a.value_str() {\n+                    Some(ref n) if *n == \"rlib\" => Some(config::CrateType::Rlib),\n+                    Some(ref n) if *n == \"dylib\" => Some(config::CrateType::Dylib),\n+                    Some(ref n) if *n == \"cdylib\" => Some(config::CrateType::Cdylib),\n+                    Some(ref n) if *n == \"lib\" => Some(config::default_lib_output()),\n+                    Some(ref n) if *n == \"staticlib\" => Some(config::CrateType::Staticlib),\n+                    Some(ref n) if *n == \"proc-macro\" => Some(config::CrateType::ProcMacro),\n+                    Some(ref n) if *n == \"bin\" => Some(config::CrateType::Executable),\n+                    Some(ref n) => {\n+                        let crate_types = vec![\n+                            Symbol::intern(\"rlib\"),\n+                            Symbol::intern(\"dylib\"),\n+                            Symbol::intern(\"cdylib\"),\n+                            Symbol::intern(\"lib\"),\n+                            Symbol::intern(\"staticlib\"),\n+                            Symbol::intern(\"proc-macro\"),\n+                            Symbol::intern(\"bin\")\n+                        ];\n+\n+                        if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().node {\n+                            let span = spanned.span;\n+                            let lev_candidate = find_best_match_for_name(\n+                                crate_types.iter(),\n+                                &n.as_str(),\n+                                None\n+                            );\n+                            if let Some(candidate) = lev_candidate {\n+                                session.buffer_lint_with_diagnostic(\n+                                    lint::builtin::UNKNOWN_CRATE_TYPES,\n+                                    ast::CRATE_NODE_ID,\n+                                    span,\n+                                    \"invalid `crate_type` value\",\n+                                    lint::builtin::BuiltinLintDiagnostics::\n+                                        UnknownCrateTypes(\n+                                            span,\n+                                            \"did you mean\".to_string(),\n+                                            format!(\"\\\"{}\\\"\", candidate)\n+                                        )\n+                                );\n+                            } else {\n+                                session.buffer_lint(\n+                                    lint::builtin::UNKNOWN_CRATE_TYPES,\n+                                    ast::CRATE_NODE_ID,\n+                                    span,\n+                                    \"invalid `crate_type` value\"\n+                                );\n+                            }\n+                        }\n+                        None\n+                    }\n+                    None => None\n+                }\n+            } else {\n+                None\n+            }\n+        })\n+        .collect();\n+\n+    // If we're generating a test executable, then ignore all other output\n+    // styles at all other locations\n+    if session.opts.test {\n+        return vec![config::CrateType::Executable];\n+    }\n+\n+    // Only check command line flags if present. If no types are specified by\n+    // command line, then reuse the empty `base` Vec to hold the types that\n+    // will be found in crate attributes.\n+    let mut base = session.opts.crate_types.clone();\n+    if base.is_empty() {\n+        base.extend(attr_types);\n+        if base.is_empty() {\n+            base.push(::rustc_codegen_utils::link::default_output_for_target(\n+                session,\n+            ));\n+        } else {\n+            base.sort();\n+            base.dedup();\n+        }\n+    }\n+\n+    base.retain(|crate_type| {\n+        let res = !::rustc_codegen_utils::link::invalid_output_for_target(session, *crate_type);\n+\n+        if !res {\n+            session.warn(&format!(\n+                \"dropping unsupported crate type `{}` for target `{}`\",\n+                *crate_type, session.opts.target_triple\n+            ));\n+        }\n+\n+        res\n+    });\n+\n+    base\n+}\n+\n+pub fn build_output_filenames(\n+    input: &Input,\n+    odir: &Option<PathBuf>,\n+    ofile: &Option<PathBuf>,\n+    attrs: &[ast::Attribute],\n+    sess: &Session,\n+) -> OutputFilenames {\n+    match *ofile {\n+        None => {\n+            // \"-\" as input file will cause the parser to read from stdin so we\n+            // have to make up a name\n+            // We want to toss everything after the final '.'\n+            let dirpath = (*odir).as_ref().cloned().unwrap_or_default();\n+\n+            // If a crate name is present, we use it as the link name\n+            let stem = sess.opts\n+                .crate_name\n+                .clone()\n+                .or_else(|| attr::find_crate_name(attrs).map(|n| n.to_string()))\n+                .unwrap_or_else(|| input.filestem().to_owned());\n+\n+            OutputFilenames {\n+                out_directory: dirpath,\n+                out_filestem: stem,\n+                single_output_file: None,\n+                extra: sess.opts.cg.extra_filename.clone(),\n+                outputs: sess.opts.output_types.clone(),\n+            }\n+        }\n+\n+        Some(ref out_file) => {\n+            let unnamed_output_types = sess.opts\n+                .output_types\n+                .values()\n+                .filter(|a| a.is_none())\n+                .count();\n+            let ofile = if unnamed_output_types > 1 {\n+                sess.warn(\n+                    \"due to multiple output types requested, the explicitly specified \\\n+                     output file name will be adapted for each output type\",\n+                );\n+                None\n+            } else {\n+                Some(out_file.clone())\n+            };\n+            if *odir != None {\n+                sess.warn(\"ignoring --out-dir flag due to -o flag\");\n+            }\n+            if !sess.opts.cg.extra_filename.is_empty() {\n+                sess.warn(\"ignoring -C extra-filename flag due to -o flag\");\n+            }\n+\n+            OutputFilenames {\n+                out_directory: out_file.parent().unwrap_or_else(|| Path::new(\"\")).to_path_buf(),\n+                out_filestem: out_file\n+                    .file_stem()\n+                    .unwrap_or_default()\n+                    .to_str()\n+                    .unwrap()\n+                    .to_string(),\n+                single_output_file: ofile,\n+                extra: sess.opts.cg.extra_filename.clone(),\n+                outputs: sess.opts.output_types.clone(),\n+            }\n+        }\n+    }\n+}\n+\n+// Note: Also used by librustdoc, see PR #43348. Consider moving this struct elsewhere.\n+//\n+// FIXME: Currently the `everybody_loops` transformation is not applied to:\n+//  * `const fn`, due to issue #43636 that `loop` is not supported for const evaluation. We are\n+//    waiting for miri to fix that.\n+//  * `impl Trait`, due to issue #43869 that functions returning impl Trait cannot be diverging.\n+//    Solving this may require `!` to implement every trait, which relies on the an even more\n+//    ambitious form of the closed RFC #1637. See also [#34511].\n+//\n+// [#34511]: https://github.com/rust-lang/rust/issues/34511#issuecomment-322340401\n+pub struct ReplaceBodyWithLoop<'a> {\n+    within_static_or_const: bool,\n+    nested_blocks: Option<Vec<ast::Block>>,\n+    sess: &'a Session,\n+}\n+\n+impl<'a> ReplaceBodyWithLoop<'a> {\n+    pub fn new(sess: &'a Session) -> ReplaceBodyWithLoop<'a> {\n+        ReplaceBodyWithLoop {\n+            within_static_or_const: false,\n+            nested_blocks: None,\n+            sess\n+        }\n+    }\n+\n+    fn run<R, F: FnOnce(&mut Self) -> R>(&mut self, is_const: bool, action: F) -> R {\n+        let old_const = mem::replace(&mut self.within_static_or_const, is_const);\n+        let old_blocks = self.nested_blocks.take();\n+        let ret = action(self);\n+        self.within_static_or_const = old_const;\n+        self.nested_blocks = old_blocks;\n+        ret\n+    }\n+\n+    fn should_ignore_fn(ret_ty: &ast::FnDecl) -> bool {\n+        if let ast::FunctionRetTy::Ty(ref ty) = ret_ty.output {\n+            fn involves_impl_trait(ty: &ast::Ty) -> bool {\n+                match ty.node {\n+                    ast::TyKind::ImplTrait(..) => true,\n+                    ast::TyKind::Slice(ref subty) |\n+                    ast::TyKind::Array(ref subty, _) |\n+                    ast::TyKind::Ptr(ast::MutTy { ty: ref subty, .. }) |\n+                    ast::TyKind::Rptr(_, ast::MutTy { ty: ref subty, .. }) |\n+                    ast::TyKind::Paren(ref subty) => involves_impl_trait(subty),\n+                    ast::TyKind::Tup(ref tys) => any_involves_impl_trait(tys.iter()),\n+                    ast::TyKind::Path(_, ref path) => path.segments.iter().any(|seg| {\n+                        match seg.args.as_ref().map(|generic_arg| &**generic_arg) {\n+                            None => false,\n+                            Some(&ast::GenericArgs::AngleBracketed(ref data)) => {\n+                                let types = data.args.iter().filter_map(|arg| match arg {\n+                                    ast::GenericArg::Type(ty) => Some(ty),\n+                                    _ => None,\n+                                });\n+                                any_involves_impl_trait(types.into_iter()) ||\n+                                any_involves_impl_trait(data.bindings.iter().map(|b| &b.ty))\n+                            },\n+                            Some(&ast::GenericArgs::Parenthesized(ref data)) => {\n+                                any_involves_impl_trait(data.inputs.iter()) ||\n+                                any_involves_impl_trait(data.output.iter())\n+                            }\n+                        }\n+                    }),\n+                    _ => false,\n+                }\n+            }\n+\n+            fn any_involves_impl_trait<'a, I: Iterator<Item = &'a P<ast::Ty>>>(mut it: I) -> bool {\n+                it.any(|subty| involves_impl_trait(subty))\n+            }\n+\n+            involves_impl_trait(ty)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n+    fn visit_item_kind(&mut self, i: &mut ast::ItemKind) {\n+        let is_const = match i {\n+            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => true,\n+            ast::ItemKind::Fn(ref decl, ref header, _, _) =>\n+                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n+            _ => false,\n+        };\n+        self.run(is_const, |s| noop_visit_item_kind(i, s))\n+    }\n+\n+    fn flat_map_trait_item(&mut self, i: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n+        let is_const = match i.node {\n+            ast::TraitItemKind::Const(..) => true,\n+            ast::TraitItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n+                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n+            _ => false,\n+        };\n+        self.run(is_const, |s| noop_flat_map_trait_item(i, s))\n+    }\n+\n+    fn flat_map_impl_item(&mut self, i: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n+        let is_const = match i.node {\n+            ast::ImplItemKind::Const(..) => true,\n+            ast::ImplItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n+                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n+            _ => false,\n+        };\n+        self.run(is_const, |s| noop_flat_map_impl_item(i, s))\n+    }\n+\n+    fn visit_anon_const(&mut self, c: &mut ast::AnonConst) {\n+        self.run(true, |s| noop_visit_anon_const(c, s))\n+    }\n+\n+    fn visit_block(&mut self, b: &mut P<ast::Block>) {\n+        fn stmt_to_block(rules: ast::BlockCheckMode,\n+                         s: Option<ast::Stmt>,\n+                         sess: &Session) -> ast::Block {\n+            ast::Block {\n+                stmts: s.into_iter().collect(),\n+                rules,\n+                id: sess.next_node_id(),\n+                span: syntax_pos::DUMMY_SP,\n+            }\n+        }\n+\n+        fn block_to_stmt(b: ast::Block, sess: &Session) -> ast::Stmt {\n+            let expr = P(ast::Expr {\n+                id: sess.next_node_id(),\n+                node: ast::ExprKind::Block(P(b), None),\n+                span: syntax_pos::DUMMY_SP,\n+                attrs: ThinVec::new(),\n+            });\n+\n+            ast::Stmt {\n+                id: sess.next_node_id(),\n+                node: ast::StmtKind::Expr(expr),\n+                span: syntax_pos::DUMMY_SP,\n+            }\n+        }\n+\n+        let empty_block = stmt_to_block(BlockCheckMode::Default, None, self.sess);\n+        let loop_expr = P(ast::Expr {\n+            node: ast::ExprKind::Loop(P(empty_block), None),\n+            id: self.sess.next_node_id(),\n+            span: syntax_pos::DUMMY_SP,\n+                attrs: ThinVec::new(),\n+        });\n+\n+        let loop_stmt = ast::Stmt {\n+            id: self.sess.next_node_id(),\n+            span: syntax_pos::DUMMY_SP,\n+            node: ast::StmtKind::Expr(loop_expr),\n+        };\n+\n+        if self.within_static_or_const {\n+            noop_visit_block(b, self)\n+        } else {\n+            visit_clobber(b.deref_mut(), |b| {\n+                let mut stmts = vec![];\n+                for s in b.stmts {\n+                    let old_blocks = self.nested_blocks.replace(vec![]);\n+\n+                    stmts.extend(self.flat_map_stmt(s).into_iter().filter(|s| s.is_item()));\n+\n+                    // we put a Some in there earlier with that replace(), so this is valid\n+                    let new_blocks = self.nested_blocks.take().unwrap();\n+                    self.nested_blocks = old_blocks;\n+                    stmts.extend(new_blocks.into_iter().map(|b| block_to_stmt(b, &self.sess)));\n+                }\n+\n+                let mut new_block = ast::Block {\n+                    stmts,\n+                    ..b\n+                };\n+\n+                if let Some(old_blocks) = self.nested_blocks.as_mut() {\n+                    //push our fresh block onto the cache and yield an empty block with `loop {}`\n+                    if !new_block.stmts.is_empty() {\n+                        old_blocks.push(new_block);\n+                    }\n+\n+                    stmt_to_block(b.rules, Some(loop_stmt), self.sess)\n+                } else {\n+                    //push `loop {}` onto the end of our fresh block and yield that\n+                    new_block.stmts.push(loop_stmt);\n+\n+                    new_block\n+                }\n+            })\n+        }\n+    }\n+\n+    // in general the pretty printer processes unexpanded code, so\n+    // we override the default `visit_mac` method which panics.\n+    fn visit_mac(&mut self, mac: &mut ast::Mac) {\n+        noop_visit_mac(mac, self)\n+    }\n+}"}, {"sha": "5769ab253123276c51f2bb65231823c8bd72ae39", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -131,7 +131,7 @@ use std::ops::{self, Deref};\n use std::slice;\n \n use crate::require_c_abi_if_c_variadic;\n-use crate::session::{CompileIncomplete, Session};\n+use crate::session::Session;\n use crate::session::config::EntryFnType;\n use crate::TypeAndSubsts;\n use crate::lint;\n@@ -711,12 +711,12 @@ fn check_mod_item_types<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId)\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckItemTypesVisitor { tcx });\n }\n \n-pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), CompileIncomplete> {\n+pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), ErrorReported> {\n     tcx.typeck_item_bodies(LOCAL_CRATE)\n }\n \n fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n-                                -> Result<(), CompileIncomplete>\n+                                -> Result<(), ErrorReported>\n {\n     debug_assert!(crate_num == LOCAL_CRATE);\n     Ok(tcx.sess.track_errors(|| {"}, {"sha": "00c2ab792869d3ee1bebc97ef2b7c1d2e394617d", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -102,7 +102,7 @@ use rustc::infer::InferOk;\n use rustc::lint;\n use rustc::middle;\n use rustc::session;\n-use rustc::session::CompileIncomplete;\n+use rustc::util::common::ErrorReported;\n use rustc::session::config::{EntryFnType, nightly_options};\n use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n use rustc::ty::subst::SubstsRef;\n@@ -315,7 +315,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                             -> Result<(), CompileIncomplete>\n+                             -> Result<(), ErrorReported>\n {\n     tcx.sess.profiler(|p| p.start_activity(ProfileCategory::TypeChecking));\n \n@@ -324,7 +324,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     tcx.sess.track_errors(|| {\n         time(tcx.sess, \"type collecting\", ||\n              collect::collect_item_types(tcx));\n-\n     })?;\n \n     if tcx.features().rustc_attrs {\n@@ -362,7 +361,11 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n     tcx.sess.profiler(|p| p.end_activity(ProfileCategory::TypeChecking));\n \n-    tcx.sess.compile_status()\n+    if tcx.sess.err_count() == 0 {\n+        Ok(())\n+    } else {\n+        Err(ErrorReported)\n+    }\n }\n \n /// A quasi-deprecated helper used in rustdoc and save-analysis to get"}, {"sha": "fdb071638b7993245b7dc66bb6a9097fac1d7a13", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -1,5 +1,5 @@\n use rustc_lint;\n-use rustc_driver::{self, driver, target_features, abort_on_err};\n+use rustc_driver::{driver, abort_on_err};\n use rustc::session::{self, config};\n use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CrateNum, LOCAL_CRATE};\n use rustc::hir::def::Def;\n@@ -11,6 +11,7 @@ use rustc::hir::map as hir_map;\n use rustc::lint::{self, LintPass};\n use rustc::session::config::ErrorOutputType;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_interface::util;\n use rustc_resolve as resolve;\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n@@ -402,7 +403,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                                              debugging_options.ui_testing);\n \n         let mut sess = session::build_session_(\n-            sessopts, cpath, diagnostic_handler, source_map,\n+            sessopts, cpath, diagnostic_handler, source_map, Default::default(),\n         );\n \n         lint::builtin::HardwiredLints.get_lints()\n@@ -422,12 +423,12 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                                                                       lint::Allow);\n                                      });\n \n-        let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n+        let codegen_backend = util::get_codegen_backend(&sess);\n         let cstore = Rc::new(CStore::new(codegen_backend.metadata_loader()));\n         rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n         let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));\n-        target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n+        util::add_configuration(&mut cfg, &sess, &*codegen_backend);\n         sess.parse_sess.config = cfg;\n \n         let control = &driver::CompileController::basic();\n@@ -481,23 +482,23 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n         let mut arenas = AllArenas::new();\n         let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n-        let output_filenames = driver::build_output_filenames(&input,\n+        let output_filenames = util::build_output_filenames(&input,\n                                                             &None,\n                                                             &None,\n                                                             &[],\n                                                             &sess);\n \n         let resolver = RefCell::new(resolver);\n-        abort_on_err(driver::phase_3_run_analysis_passes(&*codegen_backend,\n-                                                        control,\n-                                                        &sess,\n-                                                        &*cstore,\n-                                                        hir_map,\n-                                                        resolutions,\n-                                                        &mut arenas,\n-                                                        &name,\n-                                                        &output_filenames,\n-                                                        |tcx, _, result| {\n+        driver::phase_3_run_analysis_passes(&*codegen_backend,\n+                                            control,\n+                                            &sess,\n+                                            &*cstore,\n+                                            hir_map,\n+                                            resolutions,\n+                                            &mut arenas,\n+                                            &name,\n+                                            &output_filenames,\n+                                            |tcx, _, result| {\n             if result.is_err() {\n                 sess.fatal(\"Compilation failed, aborting rustdoc\");\n             }\n@@ -615,6 +616,6 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             ctxt.sess().abort_if_errors();\n \n             (krate, ctxt.renderinfo.into_inner(), render_options, passes)\n-        }), &sess)\n+        })\n     })\n }"}, {"sha": "b3807d750b6eae2416cb50ca916d6686c4435ca5", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -30,6 +30,7 @@ extern crate rustc_lint;\n extern crate rustc_metadata;\n extern crate rustc_target;\n extern crate rustc_typeck;\n+extern crate rustc_interface;\n extern crate serialize;\n extern crate syntax;\n extern crate syntax_pos;"}, {"sha": "c3c0875bc7d248cbcfa5cde7f9f03ecfa3f39029", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -2,9 +2,10 @@ use errors::{self, FatalError};\n use errors::emitter::ColorConfig;\n use rustc_data_structures::sync::Lrc;\n use rustc_lint;\n-use rustc_driver::{self, driver, target_features, Compilation};\n+use rustc_driver::{self, driver, Compilation};\n use rustc_driver::driver::phase_2_configure_and_expand;\n use rustc_metadata::cstore::CStore;\n+use rustc_interface::util;\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::session::{self, CompileIncomplete, config};\n@@ -70,15 +71,15 @@ pub fn run(mut options: Options) -> isize {\n                                             Some(source_map.clone()));\n \n         let mut sess = session::build_session_(\n-            sessopts, Some(options.input), handler, source_map.clone(),\n+            sessopts, Some(options.input), handler, source_map.clone(), Default::default(),\n         );\n-        let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n+        let codegen_backend = util::get_codegen_backend(&sess);\n         let cstore = CStore::new(codegen_backend.metadata_loader());\n         rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n         let mut cfg = config::build_configuration(&sess,\n                                                   config::parse_cfgspecs(options.cfgs.clone()));\n-        target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n+        util::add_configuration(&mut cfg, &sess, &*codegen_backend);\n         sess.parse_sess.config = cfg;\n \n         let krate =\n@@ -274,9 +275,9 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n         let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n         let mut sess = session::build_session_(\n-            sessopts, None, diagnostic_handler, source_map,\n+            sessopts, None, diagnostic_handler, source_map, Default::default(),\n         );\n-        let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n+        let codegen_backend = util::get_codegen_backend(&sess);\n         let cstore = CStore::new(codegen_backend.metadata_loader());\n         rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n@@ -305,7 +306,7 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n         let mut control = driver::CompileController::basic();\n \n         let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n-        target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n+        util::add_configuration(&mut cfg, &sess, &*codegen_backend);\n         sess.parse_sess.config = cfg;\n \n         let out = Some(outdir.lock().unwrap().path().join(\"rust_out\"));"}, {"sha": "e9d825df2a46ec9834971dc6b44c7e953261140a", "filename": "src/test/run-make-fulldeps/issue-19371/foo.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -6,6 +6,7 @@ extern crate rustc_lint;\n extern crate rustc_metadata;\n extern crate rustc_errors;\n extern crate rustc_codegen_utils;\n+extern crate rustc_interface;\n extern crate syntax;\n \n use rustc::session::{build_session, Session};\n@@ -14,6 +15,7 @@ use rustc::session::config::{Input, Options,\n use rustc_driver::driver::{self, compile_input, CompileController};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n+use rustc_interface::util;\n use syntax::source_map::FileName;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n@@ -45,7 +47,7 @@ fn main() {\n fn basic_sess(opts: Options) -> (Session, Rc<CStore>, Box<CodegenBackend>) {\n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let sess = build_session(opts, None, descriptions);\n-    let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n+    let codegen_backend = util::get_codegen_backend(&sess);\n     let cstore = Rc::new(CStore::new(codegen_backend.metadata_loader()));\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     (sess, cstore, codegen_backend)"}, {"sha": "895c40e4cab2621741cf32f225230fb8b430820a", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -12,7 +12,7 @@ error[E0425]: cannot find value `no` in this scope\n 3 | no\n   | ^^ not found in this scope\n \n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:351:13\n+thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:352:13\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n ---- $DIR/failed-doctest-output.rs - SomeStruct (line 11) stdout ----\n@@ -21,7 +21,7 @@ thread '$DIR/failed-doctest-output.rs - SomeStruct (line 11)' panicked at 'test\n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n-', src/librustdoc/test.rs:372:17\n+', src/librustdoc/test.rs:373:17\n \n \n failures:"}, {"sha": "b3ca736622a2ad662501bdb87026f6a6297d848f", "filename": "src/test/ui/issues/issue-23302-3.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/350674b7180a41c8e508d93c6ab8e203b69d3df7/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr?ref=350674b7180a41c8e508d93c6ab8e203b69d3df7", "patch": "@@ -20,6 +20,7 @@ note: ...which requires checking which parts of `B` are promotable to static...\n LL | const B: i32 = A;\n    |                ^\n    = note: ...which again requires const checking if rvalue is promotable to static `A`, completing the cycle\n+   = note: cycle used when running analysis passes on this crate\n \n error: aborting due to previous error\n "}]}