{"sha": "3fcf43bb0f3e86c16a88f239da18a1729a94d244", "node_id": "C_kwDOAAsO6NoAKDNmY2Y0M2JiMGYzZTg2YzE2YTg4ZjIzOWRhMThhMTcyOWE5NGQyNDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-29T15:05:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-29T15:05:29Z"}, "message": "Auto merge of #98669 - Dylan-DPC:rollup-8uzhcip, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #98415 (Migrate some `rustc_borrowck` diagnostics to `SessionDiagnostic`)\n - #98479 (Add `fetch_not` method on `AtomicBool`)\n - #98499 (Erase regions in New Abstract Consts)\n - #98516 (library: fix uefi va_list type definition)\n - #98554 (Fix box with custom allocator in miri)\n - #98607 (Clean up arg mismatch diagnostic, generalize tuple wrap suggestion)\n - #98625 (emit Retag for compound types with reference fields)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "17006f074d35aff9787abc12ac80094d53a436b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17006f074d35aff9787abc12ac80094d53a436b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fcf43bb0f3e86c16a88f239da18a1729a94d244", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fcf43bb0f3e86c16a88f239da18a1729a94d244", "html_url": "https://github.com/rust-lang/rust/commit/3fcf43bb0f3e86c16a88f239da18a1729a94d244", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fcf43bb0f3e86c16a88f239da18a1729a94d244/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66c83ffca1512ed76f9445ec7f7280f768ef71c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/66c83ffca1512ed76f9445ec7f7280f768ef71c4", "html_url": "https://github.com/rust-lang/rust/commit/66c83ffca1512ed76f9445ec7f7280f768ef71c4"}, {"sha": "68228be56062eb62f09088663e93ea66109156f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/68228be56062eb62f09088663e93ea66109156f8", "html_url": "https://github.com/rust-lang/rust/commit/68228be56062eb62f09088663e93ea66109156f8"}], "stats": {"total": 782, "additions": 511, "deletions": 271}, "files": [{"sha": "c0905982467dffd45bb99232a0596a219255fb16", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -3595,6 +3595,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_lexer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_mir_dataflow\",\n  \"rustc_serialize\","}, {"sha": "fbf628e865e2c8bc52331cf6a413cfdcfbeddf3a", "filename": "compiler/rustc_borrowck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2FCargo.toml?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -19,6 +19,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_const_eval = { path = \"../rustc_const_eval\" }\n rustc_mir_dataflow = { path = \"../rustc_mir_dataflow\" }"}, {"sha": "1ef2b0ae98843b3edd575b71783fd86a7f0e8b14", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -19,6 +19,9 @@ use std::fmt;\n use std::rc::Rc;\n \n use crate::region_infer::values::RegionElement;\n+use crate::session_diagnostics::HigherRankedErrorCause;\n+use crate::session_diagnostics::HigherRankedLifetimeError;\n+use crate::session_diagnostics::HigherRankedSubtypeError;\n use crate::MirBorrowckCtxt;\n \n #[derive(Clone)]\n@@ -69,7 +72,7 @@ impl<'tcx> UniverseInfo<'tcx> {\n                 // up in the existing UI tests. Consider investigating this\n                 // some more.\n                 mbcx.buffer_error(\n-                    mbcx.infcx.tcx.sess.struct_span_err(cause.span, \"higher-ranked subtype error\"),\n+                    mbcx.infcx.tcx.sess.create_err(HigherRankedSubtypeError { span: cause.span }),\n                 );\n             }\n         }\n@@ -216,9 +219,12 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = tcx.sess.struct_span_err(span, \"higher-ranked lifetime error\");\n-        err.note(&format!(\"could not prove {}\", self.canonical_query.value.value.predicate));\n-        err\n+        tcx.sess.create_err(HigherRankedLifetimeError {\n+            cause: Some(HigherRankedErrorCause::CouldNotProve {\n+                predicate: self.canonical_query.value.value.predicate.to_string(),\n+            }),\n+            span,\n+        })\n     }\n \n     fn base_universe(&self) -> ty::UniverseIndex {\n@@ -263,9 +269,12 @@ where\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = tcx.sess.struct_span_err(span, \"higher-ranked lifetime error\");\n-        err.note(&format!(\"could not normalize `{}`\", self.canonical_query.value.value.value));\n-        err\n+        tcx.sess.create_err(HigherRankedLifetimeError {\n+            cause: Some(HigherRankedErrorCause::CouldNotNormalize {\n+                value: self.canonical_query.value.value.value.to_string(),\n+            }),\n+            span,\n+        })\n     }\n \n     fn base_universe(&self) -> ty::UniverseIndex {\n@@ -326,7 +335,7 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         // FIXME: This error message isn't great, but it doesn't show up in the existing UI tests,\n         // and is only the fallback when the nice error fails. Consider improving this some more.\n-        tcx.sess.struct_span_err(span, \"higher-ranked lifetime error\")\n+        tcx.sess.create_err(HigherRankedLifetimeError { cause: None, span })\n     }\n \n     fn base_universe(&self) -> ty::UniverseIndex {\n@@ -366,7 +375,7 @@ impl<'tcx> TypeOpInfo<'tcx> for crate::type_check::InstantiateOpaqueType<'tcx> {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         // FIXME: This error message isn't great, but it doesn't show up in the existing UI tests,\n         // and is only the fallback when the nice error fails. Consider improving this some more.\n-        tcx.sess.struct_span_err(span, \"higher-ranked lifetime error for opaque type!\")\n+        tcx.sess.create_err(HigherRankedLifetimeError { cause: None, span })\n     }\n \n     fn base_universe(&self) -> ty::UniverseIndex {"}, {"sha": "5d3997289bb333ec6f7b8b55b0f42e45eb6ca68f", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -24,6 +24,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n use crate::borrowck_errors;\n+use crate::session_diagnostics::GenericDoesNotLiveLongEnough;\n \n use super::{OutlivesSuggestionBuilder, RegionName};\n use crate::region_infer::BlameConstraint;\n@@ -196,9 +197,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // to report it; we could probably handle it by\n                         // iterating over the universal regions and reporting\n                         // an error that multiple bounds are required.\n-                        self.buffer_error(self.infcx.tcx.sess.struct_span_err(\n-                            type_test_span,\n-                            &format!(\"`{}` does not live long enough\", type_test.generic_kind),\n+                        self.buffer_error(self.infcx.tcx.sess.create_err(\n+                            GenericDoesNotLiveLongEnough {\n+                                kind: type_test.generic_kind.to_string(),\n+                                span: type_test_span,\n+                            },\n                         ));\n                     }\n                 }"}, {"sha": "7d6f37340c2bb06218aa855cb451ddc3998bda5e", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -76,6 +76,7 @@ mod places_conflict;\n mod prefixes;\n mod region_infer;\n mod renumber;\n+mod session_diagnostics;\n mod type_check;\n mod universal_regions;\n mod used_muts;"}, {"sha": "895723d44ff1b474b88468b9d4b365e8abafaf5b", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -0,0 +1,44 @@\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_middle::ty::Ty;\n+use rustc_span::Span;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(borrowck::move_unsized, code = \"E0161\")]\n+pub(crate) struct MoveUnsized<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(borrowck::higher_ranked_lifetime_error)]\n+pub(crate) struct HigherRankedLifetimeError {\n+    #[subdiagnostic]\n+    pub cause: Option<HigherRankedErrorCause>,\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum HigherRankedErrorCause {\n+    #[note(borrowck::could_not_prove)]\n+    CouldNotProve { predicate: String },\n+    #[note(borrowck::could_not_normalize)]\n+    CouldNotNormalize { value: String },\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(borrowck::higher_ranked_subtype_error)]\n+pub(crate) struct HigherRankedSubtypeError {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(borrowck::generic_does_not_live_long_enough)]\n+pub(crate) struct GenericDoesNotLiveLongEnough {\n+    pub kind: String,\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "5ee1f5a8e8e37f414e05a2d5dde65febdbcc21ee", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -9,7 +9,6 @@ use hir::OpaqueTyOrigin;\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::vec_map::VecMap;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n@@ -48,6 +47,7 @@ use rustc_mir_dataflow::impls::MaybeInitializedPlaces;\n use rustc_mir_dataflow::move_paths::MoveData;\n use rustc_mir_dataflow::ResultsCursor;\n \n+use crate::session_diagnostics::MoveUnsized;\n use crate::{\n     borrow_set::BorrowSet,\n     constraints::{OutlivesConstraint, OutlivesConstraintSet},\n@@ -1780,19 +1780,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             // slot or local, so to find all unsized rvalues it is enough\n             // to check all temps, return slots and locals.\n             if self.reported_errors.replace((ty, span)).is_none() {\n-                let mut diag = struct_span_err!(\n-                    self.tcx().sess,\n-                    span,\n-                    E0161,\n-                    \"cannot move a value of type {0}: the size of {0} \\\n-                     cannot be statically determined\",\n-                    ty\n-                );\n-\n                 // While this is located in `nll::typeck` this error is not\n                 // an NLL error, it's a required check to prevent creation\n                 // of unsized rvalues in a call expression.\n-                diag.emit();\n+                self.tcx().sess.emit_err(MoveUnsized { ty, span });\n             }\n         }\n     }"}, {"sha": "076415b2d1b2f3b8f4df9267488db7b82dbffd8b", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -366,22 +366,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n                 assert_eq!(def_a, def_b);\n-                if def_a.is_box() || def_b.is_box() {\n-                    if !def_a.is_box() || !def_b.is_box() {\n-                        span_bug!(\n-                            self.cur_span(),\n-                            \"invalid unsizing between {:?} -> {:?}\",\n-                            src.layout.ty,\n-                            cast_ty.ty\n-                        );\n-                    }\n-                    return self.unsize_into_ptr(\n-                        src,\n-                        dest,\n-                        src.layout.ty.boxed_ty(),\n-                        cast_ty.ty.boxed_ty(),\n-                    );\n-                }\n \n                 // unsizing of generic struct with pointer fields\n                 // Example: `Arc<T>` -> `Arc<Trait>`"}, {"sha": "905ab6cb578fc1e0eef52b71276797efe7f530ab", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -594,7 +594,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 Ok(true)\n             }\n             ty::Adt(def, ..) if def.is_box() => {\n-                self.check_safe_pointer(value, \"box\")?;\n+                let unique = self.ecx.operand_field(value, 0)?;\n+                let nonnull = self.ecx.operand_field(&unique, 0)?;\n+                let ptr = self.ecx.operand_field(&nonnull, 0)?;\n+                self.check_safe_pointer(&ptr, \"box\")?;\n+\n+                // Check other fields of Box\n+                self.walk_value(value)?;\n                 Ok(true)\n             }\n             ty::FnPtr(_sig) => {"}, {"sha": "645673ef47aeb618faf16c7a4a4abce055170575", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -0,0 +1,18 @@\n+borrowck-move-unsized =\n+    cannot move a value of type `{$ty}`\n+    .label = the size of `{$ty}` cannot be statically determined\n+\n+borrowck-higher-ranked-lifetime-error =\n+    higher-ranked lifetime error\n+\n+borrowck-could-not-prove =\n+    could not prove `{$predicate}`\n+\n+borrowck-could-not-normalize =\n+    could not normalize `{$value}`\n+\n+borrowck-higher-ranked-subtype-error =\n+    higher-ranked subtype error\n+  \n+generic-does-not-live-long-enough =\n+    `{$kind}` does not live long enough\n\\ No newline at end of file"}, {"sha": "d52b94b78dfac035f1d227d3c385364bb4bc32cd", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -35,6 +35,7 @@ fluent_messages! {\n     privacy => \"../locales/en-US/privacy.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n+    borrowck => \"../locales/en-US/borrowck.ftl\",\n }\n \n pub use fluent_generated::{self as fluent, DEFAULT_LOCALE_RESOURCES};"}, {"sha": "6d74e9a9f2b9e5dd20ab8c134b8d21d05934142e", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -281,9 +281,19 @@ pub trait Emitter {\n         let message = bundle.get_message(&identifier).expect(\"missing diagnostic in fluent bundle\");\n         let value = match attr {\n             Some(attr) => {\n-                message.get_attribute(attr).expect(\"missing attribute in fluent message\").value()\n+                if let Some(attr) = message.get_attribute(attr) {\n+                    attr.value()\n+                } else {\n+                    panic!(\"missing attribute `{attr}` in fluent message `{identifier}`\")\n+                }\n+            }\n+            None => {\n+                if let Some(value) = message.value() {\n+                    value\n+                } else {\n+                    panic!(\"missing value in fluent message `{identifier}`\")\n+                }\n             }\n-            None => message.value().expect(\"missing value in fluent message\"),\n         };\n \n         let mut err = vec![];"}, {"sha": "e319f17b0e60d5fccc69536a0b085b279e2f4c91", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -342,8 +342,8 @@ pub fn same_type_modulo_infer<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         )\n         | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n         | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n-        (&ty::Ref(reg_a, ty_a, mut_a), &ty::Ref(reg_b, ty_b, mut_b)) => {\n-            reg_a == reg_b && mut_a == mut_b && same_type_modulo_infer(*ty_a, *ty_b)\n+        (&ty::Ref(_, ty_a, mut_a), &ty::Ref(_, ty_b, mut_b)) => {\n+            mut_a == mut_b && same_type_modulo_infer(*ty_a, *ty_b)\n         }\n         _ => a == b,\n     }"}, {"sha": "0f87e638d2618e2ea92aa756008ed40f0a230c03", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -33,8 +33,9 @@ fn is_stable(place: PlaceRef<'_>) -> bool {\n     })\n }\n \n-/// Determine whether this type may be a reference (or box), and thus needs retagging.\n-fn may_be_reference(ty: Ty<'_>) -> bool {\n+/// Determine whether this type may contain a reference (or box), and thus needs retagging.\n+/// We will only recurse `depth` times into Tuples/ADTs to bound the cost of this.\n+fn may_contain_reference<'tcx>(ty: Ty<'tcx>, depth: u32, tcx: TyCtxt<'tcx>) -> bool {\n     match ty.kind() {\n         // Primitive types that are not references\n         ty::Bool\n@@ -50,8 +51,20 @@ fn may_be_reference(ty: Ty<'_>) -> bool {\n         // References\n         ty::Ref(..) => true,\n         ty::Adt(..) if ty.is_box() => true,\n-        // Compound types are not references\n-        ty::Array(..) | ty::Slice(..) | ty::Tuple(..) | ty::Adt(..) => false,\n+        // Compound types: recurse\n+        ty::Array(ty, _) | ty::Slice(ty) => {\n+            // This does not branch so we keep the depth the same.\n+            may_contain_reference(*ty, depth, tcx)\n+        }\n+        ty::Tuple(tys) => {\n+            depth == 0 || tys.iter().any(|ty| may_contain_reference(ty, depth - 1, tcx))\n+        }\n+        ty::Adt(adt, subst) => {\n+            depth == 0\n+                || adt.variants().iter().any(|v| {\n+                    v.fields.iter().any(|f| may_contain_reference(f.ty(tcx, subst), depth - 1, tcx))\n+                })\n+        }\n         // Conservative fallback\n         _ => true,\n     }\n@@ -83,7 +96,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that.\n             is_stable(place.as_ref())\n-                && may_be_reference(place.ty(&*local_decls, tcx).ty)\n+                && may_contain_reference(place.ty(&*local_decls, tcx).ty, /*depth*/ 3, tcx)\n                 && is_not_temp(&local_decls[place.local])\n         };\n         let place_base_raw = |place: &Place<'tcx>| {"}, {"sha": "424eff2f6212a6dfcb71b1792781cbae049fd05a", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -236,7 +236,7 @@ impl<'tcx> AbstractConst<'tcx> {\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n         let inner = tcx.thir_abstract_const_opt_const_arg(uv.def)?;\n         debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n-        Ok(inner.map(|inner| AbstractConst { inner, substs: uv.substs }))\n+        Ok(inner.map(|inner| AbstractConst { inner, substs: tcx.erase_regions(uv.substs) }))\n     }\n \n     pub fn from_const(\n@@ -416,6 +416,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     // `AbstractConst`s should not contain any promoteds as they require references which\n                     // are not allowed.\n                     assert_eq!(ct.promoted, None);\n+                    assert_eq!(ct, self.tcx.erase_regions(ct));\n                 }\n             }\n         }"}, {"sha": "dc49ff90f34b0035dd77a4a5ead4c66c8641aa99", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 169, "deletions": 177, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -24,7 +24,6 @@ use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, IsSuggestable, Ty, TyCtxt};\n use rustc_session::Session;\n@@ -35,12 +34,6 @@ use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpres\n use std::iter;\n use std::slice;\n \n-enum TupleMatchFound {\n-    None,\n-    Single,\n-    /// Beginning and end Span\n-    Multiple(Span, Span),\n-}\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&self) {\n         let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n@@ -216,14 +209,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let minimum_input_count = expected_input_tys.len();\n         let provided_arg_count = provided_args.len();\n \n-        // We'll also want to keep track of the fully coerced argument types, for an awkward hack near the end\n-        // FIXME(compiler-errors): Get rid of this, actually.\n-        let mut final_arg_types: Vec<Option<(Ty<'_>, Ty<'_>)>> = vec![None; provided_arg_count];\n-\n         // We introduce a helper function to demand that a given argument satisfy a given input\n         // This is more complicated than just checking type equality, as arguments could be coerced\n         // This version writes those types back so further type checking uses the narrowed types\n-        let demand_compatible = |idx, final_arg_types: &mut Vec<Option<(Ty<'tcx>, Ty<'tcx>)>>| {\n+        let demand_compatible = |idx| {\n             let formal_input_ty: Ty<'tcx> = formal_input_tys[idx];\n             let expected_input_ty: Ty<'tcx> = expected_input_tys[idx];\n             let provided_arg = &provided_args[idx];\n@@ -242,9 +231,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n             let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n \n-            // Keep track of these for below\n-            final_arg_types[idx] = Some((checked_ty, coerced_ty));\n-\n             // Cause selection errors caused by resolving a single argument to point at the\n             // argument and not the call. This lets us customize the span pointed to in the\n             // fulfillment error to be more accurate.\n@@ -253,16 +239,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                     self.point_at_arg_instead_of_call_if_possible(\n                         errors,\n-                        &final_arg_types,\n                         call_expr,\n                         call_span,\n                         provided_args,\n+                        &expected_input_tys,\n                     );\n                 });\n \n-            // Make sure we store the resolved type\n-            final_arg_types[idx] = Some((checked_ty, coerced_ty));\n-\n             let coerce_error = self\n                 .try_coerce(provided_arg, checked_ty, coerced_ty, AllowTwoPhase::Yes, None)\n                 .err();\n@@ -320,10 +303,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                     self.point_at_arg_instead_of_call_if_possible(\n                         errors,\n-                        &final_arg_types,\n                         call_expr,\n                         call_span,\n                         &provided_args,\n+                        &expected_input_tys,\n                     );\n                 })\n             }\n@@ -352,7 +335,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     continue;\n                 }\n \n-                let compatible = demand_compatible(idx, &mut final_arg_types);\n+                let compatible = demand_compatible(idx);\n                 let is_compatible = matches!(compatible, Compatibility::Compatible);\n                 compatibility_diagonal[idx] = compatible;\n \n@@ -445,72 +428,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 None => \"function\",\n             };\n \n-            let try_tuple_wrap_args = || {\n-                // The case where we expect a single tuple and wrapping all the args\n-                // in parentheses (or adding a comma to already existing parentheses)\n-                // will result in a tuple that satisfies the call.\n-                // This isn't super ideal code, because we copy code from elsewhere\n-                // and somewhat duplicate this. We also delegate to the general type\n-                // mismatch suggestions for the single arg case.\n-                match self.suggested_tuple_wrap(&expected_input_tys, provided_args) {\n-                    TupleMatchFound::Single => {\n-                        let expected_ty = expected_input_tys[0];\n-                        let provided_ty = final_arg_types[0].map(|ty| ty.0).unwrap();\n-                        let expected_ty = self.resolve_vars_if_possible(expected_ty);\n-                        let provided_ty = self.resolve_vars_if_possible(provided_ty);\n-                        let cause = &self.misc(provided_args[0].span);\n-                        let compatibility = demand_compatible(0, &mut final_arg_types);\n-                        let type_error = match compatibility {\n-                            Compatibility::Incompatible(Some(error)) => error,\n-                            _ => TypeError::Mismatch,\n-                        };\n-                        let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-                        let mut err = self.report_and_explain_type_error(trace, &type_error);\n-                        self.emit_coerce_suggestions(\n-                            &mut err,\n-                            &provided_args[0],\n-                            final_arg_types[0].map(|ty| ty.0).unwrap(),\n-                            final_arg_types[0].map(|ty| ty.1).unwrap(),\n-                            None,\n-                            None,\n-                        );\n-                        err.span_label(\n-                            full_call_span,\n-                            format!(\"arguments to this {} are incorrect\", call_name),\n-                        );\n-                        // Call out where the function is defined\n-                        label_fn_like(tcx, &mut err, fn_def_id);\n-                        err.emit();\n-                        return true;\n-                    }\n-                    TupleMatchFound::Multiple(start, end) => {\n-                        let mut err = tcx.sess.struct_span_err_with_code(\n-                            full_call_span,\n-                            &format!(\n-                                \"this {} takes {}{} but {} {} supplied\",\n-                                call_name,\n-                                if c_variadic { \"at least \" } else { \"\" },\n-                                potentially_plural_count(minimum_input_count, \"argument\"),\n-                                potentially_plural_count(provided_arg_count, \"argument\"),\n-                                if provided_arg_count == 1 { \"was\" } else { \"were\" }\n-                            ),\n-                            DiagnosticId::Error(err_code.to_owned()),\n-                        );\n-                        // Call out where the function is defined\n-                        label_fn_like(tcx, &mut err, fn_def_id);\n-                        err.multipart_suggestion(\n-                            \"use parentheses to construct a tuple\",\n-                            vec![(start, '('.to_string()), (end, ')'.to_string())],\n-                            Applicability::MachineApplicable,\n-                        );\n-                        err.emit();\n-                        return true;\n-                    }\n-                    TupleMatchFound::None => {}\n-                }\n-                false\n-            };\n-\n             let compatibility_diagonal = IndexVec::from_raw(compatibility_diagonal);\n             let provided_args = IndexVec::from_iter(provided_args.iter().take(if c_variadic {\n                 minimum_input_count\n@@ -541,7 +458,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 c_variadic,\n                 err_code,\n                 fn_def_id,\n-                try_tuple_wrap_args,\n             );\n         }\n     }\n@@ -558,7 +474,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         c_variadic: bool,\n         err_code: &str,\n         fn_def_id: Option<DefId>,\n-        try_tuple_wrap_args: impl FnOnce() -> bool,\n     ) {\n         // Don't print if it has error types or is just plain `_`\n         fn has_error_or_infer<'tcx>(tys: impl IntoIterator<Item = Ty<'tcx>>) -> bool {\n@@ -578,7 +493,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let (formal_input_ty, expected_input_ty) = formal_and_expected_inputs[expected_idx];\n             // If either is an error type, we defy the usual convention and consider them to *not* be\n-            // coercible.  This prevents our error message heuristic from trying to pass errors into\n+            // coercible. This prevents our error message heuristic from trying to pass errors into\n             // every argument.\n             if (formal_input_ty, expected_input_ty).references_error() {\n                 return Compatibility::Incompatible(None);\n@@ -599,16 +514,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return Compatibility::Incompatible(None);\n             }\n \n-            let subtyping_result = self\n-                .at(&self.misc(provided_arg.span), self.param_env)\n-                .sup(formal_input_ty, coerced_ty);\n+            // Using probe here, since we don't want this subtyping to affect inference.\n+            let subtyping_error = self.probe(|_| {\n+                self.at(&self.misc(provided_arg.span), self.param_env)\n+                    .sup(formal_input_ty, coerced_ty)\n+                    .err()\n+            });\n \n             // Same as above: if either the coerce type or the checked type is an error type,\n             // consider them *not* compatible.\n             let references_error = (coerced_ty, checked_ty).references_error();\n-            match (references_error, &subtyping_result) {\n-                (false, Ok(_)) => Compatibility::Compatible,\n-                _ => Compatibility::Incompatible(subtyping_result.err()),\n+            match (references_error, subtyping_error) {\n+                (false, None) => Compatibility::Compatible,\n+                (_, subtyping_error) => Compatibility::Incompatible(subtyping_error),\n             }\n         };\n \n@@ -629,16 +547,105 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .map(|expr| {\n                 let ty = self\n-                    .in_progress_typeck_results\n-                    .as_ref()\n-                    .unwrap()\n+                    .typeck_results\n                     .borrow()\n                     .expr_ty_adjusted_opt(*expr)\n                     .unwrap_or_else(|| tcx.ty_error());\n                 (self.resolve_vars_if_possible(ty), expr.span)\n             })\n             .collect();\n \n+        // First, check if we just need to wrap some arguments in a tuple.\n+        if let Some((mismatch_idx, terr)) =\n+            compatibility_diagonal.iter().enumerate().find_map(|(i, c)| {\n+                if let Compatibility::Incompatible(Some(terr)) = c { Some((i, terr)) } else { None }\n+            })\n+        {\n+            // Is the first bad expected argument a tuple?\n+            // Do we have as many extra provided arguments as the tuple's length?\n+            // If so, we might have just forgotten to wrap some args in a tuple.\n+            if let Some(ty::Tuple(tys)) =\n+                formal_and_expected_inputs.get(mismatch_idx.into()).map(|tys| tys.1.kind())\n+                && provided_arg_tys.len() == formal_and_expected_inputs.len() - 1 + tys.len()\n+            {\n+                // Wrap up the N provided arguments starting at this position in a tuple.\n+                let provided_as_tuple = tcx.mk_tup(\n+                    provided_arg_tys.iter().map(|(ty, _)| *ty).skip(mismatch_idx).take(tys.len()),\n+                );\n+\n+                let mut satisfied = true;\n+                // Check if the newly wrapped tuple + rest of the arguments are compatible.\n+                for ((_, expected_ty), provided_ty) in std::iter::zip(\n+                    formal_and_expected_inputs.iter().skip(mismatch_idx),\n+                    [provided_as_tuple].into_iter().chain(\n+                        provided_arg_tys.iter().map(|(ty, _)| *ty).skip(mismatch_idx + tys.len()),\n+                    ),\n+                ) {\n+                    if !self.can_coerce(provided_ty, *expected_ty) {\n+                        satisfied = false;\n+                        break;\n+                    }\n+                }\n+\n+                // If they're compatible, suggest wrapping in an arg, and we're done!\n+                // Take some care with spans, so we don't suggest wrapping a macro's\n+                // innards in parenthesis, for example.\n+                if satisfied\n+                    && let Some(lo) =\n+                        provided_args[mismatch_idx.into()].span.find_ancestor_inside(error_span)\n+                    && let Some(hi) = provided_args[(mismatch_idx + tys.len() - 1).into()]\n+                        .span\n+                        .find_ancestor_inside(error_span)\n+                {\n+                    let mut err;\n+                    if tys.len() == 1 {\n+                        // A tuple wrap suggestion actually occurs within,\n+                        // so don't do anything special here.\n+                        err = self.report_and_explain_type_error(\n+                            TypeTrace::types(\n+                                &self.misc(lo),\n+                                true,\n+                                formal_and_expected_inputs[mismatch_idx.into()].1,\n+                                provided_arg_tys[mismatch_idx.into()].0,\n+                            ),\n+                            terr,\n+                        );\n+                        err.span_label(\n+                            full_call_span,\n+                            format!(\"arguments to this {} are incorrect\", call_name),\n+                        );\n+                    } else {\n+                        err = tcx.sess.struct_span_err_with_code(\n+                            full_call_span,\n+                            &format!(\n+                                \"this {} takes {}{} but {} {} supplied\",\n+                                call_name,\n+                                if c_variadic { \"at least \" } else { \"\" },\n+                                potentially_plural_count(\n+                                    formal_and_expected_inputs.len(),\n+                                    \"argument\"\n+                                ),\n+                                potentially_plural_count(provided_args.len(), \"argument\"),\n+                                if provided_args.len() == 1 { \"was\" } else { \"were\" }\n+                            ),\n+                            DiagnosticId::Error(err_code.to_owned()),\n+                        );\n+                        err.multipart_suggestion_verbose(\n+                            \"wrap these arguments in parentheses to construct a tuple\",\n+                            vec![\n+                                (lo.shrink_to_lo(), \"(\".to_string()),\n+                                (hi.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            Applicability::MachineApplicable,\n+                        );\n+                    };\n+                    label_fn_like(tcx, &mut err, fn_def_id);\n+                    err.emit();\n+                    return;\n+                }\n+            }\n+        }\n+\n         // Okay, so here's where it gets complicated in regards to what errors\n         // we emit and how.\n         // There are 3 different \"types\" of errors we might encounter.\n@@ -666,7 +673,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     )\n                     .note(\n                         \"we would appreciate a bug report: \\\n-                        https://github.com/rust-lang/rust-clippy/issues/new\",\n+                        https://github.com/rust-lang/rust/issues/new\",\n                     )\n                     .emit();\n             }\n@@ -727,13 +734,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        // Second, let's try tuple wrapping the args.\n-        // FIXME(compiler-errors): This is currently in its own closure because\n-        // I didn't want to factor it out.\n-        if try_tuple_wrap_args() {\n-            return;\n-        }\n-\n         let mut err = if formal_and_expected_inputs.len() == provided_args.len() {\n             struct_span_err!(\n                 tcx.sess,\n@@ -989,13 +989,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             String::new()\n                         };\n-                        // FIXME(compiler-errors): Why do we get permutations with the same type?\n-                        if expected_ty != provided_ty {\n-                            labels.push((\n-                                provided_span,\n-                                format!(\"expected `{}`{}\", expected_ty, provided_ty_name),\n-                            ));\n-                        }\n+                        labels.push((\n+                            provided_span,\n+                            format!(\"expected `{}`{}\", expected_ty, provided_ty_name),\n+                        ));\n                     }\n \n                     suggestion_text = match suggestion_text {\n@@ -1043,10 +1040,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else {\n                     needs_comma = true;\n                 }\n-                let suggestion_text =\n-                    if let Some(provided_idx) = provided_idx\n+                let suggestion_text = if let Some(provided_idx) = provided_idx\n                     && let (_, provided_span) = provided_arg_tys[*provided_idx]\n-                    && let Ok(arg_text) = source_map.span_to_snippet(provided_span.source_callsite()) {\n+                    && let Ok(arg_text) =\n+                        source_map.span_to_snippet(provided_span.source_callsite())\n+                {\n                     arg_text\n                 } else {\n                     // Propose a placeholder of the correct type\n@@ -1073,38 +1071,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn suggested_tuple_wrap(\n-        &self,\n-        expected_input_tys: &[Ty<'tcx>],\n-        provided_args: &'tcx [hir::Expr<'tcx>],\n-    ) -> TupleMatchFound {\n-        // Only handle the case where we expect only one tuple arg\n-        let [expected_arg_type] = expected_input_tys[..] else { return TupleMatchFound::None };\n-        let &ty::Tuple(expected_types) = self.resolve_vars_if_possible(expected_arg_type).kind()\n-            else { return TupleMatchFound::None };\n-\n-        // First check that there are the same number of types.\n-        if expected_types.len() != provided_args.len() {\n-            return TupleMatchFound::None;\n-        }\n-\n-        let supplied_types: Vec<_> = provided_args.iter().map(|arg| self.check_expr(arg)).collect();\n-\n-        let all_match = iter::zip(expected_types, supplied_types)\n-            .all(|(expected, supplied)| self.can_eq(self.param_env, expected, supplied).is_ok());\n-\n-        if !all_match {\n-            return TupleMatchFound::None;\n-        }\n-        match provided_args {\n-            [] => TupleMatchFound::None,\n-            [_] => TupleMatchFound::Single,\n-            [first, .., last] => {\n-                TupleMatchFound::Multiple(first.span.shrink_to_lo(), last.span.shrink_to_hi())\n-            }\n-        }\n-    }\n-\n     // AST fragment checking\n     pub(in super::super) fn check_lit(\n         &self,\n@@ -1652,18 +1618,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn point_at_arg_instead_of_call_if_possible(\n         &self,\n         errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n-        final_arg_types: &[Option<(Ty<'tcx>, Ty<'tcx>)>],\n         expr: &'tcx hir::Expr<'tcx>,\n         call_sp: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n+        expected_tys: &[Ty<'tcx>],\n     ) {\n         // We *do not* do this for desugared call spans to keep good diagnostics when involving\n         // the `?` operator.\n         if call_sp.desugaring_kind().is_some() {\n             return;\n         }\n \n-        for error in errors {\n+        'outer: for error in errors {\n             // Only if the cause is somewhere inside the expression we want try to point at arg.\n             // Otherwise, it means that the cause is somewhere else and we should not change\n             // anything because we can break the correct span.\n@@ -1688,39 +1654,65 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (result_code, code) = (code, parent);\n                 }\n             }\n-            let self_: ty::subst::GenericArg<'_> = match unpeel_to_top(error.obligation.cause.code()) {\n-                ObligationCauseCode::BuiltinDerivedObligation(code) |\n-                ObligationCauseCode::DerivedObligation(code) => {\n-                    code.parent_trait_pred.self_ty().skip_binder().into()\n-                }\n-                ObligationCauseCode::ImplDerivedObligation(code) => {\n-                    code.derived.parent_trait_pred.self_ty().skip_binder().into()\n-                }\n-                _ if let ty::PredicateKind::Trait(predicate) =\n-                    error.obligation.predicate.kind().skip_binder() => {\n+            let self_: ty::subst::GenericArg<'_> =\n+                match unpeel_to_top(error.obligation.cause.code()) {\n+                    ObligationCauseCode::BuiltinDerivedObligation(code)\n+                    | ObligationCauseCode::DerivedObligation(code) => {\n+                        code.parent_trait_pred.self_ty().skip_binder().into()\n+                    }\n+                    ObligationCauseCode::ImplDerivedObligation(code) => {\n+                        code.derived.parent_trait_pred.self_ty().skip_binder().into()\n+                    }\n+                    _ if let ty::PredicateKind::Trait(predicate) =\n+                        error.obligation.predicate.kind().skip_binder() =>\n+                    {\n                         predicate.self_ty().into()\n                     }\n-                _ =>  continue,\n-            };\n+                    _ => continue,\n+                };\n             let self_ = self.resolve_vars_if_possible(self_);\n+            let ty_matches_self = |ty: Ty<'tcx>| ty.walk().any(|arg| arg == self_);\n+\n+            let typeck_results = self.typeck_results.borrow();\n+\n+            for (idx, arg) in args.iter().enumerate() {\n+                // Don't adjust the span if we already have a more precise span\n+                // within one of the args.\n+                if arg.span.contains(error.obligation.cause.span) {\n+                    let references_arg =\n+                        typeck_results.expr_ty_opt(arg).map_or(false, &ty_matches_self)\n+                            || expected_tys.get(idx).copied().map_or(false, &ty_matches_self);\n+                    if references_arg && !arg.span.from_expansion() {\n+                        error.obligation.cause.map_code(|parent_code| {\n+                            ObligationCauseCode::FunctionArgumentObligation {\n+                                arg_hir_id: args[idx].hir_id,\n+                                call_hir_id: expr.hir_id,\n+                                parent_code,\n+                            }\n+                        })\n+                    }\n+                    continue 'outer;\n+                }\n+            }\n \n             // Collect the argument position for all arguments that could have caused this\n             // `FulfillmentError`.\n-            let mut referenced_in = final_arg_types\n-                .iter()\n+            let mut referenced_in: Vec<_> = std::iter::zip(expected_tys, args)\n                 .enumerate()\n-                .filter_map(|(i, arg)| match arg {\n-                    Some((checked_ty, coerce_ty)) => Some([(i, *checked_ty), (i, *coerce_ty)]),\n-                    _ => None,\n+                .flat_map(|(idx, (expected_ty, arg))| {\n+                    if let Some(arg_ty) = typeck_results.expr_ty_opt(arg) {\n+                        vec![(idx, arg_ty), (idx, *expected_ty)]\n+                    } else {\n+                        vec![]\n+                    }\n                 })\n-                .flatten()\n-                .flat_map(|(i, ty)| {\n+                .filter_map(|(i, ty)| {\n                     let ty = self.resolve_vars_if_possible(ty);\n                     // We walk the argument type because the argument's type could have\n                     // been `Option<T>`, but the `FulfillmentError` references `T`.\n-                    if ty.walk().any(|arg| arg == self_) { Some(i) } else { None }\n+                    if ty_matches_self(ty) { Some(i) } else { None }\n                 })\n-                .collect::<Vec<usize>>();\n+                .collect();\n \n             // Both checked and coerced types could have matched, thus we need to remove\n             // duplicates.\n@@ -1729,18 +1721,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             referenced_in.sort_unstable();\n             referenced_in.dedup();\n \n-            if let (Some(ref_in), None) = (referenced_in.pop(), referenced_in.pop()) {\n+            if let &[idx] = &referenced_in[..] {\n                 // Do not point at the inside of a macro.\n                 // That would often result in poor error messages.\n-                if args[ref_in].span.from_expansion() {\n-                    return;\n+                if args[idx].span.from_expansion() {\n+                    continue;\n                 }\n                 // We make sure that only *one* argument matches the obligation failure\n                 // and we assign the obligation's span to its expression's.\n-                error.obligation.cause.span = args[ref_in].span;\n+                error.obligation.cause.span = args[idx].span;\n                 error.obligation.cause.map_code(|parent_code| {\n                     ObligationCauseCode::FunctionArgumentObligation {\n-                        arg_hir_id: args[ref_in].hir_id,\n+                        arg_hir_id: args[idx].hir_id,\n                         call_hir_id: expr.hir_id,\n                         parent_code,\n                     }"}, {"sha": "43e4b7f08e22d37c96f173b39e09685bd37f9453", "filename": "library/core/src/ffi/mod.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -231,7 +231,8 @@ impl fmt::Debug for c_void {\n     all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n     target_family = \"wasm\",\n     target_arch = \"asmjs\",\n-    windows\n+    target_os = \"uefi\",\n+    windows,\n ))]\n #[repr(transparent)]\n #[unstable(\n@@ -254,7 +255,8 @@ pub struct VaListImpl<'f> {\n     all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n     target_family = \"wasm\",\n     target_arch = \"asmjs\",\n-    windows\n+    target_os = \"uefi\",\n+    windows,\n ))]\n #[unstable(\n     feature = \"c_variadic\",\n@@ -276,7 +278,8 @@ impl<'f> fmt::Debug for VaListImpl<'f> {\n #[cfg(all(\n     target_arch = \"aarch64\",\n     not(any(target_os = \"macos\", target_os = \"ios\")),\n-    not(windows)\n+    not(target_os = \"uefi\"),\n+    not(windows),\n ))]\n #[repr(C)]\n #[derive(Debug)]\n@@ -297,7 +300,7 @@ pub struct VaListImpl<'f> {\n }\n \n /// PowerPC ABI implementation of a `va_list`.\n-#[cfg(all(target_arch = \"powerpc\", not(windows)))]\n+#[cfg(all(target_arch = \"powerpc\", not(target_os = \"uefi\"), not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n #[unstable(\n@@ -317,7 +320,7 @@ pub struct VaListImpl<'f> {\n }\n \n /// x86_64 ABI implementation of a `va_list`.\n-#[cfg(all(target_arch = \"x86_64\", not(windows)))]\n+#[cfg(all(target_arch = \"x86_64\", not(target_os = \"uefi\"), not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n #[unstable(\n@@ -354,7 +357,8 @@ pub struct VaList<'a, 'f: 'a> {\n         all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n         target_family = \"wasm\",\n         target_arch = \"asmjs\",\n-        windows\n+        target_os = \"uefi\",\n+        windows,\n     ))]\n     inner: VaListImpl<'f>,\n \n@@ -363,7 +367,8 @@ pub struct VaList<'a, 'f: 'a> {\n         any(not(target_arch = \"aarch64\"), not(any(target_os = \"macos\", target_os = \"ios\"))),\n         not(target_family = \"wasm\"),\n         not(target_arch = \"asmjs\"),\n-        not(windows)\n+        not(target_os = \"uefi\"),\n+        not(windows),\n     ))]\n     inner: &'a mut VaListImpl<'f>,\n \n@@ -375,7 +380,8 @@ pub struct VaList<'a, 'f: 'a> {\n     all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n     target_family = \"wasm\",\n     target_arch = \"asmjs\",\n-    windows\n+    target_os = \"uefi\",\n+    windows,\n ))]\n #[unstable(\n     feature = \"c_variadic\",\n@@ -396,7 +402,8 @@ impl<'f> VaListImpl<'f> {\n     any(not(target_arch = \"aarch64\"), not(any(target_os = \"macos\", target_os = \"ios\"))),\n     not(target_family = \"wasm\"),\n     not(target_arch = \"asmjs\"),\n-    not(windows)\n+    not(target_os = \"uefi\"),\n+    not(windows),\n ))]\n #[unstable(\n     feature = \"c_variadic\","}, {"sha": "90e2dfd5d3d9ba788721df524b7ef723b49c53e6", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -854,6 +854,42 @@ impl AtomicBool {\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n \n+    /// Logical \"not\" with a boolean value.\n+    ///\n+    /// Performs a logical \"not\" operation on the current value, and sets\n+    /// the new value to the result.\n+    ///\n+    /// Returns the previous value.\n+    ///\n+    /// `fetch_not` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on `u8`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(atomic_bool_fetch_not)]\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(foo.fetch_not(Ordering::SeqCst), true);\n+    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n+    ///\n+    /// let foo = AtomicBool::new(false);\n+    /// assert_eq!(foo.fetch_not(Ordering::SeqCst), false);\n+    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_bool_fetch_not\", issue = \"98485\")]\n+    #[cfg(target_has_atomic = \"8\")]\n+    pub fn fetch_not(&self, order: Ordering) -> bool {\n+        self.fetch_xor(true, order)\n+    }\n+\n     /// Returns a mutable pointer to the underlying [`bool`].\n     ///\n     /// Doing non-atomic reads and writes on the resulting integer can be a data race."}, {"sha": "c8c45da19137fb20ee213f7815402a6e3ad7a567", "filename": "src/test/mir-opt/retag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -129,6 +129,7 @@ fn array_casts() -> () {\n         _18 = &(*_35);                   // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Retag(_18);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _13 = (move _14, move _18);      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        Retag(_13);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageDead(_18);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageDead(_14);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_20);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n@@ -171,6 +172,7 @@ fn array_casts() -> () {\n         Retag(_32);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_34);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _34 = Option::<Arguments>::None; // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        Retag(_34);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _28 = core::panicking::assert_failed::<usize, usize>(move _29, move _30, move _32, move _34); // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL"}, {"sha": "2ae0ae70dd9778971c64c7fd8af09aefd97c93bf", "filename": "src/test/ui/const-generics/try_unify_ignore_lifetimes.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fconst-generics%2Ftry_unify_ignore_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fconst-generics%2Ftry_unify_ignore_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftry_unify_ignore_lifetimes.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -0,0 +1,33 @@\n+// check-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+struct Num<const N: usize>;\n+\n+trait NumT {\n+    const VALUE: usize;\n+}\n+\n+impl<const N: usize> NumT for Num<N> {\n+    const VALUE: usize = N;\n+}\n+\n+struct Foo<'a, N: NumT>(&'a [u32; N::VALUE]) where [(); N::VALUE]:;\n+\n+trait Bar {\n+    type Size: NumT;\n+\n+    fn bar<'a>(foo: &Foo<'a, Self::Size>) where [(); Self::Size::VALUE]: {\n+        todo!();\n+    }\n+}\n+\n+trait Baz<'a> {\n+    type Size: NumT;\n+\n+    fn baz(foo: &Foo<'a, Self::Size>) where [(); Self::Size::VALUE]: {\n+        todo!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d38af3f89c21b84d8d400375ad8e8b1dd3234ed0", "filename": "src/test/ui/dst/dst-index.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fdst%2Fdst-index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fdst%2Fdst-index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-index.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -1,14 +1,14 @@\n-error[E0161]: cannot move a value of type str: the size of str cannot be statically determined\n+error[E0161]: cannot move a value of type `str`\n   --> $DIR/dst-index.rs:31:5\n    |\n LL |     S[0];\n-   |     ^^^^\n+   |     ^^^^ the size of `str` cannot be statically determined\n \n-error[E0161]: cannot move a value of type dyn Debug: the size of dyn Debug cannot be statically determined\n+error[E0161]: cannot move a value of type `dyn Debug`\n   --> $DIR/dst-index.rs:34:5\n    |\n LL |     T[0];\n-   |     ^^^^\n+   |     ^^^^ the size of `dyn Debug` cannot be statically determined\n \n error[E0507]: cannot move out of index of `S`\n   --> $DIR/dst-index.rs:31:5"}, {"sha": "15d98b657a262a01a79937fba825a375d16cc57d", "filename": "src/test/ui/error-codes/E0161.base.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Ferror-codes%2FE0161.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Ferror-codes%2FE0161.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0161.base.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -1,8 +1,8 @@\n-error[E0161]: cannot move a value of type dyn Bar: the size of dyn Bar cannot be statically determined\n+error[E0161]: cannot move a value of type `dyn Bar`\n   --> $DIR/E0161.rs:16:5\n    |\n LL |     x.f();\n-   |     ^^^^^\n+   |     ^^^^^ the size of `dyn Bar` cannot be statically determined\n \n error: aborting due to previous error\n "}, {"sha": "43e609cc59efb0eddd9b52e21acf8621ad23573e", "filename": "src/test/ui/higher-rank-trait-bounds/issue-59311.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -4,15 +4,15 @@ error: higher-ranked lifetime error\n LL |     v.t(|| {});\n    |     ^^^^^^^^^^\n    |\n-   = note: could not prove [closure@$DIR/issue-59311.rs:17:9: 17:14] well-formed\n+   = note: could not prove `[closure@$DIR/issue-59311.rs:17:9: 17:14] well-formed`\n \n error: higher-ranked lifetime error\n   --> $DIR/issue-59311.rs:17:9\n    |\n LL |     v.t(|| {});\n    |         ^^^^^\n    |\n-   = note: could not prove for<'a> &'a V: 'static\n+   = note: could not prove `for<'a> &'a V: 'static`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "72bb0782f4b4f2170b0532f1fde4e24ec4e6200b", "filename": "src/test/ui/lifetimes/re-empty-in-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Flifetimes%2Fre-empty-in-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Flifetimes%2Fre-empty-in-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fre-empty-in-error.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -4,7 +4,7 @@ error: higher-ranked lifetime error\n LL |     foo(&10);\n    |     ^^^^^^^^\n    |\n-   = note: could not prove for<'b, 'r> &'b (): 'r\n+   = note: could not prove `for<'b, 'r> &'b (): 'r`\n \n error: aborting due to previous error\n "}, {"sha": "f73d38f80426f551b39c177b1503345795b1b98b", "filename": "src/test/ui/mir/issue-67947.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fmir%2Fissue-67947.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fmir%2Fissue-67947.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-67947.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -1,6 +1,6 @@\n struct Bug {\n     A: [(); { *\"\" }.len()],\n-    //~^ ERROR: cannot move a value of type str\n+    //~^ ERROR: cannot move a value of type `str`\n     //~| ERROR: cannot move out of a shared reference\n }\n "}, {"sha": "7697a411eb481975c78efa65e13d42a844fe6226", "filename": "src/test/ui/mir/issue-67947.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fmir%2Fissue-67947.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fmir%2Fissue-67947.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-67947.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -1,8 +1,8 @@\n-error[E0161]: cannot move a value of type str: the size of str cannot be statically determined\n+error[E0161]: cannot move a value of type `str`\n   --> $DIR/issue-67947.rs:2:13\n    |\n LL |     A: [(); { *\"\" }.len()],\n-   |             ^^^^^^^\n+   |             ^^^^^^^ the size of `str` cannot be statically determined\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/issue-67947.rs:2:15"}, {"sha": "8e93c538217bbd2e4ec90cabd41e0b03d192fbc1", "filename": "src/test/ui/object-safety/object-safety-by-value-self-use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-by-value-self-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-by-value-self-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-by-value-self-use.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -12,7 +12,7 @@ trait Baz {\n }\n \n fn use_bar(t: Box<dyn Bar>) {\n-    t.bar() //~ ERROR cannot move a value of type dyn Bar\n+    t.bar() //~ ERROR cannot move a value of type `dyn Bar`\n }\n \n fn main() { }"}, {"sha": "94fdcdf263ae08843249df4f7d229f8c2181b64a", "filename": "src/test/ui/object-safety/object-safety-by-value-self-use.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-by-value-self-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-by-value-self-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-by-value-self-use.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -1,8 +1,8 @@\n-error[E0161]: cannot move a value of type dyn Bar: the size of dyn Bar cannot be statically determined\n+error[E0161]: cannot move a value of type `dyn Bar`\n   --> $DIR/object-safety-by-value-self-use.rs:15:5\n    |\n LL |     t.bar()\n-   |     ^^^^^^^\n+   |     ^^^^^^^ the size of `dyn Bar` cannot be statically determined\n \n error: aborting due to previous error\n "}, {"sha": "a6bd98ddb1977881ceb3a7d5d6ca5476e6a0258a", "filename": "src/test/ui/proc-macro/signature.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -5,10 +5,7 @@ LL | / pub unsafe extern \"C\" fn foo(a: i32, b: u32) -> u32 {\n LL | |\n LL | |     loop {}\n LL | | }\n-   | | ^\n-   | | |\n-   | |_call the function in a closure: `|| unsafe { /* code */ }`\n-   |   required by a bound introduced by this call\n+   | |_^ call the function in a closure: `|| unsafe { /* code */ }`\n    |\n    = help: the trait `Fn<(proc_macro::TokenStream,)>` is not implemented for `unsafe extern \"C\" fn(i32, u32) -> u32 {foo}`\n    = note: unsafe function cannot be called generically without an unsafe block"}, {"sha": "2448a5149654d318ef4067e2177a5e08815e4608", "filename": "src/test/ui/suggestions/args-instead-of-tuple.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -9,7 +9,7 @@ note: tuple variant defined here\n    |\n LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     let _: Result<(i32, i8), ()> = Ok((1, 2));\n    |                                       +    +\n@@ -25,7 +25,7 @@ note: tuple variant defined here\n    |\n LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^^^\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     let _: Option<(i32, i8, &'static str)> = Some((1, 2, \"hi\"));\n    |                                                   +          +\n@@ -97,7 +97,7 @@ note: function defined here\n    |\n LL | fn two_ints(_: (i32, i32)) {\n    |    ^^^^^^^^ -------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     two_ints((1, 2));\n    |              +    +\n@@ -113,7 +113,7 @@ note: function defined here\n    |\n LL | fn with_generic<T: Copy + Send>((a, b): (i32, T)) {\n    |    ^^^^^^^^^^^^                 ----------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     with_generic((3, 4));\n    |                  +    +\n@@ -129,7 +129,7 @@ note: function defined here\n    |\n LL | fn with_generic<T: Copy + Send>((a, b): (i32, T)) {\n    |    ^^^^^^^^^^^^                 ----------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |         with_generic((a, b));\n    |                      +    +"}, {"sha": "089c703fda5c7a8101544a7b9148f78b447ba4fe", "filename": "src/test/ui/tuple/add-tuple-within-arguments.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -0,0 +1,10 @@\n+fn foo(s: &str, a: (i32, i32), s2: &str) {}\n+\n+fn bar(s: &str, a: (&str,), s2: &str) {}\n+\n+fn main() {\n+    foo(\"hi\", 1, 2, \"hi\");\n+    //~^ ERROR this function takes 3 arguments but 4 arguments were supplied\n+    bar(\"hi\", \"hi\", \"hi\");\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "95df96ca0dd4f2c09574f8b70cff237b97a06f5e", "filename": "src/test/ui/tuple/add-tuple-within-arguments.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -0,0 +1,40 @@\n+error[E0061]: this function takes 3 arguments but 4 arguments were supplied\n+  --> $DIR/add-tuple-within-arguments.rs:6:5\n+   |\n+LL |     foo(\"hi\", 1, 2, \"hi\");\n+   |     ^^^\n+   |\n+note: function defined here\n+  --> $DIR/add-tuple-within-arguments.rs:1:4\n+   |\n+LL | fn foo(s: &str, a: (i32, i32), s2: &str) {}\n+   |    ^^^ -------  -------------  --------\n+help: wrap these arguments in parentheses to construct a tuple\n+   |\n+LL |     foo(\"hi\", (1, 2), \"hi\");\n+   |               +    +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/add-tuple-within-arguments.rs:8:15\n+   |\n+LL |     bar(\"hi\", \"hi\", \"hi\");\n+   |     ---       ^^^^ expected tuple, found `&str`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note:  expected tuple `(&str,)`\n+           found reference `&'static str`\n+note: function defined here\n+  --> $DIR/add-tuple-within-arguments.rs:3:4\n+   |\n+LL | fn bar(s: &str, a: (&str,), s2: &str) {}\n+   |    ^^^ -------  ----------  --------\n+help: use a trailing comma to create a tuple with one element\n+   |\n+LL |     bar(\"hi\", (\"hi\",), \"hi\");\n+   |               +    ++\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0061, E0308.\n+For more information about an error, try `rustc --explain E0061`."}, {"sha": "0c2a4c41461fc4d108f5656c5bb8917e899df08a", "filename": "src/test/ui/tuple/wrong_argument_ice-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-2.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -9,7 +9,7 @@ note: function defined here\n    |\n LL | fn test(t: (i32, i32)) {}\n    |    ^^^^ -------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     test((x.qux(), x.qux()));\n    |          +                +"}, {"sha": "ec07f1e70cff6a135376c7f51c3529237dfdd66c", "filename": "src/test/ui/tuple/wrong_argument_ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -9,7 +9,7 @@ note: associated function defined here\n    |\n LL |     pub fn push_back(&mut self, value: T) {\n    |            ^^^^^^^^^\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |         self.acc.push_back((self.current_provides, self.current_requires));\n    |                            +                                            +"}, {"sha": "f053f4b0af89c0de9b720c382ea1c910a4341fba", "filename": "src/test/ui/unsized/return-unsized-from-trait-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -7,7 +7,7 @@ trait Foo {\n fn foo(f: Option<&dyn Foo>) {\n     if let Some(f) = f {\n         let _ = f.foo();\n-        //~^ ERROR cannot move a value of type [u8]: the size of [u8] cannot be statically determined\n+        //~^ ERROR cannot move a value of type `[u8]`\n     }\n }\n "}, {"sha": "671d409937cac0083eeab0c727455905bb38af81", "filename": "src/test/ui/unsized/return-unsized-from-trait-method.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Freturn-unsized-from-trait-method.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -1,8 +1,8 @@\n-error[E0161]: cannot move a value of type [u8]: the size of [u8] cannot be statically determined\n+error[E0161]: cannot move a value of type `[u8]`\n   --> $DIR/return-unsized-from-trait-method.rs:9:17\n    |\n LL |         let _ = f.foo();\n-   |                 ^^^^^^^\n+   |                 ^^^^^^^ the size of `[u8]` cannot be statically determined\n \n error: aborting due to previous error\n "}, {"sha": "0221ef16b4965f30eb121b81b0b3843c40e6f42e", "filename": "src/test/ui/unsized/unsized-fn-param.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -2,7 +2,9 @@ error[E0277]: the size for values of type `str` cannot be known at compilation t\n   --> $DIR/unsized-fn-param.rs:11:11\n    |\n LL |     foo11(\"bar\", &\"baz\");\n-   |           ^^^^^ doesn't have a size known at compile-time\n+   |     ----- ^^^^^ doesn't have a size known at compile-time\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n    = note: required for the cast from `str` to the object type `dyn AsRef<Path>`\n@@ -15,7 +17,9 @@ error[E0277]: the size for values of type `str` cannot be known at compilation t\n   --> $DIR/unsized-fn-param.rs:13:19\n    |\n LL |     foo12(&\"bar\", \"baz\");\n-   |                   ^^^^^ doesn't have a size known at compile-time\n+   |     -----         ^^^^^ doesn't have a size known at compile-time\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n    = note: required for the cast from `str` to the object type `dyn AsRef<Path>`\n@@ -28,7 +32,9 @@ error[E0277]: the size for values of type `str` cannot be known at compilation t\n   --> $DIR/unsized-fn-param.rs:16:11\n    |\n LL |     foo21(\"bar\", &\"baz\");\n-   |           ^^^^^ doesn't have a size known at compile-time\n+   |     ----- ^^^^^ doesn't have a size known at compile-time\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n    = note: required for the cast from `str` to the object type `dyn AsRef<str>`\n@@ -41,7 +47,9 @@ error[E0277]: the size for values of type `str` cannot be known at compilation t\n   --> $DIR/unsized-fn-param.rs:18:19\n    |\n LL |     foo22(&\"bar\", \"baz\");\n-   |                   ^^^^^ doesn't have a size known at compile-time\n+   |     -----         ^^^^^ doesn't have a size known at compile-time\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n    = note: required for the cast from `str` to the object type `dyn AsRef<str>`"}, {"sha": "af76aca2c295803a25e0ab072dfd67f837a3ed62", "filename": "src/test/ui/unsized/unsized3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Funsized%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Funsized%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized3.rs?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -44,6 +44,7 @@ fn f9<X: ?Sized>(x1: Box<S<X>>) {\n fn f10<X: ?Sized>(x1: Box<S<X>>) {\n     f5(&(32, *x1));\n     //~^ ERROR the size for values of type\n+    //~| ERROR the size for values of type\n }\n \n pub fn main() {}"}, {"sha": "d64091b15eb1fc2c747980353ca77551e9d41dea", "filename": "src/test/ui/unsized/unsized3.stderr", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Funsized%2Funsized3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcf43bb0f3e86c16a88f239da18a1729a94d244/src%2Ftest%2Fui%2Funsized%2Funsized3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized3.stderr?ref=3fcf43bb0f3e86c16a88f239da18a1729a94d244", "patch": "@@ -100,6 +100,29 @@ LL - fn f9<X: ?Sized>(x1: Box<S<X>>) {\n LL + fn f9<X>(x1: Box<S<X>>) {\n    |\n \n+error[E0277]: the size for values of type `X` cannot be known at compilation time\n+  --> $DIR/unsized3.rs:45:9\n+   |\n+LL | fn f10<X: ?Sized>(x1: Box<S<X>>) {\n+   |        - this type parameter needs to be `std::marker::Sized`\n+LL |     f5(&(32, *x1));\n+   |     --  ^^^^^^^^^ doesn't have a size known at compile-time\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required because it appears within the type `S<X>`\n+  --> $DIR/unsized3.rs:28:8\n+   |\n+LL | struct S<X: ?Sized> {\n+   |        ^\n+   = note: required because it appears within the type `({integer}, S<X>)`\n+   = note: tuples must have a statically known size to be initialized\n+help: consider removing the `?Sized` bound to make the type parameter `Sized`\n+   |\n+LL - fn f10<X: ?Sized>(x1: Box<S<X>>) {\n+LL + fn f10<X>(x1: Box<S<X>>) {\n+   |\n+\n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized3.rs:45:8\n    |\n@@ -116,13 +139,21 @@ note: required because it appears within the type `S<X>`\n LL | struct S<X: ?Sized> {\n    |        ^\n    = note: required because it appears within the type `({integer}, S<X>)`\n-   = note: tuples must have a statically known size to be initialized\n+note: required by a bound in `f5`\n+  --> $DIR/unsized3.rs:24:7\n+   |\n+LL | fn f5<Y>(x: &Y) {}\n+   |       ^ required by this bound in `f5`\n help: consider removing the `?Sized` bound to make the type parameter `Sized`\n    |\n LL - fn f10<X: ?Sized>(x1: Box<S<X>>) {\n LL + fn f10<X>(x1: Box<S<X>>) {\n    |\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn f5<Y: ?Sized>(x: &Y) {}\n+   |        ++++++++\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}]}