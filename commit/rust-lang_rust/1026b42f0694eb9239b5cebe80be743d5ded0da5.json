{"sha": "1026b42f0694eb9239b5cebe80be743d5ded0da5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMjZiNDJmMDY5NGViOTIzOWI1Y2ViZTgwYmU3NDNkNWRlZDBkYTU=", "commit": {"author": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-06-10T03:32:24Z"}, "committer": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-09-24T21:02:05Z"}, "message": "Rename a struct and variables", "tree": {"sha": "1af141762d84dfdeabb0456af51e3db83b3198e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1af141762d84dfdeabb0456af51e3db83b3198e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1026b42f0694eb9239b5cebe80be743d5ded0da5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1026b42f0694eb9239b5cebe80be743d5ded0da5", "html_url": "https://github.com/rust-lang/rust/commit/1026b42f0694eb9239b5cebe80be743d5ded0da5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1026b42f0694eb9239b5cebe80be743d5ded0da5/comments", "author": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9573a0d378033a81e55ca834a5d305d3cf2be24d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9573a0d378033a81e55ca834a5d305d3cf2be24d", "html_url": "https://github.com/rust-lang/rust/commit/9573a0d378033a81e55ca834a5d305d3cf2be24d"}], "stats": {"total": 65, "additions": 33, "deletions": 32}, "files": [{"sha": "d9896f7fd6b14becb09893888cc284193569ebe8", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1026b42f0694eb9239b5cebe80be743d5ded0da5/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1026b42f0694eb9239b5cebe80be743d5ded0da5/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=1026b42f0694eb9239b5cebe80be743d5ded0da5", "patch": "@@ -820,9 +820,9 @@ impl Offset {\n     }\n }\n \n-struct FixedOffsetVar<'hir> {\n-    var: &'hir Expr<'hir>,\n-    offset: Offset,\n+struct IndexExpr<'hir> {\n+    base: &'hir Expr<'hir>,\n+    idx_offset: Offset,\n }\n \n fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n@@ -845,35 +845,35 @@ fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     }\n }\n \n-fn get_offset<'tcx>(cx: &LateContext<'tcx>, idx: &Expr<'_>, var: HirId) -> Option<Offset> {\n-    fn extract_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, var: HirId) -> Option<String> {\n+fn get_offset<'tcx>(cx: &LateContext<'tcx>, idx: &Expr<'_>, start: HirId) -> Option<Offset> {\n+    fn extract_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, start: HirId) -> Option<String> {\n         match &e.kind {\n             ExprKind::Lit(l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n                 _ => None,\n             },\n-            ExprKind::Path(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n+            ExprKind::Path(..) if !same_var(cx, e, start) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n             _ => None,\n         }\n     }\n \n     match idx.kind {\n         ExprKind::Binary(op, lhs, rhs) => match op.node {\n             BinOpKind::Add => {\n-                let offset_opt = if same_var(cx, lhs, var) {\n-                    extract_offset(cx, rhs, var)\n-                } else if same_var(cx, rhs, var) {\n-                    extract_offset(cx, lhs, var)\n+                let offset_opt = if same_var(cx, lhs, start) {\n+                    extract_offset(cx, rhs, start)\n+                } else if same_var(cx, rhs, start) {\n+                    extract_offset(cx, lhs, start)\n                 } else {\n                     None\n                 };\n \n                 offset_opt.map(Offset::positive)\n             },\n-            BinOpKind::Sub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n+            BinOpKind::Sub if same_var(cx, lhs, start) => extract_offset(cx, rhs, start).map(Offset::negative),\n             _ => None,\n         },\n-        ExprKind::Path(..) if same_var(cx, idx, var) => Some(Offset::positive(\"0\".into())),\n+        ExprKind::Path(..) if same_var(cx, idx, start) => Some(Offset::positive(\"0\".into())),\n         _ => None,\n     }\n }\n@@ -916,8 +916,8 @@ fn build_manual_memcpy_suggestion<'tcx>(\n     start: &Expr<'_>,\n     end: &Expr<'_>,\n     limits: ast::RangeLimits,\n-    dst_var: FixedOffsetVar<'_>,\n-    src_var: FixedOffsetVar<'_>,\n+    dst: IndexExpr<'_>,\n+    src: IndexExpr<'_>,\n ) -> String {\n     fn print_sum(arg1: &str, arg2: &Offset) -> String {\n         match (arg1, &arg2.value[..], arg2.sign) {\n@@ -944,13 +944,13 @@ fn build_manual_memcpy_suggestion<'tcx>(\n         }\n     }\n \n-    let print_limit = |end: &Expr<'_>, offset: Offset, var: &Expr<'_>| {\n+    let print_limit = |end: &Expr<'_>, offset: Offset, base: &Expr<'_>| {\n         if_chain! {\n             if let ExprKind::MethodCall(method, _, len_args, _) = end.kind;\n             if method.ident.name == sym!(len);\n             if len_args.len() == 1;\n             if let Some(arg) = len_args.get(0);\n-            if var_def_id(cx, arg) == var_def_id(cx, var);\n+            if var_def_id(cx, arg) == var_def_id(cx, base);\n             then {\n                 match offset.sign {\n                     OffsetSign::Negative => format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value),\n@@ -971,25 +971,26 @@ fn build_manual_memcpy_suggestion<'tcx>(\n     };\n \n     let start_str = snippet(cx, start.span, \"\").to_string();\n-    let dst_offset = print_offset(&start_str, &dst_var.offset);\n-    let dst_limit = print_limit(end, dst_var.offset, dst_var.var);\n-    let src_offset = print_offset(&start_str, &src_var.offset);\n-    let src_limit = print_limit(end, src_var.offset, src_var.var);\n+    let dst_offset = print_offset(&start_str, &dst.idx_offset);\n+    let dst_limit = print_limit(end, dst.idx_offset, dst.base);\n+    let src_offset = print_offset(&start_str, &src.idx_offset);\n+    let src_limit = print_limit(end, src.idx_offset, src.base);\n \n-    let dst_var_name = snippet_opt(cx, dst_var.var.span).unwrap_or_else(|| \"???\".into());\n-    let src_var_name = snippet_opt(cx, src_var.var.span).unwrap_or_else(|| \"???\".into());\n+    let dst_base_str = snippet_opt(cx, dst.base.span).unwrap_or_else(|| \"???\".into());\n+    let src_base_str = snippet_opt(cx, src.base.span).unwrap_or_else(|| \"???\".into());\n \n     let dst = if dst_offset == \"\" && dst_limit == \"\" {\n-        dst_var_name\n+        dst_base_str\n     } else {\n-        format!(\"{}[{}..{}]\", dst_var_name, dst_offset, dst_limit)\n+        format!(\"{}[{}..{}]\", dst_base_str, dst_offset, dst_limit)\n     };\n \n     format!(\n         \"{}.clone_from_slice(&{}[{}..{}])\",\n-        dst, src_var_name, src_offset, src_limit\n+        dst, src_base_str, src_offset, src_limit\n     )\n }\n+\n /// Checks for for loops that sequentially copy items from one slice-like\n /// object to another.\n fn detect_manual_memcpy<'tcx>(\n@@ -1014,18 +1015,18 @@ fn detect_manual_memcpy<'tcx>(\n                     o.and_then(|(lhs, rhs)| {\n                         let rhs = fetch_cloned_expr(rhs);\n                         if_chain! {\n-                            if let ExprKind::Index(seqexpr_left, idx_left) = lhs.kind;\n-                            if let ExprKind::Index(seqexpr_right, idx_right) = rhs.kind;\n-                            if is_slice_like(cx, cx.typeck_results().expr_ty(seqexpr_left))\n-                                && is_slice_like(cx, cx.typeck_results().expr_ty(seqexpr_right));\n+                            if let ExprKind::Index(base_left, idx_left) = lhs.kind;\n+                            if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left))\n+                                && is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n                             if let Some(offset_left) = get_offset(cx, &idx_left, canonical_id);\n                             if let Some(offset_right) = get_offset(cx, &idx_right, canonical_id);\n \n                             // Source and destination must be different\n-                            if var_def_id(cx, seqexpr_left) != var_def_id(cx, seqexpr_right);\n+                            if var_def_id(cx, base_left) != var_def_id(cx, base_right);\n                             then {\n-                                Some((FixedOffsetVar { var: seqexpr_left, offset: offset_left },\n-                                    FixedOffsetVar { var: seqexpr_right, offset: offset_right }))\n+                                Some((IndexExpr { base: base_left, idx_offset: offset_left },\n+                                    IndexExpr { base: base_right, idx_offset: offset_right }))\n                             } else {\n                                 None\n                             }"}]}