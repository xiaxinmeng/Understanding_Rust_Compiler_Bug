{"sha": "2bb056f4ab416b08a499b2229a3cca6404ce3c54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYjA1NmY0YWI0MTZiMDhhNDk5YjIyMjlhM2NjYTY0MDRjZTNjNTQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-27T19:16:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-27T21:27:42Z"}, "message": "rustc: Avoid an allocation on every GEPi", "tree": {"sha": "312d318c628316aae268fcd76cc092b70b747e0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/312d318c628316aae268fcd76cc092b70b747e0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bb056f4ab416b08a499b2229a3cca6404ce3c54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bb056f4ab416b08a499b2229a3cca6404ce3c54", "html_url": "https://github.com/rust-lang/rust/commit/2bb056f4ab416b08a499b2229a3cca6404ce3c54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bb056f4ab416b08a499b2229a3cca6404ce3c54/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8453097dd52f6fdd6a710c382978af02d7f55844", "url": "https://api.github.com/repos/rust-lang/rust/commits/8453097dd52f6fdd6a710c382978af02d7f55844", "html_url": "https://github.com/rust-lang/rust/commit/8453097dd52f6fdd6a710c382978af02d7f55844"}], "stats": {"total": 224, "additions": 110, "deletions": 114}, "files": [{"sha": "5bd13aaa24a5f99fbdd4bafe59079b6b879f518d", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=2bb056f4ab416b08a499b2229a3cca6404ce3c54", "patch": "@@ -317,7 +317,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     if size > 0u && (*variants).len() != 1u {\n         let enumptr =\n             PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n-        blobptr = GEPi(bcx, enumptr, ~[0u, 1u]);\n+        blobptr = GEPi(bcx, enumptr, [0u, 1u]);\n     }\n     let vdefs_tg = vdefs.enm;\n     let vdefs_var = vdefs.var;\n@@ -525,7 +525,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         let mut rec_vals = ~[];\n         for vec::each(rec_fields) |field_name| {\n             let ix = option::get(ty::field_idx(field_name, fields));\n-            vec::push(rec_vals, GEPi(bcx, val, ~[0u, ix]));\n+            vec::push(rec_vals, GEPi(bcx, val, [0u, ix]));\n         }\n         compile_submatch(bcx,\n                          enter_rec_or_struct(bcx, dm, m, col, rec_fields,\n@@ -581,7 +581,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         };\n         let mut tup_vals = ~[], i = 0u;\n         while i < n_tup_elts {\n-            vec::push(tup_vals, GEPi(bcx, val, ~[0u, i]));\n+            vec::push(tup_vals, GEPi(bcx, val, [0u, i]));\n             i += 1u;\n         }\n         compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n@@ -594,7 +594,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         let llbox = Load(bcx, val);\n         let box_no_addrspace = non_gc_box_cast(bcx, llbox);\n         let unboxed =\n-            GEPi(bcx, box_no_addrspace, ~[0u, abi::box_field_body]);\n+            GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_box(bcx, dm, m, col, val),\n                          vec::append(~[unboxed], vals_left), chk, exits);\n         return;\n@@ -604,7 +604,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         let llbox = Load(bcx, val);\n         let box_no_addrspace = non_gc_box_cast(bcx, llbox);\n         let unboxed =\n-            GEPi(bcx, box_no_addrspace, ~[0u, abi::box_field_body]);\n+            GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n                          vec::append(~[unboxed], vals_left), chk, exits);\n         return;\n@@ -623,7 +623,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n             } else {\n                 let enumptr =\n                     PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n-                let discrimptr = GEPi(bcx, enumptr, ~[0u, 0u]);\n+                let discrimptr = GEPi(bcx, enumptr, [0u, 0u]);\n                 test_val = Load(bcx, discrimptr);\n                 kind = switch;\n             }\n@@ -932,7 +932,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         let rec_fields = ty::get_fields(node_id_type(bcx, pat.id));\n         for vec::each(fields) |f| {\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n-            let fldptr = GEPi(bcx, val, ~[0u, ix]);\n+            let fldptr = GEPi(bcx, val, [0u, ix]);\n             bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, make_copy);\n         }\n       }\n@@ -967,21 +967,21 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n       ast::pat_tup(elems) => {\n         let mut i = 0u;\n         for vec::each(elems) |elem| {\n-            let fldptr = GEPi(bcx, val, ~[0u, i]);\n+            let fldptr = GEPi(bcx, val, [0u, i]);\n             bcx = bind_irrefutable_pat(bcx, elem, fldptr, make_copy);\n             i += 1u;\n         }\n       }\n       ast::pat_box(inner) => {\n         let llbox = Load(bcx, val);\n         let unboxed =\n-            GEPi(bcx, llbox, ~[0u, abi::box_field_body]);\n+            GEPi(bcx, llbox, [0u, abi::box_field_body]);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_uniq(inner) => {\n         let llbox = Load(bcx, val);\n         let unboxed =\n-            GEPi(bcx, llbox, ~[0u, abi::box_field_body]);\n+            GEPi(bcx, llbox, [0u, abi::box_field_body]);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) => ()"}, {"sha": "5afab464748948d364973deefcb0c8c3bcff70cd", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2bb056f4ab416b08a499b2229a3cca6404ce3c54", "patch": "@@ -362,7 +362,7 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     });\n     let typed_blobptr = PointerCast(bcx, llblobptr,\n                                     T_ptr(T_struct(arg_lltys)));\n-    GEPi(bcx, typed_blobptr, ~[0u, ix])\n+    GEPi(bcx, typed_blobptr, [0u, ix])\n }\n \n // Returns a pointer to the body for the box. The box may be an opaque\n@@ -376,7 +376,7 @@ fn opaque_box_body(bcx: block,\n     let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let boxptr = PointerCast(bcx, boxptr, T_ptr(T_box_header(ccx)));\n-    let bodyptr = GEPi(bcx, boxptr, ~[1u]);\n+    let bodyptr = GEPi(bcx, boxptr, [1u]);\n     PointerCast(bcx, bodyptr, T_ptr(type_of(ccx, body_t)))\n }\n \n@@ -422,7 +422,7 @@ fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     let _icx = bcx.insn_ctxt(\"malloc_general\");\n     let {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n     let non_gc_box = non_gc_box_cast(bcx, llbox);\n-    let body = GEPi(bcx, non_gc_box, ~[0u, abi::box_field_body]);\n+    let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n     return {bcx: bcx, box: llbox, body: body};\n }\n \n@@ -732,7 +732,7 @@ fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n         closure::make_fn_glue(bcx, v, t, take_ty)\n       }\n       ty::ty_trait(_, _, _) => {\n-        let llbox = Load(bcx, GEPi(bcx, v, ~[0u, 1u]));\n+        let llbox = Load(bcx, GEPi(bcx, v, [0u, 1u]));\n         incr_refcnt_of_boxed(bcx, llbox);\n         bcx\n       }\n@@ -752,7 +752,7 @@ fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n     let _icx = cx.insn_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     maybe_validate_box(cx, box_ptr);\n-    let rc_ptr = GEPi(cx, box_ptr, ~[0u, abi::box_field_refcnt]);\n+    let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n     let rc = Load(cx, rc_ptr);\n     let rc = Add(cx, rc, C_int(ccx, 1));\n     Store(cx, rc, rc_ptr);\n@@ -777,16 +777,16 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let bcx = match ty::get(t).struct {\n       ty::ty_box(body_mt) => {\n         let v = Load(bcx, v);\n-        let body = GEPi(bcx, v, ~[0u, abi::box_field_body]);\n+        let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n         // Cast away the addrspace of the box pointer.\n         let body = PointerCast(bcx, body, T_ptr(type_of(ccx, body_mt.ty)));\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         trans_free(bcx, v)\n       }\n       ty::ty_opaque_box => {\n         let v = Load(bcx, v);\n-        let td = Load(bcx, GEPi(bcx, v, ~[0u, abi::box_field_tydesc]));\n-        let valptr = GEPi(bcx, v, ~[0u, abi::box_field_body]);\n+        let td = Load(bcx, GEPi(bcx, v, [0u, abi::box_field_tydesc]));\n+        let valptr = GEPi(bcx, v, [0u, abi::box_field_body]);\n         // Generate code that, dynamically, indexes into the\n         // tydesc and calls the drop glue that got set dynamically\n         call_tydesc_glue_full(bcx, valptr, td, abi::tydesc_field_drop_glue,\n@@ -822,11 +822,11 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n                     class_did: ast::def_id,\n                     substs: &ty::substs) -> block {\n-  let drop_flag = GEPi(bcx, v0, ~[0u, 0u]);\n+  let drop_flag = GEPi(bcx, v0, [0u, 0u]);\n     do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n     let mut bcx = cx;\n       // We have to cast v0\n-     let classptr = GEPi(bcx, v0, ~[0u, 1u]);\n+     let classptr = GEPi(bcx, v0, [0u, 1u]);\n      // Find and call the actual destructor\n      let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, class_did, substs.tps);\n      // The second argument is the \"self\" argument for drop\n@@ -843,7 +843,7 @@ fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n      for vec::eachi(ty::class_items_as_mutable_fields(bcx.tcx(), class_did,\n                                                       substs))\n          |i, fld| {\n-        let llfld_a = GEPi(bcx, classptr, ~[0u, i]);\n+        let llfld_a = GEPi(bcx, classptr, [0u, i]);\n         bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n      }\n      Store(bcx, C_u8(0u), drop_flag);\n@@ -884,7 +884,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n         closure::make_fn_glue(bcx, v0, t, drop_ty)\n       }\n       ty::ty_trait(_, _, _) => {\n-        let llbox = Load(bcx, GEPi(bcx, v0, ~[0u, 1u]));\n+        let llbox = Load(bcx, GEPi(bcx, v0, [0u, 1u]));\n         decr_refcnt_maybe_free(bcx, llbox, ty::mk_opaque_box(ccx.tcx))\n       }\n       ty::ty_opaque_closure_ptr(ck) => {\n@@ -940,7 +940,7 @@ fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n     maybe_validate_box(bcx, box_ptr);\n \n     do with_cond(bcx, IsNotNull(bcx, box_ptr)) |bcx| {\n-        let rc_ptr = GEPi(bcx, box_ptr, ~[0u, abi::box_field_refcnt]);\n+        let rc_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_refcnt]);\n         let rc = Sub(bcx, Load(bcx, rc_ptr), C_int(ccx, 1));\n         Store(bcx, rc, rc_ptr);\n         let zero_test = ICmp(bcx, lib::llvm::IntEQ, C_int(ccx, 0), rc);\n@@ -1046,12 +1046,11 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n type val_pair_fn = fn@(block, ValueRef, ValueRef) -> block;\n type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> block;\n \n-fn load_inbounds(cx: block, p: ValueRef, idxs: ~[uint]) -> ValueRef {\n+fn load_inbounds(cx: block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n     return Load(cx, GEPi(cx, p, idxs));\n }\n \n-fn store_inbounds(cx: block, v: ValueRef, p: ValueRef,\n-                  idxs: ~[uint]) {\n+fn store_inbounds(cx: block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n     Store(cx, v, GEPi(cx, p, idxs));\n }\n \n@@ -1092,7 +1091,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     match ty::get(t).struct {\n       ty::ty_rec(fields) => {\n         for vec::eachi(fields) |i, fld| {\n-            let llfld_a = GEPi(cx, av, ~[0u, i]);\n+            let llfld_a = GEPi(cx, av, [0u, i]);\n             cx = f(cx, llfld_a, fld.mt.ty);\n         }\n       }\n@@ -1103,7 +1102,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       }\n       ty::ty_tup(args) => {\n         for vec::eachi(args) |i, arg| {\n-            let llfld_a = GEPi(cx, av, ~[0u, i]);\n+            let llfld_a = GEPi(cx, av, [0u, i]);\n             cx = f(cx, llfld_a, arg);\n         }\n       }\n@@ -1120,8 +1119,8 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         let ccx = cx.ccx();\n         let llenumty = T_opaque_enum_ptr(ccx);\n         let av_enum = PointerCast(cx, av, llenumty);\n-        let lldiscrim_a_ptr = GEPi(cx, av_enum, ~[0u, 0u]);\n-        let llunion_a_ptr = GEPi(cx, av_enum, ~[0u, 1u]);\n+        let lldiscrim_a_ptr = GEPi(cx, av_enum, [0u, 0u]);\n+        let llunion_a_ptr = GEPi(cx, av_enum, [0u, 1u]);\n         let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n \n         // NB: we must hit the discriminant first so that structural\n@@ -1147,13 +1146,13 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       ty::ty_class(did, ref substs) => {\n           // Take the drop bit into account\n           let classptr = if is_some(ty::ty_dtor(cx.tcx(), did)) {\n-                  GEPi(cx, av, ~[0u, 1u])\n+                  GEPi(cx, av, [0u, 1u])\n               }\n           else { av };\n         for vec::eachi(ty::class_items_as_mutable_fields(cx.tcx(), did,\n                                                          substs))\n             |i, fld| {\n-               let llfld_a = GEPi(cx, classptr, ~[0u, i]);\n+               let llfld_a = GEPi(cx, classptr, [0u, i]);\n                cx = f(cx, llfld_a, fld.mt.ty);\n            }\n       }\n@@ -1282,7 +1281,7 @@ fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n         match static_glue_fn {\n           None => {\n             // Select out the glue function to call from the tydesc\n-            let llfnptr = GEPi(bcx, tydesc, ~[0u, field]);\n+            let llfnptr = GEPi(bcx, tydesc, [0u, field]);\n             Load(bcx, llfnptr)\n           }\n           Some(sgf) => sgf\n@@ -1880,7 +1879,7 @@ fn autoderef(cx: block, e_id: ast::node_id,\n \n         match ty::get(t1).struct {\n           ty::ty_box(mt) => {\n-            let body = GEPi(cx, v1, ~[0u, abi::box_field_body]);\n+            let body = GEPi(cx, v1, [0u, abi::box_field_body]);\n             t1 = mt.ty;\n \n             // Since we're changing levels of box indirection, we may have\n@@ -2603,7 +2602,7 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n             // Nullary variant.\n             let enum_ty = node_id_type(cx, id);\n             let llenumptr = alloc_ty(cx, enum_ty);\n-            let lldiscrimptr = GEPi(cx, llenumptr, ~[0u, 0u]);\n+            let lldiscrimptr = GEPi(cx, llenumptr, [0u, 0u]);\n             let lldiscrim_gv = lookup_discriminant(ccx, vid);\n             let lldiscrim = Load(cx, lldiscrim_gv);\n             Store(cx, lldiscrim, lldiscrimptr);\n@@ -2664,9 +2663,9 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n        (If any other code does the same thing, that's\n        a bug */\n     let val = if llderef {\n-        GEPi(bcx, GEPi(bcx, val, ~[0u, 1u]), ~[0u, ix])\n+        GEPi(bcx, GEPi(bcx, val, [0u, 1u]), [0u, ix])\n     }\n-    else { GEPi(bcx, val, ~[0u, ix]) };\n+    else { GEPi(bcx, val, [0u, ix]) };\n \n     return {bcx: bcx, val: val, kind: lv_owned};\n }\n@@ -2801,11 +2800,11 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n             let val = match ty::get(t).struct {\n               ty::ty_box(_) => {\n                 let non_gc_val = non_gc_box_cast(sub.bcx, sub.val);\n-                GEPi(sub.bcx, non_gc_val, ~[0u, abi::box_field_body])\n+                GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n               }\n               ty::ty_uniq(_) => {\n                 let non_gc_val = non_gc_box_cast(sub.bcx, sub.val);\n-                GEPi(sub.bcx, non_gc_val, ~[0u, abi::box_field_body])\n+                GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n               }\n               ty::ty_enum(_, _) => {\n                 let ety = expr_ty(cx, e);\n@@ -2946,7 +2945,7 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n             let cx = e_res.bcx;\n             let llenumty = T_opaque_enum_ptr(ccx);\n             let av_enum = PointerCast(cx, e_res.val, llenumty);\n-            let lldiscrim_a_ptr = GEPi(cx, av_enum, ~[0u, 0u]);\n+            let lldiscrim_a_ptr = GEPi(cx, av_enum, [0u, 0u]);\n             let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n             match k_out {\n               cast_integral => int_cast(e_res.bcx, ll_t_out,\n@@ -3103,7 +3102,7 @@ fn adapt_borrowed_value(lv: lval_result,\n     match ty::get(e_ty).struct {\n       ty::ty_uniq(mt) | ty::ty_box(mt) => {\n         let box_ptr = load_value_from_lval_result(lv, e_ty);\n-        let body_ptr = GEPi(bcx, box_ptr, ~[0u, abi::box_field_body]);\n+        let body_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_body]);\n         let rptr_ty = ty::mk_rptr(bcx.tcx(), ty::re_static, mt);\n         return {lv: lval_temp(bcx, body_ptr), ty: rptr_ty};\n       }\n@@ -3125,8 +3124,8 @@ fn adapt_borrowed_value(lv: lval_result,\n                val_str(bcx.ccx().tn, val),\n                val_str(bcx.ccx().tn, p));\n \n-        Store(bcx, base, GEPi(bcx, p, ~[0u, abi::slice_elt_base]));\n-        Store(bcx, len, GEPi(bcx, p, ~[0u, abi::slice_elt_len]));\n+        Store(bcx, base, GEPi(bcx, p, [0u, abi::slice_elt_base]));\n+        Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]));\n \n         // this isn't necessarily the type that rust would assign but it's\n         // close enough for trans purposes, as it will have the same runtime\n@@ -3297,9 +3296,9 @@ fn trans_call_inner(\n                 faddr = load_if_immediate(bcx, faddr, fn_expr_ty);\n             }\n             let pair = faddr;\n-            faddr = GEPi(bcx, pair, ~[0u, abi::fn_field_code]);\n+            faddr = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n             faddr = Load(bcx, faddr);\n-            let llclosure = GEPi(bcx, pair, ~[0u, abi::fn_field_box]);\n+            let llclosure = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n             Load(bcx, llclosure)\n           }\n         };\n@@ -3494,7 +3493,7 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n     };\n     let mut temp_cleanups = ~[];\n     for vec::eachi(elts) |i, e| {\n-        let dst = GEPi(bcx, addr, ~[0u, i]);\n+        let dst = GEPi(bcx, addr, [0u, i]);\n         let e_ty = expr_ty(bcx, e);\n         bcx = trans_expr_save_in(bcx, e, dst);\n         add_clean_temp_mem(bcx, dst, e_ty);\n@@ -3530,7 +3529,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n     for fields.each |fld| {\n         let ix = option::get(vec::position(ty_fields,\n             |ft| ft.ident == fld.node.ident));\n-        let dst = GEPi(bcx, addr, ~[0u, ix]);\n+        let dst = GEPi(bcx, addr, [0u, ix]);\n         bcx = trans_expr_save_in(bcx, fld.node.expr, dst);\n         add_clean_temp_mem(bcx, dst, ty_fields[ix].mt.ty);\n         vec::push(temp_cleanups, dst);\n@@ -3542,8 +3541,8 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n         // Copy over inherited fields\n         for ty_fields.eachi |i, tf| {\n             if !vec::any(fields, |f| f.node.ident == tf.ident) {\n-                let dst = GEPi(bcx, addr, ~[0u, i]);\n-                let base = GEPi(bcx, base_val, ~[0u, i]);\n+                let dst = GEPi(bcx, addr, [0u, i]);\n+                let base = GEPi(bcx, base_val, [0u, i]);\n                 let val = load_if_immediate(bcx, base, tf.mt.ty);\n                 bcx = copy_val(bcx, INIT, dst, val, tf.mt.ty);\n             }\n@@ -3564,10 +3563,10 @@ fn get_struct_field(block_context: block, dest_address: ValueRef,\n                     class_id: ast::def_id, index: uint) -> ValueRef {\n     if ty::ty_dtor(block_context.tcx(), class_id).is_some() {\n         return GEPi(block_context,\n-                    GEPi(block_context, dest_address, ~[0, 1]),\n-                    ~[0, index]);\n+                    GEPi(block_context, dest_address, [0, 1]),\n+                    [0, index]);\n     }\n-    return GEPi(block_context, dest_address, ~[0, index]);\n+    return GEPi(block_context, dest_address, [0, index]);\n }\n \n fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n@@ -3615,7 +3614,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n \n     // Add the drop flag if necessary.\n     if ty::ty_dtor(block_context.tcx(), class_id).is_some() {\n-        let llflagptr = GEPi(block_context, dest_address, ~[0, 0]);\n+        let llflagptr = GEPi(block_context, dest_address, [0, 0]);\n         Store(block_context, C_u8(1), llflagptr);\n     }\n \n@@ -3674,7 +3673,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n                                                         i);\n                 let llbasefieldvalue = GEPi(block_context,\n                                             llbasevalue,\n-                                            ~[0, i]);\n+                                            [0, i]);\n                 let field_type = ty::lookup_field_type(block_context.tcx(),\n                                                        class_id,\n                                                        class_field.id,\n@@ -4964,9 +4963,9 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n     } else {\n         let llenumptr =\n             PointerCast(bcx, fcx.llretptr, T_opaque_enum_ptr(ccx));\n-        let lldiscrimptr = GEPi(bcx, llenumptr, ~[0u, 0u]);\n+        let lldiscrimptr = GEPi(bcx, llenumptr, [0u, 0u]);\n         Store(bcx, C_int(ccx, disr), lldiscrimptr);\n-        GEPi(bcx, llenumptr, ~[0u, 1u])\n+        GEPi(bcx, llenumptr, [0u, 1u])\n     };\n     let t_id = local_def(enum_id);\n     let v_id = local_def(variant.node.id);\n@@ -5023,10 +5022,10 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                                   parent_id)) {\n     // Initialize the drop flag\n     let one = C_u8(1u);\n-    let flag = GEPi(bcx_top, selfptr, ~[0u, 0u]);\n+    let flag = GEPi(bcx_top, selfptr, [0u, 0u]);\n     Store(bcx_top, one, flag);\n     // Select the pointer to the class itself\n-    GEPi(bcx_top, selfptr, ~[0u, 1u])\n+    GEPi(bcx_top, selfptr, [0u, 1u])\n   }\n   else { selfptr };\n \n@@ -5039,7 +5038,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   // drop their LHS\n     for fields.each |field| {\n      let ix = field_idx_strict(bcx.tcx(), sp, field.ident, fields);\n-     bcx = zero_mem(bcx, GEPi(bcx, valptr, ~[0u, ix]), field.mt.ty);\n+     bcx = zero_mem(bcx, GEPi(bcx, valptr, [0u, ix]), field.mt.ty);\n   }\n \n   // note we don't want to take *or* drop self.\n@@ -5352,9 +5351,9 @@ fn create_real_fn_pair(cx: block, llfnty: TypeRef, llfn: ValueRef,\n fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n                 llenvptr: ValueRef) {\n     let ccx = bcx.ccx();\n-    let code_cell = GEPi(bcx, pair, ~[0u, abi::fn_field_code]);\n+    let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n     Store(bcx, llfn, code_cell);\n-    let env_cell = GEPi(bcx, pair, ~[0u, abi::fn_field_box]);\n+    let env_cell = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n     let llenvblobptr = PointerCast(bcx, llenvptr, T_opaque_box_ptr(ccx));\n     Store(bcx, llenvblobptr, env_cell);\n }"}, {"sha": "b22560d491dee13e33826f8c84edfa1f0cc48e33", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=2bb056f4ab416b08a499b2229a3cca6404ce3c54", "patch": "@@ -431,20 +431,22 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n \n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n-fn GEPi(cx: block, base: ValueRef, ixs: ~[uint]) -> ValueRef {\n+//\n+// XXX: Use a small-vector optimization to avoid allocations here.\n+fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     let mut v: ~[ValueRef] = ~[];\n     for vec::each(ixs) |i| { vec::push(v, C_i32(i as i32)); }\n     count_insn(cx, \"gepi\");\n     return InBoundsGEP(cx, base, v);\n }\n \n-fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) ->\n+fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n    ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n         count_insn(cx, \"inboundsgep\");\n     return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n-                                       vec::unsafe::to_ptr(Indices),\n+                                       vec::unsafe::to_ptr_slice(Indices),\n                                        Indices.len() as c_uint,\n                                        noname());\n     }"}, {"sha": "17424dcc023524a7d9ebaa6f80fed5ae4ff147f0", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=2bb056f4ab416b08a499b2229a3cca6404ce3c54", "patch": "@@ -145,7 +145,7 @@ fn allocate_cbox(bcx: block,\n         // Initialize ref count to arbitrary value for debugging:\n         let ccx = bcx.ccx();\n         let llbox = PointerCast(bcx, llbox, T_opaque_box_ptr(ccx));\n-        let ref_cnt = GEPi(bcx, llbox, ~[0u, abi::box_field_refcnt]);\n+        let ref_cnt = GEPi(bcx, llbox, [0u, abi::box_field_refcnt]);\n         let rc = C_int(ccx, 0x12345678);\n         Store(bcx, rc, ref_cnt);\n     }\n@@ -207,8 +207,7 @@ fn store_environment(bcx: block,\n                                   ev_to_str(ccx, bv)));\n         }\n \n-        let bound_data = GEPi(bcx, llbox,\n-             ~[0u, abi::box_field_body, i]);\n+        let bound_data = GEPi(bcx, llbox, [0u, abi::box_field_body, i]);\n         match bv {\n           env_copy(val, ty, lv_owned) => {\n             let val1 = load_if_immediate(bcx, val, ty);\n@@ -326,8 +325,7 @@ fn load_environment(fcx: fn_ctxt,\n         match cap_var.mode {\n           capture::cap_drop => { /* ignore */ }\n           _ => {\n-            let mut upvarptr =\n-                GEPi(bcx, llcdata, ~[0u, i]);\n+            let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n             match ck {\n               ty::ck_block => { upvarptr = Load(bcx, upvarptr); }\n               ty::ck_uniq | ty::ck_box => ()\n@@ -339,11 +337,9 @@ fn load_environment(fcx: fn_ctxt,\n         }\n     }\n     if load_ret_handle {\n-        let flagptr = Load(bcx, GEPi(bcx, llcdata,\n-                                     ~[0u, i]));\n+        let flagptr = Load(bcx, GEPi(bcx, llcdata, [0u, i]));\n         let retptr = Load(bcx,\n-                          GEPi(bcx, llcdata,\n-                               ~[0u, i+1u]));\n+                          GEPi(bcx, llcdata, [0u, i+1u]));\n         fcx.loop_ret = Some({flagptr: flagptr, retptr: retptr});\n     }\n }\n@@ -415,7 +411,7 @@ fn make_fn_glue(\n     let tcx = cx.tcx();\n \n     let fn_env = fn@(ck: ty::closure_kind) -> block {\n-        let box_cell_v = GEPi(cx, v, ~[0u, abi::fn_field_box]);\n+        let box_cell_v = GEPi(cx, v, [0u, abi::fn_field_box]);\n         let box_ptr_v = Load(cx, box_cell_v);\n         do with_cond(cx, IsNotNull(cx, box_ptr_v)) |bcx| {\n             let closure_ty = ty::mk_opaque_closure_ptr(tcx, ck);\n@@ -459,10 +455,10 @@ fn make_opaque_cbox_take_glue(\n     do with_cond(bcx, IsNotNull(bcx, cbox_in)) |bcx| {\n         // Load the size from the type descr found in the cbox\n         let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n-        let tydescptr = GEPi(bcx, cbox_in, ~[0u, abi::box_field_tydesc]);\n+        let tydescptr = GEPi(bcx, cbox_in, [0u, abi::box_field_tydesc]);\n         let tydesc = Load(bcx, tydescptr);\n         let tydesc = PointerCast(bcx, tydesc, T_ptr(ccx.tydesc_type));\n-        let sz = Load(bcx, GEPi(bcx, tydesc, ~[0u, abi::tydesc_field_size]));\n+        let sz = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_size]));\n \n         // Adjust sz to account for the rust_opaque_box header fields\n         let sz = Add(bcx, sz, shape::llsize_of(ccx, T_box_header(ccx)));\n@@ -478,11 +474,11 @@ fn make_opaque_cbox_take_glue(\n         Store(bcx, cbox_out, cboxptr);\n \n         // Take the (deeply cloned) type descriptor\n-        let tydesc_out = GEPi(bcx, cbox_out, ~[0u, abi::box_field_tydesc]);\n+        let tydesc_out = GEPi(bcx, cbox_out, [0u, abi::box_field_tydesc]);\n         let bcx = take_ty(bcx, tydesc_out, ty::mk_type(tcx));\n \n         // Take the data in the tuple\n-        let cdata_out = GEPi(bcx, cbox_out, ~[0u, abi::box_field_body]);\n+        let cdata_out = GEPi(bcx, cbox_out, [0u, abi::box_field_body]);\n         call_tydesc_glue_full(bcx, cdata_out, tydesc,\n                               abi::tydesc_field_take_glue, None);\n         bcx\n@@ -524,12 +520,12 @@ fn make_opaque_cbox_free_glue(\n         // Load the type descr found in the cbox\n         let lltydescty = T_ptr(ccx.tydesc_type);\n         let cbox = Load(bcx, cbox);\n-        let tydescptr = GEPi(bcx, cbox, ~[0u, abi::box_field_tydesc]);\n+        let tydescptr = GEPi(bcx, cbox, [0u, abi::box_field_tydesc]);\n         let tydesc = Load(bcx, tydescptr);\n         let tydesc = PointerCast(bcx, tydesc, lltydescty);\n \n         // Drop the tuple data then free the descriptor\n-        let cdata = GEPi(bcx, cbox, ~[0u, abi::box_field_body]);\n+        let cdata = GEPi(bcx, cbox, [0u, abi::box_field_body]);\n         call_tydesc_glue_full(bcx, cdata, tydesc,\n                               abi::tydesc_field_drop_glue, None);\n "}, {"sha": "d760e47296e17b0dc258839513ad88804c1b04ed", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=2bb056f4ab416b08a499b2229a3cca6404ce3c54", "patch": "@@ -592,23 +592,22 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                     let mut atys = x86_64.arg_tys;\n                     let mut attrs = x86_64.attrs;\n                     if x86_64.sret {\n-                        let llretptr = GEPi(bcx, llargbundle, ~[0u, n]);\n+                        let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n                         let llretloc = Load(bcx, llretptr);\n                         llargvals = ~[llretloc];\n                         atys = vec::tail(atys);\n                         attrs = vec::tail(attrs);\n                     }\n                     while i < n {\n                         let llargval = if atys[i].cast {\n-                            let arg_ptr = GEPi(bcx, llargbundle,\n-                                               ~[0u, i]);\n+                            let arg_ptr = GEPi(bcx, llargbundle, [0u, i]);\n                             let arg_ptr = BitCast(bcx, arg_ptr,\n                                               T_ptr(atys[i].ty));\n                             Load(bcx, arg_ptr)\n                         } else if option::is_some(attrs[i]) {\n-                            GEPi(bcx, llargbundle, ~[0u, i])\n+                            GEPi(bcx, llargbundle, [0u, i])\n                         } else {\n-                            load_inbounds(bcx, llargbundle, ~[0u, i])\n+                            load_inbounds(bcx, llargbundle, [0u, i])\n                         };\n                         vec::push(llargvals, llargval);\n                         i += 1u;\n@@ -617,7 +616,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                 _ => {\n                     while i < n {\n                         let llargval = load_inbounds(bcx, llargbundle,\n-                                                          ~[0u, i]);\n+                                                          [0u, i]);\n                         vec::push(llargvals, llargval);\n                         i += 1u;\n                     }\n@@ -645,7 +644,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                         return;\n                     }\n                     let n = vec::len(tys.arg_tys);\n-                    let llretptr = GEPi(bcx, llargbundle, ~[0u, n]);\n+                    let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n                     let llretloc = Load(bcx, llretptr);\n                     if x86_64.ret_ty.cast {\n                         let tmp_ptr = BitCast(bcx, llretloc,\n@@ -659,7 +658,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                     if tys.ret_def {\n                         let n = vec::len(tys.arg_tys);\n                         // R** llretptr = &args->r;\n-                        let llretptr = GEPi(bcx, llargbundle, ~[0u, n]);\n+                        let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n                         // R* llretloc = *llretptr; /* (args->r) */\n                         let llretloc = Load(bcx, llretptr);\n                         // *args->r = r;\n@@ -1085,29 +1084,29 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                         if option::is_some(attrs[i]) {\n                             argval = Load(bcx, argval);\n                             store_inbounds(bcx, argval, llargbundle,\n-                                           ~[0u, i]);\n+                                           [0u, i]);\n                         } else if atys[i].cast {\n-                            let argptr = GEPi(bcx, llargbundle, ~[0u, i]);\n+                            let argptr = GEPi(bcx, llargbundle, [0u, i]);\n                             let argptr = BitCast(bcx, argptr,\n                                                  T_ptr(atys[i].ty));\n                             Store(bcx, argval, argptr);\n                         } else {\n                             store_inbounds(bcx, argval, llargbundle,\n-                                           ~[0u, i]);\n+                                           [0u, i]);\n                         }\n                         i += 1u;\n                     }\n-                    store_inbounds(bcx, llretptr, llargbundle, ~[0u, n]);\n+                    store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n                 }\n                 _ => {\n                     let llretptr = alloca(bcx, tys.ret_ty);\n                     let n = vec::len(tys.arg_tys);\n                   for uint::range(0u, n) |i| {\n                         let llargval = get_param(llwrapfn, i);\n                         store_inbounds(bcx, llargval, llargbundle,\n-                                                      ~[0u, i]);\n+                                                      [0u, i]);\n                     };\n-                    store_inbounds(bcx, llretptr, llargbundle, ~[0u, n]);\n+                    store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n                 }\n             }\n         }"}, {"sha": "6ffeb8612704ee20bb1d88b80f0a2900b352a35b", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=2bb056f4ab416b08a499b2229a3cca6404ce3c54", "patch": "@@ -275,18 +275,18 @@ fn trans_trait_callee(bcx: block, val: ValueRef,\n     -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n-    let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, ~[0u, 0u]),\n+    let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0u, 0u]),\n                                        T_ptr(T_ptr(T_vtable()))));\n-    let llbox = Load(bcx, GEPi(bcx, val, ~[0u, 1u]));\n+    let llbox = Load(bcx, GEPi(bcx, val, [0u, 1u]));\n     // FIXME[impl] I doubt this is alignment-safe (#2534)\n-    let self = GEPi(bcx, llbox, ~[0u, abi::box_field_body]);\n+    let self = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n     let env = self_env(self, ty::mk_opaque_box(bcx.tcx()), Some(llbox),\n                        // XXX: is this bogosity?\n                        ast::by_ref);\n     let llfty = type_of::type_of_fn_from_ty(ccx, callee_ty);\n     let vtable = PointerCast(bcx, vtable,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n-    let mptr = Load(bcx, GEPi(bcx, vtable, ~[0u, n_method]));\n+    let mptr = Load(bcx, GEPi(bcx, vtable, [0u, n_method]));\n     {bcx: bcx, val: mptr, kind: lv_owned, env: env}\n }\n \n@@ -423,12 +423,12 @@ fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     let bcx = trans_expr_save_in(bcx, val, body);\n     revoke_clean(bcx, llbox);\n     let result = get_dest_addr(dest);\n-    Store(bcx, llbox, PointerCast(bcx, GEPi(bcx, result, ~[0u, 1u]),\n+    Store(bcx, llbox, PointerCast(bcx, GEPi(bcx, result, [0u, 1u]),\n                                   T_ptr(val_ty(llbox))));\n     let orig = ccx.maps.vtable_map.get(id)[0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx.ccx(), orig);\n-    Store(bcx, vtable, PointerCast(bcx, GEPi(bcx, result, ~[0u, 0u]),\n+    Store(bcx, vtable, PointerCast(bcx, GEPi(bcx, result, [0u, 0u]),\n                                    T_ptr(val_ty(vtable))));\n     bcx\n }"}, {"sha": "523d5b66305552c9e27b49116bda143fb0b7c2bc", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=2bb056f4ab416b08a499b2229a3cca6404ce3c54", "patch": "@@ -33,23 +33,23 @@ fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n \n fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n-    Load(bcx, GEPi(bcx, vptr, ~[0u, abi::vec_elt_fill]))\n+    Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n }\n fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n-    Store(bcx, fill, GEPi(bcx, vptr, ~[0u, abi::vec_elt_fill]));\n+    Store(bcx, fill, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]));\n }\n fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n-    Load(bcx, GEPi(bcx, vptr, ~[0u, abi::vec_elt_alloc]))\n+    Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n \n fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n-    non_gc_box_cast(bcx, GEPi(bcx, vptr, ~[0u, abi::box_field_body]))\n+    non_gc_box_cast(bcx, GEPi(bcx, vptr, [0u, abi::box_field_body]))\n }\n \n fn get_dataptr(bcx: block, vptr: ValueRef)\n     -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n-    GEPi(bcx, vptr, ~[0u, abi::vec_elt_elems, 0u])\n+    GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n@@ -69,8 +69,8 @@ fn alloc_raw(bcx: block, unit_ty: ty::t,\n \n     let {bcx, box, body} =\n         base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n-    Store(bcx, fill, GEPi(bcx, body, ~[0u, abi::vec_elt_fill]));\n-    Store(bcx, alloc, GEPi(bcx, body, ~[0u, abi::vec_elt_alloc]));\n+    Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n+    Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n     return {bcx: bcx, val: box};\n }\n fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n@@ -187,8 +187,8 @@ fn trans_evec(bcx: block, elements: evec_elements,\n \n             let p = base::alloca(bcx, T_struct(~[T_ptr(llunitty),\n                                                 ccx.int_type]));\n-            Store(bcx, vp, GEPi(bcx, p, ~[0u, abi::slice_elt_base]));\n-            Store(bcx, len, GEPi(bcx, p, ~[0u, abi::slice_elt_len]));\n+            Store(bcx, vp, GEPi(bcx, p, [0u, abi::slice_elt_base]));\n+            Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]));\n \n             {bcx: bcx, val: p, dataptr: vp}\n           }\n@@ -298,14 +298,14 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n \n     match vstore {\n       ty::vstore_fixed(n) => {\n-        let base = GEPi(cx, v, ~[0u, 0u]);\n+        let base = GEPi(cx, v, [0u, 0u]);\n         let n = if ty::type_is_str(e_ty) { n + 1u } else { n };\n         let len = Mul(cx, C_uint(ccx, n), unit_sz);\n         (base, len)\n       }\n       ty::vstore_slice(_) => {\n-        let base = Load(cx, GEPi(cx, v, ~[0u, abi::slice_elt_base]));\n-        let len = Load(cx, GEPi(cx, v, ~[0u, abi::slice_elt_len]));\n+        let base = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_base]));\n+        let len = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_len]));\n         (base, len)\n       }\n       ty::vstore_uniq | ty::vstore_box => {"}, {"sha": "214fa0547ae611db1520cc93e1e02a8e81f8249c", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb056f4ab416b08a499b2229a3cca6404ce3c54/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=2bb056f4ab416b08a499b2229a3cca6404ce3c54", "patch": "@@ -46,9 +46,9 @@ fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     let bcx = copy_val(bcx, INIT, dst_body, src_body, content_ty);\n \n     let src_tydesc_ptr = GEPi(bcx, src_box,\n-                              ~[0u, back::abi::box_field_tydesc]);\n+                              [0u, back::abi::box_field_tydesc]);\n     let dst_tydesc_ptr = GEPi(bcx, dst_box,\n-                              ~[0u, back::abi::box_field_tydesc]);\n+                              [0u, back::abi::box_field_tydesc]);\n \n     let td = Load(bcx, src_tydesc_ptr);\n     Store(bcx, td, dst_tydesc_ptr);"}]}