{"sha": "700a3d5d75cdc1b8b7049d35af335c638e079c5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMGEzZDVkNzVjZGMxYjhiNzA0OWQzNWFmMzM1YzYzOGUwNzljNWM=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-09-18T10:32:07Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-09-18T10:32:07Z"}, "message": "Invert condition to unindent code", "tree": {"sha": "3ed524763bcabeaa26f39ba16289f148e59fe891", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ed524763bcabeaa26f39ba16289f148e59fe891"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/700a3d5d75cdc1b8b7049d35af335c638e079c5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/700a3d5d75cdc1b8b7049d35af335c638e079c5c", "html_url": "https://github.com/rust-lang/rust/commit/700a3d5d75cdc1b8b7049d35af335c638e079c5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/700a3d5d75cdc1b8b7049d35af335c638e079c5c/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "086f1c4b3025b405fde077df3319551140136131", "url": "https://api.github.com/repos/rust-lang/rust/commits/086f1c4b3025b405fde077df3319551140136131", "html_url": "https://github.com/rust-lang/rust/commit/086f1c4b3025b405fde077df3319551140136131"}], "stats": {"total": 315, "additions": 157, "deletions": 158}, "files": [{"sha": "925043aa9dcab65db58863533e084c6827ec7356", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 157, "deletions": 158, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/700a3d5d75cdc1b8b7049d35af335c638e079c5c/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700a3d5d75cdc1b8b7049d35af335c638e079c5c/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=700a3d5d75cdc1b8b7049d35af335c638e079c5c", "patch": "@@ -874,184 +874,183 @@ impl ModCollector<'_, '_> {\n \n         for &item in items {\n             let attrs = self.item_tree.attrs(item.into());\n-            if self.is_cfg_enabled(attrs) {\n-                let module =\n-                    ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n-                let container = ContainerId::ModuleId(module);\n-\n-                let mut def = None;\n-                match item {\n-                    ModItem::Mod(m) => self.collect_module(&self.item_tree[m], attrs),\n-                    ModItem::Import(import_id) => {\n-                        self.def_collector.unresolved_imports.push(ImportDirective {\n-                            module_id: self.module_id,\n-                            import: Import::from_use(\n-                                &self.item_tree,\n-                                InFile::new(self.file_id, import_id),\n-                            ),\n-                            status: PartialResolvedImport::Unresolved,\n-                        })\n-                    }\n-                    ModItem::ExternCrate(import_id) => {\n-                        self.def_collector.unresolved_imports.push(ImportDirective {\n-                            module_id: self.module_id,\n-                            import: Import::from_extern_crate(\n-                                &self.item_tree,\n-                                InFile::new(self.file_id, import_id),\n-                            ),\n-                            status: PartialResolvedImport::Unresolved,\n-                        })\n-                    }\n-                    ModItem::MacroCall(mac) => self.collect_macro(&self.item_tree[mac]),\n-                    ModItem::Impl(imp) => {\n-                        let module = ModuleId {\n-                            krate: self.def_collector.def_map.krate,\n-                            local_id: self.module_id,\n-                        };\n-                        let container = ContainerId::ModuleId(module);\n-                        let impl_id = ImplLoc { container, id: ItemTreeId::new(self.file_id, imp) }\n-                            .intern(self.def_collector.db);\n-                        self.def_collector.def_map.modules[self.module_id]\n-                            .scope\n-                            .define_impl(impl_id)\n-                    }\n-                    ModItem::Function(id) => {\n-                        let func = &self.item_tree[id];\n-                        def = Some(DefData {\n-                            id: FunctionLoc {\n-                                container: container.into(),\n-                                id: ItemTreeId::new(self.file_id, id),\n-                            }\n-                            .intern(self.def_collector.db)\n-                            .into(),\n-                            name: &func.name,\n-                            visibility: &self.item_tree[func.visibility],\n-                            has_constructor: false,\n-                        });\n-                    }\n-                    ModItem::Struct(id) => {\n-                        let it = &self.item_tree[id];\n-\n-                        // FIXME: check attrs to see if this is an attribute macro invocation;\n-                        // in which case we don't add the invocation, just a single attribute\n-                        // macro invocation\n-                        self.collect_derives(attrs, it.ast_id.upcast());\n-\n-                        def = Some(DefData {\n-                            id: StructLoc { container, id: ItemTreeId::new(self.file_id, id) }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                            name: &it.name,\n-                            visibility: &self.item_tree[it.visibility],\n-                            has_constructor: it.kind != StructDefKind::Record,\n-                        });\n-                    }\n-                    ModItem::Union(id) => {\n-                        let it = &self.item_tree[id];\n+            if !self.is_cfg_enabled(attrs) {\n+                continue;\n+            }\n+            let module =\n+                ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n+            let container = ContainerId::ModuleId(module);\n+\n+            let mut def = None;\n+            match item {\n+                ModItem::Mod(m) => self.collect_module(&self.item_tree[m], attrs),\n+                ModItem::Import(import_id) => {\n+                    self.def_collector.unresolved_imports.push(ImportDirective {\n+                        module_id: self.module_id,\n+                        import: Import::from_use(\n+                            &self.item_tree,\n+                            InFile::new(self.file_id, import_id),\n+                        ),\n+                        status: PartialResolvedImport::Unresolved,\n+                    })\n+                }\n+                ModItem::ExternCrate(import_id) => {\n+                    self.def_collector.unresolved_imports.push(ImportDirective {\n+                        module_id: self.module_id,\n+                        import: Import::from_extern_crate(\n+                            &self.item_tree,\n+                            InFile::new(self.file_id, import_id),\n+                        ),\n+                        status: PartialResolvedImport::Unresolved,\n+                    })\n+                }\n+                ModItem::MacroCall(mac) => self.collect_macro(&self.item_tree[mac]),\n+                ModItem::Impl(imp) => {\n+                    let module = ModuleId {\n+                        krate: self.def_collector.def_map.krate,\n+                        local_id: self.module_id,\n+                    };\n+                    let container = ContainerId::ModuleId(module);\n+                    let impl_id = ImplLoc { container, id: ItemTreeId::new(self.file_id, imp) }\n+                        .intern(self.def_collector.db);\n+                    self.def_collector.def_map.modules[self.module_id].scope.define_impl(impl_id)\n+                }\n+                ModItem::Function(id) => {\n+                    let func = &self.item_tree[id];\n+                    def = Some(DefData {\n+                        id: FunctionLoc {\n+                            container: container.into(),\n+                            id: ItemTreeId::new(self.file_id, id),\n+                        }\n+                        .intern(self.def_collector.db)\n+                        .into(),\n+                        name: &func.name,\n+                        visibility: &self.item_tree[func.visibility],\n+                        has_constructor: false,\n+                    });\n+                }\n+                ModItem::Struct(id) => {\n+                    let it = &self.item_tree[id];\n \n-                        // FIXME: check attrs to see if this is an attribute macro invocation;\n-                        // in which case we don't add the invocation, just a single attribute\n-                        // macro invocation\n-                        self.collect_derives(attrs, it.ast_id.upcast());\n+                    // FIXME: check attrs to see if this is an attribute macro invocation;\n+                    // in which case we don't add the invocation, just a single attribute\n+                    // macro invocation\n+                    self.collect_derives(attrs, it.ast_id.upcast());\n \n-                        def = Some(DefData {\n-                            id: UnionLoc { container, id: ItemTreeId::new(self.file_id, id) }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                            name: &it.name,\n-                            visibility: &self.item_tree[it.visibility],\n-                            has_constructor: false,\n-                        });\n-                    }\n-                    ModItem::Enum(id) => {\n-                        let it = &self.item_tree[id];\n+                    def = Some(DefData {\n+                        id: StructLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: it.kind != StructDefKind::Record,\n+                    });\n+                }\n+                ModItem::Union(id) => {\n+                    let it = &self.item_tree[id];\n \n-                        // FIXME: check attrs to see if this is an attribute macro invocation;\n-                        // in which case we don't add the invocation, just a single attribute\n-                        // macro invocation\n-                        self.collect_derives(attrs, it.ast_id.upcast());\n+                    // FIXME: check attrs to see if this is an attribute macro invocation;\n+                    // in which case we don't add the invocation, just a single attribute\n+                    // macro invocation\n+                    self.collect_derives(attrs, it.ast_id.upcast());\n \n-                        def = Some(DefData {\n-                            id: EnumLoc { container, id: ItemTreeId::new(self.file_id, id) }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                            name: &it.name,\n-                            visibility: &self.item_tree[it.visibility],\n-                            has_constructor: false,\n-                        });\n-                    }\n-                    ModItem::Const(id) => {\n-                        let it = &self.item_tree[id];\n-\n-                        if let Some(name) = &it.name {\n-                            def = Some(DefData {\n-                                id: ConstLoc {\n-                                    container: container.into(),\n-                                    id: ItemTreeId::new(self.file_id, id),\n-                                }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                                name,\n-                                visibility: &self.item_tree[it.visibility],\n-                                has_constructor: false,\n-                            });\n-                        }\n-                    }\n-                    ModItem::Static(id) => {\n-                        let it = &self.item_tree[id];\n+                    def = Some(DefData {\n+                        id: UnionLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: false,\n+                    });\n+                }\n+                ModItem::Enum(id) => {\n+                    let it = &self.item_tree[id];\n \n-                        def = Some(DefData {\n-                            id: StaticLoc { container, id: ItemTreeId::new(self.file_id, id) }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                            name: &it.name,\n-                            visibility: &self.item_tree[it.visibility],\n-                            has_constructor: false,\n-                        });\n-                    }\n-                    ModItem::Trait(id) => {\n-                        let it = &self.item_tree[id];\n+                    // FIXME: check attrs to see if this is an attribute macro invocation;\n+                    // in which case we don't add the invocation, just a single attribute\n+                    // macro invocation\n+                    self.collect_derives(attrs, it.ast_id.upcast());\n \n-                        def = Some(DefData {\n-                            id: TraitLoc { container, id: ItemTreeId::new(self.file_id, id) }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                            name: &it.name,\n-                            visibility: &self.item_tree[it.visibility],\n-                            has_constructor: false,\n-                        });\n-                    }\n-                    ModItem::TypeAlias(id) => {\n-                        let it = &self.item_tree[id];\n+                    def = Some(DefData {\n+                        id: EnumLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: false,\n+                    });\n+                }\n+                ModItem::Const(id) => {\n+                    let it = &self.item_tree[id];\n \n+                    if let Some(name) = &it.name {\n                         def = Some(DefData {\n-                            id: TypeAliasLoc {\n+                            id: ConstLoc {\n                                 container: container.into(),\n                                 id: ItemTreeId::new(self.file_id, id),\n                             }\n                             .intern(self.def_collector.db)\n                             .into(),\n-                            name: &it.name,\n+                            name,\n                             visibility: &self.item_tree[it.visibility],\n                             has_constructor: false,\n                         });\n                     }\n                 }\n+                ModItem::Static(id) => {\n+                    let it = &self.item_tree[id];\n \n-                if let Some(DefData { id, name, visibility, has_constructor }) = def {\n-                    self.def_collector.def_map.modules[self.module_id].scope.define_def(id);\n-                    let vis = self\n-                        .def_collector\n-                        .def_map\n-                        .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n-                        .unwrap_or(Visibility::Public);\n-                    self.def_collector.update(\n-                        self.module_id,\n-                        &[(Some(name.clone()), PerNs::from_def(id, vis, has_constructor))],\n-                        vis,\n-                        ImportType::Named,\n-                    )\n+                    def = Some(DefData {\n+                        id: StaticLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: false,\n+                    });\n+                }\n+                ModItem::Trait(id) => {\n+                    let it = &self.item_tree[id];\n+\n+                    def = Some(DefData {\n+                        id: TraitLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: false,\n+                    });\n                 }\n+                ModItem::TypeAlias(id) => {\n+                    let it = &self.item_tree[id];\n+\n+                    def = Some(DefData {\n+                        id: TypeAliasLoc {\n+                            container: container.into(),\n+                            id: ItemTreeId::new(self.file_id, id),\n+                        }\n+                        .intern(self.def_collector.db)\n+                        .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: false,\n+                    });\n+                }\n+            }\n+\n+            if let Some(DefData { id, name, visibility, has_constructor }) = def {\n+                self.def_collector.def_map.modules[self.module_id].scope.define_def(id);\n+                let vis = self\n+                    .def_collector\n+                    .def_map\n+                    .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n+                    .unwrap_or(Visibility::Public);\n+                self.def_collector.update(\n+                    self.module_id,\n+                    &[(Some(name.clone()), PerNs::from_def(id, vis, has_constructor))],\n+                    vis,\n+                    ImportType::Named,\n+                )\n             }\n         }\n     }"}]}