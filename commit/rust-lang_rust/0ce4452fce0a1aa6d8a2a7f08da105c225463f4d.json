{"sha": "0ce4452fce0a1aa6d8a2a7f08da105c225463f4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjZTQ0NTJmY2UwYTFhYTZkOGEyYTdmMDhkYTEwNWMyMjU0NjNmNGQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-02-10T23:27:33Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-10-21T01:43:57Z"}, "message": "rustc_codegen_llvm: add support for inlined function debuginfo.", "tree": {"sha": "8de45f19451d5a7b137874dc9b5a3b0f171e814c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8de45f19451d5a7b137874dc9b5a3b0f171e814c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d", "html_url": "https://github.com/rust-lang/rust/commit/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "737499593db6d7702de3bf9d0070ec3f8e65d71e", "url": "https://api.github.com/repos/rust-lang/rust/commits/737499593db6d7702de3bf9d0070ec3f8e65d71e", "html_url": "https://github.com/rust-lang/rust/commit/737499593db6d7702de3bf9d0070ec3f8e65d71e"}], "stats": {"total": 201, "additions": 137, "deletions": 64}, "files": [{"sha": "6737872f203ad0c8b443aebc81d29b5b46f797be", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=0ce4452fce0a1aa6d8a2a7f08da105c225463f4d", "patch": "@@ -3,21 +3,26 @@ use super::utils::DIB;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext};\n use rustc_codegen_ssa::traits::*;\n \n+use crate::abi::FnAbi;\n use crate::common::CodegenCx;\n use crate::llvm;\n-use crate::llvm::debuginfo::DIScope;\n+use crate::llvm::debuginfo::{DILocation, DIScope};\n use rustc_middle::mir::{Body, SourceScope};\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_middle::ty::{self, Instance};\n use rustc_session::config::DebugInfo;\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n \n /// Produces DIScope DIEs for each MIR Scope which has variables defined in it.\n+// FIXME(eddyb) almost all of this should be in `rustc_codegen_ssa::mir::debuginfo`.\n pub fn compute_mir_scopes(\n-    cx: &CodegenCx<'ll, '_>,\n-    mir: &Body<'_>,\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    instance: Instance<'tcx>,\n+    mir: &Body<'tcx>,\n     fn_dbg_scope: &'ll DIScope,\n-    debug_context: &mut FunctionDebugContext<&'ll DIScope>,\n+    debug_context: &mut FunctionDebugContext<&'ll DIScope, &'ll DILocation>,\n ) {\n     // Find all the scopes with variables defined in them.\n     let mut has_variables = BitSet::new_empty(mir.source_scopes.len());\n@@ -37,16 +42,17 @@ pub fn compute_mir_scopes(\n     // Instantiate all scopes.\n     for idx in 0..mir.source_scopes.len() {\n         let scope = SourceScope::new(idx);\n-        make_mir_scope(cx, &mir, fn_dbg_scope, &has_variables, debug_context, scope);\n+        make_mir_scope(cx, instance, &mir, fn_dbg_scope, &has_variables, debug_context, scope);\n     }\n }\n \n fn make_mir_scope(\n-    cx: &CodegenCx<'ll, '_>,\n-    mir: &Body<'_>,\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    instance: Instance<'tcx>,\n+    mir: &Body<'tcx>,\n     fn_dbg_scope: &'ll DIScope,\n     has_variables: &BitSet<SourceScope>,\n-    debug_context: &mut FunctionDebugContext<&'ll DIScope>,\n+    debug_context: &mut FunctionDebugContext<&'ll DIScope, &'ll DILocation>,\n     scope: SourceScope,\n ) {\n     if debug_context.scopes[scope].dbg_scope.is_some() {\n@@ -55,40 +61,63 @@ fn make_mir_scope(\n \n     let scope_data = &mir.source_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n-        make_mir_scope(cx, mir, fn_dbg_scope, has_variables, debug_context, parent);\n+        make_mir_scope(cx, instance, mir, fn_dbg_scope, has_variables, debug_context, parent);\n         debug_context.scopes[parent]\n     } else {\n         // The root is the function itself.\n         let loc = cx.lookup_debug_loc(mir.span.lo());\n         debug_context.scopes[scope] = DebugScope {\n             dbg_scope: Some(fn_dbg_scope),\n+            inlined_at: None,\n             file_start_pos: loc.file.start_pos,\n             file_end_pos: loc.file.end_pos,\n         };\n         return;\n     };\n \n-    if !has_variables.contains(scope) {\n-        // Do not create a DIScope if there are no variables\n-        // defined in this MIR Scope, to avoid debuginfo bloat.\n+    if !has_variables.contains(scope) && scope_data.inlined.is_none() {\n+        // Do not create a DIScope if there are no variables defined in this\n+        // MIR `SourceScope`, and it's not `inlined`, to avoid debuginfo bloat.\n         debug_context.scopes[scope] = parent_scope;\n         return;\n     }\n \n     let loc = cx.lookup_debug_loc(scope_data.span.lo());\n     let file_metadata = file_metadata(cx, &loc.file);\n \n-    let dbg_scope = unsafe {\n-        Some(llvm::LLVMRustDIBuilderCreateLexicalBlock(\n-            DIB(cx),\n-            parent_scope.dbg_scope.unwrap(),\n-            file_metadata,\n-            loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n-            loc.col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n-        ))\n+    let dbg_scope = match scope_data.inlined {\n+        Some((callee, _)) => {\n+            // FIXME(eddyb) this would be `self.monomorphize(&callee)`\n+            // if this is moved to `rustc_codegen_ssa::mir::debuginfo`.\n+            let callee = cx.tcx.subst_and_normalize_erasing_regions(\n+                instance.substs,\n+                ty::ParamEnv::reveal_all(),\n+                &callee,\n+            );\n+            let callee_fn_abi = FnAbi::of_instance(cx, callee, &[]);\n+            cx.dbg_scope_fn(callee, &callee_fn_abi, None)\n+        }\n+        None => unsafe {\n+            llvm::LLVMRustDIBuilderCreateLexicalBlock(\n+                DIB(cx),\n+                parent_scope.dbg_scope.unwrap(),\n+                file_metadata,\n+                loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n+                loc.col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n+            )\n+        },\n     };\n+\n+    let inlined_at = scope_data.inlined.map(|(_, callsite_span)| {\n+        // FIXME(eddyb) this doesn't account for the macro-related\n+        // `Span` fixups that `rustc_codegen_ssa::mir::debuginfo` does.\n+        let callsite_scope = parent_scope.adjust_dbg_scope_for_span(cx, callsite_span);\n+        cx.dbg_loc(callsite_scope, parent_scope.inlined_at, callsite_span)\n+    });\n+\n     debug_context.scopes[scope] = DebugScope {\n-        dbg_scope,\n+        dbg_scope: Some(dbg_scope),\n+        inlined_at: inlined_at.or(parent_scope.inlined_at),\n         file_start_pos: loc.file.start_pos,\n         file_end_pos: loc.file.end_pos,\n     };"}, {"sha": "beaea49874e6eabd0bdb8c7437c8cd5ab49cac3e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=0ce4452fce0a1aa6d8a2a7f08da105c225463f4d", "patch": "@@ -265,22 +265,27 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         instance: Instance<'tcx>,\n         fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         llfn: &'ll Value,\n-        mir: &mir::Body<'_>,\n-    ) -> Option<FunctionDebugContext<&'ll DIScope>> {\n+        mir: &mir::Body<'tcx>,\n+    ) -> Option<FunctionDebugContext<&'ll DIScope, &'ll DILocation>> {\n         if self.sess().opts.debuginfo == DebugInfo::None {\n             return None;\n         }\n \n         // Initialize fn debug context (including scopes).\n         // FIXME(eddyb) figure out a way to not need `Option` for `dbg_scope`.\n-        let empty_scope =\n-            DebugScope { dbg_scope: None, file_start_pos: BytePos(0), file_end_pos: BytePos(0) };\n+        let empty_scope = DebugScope {\n+            dbg_scope: None,\n+            inlined_at: None,\n+            file_start_pos: BytePos(0),\n+            file_end_pos: BytePos(0),\n+        };\n         let mut fn_debug_context =\n             FunctionDebugContext { scopes: IndexVec::from_elem(empty_scope, &mir.source_scopes) };\n \n         // Fill in all the scopes, with the information from the MIR body.\n         compute_mir_scopes(\n             self,\n+            instance,\n             mir,\n             self.dbg_scope_fn(instance, fn_abi, Some(llfn)),\n             &mut fn_debug_context,\n@@ -537,7 +542,12 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn dbg_loc(&self, scope: &'ll DIScope, span: Span) -> &'ll DILocation {\n+    fn dbg_loc(\n+        &self,\n+        scope: &'ll DIScope,\n+        inlined_at: Option<&'ll DILocation>,\n+        span: Span,\n+    ) -> &'ll DILocation {\n         let DebugLoc { line, col, .. } = self.lookup_debug_loc(span.lo());\n \n         unsafe {\n@@ -546,7 +556,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 line.unwrap_or(UNKNOWN_LINE_NUMBER),\n                 col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n                 scope,\n-                None,\n+                inlined_at,\n             )\n         }\n     }"}, {"sha": "e93830397c95e38ae23a229fd547827dc83b0158", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 62, "deletions": 33, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=0ce4452fce0a1aa6d8a2a7f08da105c225463f4d", "patch": "@@ -12,8 +12,8 @@ use super::operand::OperandValue;\n use super::place::PlaceRef;\n use super::{FunctionCx, LocalRef};\n \n-pub struct FunctionDebugContext<D> {\n-    pub scopes: IndexVec<mir::SourceScope, DebugScope<D>>,\n+pub struct FunctionDebugContext<S, L> {\n+    pub scopes: IndexVec<mir::SourceScope, DebugScope<S, L>>,\n }\n \n #[derive(Copy, Clone)]\n@@ -36,15 +36,42 @@ pub struct PerLocalVarDebugInfo<'tcx, D> {\n }\n \n #[derive(Clone, Copy, Debug)]\n-pub struct DebugScope<D> {\n+pub struct DebugScope<S, L> {\n     // FIXME(eddyb) this should never be `None`, after initialization.\n-    pub dbg_scope: Option<D>,\n+    pub dbg_scope: Option<S>,\n+\n+    /// Call site location, if this scope was inlined from another function.\n+    pub inlined_at: Option<L>,\n+\n     // Start and end offsets of the file to which this DIScope belongs.\n     // These are used to quickly determine whether some span refers to the same file.\n     pub file_start_pos: BytePos,\n     pub file_end_pos: BytePos,\n }\n \n+impl<'tcx, S: Copy, L: Copy> DebugScope<S, L> {\n+    /// DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n+    /// it may so happen that the current span belongs to a different file than the DIScope\n+    /// corresponding to span's containing source scope.  If so, we need to create a DIScope\n+    /// \"extension\" into that file.\n+    pub fn adjust_dbg_scope_for_span<Cx: CodegenMethods<'tcx, DIScope = S, DILocation = L>>(\n+        &self,\n+        cx: &Cx,\n+        span: Span,\n+    ) -> S {\n+        // FIXME(eddyb) this should never be `None`.\n+        let dbg_scope = self.dbg_scope.unwrap();\n+\n+        let pos = span.lo();\n+        if pos < self.file_start_pos || pos >= self.file_end_pos {\n+            let sm = cx.sess().source_map();\n+            cx.extend_scope_to_file(dbg_scope, &sm.lookup_char_pos(pos).file)\n+        } else {\n+            dbg_scope\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn set_debug_loc(&self, bx: &mut Bx, source_info: mir::SourceInfo) {\n         bx.set_span(source_info.span);\n@@ -54,19 +81,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n \n     fn dbg_loc(&self, source_info: mir::SourceInfo) -> Option<Bx::DILocation> {\n-        let (scope, span) = self.dbg_scope_and_span(source_info)?;\n-        Some(self.cx.dbg_loc(scope, span))\n+        let span = self.adjust_span_for_debugging(source_info.span);\n+        let scope = &self.debug_context.as_ref()?.scopes[source_info.scope];\n+        let dbg_scope = scope.adjust_dbg_scope_for_span(self.cx, span);\n+        Some(self.cx.dbg_loc(dbg_scope, scope.inlined_at, span))\n     }\n \n-    fn dbg_scope_and_span(&self, source_info: mir::SourceInfo) -> Option<(Bx::DIScope, Span)> {\n+    /// In order to have a good line stepping behavior in debugger, we overwrite debug\n+    /// locations of macro expansions with that of the outermost expansion site\n+    /// (unless the crate is being compiled with `-Z debug-macros`).\n+    fn adjust_span_for_debugging(&self, mut span: Span) -> Span {\n         // Bail out if debug info emission is not enabled.\n-        let debug_context = self.debug_context.as_ref()?;\n-        let scope = &debug_context.scopes[source_info.scope];\n+        if self.debug_context.is_none() {\n+            return span;\n+        }\n \n-        // In order to have a good line stepping behavior in debugger, we overwrite debug\n-        // locations of macro expansions with that of the outermost expansion site\n-        // (unless the crate is being compiled with `-Z debug-macros`).\n-        let mut span = source_info.span;\n         if span.from_expansion() && !self.cx.sess().opts.debugging_opts.debug_macros {\n             // Walk up the macro expansion chain until we reach a non-expanded span.\n             // We also stop at the function body level because no line stepping can occur\n@@ -75,20 +104,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             span = rustc_span::hygiene::walk_chain(span, self.mir.span.ctxt());\n         }\n \n-        // FIXME(eddyb) this should never be `None`.\n-        let mut dbg_scope = scope.dbg_scope?;\n-\n-        // DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n-        // it may so happen that the current span belongs to a different file than the DIScope\n-        // corresponding to span's containing source scope.  If so, we need to create a DIScope\n-        // \"extension\" into that file.\n-        let pos = span.lo();\n-        if pos < scope.file_start_pos || pos >= scope.file_end_pos {\n-            let sm = self.cx.sess().source_map();\n-            dbg_scope = self.cx.extend_scope_to_file(dbg_scope, &sm.lookup_char_pos(pos).file);\n-        }\n-\n-        Some((dbg_scope, span))\n+        span\n     }\n \n     /// Apply debuginfo and/or name, after creating the `alloca` for a local,\n@@ -130,11 +146,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let name = kw::Invalid;\n                 let decl = &self.mir.local_decls[local];\n                 let dbg_var = if full_debug_info {\n-                    self.dbg_scope_and_span(decl.source_info).map(|(scope, span)| {\n+                    self.debug_context.as_ref().map(|debug_context| {\n                         // FIXME(eddyb) is this `+ 1` needed at all?\n                         let kind = VariableKind::ArgumentVariable(arg_index + 1);\n \n-                        self.cx.create_dbg_var(name, self.monomorphize(&decl.ty), scope, kind, span)\n+                        let arg_ty = self.monomorphize(&decl.ty);\n+\n+                        let span = self.adjust_span_for_debugging(decl.source_info.span);\n+                        let scope = &debug_context.scopes[decl.source_info.scope];\n+                        let dbg_scope = scope.adjust_dbg_scope_for_span(self.cx, span);\n+\n+                        self.cx.create_dbg_var(name, arg_ty, dbg_scope, kind, span)\n                     })\n                 } else {\n                     None\n@@ -288,9 +310,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let mut per_local = IndexVec::from_elem(vec![], &self.mir.local_decls);\n         for var in &self.mir.var_debug_info {\n-            let scope_and_span =\n-                if full_debug_info { self.dbg_scope_and_span(var.source_info) } else { None };\n-            let dbg_var = scope_and_span.map(|(scope, span)| {\n+            let dbg_scope_and_span = if full_debug_info {\n+                self.debug_context.as_ref().map(|debug_context| {\n+                    let span = self.adjust_span_for_debugging(var.source_info.span);\n+                    let scope = &debug_context.scopes[var.source_info.scope];\n+                    (scope.adjust_dbg_scope_for_span(self.cx, span), span)\n+                })\n+            } else {\n+                None\n+            };\n+            let dbg_var = dbg_scope_and_span.map(|(dbg_scope, span)| {\n                 let place = var.place;\n                 let var_ty = self.monomorphized_place_ty(place.as_ref());\n                 let var_kind = if self.mir.local_kind(place.local) == mir::LocalKind::Arg\n@@ -306,7 +335,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 } else {\n                     VariableKind::LocalVariable\n                 };\n-                self.cx.create_dbg_var(var.name, var_ty, scope, var_kind, span)\n+                self.cx.create_dbg_var(var.name, var_ty, dbg_scope, var_kind, span)\n             });\n \n             per_local[var.place.local].push(PerLocalVarDebugInfo {"}, {"sha": "84e82e88e8eeaafffc89bf2f49237a4c3278f590", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=0ce4452fce0a1aa6d8a2a7f08da105c225463f4d", "patch": "@@ -26,7 +26,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n \n     mir: &'tcx mir::Body<'tcx>,\n \n-    debug_context: Option<FunctionDebugContext<Bx::DIScope>>,\n+    debug_context: Option<FunctionDebugContext<Bx::DIScope, Bx::DILocation>>,\n \n     llfn: Bx::Function,\n "}, {"sha": "3e66d711d2ef59a79e1c7dc3b1597ac018f32ae3", "filename": "compiler/rustc_codegen_ssa/src/traits/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ce4452fce0a1aa6d8a2a7f08da105c225463f4d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs?ref=0ce4452fce0a1aa6d8a2a7f08da105c225463f4d", "patch": "@@ -18,8 +18,8 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         instance: Instance<'tcx>,\n         fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         llfn: Self::Function,\n-        mir: &mir::Body<'_>,\n-    ) -> Option<FunctionDebugContext<Self::DIScope>>;\n+        mir: &mir::Body<'tcx>,\n+    ) -> Option<FunctionDebugContext<Self::DIScope, Self::DILocation>>;\n \n     // FIXME(eddyb) find a common convention for all of the debuginfo-related\n     // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n@@ -30,7 +30,12 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         maybe_definition_llfn: Option<Self::Function>,\n     ) -> Self::DIScope;\n \n-    fn dbg_loc(&self, scope: Self::DIScope, span: Span) -> Self::DILocation;\n+    fn dbg_loc(\n+        &self,\n+        scope: Self::DIScope,\n+        inlined_at: Option<Self::DILocation>,\n+        span: Span,\n+    ) -> Self::DILocation;\n \n     fn extend_scope_to_file(\n         &self,"}]}