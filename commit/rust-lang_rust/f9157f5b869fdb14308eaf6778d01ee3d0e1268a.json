{"sha": "f9157f5b869fdb14308eaf6778d01ee3d0e1268a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MTU3ZjViODY5ZmRiMTQzMDhlYWY2Nzc4ZDAxZWUzZDBlMTI2OGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-05T01:47:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-05T01:47:13Z"}, "message": "Auto merge of #51242 - ytausky:mut-ref, r=estebank\n\nSuggest not mutably borrowing a mutable reference\n\nThis PR would (hopefully) solve #45392. I deviated a bit from @estebank's instructions since the error span only included the borrowed expression (e.g. the `b` in `&mut b`). I also didn't check the mutability of the local binding, since this whole case is concerned with an immutable local.\n\nI can see two outstanding questions:\n1. `note_immutability_blame` is called in two places, but I only have one test case. I think it covers the call in `report_bckerror`, but I'm not sure how to trigger the call from `report_aliasability_violation`.\n2. There is one failing test, where the local binding is `self: &mut Self`. I'm not entirely sure what the correct output should be, but I think the new message should also apply. Unfortunately, since this parameter is parsed differently, its `let_span` covers both the pattern and the type, leading to a wrong suggestion text. I'm not sure how to correctly identify this case.", "tree": {"sha": "dd3773889cae79721fa3cee93c982712543b8680", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd3773889cae79721fa3cee93c982712543b8680"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9157f5b869fdb14308eaf6778d01ee3d0e1268a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9157f5b869fdb14308eaf6778d01ee3d0e1268a", "html_url": "https://github.com/rust-lang/rust/commit/f9157f5b869fdb14308eaf6778d01ee3d0e1268a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c610be92e2925ab8e789efc835c88247e46c6cbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/c610be92e2925ab8e789efc835c88247e46c6cbf", "html_url": "https://github.com/rust-lang/rust/commit/c610be92e2925ab8e789efc835c88247e46c6cbf"}, {"sha": "3303e6847b4e8b413ec65a166337e5f9f8325f28", "url": "https://api.github.com/repos/rust-lang/rust/commits/3303e6847b4e8b413ec65a166337e5f9f8325f28", "html_url": "https://github.com/rust-lang/rust/commit/3303e6847b4e8b413ec65a166337e5f9f8325f28"}], "stats": {"total": 153, "additions": 114, "deletions": 39}, "files": [{"sha": "e063880028fc9a1c4d3b6069f4f3853adb94cc63", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f9157f5b869fdb14308eaf6778d01ee3d0e1268a", "patch": "@@ -899,7 +899,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n \n                 self.note_and_explain_mutbl_error(&mut db, &err, &error_span);\n-                self.note_immutability_blame(&mut db, err.cmt.immutability_blame());\n+                self.note_immutability_blame(&mut db, err.cmt.immutability_blame(), err.cmt.id);\n                 db.emit();\n             }\n             err_out_of_scope(super_scope, sub_scope, cause) => {\n@@ -1105,7 +1105,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                             Origin::Ast)\n             }\n         };\n-        self.note_immutability_blame(&mut err, blame);\n+        self.note_immutability_blame(&mut err, blame, cmt.id);\n \n         if is_closure {\n             err.help(\"closures behind references must be called via `&mut`\");\n@@ -1184,25 +1184,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n     fn note_immutability_blame(&self,\n                                db: &mut DiagnosticBuilder,\n-                               blame: Option<ImmutabilityBlame>) {\n+                               blame: Option<ImmutabilityBlame>,\n+                               error_node_id: ast::NodeId) {\n         match blame {\n             None => {}\n             Some(ImmutabilityBlame::ClosureEnv(_)) => {}\n             Some(ImmutabilityBlame::ImmLocal(node_id)) => {\n-                let let_span = self.tcx.hir.span(node_id);\n-                if let ty::BindByValue(..) = self.local_binding_mode(node_id) {\n-                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(let_span) {\n-                        let (_, is_implicit_self) = self.local_ty(node_id);\n-                        if is_implicit_self && snippet != \"self\" {\n-                            // avoid suggesting `mut &self`.\n-                            return\n-                        }\n-                        db.span_label(\n-                            let_span,\n-                            format!(\"consider changing this to `mut {}`\", snippet)\n-                        );\n-                    }\n-                }\n+                self.note_immutable_local(db, error_node_id, node_id)\n             }\n             Some(ImmutabilityBlame::LocalDeref(node_id)) => {\n                 let let_span = self.tcx.hir.span(node_id);\n@@ -1242,6 +1230,46 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n+     // Suggest a fix when trying to mutably borrow an immutable local\n+     // binding: either to make the binding mutable (if its type is\n+     // not a mutable reference) or to avoid borrowing altogether\n+    fn note_immutable_local(&self,\n+                            db: &mut DiagnosticBuilder,\n+                            borrowed_node_id: ast::NodeId,\n+                            binding_node_id: ast::NodeId) {\n+        let let_span = self.tcx.hir.span(binding_node_id);\n+        if let ty::BindByValue(..) = self.local_binding_mode(binding_node_id) {\n+            if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(let_span) {\n+                let (ty, is_implicit_self) = self.local_ty(binding_node_id);\n+                if is_implicit_self && snippet != \"self\" {\n+                    // avoid suggesting `mut &self`.\n+                    return\n+                }\n+                if let Some(&hir::TyRptr(\n+                    _,\n+                    hir::MutTy {\n+                        mutbl: hir::MutMutable,\n+                        ..\n+                    },\n+                )) = ty.map(|t| &t.node)\n+                {\n+                    let borrow_expr_id = self.tcx.hir.get_parent_node(borrowed_node_id);\n+                    db.span_suggestion(\n+                        self.tcx.hir.span(borrow_expr_id),\n+                        \"consider removing the `&mut`, as it is an \\\n+                        immutable binding to a mutable reference\",\n+                        snippet\n+                    );\n+                } else {\n+                    db.span_label(\n+                        let_span,\n+                        format!(\"consider changing this to `mut {}`\", snippet),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n     fn report_out_of_scope_escaping_closure_capture(&self,\n                                                     err: &BckError<'a, 'tcx>,\n                                                     capture_span: Span)"}, {"sha": "95d519eae5851f570b58e489789f3224b910367a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f9157f5b869fdb14308eaf6778d01ee3d0e1268a", "patch": "@@ -5190,88 +5190,90 @@ impl<'a> Parser<'a> {\n         // Only a limited set of initial token sequences is considered self parameters, anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n         let eself_lo = self.span;\n-        let (eself, eself_ident) = match self.token {\n+        let (eself, eself_ident, eself_hi) = match self.token {\n             token::BinOp(token::And) => {\n                 // &self\n                 // &mut self\n                 // &'lt self\n                 // &'lt mut self\n                 // &not_self\n-                if isolated_self(self, 1) {\n+                (if isolated_self(self, 1) {\n                     self.bump();\n-                    (SelfKind::Region(None, Mutability::Immutable), expect_ident(self))\n+                    SelfKind::Region(None, Mutability::Immutable)\n                 } else if self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n                           isolated_self(self, 2) {\n                     self.bump();\n                     self.bump();\n-                    (SelfKind::Region(None, Mutability::Mutable), expect_ident(self))\n+                    SelfKind::Region(None, Mutability::Mutable)\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           isolated_self(self, 2) {\n                     self.bump();\n                     let lt = self.expect_lifetime();\n-                    (SelfKind::Region(Some(lt), Mutability::Immutable), expect_ident(self))\n+                    SelfKind::Region(Some(lt), Mutability::Immutable)\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::Mut)) &&\n                           isolated_self(self, 3) {\n                     self.bump();\n                     let lt = self.expect_lifetime();\n                     self.bump();\n-                    (SelfKind::Region(Some(lt), Mutability::Mutable), expect_ident(self))\n+                    SelfKind::Region(Some(lt), Mutability::Mutable)\n                 } else {\n                     return Ok(None);\n-                }\n+                }, expect_ident(self), self.prev_span)\n             }\n             token::BinOp(token::Star) => {\n                 // *self\n                 // *const self\n                 // *mut self\n                 // *not_self\n                 // Emit special error for `self` cases.\n-                if isolated_self(self, 1) {\n+                (if isolated_self(self, 1) {\n                     self.bump();\n                     self.span_err(self.span, \"cannot pass `self` by raw pointer\");\n-                    (SelfKind::Value(Mutability::Immutable), expect_ident(self))\n+                    SelfKind::Value(Mutability::Immutable)\n                 } else if self.look_ahead(1, |t| t.is_mutability()) &&\n                           isolated_self(self, 2) {\n                     self.bump();\n                     self.bump();\n                     self.span_err(self.span, \"cannot pass `self` by raw pointer\");\n-                    (SelfKind::Value(Mutability::Immutable), expect_ident(self))\n+                    SelfKind::Value(Mutability::Immutable)\n                 } else {\n                     return Ok(None);\n-                }\n+                }, expect_ident(self), self.prev_span)\n             }\n             token::Ident(..) => {\n                 if isolated_self(self, 0) {\n                     // self\n                     // self: TYPE\n                     let eself_ident = expect_ident(self);\n-                    if self.eat(&token::Colon) {\n+                    let eself_hi = self.prev_span;\n+                    (if self.eat(&token::Colon) {\n                         let ty = self.parse_ty()?;\n-                        (SelfKind::Explicit(ty, Mutability::Immutable), eself_ident)\n+                        SelfKind::Explicit(ty, Mutability::Immutable)\n                     } else {\n-                        (SelfKind::Value(Mutability::Immutable), eself_ident)\n-                    }\n+                        SelfKind::Value(Mutability::Immutable)\n+                    }, eself_ident, eself_hi)\n                 } else if self.token.is_keyword(keywords::Mut) &&\n                           isolated_self(self, 1) {\n                     // mut self\n                     // mut self: TYPE\n                     self.bump();\n                     let eself_ident = expect_ident(self);\n-                    if self.eat(&token::Colon) {\n+                    let eself_hi = self.prev_span;\n+                    (if self.eat(&token::Colon) {\n                         let ty = self.parse_ty()?;\n-                        (SelfKind::Explicit(ty, Mutability::Mutable), eself_ident)\n+                        SelfKind::Explicit(ty, Mutability::Mutable)\n                     } else {\n-                        (SelfKind::Value(Mutability::Mutable), eself_ident)\n-                    }\n+                        SelfKind::Value(Mutability::Mutable)\n+                    }, eself_ident, eself_hi)\n                 } else {\n                     return Ok(None);\n                 }\n             }\n             _ => return Ok(None),\n         };\n \n-        let eself = codemap::respan(eself_lo.to(self.prev_span), eself);\n+        let eself = codemap::respan(eself_lo.to(eself_hi), eself);\n         Ok(Some(Arg::from_self(eself, eself_ident)))\n     }\n "}, {"sha": "f8b84bce04ecfdb11df2fc069aa0cef7b0f195af", "filename": "src/test/ui/borrowck/mut-borrow-of-mut-ref.nll.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.nll.stderr?ref=f9157f5b869fdb14308eaf6778d01ee3d0e1268a", "patch": "@@ -0,0 +1,9 @@\n+error[E0596]: cannot borrow immutable item `b` as mutable\n+  --> $DIR/mut-borrow-of-mut-ref.rs:18:7\n+   |\n+LL |     g(&mut b) //~ ERROR cannot borrow\n+   |       ^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "75b9da52023416d2f6da6c43f7eeac7de38a118c", "filename": "src/test/ui/borrowck/mut-borrow-of-mut-ref.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.rs?ref=f9157f5b869fdb14308eaf6778d01ee3d0e1268a", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Suggest not mutably borrowing a mutable reference\n+\n+fn main() {\n+    f(&mut 0)\n+}\n+\n+fn f(b: &mut i32) {\n+    g(&mut b) //~ ERROR cannot borrow\n+}\n+\n+fn g(_: &mut i32) {}"}, {"sha": "885164cdc060328cdec3788304f09d4b0ccd2d02", "filename": "src/test/ui/borrowck/mut-borrow-of-mut-ref.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.stderr?ref=f9157f5b869fdb14308eaf6778d01ee3d0e1268a", "patch": "@@ -0,0 +1,13 @@\n+error[E0596]: cannot borrow immutable argument `b` as mutable\n+  --> $DIR/mut-borrow-of-mut-ref.rs:18:12\n+   |\n+LL |     g(&mut b) //~ ERROR cannot borrow\n+   |            ^ cannot borrow mutably\n+help: consider removing the `&mut`, as it is an immutable binding to a mutable reference\n+   |\n+LL |     g(b) //~ ERROR cannot borrow\n+   |       ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "9d0ab21ffaf0e3259157dab6b3acf1a8dc995ca7", "filename": "src/test/ui/did_you_mean/issue-31424.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9157f5b869fdb14308eaf6778d01ee3d0e1268a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.stderr?ref=f9157f5b869fdb14308eaf6778d01ee3d0e1268a", "patch": "@@ -10,10 +10,12 @@ LL |         (&mut self).bar(); //~ ERROR cannot borrow\n error[E0596]: cannot borrow immutable argument `self` as mutable\n   --> $DIR/issue-31424.rs:23:15\n    |\n-LL |     fn bar(self: &mut Self) {\n-   |            --------------- consider changing this to `mut self: &mut Self`\n LL |         (&mut self).bar(); //~ ERROR cannot borrow\n    |               ^^^^ cannot borrow mutably\n+help: consider removing the `&mut`, as it is an immutable binding to a mutable reference\n+   |\n+LL |         self.bar(); //~ ERROR cannot borrow\n+   |         ^^^^\n \n error: aborting due to 2 previous errors\n "}]}