{"sha": "58eb03d20f08881d06334c38a3ae0da25a8924bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZWIwM2QyMGYwODg4MWQwNjMzNGMzOGEzYWUwZGEyNWE4OTI0YmM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-20T21:23:07Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-20T22:39:24Z"}, "message": "check_match: simplify check_arm", "tree": {"sha": "39a09ea8a6ac398cbfcec0ade318ddfce3aff6fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39a09ea8a6ac398cbfcec0ade318ddfce3aff6fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58eb03d20f08881d06334c38a3ae0da25a8924bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58eb03d20f08881d06334c38a3ae0da25a8924bc", "html_url": "https://github.com/rust-lang/rust/commit/58eb03d20f08881d06334c38a3ae0da25a8924bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58eb03d20f08881d06334c38a3ae0da25a8924bc/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78f0c7fd6433c60d031311dacbf9a117b05e64b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/78f0c7fd6433c60d031311dacbf9a117b05e64b3", "html_url": "https://github.com/rust-lang/rust/commit/78f0c7fd6433c60d031311dacbf9a117b05e64b3"}], "stats": {"total": 109, "additions": 46, "deletions": 63}, "files": [{"sha": "cbb40f4e2a25e2230f921477fec031b4af84aa24", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58eb03d20f08881d06334c38a3ae0da25a8924bc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/58eb03d20f08881d06334c38a3ae0da25a8924bc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=58eb03d20f08881d06334c38a3ae0da25a8924bc", "patch": "@@ -3763,6 +3763,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"serialize\","}, {"sha": "a22c4d18d516aac646078b180acebc953515e0df", "filename": "src/librustc_mir_build/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58eb03d20f08881d06334c38a3ae0da25a8924bc/src%2Flibrustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/58eb03d20f08881d06334c38a3ae0da25a8924bc/src%2Flibrustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2FCargo.toml?ref=58eb03d20f08881d06334c38a3ae0da25a8924bc", "patch": "@@ -21,6 +21,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "49b7c2d41fcbb2978cf9e938e7cd63a115ffd25d", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 41, "deletions": 62, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/58eb03d20f08881d06334c38a3ae0da25a8924bc/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58eb03d20f08881d06334c38a3ae0da25a8924bc/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=58eb03d20f08881d06334c38a3ae0da25a8924bc", "patch": "@@ -5,16 +5,17 @@ use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix, PatStack}\n use super::{PatCtxt, PatKind, PatternError};\n \n use rustc::hir::map::Map;\n-use rustc::lint;\n-use rustc::session::parse::feature_err;\n-use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{HirId, Pat};\n+use rustc_session::lint::builtin::BINDINGS_WITH_VARIANT_NAME;\n+use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS};\n+use rustc_session::parse::feature_err;\n+use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::{MultiSpan, Span};\n use syntax::ast::Mutability;\n@@ -156,9 +157,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n             let inlined_arms: Vec<_> = arms\n                 .iter()\n-                .map(|arm| {\n-                    let (pattern, _) = self.lower_pattern(cx, &arm.pat, &mut have_errors);\n-                    (pattern, &*arm.pat, arm.guard.is_some())\n+                .map(|hir::Arm { pat, guard, .. }| {\n+                    (self.lower_pattern(cx, pat, &mut have_errors).0, pat.hir_id, guard.is_some())\n                 })\n                 .collect();\n \n@@ -285,7 +285,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                         let ty_path = cx.tcx.def_path_str(edef.did);\n                         cx.tcx\n                             .struct_span_lint_hir(\n-                                lint::builtin::BINDINGS_WITH_VARIANT_NAME,\n+                                BINDINGS_WITH_VARIANT_NAME,\n                                 p.hir_id,\n                                 p.span,\n                                 &format!(\n@@ -310,79 +310,63 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n }\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(pat: &Pat<'_>) -> bool {\n-    match pat.kind {\n-        hir::PatKind::Binding(.., None) => true,\n-        hir::PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n-        hir::PatKind::Ref(ref s, _) => pat_is_catchall(s),\n-        hir::PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(&p)),\n+fn pat_is_catchall(pat: &super::Pat<'_>) -> bool {\n+    use super::PatKind::*;\n+    match &*pat.kind {\n+        Binding { subpattern: None, .. } => true,\n+        Binding { subpattern: Some(s), .. } | Deref { subpattern: s } => pat_is_catchall(s),\n+        Leaf { subpatterns: s } => s.iter().all(|p| pat_is_catchall(&p.pattern)),\n         _ => false,\n     }\n }\n \n+fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<Span>) {\n+    let mut err = tcx.struct_span_lint_hir(UNREACHABLE_PATTERNS, id, span, \"unreachable pattern\");\n+    if let Some(catchall) = catchall {\n+        // We had a catchall pattern, hint at that.\n+        err.span_label(span, \"unreachable pattern\");\n+        err.span_label(catchall, \"matches any value\");\n+    }\n+    err.emit();\n+}\n+\n+fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::MatchSource) {\n+    let msg = match source {\n+        hir::MatchSource::IfLetDesugar { .. } => \"irrefutable if-let pattern\",\n+        hir::MatchSource::WhileLetDesugar => \"irrefutable while-let pattern\",\n+        _ => bug!(),\n+    };\n+    tcx.lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, msg);\n+}\n+\n /// Check for unreachable patterns.\n fn check_arms<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    arms: &[(&'p super::Pat<'tcx>, &hir::Pat<'_>, bool)],\n+    arms: &[(&'p super::Pat<'tcx>, HirId, bool)],\n     source: hir::MatchSource,\n ) -> Matrix<'p, 'tcx> {\n     let mut seen = Matrix::empty();\n     let mut catchall = None;\n-    for (arm_index, (pat, hir_pat, has_guard)) in arms.iter().enumerate() {\n+    for (arm_index, (pat, id, has_guard)) in arms.iter().copied().enumerate() {\n         let v = PatStack::from_pattern(pat);\n-\n-        match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id, true) {\n+        match is_useful(cx, &seen, &v, LeaveOutWitness, id, true) {\n             NotUseful => {\n                 match source {\n                     hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => bug!(),\n \n                     hir::MatchSource::IfLetDesugar { .. } | hir::MatchSource::WhileLetDesugar => {\n-                        // check which arm we're on.\n+                        // Check which arm we're on.\n                         match arm_index {\n                             // The arm with the user-specified pattern.\n-                            0 => {\n-                                cx.tcx.lint_hir(\n-                                    lint::builtin::UNREACHABLE_PATTERNS,\n-                                    hir_pat.hir_id,\n-                                    pat.span,\n-                                    \"unreachable pattern\",\n-                                );\n-                            }\n+                            0 => unreachable_pattern(cx.tcx, pat.span, id, None),\n                             // The arm with the wildcard pattern.\n-                            1 => {\n-                                let msg = match source {\n-                                    hir::MatchSource::IfLetDesugar { .. } => {\n-                                        \"irrefutable if-let pattern\"\n-                                    }\n-                                    hir::MatchSource::WhileLetDesugar => {\n-                                        \"irrefutable while-let pattern\"\n-                                    }\n-                                    _ => bug!(),\n-                                };\n-                                cx.tcx.lint_hir(\n-                                    lint::builtin::IRREFUTABLE_LET_PATTERNS,\n-                                    hir_pat.hir_id,\n-                                    pat.span,\n-                                    msg,\n-                                );\n-                            }\n+                            1 => irrefutable_let_pattern(cx.tcx, pat.span, id, source),\n                             _ => bug!(),\n                         }\n                     }\n \n                     hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                        let mut err = cx.tcx.struct_span_lint_hir(\n-                            lint::builtin::UNREACHABLE_PATTERNS,\n-                            hir_pat.hir_id,\n-                            pat.span,\n-                            \"unreachable pattern\",\n-                        );\n-                        // if we had a catchall pattern, hint at that\n-                        if let Some(catchall) = catchall {\n-                            err.span_label(pat.span, \"unreachable pattern\");\n-                            err.span_label(catchall, \"matches any value\");\n-                        }\n-                        err.emit();\n+                        unreachable_pattern(cx.tcx, pat.span, id, catchall);\n                     }\n \n                     // Unreachable patterns in try and await expressions occur when one of\n@@ -392,19 +376,14 @@ fn check_arms<'p, 'tcx>(\n             }\n             Useful(unreachable_subpatterns) => {\n                 for pat in unreachable_subpatterns {\n-                    cx.tcx.lint_hir(\n-                        lint::builtin::UNREACHABLE_PATTERNS,\n-                        hir_pat.hir_id,\n-                        pat.span,\n-                        \"unreachable pattern\",\n-                    );\n+                    unreachable_pattern(cx.tcx, pat.span, id, None);\n                 }\n             }\n             UsefulWithWitness(_) => bug!(),\n         }\n         if !has_guard {\n             seen.push(v);\n-            if catchall.is_none() && pat_is_catchall(hir_pat) {\n+            if catchall.is_none() && pat_is_catchall(pat) {\n                 catchall = Some(pat.span);\n             }\n         }"}, {"sha": "0115fc081a9701f06ce37608998fb3b15547e26c", "filename": "src/test/ui/pattern/usefulness/struct-pattern-match-useless.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58eb03d20f08881d06334c38a3ae0da25a8924bc/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-pattern-match-useless.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58eb03d20f08881d06334c38a3ae0da25a8924bc/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-pattern-match-useless.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-pattern-match-useless.stderr?ref=58eb03d20f08881d06334c38a3ae0da25a8924bc", "patch": "@@ -1,8 +1,10 @@\n error: unreachable pattern\n   --> $DIR/struct-pattern-match-useless.rs:12:9\n    |\n+LL |         Foo { x: _x, y: _y } => (),\n+   |         -------------------- matches any value\n LL |         Foo { .. } => ()\n-   |         ^^^^^^^^^^\n+   |         ^^^^^^^^^^ unreachable pattern\n    |\n note: lint level defined here\n   --> $DIR/struct-pattern-match-useless.rs:1:9"}]}