{"sha": "c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZTI5NjdiOWM2YmQ0M2RkZTgxZjhjMzU3NGNhNjA0MDQwY2M0ZjE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-12-06T10:32:21Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-12-06T10:32:21Z"}, "message": "rustup to rustc 1.15.0-dev (3b248a184 2016-12-05)", "tree": {"sha": "28503f2e28c72f9251c29117165e324c342c64a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28503f2e28c72f9251c29117165e324c342c64a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYRpO1AAoJEFbW7qD8Z6xGlTEQAI7dLq+sKt0dgsHCKoWpxqeO\n9fUigEuHkJ6Rw0ortpMkBatvChZvAqOVtse6ZYp7lvJ0yZ6zG9W7Q6PeutfDE2Zx\nxDgQckMIRRbVC04kNLrBQXnFcj87oPJcxTzeuCy7ssPcDKYDq3g1VT4XW0acIGhJ\nnjkeihd5iYhErQwJz/8sZ6eSaPyxtsS85wsEhzK0YLN9/aNmUVqwaVGMP551AETP\nv8lqYSFtZYciWNPjL2hCjSuR9TTGr2kAh3SsYmjYu5BIO1qqsmld9DqZzE6SgMxQ\nEqGuT6cLhLDdEskjVzhD/bUU+YC+eREiyiuCp89bGDCWmGV4QVsbf2lHqL1usz/g\nEh0kdw3YhNKeuMdNcYTgluHgRaaY6SNjhJZ/KfHuiBr9fhqVxwnIp7WaQp8s6U86\nLL74++A3hOJSpXxP81O+aQQR53v80oUO9XI5erPmeJSlhTPY4Ac+LSgUdnJwKOKP\naMfOeXQxbmk9XbU8eK0oezJMY6Pyn8hp2Yev1KQVcnkKVpfi7BSfJJCSxutdSkZ2\nEFw3Ysn5YM7QjryXbF00ijG6XX4rMTNlHWEX0QjmlghQEe4LO5QzuOhWUYTUMCIB\nrq8mxjzJseSMecLfJ5eEbBoPdMa96glTILQUrHUEd8W5cSd4sE4GEePkNrV8fvLe\nt/IncujYELPz2V6coWkA\n=kXId\n-----END PGP SIGNATURE-----", "payload": "tree 28503f2e28c72f9251c29117165e324c342c64a8\nparent 2e63a5648a5a45d9c2ad1d5f2aea66b304ccea76\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1481020341 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1481020341 +0100\n\nrustup to rustc 1.15.0-dev (3b248a184 2016-12-05)"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "html_url": "https://github.com/rust-lang/rust/commit/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e63a5648a5a45d9c2ad1d5f2aea66b304ccea76", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e63a5648a5a45d9c2ad1d5f2aea66b304ccea76", "html_url": "https://github.com/rust-lang/rust/commit/2e63a5648a5a45d9c2ad1d5f2aea66b304ccea76"}], "stats": {"total": 852, "additions": 517, "deletions": 335}, "files": [{"sha": "9a6678f176a125449b75c2b37326369abd0979ea", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -60,7 +60,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprLit(ref lit) = e.node {\n             check_lit(cx, lit, e);\n         }"}, {"sha": "0ae64e0e7872c751bf3293d08cd65960fdae1be3", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -48,7 +48,7 @@ impl LintPass for Arithmetic {\n }\n \n impl LateLintPass for Arithmetic {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if self.span.is_some() {\n             return;\n         }\n@@ -82,7 +82,7 @@ impl LateLintPass for Arithmetic {\n         }\n     }\n \n-    fn check_expr_post(&mut self, _: &LateContext, expr: &hir::Expr) {\n+    fn check_expr_post<'a, 'tcx: 'a>(&mut self, _: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if Some(expr.span) == self.span {\n             self.span = None;\n         }"}, {"sha": "1f68c32cd24ff00e039d2c38fb6d527e033c4f7f", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -56,7 +56,7 @@ impl LintPass for ArrayIndexing {\n }\n \n impl LateLintPass for ArrayIndexing {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         if let hir::ExprIndex(ref array, ref index) = e.node {\n             // Array with known size can be checked statically\n             let ty = cx.tcx.tables().expr_ty(array);"}, {"sha": "84b61b1cba42b85720aecdb7a9db2618ed59c3ed", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -67,7 +67,7 @@ impl LintPass for AssignOps {\n }\n \n impl LateLintPass for AssignOps {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 span_lint_and_then(cx, ASSIGN_OPS, expr.span, \"assign operation detected\", |db| {"}, {"sha": "5ddbeb5704682e97859ba00170b69d7d6f4ababe", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -82,7 +82,7 @@ impl LintPass for AttrPass {\n }\n \n impl LateLintPass for AttrPass {\n-    fn check_attribute(&mut self, cx: &LateContext, attr: &Attribute) {\n+    fn check_attribute<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, attr: &'tcx Attribute) {\n         if let MetaItemKind::List(ref items) = attr.value.node {\n             if items.is_empty() || attr.name() != \"deprecated\" {\n                 return;\n@@ -99,7 +99,7 @@ impl LateLintPass for AttrPass {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if is_relevant_item(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n@@ -138,38 +138,38 @@ impl LateLintPass for AttrPass {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if is_relevant_impl(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if is_relevant_trait(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n }\n \n fn is_relevant_item(cx: &LateContext, item: &Item) -> bool {\n-    if let ItemFn(_, _, _, _, _, ref expr) = item.node {\n-        is_relevant_expr(cx, expr)\n+    if let ItemFn(_, _, _, _, _, eid) = item.node {\n+        is_relevant_expr(cx, cx.tcx.map.expr(eid))\n     } else {\n         false\n     }\n }\n \n fn is_relevant_impl(cx: &LateContext, item: &ImplItem) -> bool {\n     match item.node {\n-        ImplItemKind::Method(_, ref expr) => is_relevant_expr(cx, expr),\n+        ImplItemKind::Method(_, eid) => is_relevant_expr(cx, cx.tcx.map.expr(eid)),\n         _ => false,\n     }\n }\n \n fn is_relevant_trait(cx: &LateContext, item: &TraitItem) -> bool {\n     match item.node {\n         MethodTraitItem(_, None) => true,\n-        MethodTraitItem(_, Some(ref expr)) => is_relevant_expr(cx, expr),\n+        MethodTraitItem(_, Some(eid)) => is_relevant_expr(cx, cx.tcx.map.expr(eid)),\n         _ => false,\n     }\n }"}, {"sha": "fb305f8907d54ef86db80e469b2084a173600f56", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -80,7 +80,7 @@ impl LintPass for BitMask {\n }\n \n impl LateLintPass for BitMask {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {"}, {"sha": "542bf0a4f2854c0c3a96fa2de7b2465a1bd007bd", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -38,7 +38,7 @@ impl LintPass for BlackListedName {\n }\n \n impl LateLintPass for BlackListedName {\n-    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n+    fn check_pat<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if let PatKind::Binding(_, _, ref ident, _) = pat.node {\n             if self.blacklist.iter().any(|s| s == &*ident.node.as_str()) {\n                 span_lint(cx,"}, {"sha": "1ac96bf6bcafb533c632eabdda004e40a05a6749", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::{LateLintPass, LateContext, LintArray, LintPass};\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use utils::*;\n \n /// **What it does:** Checks for `if` conditions that use blocks to contain an\n@@ -49,28 +49,33 @@ impl LintPass for BlockInIfCondition {\n     }\n }\n \n-struct ExVisitor<'v> {\n-    found_block: Option<&'v Expr>,\n+struct ExVisitor<'a, 'tcx: 'a> {\n+    found_block: Option<&'tcx Expr>,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v> Visitor<'v> for ExVisitor<'v> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n-        if let ExprClosure(_, _, ref expr, _) = expr.node {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let ExprClosure(_, _, eid, _) = expr.node {\n+            let expr = self.cx.tcx.map.expr(eid);\n             if matches!(expr.node, ExprBlock(_)) {\n                 self.found_block = Some(expr);\n                 return;\n             }\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n const BRACED_EXPR_MESSAGE: &'static str = \"omit braces around single expression condition\";\n const COMPLEX_BLOCK_MESSAGE: &'static str = \"in an 'if' condition, avoid complex blocks or closures with blocks; \\\n                                              instead, move the block or closure higher and bind it with a 'let'\";\n \n impl LateLintPass for BlockInIfCondition {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprIf(ref check, ref then, _) = expr.node {\n             if let ExprBlock(ref block) = check.node {\n                 if block.rules == DefaultBlock {\n@@ -105,7 +110,7 @@ impl LateLintPass for BlockInIfCondition {\n                     }\n                 }\n             } else {\n-                let mut visitor = ExVisitor { found_block: None };\n+                let mut visitor = ExVisitor { found_block: None, cx: cx };\n                 walk_expr(&mut visitor, check);\n                 if let Some(block) = visitor.found_block {\n                     span_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span, COMPLEX_BLOCK_MESSAGE);"}, {"sha": "64c575046a21bda26517824f1b4999138bcc09a7", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -54,12 +54,14 @@ impl LintPass for NonminimalBool {\n }\n \n impl LateLintPass for NonminimalBool {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        NonminimalBoolVisitor(cx).visit_item(item)\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n+        NonminimalBoolVisitor { cx: cx }.visit_item(item)\n     }\n }\n \n-struct NonminimalBoolVisitor<'a, 'tcx: 'a>(&'a LateContext<'a, 'tcx>);\n+struct NonminimalBoolVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n \n use quine_mc_cluskey::Bool;\n struct Hir2Qmm<'a, 'tcx: 'a, 'v> {\n@@ -308,7 +310,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n     fn bool_expr(&self, e: &Expr) {\n         let mut h2q = Hir2Qmm {\n             terminals: Vec::new(),\n-            cx: self.0,\n+            cx: self.cx,\n         };\n         if let Ok(expr) = h2q.run(e) {\n \n@@ -343,7 +345,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                         continue 'simplified;\n                     }\n                     if stats.terminals[i] != 0 && simplified_stats.terminals[i] == 0 {\n-                        span_lint_and_then(self.0,\n+                        span_lint_and_then(self.cx,\n                                            LOGIC_BUG,\n                                            e.span,\n                                            \"this boolean expression contains a logic bug\",\n@@ -353,7 +355,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                                           outer expression\");\n                             db.span_suggestion(e.span,\n                                                \"it would look like the following\",\n-                                               suggest(self.0, suggestion, &h2q.terminals));\n+                                               suggest(self.cx, suggestion, &h2q.terminals));\n                         });\n                         // don't also lint `NONMINIMAL_BOOL`\n                         return;\n@@ -370,29 +372,29 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                 }\n             }\n             if !improvements.is_empty() {\n-                span_lint_and_then(self.0,\n+                span_lint_and_then(self.cx,\n                                    NONMINIMAL_BOOL,\n                                    e.span,\n                                    \"this boolean expression can be simplified\",\n                                    |db| {\n                     for suggestion in &improvements {\n-                        db.span_suggestion(e.span, \"try\", suggest(self.0, suggestion, &h2q.terminals));\n+                        db.span_suggestion(e.span, \"try\", suggest(self.cx, suggestion, &h2q.terminals));\n                     }\n                 });\n             }\n         }\n     }\n }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, e: &'v Expr) {\n-        if in_macro(self.0, e.span) {\n+impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'tcx Expr) {\n+        if in_macro(self.cx, e.span) {\n             return;\n         }\n         match e.node {\n             ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n             ExprUnary(UnNot, ref inner) => {\n-                if self.0.tcx.tables.borrow().node_types[&inner.id].is_bool() {\n+                if self.cx.tcx.tables.borrow().node_types[&inner.id].is_bool() {\n                     self.bool_expr(e);\n                 } else {\n                     walk_expr(self, e);\n@@ -401,4 +403,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n             _ => walk_expr(self, e),\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "1931b5d1e3f6fff964e2aea604767a45dd9d01db", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -110,7 +110,7 @@ impl LintPass for CopyAndPaste {\n }\n \n impl LateLintPass for CopyAndPaste {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if !in_macro(cx, expr.span) {\n             // skip ifs directly in else, it will be checked in the parent if\n             if let Some(&Expr { node: ExprIf(_, _, Some(ref else_expr)), .. }) = get_parent_expr(cx, expr) {"}, {"sha": "67066d32cc3e9e1d3da4296358703538e1dec0f8", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -4,7 +4,7 @@ use rustc::cfg::CFG;\n use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use syntax::ast::Attribute;\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -42,7 +42,7 @@ impl LintPass for CyclomaticComplexity {\n }\n \n impl CyclomaticComplexity {\n-    fn check<'a, 'tcx>(&mut self, cx: &'a LateContext<'a, 'tcx>, expr: &Expr, span: Span) {\n+    fn check<'a, 'tcx: 'a>(&mut self, cx: &'a LateContext<'a, 'tcx>, expr: &'tcx Expr, span: Span) {\n         if in_macro(cx, span) {\n             return;\n         }\n@@ -60,7 +60,7 @@ impl CyclomaticComplexity {\n             divergence: 0,\n             short_circuits: 0,\n             returns: 0,\n-            tcx: &cx.tcx,\n+            cx: cx,\n         };\n         helper.visit_expr(expr);\n         let CCHelper { match_arms, divergence, short_circuits, returns, .. } = helper;\n@@ -91,44 +91,44 @@ impl CyclomaticComplexity {\n }\n \n impl LateLintPass for CyclomaticComplexity {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        if let ItemFn(_, _, _, _, _, ref expr) = item.node {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n+        if let ItemFn(_, _, _, _, _, eid) = item.node {\n             if !attr::contains_name(&item.attrs, \"test\") {\n-                self.check(cx, expr, item.span);\n+                self.check(cx, cx.tcx.map.expr(eid), item.span);\n             }\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n-        if let ImplItemKind::Method(_, ref expr) = item.node {\n-            self.check(cx, expr, item.span);\n+    fn check_impl_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n+        if let ImplItemKind::Method(_, eid) = item.node {\n+            self.check(cx, cx.tcx.map.expr(eid), item.span);\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n-        if let MethodTraitItem(_, Some(ref expr)) = item.node {\n-            self.check(cx, expr, item.span);\n+    fn check_trait_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n+        if let MethodTraitItem(_, Some(eid)) = item.node {\n+            self.check(cx, cx.tcx.map.expr(eid), item.span);\n         }\n     }\n \n-    fn enter_lint_attrs(&mut self, cx: &LateContext, attrs: &[Attribute]) {\n+    fn enter_lint_attrs<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n         self.limit.push_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n     }\n-    fn exit_lint_attrs(&mut self, cx: &LateContext, attrs: &[Attribute]) {\n+    fn exit_lint_attrs<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n         self.limit.pop_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n     }\n }\n \n-struct CCHelper<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+struct CCHelper<'a, 'tcx: 'a> {\n     match_arms: u64,\n     divergence: u64,\n     returns: u64,\n     short_circuits: u64, // && and ||\n-    tcx: &'a ty::TyCtxt<'a, 'gcx, 'tcx>,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'a, 'b, 'tcx, 'gcx> Visitor<'a> for CCHelper<'b, 'gcx, 'tcx> {\n-    fn visit_expr(&mut self, e: &'a Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n             ExprMatch(_, ref arms, _) => {\n                 walk_expr(self, e);\n@@ -139,7 +139,7 @@ impl<'a, 'b, 'tcx, 'gcx> Visitor<'a> for CCHelper<'b, 'gcx, 'tcx> {\n             }\n             ExprCall(ref callee, _) => {\n                 walk_expr(self, e);\n-                let ty = self.tcx.tables().node_id_to_type(callee.id);\n+                let ty = self.cx.tcx.tables().node_id_to_type(callee.id);\n                 match ty.sty {\n                     ty::TyFnDef(_, _, ty) |\n                     ty::TyFnPtr(ty) if ty.sig.skip_binder().output.sty == ty::TyNever => {\n@@ -160,6 +160,9 @@ impl<'a, 'b, 'tcx, 'gcx> Visitor<'a> for CCHelper<'b, 'gcx, 'tcx> {\n             _ => walk_expr(self, e),\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n }\n \n #[cfg(feature=\"debugging\")]"}, {"sha": "4e9f7d9c6645360ebd8fe9c001fc0e39ade14087", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -71,7 +71,7 @@ impl LintPass for Derive {\n }\n \n impl LateLintPass for Derive {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n             let ty = cx.tcx.item_type(cx.tcx.map.local_def_id(item.id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);"}, {"sha": "c16d879ec2f546d3463feba54e88a2e1a5f08532", "filename": "clippy_lints/src/drop_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_ref.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -36,7 +36,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprCall(ref path, ref args) = expr.node {\n             if let ExprPath(ref qpath) = path.node {\n                 let def_id = cx.tcx.tables().qpath_def(qpath, path.id).def_id();"}, {"sha": "133d2dc68f92e74d521746a0dc9cd2d98f891e2c", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr, walk_block};\n+use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, NestedVisitorMap};\n use rustc::lint::*;\n use syntax::codemap::Span;\n use utils::SpanlessEq;\n@@ -40,7 +40,7 @@ impl LintPass for HashMapLint {\n }\n \n impl LateLintPass for HashMapLint {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprIf(ref check, ref then_block, ref else_block) = expr.node {\n             if let ExprUnary(UnOp::UnNot, ref check) = check.node {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n@@ -111,8 +111,8 @@ struct InsertVisitor<'a, 'tcx: 'a, 'b> {\n     sole_expr: bool,\n }\n \n-impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let ExprMethodCall(ref name, _, ref params) = expr.node,\n             params.len() == 3,\n@@ -144,4 +144,7 @@ impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n             walk_expr(self, expr);\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "28fd9833e25c6094e2f92a203843eb2a479ac7f8", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -38,7 +38,7 @@ impl LintPass for UnportableVariant {\n \n impl LateLintPass for UnportableVariant {\n     #[allow(cast_possible_truncation, cast_sign_loss)]\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemEnum(ref def, _) = item.node {\n             for var in &def.variants {\n                 let variant = &var.node;"}, {"sha": "1db8607bd25720289e408bce1f54e75075c5659f", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -33,7 +33,7 @@ impl LintPass for EnumGlobUse {\n }\n \n impl LateLintPass for EnumGlobUse {\n-    fn check_mod(&mut self, cx: &LateContext, m: &Mod, _: Span, _: NodeId) {\n+    fn check_mod<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, m: &'tcx Mod, _: Span, _: NodeId) {\n         // only check top level `use` statements\n         for item in &m.item_ids {\n             self.lint_item(cx, cx.krate.item(item.id));"}, {"sha": "8cfeabba9fcb2ad136932e0796093da425d8581d", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -33,7 +33,7 @@ impl LintPass for EqOp {\n }\n \n impl LateLintPass for EqOp {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n             if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n                 span_lint(cx,"}, {"sha": "df01e0481a80086bfe3e84cc2a8277d5452af740", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -61,7 +61,15 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, _: visit::FnKind, decl: &FnDecl, body: &Expr, _: Span, id: NodeId) {\n+    fn check_fn<'a, 'tcx: 'a>(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: visit::FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        body: &'tcx Expr,\n+        _: Span,\n+        id: NodeId,\n+    ) {\n         let param_env = ty::ParameterEnvironment::for_item(cx.tcx, id);\n \n         let infcx = cx.tcx.borrowck_fake_infer_ctxt(param_env);"}, {"sha": "c8d468f7fa90eac015bdefdbfb313805be5a1294", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -34,7 +34,7 @@ impl LintPass for EtaPass {\n }\n \n impl LateLintPass for EtaPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n             ExprCall(_, ref args) |\n             ExprMethodCall(_, _, ref args) => {\n@@ -48,7 +48,8 @@ impl LateLintPass for EtaPass {\n }\n \n fn check_closure(cx: &LateContext, expr: &Expr) {\n-    if let ExprClosure(_, ref decl, ref ex, _) = expr.node {\n+    if let ExprClosure(_, ref decl, eid, _) = expr.node {\n+        let ex = cx.tcx.map.expr(eid);\n         if let ExprCall(ref caller, ref args) = ex.node {\n             if args.len() != decl.inputs.len() {\n                 // Not the same number of arguments, there"}, {"sha": "3a991b0f28b29b54389bb5c7e39e42147e6f7100", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use rustc::hir::*;\n use rustc::ty;\n use rustc::lint::*;\n@@ -57,7 +57,7 @@ impl LintPass for EvalOrderDependence {\n }\n \n impl LateLintPass for EvalOrderDependence {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // Find a write to a local variable.\n         match expr.node {\n             ExprAssign(ref lhs, _) | ExprAssignOp(_, ref lhs, _) => {\n@@ -79,24 +79,26 @@ impl LateLintPass for EvalOrderDependence {\n             _ => {}\n         }\n     }\n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n+    fn check_stmt<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         match stmt.node {\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) => DivergenceVisitor(cx).maybe_walk_expr(e),\n+            StmtExpr(ref e, _) | StmtSemi(ref e, _) => DivergenceVisitor { cx: cx }.maybe_walk_expr(e),\n             StmtDecl(ref d, _) => {\n                 if let DeclLocal(ref local) = d.node {\n                     if let Local { init: Some(ref e), .. } = **local {\n-                        DivergenceVisitor(cx).visit_expr(e);\n+                        DivergenceVisitor { cx: cx }.visit_expr(e);\n                     }\n                 }\n             },\n         }\n     }\n }\n \n-struct DivergenceVisitor<'a, 'tcx: 'a>(&'a LateContext<'a, 'tcx>);\n+struct DivergenceVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n \n impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n-    fn maybe_walk_expr(&mut self, e: &Expr) {\n+    fn maybe_walk_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n             ExprClosure(..) => {},\n             ExprMatch(ref e, ref arms, _) => {\n@@ -114,33 +116,33 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n     }\n     fn report_diverging_sub_expr(&mut self, e: &Expr) {\n         span_lint(\n-            self.0,\n+            self.cx,\n             DIVERGING_SUB_EXPRESSION,\n             e.span,\n             \"sub-expression diverges\",\n         );\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for DivergenceVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, e: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n             ExprAgain(_) |\n             ExprBreak(_, _) |\n             ExprRet(_) => self.report_diverging_sub_expr(e),\n-            ExprCall(ref func, _) => match self.0.tcx.tables().expr_ty(func).sty {\n+            ExprCall(ref func, _) => match self.cx.tcx.tables().expr_ty(func).sty {\n                 ty::TyFnDef(_, _, fn_ty) |\n-                ty::TyFnPtr(fn_ty) => if let ty::TyNever = self.0.tcx.erase_late_bound_regions(&fn_ty.sig).output.sty {\n+                ty::TyFnPtr(fn_ty) => if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&fn_ty.sig).output.sty {\n                     self.report_diverging_sub_expr(e);\n                 },\n                 _ => {},\n             },\n             ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(e.id);\n-                let borrowed_table = self.0.tcx.tables.borrow();\n+                let borrowed_table = self.cx.tcx.tables.borrow();\n                 let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n                 let result_ty = method_type.ty.fn_ret();\n-                if let ty::TyNever = self.0.tcx.erase_late_bound_regions(&result_ty).sty {\n+                if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&result_ty).sty {\n                     self.report_diverging_sub_expr(e);\n                 }\n             },\n@@ -150,9 +152,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DivergenceVisitor<'a, 'tcx> {\n         }\n         self.maybe_walk_expr(e);\n     }\n-    fn visit_block(&mut self, _: &'v Block) {\n+    fn visit_block(&mut self, _: &'tcx Block) {\n         // don't continue over blocks, LateLintPass already does that\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// Walks up the AST from the the given write expression (`vis.write_expr`)\n@@ -209,7 +214,7 @@ enum StopEarly {\n     Stop,\n }\n \n-fn check_expr<'v, 't>(vis: & mut ReadVisitor<'v, 't>, expr: &'v Expr) -> StopEarly {\n+fn check_expr<'a, 'tcx: 'a>(vis: & mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> StopEarly {\n     if expr.id == vis.last_expr.id {\n         return StopEarly::KeepGoing;\n     }\n@@ -258,7 +263,7 @@ fn check_expr<'v, 't>(vis: & mut ReadVisitor<'v, 't>, expr: &'v Expr) -> StopEar\n     StopEarly::KeepGoing\n }\n \n-fn check_stmt<'v, 't>(vis: &mut ReadVisitor<'v, 't>, stmt: &'v Stmt) -> StopEarly {\n+fn check_stmt<'a, 'tcx: 'a>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> StopEarly {\n     match stmt.node {\n         StmtExpr(ref expr, _) |\n         StmtSemi(ref expr, _) => check_expr(vis, expr),\n@@ -276,20 +281,20 @@ fn check_stmt<'v, 't>(vis: &mut ReadVisitor<'v, 't>, stmt: &'v Stmt) -> StopEarl\n }\n \n /// A visitor that looks for reads from a variable.\n-struct ReadVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>,\n+struct ReadVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     /// The id of the variable we're looking for.\n     var: DefId,\n     /// The expressions where the write to the variable occurred (for reporting\n     /// in the lint).\n-    write_expr: &'v Expr,\n+    write_expr: &'tcx Expr,\n     /// The last (highest in the AST) expression we've checked, so we know not\n     /// to recheck it.\n-    last_expr: &'v Expr,\n+    last_expr: &'tcx Expr,\n }\n \n-impl<'v, 't> Visitor<'v> for ReadVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if expr.id == self.last_expr.id {\n             return;\n         }\n@@ -336,6 +341,9 @@ impl<'v, 't> Visitor<'v> for ReadVisitor<'v, 't> {\n \n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// Returns true if `expr` is the LHS of an assignment, like `expr = ...`."}, {"sha": "236888fe191e9ef3fca71aaf8a4f9d4a184ff1de", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -39,7 +39,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let Some(span) = is_expn_of(cx, expr.span, \"format\") {\n             match expr.node {\n                 // `format!(\"{}\", foo)` expansion"}, {"sha": "0d9a668e8b621b8af330e93d705b31af385eeadd", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -69,7 +69,15 @@ impl LintPass for Functions {\n }\n \n impl LateLintPass for Functions {\n-    fn check_fn(&mut self, cx: &LateContext, kind: intravisit::FnKind, decl: &hir::FnDecl, expr: &hir::Expr, span: Span, nodeid: ast::NodeId) {\n+    fn check_fn<'a, 'tcx: 'a>(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: intravisit::FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl,\n+        expr: &'tcx hir::Expr,\n+        span: Span,\n+        nodeid: ast::NodeId,\n+    ) {\n         use rustc::hir::map::Node::*;\n \n         let is_impl = if let Some(NodeItem(item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {\n@@ -97,14 +105,15 @@ impl LateLintPass for Functions {\n         self.check_raw_ptr(cx, unsafety, decl, expr, nodeid);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n-        if let hir::MethodTraitItem(ref sig, ref expr) = item.node {\n+    fn check_trait_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n+        if let hir::MethodTraitItem(ref sig, eid) = item.node {\n             // don't lint extern functions decls, it's not their fault\n             if sig.abi == Abi::Rust {\n                 self.check_arg_number(cx, &sig.decl, item.span);\n             }\n \n-            if let Some(ref expr) = *expr {\n+            if let Some(eid) = eid {\n+                let expr = cx.tcx.map.expr(eid);\n                 self.check_raw_ptr(cx, sig.unsafety, &sig.decl, expr, item.id);\n             }\n         }\n@@ -122,7 +131,14 @@ impl Functions {\n         }\n     }\n \n-    fn check_raw_ptr(&self, cx: &LateContext, unsafety: hir::Unsafety, decl: &hir::FnDecl, expr: &hir::Expr, nodeid: ast::NodeId) {\n+    fn check_raw_ptr<'a, 'tcx: 'a>(\n+        &self,\n+        cx: &LateContext<'a, 'tcx>,\n+        unsafety: hir::Unsafety,\n+        decl: &'tcx hir::FnDecl,\n+        expr: &'tcx hir::Expr,\n+        nodeid: ast::NodeId,\n+    ) {\n         if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(nodeid) {\n             let raw_ptrs = decl.inputs.iter().filter_map(|arg| raw_ptr_arg(cx, arg)).collect::<HashSet<_>>();\n \n@@ -151,8 +167,8 @@ struct DerefVisitor<'a, 'tcx: 'a> {\n     ptrs: HashSet<hir::def_id::DefId>,\n }\n \n-impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for DerefVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprCall(ref f, ref args) => {\n                 let ty = self.cx.tcx.tables().expr_ty(f);\n@@ -179,6 +195,9 @@ impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for DerefVisitor<'a, 'tcx> {\n \n         hir::intravisit::walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {"}, {"sha": "f360c59372bc5eba4e4a502d2ac2300901a03ea0", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -32,7 +32,7 @@ impl LintPass for IdentityOp {\n }\n \n impl LateLintPass for IdentityOp {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if in_macro(cx, e.span) {\n             return;\n         }"}, {"sha": "bc834886db96eada09b5f7c85f632005f4b62652", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -43,7 +43,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n \n         if let ExprMatch(ref op, ref arms, MatchSource::IfLetDesugar{..}) = expr.node {\n "}, {"sha": "98db74cff3a21673a0bfe5aff05778f520119a31", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -60,7 +60,7 @@ impl LintPass for LenZero {\n }\n \n impl LateLintPass for LenZero {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if in_macro(cx, item.span) {\n             return;\n         }\n@@ -72,7 +72,7 @@ impl LateLintPass for LenZero {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if in_macro(cx, expr.span) {\n             return;\n         }\n@@ -208,7 +208,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n \n     let ty = &walk_ptrs_ty(cx.tcx.tables().expr_ty(expr));\n     match ty.sty {\n-        ty::TyTrait(_) => {\n+        ty::TyDynamic(..) => {\n             cx.tcx\n               .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n               .any(|item| is_is_empty(cx, &item))"}, {"sha": "1605505a6ae3dbb8346b3470703d0788737ba975", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -58,7 +58,7 @@ impl LintPass for LetIfSeq {\n }\n \n impl LateLintPass for LetIfSeq {\n-    fn check_block(&mut self, cx: &LateContext, block: &hir::Block) {\n+    fn check_block<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block) {\n         let mut it = block.stmts.iter().peekable();\n         while let Some(stmt) = it.next() {\n             if_let_chain! {[\n@@ -133,8 +133,8 @@ struct UsedVisitor<'a, 'tcx: 'a> {\n     used: bool,\n }\n \n-impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for UsedVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if_let_chain! {[\n             let hir::ExprPath(ref qpath) = expr.node,\n             self.id == self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id(),\n@@ -144,9 +144,16 @@ impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for UsedVisitor<'a, 'tcx> {\n         }}\n         hir::intravisit::walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> hir::intravisit::NestedVisitorMap<'this, 'tcx> {\n+        hir::intravisit::NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-fn check_assign<'e>(cx: &LateContext, decl: hir::def_id::DefId, block: &'e hir::Block) -> Option<&'e hir::Expr> {\n+fn check_assign<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    decl: hir::def_id::DefId,\n+    block: &'tcx hir::Block,\n+) -> Option<&'tcx hir::Expr> {\n     if_let_chain! {[\n         block.expr.is_none(),\n         let Some(expr) = block.stmts.iter().last(),\n@@ -175,7 +182,11 @@ fn check_assign<'e>(cx: &LateContext, decl: hir::def_id::DefId, block: &'e hir::\n     None\n }\n \n-fn used_in_expr(cx: &LateContext, id: hir::def_id::DefId, expr: &hir::Expr) -> bool {\n+fn used_in_expr<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    id: hir::def_id::DefId,\n+    expr: &'tcx hir::Expr,\n+) -> bool {\n     let mut v = UsedVisitor {\n         cx: cx,\n         id: id,"}, {"sha": "b28c78f29d1c43f30e5ba55f485e3364c04b0048", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -9,6 +9,7 @@\n #![feature(repeat_str)]\n \n #![allow(indexing_slicing, shadow_reuse, unknown_lints, missing_docs_in_private_items)]\n+#![allow(needless_lifetimes)]\n \n #[macro_use]\n extern crate syntax;"}, {"sha": "22e7384675fb7919eca84134466f3084918a0c82", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -2,7 +2,7 @@ use reexport::*;\n use rustc::lint::*;\n use rustc::hir::def::Def;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_ty, walk_ty_param_bound, walk_fn_decl, walk_generics};\n+use rustc::hir::intravisit::{Visitor, walk_ty, walk_ty_param_bound, walk_fn_decl, walk_generics, NestedVisitorMap};\n use std::collections::{HashSet, HashMap};\n use syntax::codemap::Span;\n use utils::{in_external_macro, span_lint, last_path_segment};\n@@ -57,19 +57,19 @@ impl LintPass for LifetimePass {\n }\n \n impl LateLintPass for LifetimePass {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemFn(ref decl, _, _, _, ref generics, _) = item.node {\n             check_fn_inner(cx, decl, generics, item.span);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(ref sig, _) = item.node {\n             check_fn_inner(cx, &sig.decl, &sig.generics, item.span);\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n             check_fn_inner(cx, &sig.decl, &sig.generics, item.span);\n         }\n@@ -98,7 +98,12 @@ fn bound_lifetimes(bound: &TyParamBound) -> HirVec<&Lifetime> {\n     }\n }\n \n-fn check_fn_inner(cx: &LateContext, decl: &FnDecl, generics: &Generics, span: Span) {\n+fn check_fn_inner<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    decl: &'tcx FnDecl,\n+    generics: &'tcx Generics,\n+    span: Span,\n+) {\n     if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n@@ -116,9 +121,16 @@ fn check_fn_inner(cx: &LateContext, decl: &FnDecl, generics: &Generics, span: Sp\n     report_extra_lifetimes(cx, decl, generics);\n }\n \n-fn could_use_elision<'a, T: Iterator<Item = &'a Lifetime>>(cx: &LateContext, func: &FnDecl,\n-                                                           named_lts: &[LifetimeDef], bounds_lts: T)\n-                                                           -> bool {\n+fn could_use_elision<\n+    'a,\n+    'tcx: 'a,\n+    T: Iterator<Item = &'tcx Lifetime>\n+>(\n+    cx: &LateContext<'a, 'tcx>,\n+    func: &'tcx FnDecl,\n+    named_lts: &'tcx [LifetimeDef],\n+    bounds_lts: T,\n+) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n@@ -210,8 +222,8 @@ fn unique_lifetimes(lts: &[RefLt]) -> usize {\n }\n \n /// A visitor usable for `rustc_front::visit::walk_ty()`.\n-struct RefVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>,\n+struct RefVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     lts: Vec<RefLt>,\n }\n \n@@ -253,7 +265,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                     }\n                     Def::Trait(def_id) => {\n                         let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n-                        for _ in &trait_def.generics.regions {\n+                        for _ in &self.cx.tcx.item_generics(trait_def.def_id).regions {\n                             self.record(&None);\n                         }\n                     }\n@@ -264,13 +276,13 @@ impl<'v, 't> RefVisitor<'v, 't> {\n     }\n }\n \n-impl<'v, 't> Visitor<'v> for RefVisitor<'v, 't> {\n+impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n     // for lifetimes as parameters of generics\n-    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n         self.record(&Some(*lifetime));\n     }\n \n-    fn visit_ty(&mut self, ty: &'v Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx Ty) {\n         match ty.node {\n             TyRptr(None, _) => {\n                 self.record(&None);\n@@ -282,11 +294,14 @@ impl<'v, 't> Visitor<'v> for RefVisitor<'v, 't> {\n         }\n         walk_ty(self, ty);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n }\n \n /// Are any lifetimes mentioned in the `where` clause? If yes, we don't try to\n /// reason about elision.\n-fn has_where_lifetimes(cx: &LateContext, where_clause: &WhereClause) -> bool {\n+fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &'tcx WhereClause) -> bool {\n     for predicate in &where_clause.predicates {\n         match *predicate {\n             WherePredicate::RegionPredicate(..) => return true,\n@@ -323,34 +338,39 @@ fn has_where_lifetimes(cx: &LateContext, where_clause: &WhereClause) -> bool {\n     false\n }\n \n-struct LifetimeChecker(HashMap<Name, Span>);\n+struct LifetimeChecker {\n+    map: HashMap<Name, Span>,\n+}\n \n-impl<'v> Visitor<'v> for LifetimeChecker {\n+impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n     // for lifetimes as parameters of generics\n-    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n-        self.0.remove(&lifetime.name);\n+    fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n+        self.map.remove(&lifetime.name);\n     }\n \n-    fn visit_lifetime_def(&mut self, _: &'v LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, _: &'tcx LifetimeDef) {\n         // don't actually visit `<'a>` or `<'a: 'b>`\n         // we've already visited the `'a` declarations and\n         // don't want to spuriously remove them\n         // `'b` in `'a: 'b` is useless unless used elsewhere in\n         // a non-lifetime bound\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n }\n \n-fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl, generics: &Generics) {\n+fn report_extra_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, func: &'tcx FnDecl, generics: &'tcx Generics) {\n     let hs = generics.lifetimes\n                      .iter()\n                      .map(|lt| (lt.lifetime.name, lt.lifetime.span))\n                      .collect();\n-    let mut checker = LifetimeChecker(hs);\n+    let mut checker = LifetimeChecker { map: hs };\n \n     walk_generics(&mut checker, generics);\n     walk_fn_decl(&mut checker, func);\n \n-    for &v in checker.0.values() {\n+    for &v in checker.map.values() {\n         span_lint(cx, UNUSED_LIFETIMES, v, \"this lifetime isn't used in the function definition\");\n     }\n }"}, {"sha": "233c6289009686db7a1de9412379af100a81f55a", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 76, "deletions": 32, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -2,7 +2,7 @@ use reexport::*;\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, walk_decl};\n+use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, walk_decl, NestedVisitorMap};\n use rustc::hir::map::Node::NodeBlock;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n@@ -308,7 +308,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let Some((pat, arg, body)) = higher::for_loop(expr) {\n             check_for_loop(cx, pat, arg, body, expr);\n         }\n@@ -391,7 +391,7 @@ impl LateLintPass for Pass {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n+    fn check_stmt<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1 && &*method.node.as_str() == \"collect\" &&\n@@ -407,7 +407,13 @@ impl LateLintPass for Pass {\n     }\n }\n \n-fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr,\n+) {\n     check_for_loop_range(cx, pat, arg, body, expr);\n     check_for_loop_reverse_range(cx, arg, expr);\n     check_for_loop_arg(cx, pat, arg, expr);\n@@ -417,7 +423,13 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n \n /// Check for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n-fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop_range<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr,\n+) {\n     if let Some(higher::Range { start: Some(start), ref end, limits }) = higher::range(arg) {\n         // the var must be a single name\n         if let PatKind::Binding(_, def_id, ref ident, _) = pat.node {\n@@ -646,7 +658,12 @@ fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n     }\n }\n \n-fn check_for_loop_explicit_counter(cx: &LateContext, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop_explicit_counter<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr,\n+) {\n     // Look for variables that are incremented once per loop iteration.\n     let mut visitor = IncrementVisitor {\n         cx: cx,\n@@ -691,14 +708,20 @@ fn check_for_loop_explicit_counter(cx: &LateContext, arg: &Expr, body: &Expr, ex\n }\n \n /// Check for the `FOR_KV_MAP` lint.\n-fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop_over_map_kv<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr,\n+) {\n     let pat_span = pat.span;\n \n     if let PatKind::Tuple(ref pat, _) = pat.node {\n         if pat.len() == 2 {\n             let (new_pat_span, kind) = match (&pat[0].node, &pat[1].node) {\n-                (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\"),\n-                (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\"),\n+                (key, _) if pat_is_wild(cx, key, body) => (pat[1].span, \"value\"),\n+                (_, value) if pat_is_wild(cx, value, body) => (pat[0].span, \"key\"),\n                 _ => return,\n             };\n \n@@ -728,13 +751,18 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n }\n \n /// Return true if the pattern is a `PatWild` or an ident prefixed with `'_'`.\n-fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n+fn pat_is_wild<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx PatKind,\n+    body: &'tcx Expr,\n+) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n         PatKind::Binding(_, _, ident, None) if ident.node.as_str().starts_with('_') => {\n             let mut visitor = UsedVisitor {\n                 var: ident.node,\n                 used: false,\n+                cx: cx,\n             };\n             walk_expr(&mut visitor, body);\n             !visitor.used\n@@ -743,13 +771,14 @@ fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n     }\n }\n \n-struct UsedVisitor {\n+struct UsedVisitor<'a, 'tcx: 'a> {\n     var: ast::Name, // var to look for\n     used: bool, // has the var been used otherwise?\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'a> Visitor<'a> for UsedVisitor {\n-    fn visit_expr(&mut self, expr: &Expr) {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if let ExprPath(QPath::Resolved(None, ref path)) = expr.node {\n             if path.segments.len() == 1 && path.segments[0].name == self.var {\n                 self.used = true;\n@@ -759,17 +788,20 @@ impl<'a> Visitor<'a> for UsedVisitor {\n \n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-struct VarVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>, // context reference\n+struct VarVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>, // context reference\n     var: DefId, // var name to look for as index\n     indexed: HashMap<Name, Option<CodeExtent>>, // indexed variables, the extent is None for global\n     nonindex: bool, // has the var been used otherwise?\n }\n \n-impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if let ExprPath(ref qpath) = expr.node {\n             if let QPath::Resolved(None, ref path) = *qpath {\n                 if path.segments.len() == 1 && self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id() == self.var {\n@@ -806,9 +838,12 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-fn is_iterator_used_after_while_let(cx: &LateContext, iter_expr: &Expr) -> bool {\n+fn is_iterator_used_after_while_let<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, iter_expr: &'tcx Expr) -> bool {\n     let def_id = match var_def_id(cx, iter_expr) {\n         Some(id) => id,\n         None => return false,\n@@ -826,16 +861,16 @@ fn is_iterator_used_after_while_let(cx: &LateContext, iter_expr: &Expr) -> bool\n     visitor.var_used_after_while_let\n }\n \n-struct VarUsedAfterLoopVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>,\n+struct VarUsedAfterLoopVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     def_id: NodeId,\n     iter_expr_id: NodeId,\n     past_while_let: bool,\n     var_used_after_while_let: bool,\n }\n \n-impl<'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if self.past_while_let {\n             if Some(self.def_id) == var_def_id(self.cx, expr) {\n                 self.var_used_after_while_let = true;\n@@ -845,6 +880,9 @@ impl<'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n \n@@ -935,15 +973,15 @@ enum VarState {\n }\n \n /// Scan a for loop for variables that are incremented exactly once.\n-struct IncrementVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>, // context reference\n+struct IncrementVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>, // context reference\n     states: HashMap<NodeId, VarState>, // incremented variables\n     depth: u32, // depth of conditional expressions\n     done: bool,\n }\n \n-impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if self.done {\n             return;\n         }\n@@ -984,21 +1022,24 @@ impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// Check whether a variable is initialized to zero at the start of a loop.\n-struct InitializeVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>, // context reference\n-    end_expr: &'v Expr, // the for loop. Stop scanning here.\n+struct InitializeVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>, // context reference\n+    end_expr: &'tcx Expr, // the for loop. Stop scanning here.\n     var_id: NodeId,\n     state: VarState,\n     name: Option<Name>,\n     depth: u32, // depth of conditional expressions\n     past_loop: bool,\n }\n \n-impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n-    fn visit_decl(&mut self, decl: &'v Decl) {\n+impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n+    fn visit_decl(&mut self, decl: &'tcx Decl) {\n         // Look for declarations of the variable\n         if let DeclLocal(ref local) = decl.node {\n             if local.pat.id == self.var_id {\n@@ -1020,7 +1061,7 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n         walk_decl(self, decl);\n     }\n \n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if self.state == VarState::DontWarn {\n             return;\n         }\n@@ -1068,6 +1109,9 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {"}, {"sha": "416f9dcf93eb97b12dbea7eddab4775feaf5da0b", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -25,13 +25,13 @@ declare_lint! {\n pub struct Pass;\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // call to .map()\n         if let ExprMethodCall(name, _, ref args) = expr.node {\n             if &*name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n-                    ExprClosure(_, ref decl, ref closure_expr, _) => {\n-                        let closure_expr = remove_blocks(closure_expr);\n+                    ExprClosure(_, ref decl, closure_eid, _) => {\n+                        let closure_expr = remove_blocks(cx.tcx.map.expr(closure_eid));\n                         if_let_chain! {[\n                             // nothing special in the argument, besides reference bindings\n                             // (e.g. .map(|&x| x) )"}, {"sha": "0820a81373294aaac2811d075a457cdd81e2cedb", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -130,7 +130,7 @@ impl LintPass for MatchPass {\n }\n \n impl LateLintPass for MatchPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if in_external_macro(cx, expr.span) {\n             return;\n         }"}, {"sha": "e3299958ae685420f02ce5f6eaec902b08691614", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -28,7 +28,7 @@ impl LintPass for MemForget {\n }\n \n impl LateLintPass for MemForget {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n             if let ExprPath(ref qpath) = path_expr.node {\n                 let def_id = cx.tcx.tables().qpath_def(qpath, path_expr.id).def_id();"}, {"sha": "dd99f5a358ba76ec20da54549d7c0324a02e7ff1", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -553,7 +553,7 @@ impl LateLintPass for Pass {\n     #[allow(unused_attributes)]\n     // ^ required because `cyclomatic_complexity` attribute shows up as unused\n     #[cyclomatic_complexity = \"30\"]\n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if in_macro(cx, expr.span) {\n             return;\n         }\n@@ -629,7 +629,7 @@ impl LateLintPass for Pass {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, implitem: &hir::ImplItem) {\n+    fn check_impl_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, implitem: &'tcx hir::ImplItem) {\n         if in_external_macro(cx, implitem.span) {\n             return;\n         }"}, {"sha": "f1f353cb762c8f94312ad5512710fba16cce9774", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -34,7 +34,7 @@ impl LintPass for MinMaxPass {\n }\n \n impl LateLintPass for MinMaxPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let Some((outer_max, outer_c, oe)) = min_max(cx, expr) {\n             if let Some((inner_max, inner_c, _)) = min_max(cx, oe) {\n                 if outer_max == inner_max {"}, {"sha": "679bad666b9f96bd1cbe96cf1ad3b26ef0185e5c", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -167,7 +167,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, k: FnKind, decl: &FnDecl, _: &Expr, _: Span, _: NodeId) {\n+    fn check_fn<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, k: FnKind<'tcx>, decl: &'tcx FnDecl, _: &'tcx Expr, _: Span, _: NodeId) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n             return;\n@@ -182,7 +182,7 @@ impl LateLintPass for Pass {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext, s: &Stmt) {\n+    fn check_stmt<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, s: &'tcx Stmt) {\n         if_let_chain! {[\n             let StmtDecl(ref d, _) = s.node,\n             let DeclLocal(ref l) = d.node,\n@@ -216,7 +216,7 @@ impl LateLintPass for Pass {\n         }}\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             let op = cmp.node;\n             if op.is_comparison() {\n@@ -294,7 +294,7 @@ impl LateLintPass for Pass {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n+    fn check_pat<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if let PatKind::Binding(_, _, ref ident, Some(ref right)) = pat.node {\n             if right.node == PatKind::Wild {\n                 span_lint(cx,\n@@ -440,9 +440,7 @@ fn in_attributes_expansion(cx: &LateContext, expr: &Expr) -> bool {\n fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n     match *def {\n         def::Def::Local(id) | def::Def::Upvar(id, _, _) => {\n-            let id = cx.tcx.map.as_local_node_id(id).expect(\"That DefId should be valid\");\n-\n-            if let Some(span) = cx.tcx.map.opt_span(id) {\n+            if let Some(span) = cx.tcx.map.span_if_local(id) {\n                 !in_macro(cx, span)\n             } else {\n                 true"}, {"sha": "e40638616b6ebff899b481c0a893cbc2616d6a8e", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -95,7 +95,7 @@ impl LintPass for MissingDoc {\n }\n \n impl LateLintPass for MissingDoc {\n-    fn enter_lint_attrs(&mut self, _: &LateContext, attrs: &[ast::Attribute]) {\n+    fn enter_lint_attrs<'a, 'tcx: 'a>(&mut self, _: &LateContext<'a, 'tcx>, attrs: &'tcx [ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n@@ -105,15 +105,15 @@ impl LateLintPass for MissingDoc {\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) {\n+    fn exit_lint_attrs<'a, 'tcx: 'a>(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx [ast::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n+    fn check_crate<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, krate: &'tcx hir::Crate) {\n         self.check_missing_docs_attrs(cx, &krate.attrs, krate.span, \"crate\");\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n         let desc = match it.node {\n             hir::ItemConst(..) => \"a constant\",\n             hir::ItemEnum(..) => \"an enum\",\n@@ -134,7 +134,7 @@ impl LateLintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, &it.attrs, it.span, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n+    fn check_trait_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, trait_item: &'tcx hir::TraitItem) {\n         let desc = match trait_item.node {\n             hir::ConstTraitItem(..) => \"an associated constant\",\n             hir::MethodTraitItem(..) => \"a trait method\",\n@@ -144,7 +144,7 @@ impl LateLintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, desc);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n+    fn check_impl_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n         let def_id = cx.tcx.map.local_def_id(impl_item.id);\n         match cx.tcx.associated_item(def_id).container {\n@@ -164,13 +164,13 @@ impl LateLintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, sf: &hir::StructField) {\n+    fn check_struct_field<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, sf: &'tcx hir::StructField) {\n         if !sf.is_positional() {\n             self.check_missing_docs_attrs(cx, &sf.attrs, sf.span, \"a struct field\");\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, v: &'tcx hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx, &v.node.attrs, v.span, \"a variant\");\n     }\n }"}, {"sha": "303c53186024ad7703a03bd24775c020234cbed2", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -32,11 +32,11 @@ impl LintPass for MutMut {\n }\n \n impl LateLintPass for MutMut {\n-    fn check_block(&mut self, cx: &LateContext, block: &hir::Block) {\n+    fn check_block<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block) {\n         intravisit::walk_block(&mut MutVisitor { cx: cx }, block);\n     }\n \n-    fn check_ty(&mut self, cx: &LateContext, ty: &hir::Ty) {\n+    fn check_ty<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, ty: &'tcx hir::Ty) {\n         use rustc::hir::intravisit::Visitor;\n \n         MutVisitor { cx: cx }.visit_ty(ty);\n@@ -47,8 +47,8 @@ pub struct MutVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if in_external_macro(self.cx, expr.span) {\n             return;\n         }\n@@ -74,7 +74,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyRptr(_, hir::MutTy { ty: ref pty, mutbl: hir::MutMutable }) = ty.node {\n             if let hir::TyRptr(_, hir::MutTy { mutbl: hir::MutMutable, .. }) = pty.node {\n                 span_lint(self.cx, MUT_MUT, ty.span, \"generally you want to avoid `&mut &mut _` if possible\");\n@@ -84,4 +84,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n \n         intravisit::walk_ty(self, ty);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "08d39b7c43d602c4a4d85580ed17f26fdd37c251", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -33,7 +33,7 @@ impl LintPass for UnnecessaryMutPassed {\n }\n \n impl LateLintPass for UnnecessaryMutPassed {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         let borrowed_table = cx.tcx.tables.borrow();\n         match e.node {\n             ExprCall(ref fn_expr, ref arguments) => {"}, {"sha": "71fcda814a3b3b69158339716d0c999b520449ca", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -55,7 +55,7 @@ impl LintPass for MutexAtomic {\n pub struct MutexAtomic;\n \n impl LateLintPass for MutexAtomic {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         let ty = cx.tcx.tables().expr_ty(expr);\n         if let ty::TyAdt(_, subst) = ty.sty {\n             if match_type(cx, ty, &paths::MUTEX) {"}, {"sha": "bfa51f0ba703eb71d0c61bc95d65041835678838", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -57,7 +57,7 @@ impl LintPass for NeedlessBool {\n }\n \n impl LateLintPass for NeedlessBool {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n         if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n             let reduce = |ret, not| {\n@@ -117,7 +117,7 @@ impl LintPass for BoolComparison {\n }\n \n impl LateLintPass for BoolComparison {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n         if let ExprBinary(Spanned { node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {"}, {"sha": "0f03ff774d2b753b8402e4595888001c65d52f81", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -35,7 +35,7 @@ impl LintPass for NeedlessBorrow {\n }\n \n impl LateLintPass for NeedlessBorrow {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if in_macro(cx, e.span) {\n             return;\n         }\n@@ -53,7 +53,7 @@ impl LateLintPass for NeedlessBorrow {\n             }\n         }\n     }\n-    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n+    fn check_pat<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if in_macro(cx, pat.span) {\n             return;\n         }"}, {"sha": "82cd502081f7c7e347261845005f668ec8074fb2", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -31,7 +31,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tcx.tables().expr_ty(expr);\n             if let TyAdt(def, _) = ty.sty {"}, {"sha": "6b0c8001ed2254886d6c0533494ccd63a960bf79", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -32,7 +32,7 @@ impl LintPass for NegMultiply {\n \n #[allow(match_same_arms)]\n impl LateLintPass for NegMultiply {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(Spanned { node: BiMul, .. }, ref l, ref r) = e.node {\n             match (&l.node, &r.node) {\n                 (&ExprUnary(..), &ExprUnary(..)) => (),"}, {"sha": "836a5393a9d75cd66d3d27342e18e3453bde5e86", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -90,7 +90,15 @@ impl LintPass for NewWithoutDefault {\n }\n \n impl LateLintPass for NewWithoutDefault {\n-    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, _: &hir::Expr, span: Span, id: ast::NodeId) {\n+    fn check_fn<'a, 'tcx: 'a>(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl,\n+        _: &'tcx hir::Expr,\n+        span: Span,\n+        id: ast::NodeId,\n+    ) {\n         if in_external_macro(cx, span) {\n             return;\n         }"}, {"sha": "0a5c21114fb54707333c3b5b6334712155330030", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -103,7 +103,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n+    fn check_stmt<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if has_no_effect(cx, expr) {\n                 span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");"}, {"sha": "6ccdb6ee14593ff481c1f8ca8389a41f482681b5", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -59,9 +59,9 @@ struct ExistingName {\n     whitelist: &'static [&'static str],\n }\n \n-struct SimilarNamesLocalVisitor<'a, 'b: 'a> {\n+struct SimilarNamesLocalVisitor<'a, 'tcx: 'a> {\n     names: Vec<ExistingName>,\n-    cx: &'a EarlyContext<'b>,\n+    cx: &'a EarlyContext<'tcx>,\n     lint: &'a NonExpressiveNames,\n     single_char_names: Vec<char>,\n }\n@@ -76,10 +76,10 @@ const WHITELIST: &'static [&'static [&'static str]] = &[\n     &[\"set\", \"get\"],\n ];\n \n-struct SimilarNamesNameVisitor<'a, 'b: 'a, 'c: 'b>(&'a mut SimilarNamesLocalVisitor<'b, 'c>);\n+struct SimilarNamesNameVisitor<'a: 'b, 'tcx: 'a, 'b>(&'b mut SimilarNamesLocalVisitor<'a, 'tcx>);\n \n-impl<'a, 'b, 'c> Visitor for SimilarNamesNameVisitor<'a, 'b, 'c> {\n-    fn visit_pat(&mut self, pat: &Pat) {\n+impl<'a, 'tcx: 'a, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n+    fn visit_pat(&mut self, pat: &'tcx Pat) {\n         match pat.node {\n             PatKind::Ident(_, id, _) => self.check_name(id.span, id.node.name),\n             PatKind::Struct(_, ref fields, _) => {\n@@ -120,7 +120,7 @@ fn whitelisted(interned_name: &str, list: &[&str]) -> bool {\n     false\n }\n \n-impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n+impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n     fn check_short_name(&mut self, c: char, span: Span) {\n         // make sure we ignore shadowing\n         if self.0.single_char_names.contains(&c) {\n@@ -236,18 +236,18 @@ impl<'a, 'b> SimilarNamesLocalVisitor<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b> Visitor for SimilarNamesLocalVisitor<'a, 'b> {\n-    fn visit_local(&mut self, local: &Local) {\n+impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n+    fn visit_local(&mut self, local: &'tcx Local) {\n         if let Some(ref init) = local.init {\n             self.apply(|this| walk_expr(this, &**init));\n         }\n         // add the pattern after the expression because the bindings aren't available yet in the init expression\n         SimilarNamesNameVisitor(self).visit_pat(&*local.pat);\n     }\n-    fn visit_block(&mut self, blk: &Block) {\n+    fn visit_block(&mut self, blk: &'tcx Block) {\n         self.apply(|this| walk_block(this, blk));\n     }\n-    fn visit_arm(&mut self, arm: &Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx Arm) {\n         self.apply(|this| {\n             // just go through the first pattern, as either all patterns bind the same bindings or rustc would have errored much earlier\n             SimilarNamesNameVisitor(this).visit_pat(&arm.pats[0]);"}, {"sha": "77244acb308140557ff1bb6561b04e79a9713eb4", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -41,7 +41,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[ //begin checking variables\n             let ExprMatch(ref op, ref body, ref source) = expr.node, //test if expr is a match\n             let MatchSource::IfLetDesugar { .. } = *source, //test if it is an If Let"}, {"sha": "538d09d082ee0682c64891d6416a822e500f7f3c", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -33,7 +33,7 @@ impl LintPass for NonSensical {\n }\n \n impl LateLintPass for NonSensical {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&arguments[0]));\n             if &*name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {"}, {"sha": "583b9315fee8fd95659bd661caa18781c3e4da63", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -31,7 +31,7 @@ impl LintPass for OverflowCheckConditional {\n \n impl LateLintPass for OverflowCheckConditional {\n     // a + b < a, a > a + b, a < a - b, a - b > a\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n             let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node,"}, {"sha": "893a17a63fc72d709b1f5dba3975efb91a3dd2b3", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -33,7 +33,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let ExprBlock(ref block) = expr.node,\n             let Some(ref ex) = block.expr,"}, {"sha": "4982055ef3a2e58f924815c83794a34911022762", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -36,7 +36,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if_let_chain! {[\n             let ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) = item.node,\n             !is_automatically_derived(&*item.attrs),"}, {"sha": "be70f6a7648f535b5e3d65f879b1ef92d5b6156d", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -66,7 +66,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let ExprCall(ref fun, ref args) = expr.node,\n             let ExprPath(ref qpath) = fun.node,"}, {"sha": "a6be3fae45fc3b583f7ec1496c4010d99baa43ea", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -55,13 +55,13 @@ impl LintPass for PointerPass {\n }\n \n impl LateLintPass for PointerPass {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemFn(ref decl, _, _, _, _, _) = item.node {\n             check_fn(cx, decl, item.id);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(ref sig, _) = item.node {\n             if let Some(NodeItem(it)) = cx.tcx.map.find(cx.tcx.map.get_parent(item.id)) {\n                 if let ItemImpl(_, _, _, Some(_), _, _) = it.node {\n@@ -72,13 +72,13 @@ impl LateLintPass for PointerPass {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n             check_fn(cx, &sig.decl, item.id);\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprBinary(ref op, ref l, ref r) = expr.node {\n             if (op.node == BiEq || op.node == BiNe) && (is_null_path(l) || is_null_path(r)) {\n                 span_lint(cx,"}, {"sha": "6936fc1999344f9e9c8a7a1d39caf57730d547c8", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -47,7 +47,7 @@ impl LintPass for StepByZero {\n }\n \n impl LateLintPass for StepByZero {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) = expr.node {\n             let name = &*name.as_str();\n "}, {"sha": "d04b03fcf57e18d4d844e4bf44cfd77e33d116d9", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -83,11 +83,11 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_crate(&mut self, _: &LateContext, _: &Crate) {\n+    fn check_crate<'a, 'tcx: 'a>(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx Crate) {\n         self.spans.clear();\n     }\n \n-    fn check_block(&mut self, cx: &LateContext, block: &Block) {\n+    fn check_block<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n         if_let_chain!{[\n             self.last.is_none(),\n             let Some(ref expr) = block.expr,\n@@ -106,13 +106,13 @@ impl LateLintPass for Pass {\n         }}\n     }\n \n-    fn check_block_post(&mut self, _: &LateContext, block: &Block) {\n+    fn check_block_post<'a, 'tcx: 'a>(&mut self, _: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n         if self.last.map_or(false, |id| block.id == id) {\n             self.last = None;\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain!{[\n             let ExprCall(ref fun, ref args) = expr.node,\n             let ExprPath(ref qpath) = fun.node,"}, {"sha": "97a0e0052b5881961ccb9de04ac7dad2781918ce", "filename": "clippy_lints/src/serde.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fserde.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fserde.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -27,7 +27,7 @@ impl LintPass for Serde {\n }\n \n impl LateLintPass for Serde {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemImpl(_, _, _, Some(ref trait_ref), _, ref items) = item.node {\n             let did = trait_ref.path.def.def_id();\n             if let Some(visit_did) = get_trait_def_id(cx, &paths::SERDE_DE_VISITOR) {"}, {"sha": "9ec4ceba7e67cee1b21c408931a6c95bbeebb123", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -1,9 +1,8 @@\n use reexport::*;\n use rustc::lint::*;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, FnKind};\n+use rustc::hir::intravisit::{Visitor, FnKind, NestedVisitorMap};\n use rustc::ty;\n-use std::ops::Deref;\n use syntax::codemap::Span;\n use utils::{higher, in_external_macro, snippet, span_lint_and_then};\n \n@@ -81,15 +80,23 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, expr: &Expr, _: Span, _: NodeId) {\n+    fn check_fn<'a, 'tcx: 'a>(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        expr: &'tcx Expr,\n+        _: Span,\n+        _: NodeId,\n+    ) {\n         if in_external_macro(cx, expr.span) {\n             return;\n         }\n         check_fn(cx, decl, expr);\n     }\n }\n \n-fn check_fn(cx: &LateContext, decl: &FnDecl, expr: &Expr) {\n+fn check_fn<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, expr: &'tcx Expr) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n         if let PatKind::Binding(_, _, ident, _) = arg.pat.node {\n@@ -99,7 +106,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, expr: &Expr) {\n     check_expr(cx, expr, &mut bindings);\n }\n \n-fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>) {\n+fn check_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, bindings: &mut Vec<(Name, Span)>) {\n     let len = bindings.len();\n     for stmt in &block.stmts {\n         match stmt.node {\n@@ -114,7 +121,7 @@ fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>\n     bindings.truncate(len);\n }\n \n-fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n+fn check_decl<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, decl.span) {\n         return;\n     }\n@@ -128,9 +135,9 @@ fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n         }\n         if let Some(ref o) = *init {\n             check_expr(cx, o, bindings);\n-            check_pat(cx, pat, &Some(o), span, bindings);\n+            check_pat(cx, pat, Some(o), span, bindings);\n         } else {\n-            check_pat(cx, pat, &None, span, bindings);\n+            check_pat(cx, pat, None, span, bindings);\n         }\n     }\n }\n@@ -143,7 +150,13 @@ fn is_binding(cx: &LateContext, pat_id: NodeId) -> bool {\n     }\n }\n \n-fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bindings: &mut Vec<(Name, Span)>) {\n+fn check_pat<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    init: Option<&'tcx Expr>,\n+    span: Span,\n+    bindings: &mut Vec<(Name, Span)>,\n+) {\n     // TODO: match more stuff / destructuring\n     match pat.node {\n         PatKind::Binding(_, _, ref ident, ref inner) => {\n@@ -167,14 +180,14 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n             }\n         }\n         PatKind::Struct(_, ref pfields, _) => {\n-            if let Some(init_struct) = *init {\n+            if let Some(init_struct) = init {\n                 if let ExprStruct(_, ref efields, _) = init_struct.node {\n                     for field in pfields {\n                         let name = field.node.name;\n                         let efield = efields.iter()\n                                             .find(|f| f.name.node == name)\n                                             .map(|f| &*f.expr);\n-                        check_pat(cx, &field.node.pat, &efield, span, bindings);\n+                        check_pat(cx, &field.node.pat, efield, span, bindings);\n                     }\n                 } else {\n                     for field in pfields {\n@@ -183,15 +196,15 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n                 }\n             } else {\n                 for field in pfields {\n-                    check_pat(cx, &field.node.pat, &None, span, bindings);\n+                    check_pat(cx, &field.node.pat, None, span, bindings);\n                 }\n             }\n         }\n         PatKind::Tuple(ref inner, _) => {\n-            if let Some(init_tup) = *init {\n+            if let Some(init_tup) = init {\n                 if let ExprTup(ref tup) = init_tup.node {\n                     for (i, p) in inner.iter().enumerate() {\n-                        check_pat(cx, p, &Some(&tup[i]), p.span, bindings);\n+                        check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n                     }\n                 } else {\n                     for p in inner {\n@@ -200,14 +213,14 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n                 }\n             } else {\n                 for p in inner {\n-                    check_pat(cx, p, &None, span, bindings);\n+                    check_pat(cx, p, None, span, bindings);\n                 }\n             }\n         }\n         PatKind::Box(ref inner) => {\n-            if let Some(initp) = *init {\n+            if let Some(initp) = init {\n                 if let ExprBox(ref inner_init) = initp.node {\n-                    check_pat(cx, inner, &Some(&**inner_init), span, bindings);\n+                    check_pat(cx, inner, Some(&**inner_init), span, bindings);\n                 } else {\n                     check_pat(cx, inner, init, span, bindings);\n                 }\n@@ -221,10 +234,15 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n     }\n }\n \n-fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, pattern_span: Span, init: &Option<T>, prev_span: Span)\n-    where T: Deref<Target = Expr>\n-{\n-    if let Some(ref expr) = *init {\n+fn lint_shadow<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    name: Name,\n+    span: Span,\n+    pattern_span: Span,\n+    init: Option<&'tcx Expr>,\n+    prev_span: Span,\n+) {\n+    if let Some(expr) = init {\n         if is_self_shadow(name, expr) {\n             span_lint_and_then(cx,\n                                SHADOW_SAME,\n@@ -234,7 +252,7 @@ fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, pattern_span: Span,\n                                         snippet(cx, expr.span, \"..\")),\n                                |db| { db.span_note(prev_span, \"previous binding is here\"); },\n             );\n-        } else if contains_self(name, expr) {\n+        } else if contains_self(cx, name, expr) {\n             span_lint_and_then(cx,\n                                SHADOW_REUSE,\n                                pattern_span,\n@@ -267,7 +285,7 @@ fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, pattern_span: Span,\n     }\n }\n \n-fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n+fn check_expr<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, expr.span) {\n         return;\n     }\n@@ -302,7 +320,7 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n             let len = bindings.len();\n             for arm in arms {\n                 for pat in &arm.pats {\n-                    check_pat(cx, pat, &Some(&**init), pat.span, bindings);\n+                    check_pat(cx, pat, Some(&**init), pat.span, bindings);\n                     // This is ugly, but needed to get the right type\n                     if let Some(ref guard) = arm.guard {\n                         check_expr(cx, guard, bindings);\n@@ -316,7 +334,7 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n     }\n }\n \n-fn check_ty(cx: &LateContext, ty: &Ty, bindings: &mut Vec<(Name, Span)>) {\n+fn check_ty<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut Vec<(Name, Span)>) {\n     match ty.node {\n         TyObjectSum(ref sty, _) |\n         TySlice(ref sty) => check_ty(cx, sty, bindings),\n@@ -353,23 +371,28 @@ fn path_eq_name(name: Name, path: &Path) -> bool {\n     !path.global && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n }\n \n-struct ContainsSelf {\n+struct ContainsSelf<'a, 'tcx: 'a> {\n     name: Name,\n     result: bool,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v> Visitor<'v> for ContainsSelf {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for ContainsSelf<'a, 'tcx> {\n     fn visit_name(&mut self, _: Span, name: Name) {\n         if self.name == name {\n             self.result = true;\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-fn contains_self(name: Name, expr: &Expr) -> bool {\n+fn contains_self<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, name: Name, expr: &'tcx Expr) -> bool {\n     let mut cs = ContainsSelf {\n         name: name,\n         result: false,\n+        cx: cx,\n     };\n     cs.visit_expr(expr);\n     cs.result"}, {"sha": "985ef912dc1cf303ad5092becc657073cae2657f", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -80,7 +80,7 @@ impl LintPass for StringAdd {\n }\n \n impl LateLintPass for StringAdd {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) = e.node {\n             if is_string(cx, left) {\n                 if let Allow = cx.current_level(STRING_ADD_ASSIGN) {\n@@ -137,7 +137,7 @@ impl LintPass for StringLitAsBytes {\n }\n \n impl LateLintPass for StringLitAsBytes {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use std::ascii::AsciiExt;\n         use syntax::ast::LitKind;\n         use utils::{snippet, in_macro};"}, {"sha": "f251db2b1870c1d2c46d2900b8936dda42dfecd1", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -51,7 +51,7 @@ impl LintPass for Swap {\n }\n \n impl LateLintPass for Swap {\n-    fn check_block(&mut self, cx: &LateContext, block: &Block) {\n+    fn check_block<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n         check_manual_swap(cx, block);\n         check_suspicious_swap(cx, block);\n     }"}, {"sha": "c6246fec9b0f244dd08dd286e210ed9b1a53e238", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -38,7 +38,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprAssign(ref target, _) = expr.node {\n             match target.node {\n                 ExprField(ref base, _) |"}, {"sha": "2d09c725fb0d0a202ff752ebc713d94bef66deac", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -85,7 +85,7 @@ impl LintPass for Transmute {\n }\n \n impl LateLintPass for Transmute {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n             if let ExprPath(ref qpath) = path_expr.node {\n                 let def_id = cx.tcx.tables().qpath_def(qpath, path_expr.id).def_id();"}, {"sha": "66c14e70e6a5d00294f9a49d8961b459a27b4f01", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -1,6 +1,6 @@\n use reexport::*;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{FnKind, Visitor, walk_ty};\n+use rustc::hir::intravisit::{FnKind, Visitor, walk_ty, NestedVisitorMap};\n use rustc::lint::*;\n use rustc::ty;\n use std::cmp::Ordering;\n@@ -70,7 +70,7 @@ impl LintPass for TypePass {\n }\n \n impl LateLintPass for TypePass {\n-    fn check_ty(&mut self, cx: &LateContext, ast_ty: &Ty) {\n+    fn check_ty<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, ast_ty: &'tcx Ty) {\n         if in_macro(cx, ast_ty.span) {\n             return;\n         }\n@@ -154,7 +154,7 @@ impl LintPass for LetPass {\n }\n \n impl LateLintPass for LetPass {\n-    fn check_decl(&mut self, cx: &LateContext, decl: &Decl) {\n+    fn check_decl<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl) {\n         check_let_unit(cx, decl)\n     }\n }\n@@ -191,7 +191,7 @@ impl LintPass for UnitCmp {\n }\n \n impl LateLintPass for UnitCmp {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if in_macro(cx, expr.span) {\n             return;\n         }\n@@ -448,7 +448,7 @@ impl LintPass for CastPass {\n }\n \n impl LateLintPass for CastPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprCast(ref ex, _) = expr.node {\n             let (cast_from, cast_to) = (cx.tcx.tables().expr_ty(ex), cx.tcx.tables().expr_ty(expr));\n             if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx, expr.span) {\n@@ -536,16 +536,16 @@ impl LintPass for TypeComplexityPass {\n }\n \n impl LateLintPass for TypeComplexityPass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Expr, _: Span, _: NodeId) {\n+    fn check_fn<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, _: FnKind<'tcx>, decl: &'tcx FnDecl, _: &'tcx Expr, _: Span, _: NodeId) {\n         self.check_fndecl(cx, decl);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, field: &StructField) {\n+    fn check_struct_field<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx StructField) {\n         // enum variants are also struct fields now\n         self.check_type(cx, &field.ty);\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         match item.node {\n             ItemStatic(ref ty, _, _) |\n             ItemConst(ref ty, _) => self.check_type(cx, ty),\n@@ -554,7 +554,7 @@ impl LateLintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         match item.node {\n             ConstTraitItem(ref ty, _) |\n             TypeTraitItem(_, Some(ref ty)) => self.check_type(cx, ty),\n@@ -564,7 +564,7 @@ impl LateLintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         match item.node {\n             ImplItemKind::Const(ref ty, _) |\n             ImplItemKind::Type(ref ty) => self.check_type(cx, ty),\n@@ -573,15 +573,15 @@ impl LateLintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext, local: &Local) {\n+    fn check_local<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local) {\n         if let Some(ref ty) = local.ty {\n             self.check_type(cx, ty);\n         }\n     }\n }\n \n impl TypeComplexityPass {\n-    fn check_fndecl(&self, cx: &LateContext, decl: &FnDecl) {\n+    fn check_fndecl<'a, 'tcx: 'a>(&self, cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl) {\n         for arg in &decl.inputs {\n             self.check_type(cx, &arg.ty);\n         }\n@@ -590,14 +590,15 @@ impl TypeComplexityPass {\n         }\n     }\n \n-    fn check_type(&self, cx: &LateContext, ty: &Ty) {\n+    fn check_type<'a, 'tcx: 'a>(&self, cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty) {\n         if in_macro(cx, ty.span) {\n             return;\n         }\n         let score = {\n             let mut visitor = TypeComplexityVisitor {\n                 score: 0,\n                 nest: 1,\n+                cx: cx,\n             };\n             visitor.visit_ty(ty);\n             visitor.score\n@@ -613,15 +614,16 @@ impl TypeComplexityPass {\n }\n \n /// Walks a type and assigns a complexity score to it.\n-struct TypeComplexityVisitor {\n+struct TypeComplexityVisitor<'a, 'tcx: 'a> {\n     /// total complexity score of the type\n     score: u64,\n     /// current nesting level\n     nest: u64,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v> Visitor<'v> for TypeComplexityVisitor {\n-    fn visit_ty(&mut self, ty: &'v Ty) {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for TypeComplexityVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &'tcx Ty) {\n         let (add_score, sub_nest) = match ty.node {\n             // _, &x and *x have only small overhead; don't mess with nesting level\n             TyInfer | TyPtr(..) | TyRptr(..) => (1, 0),\n@@ -646,6 +648,9 @@ impl<'v> Visitor<'v> for TypeComplexityVisitor {\n         walk_ty(self, ty);\n         self.nest -= sub_nest;\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// **What it does:** Checks for expressions where a character literal is cast\n@@ -678,7 +683,7 @@ impl LintPass for CharLitAsU8 {\n }\n \n impl LateLintPass for CharLitAsU8 {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         use syntax::ast::{LitKind, UintTy};\n \n         if let ExprCast(ref e, _) = expr.node {\n@@ -842,7 +847,7 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n }\n \n impl LateLintPass for AbsurdExtremeComparisons {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         use types::ExtremeType::*;\n         use types::AbsurdComparisonResult::*;\n \n@@ -1067,7 +1072,7 @@ fn upcast_comparison_bounds_err(cx: &LateContext, span: &Span, rel: comparisons:\n }\n \n impl LateLintPass for InvalidUpcastComparisons {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n \n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);"}, {"sha": "ba82bc470dcab04b05790b431c1ebf262e343642", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -69,7 +69,7 @@ impl LintPass for Unicode {\n }\n \n impl LateLintPass for Unicode {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprLit(ref lit) = expr.node {\n             if let LitKind::Str(_, _) = lit.node {\n                 check_str(cx, lit.span)"}, {"sha": "8119c4d727abb6ca1041ca5cf3fc2813147fbe5a", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir;\n-use rustc::hir::intravisit::{FnKind, Visitor, walk_expr, walk_fn};\n+use rustc::hir::intravisit::{FnKind, Visitor, walk_expr, walk_fn, NestedVisitorMap};\n use std::collections::HashMap;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -29,15 +29,9 @@ declare_lint! {\n \n pub struct UnusedLabel;\n \n-#[derive(Default)]\n-struct UnusedLabelVisitor {\n+struct UnusedLabelVisitor<'a, 'tcx: 'a> {\n     labels: HashMap<InternedString, Span>,\n-}\n-\n-impl UnusedLabelVisitor {\n-    pub fn new() -> UnusedLabelVisitor {\n-        ::std::default::Default::default()\n-    }\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n impl LintPass for UnusedLabel {\n@@ -47,22 +41,33 @@ impl LintPass for UnusedLabel {\n }\n \n impl LateLintPass for UnusedLabel {\n-    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, body: &hir::Expr, span: Span, fn_id: ast::NodeId) {\n+    fn check_fn<'a, 'tcx: 'a>(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl,\n+        body: &'tcx hir::Expr,\n+        span: Span,\n+        fn_id: ast::NodeId,\n+    ) {\n         if in_macro(cx, span) {\n             return;\n         }\n \n-        let mut v = UnusedLabelVisitor::new();\n-        walk_fn(&mut v, kind, decl, body, span, fn_id);\n+        let mut v = UnusedLabelVisitor {\n+            cx: cx,\n+            labels: HashMap::new(),\n+        };\n+        walk_fn(&mut v, kind, decl, body.expr_id(), span, fn_id);\n \n         for (label, span) in v.labels {\n             span_lint(cx, UNUSED_LABEL, span, &format!(\"unused label `{}`\", label));\n         }\n     }\n }\n \n-impl<'v> Visitor<'v> for UnusedLabelVisitor {\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprBreak(Some(label), _) |\n             hir::ExprAgain(Some(label)) => {\n@@ -77,4 +82,7 @@ impl<'v> Visitor<'v> for UnusedLabelVisitor {\n \n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "e01feb3fcae22dedc0b99f1b03ef532f04b54489", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -376,11 +376,11 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(e);\n                 // TODO: _ty\n             }\n-            ExprClosure(cap, _, ref e, _) => {\n+            ExprClosure(cap, _, eid, _) => {\n                 let c: fn(_, _, _, _) -> _ = ExprClosure;\n                 c.hash(&mut self.s);\n                 cap.hash(&mut self.s);\n-                self.hash_expr(e);\n+                self.hash_expr(self.cx.tcx.map.expr(eid));\n             }\n             ExprField(ref e, ref f) => {\n                 let c: fn(_, _) -> _ = ExprField;"}, {"sha": "ef98247b7e83b72a477f0f03f1153fdd1b0463f4", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -37,14 +37,14 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n         if !has_attr(&item.attrs) {\n             return;\n         }\n         print_item(cx, item);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &hir::ImplItem) {\n+    fn check_impl_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem) {\n         if !has_attr(&item.attrs) {\n             return;\n         }\n@@ -68,33 +68,33 @@ impl LateLintPass for Pass {\n         }\n     }\n /*\n-    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n+    fn check_trait_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n         if !has_attr(&item.attrs) {\n             return;\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext, var: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, var: &'tcx hir::Variant, _: &hir::Generics) {\n         if !has_attr(&var.node.attrs) {\n             return;\n         }\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, field: &hir::StructField) {\n+    fn check_struct_field<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField) {\n         if !has_attr(&field.attrs) {\n             return;\n         }\n     }\n */\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if !has_attr(&expr.attrs) {\n             return;\n         }\n         print_expr(cx, expr, 0);\n     }\n \n-    fn check_arm(&mut self, cx: &LateContext, arm: &hir::Arm) {\n+    fn check_arm<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm) {\n         if !has_attr(&arm.attrs) {\n             return;\n         }\n@@ -109,7 +109,7 @@ impl LateLintPass for Pass {\n         print_expr(cx, &arm.body, 1);\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &hir::Stmt) {\n+    fn check_stmt<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n         if !has_attr(stmt.node.attrs()) {\n             return;\n         }\n@@ -120,7 +120,7 @@ impl LateLintPass for Pass {\n     }\n /*\n \n-    fn check_foreign_item(&mut self, cx: &LateContext, item: &hir::ForeignItem) {\n+    fn check_foreign_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ForeignItem) {\n         if !has_attr(&item.attrs) {\n             return;\n         }"}, {"sha": "c2e55862b3db594c84178b157199ccc2c1d91aad", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use utils::{paths, match_path, span_lint};\n use syntax::symbol::InternedString;\n use syntax::ast::{Name, NodeId, ItemKind, Crate as AstCrate};\n@@ -105,18 +105,18 @@ impl LintPass for LintWithoutLintPass {\n \n \n impl LateLintPass for LintWithoutLintPass {\n-    fn check_item(&mut self, _: &LateContext, item: &Item) {\n+    fn check_item<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemStatic(ref ty, MutImmutable, ref expr) = item.node {\n             if is_lint_ref_type(ty) {\n                 self.declared_lints.insert(item.name, item.span);\n             } else if is_lint_array_type(ty) && item.vis == Visibility::Inherited && item.name == \"ARRAY\" {\n-                let mut collector = LintCollector { output: &mut self.registered_lints };\n+                let mut collector = LintCollector { output: &mut self.registered_lints, cx: cx };\n                 collector.visit_expr(expr);\n             }\n         }\n     }\n \n-    fn check_crate_post(&mut self, cx: &LateContext, _: &Crate) {\n+    fn check_crate_post<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, _: &'tcx Crate) {\n         for (lint_name, &lint_span) in &self.declared_lints {\n             // When using the `declare_lint!` macro, the original `lint_span`'s\n             // file points to \"<rustc macros>\".\n@@ -156,18 +156,22 @@ fn is_lint_array_type(ty: &Ty) -> bool {\n     }\n }\n \n-struct LintCollector<'a> {\n+struct LintCollector<'a, 'tcx: 'a> {\n     output: &'a mut HashSet<Name>,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v, 'a: 'v> Visitor<'v> for LintCollector<'a> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         walk_expr(self, expr);\n     }\n \n-    fn visit_path(&mut self, path: &'v Path, _: NodeId) {\n+    fn visit_path(&mut self, path: &'tcx Path, _: NodeId) {\n         if path.segments.len() == 1 {\n             self.output.insert(path.segments[0].name);\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "dc64e56b2e683c984be93f8bae4e8f16ad84ffa9", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -94,7 +94,7 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.expn_id != lhs.expn_id\n }\n /// Returns true if this `expn_info` was expanded by any macro.\n-pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n+pub fn in_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n     cx.sess().codemap().with_expn_info(span.expn_id, |info| match info {\n         Some(info) => {\n             match info.callee.format {\n@@ -109,10 +109,10 @@ pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n \n /// Returns true if the macro that expanded the crate was outside of the current crate or was a\n /// compiler plugin.\n-pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n+pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n     /// Invokes `in_macro` with the expansion info of the given span slightly heavy, try to use\n     /// this after other checks have already happened.\n-    fn in_macro_ext<T: LintContext>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n+    fn in_macro_ext<'a, T: LintContext<'a>>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n         // no ExpnInfo = no macro\n         opt_info.map_or(false, |info| {\n             if let ExpnFormat::MacroAttribute(..) = info.callee.format {\n@@ -371,12 +371,12 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n /// ```\n /// snippet(cx, expr.span, \"..\")\n /// ```\n-pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+pub fn snippet<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or_else(|_| Cow::Borrowed(default))\n }\n \n /// Convert a span to a code snippet. Returns `None` if not available.\n-pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n+pub fn snippet_opt<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     cx.sess().codemap().span_to_snippet(span).ok()\n }\n \n@@ -388,14 +388,14 @@ pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n /// ```\n /// snippet(cx, expr.span, \"..\")\n /// ```\n-pub fn snippet_block<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+pub fn snippet_block<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     let snip = snippet(cx, span, default);\n     trim_multiline(snip, true)\n }\n \n /// Like `snippet_block`, but add braces if the expr is not an `ExprBlock`.\n /// Also takes an `Option<String>` which can be put inside the braces.\n-pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, option: Option<String>, default: &'a str) -> Cow<'a, str> {\n+pub fn expr_block<'a, 'b, T: LintContext<'b>>(cx: &T, expr: &Expr, option: Option<String>, default: &'a str) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     let string = option.unwrap_or_default();\n     if let ExprBlock(_) = expr.node {\n@@ -464,15 +464,15 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n     })\n }\n \n-pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c Block> {\n+pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n     let map = &cx.tcx.map;\n     let enclosing_node = map.get_enclosing_scope(node)\n                             .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n             Node::NodeBlock(block) => Some(block),\n-            Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, ref expr), .. }) => {\n-                match expr.node {\n+            Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, eid), .. }) => {\n+                match cx.tcx.map.expr(eid).node {\n                     ExprBlock(ref block) => Some(block),\n                     _ => None,\n                 }\n@@ -501,24 +501,29 @@ impl<'a> DiagnosticWrapper<'a> {\n     }\n }\n \n-pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n+pub fn span_lint<'a, T: LintContext<'a>>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {\n         db.wiki_link(lint);\n     }\n }\n \n-// FIXME: needless lifetime doesn't trigger here\n-pub fn span_help_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span, msg: &str, help: &str) {\n+pub fn span_help_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(cx: &'a T, lint: &'static Lint, span: Span, msg: &str, help: &str) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n     if cx.current_level(lint) != Level::Allow {\n         db.0.help(help);\n         db.wiki_link(lint);\n     }\n }\n \n-pub fn span_note_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span, msg: &str, note_span: Span,\n-                                              note: &str) {\n+pub fn span_note_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n+    cx: &'a T,\n+    lint: &'static Lint,\n+    span: Span,\n+    msg: &str,\n+    note_span: Span,\n+    note: &str,\n+) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n     if cx.current_level(lint) != Level::Allow {\n         if note_span == span {\n@@ -530,8 +535,8 @@ pub fn span_note_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, sp\n     }\n }\n \n-pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n-    where F: FnOnce(&mut DiagnosticBuilder<'a>)\n+pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n+    where F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>)\n {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {"}, {"sha": "347834a062a7ae45e77d5541510e125bc414b794", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -384,7 +384,7 @@ fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n }\n \n /// Return the indentation before `span` if there are nothing but `[ \\t]` before it on its line.\n-fn indentation<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n+fn indentation<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     let lo = cx.sess().codemap().lookup_char_pos(span.lo);\n     if let Some(line) = lo.file.get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */) {\n         if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n@@ -403,7 +403,7 @@ fn indentation<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n }\n \n /// Convenience extension trait for `DiagnosticBuilder`.\n-pub trait DiagnosticBuilderExt<T: LintContext> {\n+pub trait DiagnosticBuilderExt<'a, T: LintContext<'a>> {\n     /// Suggests to add an attribute to an item.\n     ///\n     /// Correctly handles indentation of the attribute and item.\n@@ -430,7 +430,7 @@ pub trait DiagnosticBuilderExt<T: LintContext> {\n     fn suggest_prepend_item(&mut self, cx: &T, item: Span, msg: &str, new_item: &str);\n }\n \n-impl<'a, 'b, T: LintContext> DiagnosticBuilderExt<T> for rustc_errors::DiagnosticBuilder<'b> {\n+impl<'a, 'b, 'c, T: LintContext<'c>> DiagnosticBuilderExt<'c, T> for rustc_errors::DiagnosticBuilder<'b> {\n     fn suggest_item_with_attr<D: Display+?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D) {\n         if let Some(indent) = indentation(cx, item) {\n             let span = Span {"}, {"sha": "bed98559e6f0d627e111965703aa143068bd28c2", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -33,7 +33,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_let_chain!{[\n             let ty::TypeVariants::TyRef(_, ref ty) = cx.tcx.tables().expr_ty_adjusted(expr).sty,"}, {"sha": "b0cc96f3d64bdf7ebf61e560fd2412193370c521", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e2967b9c6bd43dde81f8c3574ca604040cc4f1/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=c6e2967b9c6bd43dde81f8c3574ca604040cc4f1", "patch": "@@ -28,7 +28,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr<'a, 'tcx: 'a>(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // check for instances of 0.0/0.0\n         if_let_chain! {[\n             let ExprBinary(ref op, ref left, ref right) = expr.node,"}]}