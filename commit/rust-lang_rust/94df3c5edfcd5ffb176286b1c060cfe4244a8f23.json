{"sha": "94df3c5edfcd5ffb176286b1c060cfe4244a8f23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZGYzYzVlZGZjZDVmZmIxNzYyODZiMWMwNjBjZmU0MjQ0YThmMjM=", "commit": {"author": {"name": "Christopher Vittal", "email": "christopher.vittal@gmail.com", "date": "2017-11-10T17:38:05Z"}, "committer": {"name": "Christopher Vittal", "email": "christopher.vittal@gmail.com", "date": "2017-11-15T20:46:01Z"}, "message": "Alter type collection to collect impl Trait bounds\n\nIn ast_generics extraction in generics_of and explicit_predicates_of,\nalso collect inputs if there are any.\n\nThen use a Visitor to extract the necessary information from the\nTyImplTraitUniversal types before extending generics and predicates with\nthe new information.", "tree": {"sha": "4d54d7f8c756a2afb890046b14e7859ae973de73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d54d7f8c756a2afb890046b14e7859ae973de73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94df3c5edfcd5ffb176286b1c060cfe4244a8f23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94df3c5edfcd5ffb176286b1c060cfe4244a8f23", "html_url": "https://github.com/rust-lang/rust/commit/94df3c5edfcd5ffb176286b1c060cfe4244a8f23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94df3c5edfcd5ffb176286b1c060cfe4244a8f23/comments", "author": {"login": "chrisvittal", "id": 15916123, "node_id": "MDQ6VXNlcjE1OTE2MTIz", "avatar_url": "https://avatars.githubusercontent.com/u/15916123?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chrisvittal", "html_url": "https://github.com/chrisvittal", "followers_url": "https://api.github.com/users/chrisvittal/followers", "following_url": "https://api.github.com/users/chrisvittal/following{/other_user}", "gists_url": "https://api.github.com/users/chrisvittal/gists{/gist_id}", "starred_url": "https://api.github.com/users/chrisvittal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chrisvittal/subscriptions", "organizations_url": "https://api.github.com/users/chrisvittal/orgs", "repos_url": "https://api.github.com/users/chrisvittal/repos", "events_url": "https://api.github.com/users/chrisvittal/events{/privacy}", "received_events_url": "https://api.github.com/users/chrisvittal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chrisvittal", "id": 15916123, "node_id": "MDQ6VXNlcjE1OTE2MTIz", "avatar_url": "https://avatars.githubusercontent.com/u/15916123?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chrisvittal", "html_url": "https://github.com/chrisvittal", "followers_url": "https://api.github.com/users/chrisvittal/followers", "following_url": "https://api.github.com/users/chrisvittal/following{/other_user}", "gists_url": "https://api.github.com/users/chrisvittal/gists{/gist_id}", "starred_url": "https://api.github.com/users/chrisvittal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chrisvittal/subscriptions", "organizations_url": "https://api.github.com/users/chrisvittal/orgs", "repos_url": "https://api.github.com/users/chrisvittal/repos", "events_url": "https://api.github.com/users/chrisvittal/events{/privacy}", "received_events_url": "https://api.github.com/users/chrisvittal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4c7e2c99a81179fe7d15e36c7f20724cf64ae7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c7e2c99a81179fe7d15e36c7f20724cf64ae7c", "html_url": "https://github.com/rust-lang/rust/commit/e4c7e2c99a81179fe7d15e36c7f20724cf64ae7c"}], "stats": {"total": 145, "additions": 121, "deletions": 24}, "files": [{"sha": "909855c1669f11f829eb98e31524c06727bf3782", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 121, "deletions": 24, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/94df3c5edfcd5ffb176286b1c060cfe4244a8f23/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94df3c5edfcd5ffb176286b1c060cfe4244a8f23/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=94df3c5edfcd5ffb176286b1c060cfe4244a8f23", "patch": "@@ -43,6 +43,7 @@ use rustc_const_math::ConstInt;\n use std::collections::BTreeMap;\n \n use syntax::{abi, ast};\n+use syntax::ptr::P;\n use syntax::codemap::Spanned;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -873,22 +874,32 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut allow_defaults = false;\n \n     let no_generics = hir::Generics::empty();\n-    let ast_generics = match node {\n-        NodeTraitItem(item) => &item.generics,\n+    let (ast_generics, opt_inputs) = match node {\n+        NodeTraitItem(item) => {\n+            match item.node {\n+                TraitItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n+                _ => (&item.generics, None)\n+            }\n+        }\n \n-        NodeImplItem(item) => &item.generics,\n+        NodeImplItem(item) => {\n+            match item.node {\n+                ImplItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n+                _ => (&item.generics, None)\n+            }\n+        }\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemFn(.., ref generics, _) |\n-                ItemImpl(_, _, _, ref generics, ..) => generics,\n+                ItemFn(ref decl, .., ref generics, _) => (generics, Some(&decl.inputs)),\n+                ItemImpl(_, _, _, ref generics, ..) => (generics, None),\n \n                 ItemTy(_, ref generics) |\n                 ItemEnum(_, ref generics) |\n                 ItemStruct(_, ref generics) |\n                 ItemUnion(_, ref generics) => {\n                     allow_defaults = true;\n-                    generics\n+                    (generics, None)\n                 }\n \n                 ItemTrait(_, _, ref generics, ..) => {\n@@ -909,22 +920,22 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     });\n \n                     allow_defaults = true;\n-                    generics\n+                    (generics, None)\n                 }\n \n-                _ => &no_generics\n+                _ => (&no_generics, None)\n             }\n         }\n \n         NodeForeignItem(item) => {\n             match item.node {\n-                ForeignItemStatic(..) => &no_generics,\n-                ForeignItemFn(_, _, ref generics) => generics,\n-                ForeignItemType => &no_generics,\n+                ForeignItemStatic(..) => (&no_generics, None),\n+                ForeignItemFn(ref decl, _, ref generics) => (generics, Some(&decl.inputs)),\n+                ForeignItemType => (&no_generics, None)\n             }\n         }\n \n-        _ => &no_generics\n+        _ => (&no_generics, None)\n     };\n \n     let has_self = opt_self.is_some();\n@@ -981,7 +992,24 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             synthetic: p.synthetic,\n         }\n     });\n-    let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n+\n+    let fn_ins = opt_inputs.map(|tys| &tys[..]);\n+    let univ_impl_trait_info = extract_universal_impl_trait_info(tcx, fn_ins);\n+    let other_type_start = type_start + ast_generics.ty_params.len() as u32;\n+    let mut types: Vec<_> = opt_self.into_iter()\n+        .chain(types)\n+        .chain(univ_impl_trait_info.iter().enumerate().map(|(i, info)| {\n+            ty::TypeParameterDef {\n+                index: other_type_start + i as u32,\n+                name: keywords::Invalid.name() /* FIXME(chrisvittal) maybe make not Invalid */,\n+                def_id: info.def_id,\n+                has_default: false,\n+                object_lifetime_default: rl::Set1::Empty,\n+                pure_wrt_drop: false,\n+                synthetic: Some(SyntheticTyParamKind::ImplTrait),\n+            }\n+        }))\n+        .collect();\n \n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n@@ -1337,39 +1365,50 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let icx = ItemCtxt::new(tcx, def_id);\n     let no_generics = hir::Generics::empty();\n-    let ast_generics = match node {\n-        NodeTraitItem(item) => &item.generics,\n+    let (ast_generics, opt_inputs) = match node {\n+        NodeTraitItem(item) => {\n+            match item.node {\n+                TraitItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n+                _ => (&item.generics, None)\n+            }\n+        }\n \n-        NodeImplItem(item) => &item.generics,\n+        NodeImplItem(item) => {\n+            match item.node {\n+                ImplItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n+                _ => (&item.generics, None)\n+            }\n+        }\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemFn(.., ref generics, _) |\n+                ItemFn(ref decl, .., ref generics, _) => (generics, Some(&decl.inputs)),\n+\n                 ItemImpl(_, _, _, ref generics, ..) |\n                 ItemTy(_, ref generics) |\n                 ItemEnum(_, ref generics) |\n                 ItemStruct(_, ref generics) |\n                 ItemUnion(_, ref generics) => {\n-                    generics\n+                    (generics, None)\n                 }\n \n                 ItemTrait(_, _, ref generics, .., ref items) => {\n                     is_trait = Some((ty::TraitRef {\n                         def_id,\n                         substs: Substs::identity_for_item(tcx, def_id)\n                     }, items));\n-                    generics\n+                    (generics, None)\n                 }\n \n-                _ => &no_generics\n+                _ => (&no_generics, None)\n             }\n         }\n \n         NodeForeignItem(item) => {\n             match item.node {\n-                ForeignItemStatic(..) => &no_generics,\n-                ForeignItemFn(_, _, ref generics) => generics,\n-                ForeignItemType => &no_generics,\n+                ForeignItemStatic(..) => (&no_generics, None),\n+                ForeignItemFn(ref decl, _, ref generics) => (generics, Some(&decl.inputs)),\n+                ForeignItemType => (&no_generics, None),\n             }\n         }\n \n@@ -1387,7 +1426,7 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             };\n         }\n \n-        _ => &no_generics\n+        _ => (&no_generics, None)\n     };\n \n     let generics = tcx.generics_of(def_id);\n@@ -1518,6 +1557,19 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }))\n     }\n \n+    // Add predicates from impl Trait arguments\n+    let fn_ins = opt_inputs.map(|tys| &tys[..]);\n+    let univ_impl_trait_info = extract_universal_impl_trait_info(tcx, fn_ins);\n+    for info in univ_impl_trait_info.iter() {\n+        let name = keywords::Invalid.name();\n+        let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n+        index += 1;\n+        let bounds = compute_bounds(&icx, param_ty, info.bounds,\n+                                    SizedByDefault::Yes,\n+                                    info.span);\n+        predicates.extend(bounds.predicates(tcx, param_ty));\n+    }\n+\n     // Subtle: before we store the predicates into the tcx, we\n     // sort them so that predicates like `T: Foo<Item=U>` come\n     // before uses of `U`.  This avoids false ambiguity errors\n@@ -1678,3 +1730,48 @@ fn is_auto_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _ => bug!(\"is_auto_impl applied to non-local def-id {:?}\", def_id)\n     }\n }\n+\n+struct ImplTraitUniversalInfo<'hir> {\n+    def_id: DefId,\n+    span: Span,\n+    bounds: &'hir [hir::TyParamBound],\n+}\n+\n+/// Take some possible list of arguments and return the DefIds of the ImplTraitUniversal\n+/// arguments\n+fn extract_universal_impl_trait_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               opt_inputs: Option<&'tcx [P<hir::Ty>]>)\n+                                               -> Vec<ImplTraitUniversalInfo<'tcx>>\n+{\n+    // A visitor for simply collecting Universally quantified impl Trait arguments\n+    struct ImplTraitUniversalVisitor<'tcx> {\n+        items: Vec<&'tcx hir::Ty>\n+    }\n+\n+    impl<'tcx> Visitor<'tcx> for ImplTraitUniversalVisitor<'tcx> {\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+            if let hir::TyImplTraitUniversal(..) = ty.node {\n+                self.items.push(ty);\n+            }\n+            intravisit::walk_ty(self, ty);\n+        }\n+    }\n+\n+    let mut visitor = ImplTraitUniversalVisitor { items: Vec::new() };\n+    opt_inputs.map(|inputs| for t in inputs.iter() {\n+        visitor.visit_ty(t);\n+    });\n+    visitor.items.into_iter().map(|ty| if let hir::TyImplTraitUniversal(_, ref bounds) = ty.node {\n+        ImplTraitUniversalInfo {\n+            def_id: tcx.hir.local_def_id(ty.id),\n+            span: ty.span,\n+            bounds: bounds\n+        }\n+    } else {\n+        span_bug!(ty.span, \"this type should be a universally quantified impl trait. this is a bug\")\n+    }).collect()\n+}"}]}