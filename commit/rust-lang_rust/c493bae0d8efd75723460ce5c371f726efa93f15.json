{"sha": "c493bae0d8efd75723460ce5c371f726efa93f15", "node_id": "C_kwDOAAsO6NoAKGM0OTNiYWUwZDhlZmQ3NTcyMzQ2MGNlNWMzNzFmNzI2ZWZhOTNmMTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-01T09:01:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-01T09:01:12Z"}, "message": "Auto merge of #103832 - Dylan-DPC:rollup-maw3kmx, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #103061 (Rewrite implementation of `#[alloc_error_handler]`)\n - #103584 (Remove bounds check when array is indexed by enum)\n - #103706 (Fix E0433 No Typo Suggestions)\n - #103729 (interpret: fix align_of_val on packed types)\n - #103759 (Use `adt_def` during type collection.)\n - #103809 (Fix a typo in std::net mod doc comment)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "2ea0e17fd499adaa1c6d2e150edfeb0bf35baad8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ea0e17fd499adaa1c6d2e150edfeb0bf35baad8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c493bae0d8efd75723460ce5c371f726efa93f15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c493bae0d8efd75723460ce5c371f726efa93f15", "html_url": "https://github.com/rust-lang/rust/commit/c493bae0d8efd75723460ce5c371f726efa93f15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c493bae0d8efd75723460ce5c371f726efa93f15/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc05f60c1ff4e2cb2e6eb80c9b3afa612ce28c7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc05f60c1ff4e2cb2e6eb80c9b3afa612ce28c7f", "html_url": "https://github.com/rust-lang/rust/commit/dc05f60c1ff4e2cb2e6eb80c9b3afa612ce28c7f"}, {"sha": "5d30bfc43124e9c907851a5f36ab4afd48b3578d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d30bfc43124e9c907851a5f36ab4afd48b3578d", "html_url": "https://github.com/rust-lang/rust/commit/5d30bfc43124e9c907851a5f36ab4afd48b3578d"}], "stats": {"total": 1240, "additions": 853, "deletions": 387}, "files": [{"sha": "eaf1b1167cf21863153e14be1900acf6220f9e68", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -0,0 +1,104 @@\n+use crate::util::check_builtin_macro_attribute;\n+\n+use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, FnHeader, FnSig, Generics, StmtKind};\n+use rustc_ast::{Fn, ItemKind, Stmt, TyKind, Unsafe};\n+use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::Span;\n+use thin_vec::thin_vec;\n+\n+pub fn expand(\n+    ecx: &mut ExtCtxt<'_>,\n+    _span: Span,\n+    meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::alloc_error_handler);\n+\n+    let orig_item = item.clone();\n+    let not_function = || {\n+        ecx.sess\n+            .parse_sess\n+            .span_diagnostic\n+            .span_err(item.span(), \"alloc_error_handler must be a function\");\n+        vec![orig_item.clone()]\n+    };\n+\n+    // Allow using `#[alloc_error_handler]` on an item statement\n+    // FIXME - if we get deref patterns, use them to reduce duplication here\n+    let (item, is_stmt, sig_span) = match &item {\n+        Annotatable::Item(item) => match item.kind {\n+            ItemKind::Fn(ref fn_kind) => (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span)),\n+            _ => return not_function(),\n+        },\n+        Annotatable::Stmt(stmt) => match &stmt.kind {\n+            StmtKind::Item(item_) => match item_.kind {\n+                ItemKind::Fn(ref fn_kind) => {\n+                    (item_, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+                }\n+                _ => return not_function(),\n+            },\n+            _ => return not_function(),\n+        },\n+        _ => return not_function(),\n+    };\n+\n+    // Generate a bunch of new items using the AllocFnFactory\n+    let span = ecx.with_def_site_ctxt(item.span);\n+\n+    // Generate item statements for the allocator methods.\n+    let stmts = vec![generate_handler(ecx, item.ident, span, sig_span)];\n+\n+    // Generate anonymous constant serving as container for the allocator methods.\n+    let const_ty = ecx.ty(sig_span, TyKind::Tup(Vec::new()));\n+    let const_body = ecx.expr_block(ecx.block(span, stmts));\n+    let const_item = ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n+    let const_item = if is_stmt {\n+        Annotatable::Stmt(P(ecx.stmt_item(span, const_item)))\n+    } else {\n+        Annotatable::Item(const_item)\n+    };\n+\n+    // Return the original item and the new methods.\n+    vec![orig_item, const_item]\n+}\n+\n+// #[rustc_std_internal_symbol]\n+// unsafe fn __rg_oom(size: usize, align: usize) -> ! {\n+//     handler(core::alloc::Layout::from_size_align_unchecked(size, align))\n+// }\n+fn generate_handler(cx: &ExtCtxt<'_>, handler: Ident, span: Span, sig_span: Span) -> Stmt {\n+    let usize = cx.path_ident(span, Ident::new(sym::usize, span));\n+    let ty_usize = cx.ty_path(usize);\n+    let size = Ident::from_str_and_span(\"size\", span);\n+    let align = Ident::from_str_and_span(\"align\", span);\n+\n+    let layout_new = cx.std_path(&[sym::alloc, sym::Layout, sym::from_size_align_unchecked]);\n+    let layout_new = cx.expr_path(cx.path(span, layout_new));\n+    let layout =\n+        cx.expr_call(span, layout_new, vec![cx.expr_ident(span, size), cx.expr_ident(span, align)]);\n+\n+    let call = cx.expr_call_ident(sig_span, handler, vec![layout]);\n+\n+    let never = ast::FnRetTy::Ty(cx.ty(span, TyKind::Never));\n+    let params = vec![cx.param(span, size, ty_usize.clone()), cx.param(span, align, ty_usize)];\n+    let decl = cx.fn_decl(params, never);\n+    let header = FnHeader { unsafety: Unsafe::Yes(span), ..FnHeader::default() };\n+    let sig = FnSig { decl, header, span: span };\n+\n+    let body = Some(cx.block_expr(call));\n+    let kind = ItemKind::Fn(Box::new(Fn {\n+        defaultness: ast::Defaultness::Final,\n+        sig,\n+        generics: Generics::default(),\n+        body,\n+    }));\n+\n+    let special = sym::rustc_std_internal_symbol;\n+    let special = cx.meta_word(span, special);\n+    let attrs = thin_vec![cx.attribute(special)];\n+\n+    let item = cx.item(span, Ident::from_str_and_span(\"__rg_oom\", span), attrs, kind);\n+    cx.stmt_item(sig_span, item)\n+}"}, {"sha": "bde0102186a478165cdadbc0ab5f5904ec2543b9", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -25,6 +25,7 @@ use rustc_expand::base::{MacroExpanderFn, ResolverExpand, SyntaxExtensionKind};\n use rustc_expand::proc_macro::BangProcMacro;\n use rustc_span::symbol::sym;\n \n+mod alloc_error_handler;\n mod assert;\n mod cfg;\n mod cfg_accessible;\n@@ -94,6 +95,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     }\n \n     register_attr! {\n+        alloc_error_handler: alloc_error_handler::expand,\n         bench: test::expand_bench,\n         cfg_accessible: cfg_accessible::Expander,\n         cfg_eval: cfg_eval::expand,"}, {"sha": "12bb00d346db42c42c88adfad2d5939df371c1f6", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -5,6 +5,7 @@ use crate::prelude::*;\n \n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_session::config::OomStrategy;\n+use rustc_span::symbol::sym;\n \n /// Returns whether an allocator shim was created\n pub(crate) fn codegen(\n@@ -23,7 +24,7 @@ pub(crate) fn codegen(\n             module,\n             unwind_context,\n             kind,\n-            tcx.lang_items().oom().is_some(),\n+            tcx.alloc_error_handler_kind(()).unwrap(),\n             tcx.sess.opts.unstable_opts.oom,\n         );\n         true\n@@ -36,7 +37,7 @@ fn codegen_inner(\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext,\n     kind: AllocatorKind,\n-    has_alloc_error_handler: bool,\n+    alloc_error_handler_kind: AllocatorKind,\n     oom_strategy: OomStrategy,\n ) {\n     let usize_ty = module.target_config().pointer_type();\n@@ -108,12 +109,12 @@ fn codegen_inner(\n         returns: vec![],\n     };\n \n-    let callee_name = if has_alloc_error_handler { \"__rg_oom\" } else { \"__rdl_oom\" };\n+    let callee_name = alloc_error_handler_kind.fn_name(sym::oom);\n \n     let func_id =\n         module.declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig).unwrap();\n \n-    let callee_func_id = module.declare_function(callee_name, Linkage::Import, &sig).unwrap();\n+    let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n     let mut ctx = Context::new();\n     ctx.func.signature = sig;"}, {"sha": "e2c9ffe9c1c301dedb200c88e8d8dfb2cd649ef7", "filename": "compiler/rustc_codegen_gcc/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -7,7 +7,7 @@ use rustc_span::symbol::sym;\n \n use crate::GccContext;\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, alloc_error_handler_kind: AllocatorKind) {\n     let context = &mods.context;\n     let usize =\n         match tcx.sess.target.pointer_width {\n@@ -90,14 +90,7 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         .collect();\n     let func = context.new_function(None, FunctionType::Exported, void, &args, name, false);\n \n-    let kind =\n-        if has_alloc_error_handler {\n-            AllocatorKind::Global\n-        }\n-        else {\n-            AllocatorKind::Default\n-        };\n-    let callee = kind.fn_name(sym::oom);\n+    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n     let args: Vec<_> = types.iter().enumerate()\n         .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n         .collect();"}, {"sha": "dd0daf2c38b109c9775edf7ca5d70056b9e4c699", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -153,11 +153,11 @@ impl CodegenBackend for GccCodegenBackend {\n }\n \n impl ExtraBackendMethods for GccCodegenBackend {\n-    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) -> Self::Module {\n+    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind, alloc_error_handler_kind: AllocatorKind) -> Self::Module {\n         let mut mods = GccContext {\n             context: Context::default(),\n         };\n-        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind, has_alloc_error_handler); }\n+        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind, alloc_error_handler_kind); }\n         mods\n     }\n "}, {"sha": "fed56cdd43821e6cb2dd76a0918e7dcc5c55bf32", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -15,7 +15,7 @@ pub(crate) unsafe fn codegen(\n     module_llvm: &mut ModuleLlvm,\n     module_name: &str,\n     kind: AllocatorKind,\n-    has_alloc_error_handler: bool,\n+    alloc_error_handler_kind: AllocatorKind,\n ) {\n     let llcx = &*module_llvm.llcx;\n     let llmod = module_llvm.llmod();\n@@ -117,8 +117,7 @@ pub(crate) unsafe fn codegen(\n         attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n     }\n \n-    let kind = if has_alloc_error_handler { AllocatorKind::Global } else { AllocatorKind::Default };\n-    let callee = kind.fn_name(sym::oom);\n+    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n     let callee = llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n     // -> ! DIFlagNoReturn\n     attributes::apply_to_llfn(callee, llvm::AttributePlace::Function, &[no_return]);"}, {"sha": "d51aced85df43141c779d0902244f651bdcb7358", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -108,11 +108,11 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         tcx: TyCtxt<'tcx>,\n         module_name: &str,\n         kind: AllocatorKind,\n-        has_alloc_error_handler: bool,\n+        alloc_error_handler_kind: AllocatorKind,\n     ) -> ModuleLlvm {\n         let mut module_llvm = ModuleLlvm::new_metadata(tcx, module_name);\n         unsafe {\n-            allocator::codegen(tcx, &mut module_llvm, module_name, kind, has_alloc_error_handler);\n+            allocator::codegen(tcx, &mut module_llvm, module_name, kind, alloc_error_handler_kind);\n         }\n         module_llvm\n     }"}, {"sha": "752f6b1ef40c92fcdd64994d03c715f9ad6ee90b", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -193,8 +193,11 @@ fn exported_symbols_provider_local<'tcx>(\n     }\n \n     if tcx.allocator_kind(()).is_some() {\n-        for method in ALLOCATOR_METHODS {\n-            let symbol_name = format!(\"__rust_{}\", method.name);\n+        for symbol_name in ALLOCATOR_METHODS\n+            .iter()\n+            .map(|method| format!(\"__rust_{}\", method.name))\n+            .chain([\"__rust_alloc_error_handler\".to_string(), OomStrategy::SYMBOL.to_string()])\n+        {\n             let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(tcx, &symbol_name));\n \n             symbols.push(("}, {"sha": "c1411690f8289883f8cc391bffd19018b797fad0", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -638,7 +638,14 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         let llmod_id =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n         let module_llvm = tcx.sess.time(\"write_allocator_module\", || {\n-            backend.codegen_allocator(tcx, &llmod_id, kind, tcx.lang_items().oom().is_some())\n+            backend.codegen_allocator(\n+                tcx,\n+                &llmod_id,\n+                kind,\n+                // If allocator_kind is Some then alloc_error_handler_kind must\n+                // also be Some.\n+                tcx.alloc_error_handler_kind(()).unwrap(),\n+            )\n         });\n \n         Some(ModuleCodegen { name: llmod_id, module_llvm, kind: ModuleKind::Allocator })"}, {"sha": "5c35070ea66f4f1ffca07091755333058e6f146e", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -119,7 +119,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         tcx: TyCtxt<'tcx>,\n         module_name: &str,\n         kind: AllocatorKind,\n-        has_alloc_error_handler: bool,\n+        alloc_error_handler_kind: AllocatorKind,\n     ) -> Self::Module;\n     /// This generates the codegen unit and returns it along with\n     /// a `u64` giving an estimate of the unit's processing cost."}, {"sha": "f7d64f6d4f48ae2be6f6d29a69b1fa73222f1fe6", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -598,7 +598,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // the last field).  Can't have foreign types here, how would we\n                 // adjust alignment and size for them?\n                 let field = layout.field(self, layout.fields.count() - 1);\n-                let Some((unsized_size, unsized_align)) = self.size_and_align_of(metadata, &field)? else {\n+                let Some((unsized_size, mut unsized_align)) = self.size_and_align_of(metadata, &field)? else {\n                     // A field with an extern type. We don't know the actual dynamic size\n                     // or the alignment.\n                     return Ok(None);\n@@ -614,6 +614,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Return the sum of sizes and max of aligns.\n                 let size = sized_size + unsized_size; // `Size` addition\n \n+                // Packed types ignore the alignment of their fields.\n+                if let ty::Adt(def, _) = layout.ty.kind() {\n+                    if def.repr().packed() {\n+                        unsized_align = sized_align;\n+                    }\n+                }\n+\n                 // Choose max of two known alignments (combined value must\n                 // be aligned according to more restrictive of the two).\n                 let align = sized_align.max(unsized_align);"}, {"sha": "c292ae9b32abba5af8a913994643c571303332c2", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -150,12 +150,28 @@ metadata_no_multiple_global_alloc =\n metadata_prev_global_alloc =\n     previous global allocator defined here\n \n+metadata_no_multiple_alloc_error_handler =\n+    cannot define multiple allocation error handlers\n+    .label = cannot define a new allocation error handler\n+\n+metadata_prev_alloc_error_handler =\n+    previous allocation error handler defined here\n+\n metadata_conflicting_global_alloc =\n     the `#[global_allocator]` in {$other_crate_name} conflicts with global allocator in: {$crate_name}\n \n+metadata_conflicting_alloc_error_handler =\n+    the `#[alloc_error_handler]` in {$other_crate_name} conflicts with allocation error handler in: {$crate_name}\n+\n metadata_global_alloc_required =\n     no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n \n+metadata_alloc_func_required =\n+    `#[alloc_error_handler]` function required, but not found\n+\n+metadata_missing_alloc_error_handler =\n+    use `#![feature(default_alloc_error_handler)]` for a default error handler\n+\n metadata_no_transitive_needs_dep =\n     the crate `{$crate_name}` cannot depend on a crate that needs {$needs_crate_name}, but it depends on `{$deps_crate_name}`\n "}, {"sha": "bc5bfe2a24448ba575c4adcc4697a1b9b3549847", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -367,12 +367,6 @@ passes_unknown_external_lang_item =\n passes_missing_panic_handler =\n     `#[panic_handler]` function required, but not found\n \n-passes_alloc_func_required =\n-    `#[alloc_error_handler]` function required, but not found\n-\n-passes_missing_alloc_error_handler =\n-    use `#![feature(default_alloc_error_handler)]` for a default error handler\n-\n passes_missing_lang_item =\n     language item required, but not found: `{$name}`\n     .note = this can occur when a binary crate with `#![no_std]` is compiled for a target where `{$name}` is defined in the standard library"}, {"sha": "14c8e3c458c497a241673ea10558f5298363f059", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -554,10 +554,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(rustc_reallocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     rustc_attr!(rustc_deallocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     rustc_attr!(rustc_allocator_zeroed, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n-    gated!(\n-        alloc_error_handler, Normal, template!(Word), WarnFollowing,\n-        experimental!(alloc_error_handler)\n-    ),\n     gated!(\n         default_lib_allocator, Normal, template!(Word), WarnFollowing, allocator_internals,\n         experimental!(default_lib_allocator),"}, {"sha": "a55224d10972abf01a57e95933d174bab7481941", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -126,14 +126,12 @@ impl<CTX> HashStable<CTX> for LangItem {\n }\n \n /// Extracts the first `lang = \"$name\"` out of a list of attributes.\n-/// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n-/// are also extracted out when found.\n+/// The `#[panic_handler]` attribute is also extracted out when found.\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n     attrs.iter().find_map(|attr| {\n         Some(match attr {\n             _ if attr.has_name(sym::lang) => (attr.value_str()?, attr.span),\n             _ if attr.has_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n-            _ if attr.has_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n             _ => return None,\n         })\n     })\n@@ -240,7 +238,6 @@ language_item_table! {\n     ExchangeMalloc,          sym::exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n     BoxFree,                 sym::box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n     DropInPlace,             sym::drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n-    Oom,                     sym::oom,                 oom,                        Target::Fn,             GenericRequirement::None;\n     AllocLayout,             sym::alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n \n     Start,                   sym::start,               start_fn,                   Target::Fn,             GenericRequirement::Exact(1);"}, {"sha": "0cc50c6dd85054642fdb576e5137c7bded4bb934", "filename": "compiler/rustc_hir/src/weak_lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -27,5 +27,4 @@ weak_lang_items! {\n     PanicImpl,          rust_begin_unwind;\n     EhPersonality,      rust_eh_personality;\n     EhCatchTypeinfo,    rust_eh_catch_typeinfo;\n-    Oom,                rust_oom;\n }"}, {"sha": "133bbd52b9142c3249d634c057088df2953bfef9", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 62, "deletions": 59, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -6,7 +6,7 @@ use super::*;\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{ItemKind, Node, PathSegment};\n@@ -75,15 +75,15 @@ fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         check_simd(tcx, span, def_id);\n     }\n \n-    check_transparent(tcx, span, def);\n+    check_transparent(tcx, def);\n     check_packed(tcx, span, def);\n }\n \n fn check_union(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n-    check_transparent(tcx, span, def);\n+    check_transparent(tcx, def);\n     check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def);\n }\n@@ -506,11 +506,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n             tcx.ensure().typeck(id.owner_id.def_id);\n         }\n         DefKind::Enum => {\n-            let item = tcx.hir().item(id);\n-            let hir::ItemKind::Enum(ref enum_definition, _) = item.kind else {\n-                return;\n-            };\n-            check_enum(tcx, &enum_definition.variants, item.owner_id.def_id);\n+            check_enum(tcx, id.owner_id.def_id);\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n@@ -1026,7 +1022,7 @@ pub(super) fn check_packed_inner(\n     None\n }\n \n-pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtDef<'tcx>) {\n+pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>) {\n     if !adt.repr().transparent() {\n         return;\n     }\n@@ -1035,14 +1031,14 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n         feature_err(\n             &tcx.sess.parse_sess,\n             sym::transparent_unions,\n-            sp,\n+            tcx.def_span(adt.did()),\n             \"transparent unions are unstable\",\n         )\n         .emit();\n     }\n \n     if adt.variants().len() != 1 {\n-        bad_variant_count(tcx, adt, sp, adt.did());\n+        bad_variant_count(tcx, adt, tcx.def_span(adt.did()), adt.did());\n         if adt.variants().is_empty() {\n             // Don't bother checking the fields. No variants (and thus no fields) exist.\n             return;\n@@ -1103,7 +1099,7 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n         .filter_map(|(span, zst, _align1, _non_exhaustive)| if !zst { Some(span) } else { None });\n     let non_zst_count = non_zst_fields.clone().count();\n     if non_zst_count >= 2 {\n-        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, sp);\n+        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, tcx.def_span(adt.did()));\n     }\n     let incompatible_zst_fields =\n         field_infos.clone().filter(|(_, _, _, opt)| opt.is_some()).count();\n@@ -1143,20 +1139,19 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n }\n \n #[allow(trivial_numeric_casts)]\n-fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: LocalDefId) {\n+fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n-    let sp = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n \n-    if vs.is_empty() {\n+    if def.variants().is_empty() {\n         if let Some(attr) = tcx.get_attrs(def_id.to_def_id(), sym::repr).next() {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,\n                 E0084,\n                 \"unsupported representation for zero-variant enum\"\n             )\n-            .span_label(sp, \"zero-variant enum\")\n+            .span_label(tcx.def_span(def_id), \"zero-variant enum\")\n             .emit();\n         }\n     }\n@@ -1167,88 +1162,96 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: L\n             feature_err(\n                 &tcx.sess.parse_sess,\n                 sym::repr128,\n-                sp,\n+                tcx.def_span(def_id),\n                 \"repr with 128-bit type is unstable\",\n             )\n             .emit();\n         }\n     }\n \n-    for v in vs {\n-        if let Some(ref e) = v.disr_expr {\n-            tcx.ensure().typeck(tcx.hir().local_def_id(e.hir_id));\n+    for v in def.variants() {\n+        if let ty::VariantDiscr::Explicit(discr_def_id) = v.discr {\n+            tcx.ensure().typeck(discr_def_id.expect_local());\n         }\n     }\n \n-    if tcx.adt_def(def_id).repr().int.is_none() {\n-        let is_unit = |var: &hir::Variant<'_>| matches!(var.data, hir::VariantData::Unit(..));\n+    if def.repr().int.is_none() {\n+        let is_unit = |var: &ty::VariantDef| matches!(var.ctor_kind, CtorKind::Const);\n+        let has_disr = |var: &ty::VariantDef| matches!(var.discr, ty::VariantDiscr::Explicit(_));\n \n-        let has_disr = |var: &hir::Variant<'_>| var.disr_expr.is_some();\n-        let has_non_units = vs.iter().any(|var| !is_unit(var));\n-        let disr_units = vs.iter().any(|var| is_unit(&var) && has_disr(&var));\n-        let disr_non_unit = vs.iter().any(|var| !is_unit(&var) && has_disr(&var));\n+        let has_non_units = def.variants().iter().any(|var| !is_unit(var));\n+        let disr_units = def.variants().iter().any(|var| is_unit(&var) && has_disr(&var));\n+        let disr_non_unit = def.variants().iter().any(|var| !is_unit(&var) && has_disr(&var));\n \n         if disr_non_unit || (disr_units && has_non_units) {\n-            let mut err =\n-                struct_span_err!(tcx.sess, sp, E0732, \"`#[repr(inttype)]` must be specified\");\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                tcx.def_span(def_id),\n+                E0732,\n+                \"`#[repr(inttype)]` must be specified\"\n+            );\n             err.emit();\n         }\n     }\n \n-    detect_discriminant_duplicate(tcx, def.discriminants(tcx).collect(), vs, sp);\n-\n-    check_transparent(tcx, sp, def);\n+    detect_discriminant_duplicate(tcx, def);\n+    check_transparent(tcx, def);\n }\n \n /// Part of enum check. Given the discriminants of an enum, errors if two or more discriminants are equal\n-fn detect_discriminant_duplicate<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mut discrs: Vec<(VariantIdx, Discr<'tcx>)>,\n-    vs: &'tcx [hir::Variant<'tcx>],\n-    self_span: Span,\n-) {\n+fn detect_discriminant_duplicate<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>) {\n     // Helper closure to reduce duplicate code. This gets called everytime we detect a duplicate.\n     // Here `idx` refers to the order of which the discriminant appears, and its index in `vs`\n-    let report = |dis: Discr<'tcx>, idx: usize, err: &mut Diagnostic| {\n-        let var = &vs[idx]; // HIR for the duplicate discriminant\n-        let (span, display_discr) = match var.disr_expr {\n-            Some(ref expr) => {\n+    let report = |dis: Discr<'tcx>, idx, err: &mut Diagnostic| {\n+        let var = adt.variant(idx); // HIR for the duplicate discriminant\n+        let (span, display_discr) = match var.discr {\n+            ty::VariantDiscr::Explicit(discr_def_id) => {\n                 // In the case the discriminant is both a duplicate and overflowed, let the user know\n-                if let hir::ExprKind::Lit(lit) = &tcx.hir().body(expr.body).value.kind\n+                if let hir::Node::AnonConst(expr) = tcx.hir().get_by_def_id(discr_def_id.expect_local())\n+                    && let hir::ExprKind::Lit(lit) = &tcx.hir().body(expr.body).value.kind\n                     && let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node\n                     && *lit_value != dis.val\n                 {\n-                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}` (overflowed from `{lit_value}`)\"))\n-                // Otherwise, format the value as-is\n+                    (tcx.def_span(discr_def_id), format!(\"`{dis}` (overflowed from `{lit_value}`)\"))\n                 } else {\n-                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}`\"))\n+                    // Otherwise, format the value as-is\n+                    (tcx.def_span(discr_def_id), format!(\"`{dis}`\"))\n                 }\n             }\n-            None => {\n+            // This should not happen.\n+            ty::VariantDiscr::Relative(0) => (tcx.def_span(var.def_id), format!(\"`{dis}`\")),\n+            ty::VariantDiscr::Relative(distance_to_explicit) => {\n                 // At this point we know this discriminant is a duplicate, and was not explicitly\n                 // assigned by the user. Here we iterate backwards to fetch the HIR for the last\n                 // explicitly assigned discriminant, and letting the user know that this was the\n                 // increment startpoint, and how many steps from there leading to the duplicate\n-                if let Some((n, hir::Variant { span, ident, .. })) =\n-                    vs[..idx].iter().rev().enumerate().find(|v| v.1.disr_expr.is_some())\n+                if let Some(explicit_idx) =\n+                    idx.as_u32().checked_sub(distance_to_explicit).map(VariantIdx::from_u32)\n                 {\n-                    let ve_ident = var.ident;\n-                    let n = n + 1;\n-                    let sp = if n > 1 { \"variants\" } else { \"variant\" };\n+                    let explicit_variant = adt.variant(explicit_idx);\n+                    let ve_ident = var.name;\n+                    let ex_ident = explicit_variant.name;\n+                    let sp = if distance_to_explicit > 1 { \"variants\" } else { \"variant\" };\n \n                     err.span_label(\n-                        *span,\n-                        format!(\"discriminant for `{ve_ident}` incremented from this startpoint (`{ident}` + {n} {sp} later => `{ve_ident}` = {dis})\"),\n+                        tcx.def_span(explicit_variant.def_id),\n+                        format!(\n+                            \"discriminant for `{ve_ident}` incremented from this startpoint \\\n+                            (`{ex_ident}` + {distance_to_explicit} {sp} later \\\n+                             => `{ve_ident}` = {dis})\"\n+                        ),\n                     );\n                 }\n \n-                (vs[idx].span, format!(\"`{dis}`\"))\n+                (tcx.def_span(var.def_id), format!(\"`{dis}`\"))\n             }\n         };\n \n         err.span_label(span, format!(\"{display_discr} assigned here\"));\n     };\n \n+    let mut discrs = adt.discriminants(tcx).collect::<Vec<_>>();\n+\n     // Here we loop through the discriminants, comparing each discriminant to another.\n     // When a duplicate is detected, we instantiate an error and point to both\n     // initial and duplicate value. The duplicate discriminant is then discarded by swapping\n@@ -1257,29 +1260,29 @@ fn detect_discriminant_duplicate<'tcx>(\n     // style as we are mutating `discrs` on the fly).\n     let mut i = 0;\n     while i < discrs.len() {\n-        let hir_var_i_idx = discrs[i].0.index();\n+        let var_i_idx = discrs[i].0;\n         let mut error: Option<DiagnosticBuilder<'_, _>> = None;\n \n         let mut o = i + 1;\n         while o < discrs.len() {\n-            let hir_var_o_idx = discrs[o].0.index();\n+            let var_o_idx = discrs[o].0;\n \n             if discrs[i].1.val == discrs[o].1.val {\n                 let err = error.get_or_insert_with(|| {\n                     let mut ret = struct_span_err!(\n                         tcx.sess,\n-                        self_span,\n+                        tcx.def_span(adt.did()),\n                         E0081,\n                         \"discriminant value `{}` assigned more than once\",\n                         discrs[i].1,\n                     );\n \n-                    report(discrs[i].1, hir_var_i_idx, &mut ret);\n+                    report(discrs[i].1, var_i_idx, &mut ret);\n \n                     ret\n                 });\n \n-                report(discrs[o].1, hir_var_o_idx, err);\n+                report(discrs[o].1, var_o_idx, err);\n \n                 // Safe to unwrap here, as we wouldn't reach this point if `discrs` was empty\n                 discrs[o] = *discrs.last().unwrap();"}, {"sha": "99d0beacfa0a1b9a7b5fee2815d696375591bfef", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 28, "deletions": 79, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -218,19 +218,16 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::Const(ty, ..) => {\n             check_item_type(tcx, def_id, ty.span, false);\n         }\n-        hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, false, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n-\n+        hir::ItemKind::Struct(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, false);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Union(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n-\n+        hir::ItemKind::Union(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Enum(ref enum_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |wfcx| wfcx.enum_variants(enum_def));\n-\n+        hir::ItemKind::Enum(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n         hir::ItemKind::Trait(..) => {\n@@ -1037,35 +1034,33 @@ fn item_adt_kind(kind: &ItemKind<'_>) -> Option<AdtKind> {\n }\n \n /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-fn check_type_defn<'tcx, F>(\n-    tcx: TyCtxt<'tcx>,\n-    item: &hir::Item<'tcx>,\n-    all_sized: bool,\n-    mut lookup_fields: F,\n-) where\n-    F: FnMut(&WfCheckingCtxt<'_, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n-{\n+fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: bool) {\n     let _ = tcx.representability(item.owner_id.def_id);\n+    let adt_def = tcx.adt_def(item.owner_id);\n \n     enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n-        let variants = lookup_fields(wfcx);\n-        let packed = tcx.adt_def(item.owner_id).repr().packed();\n+        let variants = adt_def.variants();\n+        let packed = adt_def.repr().packed();\n \n-        for variant in &variants {\n+        for variant in variants.iter() {\n             // All field types must be well-formed.\n             for field in &variant.fields {\n+                let field_id = field.did.expect_local();\n+                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n+                else { bug!() };\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_wf_obligation(\n-                    field.span,\n-                    Some(WellFormedLoc::Ty(field.def_id)),\n-                    field.ty.into(),\n+                    hir_ty.span,\n+                    Some(WellFormedLoc::Ty(field_id)),\n+                    ty.into(),\n                 )\n             }\n \n             // For DST, or when drop needs to copy things around, all\n             // intermediate types must be sized.\n             let needs_drop_copy = || {\n                 packed && {\n-                    let ty = variant.fields.last().unwrap().ty;\n+                    let ty = tcx.type_of(variant.fields.last().unwrap().did);\n                     let ty = tcx.erase_regions(ty);\n                     if ty.needs_infer() {\n                         tcx.sess\n@@ -1084,27 +1079,31 @@ fn check_type_defn<'tcx, F>(\n                 variant.fields[..variant.fields.len() - unsized_len].iter().enumerate()\n             {\n                 let last = idx == variant.fields.len() - 1;\n+                let field_id = field.did.expect_local();\n+                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n+                else { bug!() };\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_bound(\n                     traits::ObligationCause::new(\n-                        field.span,\n+                        hir_ty.span,\n                         wfcx.body_id,\n                         traits::FieldSized {\n                             adt_kind: match item_adt_kind(&item.kind) {\n                                 Some(i) => i,\n                                 None => bug!(),\n                             },\n-                            span: field.span,\n+                            span: hir_ty.span,\n                             last,\n                         },\n                     ),\n                     wfcx.param_env,\n-                    field.ty,\n+                    ty,\n                     tcx.require_lang_item(LangItem::Sized, None),\n                 );\n             }\n \n             // Explicit `enum` discriminant values must const-evaluate successfully.\n-            if let Some(discr_def_id) = variant.explicit_discr {\n+            if let ty::VariantDiscr::Explicit(discr_def_id) = variant.discr {\n                 let cause = traits::ObligationCause::new(\n                     tcx.def_span(discr_def_id),\n                     wfcx.body_id,\n@@ -1114,7 +1113,7 @@ fn check_type_defn<'tcx, F>(\n                     cause,\n                     wfcx.param_env,\n                     ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(\n-                        ty::Const::from_anon_const(tcx, discr_def_id),\n+                        ty::Const::from_anon_const(tcx, discr_def_id.expect_local()),\n                     ))\n                     .to_predicate(tcx),\n                 ));\n@@ -1925,56 +1924,6 @@ fn check_mod_type_wf(tcx: TyCtxt<'_>, module: LocalDefId) {\n     items.par_foreign_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// ADT\n-\n-// FIXME(eddyb) replace this with getting fields/discriminants through `ty::AdtDef`.\n-struct AdtVariant<'tcx> {\n-    /// Types of fields in the variant, that must be well-formed.\n-    fields: Vec<AdtField<'tcx>>,\n-\n-    /// Explicit discriminant of this variant (e.g. `A = 123`),\n-    /// that must evaluate to a constant value.\n-    explicit_discr: Option<LocalDefId>,\n-}\n-\n-struct AdtField<'tcx> {\n-    ty: Ty<'tcx>,\n-    def_id: LocalDefId,\n-    span: Span,\n-}\n-\n-impl<'a, 'tcx> WfCheckingCtxt<'a, 'tcx> {\n-    // FIXME(eddyb) replace this with getting fields through `ty::AdtDef`.\n-    fn non_enum_variant(&self, struct_def: &hir::VariantData<'_>) -> AdtVariant<'tcx> {\n-        let fields = struct_def\n-            .fields()\n-            .iter()\n-            .map(|field| {\n-                let def_id = self.tcx().hir().local_def_id(field.hir_id);\n-                let field_ty = self.tcx().type_of(def_id);\n-                let field_ty = self.normalize(field.ty.span, None, field_ty);\n-                debug!(\"non_enum_variant: type of field {:?} is {:?}\", field, field_ty);\n-                AdtField { ty: field_ty, span: field.ty.span, def_id }\n-            })\n-            .collect();\n-        AdtVariant { fields, explicit_discr: None }\n-    }\n-\n-    fn enum_variants(&self, enum_def: &hir::EnumDef<'_>) -> Vec<AdtVariant<'tcx>> {\n-        enum_def\n-            .variants\n-            .iter()\n-            .map(|variant| AdtVariant {\n-                fields: self.non_enum_variant(&variant.data).fields,\n-                explicit_discr: variant\n-                    .disr_expr\n-                    .map(|explicit_discr| self.tcx().hir().local_def_id(explicit_discr.hir_id)),\n-            })\n-            .collect()\n-    }\n-}\n-\n fn error_392(\n     tcx: TyCtxt<'_>,\n     span: Span,"}, {"sha": "46db0f74d4d5f5b936c0b529aa22246564493007", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -604,11 +604,11 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                 }\n             }\n         }\n-        hir::ItemKind::Enum(ref enum_definition, _) => {\n+        hir::ItemKind::Enum(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n-            convert_enum_variant_types(tcx, def_id.to_def_id(), enum_definition.variants);\n+            convert_enum_variant_types(tcx, def_id.to_def_id());\n         }\n         hir::ItemKind::Impl { .. } => {\n             tcx.ensure().generics_of(def_id);\n@@ -640,7 +640,8 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             }\n \n             if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n-                convert_variant_ctor(tcx, ctor_hir_id);\n+                let ctor_def_id = tcx.hir().local_def_id(ctor_hir_id);\n+                convert_variant_ctor(tcx, ctor_def_id);\n             }\n         }\n \n@@ -750,55 +751,51 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n     }\n }\n \n-fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n-    let def_id = tcx.hir().local_def_id(ctor_id);\n+fn convert_variant_ctor(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     tcx.ensure().generics_of(def_id);\n     tcx.ensure().type_of(def_id);\n     tcx.ensure().predicates_of(def_id);\n }\n \n-fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::Variant<'_>]) {\n+fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId) {\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr().discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n     let mut prev_discr = None::<Discr<'_>>;\n \n     // fill the discriminant values and field types\n-    for variant in variants {\n+    for variant in def.variants() {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(\n-            if let Some(ref e) = variant.disr_expr {\n-                let expr_did = tcx.hir().local_def_id(e.hir_id);\n-                def.eval_explicit_discr(tcx, expr_did.to_def_id())\n+            if let ty::VariantDiscr::Explicit(const_def_id) = variant.discr {\n+                def.eval_explicit_discr(tcx, const_def_id)\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n                 Some(discr)\n             } else {\n-                struct_span_err!(tcx.sess, variant.span, E0370, \"enum discriminant overflowed\")\n-                    .span_label(\n-                        variant.span,\n-                        format!(\"overflowed on value after {}\", prev_discr.unwrap()),\n-                    )\n+                let span = tcx.def_span(variant.def_id);\n+                struct_span_err!(tcx.sess, span, E0370, \"enum discriminant overflowed\")\n+                    .span_label(span, format!(\"overflowed on value after {}\", prev_discr.unwrap()))\n                     .note(&format!(\n                         \"explicitly set `{} = {}` if that is desired outcome\",\n-                        variant.ident, wrapped_discr\n+                        tcx.item_name(variant.def_id),\n+                        wrapped_discr\n                     ))\n                     .emit();\n                 None\n             }\n             .unwrap_or(wrapped_discr),\n         );\n \n-        for f in variant.data.fields() {\n-            let def_id = tcx.hir().local_def_id(f.hir_id);\n-            tcx.ensure().generics_of(def_id);\n-            tcx.ensure().type_of(def_id);\n-            tcx.ensure().predicates_of(def_id);\n+        for f in &variant.fields {\n+            tcx.ensure().generics_of(f.did);\n+            tcx.ensure().type_of(f.did);\n+            tcx.ensure().predicates_of(f.did);\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n-            convert_variant_ctor(tcx, ctor_hir_id);\n+        if let Some(ctor_def_id) = variant.ctor_def_id {\n+            convert_variant_ctor(tcx, ctor_def_id.expect_local());\n         }\n     }\n }"}, {"sha": "b706d786b52518ef5db07778c06ae3b6e2e3296e", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -211,13 +211,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n         check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n     }\n \n-    // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n-    if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n-        && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n-    {\n-        check_alloc_error_fn(tcx, alloc_error_handler_did.expect_local(), fn_sig, decl, declared_ret_ty);\n-    }\n-\n     (fcx, gen_ty)\n }\n \n@@ -273,52 +266,3 @@ fn check_panic_info_fn(\n         tcx.sess.span_err(span, \"should have no const parameters\");\n     }\n }\n-\n-fn check_alloc_error_fn(\n-    tcx: TyCtxt<'_>,\n-    fn_id: LocalDefId,\n-    fn_sig: ty::FnSig<'_>,\n-    decl: &hir::FnDecl<'_>,\n-    declared_ret_ty: Ty<'_>,\n-) {\n-    let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() else {\n-        tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n-        return;\n-    };\n-\n-    if *declared_ret_ty.kind() != ty::Never {\n-        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n-    }\n-\n-    let inputs = fn_sig.inputs();\n-    if inputs.len() != 1 {\n-        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n-        return;\n-    }\n-\n-    let arg_is_alloc_layout = match inputs[0].kind() {\n-        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n-        _ => false,\n-    };\n-\n-    if !arg_is_alloc_layout {\n-        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n-    }\n-\n-    let DefKind::Fn = tcx.def_kind(fn_id) else {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"`#[alloc_error_handler]` should be a function\");\n-        return;\n-    };\n-\n-    let generic_counts = tcx.generics_of(fn_id).own_counts();\n-    if generic_counts.types != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"`#[alloc_error_handler]` function should have no type parameters\");\n-    }\n-    if generic_counts.consts != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess\n-            .span_err(span, \"`#[alloc_error_handler]` function should have no const parameters\");\n-    }\n-}"}, {"sha": "d4c457975a8422e76f31321a85c3f3713699d1b7", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 85, "deletions": 12, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -1,8 +1,10 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n use crate::errors::{\n-    ConflictingGlobalAlloc, CrateNotPanicRuntime, GlobalAllocRequired, NoMultipleGlobalAlloc,\n-    NoPanicStrategy, NoTransitiveNeedsDep, NotProfilerRuntime, ProfilerBuiltinsNeedsCore,\n+    AllocFuncRequired, ConflictingAllocErrorHandler, ConflictingGlobalAlloc, CrateNotPanicRuntime,\n+    GlobalAllocRequired, MissingAllocErrorHandler, NoMultipleAllocErrorHandler,\n+    NoMultipleGlobalAlloc, NoPanicStrategy, NoTransitiveNeedsDep, NotProfilerRuntime,\n+    ProfilerBuiltinsNeedsCore,\n };\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n@@ -41,8 +43,13 @@ pub struct CStore {\n     /// This crate needs an allocator and either provides it itself, or finds it in a dependency.\n     /// If the above is true, then this field denotes the kind of the found allocator.\n     allocator_kind: Option<AllocatorKind>,\n+    /// This crate needs an allocation error handler and either provides it itself, or finds it in a dependency.\n+    /// If the above is true, then this field denotes the kind of the found allocator.\n+    alloc_error_handler_kind: Option<AllocatorKind>,\n     /// This crate has a `#[global_allocator]` item.\n     has_global_allocator: bool,\n+    /// This crate has a `#[alloc_error_handler]` item.\n+    has_alloc_error_handler: bool,\n \n     /// This map is used to verify we get no hash conflicts between\n     /// `StableCrateId` values.\n@@ -197,10 +204,18 @@ impl CStore {\n         self.allocator_kind\n     }\n \n+    pub(crate) fn alloc_error_handler_kind(&self) -> Option<AllocatorKind> {\n+        self.alloc_error_handler_kind\n+    }\n+\n     pub(crate) fn has_global_allocator(&self) -> bool {\n         self.has_global_allocator\n     }\n \n+    pub(crate) fn has_alloc_error_handler(&self) -> bool {\n+        self.has_alloc_error_handler\n+    }\n+\n     pub fn report_unused_deps(&self, tcx: TyCtxt<'_>) {\n         let json_unused_externs = tcx.sess.opts.json_unused_externs;\n \n@@ -247,7 +262,9 @@ impl<'a> CrateLoader<'a> {\n                 metas: IndexVec::from_elem_n(None, 1),\n                 injected_panic_runtime: None,\n                 allocator_kind: None,\n+                alloc_error_handler_kind: None,\n                 has_global_allocator: false,\n+                has_alloc_error_handler: false,\n                 stable_crate_ids,\n                 unused_externs: Vec::new(),\n             },\n@@ -792,6 +809,13 @@ impl<'a> CrateLoader<'a> {\n             }\n             spans => !spans.is_empty(),\n         };\n+        self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(&self.sess, krate) {\n+            [span1, span2, ..] => {\n+                self.sess.emit_err(NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n+                true\n+            }\n+            spans => !spans.is_empty(),\n+        };\n \n         // Check to see if we actually need an allocator. This desire comes\n         // about through the `#![needs_allocator]` attribute and is typically\n@@ -832,22 +856,48 @@ impl<'a> CrateLoader<'a> {\n                 }\n             }\n         }\n+        let mut alloc_error_handler =\n+            self.cstore.has_alloc_error_handler.then(|| Symbol::intern(\"this crate\"));\n+        for (_, data) in self.cstore.iter_crate_data() {\n+            if data.has_alloc_error_handler() {\n+                match alloc_error_handler {\n+                    Some(other_crate) => {\n+                        self.sess.emit_err(ConflictingAllocErrorHandler {\n+                            crate_name: data.name(),\n+                            other_crate_name: other_crate,\n+                        });\n+                    }\n+                    None => alloc_error_handler = Some(data.name()),\n+                }\n+            }\n+        }\n \n         if global_allocator.is_some() {\n             self.cstore.allocator_kind = Some(AllocatorKind::Global);\n-            return;\n+        } else {\n+            // Ok we haven't found a global allocator but we still need an\n+            // allocator. At this point our allocator request is typically fulfilled\n+            // by the standard library, denoted by the `#![default_lib_allocator]`\n+            // attribute.\n+            if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n+                && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n+            {\n+                self.sess.emit_err(GlobalAllocRequired);\n+            }\n+            self.cstore.allocator_kind = Some(AllocatorKind::Default);\n         }\n \n-        // Ok we haven't found a global allocator but we still need an\n-        // allocator. At this point our allocator request is typically fulfilled\n-        // by the standard library, denoted by the `#![default_lib_allocator]`\n-        // attribute.\n-        if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n-            && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n-        {\n-            self.sess.emit_err(GlobalAllocRequired);\n+        if alloc_error_handler.is_some() {\n+            self.cstore.alloc_error_handler_kind = Some(AllocatorKind::Global);\n+        } else {\n+            // The alloc crate provides a default allocation error handler if\n+            // one isn't specified.\n+            if !self.sess.features_untracked().default_alloc_error_handler {\n+                self.sess.emit_err(AllocFuncRequired);\n+                self.sess.emit_note(MissingAllocErrorHandler);\n+            }\n+            self.cstore.alloc_error_handler_kind = Some(AllocatorKind::Default);\n         }\n-        self.cstore.allocator_kind = Some(AllocatorKind::Default);\n     }\n \n     fn inject_dependency_if(\n@@ -1023,3 +1073,26 @@ fn global_allocator_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n     visit::walk_crate(&mut f, krate);\n     f.spans\n }\n+\n+fn alloc_error_handler_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder<'a> {\n+        sess: &'a Session,\n+        name: Symbol,\n+        spans: Vec<Span>,\n+    }\n+    impl<'ast, 'a> visit::Visitor<'ast> for Finder<'a> {\n+        fn visit_item(&mut self, item: &'ast ast::Item) {\n+            if item.ident.name == self.name\n+                && self.sess.contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n+            {\n+                self.spans.push(item.span);\n+            }\n+            visit::walk_item(self, item)\n+        }\n+    }\n+\n+    let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::oom));\n+    let mut f = Finder { sess, name, spans: Vec::new() };\n+    visit::walk_crate(&mut f, krate);\n+    f.spans\n+}"}, {"sha": "289fa53aa5ef6f641412dfd0faedd5f427dcaae2", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -343,17 +343,42 @@ pub struct NoMultipleGlobalAlloc {\n     pub span1: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(metadata_no_multiple_alloc_error_handler)]\n+pub struct NoMultipleAllocErrorHandler {\n+    #[primary_span]\n+    #[label]\n+    pub span2: Span,\n+    #[label(metadata_prev_alloc_error_handler)]\n+    pub span1: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(metadata_conflicting_global_alloc)]\n pub struct ConflictingGlobalAlloc {\n     pub crate_name: Symbol,\n     pub other_crate_name: Symbol,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(metadata_conflicting_alloc_error_handler)]\n+pub struct ConflictingAllocErrorHandler {\n+    pub crate_name: Symbol,\n+    pub other_crate_name: Symbol,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(metadata_global_alloc_required)]\n pub struct GlobalAllocRequired;\n \n+#[derive(Diagnostic)]\n+#[diag(metadata_alloc_func_required)]\n+pub struct AllocFuncRequired;\n+\n+#[derive(Diagnostic)]\n+#[diag(metadata_missing_alloc_error_handler)]\n+pub struct MissingAllocErrorHandler;\n+\n #[derive(Diagnostic)]\n #[diag(metadata_no_transitive_needs_dep)]\n pub struct NoTransitiveNeedsDep<'a> {"}, {"sha": "8e80d794a13680df61c90fe9e4399c2a362dcb8f", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -1764,6 +1764,10 @@ impl CrateMetadata {\n         self.root.has_global_allocator\n     }\n \n+    pub(crate) fn has_alloc_error_handler(&self) -> bool {\n+        self.root.has_alloc_error_handler\n+    }\n+\n     pub(crate) fn has_default_lib_allocator(&self) -> bool {\n         self.root.has_default_lib_allocator\n     }"}, {"sha": "f475b0b39811c5f281ed3af160f7c959112890af", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -255,6 +255,7 @@ provide! { tcx, def_id, other, cdata,\n     is_panic_runtime => { cdata.root.panic_runtime }\n     is_compiler_builtins => { cdata.root.compiler_builtins }\n     has_global_allocator => { cdata.root.has_global_allocator }\n+    has_alloc_error_handler => { cdata.root.has_alloc_error_handler }\n     has_panic_handler => { cdata.root.has_panic_handler }\n     is_profiler_runtime => { cdata.root.profiler_runtime }\n     required_panic_strategy => { cdata.root.required_panic_strategy }\n@@ -339,6 +340,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n     // resolve! Does this work? Unsure! That's what the issue is about\n     *providers = Providers {\n         allocator_kind: |tcx, ()| CStore::from_tcx(tcx).allocator_kind(),\n+        alloc_error_handler_kind: |tcx, ()| CStore::from_tcx(tcx).alloc_error_handler_kind(),\n         is_private_dep: |_tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n             false\n@@ -464,6 +466,10 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n             assert_eq!(cnum, LOCAL_CRATE);\n             CStore::from_tcx(tcx).has_global_allocator()\n         },\n+        has_alloc_error_handler: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            CStore::from_tcx(tcx).has_alloc_error_handler()\n+        },\n         postorder_cnums: |tcx, ()| {\n             tcx.arena\n                 .alloc_slice(&CStore::from_tcx(tcx).crate_dependencies_in_postorder(LOCAL_CRATE))"}, {"sha": "c907ee6462870dd5beb2bb9b69eb1a32fdf3c668", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -670,6 +670,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 panic_in_drop_strategy: tcx.sess.opts.unstable_opts.panic_in_drop,\n                 edition: tcx.sess.edition(),\n                 has_global_allocator: tcx.has_global_allocator(LOCAL_CRATE),\n+                has_alloc_error_handler: tcx.has_alloc_error_handler(LOCAL_CRATE),\n                 has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n                 has_default_lib_allocator: tcx\n                     .sess"}, {"sha": "aa6d378a43aca95870ed71c2c7f4d3b816a5b88c", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -223,6 +223,7 @@ pub(crate) struct CrateRoot {\n     panic_in_drop_strategy: PanicStrategy,\n     edition: Edition,\n     has_global_allocator: bool,\n+    has_alloc_error_handler: bool,\n     has_panic_handler: bool,\n     has_default_lib_allocator: bool,\n "}, {"sha": "33acaed435b89eeeeb25429b60b9d66a6de92dc4", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -1391,6 +1391,13 @@ rustc_queries! {\n         desc { \"checking if the crate has_global_allocator\" }\n         separate_provide_extern\n     }\n+    query has_alloc_error_handler(_: CrateNum) -> bool {\n+        // This query depends on untracked global state in CStore\n+        eval_always\n+        fatal_cycle\n+        desc { \"checking if the crate has_alloc_error_handler\" }\n+        separate_provide_extern\n+    }\n     query has_panic_handler(_: CrateNum) -> bool {\n         fatal_cycle\n         desc { \"checking if the crate has_panic_handler\" }\n@@ -1761,6 +1768,10 @@ rustc_queries! {\n         eval_always\n         desc { \"getting the allocator kind for the current crate\" }\n     }\n+    query alloc_error_handler_kind(_: ()) -> Option<AllocatorKind> {\n+        eval_always\n+        desc { \"alloc error handler kind for the current crate\" }\n+    }\n \n     query upvars_mentioned(def_id: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n         desc { |tcx| \"collecting upvars mentioned in `{}`\", tcx.def_path_str(def_id) }"}, {"sha": "5c82fb1ddc0d5a49beaf8dbce6635556517e32d4", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -2,6 +2,7 @@\n \n use rustc_index::vec::Idx;\n use rustc_middle::ty::util::IntTypeExt;\n+use rustc_target::abi::{Abi, Primitive};\n \n use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::category::{Category, RvalueFunc};\n@@ -198,15 +199,63 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let (source, ty) = if let ty::Adt(adt_def, ..) = source.ty.kind() && adt_def.is_enum() {\n                     let discr_ty = adt_def.repr().discr_type().to_ty(this.tcx);\n                     let temp = unpack!(block = this.as_temp(block, scope, source, Mutability::Not));\n+                    let layout = this.tcx.layout_of(this.param_env.and(source.ty));\n                     let discr = this.temp(discr_ty, source.span);\n                     this.cfg.push_assign(\n                         block,\n                         source_info,\n                         discr,\n                         Rvalue::Discriminant(temp.into()),\n                     );\n+                    let (op,ty) = (Operand::Move(discr), discr_ty);\n+\n+                    if let Abi::Scalar(scalar) = layout.unwrap().abi{\n+                        if let Primitive::Int(_, signed) = scalar.primitive() {\n+                            let range = scalar.valid_range(&this.tcx);\n+                            // FIXME: Handle wraparound cases too.\n+                            if range.end >= range.start {\n+                                let mut assumer = |range: u128, bin_op: BinOp| {\n+                                    // We will be overwriting this val if our scalar is signed value\n+                                    // because sign extension on unsigned types might cause unintended things\n+                                    let mut range_val =\n+                                        ConstantKind::from_bits(this.tcx, range, ty::ParamEnv::empty().and(discr_ty));\n+                                    let bool_ty = this.tcx.types.bool;\n+                                    if signed {\n+                                        let scalar_size_extend = scalar.size(&this.tcx).sign_extend(range);\n+                                        let discr_layout = this.tcx.layout_of(this.param_env.and(discr_ty));\n+                                        let truncated_val = discr_layout.unwrap().size.truncate(scalar_size_extend);\n+                                        range_val = ConstantKind::from_bits(\n+                                            this.tcx,\n+                                            truncated_val,\n+                                            ty::ParamEnv::empty().and(discr_ty),\n+                                        );\n+                                    }\n+                                    let lit_op = this.literal_operand(expr.span, range_val);\n+                                    let is_bin_op = this.temp(bool_ty, expr_span);\n+                                    this.cfg.push_assign(\n+                                        block,\n+                                        source_info,\n+                                        is_bin_op,\n+                                        Rvalue::BinaryOp(bin_op, Box::new(((lit_op), (Operand::Copy(discr))))),\n+                                    );\n+                                    this.cfg.push(\n+                                        block,\n+                                        Statement {\n+                                            source_info,\n+                                            kind: StatementKind::Intrinsic(Box::new(NonDivergingIntrinsic::Assume(\n+                                                Operand::Copy(is_bin_op),\n+                                            ))),\n+                                        },\n+                                    )\n+                                };\n+                                assumer(range.end, BinOp::Ge);\n+                                assumer(range.start, BinOp::Le);\n+                            }\n+                        }\n+                    }\n+\n+                    (op,ty)\n \n-                    (Operand::Move(discr), discr_ty)\n                 } else {\n                     let ty = source.ty;\n                     let source = unpack!("}, {"sha": "959fcf8d89e86bf3dfcfbd6c06784f3462eda65f", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -101,12 +101,10 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n             | StatementKind::Retag { .. }\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n+            | StatementKind::Intrinsic(..)\n             | StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)\n             }\n-\n-            // Move to above list once mir construction uses it.\n-            StatementKind::Intrinsic(..) => unreachable!(),\n         }\n         self.super_statement(statement, location);\n     }"}, {"sha": "b779edbc30f754e091c0d690c134a30a5ac62877", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -470,11 +470,6 @@ fn has_allow_dead_code_or_lang_attr_helper(\n         return true;\n     }\n \n-    // (To be) stable attribute for #[lang = \"oom\"]\n-    if tcx.sess.contains_name(attrs, sym::alloc_error_handler) {\n-        return true;\n-    }\n-\n     let def_id = tcx.hir().local_def_id(id);\n     if tcx.def_kind(def_id).has_codegen_attrs() {\n         let cg_attrs = tcx.codegen_fn_attrs(def_id);"}, {"sha": "4a5cfd2d429cd67f1f435b770595595a5239e664", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -701,14 +701,6 @@ pub struct UnknownExternLangItem {\n #[diag(passes_missing_panic_handler)]\n pub struct MissingPanicHandler;\n \n-#[derive(Diagnostic)]\n-#[diag(passes_alloc_func_required)]\n-pub struct AllocFuncRequired;\n-\n-#[derive(Diagnostic)]\n-#[diag(passes_missing_alloc_error_handler)]\n-pub struct MissingAllocErrorHandler;\n-\n #[derive(Diagnostic)]\n #[diag(passes_missing_lang_item)]\n #[note]"}, {"sha": "f0815fcd8db9a6de59b633dcdb12368d05e6bd1d", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -7,10 +7,7 @@ use rustc_middle::middle::lang_items::required;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n \n-use crate::errors::{\n-    AllocFuncRequired, MissingAllocErrorHandler, MissingLangItem, MissingPanicHandler,\n-    UnknownExternLangItem,\n-};\n+use crate::errors::{MissingLangItem, MissingPanicHandler, UnknownExternLangItem};\n \n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n@@ -69,11 +66,6 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n         if missing.contains(&item) && required(tcx, item) && items.get(item).is_none() {\n             if item == LangItem::PanicImpl {\n                 tcx.sess.emit_err(MissingPanicHandler);\n-            } else if item == LangItem::Oom {\n-                if !tcx.features().default_alloc_error_handler {\n-                    tcx.sess.emit_err(AllocFuncRequired);\n-                    tcx.sess.emit_note(MissingAllocErrorHandler);\n-                }\n             } else {\n                 tcx.sess.emit_err(MissingLangItem { name: item.name() });\n             }"}, {"sha": "6d2ee25df320dd0898115e07c70b9cdb7c73a8fd", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -32,7 +32,7 @@ use smallvec::{smallvec, SmallVec};\n use rustc_span::source_map::{respan, Spanned};\n use std::assert_matches::debug_assert_matches;\n use std::collections::{hash_map::Entry, BTreeSet};\n-use std::mem::{replace, take};\n+use std::mem::{replace, swap, take};\n \n mod diagnostics;\n \n@@ -3369,11 +3369,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             let (mut err, candidates) =\n                 this.smart_resolve_report_errors(path, path_span, PathSource::Type, None);\n \n-            if candidates.is_empty() {\n-                err.cancel();\n-                return Some(parent_err);\n-            }\n-\n             // There are two different error messages user might receive at\n             // this point:\n             // - E0412 cannot find type `{}` in this scope\n@@ -3383,37 +3378,62 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // latter one - for paths in expression-position.\n             //\n             // Thus (since we're in expression-position at this point), not to\n-            // confuse the user, we want to keep the *message* from E0432 (so\n+            // confuse the user, we want to keep the *message* from E0433 (so\n             // `parent_err`), but we want *hints* from E0412 (so `err`).\n             //\n             // And that's what happens below - we're just mixing both messages\n             // into a single one.\n             let mut parent_err = this.r.into_struct_error(parent_err.span, parent_err.node);\n \n+            // overwrite all properties with the parent's error message\n             err.message = take(&mut parent_err.message);\n             err.code = take(&mut parent_err.code);\n+            swap(&mut err.span, &mut parent_err.span);\n             err.children = take(&mut parent_err.children);\n+            err.sort_span = parent_err.sort_span;\n+            err.is_lint = parent_err.is_lint;\n+\n+            // merge the parent's suggestions with the typo suggestions\n+            fn append_result<T, E>(res1: &mut Result<Vec<T>, E>, res2: Result<Vec<T>, E>) {\n+                match res1 {\n+                    Ok(vec1) => match res2 {\n+                        Ok(mut vec2) => vec1.append(&mut vec2),\n+                        Err(e) => *res1 = Err(e),\n+                    },\n+                    Err(_) => (),\n+                };\n+            }\n+            append_result(&mut err.suggestions, parent_err.suggestions.clone());\n \n             parent_err.cancel();\n \n             let def_id = this.parent_scope.module.nearest_parent_mod();\n \n             if this.should_report_errs() {\n-                this.r.use_injections.push(UseError {\n-                    err,\n-                    candidates,\n-                    def_id,\n-                    instead: false,\n-                    suggestion: None,\n-                    path: path.into(),\n-                    is_call: source.is_call(),\n-                });\n+                if candidates.is_empty() {\n+                    // When there is no suggested imports, we can just emit the error\n+                    // and suggestions immediately. Note that we bypass the usually error\n+                    // reporting routine (ie via `self.r.report_error`) because we need\n+                    // to post-process the `ResolutionError` above.\n+                    err.emit();\n+                } else {\n+                    // If there are suggested imports, the error reporting is delayed\n+                    this.r.use_injections.push(UseError {\n+                        err,\n+                        candidates,\n+                        def_id,\n+                        instead: false,\n+                        suggestion: None,\n+                        path: path.into(),\n+                        is_call: source.is_call(),\n+                    });\n+                }\n             } else {\n                 err.cancel();\n             }\n \n             // We don't return `Some(parent_err)` here, because the error will\n-            // be already printed as part of the `use` injections\n+            // be already printed either immediately or as part of the `use` injections\n             None\n         };\n "}, {"sha": "8c6663569a553e87f226bbd7a1e1c361acbebfd6", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -402,19 +402,18 @@ pub use std::alloc::handle_alloc_error;\n #[allow(unused_attributes)]\n #[unstable(feature = \"alloc_internals\", issue = \"none\")]\n pub mod __alloc_error_handler {\n-    use crate::alloc::Layout;\n-\n-    // called via generated `__rust_alloc_error_handler`\n-\n-    // if there is no `#[alloc_error_handler]`\n+    // called via generated `__rust_alloc_error_handler` if there is no\n+    // `#[alloc_error_handler]`.\n     #[rustc_std_internal_symbol]\n     pub unsafe fn __rdl_oom(size: usize, _align: usize) -> ! {\n         panic!(\"memory allocation of {size} bytes failed\")\n     }\n \n-    // if there is an `#[alloc_error_handler]`\n+    #[cfg(bootstrap)]\n     #[rustc_std_internal_symbol]\n     pub unsafe fn __rg_oom(size: usize, align: usize) -> ! {\n+        use crate::alloc::Layout;\n+\n         let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n         extern \"Rust\" {\n             #[lang = \"oom\"]"}, {"sha": "2850d84acc3274b09f9169dc6c1b377ddd516730", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -1511,6 +1511,17 @@ pub(crate) mod builtin {\n         /* compiler built-in */\n     }\n \n+    /// Attribute macro applied to a function to register it as a handler for allocation failure.\n+    ///\n+    /// See also [`std::alloc::handle_alloc_error`](../../../std/alloc/fn.handle_alloc_error.html).\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"alloc_error_handler\", issue = \"51540\")]\n+    #[allow_internal_unstable(rustc_attrs)]\n+    #[rustc_builtin_macro]\n+    pub macro alloc_error_handler($item:item) {\n+        /* compiler built-in */\n+    }\n+\n     /// Keeps the item it's applied to if the passed path is accessible, and removes it otherwise.\n     #[unstable(\n         feature = \"cfg_accessible\","}, {"sha": "804a179bdb3c04a835e47c97db8896da119f73bb", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -75,6 +75,9 @@ pub use crate::macros::builtin::{RustcDecodable, RustcEncodable};\n \n // Do not `doc(no_inline)` so that they become doc items on their own\n // (no public module for them to be re-exported from).\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+pub use crate::macros::builtin::alloc_error_handler;\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n pub use crate::macros::builtin::{bench, derive, global_allocator, test, test_case};\n "}, {"sha": "eda176d9fcbe61c307de586eb8ca416b39af0d3d", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -5,6 +5,7 @@\n #![feature(bigint_helper_methods)]\n #![feature(cell_update)]\n #![feature(const_assume)]\n+#![feature(const_align_of_val_raw)]\n #![feature(const_black_box)]\n #![feature(const_bool_to_option)]\n #![feature(const_caller_location)]\n@@ -42,6 +43,7 @@\n #![feature(try_find)]\n #![feature(inline_const)]\n #![feature(is_sorted)]\n+#![feature(layout_for_ptr)]\n #![feature(pattern)]\n #![feature(pin_macro)]\n #![feature(sort_internals)]"}, {"sha": "1cfb4fd9fd186e55cc84c3b641bdf37e10858d6e", "filename": "library/core/tests/mem.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fmem.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -1,4 +1,5 @@\n use core::mem::*;\n+use core::ptr;\n \n #[cfg(panic = \"unwind\")]\n use std::rc::Rc;\n@@ -75,6 +76,25 @@ fn align_of_val_basic() {\n     assert_eq!(align_of_val(&1u32), 4);\n }\n \n+#[test]\n+#[cfg(not(bootstrap))] // stage 0 doesn't have the fix yet, so the test fails\n+fn align_of_val_raw_packed() {\n+    #[repr(C, packed)]\n+    struct B {\n+        f: [u32],\n+    }\n+    let storage = [0u8; 4];\n+    let b: *const B = ptr::from_raw_parts(storage.as_ptr().cast(), 1);\n+    assert_eq!(unsafe { align_of_val_raw(b) }, 1);\n+\n+    const ALIGN_OF_VAL_RAW: usize = {\n+        let storage = [0u8; 4];\n+        let b: *const B = ptr::from_raw_parts(storage.as_ptr().cast(), 1);\n+        unsafe { align_of_val_raw(b) }\n+    };\n+    assert_eq!(ALIGN_OF_VAL_RAW, 1);\n+}\n+\n #[test]\n fn test_swap() {\n     let mut x = 31337;"}, {"sha": "19d90e7ec38398728170f005d86da0558e4aac04", "filename": "library/std/src/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -11,7 +11,7 @@\n //!   [`Ipv6Addr`] are respectively IPv4 and IPv6 addresses\n //! * [`SocketAddr`] represents socket addresses of either IPv4 or IPv6; [`SocketAddrV4`]\n //!   and [`SocketAddrV6`] are respectively IPv4 and IPv6 socket addresses\n-//! * [`ToSocketAddrs`] is a trait that used for generic address resolution when interacting\n+//! * [`ToSocketAddrs`] is a trait that is used for generic address resolution when interacting\n //!   with networking objects like [`TcpListener`], [`TcpStream`] or [`UdpSocket`]\n //! * Other types are return or parameter types for various methods in this module\n //!"}, {"sha": "36d9e8921ef31f110eaf284b7747aadd1044e44a", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -59,6 +59,9 @@ pub use core::prelude::v1::{RustcDecodable, RustcEncodable};\n \n // Do not `doc(no_inline)` so that they become doc items on their own\n // (no public module for them to be re-exported from).\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+pub use core::prelude::v1::alloc_error_handler;\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n pub use core::prelude::v1::{bench, derive, global_allocator, test, test_case};\n "}, {"sha": "aa66c2ed08edb777fc24e53c76b870c99b93026d", "filename": "src/test/codegen/enum-bounds-check-derived-idx.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -12,15 +12,13 @@ pub enum Bar {\n // CHECK-LABEL: @lookup_inc\n #[no_mangle]\n pub fn lookup_inc(buf: &[u8; 5], f: Bar) -> u8 {\n-    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n-    // CHECK: panic_bounds_check\n+    // CHECK-NOT: panic_bounds_check\n     buf[f as usize + 1]\n }\n \n // CHECK-LABEL: @lookup_dec\n #[no_mangle]\n pub fn lookup_dec(buf: &[u8; 5], f: Bar) -> u8 {\n-    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n-    // CHECK: panic_bounds_check\n+    // CHECK-NOT: panic_bounds_check\n     buf[f as usize - 1]\n }"}, {"sha": "b26945bc54940642ee5fc04aa5600bd13a8f87b4", "filename": "src/test/codegen/enum-bounds-check-issue-13926.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -13,7 +13,6 @@ pub enum Exception {\n // CHECK-LABEL: @access\n #[no_mangle]\n pub fn access(array: &[usize; 12], exc: Exception) -> usize {\n-    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n-    // CHECK: panic_bounds_check\n+    // CHECK-NOT: panic_bounds_check\n     array[(exc as u8 - 4) as usize]\n }"}, {"sha": "17322d5911b9228ab1e66f35e4800d16f5b48613", "filename": "src/test/codegen/enum-bounds-check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -21,7 +21,6 @@ pub enum Bar {\n // CHECK-LABEL: @lookup_unmodified\n #[no_mangle]\n pub fn lookup_unmodified(buf: &[u8; 5], f: Bar) -> u8 {\n-    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n-    // CHECK: panic_bounds_check\n+    // CHECK-NOT: panic_bounds_check\n     buf[f as usize]\n }"}, {"sha": "0746e0b498e9543263639416c06d2dbf3c4c1f50", "filename": "src/test/mir-opt/building/enum_cast.bar.built.after.mir", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fmir-opt%2Fbuilding%2Fenum_cast.bar.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fmir-opt%2Fbuilding%2Fenum_cast.bar.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fenum_cast.bar.built.after.mir?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -5,11 +5,17 @@ fn bar(_1: Bar) -> usize {\n     let mut _0: usize;                   // return place in scope 0 at $DIR/enum_cast.rs:+0:21: +0:26\n     let _2: Bar;                         // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n     let mut _3: isize;                   // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n+    let mut _4: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+    let mut _5: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n \n     bb0: {\n         StorageLive(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n         _2 = move _1;                    // scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n         _3 = discriminant(_2);           // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        _4 = Ge(const 1_isize, _3);      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        assume(_4);                      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        _5 = Le(const 0_isize, _3);      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        assume(_5);                      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n         _0 = move _3 as usize (IntToInt); // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n         StorageDead(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:16: +1:17\n         return;                          // scope 0 at $DIR/enum_cast.rs:+2:2: +2:2"}, {"sha": "699c876b01ac833c39455f3f367cd1dd1d997bfd", "filename": "src/test/mir-opt/building/enum_cast.boo.built.after.mir", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fmir-opt%2Fbuilding%2Fenum_cast.boo.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fmir-opt%2Fbuilding%2Fenum_cast.boo.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fenum_cast.boo.built.after.mir?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -5,11 +5,17 @@ fn boo(_1: Boo) -> usize {\n     let mut _0: usize;                   // return place in scope 0 at $DIR/enum_cast.rs:+0:21: +0:26\n     let _2: Boo;                         // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n     let mut _3: u8;                      // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n+    let mut _4: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+    let mut _5: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n \n     bb0: {\n         StorageLive(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n         _2 = move _1;                    // scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n         _3 = discriminant(_2);           // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        _4 = Ge(const 1_u8, _3);         // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        assume(_4);                      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        _5 = Le(const 0_u8, _3);         // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        assume(_5);                      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n         _0 = move _3 as usize (IntToInt); // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n         StorageDead(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:16: +1:17\n         return;                          // scope 0 at $DIR/enum_cast.rs:+2:2: +2:2"}, {"sha": "5231c2eab9574b9072da16bd250c1f75e2ed9ac4", "filename": "src/test/mir-opt/building/enum_cast.droppy.built.after.mir", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fmir-opt%2Fbuilding%2Fenum_cast.droppy.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fmir-opt%2Fbuilding%2Fenum_cast.droppy.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fenum_cast.droppy.built.after.mir?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -6,7 +6,9 @@ fn droppy() -> () {\n     let _2: Droppy;                      // in scope 0 at $DIR/enum_cast.rs:+2:13: +2:14\n     let _4: Droppy;                      // in scope 0 at $DIR/enum_cast.rs:+5:17: +5:18\n     let mut _5: isize;                   // in scope 0 at $DIR/enum_cast.rs:+5:17: +5:18\n-    let _6: Droppy;                      // in scope 0 at $DIR/enum_cast.rs:+7:9: +7:10\n+    let mut _6: bool;                    // in scope 0 at $DIR/enum_cast.rs:+5:17: +5:27\n+    let mut _7: bool;                    // in scope 0 at $DIR/enum_cast.rs:+5:17: +5:27\n+    let _8: Droppy;                      // in scope 0 at $DIR/enum_cast.rs:+7:9: +7:10\n     scope 1 {\n         debug x => _2;                   // in scope 1 at $DIR/enum_cast.rs:+2:13: +2:14\n         scope 2 {\n@@ -17,7 +19,7 @@ fn droppy() -> () {\n         }\n     }\n     scope 4 {\n-        debug z => _6;                   // in scope 4 at $DIR/enum_cast.rs:+7:9: +7:10\n+        debug z => _8;                   // in scope 4 at $DIR/enum_cast.rs:+7:9: +7:10\n     }\n \n     bb0: {\n@@ -29,6 +31,10 @@ fn droppy() -> () {\n         StorageLive(_4);                 // scope 3 at $DIR/enum_cast.rs:+5:17: +5:18\n         _4 = move _2;                    // scope 3 at $DIR/enum_cast.rs:+5:17: +5:18\n         _5 = discriminant(_4);           // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n+        _6 = Ge(const 2_isize, _5);      // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n+        assume(_6);                      // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n+        _7 = Le(const 0_isize, _5);      // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n+        assume(_7);                      // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n         _3 = move _5 as usize (IntToInt); // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n         drop(_4) -> [return: bb1, unwind: bb4]; // scope 3 at $DIR/enum_cast.rs:+5:26: +5:27\n     }\n@@ -44,15 +50,15 @@ fn droppy() -> () {\n     bb2: {\n         StorageDead(_2);                 // scope 0 at $DIR/enum_cast.rs:+6:5: +6:6\n         StorageDead(_1);                 // scope 0 at $DIR/enum_cast.rs:+6:5: +6:6\n-        StorageLive(_6);                 // scope 0 at $DIR/enum_cast.rs:+7:9: +7:10\n-        _6 = Droppy::B;                  // scope 0 at $DIR/enum_cast.rs:+7:13: +7:22\n-        FakeRead(ForLet(None), _6);      // scope 0 at $DIR/enum_cast.rs:+7:9: +7:10\n+        StorageLive(_8);                 // scope 0 at $DIR/enum_cast.rs:+7:9: +7:10\n+        _8 = Droppy::B;                  // scope 0 at $DIR/enum_cast.rs:+7:13: +7:22\n+        FakeRead(ForLet(None), _8);      // scope 0 at $DIR/enum_cast.rs:+7:9: +7:10\n         _0 = const ();                   // scope 0 at $DIR/enum_cast.rs:+0:13: +8:2\n-        drop(_6) -> [return: bb3, unwind: bb5]; // scope 0 at $DIR/enum_cast.rs:+8:1: +8:2\n+        drop(_8) -> [return: bb3, unwind: bb5]; // scope 0 at $DIR/enum_cast.rs:+8:1: +8:2\n     }\n \n     bb3: {\n-        StorageDead(_6);                 // scope 0 at $DIR/enum_cast.rs:+8:1: +8:2\n+        StorageDead(_8);                 // scope 0 at $DIR/enum_cast.rs:+8:1: +8:2\n         return;                          // scope 0 at $DIR/enum_cast.rs:+8:2: +8:2\n     }\n "}, {"sha": "c93645369928c4dce0ac7dd2399b456687a54f3b", "filename": "src/test/run-make-fulldeps/issue-51671/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Frun-make-fulldeps%2Fissue-51671%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Frun-make-fulldeps%2Fissue-51671%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-51671%2FMakefile?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -6,4 +6,4 @@ all:\n \t$(RUSTC) --emit=obj app.rs\n \tnm $(TMPDIR)/app.o | $(CGREP) rust_begin_unwind\n \tnm $(TMPDIR)/app.o | $(CGREP) rust_eh_personality\n-\tnm $(TMPDIR)/app.o | $(CGREP) rust_oom\n+\tnm $(TMPDIR)/app.o | $(CGREP) __rg_oom"}, {"sha": "e9dc1e9744fb143a2c406f72de9425a33fde97b8", "filename": "src/test/run-make-fulldeps/issue-51671/app.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Frun-make-fulldeps%2Fissue-51671%2Fapp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Frun-make-fulldeps%2Fissue-51671%2Fapp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-51671%2Fapp.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -1,5 +1,5 @@\n #![crate_type = \"bin\"]\n-#![feature(lang_items)]\n+#![feature(lang_items, alloc_error_handler)]\n #![no_main]\n #![no_std]\n \n@@ -14,7 +14,7 @@ fn panic(_: &PanicInfo) -> ! {\n #[lang = \"eh_personality\"]\n fn eh() {}\n \n-#[lang = \"oom\"]\n+#[alloc_error_handler]\n fn oom(_: Layout) -> ! {\n     loop {}\n }"}, {"sha": "cd06423e3a557279ebb5fe61522922fdf3a0f126", "filename": "src/test/ui/alloc-error/alloc-error-handler-bad-signature-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -8,8 +8,8 @@ use core::alloc::Layout;\n \n #[alloc_error_handler]\n fn oom(\n-    info: &Layout, //~ ERROR argument should be `Layout`\n-) -> () //~ ERROR return type should be `!`\n+    info: &Layout, //~^ ERROR mismatched types\n+) -> () //~^^ ERROR mismatched types\n {\n     loop {}\n }"}, {"sha": "d0911fa3985d0aee007ecbb1e5f226b628749ae9", "filename": "src/test/ui/alloc-error/alloc-error-handler-bad-signature-1.stderr", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -1,14 +1,50 @@\n-error: return type should be `!`\n-  --> $DIR/alloc-error-handler-bad-signature-1.rs:12:6\n+error[E0308]: mismatched types\n+  --> $DIR/alloc-error-handler-bad-signature-1.rs:10:1\n    |\n-LL | ) -> ()\n-   |      ^^\n-\n-error: argument should be `Layout`\n-  --> $DIR/alloc-error-handler-bad-signature-1.rs:11:11\n+LL |    #[alloc_error_handler]\n+   |    ---------------------- in this procedural macro expansion\n+LL |    fn oom(\n+   |   _^\n+   |  |_|\n+   | ||\n+LL | ||     info: &Layout,\n+LL | || ) -> ()\n+   | ||_______- arguments to this function are incorrect\n+LL | |  {\n+LL | |      loop {}\n+LL | |  }\n+   | |__^ expected `&Layout`, found struct `Layout`\n+   |\n+note: function defined here\n+  --> $DIR/alloc-error-handler-bad-signature-1.rs:10:4\n    |\n+LL | fn oom(\n+   |    ^^^\n LL |     info: &Layout,\n-   |           ^^^^^^^\n+   |     -------------\n+   = note: this error originates in the attribute macro `alloc_error_handler` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0308]: mismatched types\n+  --> $DIR/alloc-error-handler-bad-signature-1.rs:10:1\n+   |\n+LL |    #[alloc_error_handler]\n+   |    ---------------------- in this procedural macro expansion\n+LL |    fn oom(\n+   |   _^\n+   |  |_|\n+   | ||\n+LL | ||     info: &Layout,\n+LL | || ) -> ()\n+   | ||_______^ expected `!`, found `()`\n+LL | |  {\n+LL | |      loop {}\n+LL | |  }\n+   | |__- expected `!` because of return type\n+   |\n+   = note:   expected type `!`\n+           found unit type `()`\n+   = note: this error originates in the attribute macro `alloc_error_handler` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "4f76257fc726769df8d21c61816611337c032be8", "filename": "src/test/ui/alloc-error/alloc-error-handler-bad-signature-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -8,8 +8,8 @@ struct Layout;\n \n #[alloc_error_handler]\n fn oom(\n-    info: Layout, //~ ERROR argument should be `Layout`\n-) { //~ ERROR return type should be `!`\n+    info: Layout, //~^ ERROR mismatched types\n+) { //~^^ ERROR mismatched types\n     loop {}\n }\n "}, {"sha": "5777279855d9768b9d05555b3405d00b6a1d2fd8", "filename": "src/test/ui/alloc-error/alloc-error-handler-bad-signature-2.stderr", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -1,14 +1,63 @@\n-error: return type should be `!`\n-  --> $DIR/alloc-error-handler-bad-signature-2.rs:12:3\n+error[E0308]: mismatched types\n+  --> $DIR/alloc-error-handler-bad-signature-2.rs:10:1\n    |\n-LL | ) {\n-   |   ^\n-\n-error: argument should be `Layout`\n-  --> $DIR/alloc-error-handler-bad-signature-2.rs:11:11\n+LL |    #[alloc_error_handler]\n+   |    ---------------------- in this procedural macro expansion\n+LL |    fn oom(\n+   |   _^\n+   |  |_|\n+   | ||\n+LL | ||     info: Layout,\n+LL | || ) {\n+   | || -\n+   | ||_|\n+   | |  arguments to this function are incorrect\n+LL | |      loop {}\n+LL | |  }\n+   | |__^ expected struct `Layout`, found struct `core::alloc::Layout`\n+   |\n+   = note: struct `core::alloc::Layout` and struct `Layout` have similar names, but are actually distinct types\n+note: struct `core::alloc::Layout` is defined in crate `core`\n+  --> $SRC_DIR/core/src/alloc/layout.rs:LL:COL\n+   |\n+LL | pub struct Layout {\n+   | ^^^^^^^^^^^^^^^^^\n+note: struct `Layout` is defined in the current crate\n+  --> $DIR/alloc-error-handler-bad-signature-2.rs:7:1\n+   |\n+LL | struct Layout;\n+   | ^^^^^^^^^^^^^\n+note: function defined here\n+  --> $DIR/alloc-error-handler-bad-signature-2.rs:10:4\n    |\n+LL | fn oom(\n+   |    ^^^\n LL |     info: Layout,\n-   |           ^^^^^^\n+   |     ------------\n+   = note: this error originates in the attribute macro `alloc_error_handler` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0308]: mismatched types\n+  --> $DIR/alloc-error-handler-bad-signature-2.rs:10:1\n+   |\n+LL |    #[alloc_error_handler]\n+   |    ---------------------- in this procedural macro expansion\n+LL |    fn oom(\n+   |   _^\n+   |  |_|\n+   | ||\n+LL | ||     info: Layout,\n+LL | || ) {\n+   | || ^\n+   | ||_|\n+   | |  expected `!`, found `()`\n+LL | |      loop {}\n+LL | |  }\n+   | |__- expected `!` because of return type\n+   |\n+   = note:   expected type `!`\n+           found unit type `()`\n+   = note: this error originates in the attribute macro `alloc_error_handler` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "8430fabe84d0962dbeb17ca26afaa414b764100e", "filename": "src/test/ui/alloc-error/alloc-error-handler-bad-signature-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -7,7 +7,7 @@\n struct Layout;\n \n #[alloc_error_handler]\n-fn oom() -> ! { //~ ERROR function should have one argument\n+fn oom() -> ! { //~ ERROR this function takes 0 arguments but 1 argument was supplied\n     loop {}\n }\n "}, {"sha": "77ea8ef052091605c5d3e9cfe9ee853d8331617b", "filename": "src/test/ui/alloc-error/alloc-error-handler-bad-signature-3.stderr", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-3.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -1,8 +1,25 @@\n-error: function should have one argument\n+error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/alloc-error-handler-bad-signature-3.rs:10:1\n    |\n+LL |   #[alloc_error_handler]\n+   |   ---------------------- in this procedural macro expansion\n+LL |   fn oom() -> ! {\n+   |  _-^^^^^^^^^^^^\n+LL | |     loop {}\n+LL | | }\n+   | |_- argument of type `core::alloc::Layout` unexpected\n+   |\n+note: function defined here\n+  --> $DIR/alloc-error-handler-bad-signature-3.rs:10:4\n+   |\n LL | fn oom() -> ! {\n-   | ^^^^^^^^^^^^^\n+   |    ^^^\n+   = note: this error originates in the attribute macro `alloc_error_handler` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: remove the extra argument\n+   |\n+LL | fn oom() -> !() {\n+   |              ++\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0061`."}, {"sha": "d2320293e857ee296fc049686501afa675e0d0b7", "filename": "src/test/ui/const-generics/issues/issue-82956.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-82956.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-82956.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-82956.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -2,7 +2,7 @@ error[E0433]: failed to resolve: use of undeclared type `IntoIter`\n   --> $DIR/issue-82956.rs:25:24\n    |\n LL |         let mut iter = IntoIter::new(self);\n-   |                        ^^^^^^^^ not found in this scope\n+   |                        ^^^^^^^^ use of undeclared type `IntoIter`\n    |\n help: consider importing one of these items\n    |"}, {"sha": "2f4aabf845311168ad1a3bea2e1735e6bf5d6cd7", "filename": "src/test/ui/derived-errors/issue-31997-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -2,7 +2,7 @@ error[E0433]: failed to resolve: use of undeclared type `HashMap`\n   --> $DIR/issue-31997-1.rs:20:19\n    |\n LL |     let mut map = HashMap::new();\n-   |                   ^^^^^^^ not found in this scope\n+   |                   ^^^^^^^ use of undeclared type `HashMap`\n    |\n help: consider importing this struct\n    |"}, {"sha": "d4b21f6893b43295b023ff2de1dab074617f02e0", "filename": "src/test/ui/error-codes/E0081.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -32,7 +32,7 @@ LL |     First = -1,\n    |             -- `-1` assigned here\n LL |\n LL |     Second = -2,\n-   |     ----------- discriminant for `Last` incremented from this startpoint (`Second` + 1 variant later => `Last` = -1)\n+   |     ------ discriminant for `Last` incremented from this startpoint (`Second` + 1 variant later => `Last` = -1)\n LL |\n LL |     Last,\n    |     ---- `-1` assigned here\n@@ -53,7 +53,7 @@ LL |     V4 = 0,\n    |          - `0` assigned here\n LL |\n LL |     V5 = -2,\n-   |     ------- discriminant for `V7` incremented from this startpoint (`V5` + 2 variants later => `V7` = 0)\n+   |     -- discriminant for `V7` incremented from this startpoint (`V5` + 2 variants later => `V7` = 0)\n ...\n LL |     V7,\n    |     -- `0` assigned here\n@@ -68,7 +68,7 @@ LL |     V5 = -2,\n    |          -- `-2` assigned here\n ...\n LL |     V8 = -3,\n-   |     ------- discriminant for `V9` incremented from this startpoint (`V8` + 1 variant later => `V9` = -2)\n+   |     -- discriminant for `V9` incremented from this startpoint (`V8` + 1 variant later => `V9` = -2)\n LL |\n LL |     V9,\n    |     -- `-2` assigned here"}, {"sha": "78d189d20b64d4d9393595cf46190a976404fa9d", "filename": "src/test/ui/feature-gates/feature-gate-alloc-error-handler.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -5,10 +5,12 @@\n \n use core::alloc::Layout;\n \n-#[alloc_error_handler] //~ ERROR the `#[alloc_error_handler]` attribute is an experimental feature\n+#[alloc_error_handler] //~ ERROR use of unstable library feature 'alloc_error_handler'\n fn oom(info: Layout) -> ! {\n     loop {}\n }\n \n #[panic_handler]\n-fn panic(_: &core::panic::PanicInfo) -> ! { loop {} }\n+fn panic(_: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}"}, {"sha": "f414eb463dfbcc1f5747aaa70f060a3453dc92c4", "filename": "src/test/ui/feature-gates/feature-gate-alloc-error-handler.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -1,8 +1,8 @@\n-error[E0658]: the `#[alloc_error_handler]` attribute is an experimental feature\n-  --> $DIR/feature-gate-alloc-error-handler.rs:8:1\n+error[E0658]: use of unstable library feature 'alloc_error_handler'\n+  --> $DIR/feature-gate-alloc-error-handler.rs:8:3\n    |\n LL | #[alloc_error_handler]\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #51540 <https://github.com/rust-lang/rust/issues/51540> for more information\n    = help: add `#![feature(alloc_error_handler)]` to the crate attributes to enable"}, {"sha": "c48c840352fa09c72d907b6fd1dbc969a87354cd", "filename": "src/test/ui/hygiene/no_implicit_prelude.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -5,7 +5,7 @@ LL |     fn f() { ::bar::m!(); }\n    |              ----------- in this macro invocation\n ...\n LL |         Vec::new();\n-   |         ^^^ not found in this scope\n+   |         ^^^ use of undeclared type `Vec`\n    |\n    = note: this error originates in the macro `::bar::m` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider importing this struct"}, {"sha": "ab467041144604264932ab5e62875d9e6a4e5168", "filename": "src/test/ui/proc-macro/amputate-span.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fproc-macro%2Famputate-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fproc-macro%2Famputate-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Famputate-span.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -2,7 +2,7 @@ error[E0433]: failed to resolve: use of undeclared type `Command`\n   --> $DIR/amputate-span.rs:49:5\n    |\n LL |     Command::new(\"git\");\n-   |     ^^^^^^^ not found in this scope\n+   |     ^^^^^^^ use of undeclared type `Command`\n    |\n help: consider importing this struct\n    |\n@@ -13,7 +13,7 @@ error[E0433]: failed to resolve: use of undeclared type `Command`\n   --> $DIR/amputate-span.rs:63:9\n    |\n LL |         Command::new(\"git\");\n-   |         ^^^^^^^ not found in this scope\n+   |         ^^^^^^^ use of undeclared type `Command`\n    |\n help: consider importing this struct\n    |"}, {"sha": "fc925ba3b6a8f2fb1a3110308a59df96d016427b", "filename": "src/test/ui/resolve/missing-in-namespace.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fresolve%2Fmissing-in-namespace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fresolve%2Fmissing-in-namespace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fmissing-in-namespace.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -1,8 +1,8 @@\n error[E0433]: failed to resolve: could not find `hahmap` in `std`\n-  --> $DIR/missing-in-namespace.rs:2:29\n+  --> $DIR/missing-in-namespace.rs:2:21\n    |\n LL |     let _map = std::hahmap::HashMap::new();\n-   |                             ^^^^^^^ not found in `std::hahmap`\n+   |                     ^^^^^^ could not find `hahmap` in `std`\n    |\n help: consider importing this struct\n    |"}, {"sha": "3ce17a14f146b8a2b42933a1f3278cfe215dec2e", "filename": "src/test/ui/resolve/typo-suggestion-mistyped-in-path.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fresolve%2Ftypo-suggestion-mistyped-in-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fresolve%2Ftypo-suggestion-mistyped-in-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftypo-suggestion-mistyped-in-path.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -0,0 +1,42 @@\n+struct Struct;\n+//~^ NOTE function or associated item `fob` not found for this struct\n+\n+impl Struct {\n+    fn foo() { }\n+}\n+\n+mod module {\n+    fn foo() { }\n+\n+    struct Struct;\n+\n+    impl Struct {\n+        fn foo() { }\n+    }\n+}\n+\n+trait Trait {\n+    fn foo();\n+}\n+\n+fn main() {\n+    Struct::fob();\n+    //~^ ERROR no function or associated item named `fob` found for struct `Struct` in the current scope\n+    //~| NOTE function or associated item not found in `Struct`\n+\n+    Struc::foo();\n+    //~^ ERROR failed to resolve: use of undeclared type `Struc`\n+    //~| NOTE use of undeclared type `Struc`\n+\n+    modul::foo();\n+    //~^ ERROR failed to resolve: use of undeclared crate or module `modul`\n+    //~| NOTE use of undeclared crate or module `modul`\n+\n+    module::Struc::foo();\n+    //~^ ERROR failed to resolve: could not find `Struc` in `module`\n+    //~| NOTE could not find `Struc` in `module`\n+\n+    Trai::foo();\n+    //~^ ERROR failed to resolve: use of undeclared type `Trai`\n+    //~| NOTE use of undeclared type `Trai`\n+}"}, {"sha": "ff7cf531c06dd9bbedf494cb9b1786c0c00348ea", "filename": "src/test/ui/resolve/typo-suggestion-mistyped-in-path.stderr", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fresolve%2Ftypo-suggestion-mistyped-in-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fresolve%2Ftypo-suggestion-mistyped-in-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftypo-suggestion-mistyped-in-path.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -0,0 +1,54 @@\n+error[E0433]: failed to resolve: use of undeclared type `Struc`\n+  --> $DIR/typo-suggestion-mistyped-in-path.rs:27:5\n+   |\n+LL |     Struc::foo();\n+   |     ^^^^^\n+   |     |\n+   |     use of undeclared type `Struc`\n+   |     help: a struct with a similar name exists: `Struct`\n+\n+error[E0433]: failed to resolve: use of undeclared crate or module `modul`\n+  --> $DIR/typo-suggestion-mistyped-in-path.rs:31:5\n+   |\n+LL |     modul::foo();\n+   |     ^^^^^ use of undeclared crate or module `modul`\n+   |\n+help: there is a crate or module with a similar name\n+   |\n+LL |     module::foo();\n+   |     ~~~~~~\n+\n+error[E0433]: failed to resolve: could not find `Struc` in `module`\n+  --> $DIR/typo-suggestion-mistyped-in-path.rs:35:13\n+   |\n+LL |     module::Struc::foo();\n+   |             ^^^^^\n+   |             |\n+   |             could not find `Struc` in `module`\n+   |             help: a struct with a similar name exists: `Struct`\n+\n+error[E0433]: failed to resolve: use of undeclared type `Trai`\n+  --> $DIR/typo-suggestion-mistyped-in-path.rs:39:5\n+   |\n+LL |     Trai::foo();\n+   |     ^^^^\n+   |     |\n+   |     use of undeclared type `Trai`\n+   |     help: a trait with a similar name exists: `Trait`\n+\n+error[E0599]: no function or associated item named `fob` found for struct `Struct` in the current scope\n+  --> $DIR/typo-suggestion-mistyped-in-path.rs:23:13\n+   |\n+LL | struct Struct;\n+   | ------------- function or associated item `fob` not found for this struct\n+...\n+LL |     Struct::fob();\n+   |             ^^^\n+   |             |\n+   |             function or associated item not found in `Struct`\n+   |             help: there is an associated function with a similar name: `foo`\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0433, E0599.\n+For more information about an error, try `rustc --explain E0433`."}, {"sha": "58cb659e822035b2bf4fcba5f1cea7f74f7de426", "filename": "src/test/ui/resolve/use_suggestion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -8,7 +8,7 @@ error[E0433]: failed to resolve: use of undeclared type `HashMap`\n   --> $DIR/use_suggestion.rs:2:14\n    |\n LL |     let x1 = HashMap::new();\n-   |              ^^^^^^^ not found in this scope\n+   |              ^^^^^^^ use of undeclared type `HashMap`\n    |\n help: consider importing this struct\n    |"}, {"sha": "e4e1fc591c4760d3f6acf2897ee2e6a5c5538d01", "filename": "src/test/ui/suggestions/core-std-import-order-issue-83564.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fsuggestions%2Fcore-std-import-order-issue-83564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fsuggestions%2Fcore-std-import-order-issue-83564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcore-std-import-order-issue-83564.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -2,7 +2,7 @@ error[E0433]: failed to resolve: use of undeclared type `NonZeroU32`\n   --> $DIR/core-std-import-order-issue-83564.rs:8:14\n    |\n LL |     let _x = NonZeroU32::new(5).unwrap();\n-   |              ^^^^^^^^^^ not found in this scope\n+   |              ^^^^^^^^^^ use of undeclared type `NonZeroU32`\n    |\n help: consider importing one of these items\n    |"}, {"sha": "70c4b210d3a7bad6eb8f87c2a54b105947870e55", "filename": "src/test/ui/suggestions/suggest-tryinto-edition-change.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-tryinto-edition-change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-tryinto-edition-change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-tryinto-edition-change.rs?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -10,18 +10,19 @@ fn test() {\n \n     let _i: i16 = TryFrom::try_from(0_i32).unwrap();\n     //~^ ERROR failed to resolve: use of undeclared type\n-    //~| NOTE not found in this scope\n+    //~| NOTE use of undeclared type\n     //~| NOTE 'std::convert::TryFrom' is included in the prelude starting in Edition 2021\n     //~| NOTE 'core::convert::TryFrom' is included in the prelude starting in Edition 2021\n \n     let _i: i16 = TryInto::try_into(0_i32).unwrap();\n     //~^ ERROR failed to resolve: use of undeclared type\n-    //~| NOTE not found in this scope\n+    //~| NOTE use of undeclared type\n     //~| NOTE 'std::convert::TryInto' is included in the prelude starting in Edition 2021\n     //~| NOTE 'core::convert::TryInto' is included in the prelude starting in Edition 2021\n \n     let _v: Vec<_> = FromIterator::from_iter(&[1]);\n     //~^ ERROR failed to resolve: use of undeclared type\n+    //~| NOTE use of undeclared type\n     //~| NOTE 'std::iter::FromIterator' is included in the prelude starting in Edition 2021\n     //~| NOTE 'core::iter::FromIterator' is included in the prelude starting in Edition 2021\n }"}, {"sha": "3d1f2492360bf29ba658b5e469f2a526f9636bc4", "filename": "src/test/ui/suggestions/suggest-tryinto-edition-change.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-tryinto-edition-change.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-tryinto-edition-change.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-tryinto-edition-change.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -2,7 +2,7 @@ error[E0433]: failed to resolve: use of undeclared type `TryFrom`\n   --> $DIR/suggest-tryinto-edition-change.rs:11:19\n    |\n LL |     let _i: i16 = TryFrom::try_from(0_i32).unwrap();\n-   |                   ^^^^^^^ not found in this scope\n+   |                   ^^^^^^^ use of undeclared type `TryFrom`\n    |\n    = note: 'std::convert::TryFrom' is included in the prelude starting in Edition 2021\n    = note: 'core::convert::TryFrom' is included in the prelude starting in Edition 2021\n@@ -17,7 +17,7 @@ error[E0433]: failed to resolve: use of undeclared type `TryInto`\n   --> $DIR/suggest-tryinto-edition-change.rs:17:19\n    |\n LL |     let _i: i16 = TryInto::try_into(0_i32).unwrap();\n-   |                   ^^^^^^^ not found in this scope\n+   |                   ^^^^^^^ use of undeclared type `TryInto`\n    |\n    = note: 'std::convert::TryInto' is included in the prelude starting in Edition 2021\n    = note: 'core::convert::TryInto' is included in the prelude starting in Edition 2021\n@@ -32,12 +32,7 @@ error[E0433]: failed to resolve: use of undeclared type `FromIterator`\n   --> $DIR/suggest-tryinto-edition-change.rs:23:22\n    |\n LL |     let _v: Vec<_> = FromIterator::from_iter(&[1]);\n-   |                      ^^^^^^^^^^^^\n-   |\n-  ::: $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL | pub trait IntoIterator {\n-   | ---------------------- similarly named trait `IntoIterator` defined here\n+   |                      ^^^^^^^^^^^^ use of undeclared type `FromIterator`\n    |\n    = note: 'std::iter::FromIterator' is included in the prelude starting in Edition 2021\n    = note: 'core::iter::FromIterator' is included in the prelude starting in Edition 2021"}, {"sha": "576fc6a4f8d51c8f03f277b32767ec45f684c947", "filename": "src/test/ui/type-alias-enum-variants/self-in-enum-definition.stderr", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c493bae0d8efd75723460ce5c371f726efa93f15/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr?ref=c493bae0d8efd75723460ce5c371f726efa93f15", "patch": "@@ -12,6 +12,46 @@ LL |     V3 = Self::V1 {} as u8 + 2,\n note: ...which requires const-evaluating + checking `Alpha::V3::{constant#0}`...\n   --> $DIR/self-in-enum-definition.rs:5:10\n    |\n+LL |     V3 = Self::V1 {} as u8 + 2,\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires caching mir of `Alpha::V3::{constant#0}` for CTFE...\n+  --> $DIR/self-in-enum-definition.rs:5:10\n+   |\n+LL |     V3 = Self::V1 {} as u8 + 2,\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires elaborating drops for `Alpha::V3::{constant#0}`...\n+  --> $DIR/self-in-enum-definition.rs:5:10\n+   |\n+LL |     V3 = Self::V1 {} as u8 + 2,\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires borrow-checking `Alpha::V3::{constant#0}`...\n+  --> $DIR/self-in-enum-definition.rs:5:10\n+   |\n+LL |     V3 = Self::V1 {} as u8 + 2,\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing MIR for `Alpha::V3::{constant#0}`...\n+  --> $DIR/self-in-enum-definition.rs:5:10\n+   |\n+LL |     V3 = Self::V1 {} as u8 + 2,\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `Alpha::V3::{constant#0}`...\n+  --> $DIR/self-in-enum-definition.rs:5:10\n+   |\n+LL |     V3 = Self::V1 {} as u8 + 2,\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires preparing `Alpha::V3::{constant#0}` for borrow checking...\n+  --> $DIR/self-in-enum-definition.rs:5:10\n+   |\n+LL |     V3 = Self::V1 {} as u8 + 2,\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `Alpha::V3::{constant#0}`...\n+  --> $DIR/self-in-enum-definition.rs:5:10\n+   |\n+LL |     V3 = Self::V1 {} as u8 + 2,\n+   |          ^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for `Alpha::V3::{constant#0}`...\n+  --> $DIR/self-in-enum-definition.rs:5:10\n+   |\n LL |     V3 = Self::V1 {} as u8 + 2,\n    |          ^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires computing layout of `Alpha`..."}]}