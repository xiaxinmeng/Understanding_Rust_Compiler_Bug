{"sha": "ff34740a29e3ba4f8c34fd05badf798e481e2257", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMzQ3NDBhMjllM2JhNGY4YzM0ZmQwNWJhZGY3OThlNDgxZTIyNTc=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-11T16:26:59Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-13T01:54:12Z"}, "message": "std: Add ToOption/IntoOption/AsOption", "tree": {"sha": "8498959dee396168dbb06c046a0d6f68b3a9b0d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8498959dee396168dbb06c046a0d6f68b3a9b0d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff34740a29e3ba4f8c34fd05badf798e481e2257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff34740a29e3ba4f8c34fd05badf798e481e2257", "html_url": "https://github.com/rust-lang/rust/commit/ff34740a29e3ba4f8c34fd05badf798e481e2257", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff34740a29e3ba4f8c34fd05badf798e481e2257/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8a284e873125097dcfa5cec5d7135789d6673b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8a284e873125097dcfa5cec5d7135789d6673b3", "html_url": "https://github.com/rust-lang/rust/commit/b8a284e873125097dcfa5cec5d7135789d6673b3"}], "stats": {"total": 185, "additions": 185, "deletions": 0}, "files": [{"sha": "1773a6f8a977af22bd0824e106306c667ccb316b", "filename": "src/libstd/either.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ff34740a29e3ba4f8c34fd05badf798e481e2257/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff34740a29e3ba4f8c34fd05badf798e481e2257/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=ff34740a29e3ba4f8c34fd05badf798e481e2257", "patch": "@@ -13,6 +13,7 @@\n #[allow(missing_doc)];\n \n use option::{Some, None};\n+use option;\n use clone::Clone;\n use container::Container;\n use cmp::Eq;\n@@ -116,6 +117,36 @@ impl<L, R> Either<L, R> {\n     }\n }\n \n+impl<L, R: Clone> option::ToOption<R> for Either<L, R> {\n+    #[inline]\n+    fn to_option(&self)-> option::Option<R> {\n+        match *self {\n+            Left(_) => None,\n+            Right(ref r) => Some(r.clone()),\n+        }\n+    }\n+}\n+\n+impl<L, R> option::IntoOption<R> for Either<L, R> {\n+    #[inline]\n+    fn into_option(self)-> option::Option<R> {\n+        match self {\n+            Left(_) => None,\n+            Right(r) => Some(r),\n+        }\n+    }\n+}\n+\n+impl<L, R> option::AsOption<R> for Either<L, R> {\n+    #[inline]\n+    fn as_option<'a>(&'a self) -> option::Option<&'a R> {\n+        match *self {\n+            Left(_) => None,\n+            Right(ref r) => Some(r),\n+        }\n+    }\n+}\n+\n /// An iterator yielding the `Left` values of its source\n pub type Lefts<L, R, Iter> = FilterMap<'static, Either<L, R>, L, Iter>;\n \n@@ -167,6 +198,9 @@ pub fn partition<L, R>(eithers: ~[Either<L, R>]) -> (~[L], ~[R]) {\n mod tests {\n     use super::*;\n \n+    use option::{IntoOption, ToOption, AsOption};\n+    use option;\n+\n     #[test]\n     fn test_either_left() {\n         let val = Left(10);\n@@ -260,4 +294,30 @@ mod tests {\n         assert_eq!(rights.len(), 0u);\n     }\n \n+    #[test]\n+    pub fn test_to_option() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.to_option(), option::Some(100));\n+        assert_eq!(left.to_option(), option::None);\n+    }\n+\n+    #[test]\n+    pub fn test_into_option() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.into_option(), option::Some(100));\n+        assert_eq!(left.into_option(), option::None);\n+    }\n+\n+    #[test]\n+    pub fn test_as_option() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.as_option().unwrap(), &100);\n+        assert_eq!(left.as_option(), option::None);\n+    }\n }"}, {"sha": "5107076546a574712ae95d63a3c97b2b77da43e9", "filename": "src/libstd/option.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ff34740a29e3ba4f8c34fd05badf798e481e2257/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff34740a29e3ba4f8c34fd05badf798e481e2257/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=ff34740a29e3ba4f8c34fd05badf798e481e2257", "patch": "@@ -388,6 +388,44 @@ impl<T> Option<T> {\n     }\n }\n \n+/// A generic trait for converting a value to a `Option`\n+pub trait ToOption<T> {\n+    /// Convert to the `option` type\n+    fn to_option(&self) -> Option<T>;\n+}\n+\n+/// A generic trait for converting a value to a `Option`\n+pub trait IntoOption<T> {\n+    /// Convert to the `option` type\n+    fn into_option(self) -> Option<T>;\n+}\n+\n+/// A generic trait for converting a value to a `Option`\n+pub trait AsOption<T> {\n+    /// Convert to the `option` type\n+    fn as_option<'a>(&'a self) -> Option<&'a T>;\n+}\n+\n+impl<T: Clone> ToOption<T> for Option<T> {\n+    #[inline]\n+    fn to_option(&self) -> Option<T> { self.clone() }\n+}\n+\n+impl<T> IntoOption<T> for Option<T> {\n+    #[inline]\n+    fn into_option(self) -> Option<T> { self }\n+}\n+\n+impl<T> AsOption<T> for Option<T> {\n+    #[inline]\n+    fn as_option<'a>(&'a self) -> Option<&'a T> {\n+        match *self {\n+            Some(ref x) => Some(x),\n+            None => None,\n+        }\n+    }\n+}\n+\n impl<T: Default> Option<T> {\n     /// Returns the contained value or default (for this type)\n     #[inline]\n@@ -711,4 +749,31 @@ mod tests {\n         assert!(!x.mutate_default(0i, |i| i+1));\n         assert_eq!(x, Some(0i));\n     }\n+\n+    #[test]\n+    pub fn test_to_option() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.to_option(), Some(100));\n+        assert_eq!(none.to_option(), None);\n+    }\n+\n+    #[test]\n+    pub fn test_into_option() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.into_option(), Some(100));\n+        assert_eq!(none.into_option(), None);\n+    }\n+\n+    #[test]\n+    pub fn test_as_option() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.as_option().unwrap(), &100);\n+        assert_eq!(none.as_option(), None);\n+    }\n }"}, {"sha": "d72f151baee1e765808818459421f4fdc91652ee", "filename": "src/libstd/result.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ff34740a29e3ba4f8c34fd05badf798e481e2257/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff34740a29e3ba4f8c34fd05badf798e481e2257/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=ff34740a29e3ba4f8c34fd05badf798e481e2257", "patch": "@@ -17,6 +17,7 @@ use cmp::Eq;\n use either;\n use iter::Iterator;\n use option::{None, Option, Some, OptionIterator};\n+use option;\n use vec;\n use vec::OwnedVector;\n use to_str::ToStr;\n@@ -255,6 +256,36 @@ impl<T, E: Clone + ToStr> Result<T, E> {\n     }\n }\n \n+impl<T: Clone, E> option::ToOption<T> for Result<T, E> {\n+    #[inline]\n+    fn to_option(&self)-> Option<T> {\n+        match *self {\n+            Ok(ref t) => Some(t.clone()),\n+            Err(_) => None,\n+        }\n+    }\n+}\n+\n+impl<T, E> option::IntoOption<T> for Result<T, E> {\n+    #[inline]\n+    fn into_option(self)-> Option<T> {\n+        match self {\n+            Ok(t) => Some(t),\n+            Err(_) => None,\n+        }\n+    }\n+}\n+\n+impl<T, E> option::AsOption<T> for Result<T, E> {\n+    #[inline]\n+    fn as_option<'a>(&'a self)-> Option<&'a T> {\n+        match *self {\n+            Ok(ref t) => Some(t),\n+            Err(_) => None,\n+        }\n+    }\n+}\n+\n #[inline]\n #[allow(missing_doc)]\n pub fn map_opt<T, U: ToStr, V>(o_t: &Option<T>,\n@@ -336,6 +367,8 @@ mod tests {\n \n     use either;\n     use iter::range;\n+    use option::{IntoOption, ToOption, AsOption};\n+    use option;\n     use str::OwnedStr;\n     use vec::ImmutableVector;\n \n@@ -460,4 +493,31 @@ mod tests {\n                         .map(|f| (*f)())),\n                    Err(1));\n     }\n+\n+    #[test]\n+    pub fn test_to_option() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.to_option(), option::Some(100));\n+        assert_eq!(err.to_option(), option::None);\n+    }\n+\n+    #[test]\n+    pub fn test_into_option() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.into_option(), option::Some(100));\n+        assert_eq!(err.into_option(), option::None);\n+    }\n+\n+    #[test]\n+    pub fn test_as_option() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.as_option().unwrap(), &100);\n+        assert_eq!(err.as_option(), option::None);\n+    }\n }"}]}