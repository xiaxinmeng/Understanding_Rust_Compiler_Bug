{"sha": "3266c36624e804f9f086ebd40db19039b55a4ec1", "node_id": "C_kwDOAAsO6NoAKDMyNjZjMzY2MjRlODA0ZjlmMDg2ZWJkNDBkYjE5MDM5YjU1YTRlYzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-30T10:31:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-30T10:31:10Z"}, "message": "Auto merge of #111768 - oli-obk:pair_const_llvm, r=cjgillot\n\nOptimize scalar and scalar pair representations loaded from ByRef in llvm\n\nin https://github.com/rust-lang/rust/pull/105653 I noticed that we were generating suboptimal LLVM IR if we had a `ConstValue::ByRef` that could be represented by a `ScalarPair`. Before https://github.com/rust-lang/rust/pull/105653 this is probably rare, but after it, every slice will go down this suboptimal code path that requires LLVM to untangle a bunch of indirections and translate static allocations that are only used once to read a scalar pair from.", "tree": {"sha": "782ea7ea40d2ff1cc691626e5ab7c1a2189af2ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/782ea7ea40d2ff1cc691626e5ab7c1a2189af2ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3266c36624e804f9f086ebd40db19039b55a4ec1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3266c36624e804f9f086ebd40db19039b55a4ec1", "html_url": "https://github.com/rust-lang/rust/commit/3266c36624e804f9f086ebd40db19039b55a4ec1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3266c36624e804f9f086ebd40db19039b55a4ec1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "578bcbc2b42191556c4438b80ba37fafa4193e82", "url": "https://api.github.com/repos/rust-lang/rust/commits/578bcbc2b42191556c4438b80ba37fafa4193e82", "html_url": "https://github.com/rust-lang/rust/commit/578bcbc2b42191556c4438b80ba37fafa4193e82"}, {"sha": "164d041e303e9c98daaf35301fa88ba6844277dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/164d041e303e9c98daaf35301fa88ba6844277dd", "html_url": "https://github.com/rust-lang/rust/commit/164d041e303e9c98daaf35301fa88ba6844277dd"}], "stats": {"total": 203, "additions": 120, "deletions": 83}, "files": [{"sha": "bad87db47323e784f5d34012f6429a4115654bed", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3266c36624e804f9f086ebd40db19039b55a4ec1/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3266c36624e804f9f086ebd40db19039b55a4ec1/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=3266c36624e804f9f086ebd40db19039b55a4ec1", "patch": "@@ -1,17 +1,15 @@\n use gccjit::LValue;\n use gccjit::{RValue, Type, ToRValue};\n-use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods,\n     ConstMethods,\n-    DerivedTypeMethods,\n     MiscMethods,\n     StaticMethods,\n };\n use rustc_middle::mir::Mutability;\n-use rustc_middle::ty::layout::{TyAndLayout, LayoutOf};\n+use rustc_middle::ty::layout::{LayoutOf};\n use rustc_middle::mir::interpret::{ConstAllocation, GlobalAlloc, Scalar};\n-use rustc_target::abi::{self, HasDataLayout, Pointer, Size};\n+use rustc_target::abi::{self, HasDataLayout, Pointer};\n \n use crate::consts::const_alloc_to_gcc;\n use crate::context::CodegenCx;\n@@ -240,28 +238,26 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         const_alloc_to_gcc(self, alloc)\n     }\n \n-    fn from_const_alloc(&self, layout: TyAndLayout<'tcx>, alloc: ConstAllocation<'tcx>, offset: Size) -> PlaceRef<'tcx, RValue<'gcc>> {\n-        assert_eq!(alloc.inner().align, layout.align.abi);\n-        let ty = self.type_ptr_to(layout.gcc_type(self));\n-        let value =\n-            if layout.size == Size::ZERO {\n-                let value = self.const_usize(alloc.inner().align.bytes());\n-                self.const_bitcast(value, ty)\n-            }\n-            else {\n-                let init = const_alloc_to_gcc(self, alloc);\n-                let base_addr = self.static_addr_of(init, alloc.inner().align, None);\n-\n-                let array = self.const_bitcast(base_addr, self.type_i8p());\n-                let value = self.context.new_array_access(None, array, self.const_usize(offset.bytes())).get_address(None);\n-                self.const_bitcast(value, ty)\n-            };\n-        PlaceRef::new_sized(value, layout)\n-    }\n-\n     fn const_ptrcast(&self, val: RValue<'gcc>, ty: Type<'gcc>) -> RValue<'gcc> {\n         self.context.new_cast(None, val, ty)\n     }\n+\n+    fn const_bitcast(&self, value: RValue<'gcc>, typ: Type<'gcc>) -> RValue<'gcc> {\n+        if value.get_type() == self.bool_type.make_pointer() {\n+            if let Some(pointee) = typ.get_pointee() {\n+                if pointee.dyncast_vector().is_some() {\n+                    panic!()\n+                }\n+            }\n+        }\n+        // NOTE: since bitcast makes a value non-constant, don't bitcast if not necessary as some\n+        // SIMD builtins require a constant value.\n+        self.bitcast_if_needed(value, typ)\n+    }\n+    \n+    fn const_ptr_byte_offset(&self, base_addr: Self::Value, offset: abi::Size) -> Self::Value {\n+        self.context.new_array_access(None, base_addr, self.const_usize(offset.bytes())).get_address(None)\n+    }\n }\n \n pub trait SignType<'gcc, 'tcx> {"}, {"sha": "873f652e6f147e453c88e68a6b210194a58ecd85", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3266c36624e804f9f086ebd40db19039b55a4ec1/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3266c36624e804f9f086ebd40db19039b55a4ec1/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=3266c36624e804f9f086ebd40db19039b55a4ec1", "patch": "@@ -1,6 +1,6 @@\n #[cfg(feature = \"master\")]\n use gccjit::FnAttribute;\n-use gccjit::{Function, GlobalKind, LValue, RValue, ToRValue, Type};\n+use gccjit::{Function, GlobalKind, LValue, RValue, ToRValue};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, DerivedTypeMethods, StaticMethods};\n use rustc_middle::span_bug;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -16,21 +16,6 @@ use crate::context::CodegenCx;\n use crate::errors::InvalidMinimumAlignment;\n use crate::type_of::LayoutGccExt;\n \n-impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n-    pub fn const_bitcast(&self, value: RValue<'gcc>, typ: Type<'gcc>) -> RValue<'gcc> {\n-        if value.get_type() == self.bool_type.make_pointer() {\n-            if let Some(pointee) = typ.get_pointee() {\n-                if pointee.dyncast_vector().is_some() {\n-                    panic!()\n-                }\n-            }\n-        }\n-        // NOTE: since bitcast makes a value non-constant, don't bitcast if not necessary as some\n-        // SIMD builtins require a constant value.\n-        self.bitcast_if_needed(value, typ)\n-    }\n-}\n-\n fn set_global_alignment<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, gv: LValue<'gcc>, mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,"}, {"sha": "a3910fef9549fb20295f05a3bf07d73ec9fe8dd2", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3266c36624e804f9f086ebd40db19039b55a4ec1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3266c36624e804f9f086ebd40db19039b55a4ec1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=3266c36624e804f9f086ebd40db19039b55a4ec1", "patch": "@@ -8,16 +8,15 @@ use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n \n use rustc_ast::Mutability;\n-use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::stable_hasher::{Hash128, HashStable, StableHasher};\n use rustc_hir::def_id::DefId;\n use rustc_middle::bug;\n use rustc_middle::mir::interpret::{ConstAllocation, GlobalAlloc, Scalar};\n-use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n+use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cstore::{DllCallingConvention, DllImport, PeImportNameType};\n-use rustc_target::abi::{self, AddressSpace, HasDataLayout, Pointer, Size};\n+use rustc_target::abi::{self, AddressSpace, HasDataLayout, Pointer};\n use rustc_target::spec::Target;\n \n use libc::{c_char, c_uint};\n@@ -307,38 +306,24 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         const_alloc_to_llvm(self, alloc)\n     }\n \n-    fn from_const_alloc(\n-        &self,\n-        layout: TyAndLayout<'tcx>,\n-        alloc: ConstAllocation<'tcx>,\n-        offset: Size,\n-    ) -> PlaceRef<'tcx, &'ll Value> {\n-        let alloc_align = alloc.inner().align;\n-        assert_eq!(alloc_align, layout.align.abi);\n-        let llty = self.type_ptr_to(layout.llvm_type(self));\n-        let llval = if layout.size == Size::ZERO {\n-            let llval = self.const_usize(alloc_align.bytes());\n-            unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n-        } else {\n-            let init = const_alloc_to_llvm(self, alloc);\n-            let base_addr = self.static_addr_of(init, alloc_align, None);\n-\n-            let llval = unsafe {\n-                llvm::LLVMRustConstInBoundsGEP2(\n-                    self.type_i8(),\n-                    self.const_bitcast(base_addr, self.type_i8p()),\n-                    &self.const_usize(offset.bytes()),\n-                    1,\n-                )\n-            };\n-            self.const_bitcast(llval, llty)\n-        };\n-        PlaceRef::new_sized(llval, layout)\n-    }\n-\n     fn const_ptrcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         consts::ptrcast(val, ty)\n     }\n+\n+    fn const_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        self.const_bitcast(val, ty)\n+    }\n+\n+    fn const_ptr_byte_offset(&self, base_addr: Self::Value, offset: abi::Size) -> Self::Value {\n+        unsafe {\n+            llvm::LLVMRustConstInBoundsGEP2(\n+                self.type_i8(),\n+                self.const_bitcast(base_addr, self.type_i8p()),\n+                &self.const_usize(offset.bytes()),\n+                1,\n+            )\n+        }\n+    }\n }\n \n /// Get the [LLVM type][Type] of a [`Value`]."}, {"sha": "4000c9540ce5a6474bcee584dac29d33b2cc53fb", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3266c36624e804f9f086ebd40db19039b55a4ec1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3266c36624e804f9f086ebd40db19039b55a4ec1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=3266c36624e804f9f086ebd40db19039b55a4ec1", "patch": "@@ -8,10 +8,10 @@ use crate::traits::*;\n use crate::MemFlags;\n \n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{ConstValue, Pointer, Scalar};\n+use rustc_middle::mir::interpret::{alloc_range, ConstValue, Pointer, Scalar};\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::Ty;\n-use rustc_target::abi::{Abi, Align, Size};\n+use rustc_target::abi::{self, Abi, Align, Size};\n \n use std::fmt;\n \n@@ -115,13 +115,82 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 OperandValue::Pair(a_llval, b_llval)\n             }\n             ConstValue::ByRef { alloc, offset } => {\n-                return bx.load_operand(bx.from_const_alloc(layout, alloc, offset));\n+                return Self::from_const_alloc(bx, layout, alloc, offset);\n             }\n         };\n \n         OperandRef { val, layout }\n     }\n \n+    fn from_const_alloc<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &mut Bx,\n+        layout: TyAndLayout<'tcx>,\n+        alloc: rustc_middle::mir::interpret::ConstAllocation<'tcx>,\n+        offset: Size,\n+    ) -> Self {\n+        let alloc_align = alloc.inner().align;\n+        assert_eq!(alloc_align, layout.align.abi);\n+        let ty = bx.type_ptr_to(bx.cx().backend_type(layout));\n+\n+        let read_scalar = |start, size, s: abi::Scalar, ty| {\n+            let val = alloc\n+                .0\n+                .read_scalar(\n+                    bx,\n+                    alloc_range(start, size),\n+                    /*read_provenance*/ matches!(s.primitive(), abi::Pointer(_)),\n+                )\n+                .unwrap();\n+            bx.scalar_to_backend(val, s, ty)\n+        };\n+\n+        // It may seem like all types with `Scalar` or `ScalarPair` ABI are fair game at this point.\n+        // However, `MaybeUninit<u64>` is considered a `Scalar` as far as its layout is concerned --\n+        // and yet cannot be represented by an interpreter `Scalar`, since we have to handle the\n+        // case where some of the bytes are initialized and others are not. So, we need an extra\n+        // check that walks over the type of `mplace` to make sure it is truly correct to treat this\n+        // like a `Scalar` (or `ScalarPair`).\n+        match layout.abi {\n+            Abi::Scalar(s @ abi::Scalar::Initialized { .. }) => {\n+                let size = s.size(bx);\n+                assert_eq!(size, layout.size, \"abi::Scalar size does not match layout size\");\n+                let val = read_scalar(Size::ZERO, size, s, ty);\n+                OperandRef { val: OperandValue::Immediate(val), layout }\n+            }\n+            Abi::ScalarPair(\n+                a @ abi::Scalar::Initialized { .. },\n+                b @ abi::Scalar::Initialized { .. },\n+            ) => {\n+                let (a_size, b_size) = (a.size(bx), b.size(bx));\n+                let b_offset = a_size.align_to(b.align(bx).abi);\n+                assert!(b_offset.bytes() > 0);\n+                let a_val = read_scalar(\n+                    Size::ZERO,\n+                    a_size,\n+                    a,\n+                    bx.scalar_pair_element_backend_type(layout, 0, true),\n+                );\n+                let b_val = read_scalar(\n+                    b_offset,\n+                    b_size,\n+                    b,\n+                    bx.scalar_pair_element_backend_type(layout, 1, true),\n+                );\n+                OperandRef { val: OperandValue::Pair(a_val, b_val), layout }\n+            }\n+            _ if layout.is_zst() => OperandRef::new_zst(bx, layout),\n+            _ => {\n+                // Neither a scalar nor scalar pair. Load from a place\n+                let init = bx.const_data_from_alloc(alloc);\n+                let base_addr = bx.static_addr_of(init, alloc_align, None);\n+\n+                let llval = bx.const_ptr_byte_offset(base_addr, offset);\n+                let llval = bx.const_bitcast(llval, ty);\n+                bx.load_operand(PlaceRef::new_sized(llval, layout))\n+            }\n+        }\n+    }\n+\n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n     pub fn immediate(self) -> V {"}, {"sha": "dc2fc396480129656ead4f65c127077b4ef13f73", "filename": "compiler/rustc_codegen_ssa/src/traits/consts.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3266c36624e804f9f086ebd40db19039b55a4ec1/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3266c36624e804f9f086ebd40db19039b55a4ec1/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs?ref=3266c36624e804f9f086ebd40db19039b55a4ec1", "patch": "@@ -1,8 +1,6 @@\n use super::BackendTypes;\n-use crate::mir::place::PlaceRef;\n use rustc_middle::mir::interpret::{ConstAllocation, Scalar};\n-use rustc_middle::ty::layout::TyAndLayout;\n-use rustc_target::abi::{self, Size};\n+use rustc_target::abi;\n \n pub trait ConstMethods<'tcx>: BackendTypes {\n     // Constant constructors\n@@ -30,12 +28,8 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn const_data_from_alloc(&self, alloc: ConstAllocation<'tcx>) -> Self::Value;\n \n     fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, llty: Self::Type) -> Self::Value;\n-    fn from_const_alloc(\n-        &self,\n-        layout: TyAndLayout<'tcx>,\n-        alloc: ConstAllocation<'tcx>,\n-        offset: Size,\n-    ) -> PlaceRef<'tcx, Self::Value>;\n \n     fn const_ptrcast(&self, val: Self::Value, ty: Self::Type) -> Self::Value;\n+    fn const_bitcast(&self, val: Self::Value, ty: Self::Type) -> Self::Value;\n+    fn const_ptr_byte_offset(&self, val: Self::Value, offset: abi::Size) -> Self::Value;\n }"}, {"sha": "8f32c50b7988420b7d960e4a36ee739dcae018a1", "filename": "tests/codegen/const_scalar_pair.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3266c36624e804f9f086ebd40db19039b55a4ec1/tests%2Fcodegen%2Fconst_scalar_pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3266c36624e804f9f086ebd40db19039b55a4ec1/tests%2Fcodegen%2Fconst_scalar_pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fconst_scalar_pair.rs?ref=3266c36624e804f9f086ebd40db19039b55a4ec1", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: --crate-type=lib -Copt-level=0 -Zmir-opt-level=0 -C debuginfo=2\n+\n+#![feature(inline_const)]\n+\n+pub fn foo() -> (i32, i32) {\n+    // CHECK: ret { i32, i32 } { i32 1, i32 2 }\n+    const { (1, 2) }\n+}"}]}