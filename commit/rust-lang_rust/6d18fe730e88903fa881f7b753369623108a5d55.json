{"sha": "6d18fe730e88903fa881f7b753369623108a5d55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMThmZTczMGU4ODkwM2ZhODgxZjdiNzUzMzY5NjIzMTA4YTVkNTU=", "commit": {"author": {"name": "jrqc", "email": "jrqc01@hotmail.com", "date": "2020-08-12T12:43:44Z"}, "committer": {"name": "jrqc", "email": "jrqc01@hotmail.com", "date": "2020-08-15T21:24:27Z"}, "message": "Make needless_return a late lint pass", "tree": {"sha": "14c6229a7396243386407a94cb2438f534a0262e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14c6229a7396243386407a94cb2438f534a0262e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d18fe730e88903fa881f7b753369623108a5d55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d18fe730e88903fa881f7b753369623108a5d55", "html_url": "https://github.com/rust-lang/rust/commit/6d18fe730e88903fa881f7b753369623108a5d55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d18fe730e88903fa881f7b753369623108a5d55/comments", "author": {"login": "jrqc", "id": 14986914, "node_id": "MDQ6VXNlcjE0OTg2OTE0", "avatar_url": "https://avatars.githubusercontent.com/u/14986914?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jrqc", "html_url": "https://github.com/jrqc", "followers_url": "https://api.github.com/users/jrqc/followers", "following_url": "https://api.github.com/users/jrqc/following{/other_user}", "gists_url": "https://api.github.com/users/jrqc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jrqc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jrqc/subscriptions", "organizations_url": "https://api.github.com/users/jrqc/orgs", "repos_url": "https://api.github.com/users/jrqc/repos", "events_url": "https://api.github.com/users/jrqc/events{/privacy}", "received_events_url": "https://api.github.com/users/jrqc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jrqc", "id": 14986914, "node_id": "MDQ6VXNlcjE0OTg2OTE0", "avatar_url": "https://avatars.githubusercontent.com/u/14986914?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jrqc", "html_url": "https://github.com/jrqc", "followers_url": "https://api.github.com/users/jrqc/followers", "following_url": "https://api.github.com/users/jrqc/following{/other_user}", "gists_url": "https://api.github.com/users/jrqc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jrqc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jrqc/subscriptions", "organizations_url": "https://api.github.com/users/jrqc/orgs", "repos_url": "https://api.github.com/users/jrqc/repos", "events_url": "https://api.github.com/users/jrqc/events{/privacy}", "received_events_url": "https://api.github.com/users/jrqc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0cc006964a557ad9dcf597a7bad356132329b3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0cc006964a557ad9dcf597a7bad356132329b3c", "html_url": "https://github.com/rust-lang/rust/commit/f0cc006964a557ad9dcf597a7bad356132329b3c"}], "stats": {"total": 317, "additions": 175, "deletions": 142}, "files": [{"sha": "d2f66cf9bd01ec82407185a693aa8c87816ebb9c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d18fe730e88903fa881f7b753369623108a5d55/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d18fe730e88903fa881f7b753369623108a5d55/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6d18fe730e88903fa881f7b753369623108a5d55", "patch": "@@ -256,6 +256,7 @@ mod needless_borrow;\n mod needless_borrowed_ref;\n mod needless_continue;\n mod needless_pass_by_value;\n+mod needless_return;\n mod needless_update;\n mod neg_cmp_op_on_partial_ord;\n mod neg_multiply;\n@@ -726,6 +727,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n         &needless_continue::NEEDLESS_CONTINUE,\n         &needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n+        &needless_return::NEEDLESS_RETURN,\n         &needless_update::NEEDLESS_UPDATE,\n         &neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD,\n         &neg_multiply::NEG_MULTIPLY,\n@@ -769,7 +771,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &regex::INVALID_REGEX,\n         &regex::TRIVIAL_REGEX,\n         &repeat_once::REPEAT_ONCE,\n-        &returns::NEEDLESS_RETURN,\n         &returns::UNUSED_UNIT,\n         &serde_api::SERDE_API_MISUSE,\n         &shadow::SHADOW_REUSE,\n@@ -1027,6 +1028,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box redundant_closure_call::RedundantClosureCall);\n     store.register_early_pass(|| box returns::Return);\n     store.register_late_pass(|| box let_and_return::LetReturn);\n+    store.register_late_pass(|| box needless_return::NeedlessReturn);\n     store.register_early_pass(|| box collapsible_if::CollapsibleIf);\n     store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n     store.register_early_pass(|| box precedence::Precedence);\n@@ -1381,6 +1383,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_bool::BOOL_COMPARISON),\n         LintId::of(&needless_bool::NEEDLESS_BOOL),\n         LintId::of(&needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n+        LintId::of(&needless_return::NEEDLESS_RETURN),\n         LintId::of(&needless_update::NEEDLESS_UPDATE),\n         LintId::of(&neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n         LintId::of(&neg_multiply::NEG_MULTIPLY),\n@@ -1413,7 +1416,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&regex::INVALID_REGEX),\n         LintId::of(&regex::TRIVIAL_REGEX),\n         LintId::of(&repeat_once::REPEAT_ONCE),\n-        LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&returns::UNUSED_UNIT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n@@ -1543,6 +1545,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&misc_early::MIXED_CASE_HEX_LITERALS),\n         LintId::of(&misc_early::REDUNDANT_PATTERN),\n         LintId::of(&mut_reference::UNNECESSARY_MUT_PASSED),\n+        LintId::of(&needless_return::NEEDLESS_RETURN),\n         LintId::of(&neg_multiply::NEG_MULTIPLY),\n         LintId::of(&new_without_default::NEW_WITHOUT_DEFAULT),\n         LintId::of(&non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n@@ -1554,7 +1557,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&regex::TRIVIAL_REGEX),\n-        LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&returns::UNUSED_UNIT),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&strings::STRING_LIT_AS_BYTES),"}, {"sha": "a8876619ac15b89cfe7dc1c5ffb23a2d520ddbbd", "filename": "clippy_lints/src/needless_return.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/6d18fe730e88903fa881f7b753369623108a5d55/clippy_lints%2Fsrc%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d18fe730e88903fa881f7b753369623108a5d55/clippy_lints%2Fsrc%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_return.rs?ref=6d18fe730e88903fa881f7b753369623108a5d55", "patch": "@@ -0,0 +1,166 @@\n+use rustc_lint::{LateLintPass, LateContext};\n+use rustc_ast::ast::Attribute;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::FnKind;\n+use rustc_span::source_map::Span;\n+use rustc_middle::lint::in_external_macro;\n+use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, StmtKind};\n+\n+use crate::utils::{snippet_opt, span_lint_and_sugg, span_lint_and_then};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for return statements at the end of a block.\n+    ///\n+    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n+    /// more rusty.\n+    ///\n+    /// **Known problems:** If the computation returning the value borrows a local\n+    /// variable, removing the `return` may run afoul of the borrow checker.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(x: usize) -> usize {\n+    ///     return x;\n+    /// }\n+    /// ```\n+    /// simplify to\n+    /// ```rust\n+    /// fn foo(x: usize) -> usize {\n+    ///     x\n+    /// }\n+    /// ```\n+    pub NEEDLESS_RETURN,\n+    style,\n+    \"using a return statement like `return expr;` where an expression would suffice\"\n+}\n+\n+#[derive(PartialEq, Eq, Copy, Clone)]\n+enum RetReplacement {\n+    Empty,\n+    Block,\n+}\n+\n+declare_lint_pass!(NeedlessReturn => [NEEDLESS_RETURN]);\n+\n+impl<'tcx> LateLintPass<'tcx> for NeedlessReturn {\n+    fn check_fn(&mut self, cx: &LateContext<'tcx>, kind: FnKind<'tcx>, _: &'tcx FnDecl<'tcx>, body: &'tcx Body<'tcx>, _: Span, _: HirId) {\n+        match kind {\n+            FnKind::Closure(_) => {\n+                check_final_expr(cx, &body.value, Some(body.value.span), RetReplacement::Empty)\n+            }\n+            FnKind::ItemFn(..) | FnKind::Method(..) => {\n+                if let ExprKind::Block(ref block, _) = body.value.kind {\n+                    check_block_return(cx, block)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn attr_is_cfg(attr: &Attribute) -> bool {\n+    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n+}\n+\n+fn check_block_return(cx: &LateContext<'_>, block: &Block<'_>) {\n+    if let Some(expr) = block.expr {\n+        check_final_expr(cx, expr, Some(expr.span), RetReplacement::Empty);\n+    } else if let Some(stmt) = block.stmts.iter().last() {\n+        match stmt.kind {\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n+                check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+\n+fn check_final_expr(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    span: Option<Span>,\n+    replacement: RetReplacement,\n+) {\n+    match expr.kind {\n+        // simple return is always \"bad\"\n+        ExprKind::Ret(ref inner) => {\n+\n+            // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n+            if !expr.attrs.iter().any(attr_is_cfg) {\n+                emit_return_lint(\n+                    cx,\n+                    span.expect(\"`else return` is not possible\"),\n+                    inner.as_ref().map(|i| i.span),\n+                    replacement,\n+                );\n+            }\n+        }\n+        // a whole block? check it!\n+        ExprKind::Block(ref block, _) => {\n+            check_block_return(cx, block);\n+        }\n+        // a match expr, check all arms\n+        // an if/if let expr, check both exprs\n+        // note, if without else is going to be a type checking error anyways\n+        // (except for unit type functions) so we don't match it\n+\n+        ExprKind::Match(_, ref arms, source) => {\n+            match source {\n+                MatchSource::Normal => {\n+                    for arm in arms.iter() {\n+                        check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n+                    }\n+                }\n+                MatchSource::IfDesugar { contains_else_clause: true } | MatchSource::IfLetDesugar { contains_else_clause: true } => {\n+                    if let ExprKind::Block(ref ifblock, _) = arms[0].body.kind {\n+                        check_block_return(cx, ifblock);\n+                    }\n+                    check_final_expr(cx, arms[1].body, None, RetReplacement::Empty);\n+                }\n+                _ => ()\n+            }\n+        }\n+        _ => (),\n+    }\n+}\n+\n+fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n+    match inner_span {\n+        Some(inner_span) => {\n+            if in_external_macro(cx.tcx.sess, inner_span) || inner_span.from_expansion() {\n+                return;\n+            }\n+\n+            span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n+                if let Some(snippet) = snippet_opt(cx, inner_span) {\n+                    diag.span_suggestion(ret_span, \"remove `return`\", snippet, Applicability::MachineApplicable);\n+                }\n+            })\n+        }\n+        None => match replacement {\n+            RetReplacement::Empty => {\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_RETURN,\n+                    ret_span,\n+                    \"unneeded `return` statement\",\n+                    \"remove `return`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            RetReplacement::Block => {\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_RETURN,\n+                    ret_span,\n+                    \"unneeded `return` statement\",\n+                    \"replace `return` with an empty block\",\n+                    \"{}\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        },\n+    }\n+}"}, {"sha": "2bd0cccd39d6d93d926e92f34afd1344ebc84333", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 3, "deletions": 138, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/6d18fe730e88903fa881f7b753369623108a5d55/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d18fe730e88903fa881f7b753369623108a5d55/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=6d18fe730e88903fa881f7b753369623108a5d55", "patch": "@@ -3,38 +3,11 @@ use rustc_ast::ast;\n use rustc_ast::visit::FnKind;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::BytePos;\n \n-use crate::utils::{snippet_opt, span_lint_and_sugg, span_lint_and_then};\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for return statements at the end of a block.\n-    ///\n-    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n-    /// more rusty.\n-    ///\n-    /// **Known problems:** If the computation returning the value borrows a local\n-    /// variable, removing the `return` may run afoul of the borrow checker.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn foo(x: usize) -> usize {\n-    ///     return x;\n-    /// }\n-    /// ```\n-    /// simplify to\n-    /// ```rust\n-    /// fn foo(x: usize) -> usize {\n-    ///     x\n-    /// }\n-    /// ```\n-    pub NEEDLESS_RETURN,\n-    style,\n-    \"using a return statement like `return expr;` where an expression would suffice\"\n-}\n+use crate::utils::{span_lint_and_sugg};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n@@ -57,117 +30,12 @@ declare_clippy_lint! {\n     \"needless unit expression\"\n }\n \n-#[derive(PartialEq, Eq, Copy, Clone)]\n-enum RetReplacement {\n-    Empty,\n-    Block,\n-}\n \n-declare_lint_pass!(Return => [NEEDLESS_RETURN, UNUSED_UNIT]);\n-\n-impl Return {\n-    // Check the final stmt or expr in a block for unnecessary return.\n-    fn check_block_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n-        if let Some(stmt) = block.stmts.last() {\n-            match stmt.kind {\n-                ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n-                    self.check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n-                },\n-                _ => (),\n-            }\n-        }\n-    }\n-\n-    // Check the final expression in a block if it's a return.\n-    fn check_final_expr(\n-        &mut self,\n-        cx: &EarlyContext<'_>,\n-        expr: &ast::Expr,\n-        span: Option<Span>,\n-        replacement: RetReplacement,\n-    ) {\n-        match expr.kind {\n-            // simple return is always \"bad\"\n-            ast::ExprKind::Ret(ref inner) => {\n-                // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n-                if !expr.attrs.iter().any(attr_is_cfg) {\n-                    Self::emit_return_lint(\n-                        cx,\n-                        span.expect(\"`else return` is not possible\"),\n-                        inner.as_ref().map(|i| i.span),\n-                        replacement,\n-                    );\n-                }\n-            },\n-            // a whole block? check it!\n-            ast::ExprKind::Block(ref block, _) => {\n-                self.check_block_return(cx, block);\n-            },\n-            // an if/if let expr, check both exprs\n-            // note, if without else is going to be a type checking error anyways\n-            // (except for unit type functions) so we don't match it\n-            ast::ExprKind::If(_, ref ifblock, Some(ref elsexpr)) => {\n-                self.check_block_return(cx, ifblock);\n-                self.check_final_expr(cx, elsexpr, None, RetReplacement::Empty);\n-            },\n-            // a match expr, check all arms\n-            ast::ExprKind::Match(_, ref arms) => {\n-                for arm in arms {\n-                    self.check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-\n-    fn emit_return_lint(cx: &EarlyContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n-        match inner_span {\n-            Some(inner_span) => {\n-                if in_external_macro(cx.sess(), inner_span) || inner_span.from_expansion() {\n-                    return;\n-                }\n-\n-                span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n-                    if let Some(snippet) = snippet_opt(cx, inner_span) {\n-                        diag.span_suggestion(ret_span, \"remove `return`\", snippet, Applicability::MachineApplicable);\n-                    }\n-                })\n-            },\n-            None => match replacement {\n-                RetReplacement::Empty => {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_RETURN,\n-                        ret_span,\n-                        \"unneeded `return` statement\",\n-                        \"remove `return`\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                },\n-                RetReplacement::Block => {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_RETURN,\n-                        ret_span,\n-                        \"unneeded `return` statement\",\n-                        \"replace `return` with an empty block\",\n-                        \"{}\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                },\n-            },\n-        }\n-    }\n-}\n+declare_lint_pass!(Return => [UNUSED_UNIT]);\n \n impl EarlyLintPass for Return {\n     fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, span: Span, _: ast::NodeId) {\n-        match kind {\n-            FnKind::Fn(.., Some(block)) => self.check_block_return(cx, block),\n-            FnKind::Closure(_, body) => self.check_final_expr(cx, body, Some(body.span), RetReplacement::Empty),\n-            FnKind::Fn(.., None) => {},\n-        }\n+\n         if_chain! {\n             if let ast::FnRetTy::Ty(ref ty) = kind.decl().output;\n             if let ast::TyKind::Tup(ref vals) = ty.kind;\n@@ -234,9 +102,6 @@ impl EarlyLintPass for Return {\n     }\n }\n \n-fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n-}\n \n // get the def site\n #[must_use]"}, {"sha": "7464f1cc6de2bbdf72ffff7d461f914b34371ea9", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d18fe730e88903fa881f7b753369623108a5d55/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d18fe730e88903fa881f7b753369623108a5d55/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=6d18fe730e88903fa881f7b753369623108a5d55", "patch": "@@ -1534,7 +1534,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"using a return statement like `return expr;` where an expression would suffice\",\n         deprecation: None,\n-        module: \"returns\",\n+        module: \"needless_return\",\n     },\n     Lint {\n         name: \"needless_update\","}]}