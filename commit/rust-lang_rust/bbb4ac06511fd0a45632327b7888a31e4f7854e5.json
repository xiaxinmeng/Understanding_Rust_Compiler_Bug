{"sha": "bbb4ac06511fd0a45632327b7888a31e4f7854e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYjRhYzA2NTExZmQwYTQ1NjMyMzI3Yjc4ODhhMzFlNGY3ODU0ZTU=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-13T23:56:13Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-22T15:20:23Z"}, "message": "Rebrand `MissingConstructors` as `SplitWildcard`", "tree": {"sha": "5297355afa83f5451c9debba7baaf4861a48d168", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5297355afa83f5451c9debba7baaf4861a48d168"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbb4ac06511fd0a45632327b7888a31e4f7854e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb4ac06511fd0a45632327b7888a31e4f7854e5", "html_url": "https://github.com/rust-lang/rust/commit/bbb4ac06511fd0a45632327b7888a31e4f7854e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbb4ac06511fd0a45632327b7888a31e4f7854e5/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d0c2ed913efa358c2ce9f17e4753f72c5169dd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d0c2ed913efa358c2ce9f17e4753f72c5169dd5", "html_url": "https://github.com/rust-lang/rust/commit/9d0c2ed913efa358c2ce9f17e4753f72c5169dd5"}], "stats": {"total": 116, "additions": 67, "deletions": 49}, "files": [{"sha": "9b065810ad47b39445bfc2514e75e3814e6bd061", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 63, "deletions": 46, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/bbb4ac06511fd0a45632327b7888a31e4f7854e5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb4ac06511fd0a45632327b7888a31e4f7854e5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=bbb4ac06511fd0a45632327b7888a31e4f7854e5", "patch": "@@ -695,20 +695,9 @@ impl<'tcx> Constructor<'tcx> {\n     /// Two constructors that are not in the matrix will either both be caught (by a wildcard), or\n     /// both not be caught. Therefore we can keep the missing constructors grouped together.\n     fn split_wildcard<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Self; 1]> {\n-        // Missing constructors are those that are not matched by any non-wildcard patterns in the\n-        // current column. We only fully construct them on-demand, because they're rarely used and\n-        // can be big.\n-        let missing_ctors = MissingConstructors::new(pcx);\n-        if missing_ctors.is_empty(pcx) {\n-            // All the constructors are present in the matrix, so we just go through them all.\n-            // We must also split them first.\n-            missing_ctors.all_ctors\n-        } else {\n-            // Some constructors are missing, thus we can specialize with the wildcard constructor,\n-            // which will stand for those constructors that are missing, and behaves like any of\n-            // them.\n-            smallvec![Wildcard]\n-        }\n+        let mut split_wildcard = SplitWildcard::new(pcx);\n+        split_wildcard.split(pcx);\n+        split_wildcard.into_ctors(pcx)\n     }\n \n     /// Returns whether `self` is covered by `other`, i.e. whether `self` is a subset of `other`.\n@@ -811,7 +800,7 @@ impl<'tcx> Constructor<'tcx> {\n /// `Option<!>`, we do not include `Some(_)` in the returned list of constructors.\n /// Invariant: this returns an empty `Vec` if and only if the type is uninhabited (as determined by\n /// `cx.is_uninhabited()`).\n-fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tcx>> {\n+fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     let cx = pcx.cx;\n     let make_range = |start, end| {\n@@ -821,19 +810,19 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n         )\n     };\n     match pcx.ty.kind() {\n-        ty::Bool => vec![make_range(0, 1)],\n+        ty::Bool => smallvec![make_range(0, 1)],\n         ty::Array(sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n-                vec![]\n+                smallvec![]\n             } else {\n-                vec![Slice(Slice::new(Some(len), VarLen(0, 0)))]\n+                smallvec![Slice(Slice::new(Some(len), VarLen(0, 0)))]\n             }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n         ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n             let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n-            vec![Slice(Slice::new(None, kind))]\n+            smallvec![Slice(Slice::new(None, kind))]\n         }\n         ty::Adt(def, substs) if def.is_enum() => {\n             // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n@@ -863,7 +852,7 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n                 && !pcx.is_top_level;\n \n             if is_secretly_empty || is_declared_nonexhaustive {\n-                vec![NonExhaustive]\n+                smallvec![NonExhaustive]\n             } else if cx.tcx.features().exhaustive_patterns {\n                 // If `exhaustive_patterns` is enabled, we exclude variants known to be\n                 // uninhabited.\n@@ -880,7 +869,7 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             }\n         }\n         ty::Char => {\n-            vec![\n+            smallvec![\n                 // The valid Unicode Scalar Value ranges.\n                 make_range('\\u{0000}' as u128, '\\u{D7FF}' as u128),\n                 make_range('\\u{E000}' as u128, '\\u{10FFFF}' as u128),\n@@ -893,66 +882,94 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             // `usize`/`isize` are not allowed to be matched exhaustively unless the\n             // `precise_pointer_size_matching` feature is enabled. So we treat those types like\n             // `#[non_exhaustive]` enums by returning a special unmatcheable constructor.\n-            vec![NonExhaustive]\n+            smallvec![NonExhaustive]\n         }\n         &ty::Int(ity) => {\n             let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n             let max = min - 1;\n-            vec![make_range(min, max)]\n+            smallvec![make_range(min, max)]\n         }\n         &ty::Uint(uty) => {\n             let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n             let max = size.truncate(u128::MAX);\n-            vec![make_range(0, max)]\n+            smallvec![make_range(0, max)]\n         }\n         // If `exhaustive_patterns` is disabled and our scrutinee is the never type, we cannot\n         // expose its emptiness. The exception is if the pattern is at the top level, because we\n         // want empty matches to be considered exhaustive.\n         ty::Never if !cx.tcx.features().exhaustive_patterns && !pcx.is_top_level => {\n-            vec![NonExhaustive]\n+            smallvec![NonExhaustive]\n         }\n-        ty::Never => vec![],\n-        _ if cx.is_uninhabited(pcx.ty) => vec![],\n-        ty::Adt(..) | ty::Tuple(..) | ty::Ref(..) => vec![Single],\n+        ty::Never => smallvec![],\n+        _ if cx.is_uninhabited(pcx.ty) => smallvec![],\n+        ty::Adt(..) | ty::Tuple(..) | ty::Ref(..) => smallvec![Single],\n         // This type is one for which we cannot list constructors, like `str` or `f64`.\n-        _ => vec![NonExhaustive],\n+        _ => smallvec![NonExhaustive],\n     }\n }\n \n-// A struct to compute a set of constructors equivalent to `all_ctors \\ used_ctors`.\n+/// A wildcard constructor that we split relative to the constructors in the matrix, as explained\n+/// at the top of the file.\n+/// For splitting wildcards, there are two groups of constructors: there are the constructors\n+/// actually present in the matrix (`matrix_ctors`), and the constructors not present. Two\n+/// constructors that are not in the matrix will either both be covered (by a wildcard), or both\n+/// not be covered by any given row. Therefore we can keep the missing constructors grouped\n+/// together.\n #[derive(Debug)]\n-pub(super) struct MissingConstructors<'tcx> {\n+pub(super) struct SplitWildcard<'tcx> {\n+    /// Constructors seen in the matrix.\n+    matrix_ctors: Vec<Constructor<'tcx>>,\n+    /// All the constructors for this type\n     all_ctors: SmallVec<[Constructor<'tcx>; 1]>,\n-    used_ctors: Vec<Constructor<'tcx>>,\n }\n \n-impl<'tcx> MissingConstructors<'tcx> {\n+impl<'tcx> SplitWildcard<'tcx> {\n     pub(super) fn new<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Self {\n-        let used_ctors: Vec<Constructor<'_>> =\n+        let matrix_ctors = Vec::new();\n+        let all_ctors = all_constructors(pcx);\n+        SplitWildcard { matrix_ctors, all_ctors }\n+    }\n+\n+    /// Pass a set of constructors relative to which to split this one. Don't call twice, it won't\n+    /// do what you want.\n+    pub(super) fn split(&mut self, pcx: PatCtxt<'_, '_, 'tcx>) {\n+        self.matrix_ctors =\n             pcx.matrix.head_ctors(pcx.cx).cloned().filter(|c| !c.is_wildcard()).collect();\n         // Since `all_ctors` never contains wildcards, this won't recurse further.\n-        let all_ctors =\n-            all_constructors(pcx).into_iter().flat_map(|ctor| ctor.split(pcx)).collect();\n-\n-        MissingConstructors { all_ctors, used_ctors }\n+        self.all_ctors = self.all_ctors.iter().flat_map(|ctor| ctor.split(pcx)).collect();\n     }\n \n-    fn is_empty<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>) -> bool {\n-        self.iter(pcx).next().is_none()\n+    /// Whether there are any value constructors for this type that are not present in the matrix.\n+    fn any_missing(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> bool {\n+        self.iter_missing(pcx).next().is_some()\n     }\n \n-    /// Iterate over all_ctors \\ used_ctors\n-    fn iter<'a, 'p>(\n+    /// Iterate over the constructors for this type that are not present in the matrix.\n+    fn iter_missing<'a, 'p>(\n         &'a self,\n         pcx: PatCtxt<'a, 'p, 'tcx>,\n     ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> {\n-        self.all_ctors.iter().filter(move |ctor| !ctor.is_covered_by_any(pcx, &self.used_ctors))\n+        self.all_ctors.iter().filter(move |ctor| !ctor.is_covered_by_any(pcx, &self.matrix_ctors))\n+    }\n+\n+    /// Return the set of constructors resulting from splitting the wildcard. As explained at the\n+    /// top of the file, if any constructors are missing we can ignore the present ones.\n+    fn into_ctors(self, pcx: PatCtxt<'_, '_, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n+        if self.any_missing(pcx) {\n+            // Some constructors are missing, thus we can specialize with the wildcard constructor,\n+            // which will stand for those constructors that are missing, and matches the same rows\n+            // as any of them (namely the wildcard rows).\n+            return smallvec![Wildcard];\n+        }\n+\n+        // All the constructors are present in the matrix, so we just go through them all.\n+        self.all_ctors\n     }\n \n     /// List the patterns corresponding to the missing constructors. In some cases, instead of\n     /// listing all constructors of a given type, we prefer to simply report a wildcard.\n-    pub(super) fn report_patterns<'p>(\n+    pub(super) fn report_missing_patterns<'p>(\n         &self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n     ) -> SmallVec<[Pat<'tcx>; 1]> {\n@@ -984,7 +1001,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n         // The exception is: if we are at the top-level, for example in an empty match, we\n         // sometimes prefer reporting the list of constructors instead of just `_`.\n         let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(pcx.ty);\n-        if self.used_ctors.is_empty() && !report_when_all_missing {\n+        if self.matrix_ctors.is_empty() && !report_when_all_missing {\n             // All constructors are unused. Report only a wildcard\n             // rather than each individual constructor.\n             smallvec![Pat::wildcard_from_ty(pcx.ty)]\n@@ -993,7 +1010,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n             // constructor, that matches everything that can be built with\n             // it. For example, if `ctor` is a `Constructor::Variant` for\n             // `Option::Some`, we get the pattern `Some(_)`.\n-            self.iter(pcx)\n+            self.iter_missing(pcx)\n                 .map(|missing_ctor| Fields::wildcards(pcx, &missing_ctor).apply(pcx, missing_ctor))\n                 .collect()\n         }"}, {"sha": "5da42e705df88f9a1a0919689273c913af51a8a4", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bbb4ac06511fd0a45632327b7888a31e4f7854e5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb4ac06511fd0a45632327b7888a31e4f7854e5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=bbb4ac06511fd0a45632327b7888a31e4f7854e5", "patch": "@@ -306,7 +306,7 @@\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n-use super::deconstruct_pat::{Constructor, Fields, MissingConstructors};\n+use super::deconstruct_pat::{Constructor, Fields, SplitWildcard};\n use super::{Pat, PatKind};\n use super::{PatternFoldable, PatternFolder};\n \n@@ -810,8 +810,9 @@ impl<'tcx> Usefulness<'tcx> {\n         match self {\n             UsefulWithWitness(witnesses) => {\n                 let new_witnesses = if ctor.is_wildcard() {\n-                    let missing_ctors = MissingConstructors::new(pcx);\n-                    let new_patterns = missing_ctors.report_patterns(pcx);\n+                    let mut split_wildcard = SplitWildcard::new(pcx);\n+                    split_wildcard.split(pcx);\n+                    let new_patterns = split_wildcard.report_missing_patterns(pcx);\n                     witnesses\n                         .into_iter()\n                         .flat_map(|witness| {"}]}