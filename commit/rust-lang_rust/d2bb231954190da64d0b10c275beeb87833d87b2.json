{"sha": "d2bb231954190da64d0b10c275beeb87833d87b2", "node_id": "C_kwDOAAsO6NoAKGQyYmIyMzE5NTQxOTBkYTY0ZDBiMTBjMjc1YmVlYjg3ODMzZDg3YjI", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-02-26T00:18:05Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-02-26T00:18:05Z"}, "message": "Prune stacktraces for tag-tracking diagnostics too", "tree": {"sha": "c7bc8c5582f6c24bf7ed5d1046a8504c200852d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7bc8c5582f6c24bf7ed5d1046a8504c200852d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2bb231954190da64d0b10c275beeb87833d87b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2bb231954190da64d0b10c275beeb87833d87b2", "html_url": "https://github.com/rust-lang/rust/commit/d2bb231954190da64d0b10c275beeb87833d87b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2bb231954190da64d0b10c275beeb87833d87b2/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "538aedf09969fcc189a3aaee4a32cf01266c4941", "url": "https://api.github.com/repos/rust-lang/rust/commits/538aedf09969fcc189a3aaee4a32cf01266c4941", "html_url": "https://github.com/rust-lang/rust/commit/538aedf09969fcc189a3aaee4a32cf01266c4941"}], "stats": {"total": 94, "additions": 53, "deletions": 41}, "files": [{"sha": "8494f8a8ef0faee6399c103684a49e7a4e4e06a5", "filename": "src/diagnostics.rs", "status": "modified", "additions": 53, "deletions": 41, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d2bb231954190da64d0b10c275beeb87833d87b2/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bb231954190da64d0b10c275beeb87833d87b2/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=d2bb231954190da64d0b10c275beeb87833d87b2", "patch": "@@ -75,6 +75,54 @@ enum DiagLevel {\n     Note,\n }\n \n+fn has_local_frame(stacktrace: &[FrameInfo<'_>]) -> bool {\n+    stacktrace.iter().any(|frame| frame.instance.def_id().is_local())\n+}\n+\n+fn prune_stacktrace<'mir, 'tcx>(\n+    ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+    mut stacktrace: Vec<FrameInfo<'tcx>>,\n+) -> Vec<FrameInfo<'tcx>> {\n+    match ecx.machine.backtrace_style {\n+        BacktraceStyle::Off => {\n+            // Retain one frame so that we can print a span for the error itself\n+            stacktrace.truncate(1);\n+        }\n+        BacktraceStyle::Short => {\n+            // Only prune frames if there is at least one local frame. This check ensures that if\n+            // we get a backtrace that never makes it to the user code because it has detected a\n+            // bug in the Rust runtime, we don't prune away every frame.\n+            if has_local_frame(&stacktrace) {\n+                // This is part of the logic that `std` uses to select the relevant part of a\n+                // backtrace. But here, we only look for __rust_begin_short_backtrace, not\n+                // __rust_end_short_backtrace because the end symbol comes from a call to the default\n+                // panic handler.\n+                stacktrace = stacktrace\n+                    .into_iter()\n+                    .take_while(|frame| {\n+                        let def_id = frame.instance.def_id();\n+                        let path = ecx.tcx.tcx.def_path_str(def_id);\n+                        !path.contains(\"__rust_begin_short_backtrace\")\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                // After we prune frames from the bottom, there are a few left that are part of the\n+                // Rust runtime. So we remove frames until we get to a local symbol, which should be\n+                // main or a test.\n+                // This len check ensures that we don't somehow remove every frame, as doing so breaks\n+                // the primary error message.\n+                while stacktrace.len() > 1\n+                    && stacktrace.last().map_or(false, |e| !e.instance.def_id().is_local())\n+                {\n+                    stacktrace.pop();\n+                }\n+            }\n+        }\n+        BacktraceStyle::Full => {}\n+    }\n+    stacktrace\n+}\n+\n /// Emit a custom diagnostic without going through the miri-engine machinery\n pub fn report_error<'tcx, 'mir>(\n     ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n@@ -157,46 +205,8 @@ pub fn report_error<'tcx, 'mir>(\n         }\n     };\n \n-    let mut stacktrace = ecx.generate_stacktrace();\n-    let has_local_frame = stacktrace.iter().any(|frame| frame.instance.def_id().is_local());\n-    match ecx.machine.backtrace_style {\n-        BacktraceStyle::Off => {\n-            // Retain one frame so that we can print a span for the error itself\n-            stacktrace.truncate(1);\n-        }\n-        BacktraceStyle::Short => {\n-            // Only prune frames if there is at least one local frame. This check ensures that if\n-            // we get a backtrace that never makes it to the user code because it has detected a\n-            // bug in the Rust runtime, we don't prune away every frame.\n-            if has_local_frame {\n-                // This is part of the logic that `std` uses to select the relevant part of a\n-                // backtrace. But here, we only look for __rust_begin_short_backtrace, not\n-                // __rust_end_short_backtrace because the end symbol comes from a call to the default\n-                // panic handler.\n-                stacktrace = stacktrace\n-                    .into_iter()\n-                    .take_while(|frame| {\n-                        let def_id = frame.instance.def_id();\n-                        let path = ecx.tcx.tcx.def_path_str(def_id);\n-                        !path.contains(\"__rust_begin_short_backtrace\")\n-                    })\n-                    .collect::<Vec<_>>();\n-\n-                // After we prune frames from the bottom, there are a few left that are part of the\n-                // Rust runtime. So we remove frames until we get to a local symbol, which should be\n-                // main or a test.\n-                // This len check ensures that we don't somehow remove every frame, as doing so breaks\n-                // the primary error message.\n-                while stacktrace.len() > 1\n-                    && stacktrace.last().map_or(false, |e| !e.instance.def_id().is_local())\n-                {\n-                    stacktrace.pop();\n-                }\n-            }\n-        }\n-        BacktraceStyle::Full => {}\n-    }\n-\n+    let stacktrace = ecx.generate_stacktrace();\n+    let stacktrace = prune_stacktrace(ecx, stacktrace);\n     e.print_backtrace();\n     let msg = e.to_string();\n     report_msg(\n@@ -210,7 +220,7 @@ pub fn report_error<'tcx, 'mir>(\n \n     // Include a note like `std` does for short backtraces, but since we are opt-out not opt-in, we\n     // do not include a note when backtraces are off.\n-    if ecx.machine.backtrace_style == BacktraceStyle::Short && has_local_frame {\n+    if ecx.machine.backtrace_style == BacktraceStyle::Short && has_local_frame(&stacktrace) {\n         ecx.tcx.sess.diagnostic().note_without_error(\n             \"some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\",\n         );\n@@ -367,6 +377,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 );\n             }\n \n+            let stacktrace = prune_stacktrace(this, stacktrace);\n+\n             // Show diagnostics.\n             for e in diagnostics.drain(..) {\n                 use NonHaltingDiagnostic::*;"}]}