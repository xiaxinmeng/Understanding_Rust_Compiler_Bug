{"sha": "4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "node_id": "C_kwDOAAsO6NoAKDRiNTZmZDkzNDFkMjZhOTU1YjhlY2YwYmI2YzQ0NGY0MDNjYjQwMWE", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-07T13:12:32Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-15T14:53:18Z"}, "message": "try to avoid `FnCtxt` during wf", "tree": {"sha": "99891c843fe9b4c26b1340b216cda27e80bc3b23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99891c843fe9b4c26b1340b216cda27e80bc3b23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "html_url": "https://github.com/rust-lang/rust/commit/4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29d0390b97235e64f43bd50cf4282c26625e7e5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/29d0390b97235e64f43bd50cf4282c26625e7e5a", "html_url": "https://github.com/rust-lang/rust/commit/29d0390b97235e64f43bd50cf4282c26625e7e5a"}], "stats": {"total": 913, "additions": 468, "deletions": 445}, "files": [{"sha": "6c177f6388704a943548eb824a97e5df6ab2b46d", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -1,7 +1,17 @@\n-use rustc_middle::ty::TyCtxt;\n+use std::cell::RefCell;\n \n use super::TraitEngine;\n use super::{ChalkFulfillmentContext, FulfillmentContext};\n+use crate::infer::InferCtxtExt;\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::traits::{\n+    FulfillmentError, Obligation, ObligationCause, PredicateObligation, TraitEngineExt as _,\n+};\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::ToPredicate;\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub trait TraitEngineExt<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Box<Self>;\n@@ -16,3 +26,87 @@ impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n         }\n     }\n }\n+\n+/// Used if you want to have pleasant experience when dealing\n+/// with obligations outside of hir or mir typeck.\n+pub struct ObligationCtxt<'a, 'tcx> {\n+    pub infcx: &'a InferCtxt<'a, 'tcx>,\n+    engine: RefCell<Box<dyn TraitEngine<'tcx>>>,\n+}\n+\n+impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+        Self { infcx, engine: RefCell::new(<dyn TraitEngine<'_>>::new(infcx.tcx)) }\n+    }\n+\n+    pub fn register_obligation(&self, obligation: PredicateObligation<'tcx>) {\n+        self.engine.borrow_mut().register_predicate_obligation(self.infcx, obligation);\n+    }\n+\n+    pub fn register_obligations(\n+        &self,\n+        obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n+    ) {\n+        // Can't use `register_predicate_obligations` because the iterator\n+        // may also use this `ObligationCtxt`.\n+        for obligation in obligations {\n+            self.engine.borrow_mut().register_predicate_obligation(self.infcx, obligation)\n+        }\n+    }\n+\n+    pub fn register_infer_ok_obligations<T>(&self, infer_ok: InferOk<'tcx, T>) -> T {\n+        let InferOk { value, obligations } = infer_ok;\n+        self.engine.borrow_mut().register_predicate_obligations(self.infcx, obligations);\n+        value\n+    }\n+\n+    /// Requires that `ty` must implement the trait with `def_id` in\n+    /// the given environment. This trait must not have any type\n+    /// parameters (except for `Self`).\n+    pub fn register_bound(\n+        &self,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        def_id: DefId,\n+    ) {\n+        let tcx = self.infcx.tcx;\n+        let trait_ref = ty::TraitRef { def_id, substs: tcx.mk_substs_trait(ty, &[]) };\n+        self.register_obligation(Obligation {\n+            cause,\n+            recursion_depth: 0,\n+            param_env,\n+            predicate: ty::Binder::dummy(trait_ref).without_const().to_predicate(tcx),\n+        });\n+    }\n+\n+    pub fn normalize<T: TypeFoldable<'tcx>>(\n+        &self,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: T,\n+    ) -> T {\n+        let infer_ok = self.infcx.partially_normalize_associated_types_in(cause, param_env, value);\n+        self.register_infer_ok_obligations(infer_ok)\n+    }\n+\n+    pub fn equate_types(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+    ) -> Result<(), TypeError<'tcx>> {\n+        match self.infcx.at(cause, param_env).eq(expected, actual) {\n+            Ok(InferOk { obligations, value: () }) => {\n+                self.register_obligations(obligations);\n+                Ok(())\n+            }\n+            Err(e) => Err(e),\n+        }\n+    }\n+\n+    pub fn select_all_or_error(&self) -> Vec<FulfillmentError<'tcx>> {\n+        self.engine.borrow_mut().select_all_or_error(self.infcx)\n+    }\n+}"}, {"sha": "559f0a0550722010f22d22be8647948ee8176c20", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -47,7 +47,7 @@ pub use self::SelectionError::*;\n \n pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n pub use self::coherence::{OrphanCheckErr, OverlapResult};\n-pub use self::engine::TraitEngineExt;\n+pub use self::engine::{ObligationCtxt, TraitEngineExt};\n pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;"}, {"sha": "5ddffd0d973219eb06643f5ab57e638b9874d839", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -1,10 +1,7 @@\n-use crate::check::wfcheck::for_item;\n-\n use super::coercion::CoerceMany;\n use super::compare_method::check_type_bounds;\n use super::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n use super::*;\n-\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n@@ -29,8 +26,8 @@ use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVE\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::{self, ObligationCtxt};\n use rustc_ty_utils::representability::{self, Representability};\n \n use std::iter;\n@@ -733,14 +730,13 @@ fn check_opaque_meets_bounds<'tcx>(\n     let param_env = tcx.param_env(defining_use_anchor);\n \n     tcx.infer_ctxt().with_opaque_type_inference(defining_use_anchor).enter(move |infcx| {\n-        let inh = Inherited::new(infcx, def_id);\n-        let infcx = &inh.infcx;\n+        let ocx = ObligationCtxt::new(&infcx);\n         let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n \n         let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n         match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n-            Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n+            Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n             Err(ty_err) => {\n                 tcx.sess.delay_span_bug(\n                     span,\n@@ -754,11 +750,11 @@ fn check_opaque_meets_bounds<'tcx>(\n         // hidden type is well formed even without those bounds.\n         let predicate =\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_type.into())).to_predicate(tcx);\n-        inh.register_predicate(Obligation::new(misc_cause, param_env, predicate));\n+        ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             infcx.report_fulfillment_errors(&errors, None, false);\n         }\n@@ -940,9 +936,10 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n         DefKind::GlobalAsm => {\n             let it = tcx.hir().item(id);\n             let hir::ItemKind::GlobalAsm(asm) = it.kind else { span_bug!(it.span, \"DefKind::GlobalAsm but got {:#?}\", it) };\n-            for_item(tcx, it).with_fcx(|fcx| {\n+            Inherited::build(tcx, it.def_id).enter(|inh| {\n+                let fcx = FnCtxt::new(&inh, tcx.param_env(it.def_id), id.hir_id());\n                 fcx.check_asm(asm, it.hir_id());\n-                Default::default()\n+                fcx.select_all_obligations_or_error();\n             })\n         }\n         _ => {}"}, {"sha": "529d53a19bfef745ee18411879c04723904e0116", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -1,4 +1,4 @@\n-use super::{potentially_plural_count, Inherited};\n+use super::potentially_plural_count;\n use crate::check::regionck::OutlivesEnvironmentExt;\n use crate::check::wfcheck;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n@@ -9,7 +9,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -18,7 +18,9 @@ use rustc_middle::ty::{self, DefIdTree};\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n+use rustc_trait_selection::traits::{\n+    self, ObligationCause, ObligationCauseCode, ObligationCtxt, Reveal,\n+};\n use std::iter;\n \n /// Checks that a method from an impl conforms to the signature of\n@@ -205,21 +207,19 @@ fn compare_predicate_entailment<'tcx>(\n     );\n     let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n-        let inh = Inherited::new(infcx, impl_m.def_id.expect_local());\n-        let infcx = &inh.infcx;\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let ocx = ObligationCtxt::new(infcx);\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\", param_env.caller_bounds());\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n-\n         let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n         for (predicate, span) in iter::zip(impl_m_own_bounds.predicates, impl_m_own_bounds.spans) {\n             let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n             let traits::Normalized { value: predicate, obligations } =\n                 traits::normalize(&mut selcx, param_env, normalize_cause, predicate);\n \n-            inh.register_predicates(obligations);\n+            ocx.register_obligations(obligations);\n             let cause = ObligationCause::new(\n                 span,\n                 impl_m_hir_id,\n@@ -228,7 +228,7 @@ fn compare_predicate_entailment<'tcx>(\n                     trait_item_def_id: trait_m.def_id,\n                 },\n             );\n-            inh.register_predicate(traits::Obligation::new(cause, param_env, predicate));\n+            ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n         }\n \n         // We now need to check that the signature of the impl method is\n@@ -254,32 +254,31 @@ fn compare_predicate_entailment<'tcx>(\n             infer::HigherRankedType,\n             tcx.fn_sig(impl_m.def_id),\n         );\n-        let impl_sig =\n-            inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, impl_sig);\n+\n+        let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n+        let impl_sig = ocx.normalize(norm_cause.clone(), param_env, impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n         let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n         let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, trait_sig);\n-        let trait_sig =\n-            inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, trait_sig);\n+        let trait_sig = ocx.normalize(norm_cause, param_env, trait_sig);\n         // Add the resulting inputs and output as well-formed.\n         wf_tys.extend(trait_sig.inputs_and_output.iter());\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n \n-        let sub_result = infcx.at(&cause, param_env).sup(trait_fty, impl_fty).map(\n-            |InferOk { obligations, .. }| {\n-                // FIXME: We'd want to keep more accurate spans than \"the method signature\" when\n-                // processing the comparison between the trait and impl fn, but we sadly lose them\n-                // and point at the whole signature when a trait bound or specific input or output\n-                // type would be more appropriate. In other places we have a `Vec<Span>`\n-                // corresponding to their `Vec<Predicate>`, but we don't have that here.\n-                // Fixing this would improve the output of test `issue-83765.rs`.\n-                inh.register_predicates(obligations);\n-            },\n-        );\n+        // FIXME: We'd want to keep more accurate spans than \"the method signature\" when\n+        // processing the comparison between the trait and impl fn, but we sadly lose them\n+        // and point at the whole signature when a trait bound or specific input or output\n+        // type would be more appropriate. In other places we have a `Vec<Span>`\n+        // corresponding to their `Vec<Predicate>`, but we don't have that here.\n+        // Fixing this would improve the output of test `issue-83765.rs`.\n+        let sub_result = infcx\n+            .at(&cause, param_env)\n+            .sup(trait_fty, impl_fty)\n+            .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok));\n \n         if let Err(terr) = sub_result {\n             debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n@@ -385,7 +384,7 @@ fn compare_predicate_entailment<'tcx>(\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             let reported = infcx.report_fulfillment_errors(&errors, None, false);\n             return Err(reported);\n@@ -1058,8 +1057,7 @@ pub(crate) fn compare_const_impl<'tcx>(\n \n     tcx.infer_ctxt().enter(|infcx| {\n         let param_env = tcx.param_env(impl_c.def_id);\n-        let inh = Inherited::new(infcx, impl_c.def_id.expect_local());\n-        let infcx = &inh.infcx;\n+        let ocx = ObligationCtxt::new(&infcx);\n \n         // The below is for the most part highly similar to the procedure\n         // for methods above. It is simpler in many respects, especially\n@@ -1082,20 +1080,18 @@ pub(crate) fn compare_const_impl<'tcx>(\n         );\n \n         // There is no \"body\" here, so just pass dummy id.\n-        let impl_ty =\n-            inh.normalize_associated_types_in(impl_c_span, impl_c_hir_id, param_env, impl_ty);\n+        let impl_ty = ocx.normalize(cause.clone(), param_env, impl_ty);\n \n         debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n-        let trait_ty =\n-            inh.normalize_associated_types_in(impl_c_span, impl_c_hir_id, param_env, trait_ty);\n+        let trait_ty = ocx.normalize(cause.clone(), param_env, trait_ty);\n \n         debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n         let err = infcx\n             .at(&cause, param_env)\n             .sup(trait_ty, impl_ty)\n-            .map(|ok| inh.register_infer_ok_obligations(ok));\n+            .map(|ok| ocx.register_infer_ok_obligations(ok));\n \n         if let Err(terr) = err {\n             debug!(\n@@ -1142,7 +1138,7 @@ pub(crate) fn compare_const_impl<'tcx>(\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             infcx.report_fulfillment_errors(&errors, None, false);\n             return;\n@@ -1241,8 +1237,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     );\n     let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause.clone());\n     tcx.infer_ctxt().enter(|infcx| {\n-        let inh = Inherited::new(infcx, impl_ty.def_id.expect_local());\n-        let infcx = &inh.infcx;\n+        let ocx = ObligationCtxt::new(&infcx);\n \n         debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n \n@@ -1252,13 +1247,13 @@ fn compare_type_predicate_entailment<'tcx>(\n             let traits::Normalized { value: predicate, obligations } =\n                 traits::normalize(&mut selcx, param_env, normalize_cause.clone(), predicate);\n \n-            inh.register_predicates(obligations);\n-            inh.register_predicate(traits::Obligation::new(cause.clone(), param_env, predicate));\n+            ocx.register_obligations(obligations);\n+            ocx.register_obligation(traits::Obligation::new(cause.clone(), param_env, predicate));\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             let reported = infcx.report_fulfillment_errors(&errors, None, false);\n             return Err(reported);\n@@ -1431,10 +1426,9 @@ pub fn check_type_bounds<'tcx>(\n         impl_ty_substs.rebase_onto(tcx, impl_ty.container.id(), impl_trait_ref.substs);\n \n     tcx.infer_ctxt().enter(move |infcx| {\n-        let inh = Inherited::new(infcx, impl_ty.def_id.expect_local());\n-        let infcx = &inh.infcx;\n-        let mut selcx = traits::SelectionContext::new(&infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n \n+        let mut selcx = traits::SelectionContext::new(&infcx);\n         let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n         let normalize_cause = ObligationCause::new(\n             impl_ty_span,\n@@ -1477,13 +1471,13 @@ pub fn check_type_bounds<'tcx>(\n             debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n             obligation.predicate = normalized_predicate;\n \n-            inh.register_predicates(obligations);\n-            inh.register_predicate(obligation);\n+            ocx.register_obligations(obligations);\n+            ocx.register_obligation(obligation);\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             let reported = infcx.report_fulfillment_errors(&errors, None, false);\n             return Err(reported);\n@@ -1498,7 +1492,7 @@ pub fn check_type_bounds<'tcx>(\n             }\n         };\n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(infcx, implied_bounds, impl_ty_hir_id);\n+        outlives_environment.add_implied_bounds(&infcx, implied_bounds, impl_ty_hir_id);\n         infcx.check_region_obligations_and_report_errors(&outlives_environment);\n \n         Ok(())"}, {"sha": "42a9a23559c9e17e74f6111df84d825f07c6d495", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -37,7 +37,6 @@ use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,\n-    WellFormedLoc,\n };\n \n use std::collections::hash_map::Entry;\n@@ -375,29 +374,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (result, spans)\n     }\n \n-    /// Convenience method which tracks extra diagnostic information for normalization\n-    /// that occurs as a result of WF checking. The `hir_id` is the `HirId` of the hir item\n-    /// whose type is being wf-checked - this is used to construct a more precise span if\n-    /// an error occurs.\n-    ///\n-    /// It is never necessary to call this method - calling `normalize_associated_types_in` will\n-    /// just result in a slightly worse diagnostic span, and will still be sound.\n-    pub(in super::super) fn normalize_associated_types_in_wf<T>(\n-        &self,\n-        span: Span,\n-        value: T,\n-        loc: WellFormedLoc,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.inh.normalize_associated_types_in_with_cause(\n-            ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(Some(loc))),\n-            self.param_env,\n-            value,\n-        )\n-    }\n-\n     pub(in super::super) fn normalize_associated_types_in<T>(&self, span: Span, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,"}, {"sha": "149e4254a20e9219d63d469b38bcd82aa8e75e18", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 271, "deletions": 273, "changes": 544, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -1,5 +1,4 @@\n use crate::check::regionck::OutlivesEnvironmentExt;\n-use crate::check::{FnCtxt, Inherited};\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -23,55 +22,95 @@ use rustc_middle::ty::{\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_trait_selection::autoderef::Autoderef;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::traits::query::NoSolution;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, WellFormedLoc};\n+use rustc_trait_selection::traits::{\n+    self, ObligationCause, ObligationCauseCode, ObligationCtxt, WellFormedLoc,\n+};\n \n use std::cell::LazyCell;\n use std::convert::TryInto;\n use std::iter;\n-use std::ops::ControlFlow;\n+use std::ops::{ControlFlow, Deref};\n \n-/// Helper type of a temporary returned by `.for_item(...)`.\n-/// This is necessary because we can't write the following bound:\n-///\n-/// ```ignore (illustrative)\n-/// F: for<'b, 'tcx> where 'tcx FnOnce(FnCtxt<'b, 'tcx>)\n-/// ```\n-pub(super) struct CheckWfFcxBuilder<'tcx> {\n-    inherited: super::InheritedBuilder<'tcx>,\n-    id: hir::HirId,\n+pub(super) struct WfCheckingCtxt<'a, 'tcx> {\n+    pub(super) ocx: ObligationCtxt<'a, 'tcx>,\n     span: Span,\n+    body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n+impl<'a, 'tcx> Deref for WfCheckingCtxt<'a, 'tcx> {\n+    type Target = ObligationCtxt<'a, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.ocx\n+    }\n+}\n+\n+impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.ocx.infcx.tcx\n+    }\n \n-impl<'tcx> CheckWfFcxBuilder<'tcx> {\n-    pub(super) fn with_fcx<F>(&mut self, f: F)\n+    fn normalize<T>(&self, span: Span, loc: Option<WellFormedLoc>, value: T) -> T\n     where\n-        F: for<'b> FnOnce(&FnCtxt<'b, 'tcx>) -> FxHashSet<Ty<'tcx>>,\n+        T: TypeFoldable<'tcx>,\n     {\n-        let id = self.id;\n-        let span = self.span;\n-        let param_env = self.param_env;\n-        self.inherited.enter(|inh| {\n-            let fcx = FnCtxt::new(&inh, param_env, id);\n-            if !inh.tcx.features().trivial_bounds {\n-                // As predicates are cached rather than obligations, this\n-                // needs to be called first so that they are checked with an\n-                // empty `param_env`.\n-                check_false_global_bounds(&fcx, span, id);\n-            }\n-            let wf_tys = f(&fcx);\n-            fcx.select_all_obligations_or_error();\n+        self.ocx.normalize(\n+            ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(loc)),\n+            self.param_env,\n+            value,\n+        )\n+    }\n \n-            let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-            outlives_environment.add_implied_bounds(&fcx.infcx, wf_tys, id);\n-            fcx.infcx.check_region_obligations_and_report_errors(&outlives_environment);\n-        });\n+    fn register_wf_obligation(\n+        &self,\n+        span: Span,\n+        loc: Option<WellFormedLoc>,\n+        arg: ty::GenericArg<'tcx>,\n+    ) {\n+        let cause =\n+            traits::ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(loc));\n+        self.ocx.register_obligation(traits::Obligation::new(\n+            cause,\n+            self.param_env,\n+            ty::Binder::dummy(ty::PredicateKind::WellFormed(arg)).to_predicate(self.tcx()),\n+        ));\n     }\n }\n \n+pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    body_def_id: LocalDefId,\n+    f: F,\n+) where\n+    F: for<'a> FnOnce(&WfCheckingCtxt<'a, 'tcx>) -> FxHashSet<Ty<'tcx>>,\n+{\n+    let param_env = tcx.param_env(body_def_id);\n+    let body_id = tcx.hir().local_def_id_to_hir_id(body_def_id);\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let ocx = ObligationCtxt::new(infcx);\n+        let mut wfcx = WfCheckingCtxt { ocx, span, body_id, param_env };\n+\n+        if !tcx.features().trivial_bounds {\n+            wfcx.check_false_global_bounds()\n+        }\n+        let wf_tys = f(&mut wfcx);\n+        let errors = wfcx.select_all_or_error();\n+        if !errors.is_empty() {\n+            infcx.report_fulfillment_errors(&errors, None, false);\n+            return;\n+        }\n+\n+        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        outlives_environment.add_implied_bounds(infcx, wf_tys, body_id);\n+        infcx.check_region_obligations_and_report_errors(&outlives_environment);\n+    })\n+}\n+\n fn check_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let node = tcx.hir().expect_owner(def_id);\n     match node {\n@@ -176,17 +215,17 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n             check_item_type(tcx, item.def_id, ty.span, false);\n         }\n         hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, false, |fcx| vec![fcx.non_enum_variant(struct_def)]);\n+            check_type_defn(tcx, item, false, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n         hir::ItemKind::Union(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |fcx| vec![fcx.non_enum_variant(struct_def)]);\n+            check_type_defn(tcx, item, true, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n         hir::ItemKind::Enum(ref enum_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |fcx| fcx.enum_variants(enum_def));\n+            check_type_defn(tcx, item, true, |wfcx| wfcx.enum_variants(enum_def));\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n@@ -935,46 +974,45 @@ fn check_associated_item(\n     span: Span,\n     sig_if_method: Option<&hir::FnSig<'_>>,\n ) {\n-    let code = ObligationCauseCode::WellFormed(Some(WellFormedLoc::Ty(item_id)));\n-    for_id(tcx, item_id, span).with_fcx(|fcx| {\n-        let item = fcx.tcx.associated_item(item_id);\n+    let loc = Some(WellFormedLoc::Ty(item_id));\n+    enter_wf_checking_ctxt(tcx, span, item_id, |wfcx| {\n+        let item = tcx.associated_item(item_id);\n \n         let (mut implied_bounds, self_ty) = match item.container {\n-            ty::TraitContainer(_) => (FxHashSet::default(), fcx.tcx.types.self_param),\n+            ty::TraitContainer(_) => (FxHashSet::default(), tcx.types.self_param),\n             ty::ImplContainer(def_id) => (\n-                impl_implied_bounds(tcx, fcx.param_env, def_id.expect_local(), span),\n-                fcx.tcx.type_of(def_id),\n+                impl_implied_bounds(tcx, wfcx.param_env, def_id.expect_local(), span),\n+                tcx.type_of(def_id),\n             ),\n         };\n \n         match item.kind {\n             ty::AssocKind::Const => {\n-                let ty = fcx.tcx.type_of(item.def_id);\n-                let ty = fcx.normalize_associated_types_in_wf(span, ty, WellFormedLoc::Ty(item_id));\n-                fcx.register_wf_obligation(ty.into(), span, code.clone());\n+                let ty = tcx.type_of(item.def_id);\n+                let ty = wfcx.normalize(span, Some(WellFormedLoc::Ty(item_id)), ty);\n+                wfcx.register_wf_obligation(span, loc, ty.into());\n             }\n             ty::AssocKind::Fn => {\n-                let sig = fcx.tcx.fn_sig(item.def_id);\n+                let sig = tcx.fn_sig(item.def_id);\n                 let hir_sig = sig_if_method.expect(\"bad signature for method\");\n                 check_fn_or_method(\n-                    fcx,\n-                    item.ident(fcx.tcx).span,\n+                    wfcx,\n+                    item.ident(tcx).span,\n                     sig,\n                     hir_sig.decl,\n                     item.def_id.expect_local(),\n                     &mut implied_bounds,\n                 );\n-                check_method_receiver(fcx, hir_sig, item, self_ty);\n+                check_method_receiver(wfcx, hir_sig, item, self_ty);\n             }\n             ty::AssocKind::Type => {\n                 if let ty::AssocItemContainer::TraitContainer(_) = item.container {\n-                    check_associated_type_bounds(fcx, item, span)\n+                    check_associated_type_bounds(wfcx, item, span)\n                 }\n                 if item.defaultness.has_value() {\n-                    let ty = fcx.tcx.type_of(item.def_id);\n-                    let ty =\n-                        fcx.normalize_associated_types_in_wf(span, ty, WellFormedLoc::Ty(item_id));\n-                    fcx.register_wf_obligation(ty.into(), span, code.clone());\n+                    let ty = tcx.type_of(item.def_id);\n+                    let ty = wfcx.normalize(span, Some(WellFormedLoc::Ty(item_id)), ty);\n+                    wfcx.register_wf_obligation(span, loc, ty.into());\n                 }\n             }\n         }\n@@ -983,19 +1021,6 @@ fn check_associated_item(\n     })\n }\n \n-pub(super) fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<'tcx> {\n-    for_id(tcx, item.def_id, item.span)\n-}\n-\n-fn for_id(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> CheckWfFcxBuilder<'_> {\n-    CheckWfFcxBuilder {\n-        inherited: Inherited::build(tcx, def_id),\n-        id: hir::HirId::make_owner(def_id),\n-        span,\n-        param_env: tcx.param_env(def_id),\n-    }\n-}\n-\n fn item_adt_kind(kind: &ItemKind<'_>) -> Option<AdtKind> {\n     match kind {\n         ItemKind::Struct(..) => Some(AdtKind::Struct),\n@@ -1012,19 +1037,19 @@ fn check_type_defn<'tcx, F>(\n     all_sized: bool,\n     mut lookup_fields: F,\n ) where\n-    F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n+    F: FnMut(&WfCheckingCtxt<'_, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n {\n-    for_item(tcx, item).with_fcx(|fcx| {\n-        let variants = lookup_fields(fcx);\n+    enter_wf_checking_ctxt(tcx, item.span, item.def_id, |wfcx| {\n+        let variants = lookup_fields(wfcx);\n         let packed = tcx.adt_def(item.def_id).repr().packed();\n \n         for variant in &variants {\n             // All field types must be well-formed.\n             for field in &variant.fields {\n-                fcx.register_wf_obligation(\n-                    field.ty.into(),\n+                wfcx.register_wf_obligation(\n                     field.span,\n-                    ObligationCauseCode::WellFormed(Some(WellFormedLoc::Ty(field.def_id))),\n+                    Some(WellFormedLoc::Ty(field.def_id)),\n+                    field.ty.into(),\n                 )\n             }\n \n@@ -1051,12 +1076,10 @@ fn check_type_defn<'tcx, F>(\n                 variant.fields[..variant.fields.len() - unsized_len].iter().enumerate()\n             {\n                 let last = idx == variant.fields.len() - 1;\n-                fcx.register_bound(\n-                    field.ty,\n-                    tcx.require_lang_item(LangItem::Sized, None),\n+                wfcx.register_bound(\n                     traits::ObligationCause::new(\n                         field.span,\n-                        fcx.body_id,\n+                        wfcx.body_id,\n                         traits::FieldSized {\n                             adt_kind: match item_adt_kind(&item.kind) {\n                                 Some(i) => i,\n@@ -1066,6 +1089,9 @@ fn check_type_defn<'tcx, F>(\n                             last,\n                         },\n                     ),\n+                    wfcx.param_env,\n+                    field.ty,\n+                    tcx.require_lang_item(LangItem::Sized, None),\n                 );\n             }\n \n@@ -1075,12 +1101,12 @@ fn check_type_defn<'tcx, F>(\n \n                 let cause = traits::ObligationCause::new(\n                     tcx.def_span(discr_def_id),\n-                    fcx.body_id,\n+                    wfcx.body_id,\n                     traits::MiscObligation,\n                 );\n-                fcx.register_predicate(traits::Obligation::new(\n+                wfcx.register_obligation(traits::Obligation::new(\n                     cause,\n-                    fcx.param_env,\n+                    wfcx.param_env,\n                     ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(ty::Unevaluated::new(\n                         ty::WithOptConstParam::unknown(discr_def_id.to_def_id()),\n                         discr_substs,\n@@ -1090,7 +1116,7 @@ fn check_type_defn<'tcx, F>(\n             }\n         }\n \n-        check_where_clauses(fcx, item.span, item.def_id);\n+        check_where_clauses(wfcx, item.span, item.def_id);\n \n         // No implied bounds in a struct definition.\n         FxHashSet::default()\n@@ -1116,9 +1142,8 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n         }\n     }\n \n-    // FIXME: this shouldn't use an `FnCtxt` at all.\n-    for_item(tcx, item).with_fcx(|fcx| {\n-        check_where_clauses(fcx, item.span, item.def_id);\n+    enter_wf_checking_ctxt(tcx, item.span, item.def_id, |wfcx| {\n+        check_where_clauses(wfcx, item.span, item.def_id);\n \n         FxHashSet::default()\n     });\n@@ -1133,27 +1158,22 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n ///\n /// Assuming the defaults are used, check that all predicates (bounds on the\n /// assoc type and where clauses on the trait) hold.\n-fn check_associated_type_bounds(fcx: &FnCtxt<'_, '_>, item: &ty::AssocItem, span: Span) {\n-    let tcx = fcx.tcx;\n-\n-    let bounds = tcx.explicit_item_bounds(item.def_id);\n+fn check_associated_type_bounds(wfcx: &WfCheckingCtxt<'_, '_>, item: &ty::AssocItem, span: Span) {\n+    let bounds = wfcx.tcx().explicit_item_bounds(item.def_id);\n \n     debug!(\"check_associated_type_bounds: bounds={:?}\", bounds);\n     let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n-        let normalized_bound = fcx.normalize_associated_types_in(span, bound);\n+        let normalized_bound = wfcx.normalize(span, None, bound);\n         traits::wf::predicate_obligations(\n-            fcx,\n-            fcx.param_env,\n-            fcx.body_id,\n+            wfcx.infcx,\n+            wfcx.param_env,\n+            wfcx.body_id,\n             normalized_bound,\n             bound_span,\n         )\n     });\n \n-    for obligation in wf_obligations {\n-        debug!(\"next obligation cause: {:?}\", obligation.cause);\n-        fcx.register_predicate(obligation);\n-    }\n+    wfcx.register_obligations(wf_obligations);\n }\n \n fn check_item_fn(\n@@ -1163,39 +1183,36 @@ fn check_item_fn(\n     span: Span,\n     decl: &hir::FnDecl<'_>,\n ) {\n-    for_id(tcx, def_id, span).with_fcx(|fcx| {\n+    enter_wf_checking_ctxt(tcx, span, def_id, |wfcx| {\n         let sig = tcx.fn_sig(def_id);\n         let mut implied_bounds = FxHashSet::default();\n-        check_fn_or_method(fcx, ident.span, sig, decl, def_id, &mut implied_bounds);\n+        check_fn_or_method(wfcx, ident.span, sig, decl, def_id, &mut implied_bounds);\n         implied_bounds\n     })\n }\n \n fn check_item_type(tcx: TyCtxt<'_>, item_id: LocalDefId, ty_span: Span, allow_foreign_ty: bool) {\n     debug!(\"check_item_type: {:?}\", item_id);\n \n-    for_id(tcx, item_id, ty_span).with_fcx(|fcx| {\n+    enter_wf_checking_ctxt(tcx, ty_span, item_id, |wfcx| {\n         let ty = tcx.type_of(item_id);\n-        let item_ty = fcx.normalize_associated_types_in_wf(ty_span, ty, WellFormedLoc::Ty(item_id));\n+        let item_ty = wfcx.normalize(ty_span, Some(WellFormedLoc::Ty(item_id)), ty);\n \n         let mut forbid_unsized = true;\n         if allow_foreign_ty {\n-            let tail = fcx.tcx.struct_tail_erasing_lifetimes(item_ty, fcx.param_env);\n+            let tail = tcx.struct_tail_erasing_lifetimes(item_ty, wfcx.param_env);\n             if let ty::Foreign(_) = tail.kind() {\n                 forbid_unsized = false;\n             }\n         }\n \n-        fcx.register_wf_obligation(\n-            item_ty.into(),\n-            ty_span,\n-            ObligationCauseCode::WellFormed(Some(WellFormedLoc::Ty(item_id))),\n-        );\n+        wfcx.register_wf_obligation(ty_span, Some(WellFormedLoc::Ty(item_id)), item_ty.into());\n         if forbid_unsized {\n-            fcx.register_bound(\n+            wfcx.register_bound(\n+                traits::ObligationCause::new(ty_span, wfcx.body_id, traits::WellFormed(None)),\n+                wfcx.param_env,\n                 item_ty,\n                 tcx.require_lang_item(LangItem::Sized, None),\n-                traits::ObligationCause::new(ty_span, fcx.body_id, traits::WellFormed(None)),\n             );\n         }\n \n@@ -1206,10 +1223,11 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: LocalDefId, ty_span: Span, allow_fo\n             && !tcx.is_thread_local_static(item_id.to_def_id());\n \n         if should_check_for_sync {\n-            fcx.register_bound(\n+            wfcx.register_bound(\n+                traits::ObligationCause::new(ty_span, wfcx.body_id, traits::SharedStatic),\n+                wfcx.param_env,\n                 item_ty,\n                 tcx.require_lang_item(LangItem::Sync, Some(ty_span)),\n-                traits::ObligationCause::new(ty_span, fcx.body_id, traits::SharedStatic),\n             );\n         }\n \n@@ -1225,55 +1243,47 @@ fn check_impl<'tcx>(\n     ast_self_ty: &hir::Ty<'_>,\n     ast_trait_ref: &Option<hir::TraitRef<'_>>,\n ) {\n-    for_item(tcx, item).with_fcx(|fcx| {\n+    enter_wf_checking_ctxt(tcx, item.span, item.def_id, |wfcx| {\n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n                 let trait_ref = tcx.impl_trait_ref(item.def_id).unwrap();\n-                let trait_ref =\n-                    fcx.normalize_associated_types_in(ast_trait_ref.path.span, trait_ref);\n+                let trait_ref = wfcx.normalize(ast_trait_ref.path.span, None, trait_ref);\n                 let obligations = traits::wf::trait_obligations(\n-                    fcx,\n-                    fcx.param_env,\n-                    fcx.body_id,\n+                    wfcx.infcx,\n+                    wfcx.param_env,\n+                    wfcx.body_id,\n                     &trait_ref,\n                     ast_trait_ref.path.span,\n                     item,\n                 );\n                 debug!(?obligations);\n-                for obligation in obligations {\n-                    fcx.register_predicate(obligation);\n-                }\n+                wfcx.register_obligations(obligations);\n             }\n             None => {\n                 let self_ty = tcx.type_of(item.def_id);\n-                let self_ty = fcx.normalize_associated_types_in(item.span, self_ty);\n-                fcx.register_wf_obligation(\n-                    self_ty.into(),\n+                let self_ty = wfcx.normalize(item.span, None, self_ty);\n+                wfcx.register_wf_obligation(\n                     ast_self_ty.span,\n-                    ObligationCauseCode::WellFormed(Some(WellFormedLoc::Ty(\n-                        item.hir_id().expect_owner(),\n-                    ))),\n+                    Some(WellFormedLoc::Ty(item.hir_id().expect_owner())),\n+                    self_ty.into(),\n                 );\n             }\n         }\n \n-        check_where_clauses(fcx, item.span, item.def_id);\n+        check_where_clauses(wfcx, item.span, item.def_id);\n \n-        impl_implied_bounds(tcx, fcx.param_env, item.def_id, item.span)\n+        impl_implied_bounds(tcx, wfcx.param_env, item.def_id, item.span)\n     });\n }\n \n /// Checks where-clauses and inline bounds that are declared on `def_id`.\n-#[instrument(skip(fcx), level = \"debug\")]\n-fn check_where_clauses<'tcx, 'fcx>(\n-    fcx: &FnCtxt<'fcx, 'tcx>,\n-    span: Span,\n-    def_id: LocalDefId,\n-) {\n-    let tcx = fcx.tcx;\n+#[instrument(level = \"debug\", skip(wfcx))]\n+fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id: LocalDefId) {\n+    let infcx = wfcx.infcx;\n+    let tcx = wfcx.tcx();\n \n     let predicates = tcx.predicates_of(def_id);\n     let generics = tcx.generics_of(def_id);\n@@ -1301,11 +1311,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                     // be sure if it will error or not as user might always specify the other.\n                     if !ty.needs_subst() {\n-                        fcx.register_wf_obligation(\n-                            ty.into(),\n-                            tcx.def_span(param.def_id),\n-                            ObligationCauseCode::MiscObligation,\n-                        );\n+                        wfcx.register_wf_obligation(tcx.def_span(param.def_id), None, ty.into());\n                     }\n                 }\n             }\n@@ -1317,10 +1323,10 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     // we should eagerly error.\n                     let default_ct = tcx.const_param_default(param.def_id);\n                     if !default_ct.needs_subst() {\n-                        fcx.register_wf_obligation(\n-                            default_ct.into(),\n+                        wfcx.register_wf_obligation(\n                             tcx.def_span(param.def_id),\n-                            ObligationCauseCode::WellFormed(None),\n+                            None,\n+                            default_ct.into(),\n                         );\n                     }\n                 }\n@@ -1431,142 +1437,132 @@ fn check_where_clauses<'tcx, 'fcx>(\n             // Note the subtle difference from how we handle `predicates`\n             // below: there, we are not trying to prove those predicates\n             // to be *true* but merely *well-formed*.\n-            let pred = fcx.normalize_associated_types_in(sp, pred);\n+            let pred = wfcx.normalize(sp, None, pred);\n             let cause = traits::ObligationCause::new(\n                 sp,\n-                fcx.body_id,\n+                wfcx.body_id,\n                 traits::ItemObligation(def_id.to_def_id()),\n             );\n-            traits::Obligation::new(cause, fcx.param_env, pred)\n+            traits::Obligation::new(cause, wfcx.param_env, pred)\n         });\n \n     let predicates = predicates.instantiate_identity(tcx);\n \n-    let predicates = fcx.normalize_associated_types_in(span, predicates);\n+    let predicates = wfcx.normalize(span, None, predicates);\n \n     debug!(?predicates.predicates);\n     assert_eq!(predicates.predicates.len(), predicates.spans.len());\n     let wf_obligations =\n         iter::zip(&predicates.predicates, &predicates.spans).flat_map(|(&p, &sp)| {\n-            traits::wf::predicate_obligations(fcx, fcx.param_env, fcx.body_id, p, sp)\n+            traits::wf::predicate_obligations(infcx, wfcx.param_env, wfcx.body_id, p, sp)\n         });\n \n-    for obligation in wf_obligations.chain(default_obligations) {\n-        debug!(\"next obligation cause: {:?}\", obligation.cause);\n-        fcx.register_predicate(obligation);\n-    }\n+    let obligations: Vec<_> = wf_obligations.chain(default_obligations).collect();\n+    wfcx.register_obligations(obligations);\n }\n \n-#[tracing::instrument(level = \"debug\", skip(fcx, span, hir_decl))]\n-fn check_fn_or_method<'fcx, 'tcx>(\n-    fcx: &FnCtxt<'fcx, 'tcx>,\n+#[tracing::instrument(level = \"debug\", skip(wfcx, span, hir_decl))]\n+fn check_fn_or_method<'tcx>(\n+    wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     span: Span,\n     sig: ty::PolyFnSig<'tcx>,\n     hir_decl: &hir::FnDecl<'_>,\n     def_id: LocalDefId,\n     implied_bounds: &mut FxHashSet<Ty<'tcx>>,\n ) {\n-    let sig = fcx.tcx.liberate_late_bound_regions(def_id.to_def_id(), sig);\n+    let tcx = wfcx.tcx();\n+    let sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), sig);\n \n     // Normalize the input and output types one at a time, using a different\n     // `WellFormedLoc` for each. We cannot call `normalize_associated_types`\n     // on the entire `FnSig`, since this would use the same `WellFormedLoc`\n     // for each type, preventing the HIR wf check from generating\n     // a nice error message.\n     let ty::FnSig { mut inputs_and_output, c_variadic, unsafety, abi } = sig;\n-    inputs_and_output =\n-        fcx.tcx.mk_type_list(inputs_and_output.iter().enumerate().map(|(i, ty)| {\n-            fcx.normalize_associated_types_in_wf(\n-                span,\n-                ty,\n-                WellFormedLoc::Param {\n-                    function: def_id,\n-                    // Note that the `param_idx` of the output type is\n-                    // one greater than the index of the last input type.\n-                    param_idx: i.try_into().unwrap(),\n-                },\n-            )\n-        }));\n+    inputs_and_output = tcx.mk_type_list(inputs_and_output.iter().enumerate().map(|(i, ty)| {\n+        wfcx.normalize(\n+            span,\n+            Some(WellFormedLoc::Param {\n+                function: def_id,\n+                // Note that the `param_idx` of the output type is\n+                // one greater than the index of the last input type.\n+                param_idx: i.try_into().unwrap(),\n+            }),\n+            ty,\n+        )\n+    }));\n     // Manually call `normalize_associated_types_in` on the other types\n     // in `FnSig`. This ensures that if the types of these fields\n     // ever change to include projections, we will start normalizing\n     // them automatically.\n     let sig = ty::FnSig {\n         inputs_and_output,\n-        c_variadic: fcx.normalize_associated_types_in(span, c_variadic),\n-        unsafety: fcx.normalize_associated_types_in(span, unsafety),\n-        abi: fcx.normalize_associated_types_in(span, abi),\n+        c_variadic: wfcx.normalize(span, None, c_variadic),\n+        unsafety: wfcx.normalize(span, None, unsafety),\n+        abi: wfcx.normalize(span, None, abi),\n     };\n \n     for (i, (&input_ty, ty)) in iter::zip(sig.inputs(), hir_decl.inputs).enumerate() {\n-        fcx.register_wf_obligation(\n-            input_ty.into(),\n+        wfcx.register_wf_obligation(\n             ty.span,\n-            ObligationCauseCode::WellFormed(Some(WellFormedLoc::Param {\n-                function: def_id,\n-                param_idx: i.try_into().unwrap(),\n-            })),\n+            Some(WellFormedLoc::Param { function: def_id, param_idx: i.try_into().unwrap() }),\n+            input_ty.into(),\n         );\n     }\n \n     implied_bounds.extend(sig.inputs());\n \n-    fcx.register_wf_obligation(\n-        sig.output().into(),\n-        hir_decl.output.span(),\n-        ObligationCauseCode::ReturnType,\n-    );\n+    wfcx.register_wf_obligation(hir_decl.output.span(), None, sig.output().into());\n \n     // FIXME(#27579) return types should not be implied bounds\n     implied_bounds.insert(sig.output());\n \n     debug!(?implied_bounds);\n \n-    check_where_clauses(fcx, span, def_id);\n+    check_where_clauses(wfcx, span, def_id);\n }\n \n const HELP_FOR_SELF_TYPE: &str = \"consider changing to `self`, `&self`, `&mut self`, `self: Box<Self>`, \\\n      `self: Rc<Self>`, `self: Arc<Self>`, or `self: Pin<P>` (where P is one \\\n      of the previous types except `Self`)\";\n \n-#[tracing::instrument(level = \"debug\", skip(fcx))]\n-fn check_method_receiver<'fcx, 'tcx>(\n-    fcx: &FnCtxt<'fcx, 'tcx>,\n+#[tracing::instrument(level = \"debug\", skip(wfcx))]\n+fn check_method_receiver<'tcx>(\n+    wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     fn_sig: &hir::FnSig<'_>,\n     method: &ty::AssocItem,\n     self_ty: Ty<'tcx>,\n ) {\n-    // Check that the method has a valid receiver type, given the type `Self`.\n-    debug!(\"check_method_receiver({:?}, self_ty={:?})\", method, self_ty);\n+    let tcx = wfcx.tcx();\n \n     if !method.fn_has_self_parameter {\n         return;\n     }\n \n     let span = fn_sig.decl.inputs[0].span;\n \n-    let sig = fcx.tcx.fn_sig(method.def_id);\n-    let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, sig);\n-    let sig = fcx.normalize_associated_types_in(span, sig);\n+    let sig = tcx.fn_sig(method.def_id);\n+    let sig = tcx.liberate_late_bound_regions(method.def_id, sig);\n+    let sig = wfcx.normalize(span, None, sig);\n \n     debug!(\"check_method_receiver: sig={:?}\", sig);\n \n-    let self_ty = fcx.normalize_associated_types_in(span, self_ty);\n+    let self_ty = wfcx.normalize(span, None, self_ty);\n \n     let receiver_ty = sig.inputs()[0];\n-    let receiver_ty = fcx.normalize_associated_types_in(span, receiver_ty);\n+    let receiver_ty = wfcx.normalize(span, None, receiver_ty);\n \n-    if fcx.tcx.features().arbitrary_self_types {\n-        if !receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {\n+    if tcx.features().arbitrary_self_types {\n+        if !receiver_is_valid(wfcx, span, receiver_ty, self_ty, true) {\n             // Report error; `arbitrary_self_types` was enabled.\n-            e0307(fcx, span, receiver_ty);\n+            e0307(tcx, span, receiver_ty);\n         }\n     } else {\n-        if !receiver_is_valid(fcx, span, receiver_ty, self_ty, false) {\n-            if receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {\n+        if !receiver_is_valid(wfcx, span, receiver_ty, self_ty, false) {\n+            if receiver_is_valid(wfcx, span, receiver_ty, self_ty, true) {\n                 // Report error; would have worked with `arbitrary_self_types`.\n                 feature_err(\n-                    &fcx.tcx.sess.parse_sess,\n+                    &tcx.sess.parse_sess,\n                     sym::arbitrary_self_types,\n                     span,\n                     &format!(\n@@ -1578,15 +1574,15 @@ fn check_method_receiver<'fcx, 'tcx>(\n                 .emit();\n             } else {\n                 // Report error; would not have worked with `arbitrary_self_types`.\n-                e0307(fcx, span, receiver_ty);\n+                e0307(tcx, span, receiver_ty);\n             }\n         }\n     }\n }\n \n-fn e0307<'tcx>(fcx: &FnCtxt<'_, 'tcx>, span: Span, receiver_ty: Ty<'_>) {\n+fn e0307<'tcx>(tcx: TyCtxt<'tcx>, span: Span, receiver_ty: Ty<'_>) {\n     struct_span_err!(\n-        fcx.tcx.sess.diagnostic(),\n+        tcx.sess.diagnostic(),\n         span,\n         E0307,\n         \"invalid `self` parameter type: {receiver_ty}\"\n@@ -1605,26 +1601,30 @@ fn e0307<'tcx>(fcx: &FnCtxt<'_, 'tcx>, span: Span, receiver_ty: Ty<'_>) {\n /// N.B., there are cases this function returns `true` but causes an error to be emitted,\n /// particularly when `receiver_ty` derefs to a type that is the same as `self_ty` but has the\n /// wrong lifetime. Be careful of this if you are calling this function speculatively.\n-fn receiver_is_valid<'fcx, 'tcx>(\n-    fcx: &FnCtxt<'fcx, 'tcx>,\n+fn receiver_is_valid<'tcx>(\n+    wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     span: Span,\n     receiver_ty: Ty<'tcx>,\n     self_ty: Ty<'tcx>,\n     arbitrary_self_types_enabled: bool,\n ) -> bool {\n-    let cause = fcx.cause(span, traits::ObligationCauseCode::MethodReceiver);\n+    let infcx = wfcx.infcx;\n+    let tcx = wfcx.tcx();\n+    let cause =\n+        ObligationCause::new(span, wfcx.body_id, traits::ObligationCauseCode::MethodReceiver);\n \n-    let can_eq_self = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n+    let can_eq_self = |ty| infcx.can_eq(wfcx.param_env, self_ty, ty).is_ok();\n \n     // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {\n-        if let Some(mut err) = fcx.demand_eqtype_with_origin(&cause, self_ty, receiver_ty) {\n-            err.emit();\n+        if let Err(err) = wfcx.equate_types(&cause, wfcx.param_env, self_ty, receiver_ty) {\n+            infcx.report_mismatched_types(&cause, self_ty, receiver_ty, err).emit();\n         }\n         return true;\n     }\n \n-    let mut autoderef = fcx.autoderef(span, receiver_ty);\n+    let mut autoderef =\n+        Autoderef::new(infcx, wfcx.param_env, wfcx.body_id, span, receiver_ty, span);\n \n     // The `arbitrary_self_types` feature allows raw pointer receivers like `self: *const Self`.\n     if arbitrary_self_types_enabled {\n@@ -1634,7 +1634,7 @@ fn receiver_is_valid<'fcx, 'tcx>(\n     // The first type is `receiver_ty`, which we know its not equal to `self_ty`; skip it.\n     autoderef.next();\n \n-    let receiver_trait_def_id = fcx.tcx.require_lang_item(LangItem::Receiver, None);\n+    let receiver_trait_def_id = tcx.require_lang_item(LangItem::Receiver, None);\n \n     // Keep dereferencing `receiver_ty` until we get to `self_ty`.\n     loop {\n@@ -1645,12 +1645,12 @@ fn receiver_is_valid<'fcx, 'tcx>(\n             );\n \n             if can_eq_self(potential_self_ty) {\n-                fcx.register_predicates(autoderef.into_obligations());\n+                wfcx.register_obligations(autoderef.into_obligations());\n \n-                if let Some(mut err) =\n-                    fcx.demand_eqtype_with_origin(&cause, self_ty, potential_self_ty)\n+                if let Err(err) =\n+                    wfcx.equate_types(&cause, wfcx.param_env, self_ty, potential_self_ty)\n                 {\n-                    err.emit();\n+                    infcx.report_mismatched_types(&cause, self_ty, potential_self_ty, err).emit();\n                 }\n \n                 break;\n@@ -1659,7 +1659,7 @@ fn receiver_is_valid<'fcx, 'tcx>(\n                 // deref chain implement `receiver`\n                 if !arbitrary_self_types_enabled\n                     && !receiver_is_implemented(\n-                        fcx,\n+                        wfcx,\n                         receiver_trait_def_id,\n                         cause.clone(),\n                         potential_self_ty,\n@@ -1678,7 +1678,7 @@ fn receiver_is_valid<'fcx, 'tcx>(\n \n     // Without `feature(arbitrary_self_types)`, we require that `receiver_ty` implements `Receiver`.\n     if !arbitrary_self_types_enabled\n-        && !receiver_is_implemented(fcx, receiver_trait_def_id, cause.clone(), receiver_ty)\n+        && !receiver_is_implemented(wfcx, receiver_trait_def_id, cause.clone(), receiver_ty)\n     {\n         return false;\n     }\n@@ -1687,23 +1687,21 @@ fn receiver_is_valid<'fcx, 'tcx>(\n }\n \n fn receiver_is_implemented<'tcx>(\n-    fcx: &FnCtxt<'_, 'tcx>,\n+    wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     receiver_trait_def_id: DefId,\n     cause: ObligationCause<'tcx>,\n     receiver_ty: Ty<'tcx>,\n ) -> bool {\n+    let tcx = wfcx.tcx();\n     let trait_ref = ty::Binder::dummy(ty::TraitRef {\n         def_id: receiver_trait_def_id,\n-        substs: fcx.tcx.mk_substs_trait(receiver_ty, &[]),\n+        substs: tcx.mk_substs_trait(receiver_ty, &[]),\n     });\n \n-    let obligation = traits::Obligation::new(\n-        cause,\n-        fcx.param_env,\n-        trait_ref.without_const().to_predicate(fcx.tcx),\n-    );\n+    let obligation =\n+        traits::Obligation::new(cause, wfcx.param_env, trait_ref.without_const().to_predicate(tcx));\n \n-    if fcx.predicate_must_hold_modulo_regions(&obligation) {\n+    if wfcx.infcx.predicate_must_hold_modulo_regions(&obligation) {\n         true\n     } else {\n         debug!(\n@@ -1805,55 +1803,56 @@ fn report_bivariance(\n     err.emit()\n }\n \n-/// Feature gates RFC 2056 -- trivial bounds, checking for global bounds that\n-/// aren't true.\n-fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, mut span: Span, id: hir::HirId) {\n-    let empty_env = ty::ParamEnv::empty();\n-\n-    let def_id = fcx.tcx.hir().local_def_id(id);\n-    let predicates_with_span =\n-        fcx.tcx.predicates_of(def_id).predicates.iter().map(|(p, span)| (*p, *span));\n-    // Check elaborated bounds.\n-    let implied_obligations = traits::elaborate_predicates_with_span(fcx.tcx, predicates_with_span);\n-\n-    for obligation in implied_obligations {\n-        // We lower empty bounds like `Vec<dyn Copy>:` as\n-        // `WellFormed(Vec<dyn Copy>)`, which will later get checked by\n-        // regular WF checking\n-        if let ty::PredicateKind::WellFormed(..) = obligation.predicate.kind().skip_binder() {\n-            continue;\n-        }\n-        let pred = obligation.predicate;\n-        // Match the existing behavior.\n-        if pred.is_global() && !pred.has_late_bound_regions() {\n-            let pred = fcx.normalize_associated_types_in(span, pred);\n-            let hir_node = fcx.tcx.hir().find(id);\n+impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n+    /// Feature gates RFC 2056 -- trivial bounds, checking for global bounds that\n+    /// aren't true.\n+    fn check_false_global_bounds(&mut self) {\n+        let tcx = self.ocx.infcx.tcx;\n+        let mut span = self.span;\n+        let empty_env = ty::ParamEnv::empty();\n+\n+        let def_id = tcx.hir().local_def_id(self.body_id);\n+        let predicates_with_span = tcx.predicates_of(def_id).predicates.iter().copied();\n+        // Check elaborated bounds.\n+        let implied_obligations = traits::elaborate_predicates_with_span(tcx, predicates_with_span);\n+\n+        for obligation in implied_obligations {\n+            // We lower empty bounds like `Vec<dyn Copy>:` as\n+            // `WellFormed(Vec<dyn Copy>)`, which will later get checked by\n+            // regular WF checking\n+            if let ty::PredicateKind::WellFormed(..) = obligation.predicate.kind().skip_binder() {\n+                continue;\n+            }\n+            let pred = obligation.predicate;\n+            // Match the existing behavior.\n+            if pred.is_global() && !pred.has_late_bound_regions() {\n+                let pred = self.normalize(span, None, pred);\n+                let hir_node = tcx.hir().find(self.body_id);\n \n-            // only use the span of the predicate clause (#90869)\n+                // only use the span of the predicate clause (#90869)\n \n-            if let Some(hir::Generics { predicates, .. }) =\n-                hir_node.and_then(|node| node.generics())\n-            {\n-                let obligation_span = obligation.cause.span();\n-\n-                span = predicates\n-                    .iter()\n-                    // There seems to be no better way to find out which predicate we are in\n-                    .find(|pred| pred.span().contains(obligation_span))\n-                    .map(|pred| pred.span())\n-                    .unwrap_or(obligation_span);\n-            }\n+                if let Some(hir::Generics { predicates, .. }) =\n+                    hir_node.and_then(|node| node.generics())\n+                {\n+                    let obligation_span = obligation.cause.span();\n+\n+                    span = predicates\n+                        .iter()\n+                        // There seems to be no better way to find out which predicate we are in\n+                        .find(|pred| pred.span().contains(obligation_span))\n+                        .map(|pred| pred.span())\n+                        .unwrap_or(obligation_span);\n+                }\n \n-            let obligation = traits::Obligation::new(\n-                traits::ObligationCause::new(span, id, traits::TrivialBound),\n-                empty_env,\n-                pred,\n-            );\n-            fcx.register_predicate(obligation);\n+                let obligation = traits::Obligation::new(\n+                    traits::ObligationCause::new(span, self.body_id, traits::TrivialBound),\n+                    empty_env,\n+                    pred,\n+                );\n+                self.ocx.register_obligation(obligation);\n+            }\n         }\n     }\n-\n-    fcx.select_all_obligations_or_error();\n }\n \n fn check_mod_type_wf(tcx: TyCtxt<'_>, module: LocalDefId) {\n@@ -1883,17 +1882,16 @@ struct AdtField<'tcx> {\n     span: Span,\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> WfCheckingCtxt<'a, 'tcx> {\n     // FIXME(eddyb) replace this with getting fields through `ty::AdtDef`.\n     fn non_enum_variant(&self, struct_def: &hir::VariantData<'_>) -> AdtVariant<'tcx> {\n         let fields = struct_def\n             .fields()\n             .iter()\n             .map(|field| {\n-                let def_id = self.tcx.hir().local_def_id(field.hir_id);\n-                let field_ty = self.tcx.type_of(def_id);\n-                let field_ty = self.normalize_associated_types_in(field.ty.span, field_ty);\n-                let field_ty = self.resolve_vars_if_possible(field_ty);\n+                let def_id = self.tcx().hir().local_def_id(field.hir_id);\n+                let field_ty = self.tcx().type_of(def_id);\n+                let field_ty = self.normalize(field.ty.span, None, field_ty);\n                 debug!(\"non_enum_variant: type of field {:?} is {:?}\", field, field_ty);\n                 AdtField { ty: field_ty, span: field.ty.span, def_id }\n             })\n@@ -1909,7 +1907,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 fields: self.non_enum_variant(&variant.data).fields,\n                 explicit_discr: variant\n                     .disr_expr\n-                    .map(|explicit_discr| self.tcx.hir().local_def_id(explicit_discr.hir_id)),\n+                    .map(|explicit_discr| self.tcx().hir().local_def_id(explicit_discr.hir_id)),\n             })\n             .collect()\n     }"}, {"sha": "1a600affb31450336689d067da75e03f765827a8", "filename": "src/test/ui/builtin-superkinds/builtin-superkinds-self-type.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -2,17 +2,15 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/builtin-superkinds-self-type.rs:10:16\n    |\n LL | impl <T: Sync> Foo for T { }\n-   |                ^^^ ...so that the type `T` will meet its required lifetime bounds...\n+   |                ^^^\n    |\n+   = help: consider adding an explicit lifetime bound `T: 'static`...\n+   = note: ...so that the type `T` will meet its required lifetime bounds...\n note: ...that is required by this bound\n   --> $DIR/builtin-superkinds-self-type.rs:6:24\n    |\n LL | trait Foo : Sized+Sync+'static {\n    |                        ^^^^^^^\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | impl <T: Sync + 'static> Foo for T { }\n-   |               +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "3db0a96960f89b31af147e3cdfd9b87ff2bdd1ff", "filename": "src/test/ui/lifetimes/lifetime-doesnt-live-long-enough.stderr", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -2,45 +2,37 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:19:10\n    |\n LL |     foo: &'static T\n-   |          ^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n+   |          ^^^^^^^^^^\n    |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | struct Foo<T: 'static> {\n-   |             +++++++++\n+   = help: consider adding an explicit lifetime bound `T: 'static`...\n+   = note: ...so that the reference type `&'static T` does not outlive the data it points at\n \n error[E0309]: the parameter type `K` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:41:33\n    |\n LL |     fn generic_in_parent<'a, L: X<&'a Nested<K>>>() {\n-   |                                 ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n-   |\n-help: consider adding an explicit lifetime bound...\n+   |                                 ^^^^^^^^^^^^^^^^\n    |\n-LL | impl<K: 'a> Nested<K> {\n-   |       ++++\n+   = help: consider adding an explicit lifetime bound `K: 'a`...\n+   = note: ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n \n error[E0309]: the parameter type `M` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:44:36\n    |\n LL |     fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b>() {\n-   |                                    ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<M>` does not outlive the data it points at\n-   |\n-help: consider adding an explicit lifetime bound...\n+   |                                    ^^^^^^^^^^^^^^^^\n    |\n-LL |     fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b + 'a>() {\n-   |                                                            ++++\n+   = help: consider adding an explicit lifetime bound `M: 'a`...\n+   = note: ...so that the reference type `&'a Nested<M>` does not outlive the data it points at\n \n error[E0309]: the parameter type `K` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:24:19\n    |\n LL |     fn foo<'a, L: X<&'a Nested<K>>>();\n-   |                   ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n+   |                   ^^^^^^^^^^^^^^^^\n    |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | trait X<K: 'a>: Sized {\n-   |          ++++\n+   = help: consider adding an explicit lifetime bound `K: 'a`...\n+   = note: ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n \n error[E0309]: the parameter type `Self` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:28:19\n@@ -55,12 +47,10 @@ error[E0309]: the parameter type `L` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:32:22\n    |\n LL |     fn baz<'a, L, M: X<&'a Nested<L>>>() {\n-   |                      ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<L>` does not outlive the data it points at\n-   |\n-help: consider adding an explicit lifetime bound...\n+   |                      ^^^^^^^^^^^^^^^^\n    |\n-LL |     fn baz<'a, L: 'a, M: X<&'a Nested<L>>>() {\n-   |                 ++++\n+   = help: consider adding an explicit lifetime bound `L: 'a`...\n+   = note: ...so that the reference type `&'a Nested<L>` does not outlive the data it points at\n \n error: aborting due to 6 previous errors\n "}, {"sha": "8ace0087710cab743e92eea556ee03c225c101f8", "filename": "src/test/ui/rfc-2093-infer-outlives/dont-infer-static.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -2,17 +2,15 @@ error[E0310]: the parameter type `U` may not live long enough\n   --> $DIR/dont-infer-static.rs:6:10\n    |\n LL |     bar: Bar<U>\n-   |          ^^^^^^ ...so that the type `U` will meet its required lifetime bounds...\n+   |          ^^^^^^\n    |\n+   = help: consider adding an explicit lifetime bound `U: 'static`...\n+   = note: ...so that the type `U` will meet its required lifetime bounds...\n note: ...that is required by this bound\n   --> $DIR/dont-infer-static.rs:8:15\n    |\n LL | struct Bar<T: 'static> {\n    |               ^^^^^^^\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | struct Foo<U: 'static> {\n-   |             +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "2444046a16d67fe3b2f2c1d8d904b890169ab5e2", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-enum-not-wf.stderr", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -2,34 +2,28 @@ error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:17:18\n    |\n LL |     Ref1Variant1(RequireOutlives<'a, T>),\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | enum Ref1<'a, T: 'a> {\n-   |                ++++\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n+   = note: ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:22:25\n    |\n LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |\n-help: consider adding an explicit lifetime bound...\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL | enum Ref2<'a, T: 'a> {\n-   |                ++++\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n+   = note: ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:35:23\n    |\n LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>),\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |\n-help: consider adding an explicit lifetime bound...\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL | enum RefDouble<'a, 'b, T: 'b> {\n-   |                         ++++\n+   = help: consider adding an explicit lifetime bound `T: 'b`...\n+   = note: ...so that the type `T` will meet its required lifetime bounds\n \n error: aborting due to 3 previous errors\n "}, {"sha": "674bfa9633eae7db3ba7653b26eadb3a8cbe2a3a", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-struct-not-wf.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -2,28 +2,24 @@ error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-struct-not-wf.rs:13:16\n    |\n LL |     type Out = &'a T;\n-   |                ^^^^^ ...so that the reference type `&'a T` does not outlive the data it points at\n+   |                ^^^^^\n    |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | impl<'a, T: 'a> Trait<'a, T> for usize {\n-   |           ++++\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n+   = note: ...so that the reference type `&'a T` does not outlive the data it points at\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-struct-not-wf.rs:21:16\n    |\n LL |     type Out = RefOk<'a, T>;\n-   |                ^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds...\n+   |                ^^^^^^^^^^^^\n    |\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n+   = note: ...so that the type `T` will meet its required lifetime bounds...\n note: ...that is required by this bound\n   --> $DIR/regions-struct-not-wf.rs:16:20\n    |\n LL | struct RefOk<'a, T:'a> {\n    |                    ^^\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | impl<'a, T: 'a> Trait<'a, T> for u32 {\n-   |           ++++\n \n error[E0491]: in type `&'a &'b T`, reference has a longer lifetime than the data it references\n   --> $DIR/regions-struct-not-wf.rs:25:16"}, {"sha": "1ae4bfbffa0a9364a371d23a7b21af93d2ec9927", "filename": "src/test/ui/wf/wf-impl-associated-type-region.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -2,12 +2,10 @@ error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/wf-impl-associated-type-region.rs:10:16\n    |\n LL |     type Bar = &'a T;\n-   |                ^^^^^ ...so that the reference type `&'a T` does not outlive the data it points at\n+   |                ^^^^^\n    |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | impl<'a, T: 'a> Foo<'a> for T {\n-   |           ++++\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n+   = note: ...so that the reference type `&'a T` does not outlive the data it points at\n \n error: aborting due to previous error\n "}, {"sha": "67fd639ee4ad537427b14cd33837a6e9a8dc331c", "filename": "src/test/ui/wf/wf-in-fn-type-static.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -2,23 +2,19 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/wf-in-fn-type-static.rs:13:8\n    |\n LL |     x: fn() -> &'static T\n-   |        ^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n+   |        ^^^^^^^^^^^^^^^^^^\n    |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | struct Foo<T: 'static> {\n-   |             +++++++++\n+   = help: consider adding an explicit lifetime bound `T: 'static`...\n+   = note: ...so that the reference type `&'static T` does not outlive the data it points at\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/wf-in-fn-type-static.rs:18:8\n    |\n LL |     x: fn(&'static T)\n-   |        ^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n-   |\n-help: consider adding an explicit lifetime bound...\n+   |        ^^^^^^^^^^^^^^\n    |\n-LL | struct Bar<T: 'static> {\n-   |             +++++++++\n+   = help: consider adding an explicit lifetime bound `T: 'static`...\n+   = note: ...so that the reference type `&'static T` does not outlive the data it points at\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8eb443ae2b71d86b9749d48dec9f8ef337c12def", "filename": "src/test/ui/wf/wf-in-obj-type-static.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -2,12 +2,10 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/wf-in-obj-type-static.rs:14:8\n    |\n LL |     x: dyn Object<&'static T>\n-   |        ^^^^^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n+   |        ^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | struct Foo<T: 'static> {\n-   |             +++++++++\n+   = help: consider adding an explicit lifetime bound `T: 'static`...\n+   = note: ...so that the reference type `&'static T` does not outlive the data it points at\n \n error: aborting due to previous error\n "}, {"sha": "535e0c6489aca568030830f7f2eb5dfc0dc5695f", "filename": "src/test/ui/wf/wf-outlives-ty-in-fn-or-trait.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b56fd9341d26a955b8ecf0bb6c444f403cb401a/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr?ref=4b56fd9341d26a955b8ecf0bb6c444f403cb401a", "patch": "@@ -2,23 +2,19 @@ error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/wf-outlives-ty-in-fn-or-trait.rs:9:16\n    |\n LL |     type Out = &'a fn(T);\n-   |                ^^^^^^^^^ ...so that the reference type `&'a fn(T)` does not outlive the data it points at\n+   |                ^^^^^^^^^\n    |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | impl<'a, T: 'a> Trait<'a, T> for usize {\n-   |           ++++\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n+   = note: ...so that the reference type `&'a fn(T)` does not outlive the data it points at\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/wf-outlives-ty-in-fn-or-trait.rs:19:16\n    |\n LL |     type Out = &'a dyn Baz<T>;\n-   |                ^^^^^^^^^^^^^^ ...so that the reference type `&'a (dyn Baz<T> + 'a)` does not outlive the data it points at\n-   |\n-help: consider adding an explicit lifetime bound...\n+   |                ^^^^^^^^^^^^^^\n    |\n-LL | impl<'a, T: 'a> Trait<'a, T> for u32 {\n-   |           ++++\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n+   = note: ...so that the reference type `&'a (dyn Baz<T> + 'a)` does not outlive the data it points at\n \n error: aborting due to 2 previous errors\n "}]}