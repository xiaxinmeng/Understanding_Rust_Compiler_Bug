{"sha": "1203e0866e6c3659775efcb8aecad21dc13ef38b", "node_id": "C_kwDOAAsO6NoAKDEyMDNlMDg2NmU2YzM2NTk3NzVlZmNiOGFlY2FkMjFkYzEzZWYzOGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-16T13:46:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-16T13:46:52Z"}, "message": "Auto merge of #106824 - m-ou-se:format-args-flatten, r=oli-obk\n\nFlatten/inline format_args!() and (string and int) literal arguments into format_args!()\n\nImplements https://github.com/rust-lang/rust/issues/78356\n\nGated behind `-Zflatten-format-args=yes`.\n\nPart of #99012\n\nThis change inlines string literals, integer literals and nested format_args!() into format_args!() during ast lowering, making all of the following pairs result in equivalent hir:\n\n```rust\nprintln!(\"Hello, {}!\", \"World\");\nprintln!(\"Hello, World!\");\n```\n\n```rust\nprintln!(\"[info] {}\", format_args!(\"error\"));\nprintln!(\"[info] error\");\n```\n\n```rust\nprintln!(\"[{}] {}\", status, format_args!(\"error: {}\", msg));\nprintln!(\"[{}] error: {}\", status, msg);\n```\n\n```rust\nprintln!(\"{} + {} = {}\", 1, 2, 1 + 2);\nprintln!(\"1 + 2 = {}\", 1 + 2);\n```\n\nAnd so on.\n\nThis is useful for macros. E.g. a `log::info!()` macro could just pass the tokens from the user directly into a `format_args!()` that gets efficiently flattened/inlined into a `format_args!(\"info: {}\")`.\n\nIt also means that `dbg!(x)` will have its file, line, and expression name inlined:\n\n```rust\neprintln!(\"[{}:{}] {} = {:#?}\", file!(), line!(), stringify!(x), x); // before\neprintln!(\"[example.rs:1] x = {:#?}\", x); // after\n```\n\nWhich can be nice in some cases, but also means a lot more unique static strings than before if dbg!() is used a lot.", "tree": {"sha": "649280a25f8efd4058120de4a4e104959b83e3f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/649280a25f8efd4058120de4a4e104959b83e3f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1203e0866e6c3659775efcb8aecad21dc13ef38b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1203e0866e6c3659775efcb8aecad21dc13ef38b", "html_url": "https://github.com/rust-lang/rust/commit/1203e0866e6c3659775efcb8aecad21dc13ef38b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1203e0866e6c3659775efcb8aecad21dc13ef38b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "html_url": "https://github.com/rust-lang/rust/commit/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13"}, {"sha": "a08016514847d39ae3096ff41f98759abf59bee8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a08016514847d39ae3096ff41f98759abf59bee8", "html_url": "https://github.com/rust-lang/rust/commit/a08016514847d39ae3096ff41f98759abf59bee8"}], "stats": {"total": 384, "additions": 330, "deletions": 54}, "files": [{"sha": "5d164bc4b3cf5052603e0c3ee8b5fc9103a19744", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -1184,6 +1184,15 @@ impl Expr {\n         expr\n     }\n \n+    pub fn peel_parens_and_refs(&self) -> &Expr {\n+        let mut expr = self;\n+        while let ExprKind::Paren(inner) | ExprKind::AddrOf(BorrowKind::Ref, _, inner) = &expr.kind\n+        {\n+            expr = inner;\n+        }\n+        expr\n+    }\n+\n     /// Attempts to reparse as `Ty` (for diagnostic purposes).\n     pub fn to_ty(&self) -> Option<P<Ty>> {\n         let kind = match &self.kind {"}, {"sha": "356b9bb6371e22b3227c09fa3caf43aa40b036d2", "filename": "compiler/rustc_ast/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fformat.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -131,8 +131,8 @@ impl FormatArguments {\n         &self.arguments[..]\n     }\n \n-    pub fn all_args_mut(&mut self) -> &mut [FormatArgument] {\n-        &mut self.arguments[..]\n+    pub fn all_args_mut(&mut self) -> &mut Vec<FormatArgument> {\n+        &mut self.arguments\n     }\n }\n "}, {"sha": "72352b138cbf47117cf738e78e4ce8bc95193bda", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 216, "deletions": 22, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -7,13 +7,172 @@ use rustc_hir as hir;\n use rustc_span::{\n     sym,\n     symbol::{kw, Ident},\n-    Span,\n+    Span, Symbol,\n };\n+use std::borrow::Cow;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     pub(crate) fn lower_format_args(&mut self, sp: Span, fmt: &FormatArgs) -> hir::ExprKind<'hir> {\n-        expand_format_args(self, sp, fmt)\n+        // Never call the const constructor of `fmt::Arguments` if the\n+        // format_args!() had any arguments _before_ flattening/inlining.\n+        let allow_const = fmt.arguments.all_args().is_empty();\n+        let mut fmt = Cow::Borrowed(fmt);\n+        if self.tcx.sess.opts.unstable_opts.flatten_format_args {\n+            fmt = flatten_format_args(fmt);\n+            fmt = inline_literals(fmt);\n+        }\n+        expand_format_args(self, sp, &fmt, allow_const)\n+    }\n+}\n+\n+/// Flattens nested `format_args!()` into one.\n+///\n+/// Turns\n+///\n+/// `format_args!(\"a {} {} {}.\", 1, format_args!(\"b{}!\", 2), 3)`\n+///\n+/// into\n+///\n+/// `format_args!(\"a {} b{}! {}.\", 1, 2, 3)`.\n+fn flatten_format_args(mut fmt: Cow<'_, FormatArgs>) -> Cow<'_, FormatArgs> {\n+    let mut i = 0;\n+    while i < fmt.template.len() {\n+        if let FormatArgsPiece::Placeholder(placeholder) = &fmt.template[i]\n+            && let FormatTrait::Display | FormatTrait::Debug = &placeholder.format_trait\n+            && let Ok(arg_index) = placeholder.argument.index\n+            && let arg = fmt.arguments.all_args()[arg_index].expr.peel_parens_and_refs()\n+            && let ExprKind::FormatArgs(_) = &arg.kind\n+            // Check that this argument is not used by any other placeholders.\n+            && fmt.template.iter().enumerate().all(|(j, p)|\n+                i == j ||\n+                !matches!(p, FormatArgsPiece::Placeholder(placeholder)\n+                    if placeholder.argument.index == Ok(arg_index))\n+            )\n+        {\n+            // Now we need to mutate the outer FormatArgs.\n+            // If this is the first time, this clones the outer FormatArgs.\n+            let fmt = fmt.to_mut();\n+\n+            // Take the inner FormatArgs out of the outer arguments, and\n+            // replace it by the inner arguments. (We can't just put those at\n+            // the end, because we need to preserve the order of evaluation.)\n+\n+            let args = fmt.arguments.all_args_mut();\n+            let remaining_args = args.split_off(arg_index + 1);\n+            let old_arg_offset = args.len();\n+            let mut fmt2 = &mut args.pop().unwrap().expr; // The inner FormatArgs.\n+            let fmt2 = loop { // Unwrap the Expr to get to the FormatArgs.\n+                match &mut fmt2.kind {\n+                    ExprKind::Paren(inner) | ExprKind::AddrOf(BorrowKind::Ref, _, inner) => fmt2 = inner,\n+                    ExprKind::FormatArgs(fmt2) => break fmt2,\n+                    _ => unreachable!(),\n+                }\n+            };\n+\n+            args.append(fmt2.arguments.all_args_mut());\n+            let new_arg_offset = args.len();\n+            args.extend(remaining_args);\n+\n+            // Correct the indexes that refer to the arguments after the newly inserted arguments.\n+            for_all_argument_indexes(&mut fmt.template, |index| {\n+                if *index >= old_arg_offset {\n+                    *index -= old_arg_offset;\n+                    *index += new_arg_offset;\n+                }\n+            });\n+\n+            // Now merge the placeholders:\n+\n+            let rest = fmt.template.split_off(i + 1);\n+            fmt.template.pop(); // remove the placeholder for the nested fmt args.\n+            // Insert the pieces from the nested format args, but correct any\n+            // placeholders to point to the correct argument index.\n+            for_all_argument_indexes(&mut fmt2.template, |index| *index += arg_index);\n+            fmt.template.append(&mut fmt2.template);\n+            fmt.template.extend(rest);\n+\n+            // Don't increment `i` here, so we recurse into the newly added pieces.\n+        } else {\n+            i += 1;\n+        }\n     }\n+    fmt\n+}\n+\n+/// Inline literals into the format string.\n+///\n+/// Turns\n+///\n+/// `format_args!(\"Hello, {}! {} {}\", \"World\", 123, x)`\n+///\n+/// into\n+///\n+/// `format_args!(\"Hello, World! 123 {}\", x)`.\n+fn inline_literals(mut fmt: Cow<'_, FormatArgs>) -> Cow<'_, FormatArgs> {\n+    let mut was_inlined = vec![false; fmt.arguments.all_args().len()];\n+    let mut inlined_anything = false;\n+\n+    for i in 0..fmt.template.len() {\n+        let FormatArgsPiece::Placeholder(placeholder) = &fmt.template[i] else { continue };\n+        let Ok(arg_index) = placeholder.argument.index else { continue };\n+\n+        let mut literal = None;\n+\n+        if let FormatTrait::Display = placeholder.format_trait\n+            && placeholder.format_options == Default::default()\n+            && let arg = fmt.arguments.all_args()[arg_index].expr.peel_parens_and_refs()\n+            && let ExprKind::Lit(lit) = arg.kind\n+        {\n+            if let token::LitKind::Str | token::LitKind::StrRaw(_) = lit.kind\n+                && let Ok(LitKind::Str(s, _)) = LitKind::from_token_lit(lit)\n+            {\n+                literal = Some(s);\n+            } else if let token::LitKind::Integer = lit.kind\n+                && let Ok(LitKind::Int(n, _)) = LitKind::from_token_lit(lit)\n+            {\n+                literal = Some(Symbol::intern(&n.to_string()));\n+            }\n+        }\n+\n+        if let Some(literal) = literal {\n+            // Now we need to mutate the outer FormatArgs.\n+            // If this is the first time, this clones the outer FormatArgs.\n+            let fmt = fmt.to_mut();\n+            // Replace the placeholder with the literal.\n+            fmt.template[i] = FormatArgsPiece::Literal(literal);\n+            was_inlined[arg_index] = true;\n+            inlined_anything = true;\n+        }\n+    }\n+\n+    // Remove the arguments that were inlined.\n+    if inlined_anything {\n+        let fmt = fmt.to_mut();\n+\n+        let mut remove = was_inlined;\n+\n+        // Don't remove anything that's still used.\n+        for_all_argument_indexes(&mut fmt.template, |index| remove[*index] = false);\n+\n+        // Drop all the arguments that are marked for removal.\n+        let mut remove_it = remove.iter();\n+        fmt.arguments.all_args_mut().retain(|_| remove_it.next() != Some(&true));\n+\n+        // Calculate the mapping of old to new indexes for the remaining arguments.\n+        let index_map: Vec<usize> = remove\n+            .into_iter()\n+            .scan(0, |i, remove| {\n+                let mapped = *i;\n+                *i += !remove as usize;\n+                Some(mapped)\n+            })\n+            .collect();\n+\n+        // Correct the indexes that refer to arguments that have shifted position.\n+        for_all_argument_indexes(&mut fmt.template, |index| *index = index_map[*index]);\n+    }\n+\n+    fmt\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -189,11 +348,26 @@ fn expand_format_args<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n     macsp: Span,\n     fmt: &FormatArgs,\n+    allow_const: bool,\n ) -> hir::ExprKind<'hir> {\n+    let mut incomplete_lit = String::new();\n     let lit_pieces =\n         ctx.arena.alloc_from_iter(fmt.template.iter().enumerate().filter_map(|(i, piece)| {\n             match piece {\n-                &FormatArgsPiece::Literal(s) => Some(ctx.expr_str(fmt.span, s)),\n+                &FormatArgsPiece::Literal(s) => {\n+                    // Coalesce adjacent literal pieces.\n+                    if let Some(FormatArgsPiece::Literal(_)) = fmt.template.get(i + 1) {\n+                        incomplete_lit.push_str(s.as_str());\n+                        None\n+                    } else if !incomplete_lit.is_empty() {\n+                        incomplete_lit.push_str(s.as_str());\n+                        let s = Symbol::intern(&incomplete_lit);\n+                        incomplete_lit.clear();\n+                        Some(ctx.expr_str(fmt.span, s))\n+                    } else {\n+                        Some(ctx.expr_str(fmt.span, s))\n+                    }\n+                }\n                 &FormatArgsPiece::Placeholder(_) => {\n                     // Inject empty string before placeholders when not already preceded by a literal piece.\n                     if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n@@ -244,6 +418,18 @@ fn expand_format_args<'hir>(\n \n     let arguments = fmt.arguments.all_args();\n \n+    if allow_const && arguments.is_empty() && argmap.is_empty() {\n+        // Generate:\n+        //     <core::fmt::Arguments>::new_const(lit_pieces)\n+        let new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_const,\n+        ));\n+        let new_args = ctx.arena.alloc_from_iter([lit_pieces]);\n+        return hir::ExprKind::Call(new, new_args);\n+    }\n+\n     // If the args array contains exactly all the original arguments once,\n     // in order, we can use a simple array instead of a `match` construction.\n     // However, if there's a yield point in any argument except the first one,\n@@ -290,25 +476,14 @@ fn expand_format_args<'hir>(\n         let args_ident = Ident::new(sym::args, macsp);\n         let (args_pat, args_hir_id) = ctx.pat_ident(macsp, args_ident);\n         let args = ctx.arena.alloc_from_iter(argmap.iter().map(|&(arg_index, ty)| {\n-            if let Some(arg) = arguments.get(arg_index) {\n-                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-                let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n-                let arg = ctx.arena.alloc(ctx.expr(\n-                    sp,\n-                    hir::ExprKind::Field(\n-                        args_ident_expr,\n-                        Ident::new(sym::integer(arg_index), macsp),\n-                    ),\n-                ));\n-                make_argument(ctx, sp, arg, ty)\n-            } else {\n-                ctx.expr(\n-                    macsp,\n-                    hir::ExprKind::Err(\n-                        ctx.tcx.sess.delay_span_bug(macsp, format!(\"no arg at {arg_index}\")),\n-                    ),\n-                )\n-            }\n+            let arg = &arguments[arg_index];\n+            let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+            let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n+            let arg = ctx.arena.alloc(ctx.expr(\n+                sp,\n+                hir::ExprKind::Field(args_ident_expr, Ident::new(sym::integer(arg_index), macsp)),\n+            ));\n+            make_argument(ctx, sp, arg, ty)\n         }));\n         let elements: Vec<_> = arguments\n             .iter()\n@@ -409,3 +584,22 @@ fn may_contain_yield_point(e: &ast::Expr) -> bool {\n     visitor.visit_expr(e);\n     visitor.0\n }\n+\n+fn for_all_argument_indexes(template: &mut [FormatArgsPiece], mut f: impl FnMut(&mut usize)) {\n+    for piece in template {\n+        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n+        if let Ok(index) = &mut placeholder.argument.index {\n+            f(index);\n+        }\n+        if let Some(FormatCount::Argument(FormatArgPosition { index: Ok(index), .. })) =\n+            &mut placeholder.format_options.width\n+        {\n+            f(index);\n+        }\n+        if let Some(FormatCount::Argument(FormatArgPosition { index: Ok(index), .. })) =\n+            &mut placeholder.format_options.precision\n+        {\n+            f(index);\n+        }\n+    }\n+}"}, {"sha": "014810dba9cce060cdb2eb87970cae6f352cc58e", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -744,6 +744,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(emit_thin_lto, false);\n     tracked!(export_executable_symbols, true);\n     tracked!(fewer_names, Some(true));\n+    tracked!(flatten_format_args, true);\n     tracked!(force_unstable_if_unmarked, true);\n     tracked!(fuel, Some((\"abc\".to_string(), 99)));\n     tracked!(function_sections, Some(false));"}, {"sha": "0548379dc2fc17ebaa53dfeeb8045c8684233657", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -1422,6 +1422,9 @@ options! {\n     fewer_names: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR) \\\n         (default: no)\"),\n+    flatten_format_args: bool = (false, parse_bool, [TRACKED],\n+        \"flatten nested format_args!() and literals into a simplified format_args!() call \\\n+        (default: no)\"),\n     force_unstable_if_unmarked: bool = (false, parse_bool, [TRACKED],\n         \"force all crates to be `rustc_private` unstable (default: no)\"),\n     fuel: Option<(String, u64)> = (None, parse_optimization_fuel, [TRACKED],"}, {"sha": "abe5af8f9e0cf137bd7ea26a7745f6b2d3591258", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -984,6 +984,7 @@ symbols! {\n         never_type_fallback,\n         new,\n         new_binary,\n+        new_const,\n         new_debug,\n         new_display,\n         new_lower_exp,"}, {"sha": "6d764237dc8ae429c17bc19fe81c7e99fb946018", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -392,8 +392,31 @@ enum FlagV1 {\n }\n \n impl<'a> Arguments<'a> {\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n+    pub const fn new_const(pieces: &'a [&'static str]) -> Self {\n+        if pieces.len() > 1 {\n+            panic!(\"invalid args\");\n+        }\n+        Arguments { pieces, fmt: None, args: &[] }\n+    }\n+\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n+    #[cfg(not(bootstrap))]\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n+    pub fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+        if pieces.len() < args.len() || pieces.len() > args.len() + 1 {\n+            panic!(\"invalid args\");\n+        }\n+        Arguments { pieces, fmt: None, args }\n+    }\n+\n+    #[cfg(bootstrap)]\n     #[doc(hidden)]\n     #[inline]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n@@ -417,8 +440,7 @@ impl<'a> Arguments<'a> {\n     #[doc(hidden)]\n     #[inline]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n-    pub const fn new_v1_formatted(\n+    pub fn new_v1_formatted(\n         pieces: &'a [&'static str],\n         args: &'a [ArgumentV1<'a>],\n         fmt: &'a [rt::v1::Argument],"}, {"sha": "dd0105c0eb4fa3862c66620b7f434c41687b1b42", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -111,7 +111,7 @@ pub const fn panic(expr: &'static str) -> ! {\n     // truncation and padding (even though none is used here). Using\n     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n     // output binary, saving up to a few kilobytes.\n-    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n+    panic_fmt(fmt::Arguments::new_const(&[expr]));\n }\n \n /// Like `panic`, but without unwinding and track_caller to reduce the impact on codesize.\n@@ -120,7 +120,7 @@ pub const fn panic(expr: &'static str) -> ! {\n #[lang = \"panic_nounwind\"] // needed by codegen for non-unwinding panics\n #[rustc_nounwind]\n pub fn panic_nounwind(expr: &'static str) -> ! {\n-    panic_nounwind_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n+    panic_nounwind_fmt(fmt::Arguments::new_const(&[expr]));\n }\n \n #[inline]"}, {"sha": "c1c80c46c78b7327f6eaf671884a1b4ee9a32cd4", "filename": "library/core/tests/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/library%2Fcore%2Ftests%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/library%2Fcore%2Ftests%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ffmt%2Fmod.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -22,11 +22,11 @@ fn test_pointer_formats_data_pointer() {\n #[test]\n fn test_estimated_capacity() {\n     assert_eq!(format_args!(\"\").estimated_capacity(), 0);\n-    assert_eq!(format_args!(\"{}\", \"\").estimated_capacity(), 0);\n+    assert_eq!(format_args!(\"{}\", {\"\"}).estimated_capacity(), 0);\n     assert_eq!(format_args!(\"Hello\").estimated_capacity(), 5);\n-    assert_eq!(format_args!(\"Hello, {}!\", \"\").estimated_capacity(), 16);\n-    assert_eq!(format_args!(\"{}, hello!\", \"World\").estimated_capacity(), 0);\n-    assert_eq!(format_args!(\"{}. 16-bytes piece\", \"World\").estimated_capacity(), 32);\n+    assert_eq!(format_args!(\"Hello, {}!\", {\"\"}).estimated_capacity(), 16);\n+    assert_eq!(format_args!(\"{}, hello!\", {\"World\"}).estimated_capacity(), 0);\n+    assert_eq!(format_args!(\"{}. 16-bytes piece\", {\"World\"}).estimated_capacity(), 32);\n }\n \n #[test]"}, {"sha": "c0e32068ecaccecb39ee2ca6d5fd476559163f54", "filename": "src/tools/clippy/clippy_utils/src/macros.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -533,6 +533,14 @@ struct FormatArgsValues<'tcx> {\n }\n \n impl<'tcx> FormatArgsValues<'tcx> {\n+    fn new_empty(format_string_span: SpanData) -> Self {\n+        Self {\n+            value_args: Vec::new(),\n+            pos_to_value_index: Vec::new(),\n+            format_string_span,\n+        }\n+    }\n+\n     fn new(args: &'tcx Expr<'tcx>, format_string_span: SpanData) -> Self {\n         let mut pos_to_value_index = Vec::new();\n         let mut value_args = Vec::new();\n@@ -997,12 +1005,13 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n             .find(|&name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))?;\n         let newline = macro_name == sym::format_args_nl;\n \n+        // ::core::fmt::Arguments::new_const(pieces)\n         // ::core::fmt::Arguments::new_v1(pieces, args)\n         // ::core::fmt::Arguments::new_v1_formatted(pieces, args, fmt, _unsafe_arg)\n-        if let ExprKind::Call(callee, [pieces, args, rest @ ..]) = expr.kind\n+        if let ExprKind::Call(callee, [pieces, rest @ ..]) = expr.kind\n             && let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind\n             && let TyKind::Path(QPath::LangItem(LangItem::FormatArguments, _, _)) = ty.kind\n-            && matches!(seg.ident.as_str(), \"new_v1\" | \"new_v1_formatted\")\n+            && matches!(seg.ident.as_str(), \"new_const\" | \"new_v1\" | \"new_v1_formatted\")\n         {\n             let format_string = FormatString::new(cx, pieces)?;\n \n@@ -1026,7 +1035,7 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n                 return None;\n             }\n \n-            let positions = if let Some(fmt_arg) = rest.first() {\n+            let positions = if let Some(fmt_arg) = rest.get(1) {\n                 // If the argument contains format specs, `new_v1_formatted(_, _, fmt, _)`, parse\n                 // them.\n \n@@ -1042,7 +1051,11 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n                 }))\n             };\n \n-            let values = FormatArgsValues::new(args, format_string.span.data());\n+            let values = if let Some(args) = rest.first() {\n+                FormatArgsValues::new(args, format_string.span.data())\n+            } else {\n+                FormatArgsValues::new_empty(format_string.span.data())\n+            };\n \n             let args = izip!(positions, parsed_args, parser.arg_places)\n                 .map(|(position, parsed_arg, arg_span)| {"}, {"sha": "4020a433d6254eed3bd15b5c642669293b80ce51", "filename": "tests/pretty/issue-4264.pp", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpretty%2Fissue-4264.pp?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -32,13 +32,11 @@\n         ({\n                 let res =\n                     ((::alloc::fmt::format as\n-                            for<'a> fn(Arguments<'a>) -> String {format})(((<#[lang = \"format_arguments\"]>::new_v1\n+                            for<'a> fn(Arguments<'a>) -> String {format})(((<#[lang = \"format_arguments\"]>::new_const\n                                 as\n-                                fn(&[&'static str], &[core::fmt::ArgumentV1<'_>]) -> Arguments<'_> {Arguments::<'_>::new_v1})((&([(\"test\"\n-                                            as &str)] as [&str; 1]) as &[&str; 1]),\n-                            (&([] as [core::fmt::ArgumentV1<'_>; 0]) as\n-                                &[core::fmt::ArgumentV1<'_>; 0])) as Arguments<'_>)) as\n-                        String);\n+                                fn(&[&'static str]) -> Arguments<'_> {Arguments::<'_>::new_const})((&([(\"test\"\n+                                            as &str)] as [&str; 1]) as &[&str; 1])) as Arguments<'_>))\n+                        as String);\n                 (res as String)\n             } as String);\n     } as ())"}, {"sha": "5ad38e4fd9821ab1e7fb34722c2c1694bb3846b7", "filename": "tests/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fz-help.stdout?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -44,6 +44,7 @@\n     -Z             export-executable-symbols=val -- export symbols from executables, as if they were dynamic libraries\n     -Z                 extra-const-ub-checks=val -- turns on more checks to detect const UB, which can be slow (default: no)\n     -Z                           fewer-names=val -- reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR) (default: no)\n+    -Z                   flatten-format-args=val -- flatten nested format_args!() and literals into a simplified format_args!() call (default: no)\n     -Z            force-unstable-if-unmarked=val -- force all crates to be `rustc_private` unstable (default: no)\n     -Z                                  fuel=val -- set the optimization fuel quota for a crate\n     -Z                     function-sections=val -- whether each function should go in its own section"}, {"sha": "f032ea779dd489094ba84c61f0887b6aa8e993bc", "filename": "tests/ui/borrowck/issue-64453.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fui%2Fborrowck%2Fissue-64453.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fui%2Fborrowck%2Fissue-64453.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-64453.stderr?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -1,4 +1,4 @@\n-error: `Arguments::<'a>::new_v1` is not yet stable as a const fn\n+error: `Arguments::<'a>::new_const` is not yet stable as a const fn\n   --> $DIR/issue-64453.rs:4:31\n    |\n LL | static settings_dir: String = format!(\"\");"}, {"sha": "5bdb2bf19543907e9f563257b3ec0096345f5342", "filename": "tests/ui/consts/const-eval/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -1,12 +1,13 @@\n const fn failure() {\n     panic!(\"{:?}\", 0);\n     //~^ ERROR cannot call non-const formatting macro in constant functions\n+    //~| ERROR cannot call non-const fn `Arguments::<'_>::new_v1` in constant functions\n }\n \n const fn print() {\n     println!(\"{:?}\", 0);\n     //~^ ERROR cannot call non-const formatting macro in constant functions\n-    //~| ERROR `Arguments::<'a>::new_v1` is not yet stable as a const fn\n+    //~| ERROR cannot call non-const fn `Arguments::<'_>::new_v1` in constant functions\n     //~| ERROR cannot call non-const fn `_print` in constant functions\n }\n "}, {"sha": "c39920d444def348c5676fa24508a05b9504bdcf", "filename": "tests/ui/consts/const-eval/format.stderr", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -7,26 +7,35 @@ LL |     panic!(\"{:?}\", 0);\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `$crate::const_format_args` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+error[E0015]: cannot call non-const fn `Arguments::<'_>::new_v1` in constant functions\n+  --> $DIR/format.rs:2:5\n+   |\n+LL |     panic!(\"{:?}\", 0);\n+   |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the macro `$crate::const_format_args` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error[E0015]: cannot call non-const formatting macro in constant functions\n-  --> $DIR/format.rs:7:22\n+  --> $DIR/format.rs:8:22\n    |\n LL |     println!(\"{:?}\", 0);\n    |                      ^\n    |\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `Arguments::<'a>::new_v1` is not yet stable as a const fn\n-  --> $DIR/format.rs:7:5\n+error[E0015]: cannot call non-const fn `Arguments::<'_>::new_v1` in constant functions\n+  --> $DIR/format.rs:8:5\n    |\n LL |     println!(\"{:?}\", 0);\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: add `#![feature(const_fmt_arguments_new)]` to the crate attributes to enable\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0015]: cannot call non-const fn `_print` in constant functions\n-  --> $DIR/format.rs:7:5\n+  --> $DIR/format.rs:8:5\n    |\n LL |     println!(\"{:?}\", 0);\n    |     ^^^^^^^^^^^^^^^^^^^\n@@ -63,33 +72,33 @@ LL |     panic!(\"{:?}\", 0);\n    = note: this note originates in the macro `$crate::const_format_args` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: erroneous constant used\n-  --> $DIR/format.rs:7:14\n+  --> $DIR/format.rs:8:14\n    |\n LL |     println!(\"{:?}\", 0);\n    |              ^^^^^^\n \n note: erroneous constant used\n-  --> $DIR/format.rs:7:14\n+  --> $DIR/format.rs:8:14\n    |\n LL |     println!(\"{:?}\", 0);\n    |              ^^^^^^\n \n note: erroneous constant used\n-  --> $DIR/format.rs:7:22\n+  --> $DIR/format.rs:8:22\n    |\n LL |     println!(\"{:?}\", 0);\n    |                      ^\n    |\n    = note: this note originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: erroneous constant used\n-  --> $DIR/format.rs:7:22\n+  --> $DIR/format.rs:8:22\n    |\n LL |     println!(\"{:?}\", 0);\n    |                      ^\n    |\n    = note: this note originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0015`."}, {"sha": "705dded169a1910dfb9c204a2c3dfb4c8f881dfe", "filename": "tests/ui/unpretty/flattened-format-args.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fui%2Funpretty%2Fflattened-format-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fui%2Funpretty%2Fflattened-format-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funpretty%2Fflattened-format-args.rs?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: -Zunpretty=hir -Zflatten-format-args=yes\n+// check-pass\n+\n+fn main() {\n+    let x = 1;\n+    // Should flatten to println!(\"a 123 b {x} xyz\\n\"):\n+    println!(\"a {} {}\", format_args!(\"{} b {x}\", 123), \"xyz\");\n+}"}, {"sha": "a8fe8da0024722466a222f9292e22b5987f2c6af", "filename": "tests/ui/unpretty/flattened-format-args.stdout", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fui%2Funpretty%2Fflattened-format-args.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1203e0866e6c3659775efcb8aecad21dc13ef38b/tests%2Fui%2Funpretty%2Fflattened-format-args.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funpretty%2Fflattened-format-args.stdout?ref=1203e0866e6c3659775efcb8aecad21dc13ef38b", "patch": "@@ -0,0 +1,16 @@\n+#[prelude_import]\n+use ::std::prelude::rust_2015::*;\n+#[macro_use]\n+extern crate std;\n+// compile-flags: -Zunpretty=hir -Zflatten-format-args=yes\n+// check-pass\n+\n+fn main() {\n+        let x = 1;\n+        // Should flatten to println!(\"a 123 b {x} xyz\\n\"):\n+        {\n+                ::std::io::_print(<#[lang = \"format_arguments\"]>::new_v1(&[\"a 123 b \",\n+                                    \" xyz\\n\"],\n+                        &[<#[lang = \"format_argument\"]>::new_display(&x)]));\n+            };\n+    }"}]}