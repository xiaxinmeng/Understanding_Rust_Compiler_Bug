{"sha": "3b4b90130fea3b2f5a8a52f2d19a3ace1c464efb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiNGI5MDEzMGZlYTNiMmY1YThhNTJmMmQxOWEzYWNlMWM0NjRlZmI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-23T09:27:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-23T19:43:58Z"}, "message": "Rollup merge of #22494 - msiemens:vec_map-append-split_off, r=Gankro", "tree": {"sha": "2bdfdfec0f521221ccc0c6024103c7010c656c50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bdfdfec0f521221ccc0c6024103c7010c656c50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b4b90130fea3b2f5a8a52f2d19a3ace1c464efb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4b90130fea3b2f5a8a52f2d19a3ace1c464efb", "html_url": "https://github.com/rust-lang/rust/commit/3b4b90130fea3b2f5a8a52f2d19a3ace1c464efb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b4b90130fea3b2f5a8a52f2d19a3ace1c464efb/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf7cde449b7e5086bf2fab3e4f0843d7a1a39ff0", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf7cde449b7e5086bf2fab3e4f0843d7a1a39ff0", "html_url": "https://github.com/rust-lang/rust/commit/bf7cde449b7e5086bf2fab3e4f0843d7a1a39ff0"}, {"sha": "25d3e01a5a0051f0894aaad2d096637737fdb10c", "url": "https://api.github.com/repos/rust-lang/rust/commits/25d3e01a5a0051f0894aaad2d096637737fdb10c", "html_url": "https://github.com/rust-lang/rust/commit/25d3e01a5a0051f0894aaad2d096637737fdb10c"}], "stats": {"total": 172, "additions": 170, "deletions": 2}, "files": [{"sha": "d92249379fa8fc36adf9100163b368069495eb20", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 170, "deletions": 2, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/3b4b90130fea3b2f5a8a52f2d19a3ace1c464efb/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4b90130fea3b2f5a8a52f2d19a3ace1c464efb/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=3b4b90130fea3b2f5a8a52f2d19a3ace1c464efb", "patch": "@@ -17,13 +17,13 @@ use self::Entry::*;\n \n use core::prelude::*;\n \n-use core::cmp::Ordering;\n+use core::cmp::{max, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::iter::{Enumerate, FilterMap, Map, FromIterator, IntoIterator};\n use core::iter;\n-use core::mem::replace;\n+use core::mem::{replace, swap};\n use core::ops::{Index, IndexMut};\n \n use {vec, slice};\n@@ -320,6 +320,95 @@ impl<V> VecMap<V> {\n         IntoIter { iter: self.v.into_iter().enumerate().filter_map(filter) }\n     }\n \n+    /// Moves all elements from `other` into the map while overwriting existing keys.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecMap;\n+    ///\n+    /// let mut a = VecMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    ///\n+    /// let mut b = VecMap::new();\n+    /// b.insert(3, \"c\");\n+    /// b.insert(4, \"d\");\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.len(), 4);\n+    /// assert_eq!(b.len(), 0);\n+    /// assert_eq!(a[1], \"a\");\n+    /// assert_eq!(a[2], \"b\");\n+    /// assert_eq!(a[3], \"c\");\n+    /// assert_eq!(a[4], \"d\");\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        self.extend(other.drain());\n+    }\n+\n+    /// Splits the collection into two at the given key.\n+    ///\n+    /// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n+    /// and the returned `Self` contains elements `[at, max_key)`.\n+    ///\n+    /// Note that the capacity of `self` does not change.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecMap;\n+    ///\n+    /// let mut a = VecMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"d\");\n+    ///\n+    /// let b = a.split_off(3);\n+    ///\n+    /// assert_eq!(a[1], \"a\");\n+    /// assert_eq!(a[2], \"b\");\n+    ///\n+    /// assert_eq!(b[3], \"c\");\n+    /// assert_eq!(b[4], \"d\");\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn split_off(&mut self, at: usize) -> Self {\n+        let mut other = VecMap::new();\n+\n+        if at == 0 {\n+            // Move all elements to other\n+            swap(self, &mut other);\n+            return other\n+        } else if at > self.v.len() {\n+            // No elements to copy\n+            return other;\n+        }\n+\n+        // Look up the index of the first non-None item\n+        let first_index = self.v.iter().position(|el| el.is_some());\n+        let start_index = match first_index {\n+            Some(index) => max(at, index),\n+            None => {\n+                // self has no elements\n+                return other;\n+            }\n+        };\n+\n+        // Fill the new VecMap with `None`s until `start_index`\n+        other.v.extend((0..start_index).map(|_| None));\n+\n+        // Move elements beginning with `start_index` from `self` into `other`\n+        other.v.extend(self.v[start_index..].iter_mut().map(|el| el.take()));\n+\n+        other\n+    }\n+\n     /// Returns an iterator visiting all key-value pairs in ascending order of\n     /// the keys, emptying (but not consuming) the original `VecMap`.\n     /// The iterator's element type is `(usize, &'r V)`. Keeps the allocated memory for reuse.\n@@ -1141,6 +1230,85 @@ mod test_map {\n         assert_eq!(map.len(), 0);\n     }\n \n+    #[test]\n+    fn test_append() {\n+        let mut a = VecMap::new();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+\n+        let mut b = VecMap::new();\n+        b.insert(3, \"d\");  // Overwrite element from a\n+        b.insert(4, \"e\");\n+        b.insert(5, \"f\");\n+\n+        a.append(&mut b);\n+\n+        assert_eq!(a.len(), 5);\n+        assert_eq!(b.len(), 0);\n+        // Capacity shouldn't change for possible reuse\n+        assert!(b.capacity() >= 4);\n+\n+        assert_eq!(a[1], \"a\");\n+        assert_eq!(a[2], \"b\");\n+        assert_eq!(a[3], \"d\");\n+        assert_eq!(a[4], \"e\");\n+        assert_eq!(a[5], \"f\");\n+    }\n+\n+    #[test]\n+    fn test_split_off() {\n+        // Split within the key range\n+        let mut a = VecMap::new();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+        a.insert(4, \"d\");\n+\n+        let b = a.split_off(3);\n+\n+        assert_eq!(a.len(), 2);\n+        assert_eq!(b.len(), 2);\n+\n+        assert_eq!(a[1], \"a\");\n+        assert_eq!(a[2], \"b\");\n+\n+        assert_eq!(b[3], \"c\");\n+        assert_eq!(b[4], \"d\");\n+\n+        // Split at 0\n+        a.clear();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+        a.insert(4, \"d\");\n+\n+        let b = a.split_off(0);\n+\n+        assert_eq!(a.len(), 0);\n+        assert_eq!(b.len(), 4);\n+        assert_eq!(b[1], \"a\");\n+        assert_eq!(b[2], \"b\");\n+        assert_eq!(b[3], \"c\");\n+        assert_eq!(b[4], \"d\");\n+\n+        // Split behind max_key\n+        a.clear();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+        a.insert(4, \"d\");\n+\n+        let b = a.split_off(5);\n+\n+        assert_eq!(a.len(), 4);\n+        assert_eq!(b.len(), 0);\n+        assert_eq!(a[1], \"a\");\n+        assert_eq!(a[2], \"b\");\n+        assert_eq!(a[3], \"c\");\n+        assert_eq!(a[4], \"d\");\n+    }\n+\n     #[test]\n     fn test_show() {\n         let mut map = VecMap::new();"}]}