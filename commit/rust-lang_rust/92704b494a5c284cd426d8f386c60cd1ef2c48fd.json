{"sha": "92704b494a5c284cd426d8f386c60cd1ef2c48fd", "node_id": "C_kwDOAAsO6NoAKDkyNzA0YjQ5NGE1YzI4NGNkNDI2ZDhmMzg2YzYwY2QxZWYyYzQ4ZmQ", "commit": {"author": {"name": "Evan Typanski", "email": "evan.typanski@microfocus.com", "date": "2022-06-23T14:35:14Z"}, "committer": {"name": "Evan Typanski", "email": "evan.typanski@microfocus.com", "date": "2022-06-23T14:35:14Z"}, "message": "Split constant check functions and simplify", "tree": {"sha": "445ad483ab57e66bc6da67a6e91527c5b2fe8119", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/445ad483ab57e66bc6da67a6e91527c5b2fe8119"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92704b494a5c284cd426d8f386c60cd1ef2c48fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92704b494a5c284cd426d8f386c60cd1ef2c48fd", "html_url": "https://github.com/rust-lang/rust/commit/92704b494a5c284cd426d8f386c60cd1ef2c48fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92704b494a5c284cd426d8f386c60cd1ef2c48fd/comments", "author": null, "committer": null, "parents": [{"sha": "0447cc7affa8c4086c12eafea1b1eda3883f6677", "url": "https://api.github.com/repos/rust-lang/rust/commits/0447cc7affa8c4086c12eafea1b1eda3883f6677", "html_url": "https://github.com/rust-lang/rust/commit/0447cc7affa8c4086c12eafea1b1eda3883f6677"}], "stats": {"total": 52, "additions": 21, "deletions": 31}, "files": [{"sha": "492bd4db4341b48809880f320294e5ec6744982d", "filename": "clippy_lints/src/manual_rem_euclid.rs", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/92704b494a5c284cd426d8f386c60cd1ef2c48fd/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92704b494a5c284cd426d8f386c60cd1ef2c48fd/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs?ref=92704b494a5c284cd426d8f386c60cd1ef2c48fd", "patch": "@@ -55,15 +55,16 @@ impl<'tcx> LateLintPass<'tcx> for ManualRemEuclid {\n             return;\n         }\n \n-        if let ExprKind::Binary(op1, ..) = expr.kind\n+        if let ExprKind::Binary(op1, expr1, right) = expr.kind\n             && op1.node == BinOpKind::Rem\n-            && let Some((const1, expr1)) = check_for_positive_int_constant(cx, expr, false)\n-            && let ExprKind::Binary(op2, ..) = expr1.kind\n+            && let Some(const1) = check_for_unsigned_int_constant(cx, right)\n+            && let ExprKind::Binary(op2, left, right) = expr1.kind\n             && op2.node == BinOpKind::Add\n-            && let Some((const2, expr2)) = check_for_positive_int_constant(cx, expr1, true)\n-            && let ExprKind::Binary(op3, ..) = expr2.kind\n+            && let Some((const2, expr2)) = check_for_either_unsigned_int_constant(cx, left, right)\n+            && let ExprKind::Binary(op3, expr3, right) = expr2.kind\n             && op3.node == BinOpKind::Rem\n-            && let Some((const3, expr3)) = check_for_positive_int_constant(cx, expr2, false)\n+            && let Some(const3) = check_for_unsigned_int_constant(cx, right)\n+            // Also ensures the const is nonzero since zero can't be a divisor\n             && const1 == const2 && const2 == const3\n             && let Some(hir_id) = path_to_local(expr3)\n             && let Some(Node::Binding(_)) = cx.tcx.hir().find(hir_id) {\n@@ -96,33 +97,22 @@ impl<'tcx> LateLintPass<'tcx> for ManualRemEuclid {\n     extract_msrv_attr!(LateContext);\n }\n \n-// Takes a binary expression and separates the operands into the int constant and the other\n-// operand. Ensures the int constant is positive. Operators that are not commutative must have the\n-// constant appear on the right hand side to return a value.\n-fn check_for_positive_int_constant<'a>(\n+// Checks if either the left or right expressions can be an unsigned int constant and returns that\n+// constant along with the other expression unchanged if so\n+fn check_for_either_unsigned_int_constant<'a>(\n     cx: &'a LateContext<'_>,\n-    expr: &'a Expr<'_>,\n-    is_commutative: bool,\n+    left: &'a Expr<'_>,\n+    right: &'a Expr<'_>,\n ) -> Option<(u128, &'a Expr<'a>)> {\n-    let (int_const, other_op) = if let ExprKind::Binary(_, left, right) = expr.kind {\n-        if let Some(int_const) = constant_full_int(cx, cx.typeck_results(), right) {\n-            (int_const, left)\n-        } else if is_commutative && let Some(int_const) = constant_full_int(cx, cx.typeck_results(), left) {\n-            (int_const, right)\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        return None;\n-    };\n+    check_for_unsigned_int_constant(cx, left)\n+        .map(|int_const| (int_const, right))\n+        .or_else(|| check_for_unsigned_int_constant(cx, right).map(|int_const| (int_const, left)))\n+}\n \n-    if int_const > FullInt::S(0) {\n-        let val = match int_const {\n-            FullInt::S(s) => s.try_into().ok()?,\n-            FullInt::U(u) => u,\n-        };\n-        Some((val, other_op))\n-    } else {\n-        None\n+fn check_for_unsigned_int_constant<'a>(cx: &'a LateContext<'_>, expr: &'a Expr<'_>) -> Option<u128> {\n+    let Some(int_const) = constant_full_int(cx, cx.typeck_results(), expr) else { return None };\n+    match int_const {\n+        FullInt::S(s) => s.try_into().ok(),\n+        FullInt::U(u) => Some(u),\n     }\n }"}]}