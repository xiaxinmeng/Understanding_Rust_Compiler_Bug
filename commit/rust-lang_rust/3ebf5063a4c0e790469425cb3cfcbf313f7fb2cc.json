{"sha": "3ebf5063a4c0e790469425cb3cfcbf313f7fb2cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYmY1MDYzYTRjMGU3OTA0Njk0MjVjYjNjZmNiZjMxM2Y3ZmIyY2M=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-17T10:38:46Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-17T10:38:46Z"}, "message": "Merge sum and product representations.", "tree": {"sha": "e458d9047e9bc7cee58554b81a5cc541fcfdf79d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e458d9047e9bc7cee58554b81a5cc541fcfdf79d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ebf5063a4c0e790469425cb3cfcbf313f7fb2cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ebf5063a4c0e790469425cb3cfcbf313f7fb2cc", "html_url": "https://github.com/rust-lang/rust/commit/3ebf5063a4c0e790469425cb3cfcbf313f7fb2cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ebf5063a4c0e790469425cb3cfcbf313f7fb2cc/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71ed95246502875331e97a4be98431b032247d83", "url": "https://api.github.com/repos/rust-lang/rust/commits/71ed95246502875331e97a4be98431b032247d83", "html_url": "https://github.com/rust-lang/rust/commit/71ed95246502875331e97a4be98431b032247d83"}], "stats": {"total": 163, "additions": 78, "deletions": 85}, "files": [{"sha": "da0eb95708acc6f9b0be7bc78566825954bb4a93", "filename": "src/interpreter.rs", "status": "modified", "additions": 72, "deletions": 71, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/3ebf5063a4c0e790469425cb3cfcbf313f7fb2cc/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebf5063a4c0e790469425cb3cfcbf313f7fb2cc/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=3ebf5063a4c0e790469425cb3cfcbf313f7fb2cc", "patch": "@@ -7,6 +7,7 @@ use rustc::mir::mir_map::MirMap;\n use rustc::mir::repr as mir;\n use rustc::util::nodemap::DefIdMap;\n use std::cell::RefCell;\n+use std::iter;\n use std::ops::Deref;\n use std::rc::Rc;\n use syntax::codemap::DUMMY_SP;\n@@ -211,8 +212,8 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 let adt_ptr = try!(self.eval_lvalue(discr));\n                 let adt_repr = self.lvalue_repr(discr);\n                 let discr_size = match adt_repr {\n-                    Repr::Sum { discr_size, .. } => discr_size,\n-                    _ => panic!(\"attmpted to switch on non-sum type\"),\n+                    Repr::Aggregate { discr_size, .. } => discr_size,\n+                    _ => panic!(\"attmpted to switch on non-aggregate type\"),\n                 };\n                 let discr_val = try!(self.memory.read_uint(adt_ptr, discr_size));\n                 TerminatorTarget::Block(targets[discr_val as usize])\n@@ -300,17 +301,22 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         Ok(target)\n     }\n \n-    fn assign_to_product(&mut self, dest: Pointer, dest_repr: &Repr,\n+    fn assign_to_aggregate(&mut self, dest: Pointer, dest_repr: &Repr, variant: usize,\n                          operands: &[mir::Operand<'tcx>]) -> EvalResult<()> {\n         match *dest_repr {\n-            Repr::Product { ref fields, .. } => {\n-                for (field, operand) in fields.iter().zip(operands) {\n+            Repr::Aggregate { discr_size, ref variants, .. } => {\n+                if discr_size > 0 {\n+                    let discr = variant as u64;\n+                    try!(self.memory.write_uint(dest, discr, discr_size));\n+                }\n+                let after_discr = dest.offset(discr_size as isize);\n+                for (field, operand) in variants[variant].iter().zip(operands) {\n                     let src = try!(self.eval_operand(operand));\n-                    let field_dest = dest.offset(field.offset as isize);\n+                    let field_dest = after_discr.offset(field.offset as isize);\n                     try!(self.memory.copy(src, field_dest, field.size));\n                 }\n             }\n-            _ => panic!(\"expected Repr::Product target\"),\n+            _ => panic!(\"expected Repr::Aggregate target\"),\n         }\n         Ok(())\n     }\n@@ -350,26 +356,10 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n             Aggregate(ref kind, ref operands) => {\n                 use rustc::mir::repr::AggregateKind::*;\n                 match *kind {\n-                    Tuple => self.assign_to_product(dest, &dest_repr, operands),\n+                    Tuple => self.assign_to_aggregate(dest, &dest_repr, 0, operands),\n \n-                    Adt(ref adt_def, variant_idx, _) => match adt_def.adt_kind() {\n-                        ty::AdtKind::Struct => self.assign_to_product(dest, &dest_repr, operands),\n-\n-                        ty::AdtKind::Enum => match dest_repr {\n-                            Repr::Sum { discr_size, ref variants, .. } => {\n-                                if discr_size > 0 {\n-                                    let discr = variant_idx as u64;\n-                                    try!(self.memory.write_uint(dest, discr, discr_size));\n-                                }\n-                                self.assign_to_product(\n-                                    dest.offset(discr_size as isize),\n-                                    &variants[variant_idx],\n-                                    operands\n-                                )\n-                            }\n-                            _ => panic!(\"expected Repr::Sum target\"),\n-                        }\n-                    },\n+                    Adt(_, variant_idx, _) =>\n+                        self.assign_to_aggregate(dest, &dest_repr, variant_idx, operands),\n \n                     Vec => match dest_repr {\n                         Repr::Array { elem_size, length } => {\n@@ -480,8 +470,11 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         use rustc::mir::tcx::LvalueTy;\n         match self.current_frame().mir.lvalue_ty(self.tcx, lvalue) {\n             LvalueTy::Ty { ty } => self.ty_to_repr(ty),\n-            LvalueTy::Downcast { ref adt_def, substs, variant_index } =>\n-                self.make_variant_repr(&adt_def.variants[variant_index], substs),\n+            LvalueTy::Downcast { ref adt_def, substs, variant_index } => {\n+                let field_tys = adt_def.variants[variant_index].fields.iter()\n+                    .map(|f| f.ty(self.tcx, substs));\n+                self.make_aggregate_repr(iter::once(field_tys))\n+            }\n         }\n     }\n \n@@ -502,14 +495,16 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n                     Field(field, _) => match base_repr {\n-                        Repr::Product { ref fields, .. } =>\n-                            base_ptr.offset(fields[field.index()].offset as isize),\n+                        Repr::Aggregate { discr_size: 0, ref variants, .. } => {\n+                            let fields = &variants[0];\n+                            base_ptr.offset(fields[field.index()].offset as isize)\n+                        }\n                         _ => panic!(\"field access on non-product type: {:?}\", base_repr),\n                     },\n \n                     Downcast(..) => match base_repr {\n-                        Repr::Sum { discr_size, .. } => base_ptr.offset(discr_size as isize),\n-                        _ => panic!(\"variant downcast on non-sum type\"),\n+                        Repr::Aggregate { discr_size, .. } => base_ptr.offset(discr_size as isize),\n+                        _ => panic!(\"variant downcast on non-aggregate type: {:?}\", base_repr),\n                     },\n \n                     Deref => try!(self.memory.read_ptr(base_ptr)),\n@@ -551,20 +546,45 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         }\n     }\n \n-    fn make_product_repr<I>(&self, iter: I) -> Repr where I: IntoIterator<Item = ty::Ty<'tcx>> {\n-        let mut size = 0;\n-        let fields = iter.into_iter().map(|ty| {\n-            let field_size = self.ty_to_repr(ty).size();\n-            let old_size = size;\n-            size += field_size;\n-            FieldRepr { offset: old_size, size: field_size }\n-        }).collect();\n-        Repr::Product { size: size, fields: fields }\n-    }\n+    fn make_aggregate_repr<V, F>(&self, variant_fields: V) -> Repr\n+        where V: IntoIterator<Item = F>, F: IntoIterator<Item = ty::Ty<'tcx>>\n+    {\n+        let mut variants = Vec::new();\n+        let mut max_variant_size = 0;\n+\n+        for field_tys in variant_fields {\n+            let mut fields = Vec::new();\n+            let mut size = 0;\n+\n+            for ty in field_tys {\n+                let field_size = self.ty_to_repr(ty).size();\n+                let offest = size;\n+                size += field_size;\n+                fields.push(FieldRepr { offset: offest, size: field_size });\n+            }\n+\n+            if size > max_variant_size {\n+                max_variant_size = size;\n+            }\n+            variants.push(fields);\n+        }\n+\n+        let num_variants = variants.len();\n+\n+        let discr_size = match num_variants {\n+            n if n <= 1       => 0,\n+            n if n <= 1 << 8  => 1,\n+            n if n <= 1 << 16 => 2,\n+            n if n <= 1 << 32 => 4,\n+            _                 => 8,\n+        };\n+\n+        Repr::Aggregate {\n+            discr_size: discr_size,\n+            max_variant_size: max_variant_size,\n+            variants: variants,\n+        }\n \n-    fn make_variant_repr(&self, v: ty::VariantDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Repr {\n-        let field_tys = v.fields.iter().map(|f| f.ty(self.tcx, substs));\n-        self.make_product_repr(field_tys)\n     }\n \n     // TODO(tsion): Cache these outputs.\n@@ -584,33 +604,14 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n             ty::TyUint(UintTy::U32) => Repr::Primitive { size: 4 },\n             ty::TyUint(UintTy::U64) => Repr::Primitive { size: 8 },\n \n-            ty::TyTuple(ref fields) => self.make_product_repr(fields.iter().cloned()),\n-\n-            ty::TyEnum(adt_def, substs) => {\n-                let num_variants = adt_def.variants.len();\n-\n-                let discr_size = match num_variants {\n-                    n if n <= 1       => 0,\n-                    n if n <= 1 << 8  => 1,\n-                    n if n <= 1 << 16 => 2,\n-                    n if n <= 1 << 32 => 4,\n-                    _                 => 8,\n-                };\n-\n-                let variants: Vec<Repr> = adt_def.variants.iter().map(|v| {\n-                    self.make_variant_repr(v, substs)\n-                }).collect();\n-\n-                Repr::Sum {\n-                    discr_size: discr_size,\n-                    max_variant_size: variants.iter().map(Repr::size).max().unwrap_or(0),\n-                    variants: variants,\n-                }\n-            }\n+            ty::TyTuple(ref fields) =>\n+                self.make_aggregate_repr(iter::once(fields.iter().cloned())),\n \n-            ty::TyStruct(adt_def, substs) => {\n-                assert_eq!(adt_def.variants.len(), 1);\n-                self.make_variant_repr(&adt_def.variants[0], substs)\n+            ty::TyEnum(adt_def, substs) | ty::TyStruct(adt_def, substs) => {\n+                let variants = adt_def.variants.iter().map(|v| {\n+                    v.fields.iter().map(|f| f.ty(self.tcx, substs))\n+                });\n+                self.make_aggregate_repr(variants)\n             }\n \n             ty::TyArray(ref elem_ty, length) => Repr::Array {"}, {"sha": "a2632007d802d8fa98c88f8c288fc9f7e26e8b32", "filename": "src/memory.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ebf5063a4c0e790469425cb3cfcbf313f7fb2cc/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebf5063a4c0e790469425cb3cfcbf313f7fb2cc/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=3ebf5063a4c0e790469425cb3cfcbf313f7fb2cc", "patch": "@@ -48,24 +48,17 @@ pub enum Repr {\n     Pointer,\n     FatPointer,\n \n-    /// The representation for product types including tuples, structs, and the contents of enum\n-    /// variants.\n-    Product {\n-        /// Size in bytes.\n-        size: usize,\n-        fields: Vec<FieldRepr>,\n-    },\n-\n-    /// The representation for a sum type, i.e. a Rust enum.\n-    Sum {\n-        /// The size of the discriminant (an integer). Should be between 0 and 8.\n+    /// The representation for aggregate types including structs, enums, and tuples.\n+    Aggregate {\n+        /// The size of the discriminant (an integer). Should be between 0 and 8. Always 0 for\n+        /// structs and tuples.\n         discr_size: usize,\n \n         /// The size of the largest variant in bytes.\n         max_variant_size: usize,\n \n         /// The representations of the contents of each variant.\n-        variants: Vec<Repr>,\n+        variants: Vec<Vec<FieldRepr>>,\n     },\n \n     Array {\n@@ -373,8 +366,7 @@ impl Repr {\n     pub fn size(&self) -> usize {\n         match *self {\n             Repr::Primitive { size } => size,\n-            Repr::Product { size, .. } => size,\n-            Repr::Sum { discr_size, max_variant_size, .. } => discr_size + max_variant_size,\n+            Repr::Aggregate { discr_size, max_variant_size, .. } => discr_size + max_variant_size,\n             Repr::Array { elem_size, length } => elem_size * length,\n             Repr::Pointer => POINTER_SIZE,\n             Repr::FatPointer => POINTER_SIZE * 2,"}]}