{"sha": "35636f9459720513ca4ed19373a4a7c9e0ea3c46", "node_id": "C_kwDOAAsO6NoAKDM1NjM2Zjk0NTk3MjA1MTNjYTRlZDE5MzczYTRhN2M5ZTBlYTNjNDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-05T05:15:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-05T05:15:50Z"}, "message": "Auto merge of #107723 - Kobzol:bootstrap-bolt, r=Mark-Simulacrum\n\nApply BOLT optimizations without rebuilding LLVM\n\nThis PR adds an explicit BOLT bootstrap step which applies BOLT on the fly when LLVM artifacts are copied to a sysroot (it only does this once per bootstrap invocation, the result is cached).  This avoids one LLVM rebuild in the Linux CI dist build.\n\nr? `@jyn514`", "tree": {"sha": "f134f3d534e5f7faaa3bef1afde578c04bed3884", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f134f3d534e5f7faaa3bef1afde578c04bed3884"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35636f9459720513ca4ed19373a4a7c9e0ea3c46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35636f9459720513ca4ed19373a4a7c9e0ea3c46", "html_url": "https://github.com/rust-lang/rust/commit/35636f9459720513ca4ed19373a4a7c9e0ea3c46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35636f9459720513ca4ed19373a4a7c9e0ea3c46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a512c6c77115169d706338dbc7abc53ce302f616", "url": "https://api.github.com/repos/rust-lang/rust/commits/a512c6c77115169d706338dbc7abc53ce302f616", "html_url": "https://github.com/rust-lang/rust/commit/a512c6c77115169d706338dbc7abc53ce302f616"}, {"sha": "9aad2ad3615468463cfa036801525bc2f7e3553a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aad2ad3615468463cfa036801525bc2f7e3553a", "html_url": "https://github.com/rust-lang/rust/commit/9aad2ad3615468463cfa036801525bc2f7e3553a"}], "stats": {"total": 189, "additions": 146, "deletions": 43}, "files": [{"sha": "973dc4f602b2af8b435495d15443f63c1601ee1d", "filename": "src/bootstrap/bolt.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/35636f9459720513ca4ed19373a4a7c9e0ea3c46/src%2Fbootstrap%2Fbolt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35636f9459720513ca4ed19373a4a7c9e0ea3c46/src%2Fbootstrap%2Fbolt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbolt.rs?ref=35636f9459720513ca4ed19373a4a7c9e0ea3c46", "patch": "@@ -1,46 +1,40 @@\n use std::path::Path;\n use std::process::Command;\n \n-/// Uses the `llvm-bolt` binary to instrument the binary/library at the given `path` with BOLT.\n+/// Uses the `llvm-bolt` binary to instrument the artifact at the given `path` with BOLT.\n /// When the instrumented artifact is executed, it will generate BOLT profiles into\n /// `/tmp/prof.fdata.<pid>.fdata`.\n-pub fn instrument_with_bolt_inplace(path: &Path) {\n-    let dir = std::env::temp_dir();\n-    let instrumented_path = dir.join(\"instrumented.so\");\n-\n+/// Creates the instrumented artifact at `output_path`.\n+pub fn instrument_with_bolt(path: &Path, output_path: &Path) {\n     let status = Command::new(\"llvm-bolt\")\n         .arg(\"-instrument\")\n         .arg(&path)\n         // Make sure that each process will write its profiles into a separate file\n         .arg(\"--instrumentation-file-append-pid\")\n         .arg(\"-o\")\n-        .arg(&instrumented_path)\n+        .arg(output_path)\n         .status()\n         .expect(\"Could not instrument artifact using BOLT\");\n \n     if !status.success() {\n         panic!(\"Could not instrument {} with BOLT, exit code {:?}\", path.display(), status.code());\n     }\n-\n-    std::fs::copy(&instrumented_path, path).expect(\"Cannot copy instrumented artifact\");\n-    std::fs::remove_file(instrumented_path).expect(\"Cannot delete instrumented artifact\");\n }\n \n-/// Uses the `llvm-bolt` binary to optimize the binary/library at the given `path` with BOLT,\n+/// Uses the `llvm-bolt` binary to optimize the artifact at the given `path` with BOLT,\n /// using merged profiles from `profile_path`.\n ///\n /// The recorded profiles have to be merged using the `merge-fdata` tool from LLVM and the merged\n /// profile path should be then passed to this function.\n-pub fn optimize_library_with_bolt_inplace(path: &Path, profile_path: &Path) {\n-    let dir = std::env::temp_dir();\n-    let optimized_path = dir.join(\"optimized.so\");\n-\n+///\n+/// Creates the optimized artifact at `output_path`.\n+pub fn optimize_with_bolt(path: &Path, profile_path: &Path, output_path: &Path) {\n     let status = Command::new(\"llvm-bolt\")\n         .arg(&path)\n         .arg(\"-data\")\n         .arg(&profile_path)\n         .arg(\"-o\")\n-        .arg(&optimized_path)\n+        .arg(output_path)\n         // Reorder basic blocks within functions\n         .arg(\"-reorder-blocks=ext-tsp\")\n         // Reorder functions within the binary\n@@ -65,7 +59,4 @@ pub fn optimize_library_with_bolt_inplace(path: &Path, profile_path: &Path) {\n     if !status.success() {\n         panic!(\"Could not optimize {} with BOLT, exit code {:?}\", path.display(), status.code());\n     }\n-\n-    std::fs::copy(&optimized_path, path).expect(\"Cannot copy optimized artifact\");\n-    std::fs::remove_file(optimized_path).expect(\"Cannot delete optimized artifact\");\n }"}, {"sha": "d7008df41791edde6e7c2790f97ee2f2e1d7eebf", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 134, "deletions": 1, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/35636f9459720513ca4ed19373a4a7c9e0ea3c46/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35636f9459720513ca4ed19373a4a7c9e0ea3c46/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=35636f9459720513ca4ed19373a4a7c9e0ea3c46", "patch": "@@ -18,7 +18,9 @@ use std::process::Command;\n \n use object::read::archive::ArchiveFile;\n use object::BinaryFormat;\n+use sha2::Digest;\n \n+use crate::bolt::{instrument_with_bolt, optimize_with_bolt};\n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::channel;\n@@ -1904,6 +1906,26 @@ fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: TargetSelection) {\n     }\n }\n \n+fn install_llvm_file(builder: &Builder<'_>, source: &Path, destination: &Path) {\n+    if builder.config.dry_run() {\n+        return;\n+    }\n+\n+    // After LLVM is built, we modify (instrument or optimize) the libLLVM.so library file.\n+    // This is not done in-place so that the built LLVM files are not \"tainted\" with BOLT.\n+    // We perform the instrumentation/optimization here, on the fly, just before they are being\n+    // packaged into some destination directory.\n+    let postprocessed = if builder.config.llvm_bolt_profile_generate {\n+        builder.ensure(BoltInstrument::new(source.to_path_buf()))\n+    } else if let Some(path) = &builder.config.llvm_bolt_profile_use {\n+        builder.ensure(BoltOptimize::new(source.to_path_buf(), path.into()))\n+    } else {\n+        source.to_path_buf()\n+    };\n+\n+    builder.install(&postprocessed, destination, 0o644);\n+}\n+\n /// Maybe add LLVM object files to the given destination lib-dir. Allows either static or dynamic linking.\n ///\n /// Returns whether the files were actually copied.\n@@ -1955,7 +1977,7 @@ fn maybe_install_llvm(builder: &Builder<'_>, target: TargetSelection, dst_libdir\n             } else {\n                 PathBuf::from(file)\n             };\n-            builder.install(&file, dst_libdir, 0o644);\n+            install_llvm_file(builder, &file, dst_libdir);\n         }\n         !builder.config.dry_run()\n     } else {\n@@ -1986,6 +2008,117 @@ pub fn maybe_install_llvm_runtime(builder: &Builder<'_>, target: TargetSelection\n     }\n }\n \n+/// Creates an output path to a BOLT-manipulated artifact for the given `file`.\n+/// The hash of the file is used to make sure that we don't mix BOLT artifacts amongst different\n+/// files with the same name.\n+///\n+/// We need to keep the file-name the same though, to make sure that copying the manipulated file\n+/// to a directory will not change the final file path.\n+fn create_bolt_output_path(builder: &Builder<'_>, file: &Path, hash: &str) -> PathBuf {\n+    let directory = builder.out.join(\"bolt\").join(hash);\n+    t!(fs::create_dir_all(&directory));\n+    directory.join(file.file_name().unwrap())\n+}\n+\n+/// Instrument the provided file with BOLT.\n+/// Returns a path to the instrumented artifact.\n+#[derive(Clone, Debug, Eq, Hash, PartialEq)]\n+pub struct BoltInstrument {\n+    file: PathBuf,\n+    hash: String,\n+}\n+\n+impl BoltInstrument {\n+    fn new(file: PathBuf) -> Self {\n+        let mut hasher = sha2::Sha256::new();\n+        hasher.update(t!(fs::read(&file)));\n+        let hash = hex::encode(hasher.finalize().as_slice());\n+\n+        Self { file, hash }\n+    }\n+}\n+\n+impl Step for BoltInstrument {\n+    type Output = PathBuf;\n+\n+    const ONLY_HOSTS: bool = false;\n+    const DEFAULT: bool = false;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.never()\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+        if builder.build.config.dry_run() {\n+            return self.file.clone();\n+        }\n+\n+        if builder.build.config.llvm_from_ci {\n+            println!(\"warning: trying to use BOLT with LLVM from CI, this will probably not work\");\n+        }\n+\n+        println!(\"Instrumenting {} with BOLT\", self.file.display());\n+\n+        let output_path = create_bolt_output_path(builder, &self.file, &self.hash);\n+        if !output_path.is_file() {\n+            instrument_with_bolt(&self.file, &output_path);\n+        }\n+        output_path\n+    }\n+}\n+\n+/// Optimize the provided file with BOLT.\n+/// Returns a path to the optimized artifact.\n+///\n+/// The hash is stored in the step to make sure that we don't optimize the same file\n+/// twice (even under  different file paths).\n+#[derive(Clone, Debug, Eq, Hash, PartialEq)]\n+pub struct BoltOptimize {\n+    file: PathBuf,\n+    profile: PathBuf,\n+    hash: String,\n+}\n+\n+impl BoltOptimize {\n+    fn new(file: PathBuf, profile: PathBuf) -> Self {\n+        let mut hasher = sha2::Sha256::new();\n+        hasher.update(t!(fs::read(&file)));\n+        hasher.update(t!(fs::read(&profile)));\n+        let hash = hex::encode(hasher.finalize().as_slice());\n+\n+        Self { file, profile, hash }\n+    }\n+}\n+\n+impl Step for BoltOptimize {\n+    type Output = PathBuf;\n+\n+    const ONLY_HOSTS: bool = false;\n+    const DEFAULT: bool = false;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.never()\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+        if builder.build.config.dry_run() {\n+            return self.file.clone();\n+        }\n+\n+        if builder.build.config.llvm_from_ci {\n+            println!(\"warning: trying to use BOLT with LLVM from CI, this will probably not work\");\n+        }\n+\n+        println!(\"Optimizing {} with BOLT\", self.file.display());\n+\n+        let output_path = create_bolt_output_path(builder, &self.file, &self.hash);\n+        if !output_path.is_file() {\n+            optimize_with_bolt(&self.file, &self.profile, &output_path);\n+        }\n+        output_path\n+    }\n+}\n+\n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n pub struct LlvmTools {\n     pub target: TargetSelection,"}, {"sha": "8c2bece1e6218822dd559959c495583634fbcbcf", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35636f9459720513ca4ed19373a4a7c9e0ea3c46/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35636f9459720513ca4ed19373a4a7c9e0ea3c46/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=35636f9459720513ca4ed19373a4a7c9e0ea3c46", "patch": "@@ -16,7 +16,6 @@ use std::io;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-use crate::bolt::{instrument_with_bolt_inplace, optimize_library_with_bolt_inplace};\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::channel;\n use crate::config::{Config, TargetSelection};\n@@ -523,34 +522,12 @@ impl Step for Llvm {\n             }\n         }\n \n-        // After LLVM is built, we modify (instrument or optimize) the libLLVM.so library file\n-        // in place. This is fine, because currently we do not support incrementally rebuilding\n-        // LLVM after a configuration change, so to rebuild it the build files have to be removed,\n-        // which will also remove these modified files.\n-        if builder.config.llvm_bolt_profile_generate {\n-            instrument_with_bolt_inplace(&get_built_llvm_lib_path(&res.llvm_config));\n-        }\n-        if let Some(path) = &builder.config.llvm_bolt_profile_use {\n-            optimize_library_with_bolt_inplace(\n-                &get_built_llvm_lib_path(&res.llvm_config),\n-                &Path::new(path),\n-            );\n-        }\n-\n         t!(stamp.write());\n \n         res\n     }\n }\n \n-/// Returns path to a built LLVM library (libLLVM.so).\n-/// Assumes that we have built LLVM into a single library file.\n-fn get_built_llvm_lib_path(llvm_config_path: &Path) -> PathBuf {\n-    let mut cmd = Command::new(llvm_config_path);\n-    cmd.arg(\"--libfiles\");\n-    PathBuf::from(output(&mut cmd).trim())\n-}\n-\n fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     if !builder.config.llvm_version_check {\n         return;"}, {"sha": "fe3083dc31e467f82198e6d4e827b7c3cb9a8ad9", "filename": "src/ci/stage-build.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35636f9459720513ca4ed19373a4a7c9e0ea3c46/src%2Fci%2Fstage-build.py", "raw_url": "https://github.com/rust-lang/rust/raw/35636f9459720513ca4ed19373a4a7c9e0ea3c46/src%2Fci%2Fstage-build.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fstage-build.py?ref=35636f9459720513ca4ed19373a4a7c9e0ea3c46", "patch": "@@ -798,14 +798,16 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n                     \"--llvm-profile-use\",\n                     pipeline.llvm_profile_merged_file(),\n                     \"--llvm-bolt-profile-generate\",\n+                    \"--rust-profile-use\",\n+                    pipeline.rustc_profile_merged_file()\n                 ])\n                 record_metrics(pipeline, rustc_build)\n \n             with stage3.section(\"Gather profiles\"):\n                 gather_llvm_bolt_profiles(pipeline)\n \n+        # LLVM is not being cleared here, we want to reuse the previous build\n         print_free_disk_space(pipeline)\n-        clear_llvm_files(pipeline)\n         final_build_args += [\n             \"--llvm-bolt-profile-use\",\n             pipeline.llvm_bolt_profile_merged_file()"}]}