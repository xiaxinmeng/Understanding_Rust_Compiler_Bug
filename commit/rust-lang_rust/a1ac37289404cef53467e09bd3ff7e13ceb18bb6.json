{"sha": "a1ac37289404cef53467e09bd3ff7e13ceb18bb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYWMzNzI4OTQwNGNlZjUzNDY3ZTA5YmQzZmY3ZTEzY2ViMThiYjY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-19T22:18:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-19T22:18:56Z"}, "message": "Rollup merge of #84717 - dtolnay:literalfromstr, r=petrochenkov\n\nimpl FromStr for proc_macro::Literal\n\nNote that unlike `impl FromStr for proc_macro::TokenStream`, this impl does not permit whitespace or comments. The input string must consist of nothing but your literal.\n\n- `\"1\".parse::<Literal>()` \u27f6 ok\n\n- `\"1.0\".parse::<Literal>()` \u27f6 ok\n\n- `\"'a'\".parse::<Literal>()` \u27f6 ok\n\n- `\"\\\"\\n\\\"\".parse::<Literal>()` \u27f6 ok\n\n- `\"0 1\".parse::<Literal>()` \u27f6 LexError\n\n- `\" 0\".parse::<Literal>()` \u27f6 LexError\n\n- `\"0 \".parse::<Literal>()` \u27f6 LexError\n\n- `\"/* comment */0\".parse::<Literal>()` \u27f6 LexError\n\n- `\"0/* comment */\".parse::<Literal>()` \u27f6 LexError\n\n- `\"0// comment\".parse::<Literal>()` \u27f6 LexError\n\n---\n\n## Use case\n\n```rust\nlet hex_int: Literal = format!(\"0x{:x}\", int).parse().unwrap();\n```\n\nThe only way this is expressible in the current API is significantly worse.\n\n```rust\nlet hex_int = match format!(\"0x{:x}\", int)\n    .parse::<TokenStream>()\n    .unwrap()\n    .into_iter()\n    .next()\n    .unwrap()\n{\n    TokenTree::Literal(literal) => literal,\n    _ => unreachable!(),\n};\n```", "tree": {"sha": "d9f3c530fed7be0793b6c220a8695996bd96fcea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9f3c530fed7be0793b6c220a8695996bd96fcea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1ac37289404cef53467e09bd3ff7e13ceb18bb6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgpY7QCRBK7hj4Ov3rIwAAyTQIAAedJzoePCtOiBDo1w3GJVqN\nAyvd4Z0YE7alVs0Uu2TgUM1o3leFPNt6HL50J6fDlKtZNXZxixjZv08PFQ8cdauM\n7bwqnMwf6KeusC0JYddew8mTurmEOU6zPefK8pIZ8yjNc9cP5fKMB112wv1UTe1H\n2wN///zQETBLqL3oHSj8GfLbAsKWuFzv02v05fq6yUrztrENSVVP10GRU922ign/\nKBzpGT7h9++DveyObHHQTsxJrn5C+5wqIsX4e7qmmlSZSWPYmPf+rfV9vHUH3k08\ntPs3REBm/P76optgholmtMJ+11By/PxK8xqZ67635Sp4rWhTX/uyrKwbnuywYTE=\n=Dwr4\n-----END PGP SIGNATURE-----\n", "payload": "tree d9f3c530fed7be0793b6c220a8695996bd96fcea\nparent f94942d8421dc4b1da86d07069571ddb43127235\nparent 34585cb678bc492be7e48ff48a2633f4ce1dc5ae\nauthor Ralf Jung <post@ralfj.de> 1621462736 +0200\ncommitter GitHub <noreply@github.com> 1621462736 +0200\n\nRollup merge of #84717 - dtolnay:literalfromstr, r=petrochenkov\n\nimpl FromStr for proc_macro::Literal\n\nNote that unlike `impl FromStr for proc_macro::TokenStream`, this impl does not permit whitespace or comments. The input string must consist of nothing but your literal.\n\n- `\"1\".parse::<Literal>()` \u27f6 ok\n\n- `\"1.0\".parse::<Literal>()` \u27f6 ok\n\n- `\"'a'\".parse::<Literal>()` \u27f6 ok\n\n- `\"\\\"\\n\\\"\".parse::<Literal>()` \u27f6 ok\n\n- `\"0 1\".parse::<Literal>()` \u27f6 LexError\n\n- `\" 0\".parse::<Literal>()` \u27f6 LexError\n\n- `\"0 \".parse::<Literal>()` \u27f6 LexError\n\n- `\"/* comment */0\".parse::<Literal>()` \u27f6 LexError\n\n- `\"0/* comment */\".parse::<Literal>()` \u27f6 LexError\n\n- `\"0// comment\".parse::<Literal>()` \u27f6 LexError\n\n---\n\n## Use case\n\n```rust\nlet hex_int: Literal = format!(\"0x{:x}\", int).parse().unwrap();\n```\n\nThe only way this is expressible in the current API is significantly worse.\n\n```rust\nlet hex_int = match format!(\"0x{:x}\", int)\n    .parse::<TokenStream>()\n    .unwrap()\n    .into_iter()\n    .next()\n    .unwrap()\n{\n    TokenTree::Literal(literal) => literal,\n    _ => unreachable!(),\n};\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1ac37289404cef53467e09bd3ff7e13ceb18bb6", "html_url": "https://github.com/rust-lang/rust/commit/a1ac37289404cef53467e09bd3ff7e13ceb18bb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f94942d8421dc4b1da86d07069571ddb43127235", "url": "https://api.github.com/repos/rust-lang/rust/commits/f94942d8421dc4b1da86d07069571ddb43127235", "html_url": "https://github.com/rust-lang/rust/commit/f94942d8421dc4b1da86d07069571ddb43127235"}, {"sha": "34585cb678bc492be7e48ff48a2633f4ce1dc5ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/34585cb678bc492be7e48ff48a2633f4ce1dc5ae", "html_url": "https://github.com/rust-lang/rust/commit/34585cb678bc492be7e48ff48a2633f4ce1dc5ae"}], "stats": {"total": 149, "additions": 138, "deletions": 11}, "files": [{"sha": "92315c4d4f6c7f02e5221c2805706fe8ba12d8b6", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=a1ac37289404cef53467e09bd3ff7e13ceb18bb6", "patch": "@@ -1,9 +1,7 @@\n use crate::base::{ExtCtxt, ResolverExpand};\n \n use rustc_ast as ast;\n-use rustc_ast::token;\n-use rustc_ast::token::Nonterminal;\n-use rustc_ast::token::NtIdent;\n+use rustc_ast::token::{self, Nonterminal, NtIdent, TokenKind};\n use rustc_ast::tokenstream::{self, CanSynthesizeMissingTokens};\n use rustc_ast::tokenstream::{DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n use rustc_ast_pretty::pprust;\n@@ -541,6 +539,33 @@ impl server::Ident for Rustc<'_> {\n }\n \n impl server::Literal for Rustc<'_> {\n+    fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n+        let override_span = None;\n+        let stream = parse_stream_from_source_str(\n+            FileName::proc_macro_source_code(s),\n+            s.to_owned(),\n+            self.sess,\n+            override_span,\n+        );\n+        if stream.len() != 1 {\n+            return Err(());\n+        }\n+        let tree = stream.into_trees().next().unwrap();\n+        let token = match tree {\n+            tokenstream::TokenTree::Token(token) => token,\n+            tokenstream::TokenTree::Delimited { .. } => return Err(()),\n+        };\n+        let span_data = token.span.data();\n+        if (span_data.hi.0 - span_data.lo.0) as usize != s.len() {\n+            // There is a comment or whitespace adjacent to the literal.\n+            return Err(());\n+        }\n+        let lit = match token.kind {\n+            TokenKind::Literal(lit) => lit,\n+            _ => return Err(()),\n+        };\n+        Ok(Literal { lit, span: self.call_site })\n+    }\n     fn debug_kind(&mut self, literal: &Self::Literal) -> String {\n         format!(\"{:?}\", literal.lit.kind)\n     }"}, {"sha": "a2953b68564a89bcddb92552e527f0241fa9f18b", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=a1ac37289404cef53467e09bd3ff7e13ceb18bb6", "patch": "@@ -107,6 +107,7 @@ macro_rules! with_api {\n             Literal {\n                 fn drop($self: $S::Literal);\n                 fn clone($self: &$S::Literal) -> $S::Literal;\n+                fn from_str(s: &str) -> Result<$S::Literal, ()>;\n                 fn debug_kind($self: &$S::Literal) -> String;\n                 fn symbol($self: &$S::Literal) -> String;\n                 fn suffix($self: &$S::Literal) -> Option<String>;\n@@ -315,6 +316,19 @@ impl<T: Unmark> Unmark for Option<T> {\n     }\n }\n \n+impl<T: Mark, E: Mark> Mark for Result<T, E> {\n+    type Unmarked = Result<T::Unmarked, E::Unmarked>;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        unmarked.map(T::mark).map_err(E::mark)\n+    }\n+}\n+impl<T: Unmark, E: Unmark> Unmark for Result<T, E> {\n+    type Unmarked = Result<T::Unmarked, E::Unmarked>;\n+    fn unmark(self) -> Self::Unmarked {\n+        self.map(T::unmark).map_err(E::unmark)\n+    }\n+}\n+\n macro_rules! mark_noop {\n     ($($ty:ty),* $(,)?) => {\n         $("}, {"sha": "281999fe71588d37876bb90582095ffb37c57b76", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=a1ac37289404cef53467e09bd3ff7e13ceb18bb6", "patch": "@@ -91,6 +91,12 @@ pub struct LexError {\n     _inner: (),\n }\n \n+impl LexError {\n+    fn new() -> Self {\n+        LexError { _inner: () }\n+    }\n+}\n+\n #[stable(feature = \"proc_macro_lexerror_impls\", since = \"1.44.0\")]\n impl fmt::Display for LexError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -1171,6 +1177,28 @@ impl Literal {\n     }\n }\n \n+/// Parse a single literal from its stringified representation.\n+///\n+/// In order to parse successfully, the input string must not contain anything\n+/// but the literal token. Specifically, it must not contain whitespace or\n+/// comments in addition to the literal.\n+///\n+/// The resulting literal token will have a `Span::call_site()` span.\n+///\n+/// NOTE: some errors may cause panics instead of returning `LexError`. We\n+/// reserve the right to change these errors into `LexError`s later.\n+#[stable(feature = \"proc_macro_literal_parse\", since = \"1.54.0\")]\n+impl FromStr for Literal {\n+    type Err = LexError;\n+\n+    fn from_str(src: &str) -> Result<Self, LexError> {\n+        match bridge::client::Literal::from_str(src) {\n+            Ok(literal) => Ok(Literal(literal)),\n+            Err(()) => Err(LexError::new()),\n+        }\n+    }\n+}\n+\n // N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]"}, {"sha": "5784a6e5d94db3793f909d4619183e1563c26b6b", "filename": "src/test/ui/proc-macro/auxiliary/api/cmp.rs", "status": "renamed", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fcmp.rs?ref=a1ac37289404cef53467e09bd3ff7e13ceb18bb6", "patch": "@@ -1,8 +1,10 @@\n-#![feature(proc_macro_span)]\n+use proc_macro::{LineColumn, Punct, Spacing};\n \n-use proc_macro::{LineColumn, Punct};\n+pub fn test() {\n+    test_line_column_ord();\n+    test_punct_eq();\n+}\n \n-#[test]\n fn test_line_column_ord() {\n     let line0_column0 = LineColumn { line: 0, column: 0 };\n     let line0_column1 = LineColumn { line: 0, column: 1 };\n@@ -11,10 +13,9 @@ fn test_line_column_ord() {\n     assert!(line0_column1 < line1_column0);\n }\n \n-#[test]\n fn test_punct_eq() {\n-    // Good enough if it typechecks, since proc_macro::Punct can't exist in a test.\n-    fn _check(punct: Punct) {\n-        let _ = punct == ':';\n-    }\n+    let colon_alone = Punct::new(':', Spacing::Alone);\n+    assert_eq!(colon_alone, ':');\n+    let colon_joint = Punct::new(':', Spacing::Joint);\n+    assert_eq!(colon_joint, ':');\n }", "previous_filename": "library/proc_macro/tests/test.rs"}, {"sha": "739c25132e77b6561dad11deb64d17bf1f93c392", "filename": "src/test/ui/proc-macro/auxiliary/api/mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fmod.rs?ref=a1ac37289404cef53467e09bd3ff7e13ceb18bb6", "patch": "@@ -0,0 +1,24 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![crate_name = \"proc_macro_api_tests\"]\n+#![feature(proc_macro_span)]\n+#![deny(dead_code)] // catch if a test function is never called\n+\n+extern crate proc_macro;\n+\n+mod cmp;\n+mod parse;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn run(input: TokenStream) -> TokenStream {\n+    assert!(input.is_empty());\n+\n+    cmp::test();\n+    parse::test();\n+\n+    TokenStream::new()\n+}"}, {"sha": "4105236b7f2d35c85ab5b697b765de7478f00d16", "filename": "src/test/ui/proc-macro/auxiliary/api/parse.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fparse.rs?ref=a1ac37289404cef53467e09bd3ff7e13ceb18bb6", "patch": "@@ -0,0 +1,23 @@\n+use proc_macro::Literal;\n+\n+pub fn test() {\n+    test_parse_literal();\n+}\n+\n+fn test_parse_literal() {\n+    assert_eq!(\"1\".parse::<Literal>().unwrap().to_string(), \"1\");\n+    assert_eq!(\"1.0\".parse::<Literal>().unwrap().to_string(), \"1.0\");\n+    assert_eq!(\"'a'\".parse::<Literal>().unwrap().to_string(), \"'a'\");\n+    assert_eq!(\"\\\"\\n\\\"\".parse::<Literal>().unwrap().to_string(), \"\\\"\\n\\\"\");\n+    assert_eq!(\"b\\\"\\\"\".parse::<Literal>().unwrap().to_string(), \"b\\\"\\\"\");\n+    assert_eq!(\"r##\\\"\\\"##\".parse::<Literal>().unwrap().to_string(), \"r##\\\"\\\"##\");\n+    assert_eq!(\"10ulong\".parse::<Literal>().unwrap().to_string(), \"10ulong\");\n+\n+    assert!(\"0 1\".parse::<Literal>().is_err());\n+    assert!(\"'a\".parse::<Literal>().is_err());\n+    assert!(\" 0\".parse::<Literal>().is_err());\n+    assert!(\"0 \".parse::<Literal>().is_err());\n+    assert!(\"/* comment */0\".parse::<Literal>().is_err());\n+    assert!(\"0/* comment */\".parse::<Literal>().is_err());\n+    assert!(\"0// comment\".parse::<Literal>().is_err());\n+}"}, {"sha": "c96aa73175f2cf6ff94f71249791c5a707b96e0f", "filename": "src/test/ui/proc-macro/test.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/src%2Ftest%2Fui%2Fproc-macro%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ac37289404cef53467e09bd3ff7e13ceb18bb6/src%2Ftest%2Fui%2Fproc-macro%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Ftest.rs?ref=a1ac37289404cef53467e09bd3ff7e13ceb18bb6", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+// aux-build:api/mod.rs\n+\n+//! This is for everything that *would* be a #[test] inside of libproc_macro,\n+//! except for the fact that proc_macro objects are not capable of existing\n+//! inside of an ordinary Rust test execution, only inside a macro.\n+\n+extern crate proc_macro_api_tests;\n+\n+proc_macro_api_tests::run!();\n+\n+fn main() {}"}]}