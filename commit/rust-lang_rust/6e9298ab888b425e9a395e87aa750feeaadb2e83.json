{"sha": "6e9298ab888b425e9a395e87aa750feeaadb2e83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlOTI5OGFiODg4YjQyNWU5YTM5NWU4N2FhNzUwZmVlYWFkYjJlODM=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2013-02-07T21:46:10Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2013-02-07T21:46:10Z"}, "message": "Merge pull request #4619 from brson/exchange\n\nSome work on freestanding Rust: foreign calls, exchange allocator", "tree": {"sha": "8cacab08ce22357c491dc06f8493fa3e016d605e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cacab08ce22357c491dc06f8493fa3e016d605e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e9298ab888b425e9a395e87aa750feeaadb2e83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e9298ab888b425e9a395e87aa750feeaadb2e83", "html_url": "https://github.com/rust-lang/rust/commit/6e9298ab888b425e9a395e87aa750feeaadb2e83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e9298ab888b425e9a395e87aa750feeaadb2e83/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2817953d0a9129ba20b6400cfd53260ab505f40", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2817953d0a9129ba20b6400cfd53260ab505f40", "html_url": "https://github.com/rust-lang/rust/commit/a2817953d0a9129ba20b6400cfd53260ab505f40"}, {"sha": "e43c5bdc6b47e8dd5e2ddcd6cf57fec79388523a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e43c5bdc6b47e8dd5e2ddcd6cf57fec79388523a", "html_url": "https://github.com/rust-lang/rust/commit/e43c5bdc6b47e8dd5e2ddcd6cf57fec79388523a"}], "stats": {"total": 426, "additions": 306, "deletions": 120}, "files": [{"sha": "eff16f510f9ae39398128078bf652a71c081ae55", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -63,6 +63,7 @@ RUNTIME_CXXS_$(1) := \\\n               rt/rust_log.cpp \\\n               rt/rust_gc_metadata.cpp \\\n               rt/rust_util.cpp \\\n+              rt/rust_exchange_alloc.cpp \\\n               rt/isaac/randport.cpp \\\n               rt/miniz.cpp \\\n               rt/rust_kernel.cpp \\"}, {"sha": "56e3325edba3e1454c09d8597b18ce1275d3ca5e", "filename": "src/libcore/private.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -30,6 +30,8 @@ pub mod global;\n pub mod finally;\n #[path = \"private/weak_task.rs\"]\n pub mod weak_task;\n+#[path = \"private/exchange_alloc.rs\"]\n+pub mod exchange_alloc;\n \n extern mod rustrt {\n     pub unsafe fn rust_create_little_lock() -> rust_little_lock;\n@@ -86,6 +88,17 @@ fn test_run_in_bare_thread() {\n     }\n }\n \n+#[test]\n+fn test_run_in_bare_thread_exchange() {\n+    unsafe {\n+        // Does the exchange heap work without the runtime?\n+        let i = ~100;\n+        do run_in_bare_thread {\n+            assert i == ~100;\n+        }\n+    }\n+}\n+\n fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n     unsafe {\n         let old = rusti::atomic_cxchg(address, oldval, newval);"}, {"sha": "4a3c8d59af59bc0185a45dcdd1d475b3a1b12588", "filename": "src/libcore/private/exchange_alloc.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Flibcore%2Fprivate%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Flibcore%2Fprivate%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fexchange_alloc.rs?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sys::{TypeDesc, size_of};\n+use libc::{c_void, size_t, uintptr_t};\n+use c_malloc = libc::malloc;\n+use c_free = libc::free;\n+use managed::raw::{BoxHeaderRepr, BoxRepr};\n+use cast::transmute;\n+use ptr::{set_memory, null};\n+use intrinsic::TyDesc;\n+\n+pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n+    unsafe {\n+        assert td.is_not_null();\n+\n+        let total_size = get_box_size(size, (*td).align);\n+        let p = c_malloc(total_size as size_t);\n+        assert p.is_not_null();\n+\n+        // FIXME #4761: Would be very nice to not memset all allocations\n+        let p: *mut u8 = transmute(p);\n+        set_memory(p, 0, total_size);\n+\n+        // FIXME #3475: Converting between our two different tydesc types\n+        let td: *TyDesc = transmute(td);\n+\n+        let box: &mut BoxRepr = transmute(p);\n+        box.header.ref_count = -1; // Exchange values not ref counted\n+        box.header.type_desc = td;\n+        box.header.prev = null();\n+        box.header.next = null();\n+\n+        let exchange_count = &mut *rust_get_exchange_count_ptr();\n+        rusti::atomic_xadd(exchange_count, 1);\n+\n+        return transmute(box);\n+    }\n+}\n+\n+pub unsafe fn free(ptr: *c_void) {\n+    let exchange_count = &mut *rust_get_exchange_count_ptr();\n+    rusti::atomic_xsub(exchange_count, 1);\n+\n+    assert ptr.is_not_null();\n+    c_free(ptr);\n+}\n+\n+fn get_box_size(body_size: uint, body_align: uint) -> uint {\n+    let header_size = size_of::<BoxHeaderRepr>();\n+    // FIXME (#2699): This alignment calculation is suspicious. Is it right?\n+    let total_size = align_to(header_size, body_align) + body_size;\n+    return total_size;\n+}\n+\n+// Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n+// of two.\n+fn align_to(size: uint, align: uint) -> uint {\n+    assert align != 0;\n+    (size + align - 1) & !(align - 1)\n+}\n+\n+extern {\n+    #[rust_stack]\n+    fn rust_get_exchange_count_ptr() -> *mut int;\n+}\n+\n+#[abi = \"rust-intrinsic\"]\n+extern mod rusti {\n+    fn atomic_xadd(dst: &mut int, src: int) -> int;\n+    fn atomic_xsub(dst: &mut int, src: int) -> int;\n+}"}, {"sha": "769c0b3c7070337da2e7cbc2060a235be1359cc5", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -15,6 +15,8 @@ use libc::{c_char, c_uchar, c_void, size_t, uintptr_t};\n use managed::raw::BoxRepr;\n use str;\n use sys;\n+use private::exchange_alloc;\n+use cast::transmute;\n \n use gc::{cleanup_stack_for_failure, gc, Word};\n \n@@ -27,13 +29,6 @@ pub const FROZEN_BIT: uint = 0x80000000;\n pub const FROZEN_BIT: uint = 0x8000000000000000;\n \n pub extern mod rustrt {\n-    #[rust_stack]\n-    unsafe fn rust_upcall_exchange_malloc(td: *c_char, size: uintptr_t)\n-                                       -> *c_char;\n-\n-    #[rust_stack]\n-    unsafe fn rust_upcall_exchange_free(ptr: *c_char);\n-\n     #[rust_stack]\n     unsafe fn rust_upcall_malloc(td: *c_char, size: uintptr_t) -> *c_char;\n \n@@ -67,10 +62,11 @@ pub unsafe fn rt_fail_borrowed() {\n     }\n }\n \n+// XXX: Make these signatures agree with exchange_alloc's signatures\n #[rt(exchange_malloc)]\n #[lang=\"exchange_malloc\"]\n pub unsafe fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    return rustrt::rust_upcall_exchange_malloc(td, size);\n+    transmute(exchange_alloc::malloc(transmute(td), transmute(size)))\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n@@ -79,7 +75,7 @@ pub unsafe fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n #[rt(exchange_free)]\n #[lang=\"exchange_free\"]\n pub unsafe fn rt_exchange_free(ptr: *c_char) {\n-    rustrt::rust_upcall_exchange_free(ptr);\n+    exchange_alloc::free(transmute(ptr))\n }\n \n #[rt(malloc)]"}, {"sha": "6c0204ca736119fe5bee28525d068f74fa89c93f", "filename": "src/rt/rust_exchange_alloc.cpp", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_exchange_alloc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_exchange_alloc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_exchange_alloc.cpp?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include \"rust_exchange_alloc.h\"\n+#include \"sync/sync.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+uintptr_t exchange_count = 0;\n+\n+void *\n+rust_exchange_alloc::malloc(size_t size, bool zero) {\n+  void *value = ::malloc(size);\n+  assert(value);\n+  if (zero) {\n+    memset(value, 0, size);\n+  }\n+\n+  sync::increment(exchange_count);\n+\n+  return value;\n+}\n+\n+void *\n+rust_exchange_alloc::calloc(size_t size) {\n+  return this->malloc(size);\n+}\n+\n+void *\n+rust_exchange_alloc::realloc(void *ptr, size_t size) {\n+  void *new_ptr = ::realloc(ptr, size);\n+  assert(new_ptr);\n+  return new_ptr;\n+}\n+\n+void\n+rust_exchange_alloc::free(void *ptr) {\n+  sync::decrement(exchange_count);\n+  ::free(ptr);\n+}\n+\n+extern \"C\" uintptr_t *\n+rust_get_exchange_count_ptr() {\n+  return &exchange_count;\n+}\n+\n+void\n+rust_check_exchange_count_on_exit() {\n+  if (exchange_count != 0) {\n+    printf(\"exchange heap not empty on on exit\");\n+    printf(\"%d dangling allocations\", (int)exchange_count);\n+    abort();\n+  }\n+}"}, {"sha": "1b52929acf1b7a45df9430bbdae8f041f3699d2a", "filename": "src/rt/rust_exchange_alloc.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_exchange_alloc.h", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_exchange_alloc.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_exchange_alloc.h?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#ifndef RUST_EXCHANGE_ALLOC_H\n+#define RUST_EXCHANGE_ALLOC_H\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+class rust_exchange_alloc {\n+ public:\n+    void *malloc(size_t size, bool zero = true);\n+    void *calloc(size_t size);\n+    void *realloc(void *mem, size_t size);\n+    void free(void *mem);\n+};\n+\n+extern \"C\" uintptr_t *\n+rust_get_exchange_count_ptr();\n+\n+void\n+rust_check_exchange_count_on_exit();\n+\n+#endif"}, {"sha": "e0494c9300bc3564342193697a781c41e1e503de", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -22,7 +22,6 @@\n     KLOG_LVL(this, field, log_err, __VA_ARGS__)\n \n rust_kernel::rust_kernel(rust_env *env) :\n-    _region(env, true),\n     _log(NULL),\n     max_task_id(INIT_TASK_ID-1), // sync_add_and_fetch increments first\n     rval(0),\n@@ -77,21 +76,21 @@ rust_kernel::fatal(char const *fmt, ...) {\n \n void *\n rust_kernel::malloc(size_t size, const char *tag) {\n-    return _region.malloc(size, tag);\n+    return exchange_alloc.malloc(size);\n }\n \n void *\n rust_kernel::calloc(size_t size, const char *tag) {\n-    return _region.calloc(size, tag);\n+    return exchange_alloc.calloc(size);\n }\n \n void *\n rust_kernel::realloc(void *mem, size_t size) {\n-    return _region.realloc(mem, size);\n+    return exchange_alloc.realloc(mem, size);\n }\n \n void rust_kernel::free(void *mem) {\n-    _region.free(mem);\n+    exchange_alloc.free(mem);\n }\n \n rust_sched_id\n@@ -217,6 +216,7 @@ rust_kernel::run() {\n     assert(osmain_driver != NULL);\n     osmain_driver->start_main_loop();\n     sched_reaper.join();\n+    rust_check_exchange_count_on_exit();\n     return rval;\n }\n "}, {"sha": "11af02dace4a062af7d369f721c7ee34a4fd0801", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -45,11 +45,12 @@\n #include <map>\n #include <vector>\n \n-#include \"memory_region.h\"\n+#include \"rust_exchange_alloc.h\"\n #include \"rust_log.h\"\n #include \"rust_sched_reaper.h\"\n #include \"rust_type.h\"\n #include \"util/hash_map.h\"\n+#include \"sync/lock_and_signal.h\"\n \n class rust_scheduler;\n class rust_sched_driver;\n@@ -71,7 +72,7 @@ struct exit_functions {\n };\n \n class rust_kernel {\n-    memory_region _region;\n+    rust_exchange_alloc exchange_alloc;\n     rust_log _log;\n \n     // The next task id\n@@ -135,7 +136,7 @@ class rust_kernel {\n     void *calloc(size_t size, const char *tag);\n     void *realloc(void *mem, size_t size);\n     void free(void *mem);\n-    memory_region *region() { return &_region; }\n+    rust_exchange_alloc *region() { return &exchange_alloc; }\n \n     void fail();\n "}, {"sha": "0d0eaaee9628e22fc673ed14cabc975aab6523b9", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -260,7 +260,7 @@ rust_sched_loop::run_single_turn() {\n \n         assert(!extra_c_stack);\n         if (cached_c_stack) {\n-            destroy_stack(kernel->region(), cached_c_stack);\n+            destroy_exchange_stack(kernel->region(), cached_c_stack);\n             cached_c_stack = NULL;\n         }\n \n@@ -389,14 +389,15 @@ void\n rust_sched_loop::prepare_c_stack(rust_task *task) {\n     assert(!extra_c_stack);\n     if (!cached_c_stack && !task->have_c_stack()) {\n-        cached_c_stack = create_stack(kernel->region(), C_STACK_SIZE);\n+        cached_c_stack = create_exchange_stack(kernel->region(),\n+                                               C_STACK_SIZE);\n     }\n }\n \n void\n rust_sched_loop::unprepare_c_stack() {\n     if (extra_c_stack) {\n-        destroy_stack(kernel->region(), extra_c_stack);\n+        destroy_exchange_stack(kernel->region(), extra_c_stack);\n         extra_c_stack = NULL;\n     }\n }"}, {"sha": "0105b83e28b4581793155625f6f2fd9ab8f8edf5", "filename": "src/rt/rust_sched_loop.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -135,6 +135,7 @@ struct rust_sched_loop\n     void place_task_in_tls(rust_task *task);\n \n     static rust_task *get_task_tls();\n+    static rust_task *try_get_task_tls();\n \n     // Called by each task when they are ready to be destroyed\n     void release_task(rust_task *task);\n@@ -154,7 +155,7 @@ rust_sched_loop::get_log() {\n     return _log;\n }\n \n-inline rust_task* rust_sched_loop::get_task_tls()\n+inline rust_task* rust_sched_loop::try_get_task_tls()\n {\n     if (!tls_initialized)\n         return NULL;\n@@ -165,6 +166,12 @@ inline rust_task* rust_sched_loop::get_task_tls()\n     rust_task *task = reinterpret_cast<rust_task *>\n         (pthread_getspecific(task_key));\n #endif\n+    return task;\n+}\n+\n+inline rust_task* rust_sched_loop::get_task_tls()\n+{\n+    rust_task *task = try_get_task_tls();\n     assert(task && \"Couldn't get the task from TLS!\");\n     return task;\n }"}, {"sha": "3bcda8adf4024879a8f3fddd7a94cb5f4a6fd644", "filename": "src/rt/rust_stack.cpp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_stack.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_stack.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_stack.cpp?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -53,6 +53,8 @@ check_stack_canary(stk_seg *stk) {\n     assert(stk->canary == canary_value && \"Somebody killed the canary\");\n }\n \n+// XXX: Duplication here between the local and exchange heap constructors\n+\n stk_seg *\n create_stack(memory_region *region, size_t sz) {\n     size_t total_sz = sizeof(stk_seg) + sz;\n@@ -69,3 +71,20 @@ destroy_stack(memory_region *region, stk_seg *stk) {\n     deregister_valgrind_stack(stk);\n     region->free(stk);\n }\n+\n+stk_seg *\n+create_exchange_stack(rust_exchange_alloc *exchange, size_t sz) {\n+    size_t total_sz = sizeof(stk_seg) + sz;\n+    stk_seg *stk = (stk_seg *)exchange->malloc(total_sz, false);\n+    memset(stk, 0, sizeof(stk_seg));\n+    stk->end = (uintptr_t) &stk->data[sz];\n+    add_stack_canary(stk);\n+    register_valgrind_stack(stk);\n+    return stk;\n+}\n+\n+void\n+destroy_exchange_stack(rust_exchange_alloc *exchange, stk_seg *stk) {\n+    deregister_valgrind_stack(stk);\n+    exchange->free(stk);\n+}"}, {"sha": "51b884e47b1e7d121ba4f90c6a788cf985ba8002", "filename": "src/rt/rust_stack.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_stack.h", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_stack.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_stack.h?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -12,6 +12,7 @@\n #define RUST_STACK_H\n \n #include \"rust_globals.h\"\n+#include \"rust_exchange_alloc.h\"\n #include \"memory_region.h\"\n \n struct rust_task;\n@@ -37,6 +38,12 @@ create_stack(memory_region *region, size_t sz);\n void\n destroy_stack(memory_region *region, stk_seg *stk);\n \n+stk_seg *\n+create_exchange_stack(rust_exchange_alloc *exchange, size_t sz);\n+\n+void\n+destroy_exchange_stack(rust_exchange_alloc *exchange, stk_seg *stk);\n+\n // Must be called before each time a stack is reused to tell valgrind\n // that the stack is accessible.\n void"}, {"sha": "e51af464e488a9bee394e6fcc761954d82b76c4b", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -181,7 +181,7 @@ void task_start_wrapper(spawn_args *a)\n         // free the environment (which should be a unique closure).\n         const type_desc *td = env->td;\n         td->drop_glue(NULL, NULL, NULL, box_body(env));\n-        upcall_exchange_free(env);\n+        task->kernel->region()->free(env);\n     }\n \n     // The cleanup work needs lots of stack"}, {"sha": "cbde863fa231950756d7e900423c62f489ddb727", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -619,14 +619,14 @@ rust_task::record_stack_limit() {\n     record_sp_limit(stk->data + LIMIT_OFFSET + RED_ZONE_SIZE);\n }\n \n-inline rust_task* rust_get_current_task() {\n+inline rust_task* rust_try_get_current_task() {\n     uintptr_t sp_limit = get_sp_limit();\n \n     // FIXME (#1226) - Because of a hack in upcall_call_shim_on_c_stack this\n     // value is sometimes inconveniently set to 0, so we can't use this\n     // method of retreiving the task pointer and need to fall back to TLS.\n     if (sp_limit == 0)\n-        return rust_sched_loop::get_task_tls();\n+        return rust_sched_loop::try_get_task_tls();\n \n     // The stack pointer boundary is stored in a quickly-accessible location\n     // in the TCB. From that we can calculate the address of the stack segment\n@@ -642,6 +642,12 @@ inline rust_task* rust_get_current_task() {\n     return stk->task;\n }\n \n+inline rust_task* rust_get_current_task() {\n+    rust_task* task = rust_try_get_current_task();\n+    assert(task != NULL && \"no current task\");\n+    return task;\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "008b470fede76ab213920427e3728658c2e13f59", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 32, "deletions": 91, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -45,6 +45,8 @@ call_upcall_on_c_stack(rust_task *task, void *args, void *fn_ptr) {\n     task->call_on_c_stack(args, fn_ptr);\n }\n \n+typedef void (*CDECL stack_switch_shim)(void*);\n+\n /**********************************************************************\n  * Switches to the C-stack and invokes |fn_ptr|, passing |args| as argument.\n  * This is used by the C compiler to call foreign functions and by other\n@@ -54,13 +56,20 @@ call_upcall_on_c_stack(rust_task *task, void *args, void *fn_ptr) {\n  */\n extern \"C\" CDECL void\n upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n-    rust_task *task = rust_get_current_task();\n-\n-    try {\n-        task->call_on_c_stack(args, fn_ptr);\n-    } catch (...) {\n-        // Logging here is not reliable\n-        assert(false && \"Foreign code threw an exception\");\n+    rust_task *task = rust_try_get_current_task();\n+\n+    if (task) {\n+        // We're running in task context, do a stack switch\n+        try {\n+            task->call_on_c_stack(args, fn_ptr);\n+        } catch (...) {\n+            // Logging here is not reliable\n+            assert(false && \"Foreign code threw an exception\");\n+        }\n+    } else {\n+        // There's no task. Call the function and hope for the best\n+        stack_switch_shim f = (stack_switch_shim)fn_ptr;\n+        f(args);\n     }\n }\n \n@@ -70,15 +79,22 @@ upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n  */\n extern \"C\" CDECL void\n upcall_call_shim_on_rust_stack(void *args, void *fn_ptr) {\n-    rust_task *task = rust_get_current_task();\n-\n-    try {\n-        task->call_on_rust_stack(args, fn_ptr);\n-    } catch (...) {\n-        // We can't count on being able to unwind through arbitrary\n-        // code. Our best option is to just fail hard.\n-        // Logging here is not reliable\n-        assert(false && \"Rust task failed after reentering the Rust stack\");\n+    rust_task *task = rust_try_get_current_task();\n+\n+    if (task) {\n+        try {\n+            task->call_on_rust_stack(args, fn_ptr);\n+        } catch (...) {\n+            // We can't count on being able to unwind through arbitrary\n+            // code. Our best option is to just fail hard.\n+            // Logging here is not reliable\n+            assert(false\n+                   && \"Rust task failed after reentering the Rust stack\");\n+        }\n+    } else {\n+        // There's no task. Call the function and hope for the best\n+        stack_switch_shim f = (stack_switch_shim)fn_ptr;\n+        f(args);\n     }\n }\n \n@@ -124,81 +140,6 @@ struct s_trace_args {\n     size_t line;\n };\n \n-/**********************************************************************\n- * Allocate an object in the exchange heap\n- */\n-\n-struct s_exchange_malloc_args {\n-    rust_task *task;\n-    uintptr_t retval;\n-    type_desc *td;\n-    uintptr_t size;\n-};\n-\n-extern \"C\" CDECL void\n-upcall_s_exchange_malloc(s_exchange_malloc_args *args) {\n-    rust_task *task = args->task;\n-    LOG_UPCALL_ENTRY(task);\n-\n-    size_t total_size = get_box_size(args->size, args->td->align);\n-    void *p = task->kernel->malloc(total_size, \"exchange malloc\");\n-\n-    rust_opaque_box *header = static_cast<rust_opaque_box*>(p);\n-    header->ref_count = -1; // This is not ref counted\n-    header->td = args->td;\n-    header->prev = 0;\n-    header->next = 0;\n-\n-    LOG(task, mem, \"exchange malloced %p of size %\" PRIuPTR,\n-        header, args->size);\n-\n-    args->retval = (uintptr_t)header;\n-}\n-\n-extern \"C\" CDECL uintptr_t\n-upcall_exchange_malloc(type_desc *td, uintptr_t size) {\n-    rust_task *task = rust_get_current_task();\n-    s_exchange_malloc_args args = {task, 0, td, size};\n-    UPCALL_SWITCH_STACK(task, &args, upcall_s_exchange_malloc);\n-    return args.retval;\n-}\n-\n-// FIXME (#2861): Alias used by libcore/rt.rs to avoid naming conflicts with\n-// autogenerated wrappers for upcall_exchange_malloc. Remove this when we\n-// fully move away away from the C upcall path.\n-extern \"C\" CDECL uintptr_t\n-rust_upcall_exchange_malloc(type_desc *td, uintptr_t size) {\n-    return upcall_exchange_malloc(td, size);\n-}\n-\n-struct s_exchange_free_args {\n-    rust_task *task;\n-    void *ptr;\n-};\n-\n-extern \"C\" CDECL void\n-upcall_s_exchange_free(s_exchange_free_args *args) {\n-    rust_task *task = args->task;\n-    LOG_UPCALL_ENTRY(task);\n-    LOG(task, mem, \"exchange freed %p\", args->ptr);\n-    task->kernel->free(args->ptr);\n-}\n-\n-extern \"C\" CDECL void\n-upcall_exchange_free(void *ptr) {\n-    rust_task *task = rust_get_current_task();\n-    s_exchange_free_args args = {task,ptr};\n-    UPCALL_SWITCH_STACK(task, &args, upcall_s_exchange_free);\n-}\n-\n-// FIXME (#2861): Alias used by libcore/rt.rs to avoid naming conflicts with\n-// autogenerated wrappers for upcall_exchange_free. Remove this when we fully\n-// move away away from the C upcall path.\n-extern \"C\" CDECL void\n-rust_upcall_exchange_free(void *ptr) {\n-    return upcall_exchange_free(ptr);\n-}\n-\n /**********************************************************************\n  * Allocate an object in the task-local heap.\n  */"}, {"sha": "9076670392a85cd3bd63a44b2e22c7a0fc9fa3b1", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -68,10 +68,6 @@ upcall_call_shim_on_rust_stack\n upcall_new_stack\n upcall_del_stack\n upcall_reset_stack_limit\n-upcall_exchange_malloc\n-upcall_exchange_free\n-rust_upcall_exchange_free\n-rust_upcall_exchange_malloc\n rust_upcall_fail\n rust_upcall_free\n rust_upcall_malloc\n@@ -194,4 +190,5 @@ rust_raw_thread_join_delete\n rust_register_exit_function\n rust_get_global_data_ptr\n rust_inc_weak_task_count\n-rust_dec_weak_task_count\n\\ No newline at end of file\n+rust_dec_weak_task_count\n+rust_get_exchange_count_ptr"}, {"sha": "865aa775362843993ba0fd26f350406b3197a593", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9298ab888b425e9a395e87aa750feeaadb2e83/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=6e9298ab888b425e9a395e87aa750feeaadb2e83", "patch": "@@ -0,0 +1,24 @@\n+use core::private::run_in_bare_thread;\n+\n+extern {\n+    pub fn rust_dbg_call(cb: *u8,\n+                         data: libc::uintptr_t) -> libc::uintptr_t;\n+}\n+\n+pub fn main() {\n+    unsafe {\n+        do run_in_bare_thread() {\n+            unsafe {\n+                let i = &100;\n+                rust_dbg_call(callback, cast::transmute(i));\n+            }\n+        }\n+    }\n+}\n+\n+extern fn callback(data: libc::uintptr_t) {\n+    unsafe {\n+        let data: *int = cast::transmute(data);\n+        assert *data == 100;\n+    }\n+}\n\\ No newline at end of file"}]}