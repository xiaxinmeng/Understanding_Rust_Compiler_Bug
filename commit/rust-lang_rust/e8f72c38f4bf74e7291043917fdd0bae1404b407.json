{"sha": "e8f72c38f4bf74e7291043917fdd0bae1404b407", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZjcyYzM4ZjRiZjc0ZTcyOTEwNDM5MTdmZGQwYmFlMTQwNGI0MDc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-25T00:30:36Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-25T17:31:57Z"}, "message": "Cache and buffer stdout per-task for printing\n\nAlmost all languages provide some form of buffering of the stdout stream, and\nthis commit adds this feature for rust. A handle to stdout is lazily initialized\nin the Task structure as a buffered owned Writer trait object. The buffer\nbehavior depends on where stdout is directed to. Like C, this line-buffers the\nstream when the output goes to a terminal (flushes on newlines), and also like C\nthis uses a fixed-size buffer when output is not directed at a terminal.\n\nWe may decide the fixed-size buffering is overkill, but it certainly does reduce\nwrite syscall counts when piping output elsewhere. This is a *huge* benefit to\nany code using logging macros or the printing macros. Formatting emits calls to\n`write` very frequently, and to have each of them backed by a write syscall was\nvery expensive.\n\nIn a local benchmark of printing 10000 lines of \"what\" to stdout, I got the\nfollowing timings:\n\n  when |  terminal   |  redirected\n----------------------------------\nbefore |  0.575s     |   0.525s\nafter  |  0.197s     |   0.013s\n  C    |  0.019s     |   0.004s\n\nI can also confirm that we're buffering the output appropriately in both\nsitutations. We're still far slower than C, but I believe much of that has to do\nwith the \"homing\" that all tasks due, we're still performing an order of\nmagnitude more write syscalls than C does.", "tree": {"sha": "a6d0de8c515ae5824ec61b4f21c45e8d7c7e8840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6d0de8c515ae5824ec61b4f21c45e8d7c7e8840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8f72c38f4bf74e7291043917fdd0bae1404b407", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f72c38f4bf74e7291043917fdd0bae1404b407", "html_url": "https://github.com/rust-lang/rust/commit/e8f72c38f4bf74e7291043917fdd0bae1404b407", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8f72c38f4bf74e7291043917fdd0bae1404b407/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f5b2219cc893b30863f9136703166f306fcc684", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f5b2219cc893b30863f9136703166f306fcc684", "html_url": "https://github.com/rust-lang/rust/commit/3f5b2219cc893b30863f9136703166f306fcc684"}], "stats": {"total": 170, "additions": 139, "deletions": 31}, "files": [{"sha": "47c8dbd35c61449c0074516ea17fa2b4ec06197a", "filename": "src/libstd/rt/io/buffered.rs", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs?ref=e8f72c38f4bf74e7291043917fdd0bae1404b407", "patch": "@@ -221,17 +221,48 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n }\n \n impl<W: Writer> Decorator<W> for BufferedWriter<W> {\n-    fn inner(self) -> W {\n-        self.inner\n-    }\n+    fn inner(self) -> W { self.inner }\n+    fn inner_ref<'a>(&'a self) -> &'a W { &self.inner }\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W { &mut self.inner }\n+}\n \n-    fn inner_ref<'a>(&'a self) -> &'a W {\n-        &self.inner\n+/// Wraps a Writer and buffers output to it, flushing whenever a newline (0xa,\n+/// '\\n') is detected.\n+///\n+/// Note that this structure does NOT flush the output when dropped.\n+pub struct LineBufferedWriter<W> {\n+    priv inner: BufferedWriter<W>,\n+}\n+\n+impl<W: Writer> LineBufferedWriter<W> {\n+    /// Creates a new `LineBufferedWriter`\n+    pub fn new(inner: W) -> LineBufferedWriter<W> {\n+        // Lines typically aren't that long, don't use a giant buffer\n+        LineBufferedWriter {\n+            inner: BufferedWriter::with_capacity(1024, inner)\n+        }\n     }\n+}\n \n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W {\n-        &mut self.inner\n+impl<W: Writer> Writer for LineBufferedWriter<W> {\n+    fn write(&mut self, buf: &[u8]) {\n+        match buf.iter().position(|&b| b == '\\n' as u8) {\n+            Some(i) => {\n+                self.inner.write(buf.slice_to(i + 1));\n+                self.inner.flush();\n+                self.inner.write(buf.slice_from(i + 1));\n+            }\n+            None => self.inner.write(buf),\n+        }\n     }\n+\n+    fn flush(&mut self) { self.inner.flush() }\n+}\n+\n+impl<W: Writer> Decorator<W> for LineBufferedWriter<W> {\n+    fn inner(self) -> W { self.inner.inner() }\n+    fn inner_ref<'a>(&'a self) -> &'a W { self.inner.inner_ref() }\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W { self.inner.inner_mut_ref() }\n }\n \n struct InternalBufferedWriter<W>(BufferedWriter<W>);\n@@ -413,4 +444,19 @@ mod test {\n         assert_eq!(reader.read_until(8), Some(~[0]));\n         assert_eq!(reader.read_until(9), None);\n     }\n+\n+    #[test]\n+    fn test_line_buffer() {\n+        let mut writer = LineBufferedWriter::new(MemWriter::new());\n+        writer.write([0]);\n+        assert_eq!(*writer.inner_ref().inner_ref(), ~[]);\n+        writer.write([1]);\n+        assert_eq!(*writer.inner_ref().inner_ref(), ~[]);\n+        writer.flush();\n+        assert_eq!(*writer.inner_ref().inner_ref(), ~[0, 1]);\n+        writer.write([0, '\\n' as u8, 1]);\n+        assert_eq!(*writer.inner_ref().inner_ref(), ~[0, 1, 0, '\\n' as u8]);\n+        writer.flush();\n+        assert_eq!(*writer.inner_ref().inner_ref(), ~[0, 1, 0, '\\n' as u8, 1]);\n+    }\n }"}, {"sha": "3f34d32b350b4a2a3b9ce85cb82bf1a11dc2e2b0", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=e8f72c38f4bf74e7291043917fdd0bae1404b407", "patch": "@@ -30,6 +30,7 @@ use fmt;\n use libc;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n+use rt::io::buffered::{LineBufferedWriter, BufferedWriter};\n use rt::rtio::{IoFactory, RtioTTY, RtioFileStream, with_local_io,\n                CloseAsynchronously};\n use super::{Reader, Writer, io_error, IoError, OtherIoError};\n@@ -111,37 +112,78 @@ pub fn stderr() -> StdWriter {\n     do src(libc::STDERR_FILENO, false) |src| { StdWriter { inner: src } }\n }\n \n+/// Executes a closure with the local task's handle on stdout. By default, this\n+/// stream is a buffering stream, so the handled yielded to the given closure\n+/// can be used to flush the stdout stream (if necessary). The buffering used is\n+/// line-buffering when stdout is attached to a terminal, and a fixed sized\n+/// buffer if it is not attached to a terminal.\n+///\n+/// Note that handles generated via the `stdout()` function all output to the\n+/// same stream, and output among all task may be interleaved as a result of\n+/// this. This is provided to have access to the default stream for `print` and\n+/// `println` (and the related macros) for this task.\n+///\n+/// Also note that logging macros do not use this stream. Using the logging\n+/// macros will emit output to stderr.\n+pub fn with_task_stdout(f: &fn(&mut Writer)) {\n+    use rt::local::Local;\n+    use rt::task::Task;\n+\n+    unsafe {\n+        // Logging may require scheduling operations, so we can't remove the\n+        // task from TLS right now, hence the unsafe borrow. Sad.\n+        let task: *mut Task = Local::unsafe_borrow();\n+\n+        match (*task).stdout_handle {\n+            Some(ref mut handle) => f(*handle),\n+            None => {\n+                let handle = stdout();\n+                let mut handle = if handle.isatty() {\n+                    ~LineBufferedWriter::new(handle) as ~Writer\n+                } else {\n+                    // The default capacity is very large, 64k, but this is just\n+                    // a stdout stream, and possibly per task, so let's not make\n+                    // this too expensive.\n+                    ~BufferedWriter::with_capacity(4096, handle) as ~Writer\n+                };\n+                f(handle);\n+                (*task).stdout_handle = Some(handle);\n+            }\n+        }\n+    }\n+}\n+\n /// Prints a string to the stdout of the current process. No newline is emitted\n /// after the string is printed.\n pub fn print(s: &str) {\n-    // XXX: need to see if not caching stdin() is the cause of performance\n-    //      issues, it should be possible to cache a stdout handle in each Task\n-    //      and then re-use that across calls to print/println. Note that the\n-    //      resolution of this comment will affect all of the prints below as\n-    //      well.\n-    stdout().write(s.as_bytes());\n+    do with_task_stdout |io| {\n+        io.write(s.as_bytes());\n+    }\n }\n \n /// Prints a string as a line. to the stdout of the current process. A literal\n /// `\\n` character is printed to the console after the string.\n pub fn println(s: &str) {\n-    let mut out = stdout();\n-    out.write(s.as_bytes());\n-    out.write(['\\n' as u8]);\n+    do with_task_stdout |io| {\n+        io.write(s.as_bytes());\n+        io.write(['\\n' as u8]);\n+    }\n }\n \n /// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n /// with the `format_args!` macro.\n pub fn print_args(fmt: &fmt::Arguments) {\n-    let mut out = stdout();\n-    fmt::write(&mut out as &mut Writer, fmt);\n+    do with_task_stdout |io| {\n+        fmt::write(io, fmt);\n+    }\n }\n \n /// Similar to `println`, but takes a `fmt::Arguments` structure to be\n /// compatible with the `format_args!` macro.\n pub fn println_args(fmt: &fmt::Arguments) {\n-    let mut out = stdout();\n-    fmt::writeln(&mut out as &mut Writer, fmt);\n+    do with_task_stdout |io| {\n+        fmt::writeln(io, fmt);\n+    }\n }\n \n /// Representation of a reader of a standard input stream"}, {"sha": "cb66d6f6199ae90240cf4142b2d10b7a49d8e029", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=e8f72c38f4bf74e7291043917fdd0bae1404b407", "patch": "@@ -13,6 +13,8 @@ use from_str::from_str;\n use libc::exit;\n use option::{Some, None, Option};\n use rt::io;\n+use rt::io::stdio::StdWriter;\n+use rt::io::buffered::LineBufferedWriter;\n use rt::crate_map::{ModEntry, CrateMap, iter_crate_map, get_crate_map};\n use str::StrSlice;\n use u32;\n@@ -170,7 +172,7 @@ pub trait Logger {\n /// This logger emits output to the stderr of the process, and contains a lazily\n /// initialized event-loop driven handle to the stream.\n pub struct StdErrLogger {\n-    priv handle: Option<io::stdio::StdWriter>,\n+    priv handle: Option<LineBufferedWriter<StdWriter>>,\n }\n \n impl StdErrLogger {\n@@ -181,7 +183,7 @@ impl Logger for StdErrLogger {\n     fn log(&mut self, args: &fmt::Arguments) {\n         // First time logging? Get a handle to the stderr of this process.\n         if self.handle.is_none() {\n-            self.handle = Some(io::stderr());\n+            self.handle = Some(LineBufferedWriter::new(io::stderr()));\n         }\n         fmt::writeln(self.handle.get_mut_ref() as &mut io::Writer, args);\n     }"}, {"sha": "dc3b6293fb099bb07b647cd625d7b98a17938530", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=e8f72c38f4bf74e7291043917fdd0bae1404b407", "patch": "@@ -23,6 +23,7 @@ use option::{Option, Some, None};\n use rt::borrowck;\n use rt::borrowck::BorrowRecord;\n use rt::env;\n+use rt::io::Writer;\n use rt::kill::Death;\n use rt::local::Local;\n use rt::logging::StdErrLogger;\n@@ -56,7 +57,8 @@ pub struct Task {\n     sched: Option<~Scheduler>,\n     task_type: TaskType,\n     // Dynamic borrowck debugging info\n-    borrow_list: Option<~[BorrowRecord]>\n+    borrow_list: Option<~[BorrowRecord]>,\n+    stdout_handle: Option<~Writer>,\n }\n \n pub enum TaskType {\n@@ -141,7 +143,8 @@ impl Task {\n             name: None,\n             sched: None,\n             task_type: SchedTask,\n-            borrow_list: None\n+            borrow_list: None,\n+            stdout_handle: None,\n         }\n     }\n \n@@ -175,7 +178,8 @@ impl Task {\n             coroutine: Some(Coroutine::new(stack_pool, stack_size, start)),\n             sched: None,\n             task_type: GreenTask(Some(home)),\n-            borrow_list: None\n+            borrow_list: None,\n+            stdout_handle: None,\n         }\n     }\n \n@@ -198,7 +202,8 @@ impl Task {\n             coroutine: Some(Coroutine::new(stack_pool, stack_size, start)),\n             sched: None,\n             task_type: GreenTask(Some(home)),\n-            borrow_list: None\n+            borrow_list: None,\n+            stdout_handle: None,\n         }\n     }\n \n@@ -234,6 +239,7 @@ impl Task {\n \n             // Run the task main function, then do some cleanup.\n             do f.finally {\n+\n                 // First, destroy task-local storage. This may run user dtors.\n                 //\n                 // FIXME #8302: Dear diary. I'm so tired and confused.\n@@ -257,6 +263,17 @@ impl Task {\n \n                 // Destroy remaining boxes. Also may run user dtors.\n                 unsafe { cleanup::annihilate(); }\n+\n+                // Finally flush and destroy any output handles which the task\n+                // owns. There are no boxes here, and no user destructors should\n+                // run after this any more.\n+                match self.stdout_handle.take() {\n+                    Some(handle) => {\n+                        let mut handle = handle;\n+                        handle.flush();\n+                    }\n+                    None => {}\n+                }\n             }\n         }\n \n@@ -331,7 +348,7 @@ impl Task {\n impl Drop for Task {\n     fn drop(&mut self) {\n         rtdebug!(\"called drop for a task: {}\", borrow::to_uint(self));\n-        rtassert!(self.destroyed)\n+        rtassert!(self.destroyed);\n     }\n }\n "}, {"sha": "1d78a2a8f2ba8c75a41d6c0678918be1bc70e447", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=e8f72c38f4bf74e7291043917fdd0bae1404b407", "patch": "@@ -1791,7 +1791,7 @@ impl RtioTTY for UvTTY {\n     }\n \n     fn isatty(&self) -> bool {\n-        unsafe { uvll::guess_handle(self.fd) == uvll::UV_TTY }\n+        unsafe { uvll::guess_handle(self.fd) == uvll::UV_TTY as c_int }\n     }\n }\n "}, {"sha": "18e95c8966e18eb2d7c4de039cf07d8db2f0a984", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=e8f72c38f4bf74e7291043917fdd0bae1404b407", "patch": "@@ -977,7 +977,8 @@ pub unsafe fn tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n     #[fixed_stack_segment]; #[inline(never)];\n     rust_uv_tty_get_winsize(tty, width, height)\n }\n-pub unsafe fn guess_handle(fd: c_int) -> uv_handle_type {\n+// FIXME(#9613) this should return uv_handle_type, not a c_int\n+pub unsafe fn guess_handle(fd: c_int) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n     rust_uv_guess_handle(fd)\n }\n@@ -1148,7 +1149,7 @@ extern {\n     fn rust_uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int;\n     fn rust_uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n                                height: *c_int) -> c_int;\n-    fn rust_uv_guess_handle(fd: c_int) -> uv_handle_type;\n+    fn rust_uv_guess_handle(fd: c_int) -> c_int;\n \n     // XXX: see comments in addrinfo.rs\n     // These should all really be constants..."}, {"sha": "c59dacab88990863a046da9caa94b0bdf1d8aef9", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e8f72c38f4bf74e7291043917fdd0bae1404b407/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=e8f72c38f4bf74e7291043917fdd0bae1404b407", "patch": "@@ -659,7 +659,7 @@ rust_uv_tty_get_winsize(uv_tty_t *tty, int *width, int *height) {\n     return uv_tty_get_winsize(tty, width, height);\n }\n \n-extern \"C\" uv_handle_type\n+extern \"C\" int\n rust_uv_guess_handle(int fd) {\n     return uv_guess_handle(fd);\n }"}]}