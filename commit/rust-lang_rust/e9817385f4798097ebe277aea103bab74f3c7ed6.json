{"sha": "e9817385f4798097ebe277aea103bab74f3c7ed6", "node_id": "C_kwDOAAsO6NoAKGU5ODE3Mzg1ZjQ3OTgwOTdlYmUyNzdhZWExMDNiYWI3NGYzYzdlZDY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-03-13T13:31:05Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-03-24T12:41:21Z"}, "message": "Fix rustdoc intra-doc link invalid ambiguity error message", "tree": {"sha": "1595ccb4967f73c8cd367ab5cbb120fa6567e01e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1595ccb4967f73c8cd367ab5cbb120fa6567e01e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9817385f4798097ebe277aea103bab74f3c7ed6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9817385f4798097ebe277aea103bab74f3c7ed6", "html_url": "https://github.com/rust-lang/rust/commit/e9817385f4798097ebe277aea103bab74f3c7ed6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9817385f4798097ebe277aea103bab74f3c7ed6/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84dd6dfd9d19176cc3c94bc1448a841e44d57890", "url": "https://api.github.com/repos/rust-lang/rust/commits/84dd6dfd9d19176cc3c94bc1448a841e44d57890", "html_url": "https://github.com/rust-lang/rust/commit/84dd6dfd9d19176cc3c94bc1448a841e44d57890"}], "stats": {"total": 340, "additions": 198, "deletions": 142}, "files": [{"sha": "7e24318dec8a630b0083337619a015f84a179af2", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 198, "deletions": 142, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/e9817385f4798097ebe277aea103bab74f3c7ed6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9817385f4798097ebe277aea103bab74f3c7ed6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e9817385f4798097ebe277aea103bab74f3c7ed6", "patch": "@@ -47,7 +47,18 @@ fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     krate\n }\n \n-#[derive(Copy, Clone, Debug, Hash)]\n+fn filter_assoc_items_by_name_and_namespace<'a>(\n+    tcx: TyCtxt<'a>,\n+    assoc_items_of: DefId,\n+    ident: Ident,\n+    ns: Namespace,\n+) -> impl Iterator<Item = &ty::AssocItem> + 'a {\n+    tcx.associated_items(assoc_items_of).filter_by_name_unhygienic(ident.name).filter(move |item| {\n+        item.kind.namespace() == ns && tcx.hygienic_eq(ident, item.ident(tcx), assoc_items_of)\n+    })\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq)]\n enum Res {\n     Def(DefKind, DefId),\n     Primitive(PrimitiveType),\n@@ -317,14 +328,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n         item_name: Symbol,\n-    ) -> Option<(Res, DefId)> {\n+    ) -> Vec<(Res, DefId)> {\n         let tcx = self.cx.tcx;\n \n-        prim_ty.impls(tcx).find_map(|impl_| {\n-            tcx.associated_items(impl_)\n-                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n+        prim_ty\n+            .impls(tcx)\n+            .flat_map(|impl_| {\n+                filter_assoc_items_by_name_and_namespace(\n+                    tcx,\n+                    impl_,\n+                    Ident::with_dummy_span(item_name),\n+                    ns,\n+                )\n                 .map(|item| (Res::Primitive(prim_ty), item.def_id))\n-        })\n+            })\n+            .collect::<Vec<_>>()\n     }\n \n     fn resolve_self_ty(&self, path_str: &str, ns: Namespace, item_id: DefId) -> Option<Res> {\n@@ -394,14 +412,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         ns: Namespace,\n         item_id: DefId,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<DefId>), UnresolvedPath<'path>> {\n+    ) -> Result<Vec<(Res, Option<DefId>)>, UnresolvedPath<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, item_id, module_id) {\n             return Ok(match res {\n                 Res::Def(\n                     DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Variant,\n                     def_id,\n-                ) => (Res::from_def_id(self.cx.tcx, self.cx.tcx.parent(def_id)), Some(def_id)),\n-                _ => (res, None),\n+                ) => {\n+                    vec![(Res::from_def_id(self.cx.tcx, self.cx.tcx.parent(def_id)), Some(def_id))]\n+                }\n+                _ => vec![(res, None)],\n             });\n         } else if ns == MacroNS {\n             return Err(UnresolvedPath {\n@@ -436,14 +456,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // links to primitives when `#[doc(primitive)]` is present. It should give an ambiguity\n         // error instead and special case *only* modules with `#[doc(primitive)]`, not all\n         // primitives.\n-        resolve_primitive(&path_root, TypeNS)\n+        match resolve_primitive(&path_root, TypeNS)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, item_id, module_id))\n             .and_then(|ty_res| {\n-                self.resolve_associated_item(ty_res, item_name, ns, module_id).map(Ok)\n-            })\n-            .unwrap_or_else(|| {\n+                let candidates = self\n+                    .resolve_associated_item(ty_res, item_name, ns, module_id)\n+                    .into_iter()\n+                    .map(|(res, def_id)| (res, Some(def_id)))\n+                    .collect::<Vec<_>>();\n+                if !candidates.is_empty() { Some(candidates) } else { None }\n+            }) {\n+            Some(r) => Ok(r),\n+            None => {\n                 if ns == Namespace::ValueNS {\n                     self.variant_field(path_str, item_id, module_id)\n+                        .map(|(res, def_id)| vec![(res, Some(def_id))])\n                 } else {\n                     Err(UnresolvedPath {\n                         item_id,\n@@ -452,8 +479,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         unresolved: path_root.into(),\n                     })\n                 }\n-            })\n-            .map(|(res, def_id)| (res, Some(def_id)))\n+            }\n+        }\n     }\n \n     /// Convert a DefId to a Res, where possible.\n@@ -535,24 +562,31 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_name: Symbol,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Option<(Res, DefId)> {\n+    ) -> Vec<(Res, DefId)> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n             Res::Primitive(prim) => {\n-                self.resolve_primitive_associated_item(prim, ns, item_name).or_else(|| {\n+                let items = self.resolve_primitive_associated_item(prim, ns, item_name);\n+                if !items.is_empty() {\n+                    items\n+                // Inherent associated items take precedence over items that come from trait impls.\n+                } else {\n                     self.primitive_type_to_ty(prim)\n-                        .and_then(|ty| {\n+                        .map(|ty| {\n                             resolve_associated_trait_item(ty, module_id, item_name, ns, self.cx)\n+                                .iter()\n+                                .map(|item| (root_res, item.def_id))\n+                                .collect::<Vec<_>>()\n                         })\n-                        .map(|item| (root_res, item.def_id))\n-                })\n+                        .unwrap_or(Vec::new())\n+                }\n             }\n             Res::Def(DefKind::TyAlias, did) => {\n                 // Resolve the link on the type the alias points to.\n                 // FIXME: if the associated item is defined directly on the type alias,\n                 // it will show up on its documentation page, we should link there instead.\n-                let res = self.def_id_to_res(did)?;\n+                let Some(res) = self.def_id_to_res(did) else { return Vec::new() };\n                 self.resolve_associated_item(res, item_name, ns, module_id)\n             }\n             Res::Def(\n@@ -566,7 +600,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::Adt(adt_def, _) => {\n                             for variant in adt_def.variants() {\n                                 if variant.name == item_name {\n-                                    return Some((root_res, variant.def_id));\n+                                    return vec![(root_res, variant.def_id)];\n                                 }\n                             }\n                         }\n@@ -575,43 +609,46 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n \n                 // Checks if item_name belongs to `impl SomeItem`\n-                let assoc_item = tcx\n+                let mut assoc_items: Vec<_> = tcx\n                     .inherent_impls(did)\n                     .iter()\n                     .flat_map(|&imp| {\n-                        tcx.associated_items(imp).find_by_name_and_namespace(\n+                        filter_assoc_items_by_name_and_namespace(\n                             tcx,\n+                            imp,\n                             Ident::with_dummy_span(item_name),\n                             ns,\n-                            imp,\n                         )\n                     })\n-                    .copied()\n-                    // There should only ever be one associated item that matches from any inherent impl\n-                    .next()\n+                    .map(|item| (root_res, item.def_id))\n+                    .collect();\n+\n+                if assoc_items.is_empty() {\n                     // Check if item_name belongs to `impl SomeTrait for SomeItem`\n                     // FIXME(#74563): This gives precedence to `impl SomeItem`:\n                     // Although having both would be ambiguous, use impl version for compatibility's sake.\n                     // To handle that properly resolve() would have to support\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n-                    .or_else(|| {\n-                        resolve_associated_trait_item(\n-                            tcx.type_of(did).subst_identity(),\n-                            module_id,\n-                            item_name,\n-                            ns,\n-                            self.cx,\n-                        )\n-                    });\n+                    assoc_items = resolve_associated_trait_item(\n+                        tcx.type_of(did).subst_identity(),\n+                        module_id,\n+                        item_name,\n+                        ns,\n+                        self.cx,\n+                    )\n+                    .into_iter()\n+                    .map(|item| (root_res, item.def_id))\n+                    .collect::<Vec<_>>();\n+                }\n \n-                debug!(\"got associated item {:?}\", assoc_item);\n+                debug!(\"got associated item {:?}\", assoc_items);\n \n-                if let Some(item) = assoc_item {\n-                    return Some((root_res, item.def_id));\n+                if !assoc_items.is_empty() {\n+                    return assoc_items;\n                 }\n \n                 if ns != Namespace::ValueNS {\n-                    return None;\n+                    return Vec::new();\n                 }\n                 debug!(\"looking for fields named {} for {:?}\", item_name, did);\n                 // FIXME: this doesn't really belong in `associated_item` (maybe `variant_field` is better?)\n@@ -631,20 +668,27 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 // field syntax) and are handled by the compiler's resolver.\n                 let def = match tcx.type_of(did).subst_identity().kind() {\n                     ty::Adt(def, _) if !def.is_enum() => def,\n-                    _ => return None,\n+                    _ => return Vec::new(),\n                 };\n-                let field =\n-                    def.non_enum_variant().fields.iter().find(|item| item.name == item_name)?;\n-                Some((root_res, field.did))\n+                def.non_enum_variant()\n+                    .fields\n+                    .iter()\n+                    .filter(|field| field.name == item_name)\n+                    .map(|field| (root_res, field.did))\n+                    .collect::<Vec<_>>()\n             }\n-            Res::Def(DefKind::Trait, did) => tcx\n-                .associated_items(did)\n-                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n-                .map(|item| {\n-                    let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                    (res, item.def_id)\n-                }),\n-            _ => None,\n+            Res::Def(DefKind::Trait, did) => filter_assoc_items_by_name_and_namespace(\n+                tcx,\n+                did,\n+                Ident::with_dummy_span(item_name),\n+                ns,\n+            )\n+            .map(|item| {\n+                let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n+                (res, item.def_id)\n+            })\n+            .collect::<Vec<_>>(),\n+            _ => Vec::new(),\n         }\n     }\n }\n@@ -664,27 +708,34 @@ fn resolve_associated_trait_item<'a>(\n     item_name: Symbol,\n     ns: Namespace,\n     cx: &mut DocContext<'a>,\n-) -> Option<ty::AssocItem> {\n+) -> Vec<ty::AssocItem> {\n     // FIXME: this should also consider blanket impls (`impl<T> X for T`). Unfortunately\n     // `get_auto_trait_and_blanket_impls` is broken because the caching behavior is wrong. In the\n     // meantime, just don't look for these blanket impls.\n \n     // Next consider explicit impls: `impl MyTrait for MyType`\n     // Give precedence to inherent impls.\n     let traits = trait_impls_for(cx, ty, module);\n+    let tcx = cx.tcx;\n     debug!(\"considering traits {:?}\", traits);\n-    let mut candidates = traits.iter().filter_map(|&(impl_, trait_)| {\n-        cx.tcx\n-            .associated_items(trait_)\n-            .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n-            .map(|trait_assoc| {\n-                trait_assoc_to_impl_assoc_item(cx.tcx, impl_, trait_assoc.def_id)\n+    let candidates = traits\n+        .iter()\n+        .flat_map(|&(impl_, trait_)| {\n+            filter_assoc_items_by_name_and_namespace(\n+                cx.tcx,\n+                trait_,\n+                Ident::with_dummy_span(item_name),\n+                ns,\n+            )\n+            .map(move |trait_assoc| {\n+                trait_assoc_to_impl_assoc_item(tcx, impl_, trait_assoc.def_id)\n                     .unwrap_or(*trait_assoc)\n             })\n-    });\n+        })\n+        .collect::<Vec<_>>();\n     // FIXME(#74563): warn about ambiguity\n-    debug!(\"the candidates were {:?}\", candidates.clone().collect::<Vec<_>>());\n-    candidates.next()\n+    debug!(\"the candidates were {:?}\", candidates);\n+    candidates\n }\n \n /// Find the associated item in the impl `impl_id` that corresponds to the\n@@ -755,20 +806,6 @@ fn trait_impls_for<'a>(\n     iter.collect()\n }\n \n-/// Check for resolve collisions between a trait and its derive.\n-///\n-/// These are common and we should just resolve to the trait in that case.\n-fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_>>>) -> bool {\n-    matches!(\n-        *ns,\n-        PerNS {\n-            type_ns: Ok((Res::Def(DefKind::Trait, _), _)),\n-            macro_ns: Ok((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n-            ..\n-        }\n-    )\n-}\n-\n impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         self.resolve_links(item);\n@@ -978,15 +1015,15 @@ impl LinkCollector<'_, '_> {\n                     res = prim;\n                 } else {\n                     // `[char]` when a `char` module is in scope\n-                    let candidates = vec![res, prim];\n+                    let candidates = vec![(res, res.def_id(self.cx.tcx)), (prim, None)];\n                     ambiguity_error(self.cx, diag_info, path_str, candidates);\n                     return None;\n                 }\n             }\n         }\n \n         match res {\n-            Res::Primitive(prim) => {\n+            Res::Primitive(_) => {\n                 if let Some(UrlFragment::Item(id)) = fragment {\n                     // We're actually resolving an associated item of a primitive, so we need to\n                     // verify the disambiguator (if any) matches the type of the associated item.\n@@ -1006,15 +1043,6 @@ impl LinkCollector<'_, '_> {\n                         item,\n                         &diag_info,\n                     )?;\n-\n-                    // FIXME: it would be nice to check that the feature gate was enabled in the original crate, not just ignore it altogether.\n-                    // However I'm not sure how to check that across crates.\n-                    if prim == PrimitiveType::RawPointer\n-                        && item.item_id.is_local()\n-                        && !self.cx.tcx.features().intra_doc_pointers\n-                    {\n-                        self.report_rawptr_assoc_feature_gate(dox, ori_link, item);\n-                    }\n                 } else {\n                     match disambiguator {\n                         Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {}\n@@ -1135,10 +1163,9 @@ impl LinkCollector<'_, '_> {\n         report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, diag_info, callback);\n     }\n \n-    fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &MarkdownLink, item: &Item) {\n-        let span =\n-            super::source_span_for_markdown_range(self.cx.tcx, dox, &ori_link.range, &item.attrs)\n-                .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n+    fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &Range<usize>, item: &Item) {\n+        let span = super::source_span_for_markdown_range(self.cx.tcx, dox, ori_link, &item.attrs)\n+            .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n         rustc_session::parse::feature_err(\n             &self.cx.tcx.sess.parse_sess,\n             sym::intra_doc_pointers,\n@@ -1163,7 +1190,23 @@ impl LinkCollector<'_, '_> {\n             }\n         }\n \n-        let res = self.resolve_with_disambiguator(&key, diag.clone()).and_then(|(res, def_id)| {\n+        let mut candidates = self.resolve_with_disambiguator(&key, diag.clone());\n+\n+        // FIXME: it would be nice to check that the feature gate was enabled in the original crate, not just ignore it altogether.\n+        // However I'm not sure how to check that across crates.\n+        if let Some(candidate) = candidates.get(0) &&\n+            candidate.0 == Res::Primitive(PrimitiveType::RawPointer) &&\n+            key.path_str.contains(\"::\") // We only want to check this if this is an associated item.\n+        {\n+            if key.item_id.is_local() && !self.cx.tcx.features().intra_doc_pointers {\n+                self.report_rawptr_assoc_feature_gate(diag.dox, &diag.link_range, diag.item);\n+                return None;\n+            } else {\n+                candidates = vec![candidates[0]];\n+            }\n+        }\n+\n+        if let &[(res, def_id)] = candidates.as_slice() {\n             let fragment = match (&key.extra_fragment, def_id) {\n                 (Some(_), Some(def_id)) => {\n                     report_anchor_conflict(self.cx, diag, def_id);\n@@ -1173,13 +1216,18 @@ impl LinkCollector<'_, '_> {\n                 (None, Some(def_id)) => Some(UrlFragment::Item(def_id)),\n                 (None, None) => None,\n             };\n-            Some((res, fragment))\n-        });\n+            let r = Some((res, fragment));\n+            self.visited_links.insert(key, r.clone());\n+            return r;\n+        }\n \n-        if res.is_some() || cache_errors {\n-            self.visited_links.insert(key, res.clone());\n+        if !candidates.is_empty() {\n+            ambiguity_error(self.cx, diag, &key.path_str, candidates);\n         }\n-        res\n+        if cache_errors {\n+            self.visited_links.insert(key, None);\n+        }\n+        None\n     }\n \n     /// After parsing the disambiguator, resolve the main part of the link.\n@@ -1188,7 +1236,7 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         key: &ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n-    ) -> Option<(Res, Option<DefId>)> {\n+    ) -> Vec<(Res, Option<DefId>)> {\n         let disambiguator = key.dis;\n         let path_str = &key.path_str;\n         let item_id = key.item_id;\n@@ -1197,7 +1245,7 @@ impl LinkCollector<'_, '_> {\n         match disambiguator.map(Disambiguator::ns) {\n             Some(expected_ns) => {\n                 match self.resolve(path_str, expected_ns, item_id, module_id) {\n-                    Ok(res) => Some(res),\n+                    Ok(candidates) => candidates,\n                     Err(err) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n                         // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`.\n@@ -1206,10 +1254,11 @@ impl LinkCollector<'_, '_> {\n                         for other_ns in [TypeNS, ValueNS, MacroNS] {\n                             if other_ns != expected_ns {\n                                 if let Ok(res) =\n-                                    self.resolve(path_str, other_ns, item_id, module_id)\n+                                    self.resolve(path_str, other_ns, item_id, module_id) &&\n+                                    !res.is_empty()\n                                 {\n                                     err = ResolutionFailure::WrongNamespace {\n-                                        res: full_res(self.cx.tcx, res),\n+                                        res: full_res(self.cx.tcx, res[0]),\n                                         expected_ns,\n                                     };\n                                     break;\n@@ -1230,18 +1279,26 @@ impl LinkCollector<'_, '_> {\n                 let candidates = PerNS {\n                     macro_ns: candidate(MacroNS),\n                     type_ns: candidate(TypeNS),\n-                    value_ns: candidate(ValueNS).and_then(|(res, def_id)| {\n-                        match res {\n-                            // Constructors are picked up in the type namespace.\n-                            Res::Def(DefKind::Ctor(..), _) => {\n-                                Err(ResolutionFailure::WrongNamespace { res, expected_ns: TypeNS })\n+                    value_ns: candidate(ValueNS).and_then(|v_res| {\n+                        for (res, _) in v_res.iter() {\n+                            match res {\n+                                // Constructors are picked up in the type namespace.\n+                                Res::Def(DefKind::Ctor(..), _) => {\n+                                    return Err(ResolutionFailure::WrongNamespace {\n+                                        res: *res,\n+                                        expected_ns: TypeNS,\n+                                    });\n+                                }\n+                                _ => {}\n                             }\n-                            _ => Ok((res, def_id)),\n                         }\n+                        Ok(v_res)\n                     }),\n                 };\n \n-                let len = candidates.iter().filter(|res| res.is_ok()).count();\n+                let len = candidates\n+                    .iter()\n+                    .fold(0, |acc, res| if let Ok(res) = res { acc + res.len() } else { acc });\n \n                 if len == 0 {\n                     return resolution_failure(\n@@ -1253,21 +1310,7 @@ impl LinkCollector<'_, '_> {\n                     );\n                 }\n \n-                if len == 1 {\n-                    Some(candidates.into_iter().find_map(|res| res.ok()).unwrap())\n-                } else if len == 2 && is_derive_trait_collision(&candidates) {\n-                    Some(candidates.type_ns.unwrap())\n-                } else {\n-                    let ignore_macro = is_derive_trait_collision(&candidates);\n-                    // If we're reporting an ambiguity, don't mention the namespaces that failed\n-                    let mut candidates =\n-                        candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n-                    if ignore_macro {\n-                        candidates.macro_ns = None;\n-                    }\n-                    ambiguity_error(self.cx, diag, path_str, candidates.present_items().collect());\n-                    None\n-                }\n+                candidates.into_iter().filter_map(|res| res.ok()).flatten().collect::<Vec<_>>()\n             }\n         }\n     }\n@@ -1554,7 +1597,7 @@ fn resolution_failure(\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,\n     kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n-) -> Option<(Res, Option<DefId>)> {\n+) -> Vec<(Res, Option<DefId>)> {\n     let tcx = collector.cx.tcx;\n     let mut recovered_res = None;\n     report_diagnostic(\n@@ -1613,11 +1656,13 @@ fn resolution_failure(\n                         };\n                         name = start;\n                         for ns in [TypeNS, ValueNS, MacroNS] {\n-                            if let Ok(res) = collector.resolve(start, ns, item_id, module_id) {\n-                                debug!(\"found partial_res={:?}\", res);\n-                                *partial_res = Some(full_res(collector.cx.tcx, res));\n-                                *unresolved = end.into();\n-                                break 'outer;\n+                            if let Ok(v_res) = collector.resolve(start, ns, item_id, module_id) {\n+                                debug!(\"found partial_res={:?}\", v_res);\n+                                if !v_res.is_empty() {\n+                                    *partial_res = Some(full_res(collector.cx.tcx, v_res[0]));\n+                                    *unresolved = end.into();\n+                                    break 'outer;\n+                                }\n                             }\n                         }\n                         *unresolved = end.into();\n@@ -1765,7 +1810,10 @@ fn resolution_failure(\n         },\n     );\n \n-    recovered_res\n+    match recovered_res {\n+        Some(r) => vec![r],\n+        None => Vec::new(),\n+    }\n }\n \n fn report_multiple_anchors(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n@@ -1854,24 +1902,32 @@ fn ambiguity_error(\n     cx: &DocContext<'_>,\n     diag_info: DiagnosticInfo<'_>,\n     path_str: &str,\n-    candidates: Vec<Res>,\n+    candidates: Vec<(Res, Option<DefId>)>,\n ) {\n     let mut msg = format!(\"`{}` is \", path_str);\n+    let kinds = candidates\n+        .into_iter()\n+        .map(\n+            |(res, def_id)| {\n+                if let Some(def_id) = def_id { Res::from_def_id(cx.tcx, def_id) } else { res }\n+            },\n+        )\n+        .collect::<Vec<_>>();\n \n-    match candidates.as_slice() {\n-        [first_def, second_def] => {\n+    match kinds.as_slice() {\n+        [res1, res2] => {\n             msg += &format!(\n                 \"both {} {} and {} {}\",\n-                first_def.article(),\n-                first_def.descr(),\n-                second_def.article(),\n-                second_def.descr(),\n+                res1.article(),\n+                res1.descr(),\n+                res2.article(),\n+                res2.descr()\n             );\n         }\n         _ => {\n-            let mut candidates = candidates.iter().peekable();\n-            while let Some(res) = candidates.next() {\n-                if candidates.peek().is_some() {\n+            let mut kinds = kinds.iter().peekable();\n+            while let Some(res) = kinds.next() {\n+                if kinds.peek().is_some() {\n                     msg += &format!(\"{} {}, \", res.article(), res.descr());\n                 } else {\n                     msg += &format!(\"and {} {}\", res.article(), res.descr());\n@@ -1887,7 +1943,7 @@ fn ambiguity_error(\n             diag.note(\"ambiguous link\");\n         }\n \n-        for res in candidates {\n+        for res in kinds {\n             suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n         }\n     });"}]}