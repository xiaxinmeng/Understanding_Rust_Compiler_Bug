{"sha": "32c337724dd3a1b651cb7ba9769e60262f9f52f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyYzMzNzcyNGRkM2ExYjY1MWNiN2JhOTc2OWU2MDI2MmY5ZjUyZjg=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-05-06T15:13:20Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-12T21:41:58Z"}, "message": "Avoid unnecessary false edges in MIR match lowering", "tree": {"sha": "324d64a06ad04d9e2cdfb467c8c4d6d26b2a8c48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/324d64a06ad04d9e2cdfb467c8c4d6d26b2a8c48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32c337724dd3a1b651cb7ba9769e60262f9f52f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32c337724dd3a1b651cb7ba9769e60262f9f52f8", "html_url": "https://github.com/rust-lang/rust/commit/32c337724dd3a1b651cb7ba9769e60262f9f52f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32c337724dd3a1b651cb7ba9769e60262f9f52f8/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33bc396ff721d9beb9a918099e71852b734a0790", "url": "https://api.github.com/repos/rust-lang/rust/commits/33bc396ff721d9beb9a918099e71852b734a0790", "html_url": "https://github.com/rust-lang/rust/commit/33bc396ff721d9beb9a918099e71852b734a0790"}], "stats": {"total": 151, "additions": 98, "deletions": 53}, "files": [{"sha": "38c9a177c388ef6e6d6621736a9f9e8f5e1e07a5", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 65, "deletions": 53, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/32c337724dd3a1b651cb7ba9769e60262f9f52f8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c337724dd3a1b651cb7ba9769e60262f9f52f8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=32c337724dd3a1b651cb7ba9769e60262f9f52f8", "patch": "@@ -143,19 +143,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // create binding start block for link them by false edges\n         let candidate_count = arms.iter().map(|c| c.patterns.len()).sum::<usize>();\n-        let pre_binding_blocks: Vec<_> = (0..=candidate_count)\n+        let pre_binding_blocks: Vec<_> = (0..candidate_count)\n             .map(|_| self.cfg.start_new_block())\n             .collect();\n \n-        // There's one more pre_binding block than there are candidates so that\n-        // every candidate can have a `next_candidate_pre_binding_block`.\n-        let outer_source_info = self.source_info(span);\n-        self.cfg.terminate(\n-            *pre_binding_blocks.last().unwrap(),\n-            outer_source_info,\n-            TerminatorKind::Unreachable,\n-        );\n-\n         let mut match_has_guard = false;\n \n         let mut candidate_pre_binding_blocks = pre_binding_blocks.iter();\n@@ -171,9 +162,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let arm_candidates: Vec<_> = arm.patterns\n                     .iter()\n                     .zip(candidate_pre_binding_blocks.by_ref())\n-                    .zip(next_candidate_pre_binding_blocks.by_ref())\n                     .map(\n-                        |((pattern, pre_binding_block), next_candidate_pre_binding_block)| {\n+                        |(pattern, pre_binding_block)| {\n                             Candidate {\n                                 span: pattern.span,\n                                 match_pairs: vec![\n@@ -188,7 +178,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 },\n                                 pre_binding_block: *pre_binding_block,\n                                 next_candidate_pre_binding_block:\n-                                    *next_candidate_pre_binding_block,\n+                                    next_candidate_pre_binding_blocks.next().copied(),\n                             }\n                         },\n                     )\n@@ -225,6 +215,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             &mut fake_borrows,\n         );\n \n+        let outer_source_info = self.source_info(span);\n+\n         if !otherwise.is_empty() {\n             // All matches are exhaustive. However, because some matches\n             // only have exponentially-large exhaustive decision trees, we\n@@ -251,12 +243,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         // Step 5. Create everything else: the guards and the arms.\n-\n-        let arm_end_blocks: Vec<_> = arm_candidates.into_iter().map(|(arm, candidates)| {\n+        let arm_end_blocks: Vec<_> = arm_candidates.into_iter().map(|(arm, mut candidates)| {\n             let arm_source_info = self.source_info(arm.span);\n             let region_scope = (arm.scope, arm_source_info);\n             self.in_scope(region_scope, arm.lint_level, |this| {\n-                let arm_block = this.cfg.start_new_block();\n+                let mut arm_block = this.cfg.start_new_block();\n \n                 let body = this.hir.mirror(arm.body.clone());\n                 let scope = this.declare_bindings(\n@@ -267,6 +258,30 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Some((Some(&scrutinee_place), scrutinee_span)),\n                 );\n \n+                if candidates.len() == 1 {\n+                    arm_block = self.bind_and_guard_matched_candidate(\n+                        candidates.pop().unwrap(),\n+                        arm.guard.clone(),\n+                        &fake_borrow_temps,\n+                        scrutinee_span,\n+                    );\n+                } else {\n+                    arm_block = self.cfg.start_new_block();\n+                    for candidate in candidates {\n+                        let binding_end = self.bind_and_guard_matched_candidate(\n+                            candidate,\n+                            arm.guard.clone(),\n+                            &fake_borrow_temps,\n+                            scrutinee_span,\n+                        );\n+                        self.cfg.terminate(\n+                            binding_end,\n+                            source_info,\n+                            TerminatorKind::Goto { target: arm_block },\n+                        );\n+                    }\n+                }\n+\n                 if let Some(source_scope) = scope {\n                     this.source_scope = source_scope;\n                 }\n@@ -434,7 +449,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // since we don't call `match_candidates`, next fields are unused\n             otherwise_block: None,\n             pre_binding_block: block,\n-            next_candidate_pre_binding_block: block,\n+            next_candidate_pre_binding_block: None,\n         };\n \n         // Simplify the candidate. Since the pattern is irrefutable, this should\n@@ -689,7 +704,7 @@ pub struct Candidate<'pat, 'tcx: 'pat> {\n \n     // ...and the blocks for add false edges between candidates\n     pre_binding_block: BasicBlock,\n-    next_candidate_pre_binding_block: BasicBlock,\n+    next_candidate_pre_binding_block: Option<BasicBlock>,\n }\n \n #[derive(Clone, Debug)]\n@@ -956,14 +971,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             if let [first_candidate, second_candidate] = window {\n                 let source_info = self.source_info(first_candidate.span);\n                 if let Some(otherwise_block) = first_candidate.otherwise_block {\n-                    self.cfg.terminate(\n+                    self.false_edges(\n                         otherwise_block,\n+                        second_candidate.pre_binding_block,\n+                        first_candidate.next_candidate_pre_binding_block,\n                         source_info,\n-                        TerminatorKind::FalseEdges {\n-                            real_target: second_candidate.pre_binding_block,\n-                            imaginary_target: first_candidate.next_candidate_pre_binding_block,\n-                        }\n-                    )\n+                    );\n                 } else {\n                     bug!(\"candidate other than the last has no guard\");\n                 }\n@@ -977,13 +990,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             if let Some(otherwise) = candidate.otherwise_block {\n                 let source_info = self.source_info(candidate.span);\n                 let unreachable = self.cfg.start_new_block();\n-                self.cfg.terminate(\n+                self.false_edges(\n                     otherwise,\n+                    unreachable,\n+                    candidate.next_candidate_pre_binding_block,\n                     source_info,\n-                    TerminatorKind::FalseEdges {\n-                        real_target: unreachable,\n-                        imaginary_targets: candidate.next_candidate_pre_binding_block,\n-                    }\n                 );\n                 self.cfg.terminate(unreachable, source_info, TerminatorKind::Unreachable);\n             }\n@@ -994,13 +1005,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         if let Some(otherwise) = last_candidate.otherwise_block {\n             let source_info = self.source_info(last_candidate.span);\n             let block = self.cfg.start_new_block();\n-            self.cfg.terminate(\n+            self.false_edges(\n                 otherwise,\n+                block,\n+                last_candidate.next_candidate_pre_binding_block,\n                 source_info,\n-                TerminatorKind::FalseEdges {\n-                    real_target: block,\n-                    imaginary_target: last_candidate.next_candidate_pre_binding_block,\n-                }\n             );\n             Some(block)\n         } else {\n@@ -1311,27 +1320,38 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n         guard: Option<Guard<'tcx>>,\n-        arm_block: BasicBlock,\n         fake_borrows: &Vec<(&Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         region_scope: (region::Scope, SourceInfo),\n     ) {\n+    ) -> BasicBlock {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n         debug_assert!(candidate.match_pairs.is_empty());\n \n         let candidate_source_info = self.source_info(candidate.span);\n \n-        let mut block = self.cfg.start_new_block();\n-        self.cfg.terminate(\n-            candidate.pre_binding_block,\n+        let mut block = candidate.pre_binding_block;\n+\n+        // If we are adding our own statements, then we need a fresh block.\n+        let create_fresh_block = candidate.next_candidate_pre_binding_block.is_some()\n+            || !candidate.bindings.is_empty()\n+            || !candidate.ascriptions.is_empty()\n+            || guard.is_some();\n+\n+        if create_fresh_block {\n+            let fresh_block = self.cfg.start_new_block();\n+            self.false_edges(\n+                block,\n+                fresh_block,\n+                candidate.next_candidate_pre_binding_block,\n             candidate_source_info,\n-            TerminatorKind::FalseEdges {\n-                real_target: block,\n-                imaginary_target: candidate.next_candidate_pre_binding_block,\n-            },\n         );\n+            block = fresh_block;\n         self.ascribe_types(block, &candidate.ascriptions);\n+        } else {\n+            return block;\n+        }\n \n         // rust-lang/rust#27282: The `autoref` business deserves some\n         // explanation here.\n@@ -1476,7 +1496,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // because that would be before we've checked the result\n             // from the guard.\n             //\n-            // But binding them on `arm_block` is *too late*, because\n+            // But binding them on the arm is *too late*, because\n             // then all of the candidates for a single arm would be\n             // bound in the same place, that would cause a case like:\n             //\n@@ -1552,22 +1572,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 by_value_bindings,\n             );\n \n-            self.cfg.terminate(\n-                post_guard_block,\n-                source_info,\n-                TerminatorKind::Goto { target: arm_block },\n-            );\n+            post_guard_block\n         } else {\n             assert!(candidate.otherwise_block.is_none());\n             // (Here, it is not too early to bind the matched\n             // candidate on `block`, because there is no guard result\n             // that we have to inspect before we bind them.)\n             self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n-            self.cfg.terminate(\n-                block,\n-                candidate_source_info,\n-                TerminatorKind::Goto { target: arm_block },\n-            );\n+            block\n         }\n     }\n "}, {"sha": "04ae5a87e49e6a68d56e15c6f3b3ab804752cddc", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/32c337724dd3a1b651cb7ba9769e60262f9f52f8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c337724dd3a1b651cb7ba9769e60262f9f52f8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=32c337724dd3a1b651cb7ba9769e60262f9f52f8", "patch": "@@ -65,6 +65,39 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                   })\n         );\n     }\n+\n+    /// Creates a false edge to `imaginary_target` and a real edge to\n+    /// real_target. If `imaginary_target` is none, or is the same as the real\n+    /// target, a Goto is generated instead to simplify the generated MIR.\n+    pub fn false_edges(\n+        &mut self,\n+        from_block: BasicBlock,\n+        real_target: BasicBlock,\n+        imaginary_target: Option<BasicBlock>,\n+        source_info: SourceInfo,\n+    )  {\n+        match imaginary_target {\n+            Some(target) if target != real_target => {\n+                self.cfg.terminate(\n+                    from_block,\n+                    source_info,\n+                    TerminatorKind::FalseEdges {\n+                        real_target,\n+                        imaginary_target: target,\n+                    },\n+                );\n+            }\n+            _ => {\n+                self.cfg.terminate(\n+                    from_block,\n+                    source_info,\n+                    TerminatorKind::Goto {\n+                        target: real_target\n+                    }\n+                );\n+            }\n+        }\n+    }\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {"}]}