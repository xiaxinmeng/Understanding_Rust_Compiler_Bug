{"sha": "162dea51bfa6b7f6d64d138a84c16c96495a0fcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MmRlYTUxYmZhNmI3ZjZkNjRkMTM4YTg0YzE2Yzk2NDk1YTBmY2Q=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-17T17:22:46Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-17T17:22:46Z"}, "message": "hide root config", "tree": {"sha": "f321f11cd0d9c88c8c684f65312041d8db5598d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f321f11cd0d9c88c8c684f65312041d8db5598d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/162dea51bfa6b7f6d64d138a84c16c96495a0fcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/162dea51bfa6b7f6d64d138a84c16c96495a0fcd", "html_url": "https://github.com/rust-lang/rust/commit/162dea51bfa6b7f6d64d138a84c16c96495a0fcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/162dea51bfa6b7f6d64d138a84c16c96495a0fcd/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2", "html_url": "https://github.com/rust-lang/rust/commit/6b5d90972ae2f288ae7cf57e209c0d5d8c7a1fd2"}], "stats": {"total": 170, "additions": 89, "deletions": 81}, "files": [{"sha": "0cffc03f3ece2ef27b46b5e9ba9cf14c1ace66f2", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/162dea51bfa6b7f6d64d138a84c16c96495a0fcd/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162dea51bfa6b7f6d64d138a84c16c96495a0fcd/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=162dea51bfa6b7f6d64d138a84c16c96495a0fcd", "patch": "@@ -9,10 +9,10 @@ use relative_path::RelativePathBuf;\n use walkdir::WalkDir;\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watcher};\n \n-use crate::{RootConfig, Roots, VfsRoot};\n+use crate::{Roots, VfsRoot};\n \n pub(crate) enum Task {\n-    AddRoot { root: VfsRoot, config: Arc<RootConfig> },\n+    AddRoot { root: VfsRoot },\n }\n \n /// `TaskResult` transfers files read on the IO thread to the VFS on the main\n@@ -98,8 +98,8 @@ pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n                                 drop(input_receiver);\n                                 break\n                             },\n-                            Ok(Task::AddRoot { root, config }) => {\n-                                watch_root(watcher.as_mut(), &output_sender, root, Arc::clone(&config));\n+                            Ok(Task::AddRoot { root }) => {\n+                                watch_root(watcher.as_mut(), &output_sender, &*roots, root);\n                             }\n                         },\n                         // Watcher send us changes. If **this** channel is\n@@ -123,20 +123,21 @@ pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n fn watch_root(\n     watcher: Option<&mut RecommendedWatcher>,\n     sender: &Sender<TaskResult>,\n+    roots: &Roots,\n     root: VfsRoot,\n-    config: Arc<RootConfig>,\n ) {\n-    log::debug!(\"loading {} ...\", config.root.as_path().display());\n-    let files = watch_recursive(watcher, config.root.as_path(), &*config)\n+    let root_path = roots.path(root);\n+    log::debug!(\"loading {} ...\", root_path.display());\n+    let files = watch_recursive(watcher, root_path, roots, root)\n         .into_iter()\n         .filter_map(|path| {\n-            let abs_path = path.to_path(&config.root);\n+            let abs_path = path.to_path(&root_path);\n             let text = read_to_string(&abs_path)?;\n             Some((path, text))\n         })\n         .collect();\n     sender.send(TaskResult::BulkLoadRoot { root, files }).unwrap();\n-    log::debug!(\"... loaded {}\", config.root.as_path().display());\n+    log::debug!(\"... loaded {}\", root_path.display());\n }\n \n fn convert_notify_event(event: DebouncedEvent, sender: &Sender<(PathBuf, ChangeKind)>) {\n@@ -181,19 +182,18 @@ fn handle_change(\n         None => return,\n         Some(it) => it,\n     };\n-    let config = &roots[root];\n     match kind {\n         ChangeKind::Create => {\n             let mut paths = Vec::new();\n             if path.is_dir() {\n-                paths.extend(watch_recursive(watcher, &path, &config));\n+                paths.extend(watch_recursive(watcher, &path, roots, root));\n             } else {\n                 paths.push(rel_path);\n             }\n             paths\n                 .into_iter()\n                 .try_for_each(|rel_path| {\n-                    let abs_path = rel_path.to_path(&config.root);\n+                    let abs_path = rel_path.to_path(&roots.path(root));\n                     let text = read_to_string(&abs_path);\n                     sender.send(TaskResult::SingleFile { root, path: rel_path, text })\n                 })\n@@ -209,20 +209,21 @@ fn handle_change(\n fn watch_recursive(\n     mut watcher: Option<&mut RecommendedWatcher>,\n     dir: &Path,\n-    config: &RootConfig,\n+    roots: &Roots,\n+    root: VfsRoot,\n ) -> Vec<RelativePathBuf> {\n     let mut files = Vec::new();\n     for entry in WalkDir::new(dir)\n         .into_iter()\n-        .filter_entry(|it| config.contains(it.path()).is_some())\n+        .filter_entry(|it| roots.contains(root, it.path()).is_some())\n         .filter_map(|it| it.map_err(|e| log::warn!(\"watcher error: {}\", e)).ok())\n     {\n         if entry.file_type().is_dir() {\n             if let Some(watcher) = &mut watcher {\n                 watch_one(watcher, entry.path());\n             }\n         } else {\n-            let path = config.contains(entry.path()).unwrap();\n+            let path = roots.contains(root, entry.path()).unwrap();\n             files.push(path.to_owned());\n         }\n     }"}, {"sha": "c78096ee189934c68e61f41db9b846cedbafb7c5", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/162dea51bfa6b7f6d64d138a84c16c96495a0fcd/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162dea51bfa6b7f6d64d138a84c16c96495a0fcd/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=162dea51bfa6b7f6d64d138a84c16c96495a0fcd", "patch": "@@ -31,7 +31,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     io::{TaskResult, Worker},\n-    roots::{RootConfig, Roots},\n+    roots::Roots,\n };\n \n pub use crate::{\n@@ -74,18 +74,18 @@ impl Vfs {\n         let worker = io::start(Arc::clone(&roots));\n         let mut root2files = ArenaMap::default();\n \n-        for (root, config) in roots.iter() {\n+        for root in roots.iter() {\n             root2files.insert(root, Default::default());\n-            worker.sender().send(io::Task::AddRoot { root, config: Arc::clone(config) }).unwrap();\n+            worker.sender().send(io::Task::AddRoot { root }).unwrap();\n         }\n         let res =\n             Vfs { roots, files: Arena::default(), root2files, worker, pending_changes: Vec::new() };\n-        let vfs_roots = res.roots.iter().map(|(id, _)| id).collect();\n+        let vfs_roots = res.roots.iter().collect();\n         (res, vfs_roots)\n     }\n \n     pub fn root2path(&self, root: VfsRoot) -> PathBuf {\n-        self.roots[root].root.clone()\n+        self.roots.path(root).to_path_buf()\n     }\n \n     pub fn path2file(&self, path: &Path) -> Option<VfsFile> {\n@@ -97,7 +97,7 @@ impl Vfs {\n \n     pub fn file2path(&self, file: VfsFile) -> PathBuf {\n         let rel_path = &self.files[file].path;\n-        let root_path = &self.roots[self.files[file].root].root;\n+        let root_path = &self.roots.path(self.files[file].root);\n         rel_path.to_path(root_path)\n     }\n \n@@ -232,7 +232,7 @@ impl Vfs {\n     pub fn remove_file_overlay(&mut self, path: &Path) -> Option<VfsFile> {\n         if let Some((root, path, file)) = self.find_root(path) {\n             let file = file.expect(\"can't remove a file which wasn't added\");\n-            let full_path = path.to_path(&self.roots[root].root);\n+            let full_path = path.to_path(&self.roots.path(root));\n             if let Ok(text) = fs::read_to_string(&full_path) {\n                 self.do_change_file(file, text, true);\n             } else {"}, {"sha": "5e2776a35871fb04cf61a327c6062f49a14fad3b", "filename": "crates/ra_vfs/src/roots.rs", "status": "modified", "additions": 66, "deletions": 59, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/162dea51bfa6b7f6d64d138a84c16c96495a0fcd/crates%2Fra_vfs%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162dea51bfa6b7f6d64d138a84c16c96495a0fcd/crates%2Fra_vfs%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Froots.rs?ref=162dea51bfa6b7f6d64d138a84c16c96495a0fcd", "patch": "@@ -1,11 +1,13 @@\n use std::{\n+    iter,\n     sync::Arc,\n     path::{Path, PathBuf},\n };\n \n-use relative_path::RelativePathBuf;\n+use relative_path::{ RelativePath, RelativePathBuf};\n use ra_arena::{impl_arena_id, Arena, RawId};\n \n+/// VfsRoot identifies a watched directory on the file system.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct VfsRoot(pub RawId);\n impl_arena_id!(VfsRoot);\n@@ -15,88 +17,93 @@ impl_arena_id!(VfsRoot);\n /// `RootConfig` can be thought of as a glob pattern like `src/**.rs` which\n /// specifies the source root or as a function which takes a `PathBuf` and\n /// returns `true` iff path belongs to the source root\n-pub(crate) struct RootConfig {\n-    pub(crate) root: PathBuf,\n+struct RootData {\n+    path: PathBuf,\n     // result of `root.canonicalize()` if that differs from `root`; `None` otherwise.\n-    canonical_root: Option<PathBuf>,\n-    excluded_dirs: Vec<PathBuf>,\n+    canonical_path: Option<PathBuf>,\n+    excluded_dirs: Vec<RelativePathBuf>,\n }\n \n pub(crate) struct Roots {\n-    roots: Arena<VfsRoot, Arc<RootConfig>>,\n+    roots: Arena<VfsRoot, Arc<RootData>>,\n }\n \n-impl std::ops::Deref for Roots {\n-    type Target = Arena<VfsRoot, Arc<RootConfig>>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.roots\n-    }\n-}\n+impl Roots {\n+    pub(crate) fn new(mut paths: Vec<PathBuf>) -> Roots {\n+        let mut roots = Arena::default();\n+        // A hack to make nesting work.\n+        paths.sort_by_key(|it| std::cmp::Reverse(it.as_os_str().len()));\n+        paths.dedup();\n+        for (i, path) in paths.iter().enumerate() {\n+            let nested_roots =\n+                paths[..i].iter().filter_map(|it| rel_path(path, it)).collect::<Vec<_>>();\n+\n+            let config = Arc::new(RootData::new(path.clone(), nested_roots));\n \n-impl RootConfig {\n-    fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootConfig {\n-        let mut canonical_root = root.canonicalize().ok();\n-        if Some(&root) == canonical_root.as_ref() {\n-            canonical_root = None;\n+            roots.alloc(config.clone());\n         }\n-        RootConfig { root, canonical_root, excluded_dirs }\n+        Roots { roots }\n+    }\n+    pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n+        self.iter().find_map(|root| {\n+            let rel_path = self.contains(root, path)?;\n+            Some((root, rel_path))\n+        })\n+    }\n+    pub(crate) fn len(&self) -> usize {\n+        self.roots.len()\n+    }\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = VfsRoot> + 'a {\n+        self.roots.iter().map(|(id, _)| id)\n+    }\n+    pub(crate) fn path(&self, root: VfsRoot) -> &Path {\n+        self.roots[root].path.as_path()\n     }\n     /// Checks if root contains a path and returns a root-relative path.\n-    pub(crate) fn contains(&self, path: &Path) -> Option<RelativePathBuf> {\n-        // First, check excluded dirs\n-        if self.excluded_dirs.iter().any(|it| path.starts_with(it)) {\n-            return None;\n+    pub(crate) fn contains(&self, root: VfsRoot, path: &Path) -> Option<RelativePathBuf> {\n+        let data = &self.roots[root];\n+        iter::once(&data.path)\n+            .chain(data.canonical_path.as_ref().into_iter())\n+            .find_map(|base| rel_path(base, path))\n+            .filter(|path| !data.excluded_dirs.contains(path))\n+            .filter(|path| !data.is_excluded(path))\n+    }\n+}\n+\n+impl RootData {\n+    fn new(path: PathBuf, excluded_dirs: Vec<RelativePathBuf>) -> RootData {\n+        let mut canonical_path = path.canonicalize().ok();\n+        if Some(&path) == canonical_path.as_ref() {\n+            canonical_path = None;\n         }\n-        let rel_path = path\n-            .strip_prefix(&self.root)\n-            .or_else(|err_payload| {\n-                self.canonical_root\n-                    .as_ref()\n-                    .map_or(Err(err_payload), |canonical_root| path.strip_prefix(canonical_root))\n-            })\n-            .ok()?;\n-        let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n+        RootData { path, canonical_path, excluded_dirs }\n+    }\n \n+    fn is_excluded(&self, path: &RelativePath) -> bool {\n+        if self.excluded_dirs.iter().any(|it| it == path) {\n+            return true;\n+        }\n         // Ignore some common directories.\n         //\n         // FIXME: don't hard-code, specify at source-root creation time using\n         // gitignore\n-        for (i, c) in rel_path.components().enumerate() {\n+        for (i, c) in path.components().enumerate() {\n             if let relative_path::Component::Normal(c) = c {\n                 if (i == 0 && c == \"target\") || c == \".git\" || c == \"node_modules\" {\n-                    return None;\n+                    return true;\n                 }\n             }\n         }\n \n-        if path.is_file() && rel_path.extension() != Some(\"rs\") {\n-            return None;\n+        match path.extension() {\n+            None | Some(\"rs\") => false,\n+            _ => true,\n         }\n-\n-        Some(rel_path)\n     }\n }\n \n-impl Roots {\n-    pub(crate) fn new(mut paths: Vec<PathBuf>) -> Roots {\n-        let mut roots = Arena::default();\n-        // A hack to make nesting work.\n-        paths.sort_by_key(|it| std::cmp::Reverse(it.as_os_str().len()));\n-        paths.dedup();\n-        for (i, path) in paths.iter().enumerate() {\n-            let nested_roots = paths[..i]\n-                .iter()\n-                .filter(|it| it.starts_with(path))\n-                .map(|it| it.clone())\n-                .collect::<Vec<_>>();\n-\n-            let config = Arc::new(RootConfig::new(path.clone(), nested_roots));\n-\n-            roots.alloc(config.clone());\n-        }\n-        Roots { roots }\n-    }\n-    pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n-        self.roots.iter().find_map(|(root, data)| data.contains(path).map(|it| (root, it)))\n-    }\n+fn rel_path(base: &Path, path: &Path) -> Option<RelativePathBuf> {\n+    let path = path.strip_prefix(base).ok()?;\n+    let path = RelativePathBuf::from_path(path).unwrap();\n+    Some(path)\n }"}]}