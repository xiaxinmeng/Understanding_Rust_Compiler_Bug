{"sha": "bbed852f6fb82aa85f72fc8b2aeffdb90f409495", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiZWQ4NTJmNmZiODJhYTg1ZjcyZmM4YjJhZWZmZGI5MGY0MDk0OTU=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-06T10:05:51Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:40:24Z"}, "message": "unnecessary_fold to its own module", "tree": {"sha": "e1063e69f72b33d4f03f95dec669fd5a5417bebb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1063e69f72b33d4f03f95dec669fd5a5417bebb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbed852f6fb82aa85f72fc8b2aeffdb90f409495", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbed852f6fb82aa85f72fc8b2aeffdb90f409495", "html_url": "https://github.com/rust-lang/rust/commit/bbed852f6fb82aa85f72fc8b2aeffdb90f409495", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbed852f6fb82aa85f72fc8b2aeffdb90f409495/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78e572c62782b4bd027c23b9d56a14b0b42ba93a", "url": "https://api.github.com/repos/rust-lang/rust/commits/78e572c62782b4bd027c23b9d56a14b0b42ba93a", "html_url": "https://github.com/rust-lang/rust/commit/78e572c62782b4bd027c23b9d56a14b0b42ba93a"}], "stats": {"total": 201, "additions": 107, "deletions": 94}, "files": [{"sha": "702c8e76f4992e697cf108de675ba09b408dc5f5", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 6, "deletions": 94, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/bbed852f6fb82aa85f72fc8b2aeffdb90f409495/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbed852f6fb82aa85f72fc8b2aeffdb90f409495/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=bbed852f6fb82aa85f72fc8b2aeffdb90f409495", "patch": "@@ -40,6 +40,7 @@ mod string_extend_chars;\n mod suspicious_map;\n mod uninit_assumed_init;\n mod unnecessary_filter_map;\n+mod unnecessary_fold;\n mod unnecessary_lazy_eval;\n mod unwrap_used;\n mod useless_asref;\n@@ -53,7 +54,7 @@ use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{PatKind, TraitItem, TraitItemKind};\n+use rustc_hir::{TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass, Lint, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n@@ -67,10 +68,9 @@ use crate::utils::eager_or_lazy::is_lazyness_candidate;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     contains_return, contains_ty, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of,\n-    is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath, match_trait_method,\n-    match_type, meets_msrv, method_calls, method_chain_args, path_to_local_id, paths, remove_blocks, return_ty,\n-    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, strip_pat_refs, SpanlessEq,\n+    is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath, match_type, meets_msrv,\n+    method_calls, method_chain_args, paths, return_ty, single_segment_path, snippet, snippet_with_applicability,\n+    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1736,7 +1736,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"collect\", \"cloned\"] => iter_cloned_collect::check(cx, expr, arg_lists[1]),\n             [\"as_ref\"] => useless_asref::check(cx, expr, \"as_ref\", arg_lists[0]),\n             [\"as_mut\"] => useless_asref::check(cx, expr, \"as_mut\", arg_lists[0]),\n-            [\"fold\", ..] => lint_unnecessary_fold(cx, expr, arg_lists[0], method_spans[0]),\n+            [\"fold\", ..] => unnecessary_fold::check(cx, expr, arg_lists[0], method_spans[0]),\n             [\"filter_map\", ..] => {\n                 unnecessary_filter_map::check(cx, expr, arg_lists[0]);\n                 filter_map_identity::check(cx, expr, arg_lists[0], method_spans[0]);\n@@ -2324,94 +2324,6 @@ fn lint_expect_fun_call(\n     );\n }\n \n-fn lint_unnecessary_fold(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args: &[hir::Expr<'_>], fold_span: Span) {\n-    fn check_fold_with_op(\n-        cx: &LateContext<'_>,\n-        expr: &hir::Expr<'_>,\n-        fold_args: &[hir::Expr<'_>],\n-        fold_span: Span,\n-        op: hir::BinOpKind,\n-        replacement_method_name: &str,\n-        replacement_has_args: bool,\n-    ) {\n-        if_chain! {\n-            // Extract the body of the closure passed to fold\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].kind;\n-            let closure_body = cx.tcx.hir().body(body_id);\n-            let closure_expr = remove_blocks(&closure_body.value);\n-\n-            // Check if the closure body is of the form `acc <op> some_expr(x)`\n-            if let hir::ExprKind::Binary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.kind;\n-            if bin_op.node == op;\n-\n-            // Extract the names of the two arguments to the closure\n-            if let [param_a, param_b] = closure_body.params;\n-            if let PatKind::Binding(_, first_arg_id, ..) = strip_pat_refs(&param_a.pat).kind;\n-            if let PatKind::Binding(_, second_arg_id, second_arg_ident, _) = strip_pat_refs(&param_b.pat).kind;\n-\n-            if path_to_local_id(left_expr, first_arg_id);\n-            if replacement_has_args || path_to_local_id(right_expr, second_arg_id);\n-\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let sugg = if replacement_has_args {\n-                    format!(\n-                        \"{replacement}(|{s}| {r})\",\n-                        replacement = replacement_method_name,\n-                        s = second_arg_ident,\n-                        r = snippet_with_applicability(cx, right_expr.span, \"EXPR\", &mut applicability),\n-                    )\n-                } else {\n-                    format!(\n-                        \"{replacement}()\",\n-                        replacement = replacement_method_name,\n-                    )\n-                };\n-\n-                span_lint_and_sugg(\n-                    cx,\n-                    UNNECESSARY_FOLD,\n-                    fold_span.with_hi(expr.span.hi()),\n-                    // TODO #2371 don't suggest e.g., .any(|x| f(x)) if we can suggest .any(f)\n-                    \"this `.fold` can be written more succinctly using another method\",\n-                    \"try\",\n-                    sugg,\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-\n-    // Check that this is a call to Iterator::fold rather than just some function called fold\n-    if !match_trait_method(cx, expr, &paths::ITERATOR) {\n-        return;\n-    }\n-\n-    assert!(\n-        fold_args.len() == 3,\n-        \"Expected fold_args to have three entries - the receiver, the initial value and the closure\"\n-    );\n-\n-    // Check if the first argument to .fold is a suitable literal\n-    if let hir::ExprKind::Lit(ref lit) = fold_args[1].kind {\n-        match lit.node {\n-            ast::LitKind::Bool(false) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Or, \"any\", true)\n-            },\n-            ast::LitKind::Bool(true) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::And, \"all\", true)\n-            },\n-            ast::LitKind::Int(0, _) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Add, \"sum\", false)\n-            },\n-            ast::LitKind::Int(1, _) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Mul, \"product\", false)\n-            },\n-            _ => (),\n-        }\n-    }\n-}\n-\n fn derefs_to_slice<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'tcx>,"}, {"sha": "a26443f4ee94420be3fb97007329249448c049e1", "filename": "clippy_lints/src/methods/unnecessary_fold.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/bbed852f6fb82aa85f72fc8b2aeffdb90f409495/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbed852f6fb82aa85f72fc8b2aeffdb90f409495/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=bbed852f6fb82aa85f72fc8b2aeffdb90f409495", "patch": "@@ -0,0 +1,101 @@\n+use crate::utils::{\n+    match_trait_method, path_to_local_id, paths, remove_blocks, snippet_with_applicability, span_lint_and_sugg,\n+    strip_pat_refs,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::PatKind;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::UNNECESSARY_FOLD;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args: &[hir::Expr<'_>], fold_span: Span) {\n+    fn check_fold_with_op(\n+        cx: &LateContext<'_>,\n+        expr: &hir::Expr<'_>,\n+        fold_args: &[hir::Expr<'_>],\n+        fold_span: Span,\n+        op: hir::BinOpKind,\n+        replacement_method_name: &str,\n+        replacement_has_args: bool,\n+    ) {\n+        if_chain! {\n+            // Extract the body of the closure passed to fold\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].kind;\n+            let closure_body = cx.tcx.hir().body(body_id);\n+            let closure_expr = remove_blocks(&closure_body.value);\n+\n+            // Check if the closure body is of the form `acc <op> some_expr(x)`\n+            if let hir::ExprKind::Binary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.kind;\n+            if bin_op.node == op;\n+\n+            // Extract the names of the two arguments to the closure\n+            if let [param_a, param_b] = closure_body.params;\n+            if let PatKind::Binding(_, first_arg_id, ..) = strip_pat_refs(&param_a.pat).kind;\n+            if let PatKind::Binding(_, second_arg_id, second_arg_ident, _) = strip_pat_refs(&param_b.pat).kind;\n+\n+            if path_to_local_id(left_expr, first_arg_id);\n+            if replacement_has_args || path_to_local_id(right_expr, second_arg_id);\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let sugg = if replacement_has_args {\n+                    format!(\n+                        \"{replacement}(|{s}| {r})\",\n+                        replacement = replacement_method_name,\n+                        s = second_arg_ident,\n+                        r = snippet_with_applicability(cx, right_expr.span, \"EXPR\", &mut applicability),\n+                    )\n+                } else {\n+                    format!(\n+                        \"{replacement}()\",\n+                        replacement = replacement_method_name,\n+                    )\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_FOLD,\n+                    fold_span.with_hi(expr.span.hi()),\n+                    // TODO #2371 don't suggest e.g., .any(|x| f(x)) if we can suggest .any(f)\n+                    \"this `.fold` can be written more succinctly using another method\",\n+                    \"try\",\n+                    sugg,\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+\n+    // Check that this is a call to Iterator::fold rather than just some function called fold\n+    if !match_trait_method(cx, expr, &paths::ITERATOR) {\n+        return;\n+    }\n+\n+    assert!(\n+        fold_args.len() == 3,\n+        \"Expected fold_args to have three entries - the receiver, the initial value and the closure\"\n+    );\n+\n+    // Check if the first argument to .fold is a suitable literal\n+    if let hir::ExprKind::Lit(ref lit) = fold_args[1].kind {\n+        match lit.node {\n+            ast::LitKind::Bool(false) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Or, \"any\", true)\n+            },\n+            ast::LitKind::Bool(true) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::And, \"all\", true)\n+            },\n+            ast::LitKind::Int(0, _) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Add, \"sum\", false)\n+            },\n+            ast::LitKind::Int(1, _) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Mul, \"product\", false)\n+            },\n+            _ => (),\n+        }\n+    }\n+}"}]}