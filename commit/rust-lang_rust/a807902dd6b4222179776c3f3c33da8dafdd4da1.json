{"sha": "a807902dd6b4222179776c3f3c33da8dafdd4da1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MDc5MDJkZDZiNDIyMjE3OTc3NmMzZjNjMzNkYThkYWZkZDRkYTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-19T01:31:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-19T01:31:35Z"}, "message": "Auto merge of #63463 - matthewjasper:ty_param_cleanup, r=petrochenkov\n\nDon't special case the `Self` parameter by name\n\nThis results in a couple of small diagnostic regressions. They could be avoided by keeping the special case just for diagnostics, but that seems worse.\n\ncloses #50125\ncc #60869", "tree": {"sha": "b4636f43c056de11dd69130ce47039343a9f52c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4636f43c056de11dd69130ce47039343a9f52c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a807902dd6b4222179776c3f3c33da8dafdd4da1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a807902dd6b4222179776c3f3c33da8dafdd4da1", "html_url": "https://github.com/rust-lang/rust/commit/a807902dd6b4222179776c3f3c33da8dafdd4da1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a807902dd6b4222179776c3f3c33da8dafdd4da1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ccbae2f1878380e6c3777b8b172dfef61c3842b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ccbae2f1878380e6c3777b8b172dfef61c3842b", "html_url": "https://github.com/rust-lang/rust/commit/0ccbae2f1878380e6c3777b8b172dfef61c3842b"}, {"sha": "24587d20dfa6ddc2391e6edee81ef090f92858fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/24587d20dfa6ddc2391e6edee81ef090f92858fa", "html_url": "https://github.com/rust-lang/rust/commit/24587d20dfa6ddc2391e6edee81ef090f92858fa"}], "stats": {"total": 307, "additions": 124, "deletions": 183}, "files": [{"sha": "cc2e6137df38a2264cc8794b74f2b3399df44b39", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -2524,15 +2524,6 @@ impl<'a> LoweringContext<'a> {\n                 (param_name, kind)\n             }\n             GenericParamKind::Type { ref default, .. } => {\n-                // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n-                // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n-                // Instead, use `gensym(\"Self\")` to create a distinct name that looks the same.\n-                let ident = if param.ident.name == kw::SelfUpper {\n-                    param.ident.gensym()\n-                } else {\n-                    param.ident\n-                };\n-\n                 let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n                 if !add_bounds.is_empty() {\n                     let params = self.lower_param_bounds(add_bounds, itctx.reborrow()).into_iter();\n@@ -2551,7 +2542,7 @@ impl<'a> LoweringContext<'a> {\n                                           .next(),\n                 };\n \n-                (hir::ParamName::Plain(ident), kind)\n+                (hir::ParamName::Plain(param.ident), kind)\n             }\n             GenericParamKind::Const { ref ty } => {\n                 (hir::ParamName::Plain(param.ident), hir::GenericParamKind::Const {"}, {"sha": "84687b8cab5c0b9160103167a97ab4a149c7efe6", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -1329,15 +1329,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let generics = self.tcx.generics_of(did);\n                     // Account for the case where `did` corresponds to `Self`, which doesn't have\n                     // the expected type argument.\n-                    if !param.is_self() {\n+                    if !(generics.has_self && param.index == 0) {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir();\n                         hir.as_local_hir_id(type_param.def_id).map(|id| {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let Node::GenericParam(ref param) = hir.get(id) {\n+                            if let Node::GenericParam(param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);"}, {"sha": "7ea7bf0257cf7d56344833ef458d638c51dbeea7", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 57, "deletions": 52, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -91,6 +91,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n                                             -> Vec<ObjectSafetyViolation>\n     {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n         let violations = traits::supertrait_def_ids(self, trait_def_id)\n             .filter(|&def_id| self.predicates_reference_self(def_id, true))\n             .map(|_| ObjectSafetyViolation::SupertraitSelf)\n@@ -106,16 +107,33 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn object_safety_violations(self, trait_def_id: DefId)\n                                     -> Vec<ObjectSafetyViolation>\n     {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n         debug!(\"object_safety_violations: {:?}\", trait_def_id);\n \n         traits::supertrait_def_ids(self, trait_def_id)\n             .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n             .collect()\n     }\n \n-    fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n-                                          -> Vec<ObjectSafetyViolation>\n-    {\n+    /// We say a method is *vtable safe* if it can be invoked on a trait\n+    /// object.  Note that object-safe traits can have some\n+    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n+    /// otherwise ensure that they cannot be used when `Self=Trait`.\n+    pub fn is_vtable_safe_method(self, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n+        debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n+        // Any method that has a `Self : Sized` requisite can't be called.\n+        if self.generics_require_sized_self(method.def_id) {\n+            return false;\n+        }\n+\n+        match self.virtual_call_violation_for_method(trait_def_id, method) {\n+            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n+            Some(_) => false,\n+        }\n+    }\n+\n+    fn object_safety_violations_for_trait(self, trait_def_id: DefId) -> Vec<ObjectSafetyViolation> {\n         // Check methods for violations.\n         let mut violations: Vec<_> = self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssocKind::Method)\n@@ -163,14 +181,16 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn predicates_reference_self(\n         self,\n         trait_def_id: DefId,\n-        supertraits_only: bool) -> bool\n-    {\n+        supertraits_only: bool,\n+    ) -> bool {\n         let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(self, trait_def_id));\n         let predicates = if supertraits_only {\n             self.super_predicates_of(trait_def_id)\n         } else {\n             self.predicates_of(trait_def_id)\n         };\n+        let self_ty = self.types.self_param;\n+        let has_self_ty = |t: Ty<'tcx>| t.walk().any(|t| t == self_ty);\n         predicates\n             .predicates\n             .iter()\n@@ -179,7 +199,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 match predicate {\n                     ty::Predicate::Trait(ref data) => {\n                         // In the case of a trait predicate, we can skip the \"self\" type.\n-                        data.skip_binder().input_types().skip(1).any(|t| t.has_self_ty())\n+                        data.skip_binder().input_types().skip(1).any(has_self_ty)\n                     }\n                     ty::Predicate::Projection(ref data) => {\n                         // And similarly for projections. This should be redundant with\n@@ -199,7 +219,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                             .trait_ref(self)\n                             .input_types()\n                             .skip(1)\n-                            .any(|t| t.has_self_ty())\n+                            .any(has_self_ty)\n                     }\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n@@ -229,11 +249,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         let predicates = predicates.instantiate_identity(self).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| match predicate {\n-                ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n-                    trait_pred.skip_binder().self_ty().is_self()\n+                ty::Predicate::Trait(ref trait_pred) => {\n+                    trait_pred.def_id() == sized_def_id\n+                        && trait_pred.skip_binder().self_ty().is_param(0)\n                 }\n                 ty::Predicate::Projection(..) |\n-                ty::Predicate::Trait(..) |\n                 ty::Predicate::Subtype(..) |\n                 ty::Predicate::RegionOutlives(..) |\n                 ty::Predicate::WellFormed(..) |\n@@ -248,11 +268,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns `Some(_)` if this method makes the containing trait not object safe.\n-    fn object_safety_violation_for_method(self,\n-                                          trait_def_id: DefId,\n-                                          method: &ty::AssocItem)\n-                                          -> Option<MethodViolationCode>\n-    {\n+    fn object_safety_violation_for_method(\n+        self,\n+        trait_def_id: DefId,\n+        method: &ty::AssocItem,\n+    ) -> Option<MethodViolationCode> {\n         debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n         // Any method that has a `Self : Sized` requisite is otherwise\n         // exempt from the regulations.\n@@ -263,36 +283,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.virtual_call_violation_for_method(trait_def_id, method)\n     }\n \n-    /// We say a method is *vtable safe* if it can be invoked on a trait\n-    /// object.  Note that object-safe traits can have some\n-    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n-    /// otherwise ensure that they cannot be used when `Self=Trait`.\n-    pub fn is_vtable_safe_method(self,\n-                                 trait_def_id: DefId,\n-                                 method: &ty::AssocItem)\n-                                 -> bool\n-    {\n-        debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n-        // Any method that has a `Self : Sized` requisite can't be called.\n-        if self.generics_require_sized_self(method.def_id) {\n-            return false;\n-        }\n-\n-        match self.virtual_call_violation_for_method(trait_def_id, method) {\n-            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n-            Some(_) => false,\n-        }\n-    }\n-\n     /// Returns `Some(_)` if this method cannot be called on a trait\n     /// object; this does not necessarily imply that the enclosing trait\n     /// is not object safe, because the method might have a where clause\n     /// `Self:Sized`.\n-    fn virtual_call_violation_for_method(self,\n-                                         trait_def_id: DefId,\n-                                         method: &ty::AssocItem)\n-                                         -> Option<MethodViolationCode>\n-    {\n+    fn virtual_call_violation_for_method(\n+        self,\n+        trait_def_id: DefId,\n+        method: &ty::AssocItem,\n+    ) -> Option<MethodViolationCode> {\n         // The method's first parameter must be named `self`\n         if !method.method_has_self_argument {\n             return Some(MethodViolationCode::StaticMethod);\n@@ -323,7 +322,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                 .collect::<Vec<_>>()\n                 // Do a shallow visit so that `contains_illegal_self_type_reference`\n                 // may apply it's custom visiting.\n-                .visit_tys_shallow(|t| self.contains_illegal_self_type_reference(trait_def_id, t)) {\n+                .visit_tys_shallow(|t| {\n+                    self.contains_illegal_self_type_reference(trait_def_id, t)\n+                }) {\n             let span = self.def_span(method.def_id);\n             return Some(MethodViolationCode::WhereClauseReferencesSelf(span));\n         }\n@@ -337,7 +338,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // However, this is already considered object-safe. We allow it as a special case here.\n         // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n         // `Receiver: Unsize<Receiver[Self => dyn Trait]>`\n-        if receiver_ty != self.mk_self_type() {\n+        if receiver_ty != self.types.self_param {\n             if !self.receiver_is_dispatchable(method, receiver_ty) {\n                 return Some(MethodViolationCode::UndispatchableReceiver);\n             } else {\n@@ -404,7 +405,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n     /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`.\n     fn receiver_for_self_ty(\n-        self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n+        self,\n+        receiver_ty: Ty<'tcx>,\n+        self_ty: Ty<'tcx>,\n+        method_def_id: DefId,\n     ) -> Ty<'tcx> {\n         debug!(\"receiver_for_self_ty({:?}, {:?}, {:?})\", receiver_ty, self_ty, method_def_id);\n         let substs = InternalSubsts::for_item(self, method_def_id, |param, _| {\n@@ -555,7 +559,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             // Self: Unsize<U>\n             let unsize_predicate = ty::TraitRef {\n                 def_id: unsize_did,\n-                substs: self.mk_substs_trait(self.mk_self_type(), &[unsized_self_ty.into()]),\n+                substs: self.mk_substs_trait(self.types.self_param, &[unsized_self_ty.into()]),\n             }.to_predicate();\n \n             // U: Trait<Arg1, ..., ArgN>\n@@ -608,11 +612,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    fn contains_illegal_self_type_reference(self,\n-                                            trait_def_id: DefId,\n-                                            ty: Ty<'tcx>)\n-                                            -> bool\n-    {\n+    fn contains_illegal_self_type_reference(\n+        self,\n+        trait_def_id: DefId,\n+        ty: Ty<'tcx>,\n+     ) -> bool {\n         // This is somewhat subtle. In general, we want to forbid\n         // references to `Self` in the argument and return types,\n         // since the value of `Self` is erased. However, there is one\n@@ -654,10 +658,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n         let mut error = false;\n+        let self_ty = self.types.self_param;\n         ty.maybe_walk(|ty| {\n             match ty.sty {\n-                ty::Param(ref param_ty) => {\n-                    if param_ty.is_self() {\n+                ty::Param(_) => {\n+                    if ty == self_ty {\n                         error = true;\n                     }\n "}, {"sha": "e72efdb057ab10f08d3d1a59ea229c28880750d8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -173,6 +173,7 @@ pub struct CommonTypes<'tcx> {\n     pub f32: Ty<'tcx>,\n     pub f64: Ty<'tcx>,\n     pub never: Ty<'tcx>,\n+    pub self_param: Ty<'tcx>,\n     pub err: Ty<'tcx>,\n \n     /// Dummy type used for the `Self` of a `TraitRef` created for converting\n@@ -915,6 +916,10 @@ impl<'tcx> CommonTypes<'tcx> {\n             u128: mk(Uint(ast::UintTy::U128)),\n             f32: mk(Float(ast::FloatTy::F32)),\n             f64: mk(Float(ast::FloatTy::F64)),\n+            self_param: mk(ty::Param(ty::ParamTy {\n+                index: 0,\n+                name: kw::SelfUpper.as_interned_str(),\n+            })),\n \n             trait_object_dummy_self: mk(Infer(ty::FreshTy(0))),\n         }\n@@ -2566,10 +2571,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    #[inline]\n-    pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_ty_param(0, kw::SelfUpper.as_interned_str())\n-    }\n \n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> Kind<'tcx> {\n         match param.kind {"}, {"sha": "d6d17a67e01e95ef54529bfdd4eddd790321a612", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -239,13 +239,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n             ty::Projection(_) => \"associated type\".into(),\n             ty::UnnormalizedProjection(_) => \"non-normalized associated type\".into(),\n-            ty::Param(ref p) => {\n-                if p.is_self() {\n-                    \"Self\".into()\n-                } else {\n-                    \"type parameter\".into()\n-                }\n-            }\n+            ty::Param(_) => \"type parameter\".into(),\n             ty::Opaque(..) => \"opaque type\".into(),\n             ty::Error => \"type error\".into(),\n         }"}, {"sha": "b2d74f963b0b3db24c494d7505ce3b773ae5edd3", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -1,5 +1,5 @@\n use crate::ty::subst::{SubstsRef, UnpackedKind};\n-use crate::ty::{self, Ty, TypeFlags, TypeFoldable, InferConst};\n+use crate::ty::{self, Ty, TypeFlags, InferConst};\n use crate::mir::interpret::ConstValue;\n \n #[derive(Debug)]\n@@ -86,13 +86,9 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::HAS_TY_ERR)\n             }\n \n-            &ty::Param(ref p) => {\n+            &ty::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n-                if p.is_self() {\n-                    self.add_flags(TypeFlags::HAS_SELF);\n-                } else {\n-                    self.add_flags(TypeFlags::HAS_PARAMS);\n-                }\n+                self.add_flags(TypeFlags::HAS_PARAMS);\n             }\n \n             &ty::Generator(_, ref substs, _) => {\n@@ -143,11 +139,6 @@ impl FlagComputation {\n             }\n \n             &ty::Projection(ref data) => {\n-                // currently we can't normalize projections that\n-                // include bound regions, so track those separately.\n-                if !data.has_escaping_bound_vars() {\n-                    self.add_flags(TypeFlags::HAS_NORMALIZABLE_PROJECTION);\n-                }\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n@@ -243,7 +234,7 @@ impl FlagComputation {\n         match c.val {\n             ConstValue::Unevaluated(_, substs) => {\n                 self.add_substs(substs);\n-                self.add_flags(TypeFlags::HAS_NORMALIZABLE_PROJECTION | TypeFlags::HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n             },\n             ConstValue::Infer(infer) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_CT_INFER);"}, {"sha": "4b30412b41954e98355d645fa988dfd3dbaacac2", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -85,9 +85,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_param_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PARAMS)\n     }\n-    fn has_self_ty(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_SELF)\n-    }\n     fn has_infer_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }"}, {"sha": "c71e1ea4e585989d763de4195328aab4fadc272a", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -298,8 +298,9 @@ impl<'tcx> Instance<'tcx> {\n     ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n         let fn_sig = tcx.fn_sig(def_id);\n-        let is_vtable_shim =\n-            fn_sig.inputs().skip_binder().len() > 0 && fn_sig.input(0).skip_binder().is_self();\n+        let is_vtable_shim = fn_sig.inputs().skip_binder().len() > 0\n+            && fn_sig.input(0).skip_binder().is_param(0)\n+            && tcx.generics_of(def_id).has_self;\n         if is_vtable_shim {\n             debug!(\" => associated item with unsizeable self: Self\");\n             Some(Instance {"}, {"sha": "8febcfd0754c9e2fefef2474da0b0c3a412c89c3", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -1601,7 +1601,6 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // resulting from the final codegen session.\n         if\n             layout.ty.has_param_types() ||\n-            layout.ty.has_self_ty() ||\n             !self.param_env.caller_bounds.is_empty()\n         {\n             return;\n@@ -1767,7 +1766,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.sty {\n                     ty::Param(_) | ty::Projection(_) => {\n-                        debug_assert!(tail.has_param_types() || tail.has_self_ty());\n+                        debug_assert!(tail.has_param_types());\n                         Ok(SizeSkeleton::Pointer {\n                             non_zero,\n                             tail: tcx.erase_regions(&tail)"}, {"sha": "0b81f193df4098c737b51c3ff8c6a5c986662f6d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -414,61 +414,53 @@ pub struct CReaderCacheKey {\n bitflags! {\n     pub struct TypeFlags: u32 {\n         const HAS_PARAMS         = 1 << 0;\n-        const HAS_SELF           = 1 << 1;\n-        const HAS_TY_INFER       = 1 << 2;\n-        const HAS_RE_INFER       = 1 << 3;\n-        const HAS_RE_PLACEHOLDER = 1 << 4;\n+        const HAS_TY_INFER       = 1 << 1;\n+        const HAS_RE_INFER       = 1 << 2;\n+        const HAS_RE_PLACEHOLDER = 1 << 3;\n \n         /// Does this have any `ReEarlyBound` regions? Used to\n         /// determine whether substitition is required, since those\n         /// represent regions that are bound in a `ty::Generics` and\n         /// hence may be substituted.\n-        const HAS_RE_EARLY_BOUND = 1 << 5;\n+        const HAS_RE_EARLY_BOUND = 1 << 4;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS   = 1 << 6;\n+        const HAS_FREE_REGIONS   = 1 << 5;\n \n         /// Is an error type reachable?\n-        const HAS_TY_ERR         = 1 << 7;\n-        const HAS_PROJECTION     = 1 << 8;\n+        const HAS_TY_ERR         = 1 << 6;\n+        const HAS_PROJECTION     = 1 << 7;\n \n         // FIXME: Rename this to the actual property since it's used for generators too\n-        const HAS_TY_CLOSURE     = 1 << 9;\n+        const HAS_TY_CLOSURE     = 1 << 8;\n \n         /// `true` if there are \"names\" of types and regions and so forth\n         /// that are local to a particular fn\n-        const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n+        const HAS_FREE_LOCAL_NAMES    = 1 << 9;\n \n         /// Present if the type belongs in a local type context.\n         /// Only set for Infer other than Fresh.\n-        const KEEP_IN_LOCAL_TCX  = 1 << 11;\n-\n-        // Is there a projection that does not involve a bound region?\n-        // Currently we can't normalize projections w/ bound regions.\n-        const HAS_NORMALIZABLE_PROJECTION = 1 << 12;\n+        const KEEP_IN_LOCAL_TCX  = 1 << 10;\n \n         /// Does this have any `ReLateBound` regions? Used to check\n         /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND = 1 << 13;\n+        const HAS_RE_LATE_BOUND = 1 << 11;\n \n-        const HAS_TY_PLACEHOLDER = 1 << 14;\n+        const HAS_TY_PLACEHOLDER = 1 << 12;\n \n-        const HAS_CT_INFER = 1 << 15;\n-        const HAS_CT_PLACEHOLDER = 1 << 16;\n+        const HAS_CT_INFER = 1 << 13;\n+        const HAS_CT_PLACEHOLDER = 1 << 14;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n-                                   TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n \n         /// Flags representing the nominal content of a type,\n         /// computed by FlagsComputation. If you add a new nominal\n         /// flag, it should be added here too.\n         const NOMINAL_FLAGS     = TypeFlags::HAS_PARAMS.bits |\n-                                  TypeFlags::HAS_SELF.bits |\n                                   TypeFlags::HAS_TY_INFER.bits |\n                                   TypeFlags::HAS_RE_INFER.bits |\n-                                  TypeFlags::HAS_CT_INFER.bits |\n                                   TypeFlags::HAS_RE_PLACEHOLDER.bits |\n                                   TypeFlags::HAS_RE_EARLY_BOUND.bits |\n                                   TypeFlags::HAS_FREE_REGIONS.bits |\n@@ -479,6 +471,7 @@ bitflags! {\n                                   TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n                                   TypeFlags::HAS_RE_LATE_BOUND.bits |\n                                   TypeFlags::HAS_TY_PLACEHOLDER.bits |\n+                                  TypeFlags::HAS_CT_INFER.bits |\n                                   TypeFlags::HAS_CT_PLACEHOLDER.bits;\n     }\n }\n@@ -1734,7 +1727,6 @@ impl<'tcx> ParamEnv<'tcx> {\n                 if value.has_placeholders()\n                     || value.needs_infer()\n                     || value.has_param_types()\n-                    || value.has_self_ty()\n                 {\n                     ParamEnvAnd {\n                         param_env: self,"}, {"sha": "2b173068b38e4a610e32c546d502a9c6d3c0a5ad", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -1141,13 +1141,6 @@ impl<'tcx> ParamTy {\n     pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_ty_param(self.index, self.name)\n     }\n-\n-    pub fn is_self(&self) -> bool {\n-        // FIXME(#50125): Ignoring `Self` with `index != 0` might lead to weird behavior elsewhere,\n-        // but this should only be possible when using `-Z continue-parse-after-error` like\n-        // `compile-fail/issue-36638.rs`.\n-        self.name.as_symbol() == kw::SelfUpper && self.index == 0\n-    }\n }\n \n #[derive(Copy, Clone, Hash, RustcEncodable, RustcDecodable,\n@@ -1789,14 +1782,6 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn is_self(&self) -> bool {\n-        match self.sty {\n-            Param(ref p) => p.is_self(),\n-            _ => false,\n-        }\n-    }\n-\n     #[inline]\n     pub fn is_slice(&self) -> bool {\n         match self.sty {"}, {"sha": "3e02f6c3725fdba6e48f359b88de5daea397a73c", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -708,7 +708,7 @@ fn build_call_shim<'tcx>(\n         Adjustment::DerefMove => {\n             // fn(Self, ...) -> fn(*mut Self, ...)\n             let arg_ty = local_decls[rcvr_arg].ty;\n-            assert!(arg_ty.is_self());\n+            debug_assert!(tcx.generics_of(def_id).has_self && arg_ty == tcx.types.self_param);\n             local_decls[rcvr_arg].ty = tcx.mk_mut_ptr(arg_ty);\n \n             Operand::Move(rcvr_l.deref())"}, {"sha": "9e52eae88ef45fbdf411a0ad5794b59dad58f42e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -635,8 +635,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         });\n         let default_needs_object_self = |param: &ty::GenericParamDef| {\n             if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n-                if is_object && has_default {\n-                    if tcx.at(span).type_of(param.def_id).has_self_ty() {\n+                if is_object && has_default && has_self {\n+                    let self_param = tcx.types.self_param;\n+                    if tcx.at(span).type_of(param.def_id).walk().any(|ty| ty == self_param) {\n                         // There is no suitable inference default for a type parameter\n                         // that references self, in an object type.\n                         return true;\n@@ -2030,7 +2031,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n-                tcx.mk_self_type()\n+                tcx.types.self_param\n             }\n             Res::SelfTy(_, Some(def_id)) => {\n                 // `Self` in impl (we know the concrete type)."}, {"sha": "8e187b7e05b51ab0e10a0b7729be4ce1b947cd57", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -518,7 +518,7 @@ fn compare_self_type<'tcx>(\n     let self_string = |method: &ty::AssocItem| {\n         let untransformed_self_ty = match method.container {\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n-            ty::TraitContainer(_) => tcx.mk_self_type()\n+            ty::TraitContainer(_) => tcx.types.self_param\n         };\n         let self_arg_ty = *tcx.fn_sig(method.def_id).input(0).skip_binder();\n         let param_env = ty::ParamEnv::reveal_all();"}, {"sha": "9c6ea7d30ccf980830c33f22f9815c02cbd5a521", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -191,7 +191,7 @@ fn check_associated_item(\n         let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n-            ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n+            ty::TraitContainer(_) => (vec![], fcx.tcx.types.self_param),\n             ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n                                           fcx.tcx.type_of(def_id))\n         };"}, {"sha": "e979bc7bf25b54de39e6e58c043eb350ef7dd98a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -716,7 +716,7 @@ fn super_predicates_of(\n     let icx = ItemCtxt::new(tcx, trait_def_id);\n \n     // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n-    let self_param_ty = tcx.mk_self_type();\n+    let self_param_ty = tcx.types.self_param;\n     let superbounds1 = AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No,\n         item.span);\n \n@@ -1014,13 +1014,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                         synthetic,\n                         ..\n                     } => {\n-                        if param.name.ident().name == kw::SelfUpper {\n-                            span_bug!(\n-                                param.span,\n-                                \"`Self` should not be the name of a regular parameter\"\n-                            );\n-                        }\n-\n                         if !allow_defaults && default.is_some() {\n                             if !tcx.features().default_type_parameter_fallback {\n                                 tcx.lint_hir(\n@@ -1044,13 +1037,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                         }\n                     }\n                     GenericParamKind::Const { .. } => {\n-                        if param.name.ident().name == kw::SelfUpper {\n-                            span_bug!(\n-                                param.span,\n-                                \"`Self` should not be the name of a regular parameter\",\n-                            );\n-                        }\n-\n                         ty::GenericParamDefKind::Const\n                     }\n                     _ => return None,\n@@ -1567,7 +1553,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                     &format!(\n                                         \"defining opaque type use restricts opaque \\\n                                          type by using the generic parameter `{}` twice\",\n-                                        p.name\n+                                        p,\n                                     ),\n                                 );\n                                 return;"}, {"sha": "644d723ded5d96e60a3369ea7fb4d6aff0ac114a", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -3,7 +3,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::fold::TypeFoldable;\n use rustc::util::nodemap::FxHashMap;\n \n use super::explicit::ExplicitPredicatesMap;\n@@ -178,11 +177,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // let _: () = substs.region_at(0);\n                 check_explicit_predicates(\n                     tcx,\n-                    &def.did,\n+                    def.did,\n                     substs,\n                     required_predicates,\n                     explicit_map,\n-                    IgnoreSelfTy(false),\n+                    None,\n                 );\n             }\n \n@@ -208,11 +207,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                         .substs;\n                     check_explicit_predicates(\n                         tcx,\n-                        &ex_trait_ref.skip_binder().def_id,\n+                        ex_trait_ref.skip_binder().def_id,\n                         substs,\n                         required_predicates,\n                         explicit_map,\n-                        IgnoreSelfTy(true),\n+                        Some(tcx.types.self_param),\n                     );\n                 }\n             }\n@@ -223,11 +222,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 debug!(\"Projection\");\n                 check_explicit_predicates(\n                     tcx,\n-                    &tcx.associated_item(obj.item_def_id).container.id(),\n+                    tcx.associated_item(obj.item_def_id).container.id(),\n                     obj.substs,\n                     required_predicates,\n                     explicit_map,\n-                    IgnoreSelfTy(false),\n+                    None,\n                 );\n             }\n \n@@ -236,9 +235,6 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n     }\n }\n \n-#[derive(Debug)]\n-pub struct IgnoreSelfTy(bool);\n-\n /// We also have to check the explicit predicates\n /// declared on the type.\n ///\n@@ -256,25 +252,25 @@ pub struct IgnoreSelfTy(bool);\n /// applying the substitution as above.\n pub fn check_explicit_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: &DefId,\n+    def_id: DefId,\n     substs: &[Kind<'tcx>],\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n-    ignore_self_ty: IgnoreSelfTy,\n+    ignored_self_ty: Option<Ty<'tcx>>,\n ) {\n     debug!(\n         \"check_explicit_predicates(def_id={:?}, \\\n          substs={:?}, \\\n          explicit_map={:?}, \\\n          required_predicates={:?}, \\\n-         ignore_self_ty={:?})\",\n+         ignored_self_ty={:?})\",\n         def_id,\n         substs,\n         explicit_map,\n         required_predicates,\n-        ignore_self_ty,\n+        ignored_self_ty,\n     );\n-    let explicit_predicates = explicit_map.explicit_predicates_of(tcx, *def_id);\n+    let explicit_predicates = explicit_map.explicit_predicates_of(tcx, def_id);\n \n     for outlives_predicate in explicit_predicates.iter() {\n         debug!(\"outlives_predicate = {:?}\", &outlives_predicate);\n@@ -313,9 +309,9 @@ pub fn check_explicit_predicates<'tcx>(\n         // = X` binding from the object type (there must be such a\n         // binding) and thus infer an outlives requirement that `X:\n         // 'b`.\n-        if ignore_self_ty.0 {\n+        if let Some(self_ty) = ignored_self_ty {\n             if let UnpackedKind::Type(ty) = outlives_predicate.0.unpack() {\n-                if ty.has_self_ty() {\n+                if ty.walk().any(|ty| ty == self_ty) {\n                     debug!(\"skipping self ty = {:?}\", &ty);\n                     continue;\n                 }"}, {"sha": "9b4803ce41e290718ebb9ef7a609b4cccf5a7564", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -2303,7 +2303,7 @@ impl Clean<Item> for ty::AssocItem {\n                         ty::ImplContainer(def_id) => {\n                             cx.tcx.type_of(def_id)\n                         }\n-                        ty::TraitContainer(_) => cx.tcx.mk_self_type()\n+                        ty::TraitContainer(_) => cx.tcx.types.self_param,\n                     };\n                     let self_arg_ty = *sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {"}, {"sha": "3801c42307fc6f00099bfb01217c258dfa809dda", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -149,9 +149,11 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId,\n         return true\n     }\n     let predicates = cx.tcx.super_predicates_of(child);\n+    debug_assert!(cx.tcx.generics_of(child).has_self);\n+    let self_ty = cx.tcx.types.self_param;\n     predicates.predicates.iter().filter_map(|(pred, _)| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n-            if pred.skip_binder().trait_ref.self_ty().is_self() {\n+            if pred.skip_binder().trait_ref.self_ty() == self_ty {\n                 Some(pred.def_id())\n             } else {\n                 None"}, {"sha": "c938ce8dad98d69a9beef006d41fb432d1b04d49", "filename": "src/test/ui/structs/struct-path-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -3,13 +3,13 @@ struct S;\n trait Tr {\n     fn f() {\n         let s = Self {};\n-        //~^ ERROR expected struct, variant or union type, found Self\n+        //~^ ERROR expected struct, variant or union type, found type parameter\n         let z = Self::<u8> {};\n-        //~^ ERROR expected struct, variant or union type, found Self\n+        //~^ ERROR expected struct, variant or union type, found type parameter\n         //~| ERROR type arguments are not allowed for this type\n         match s {\n             Self { .. } => {}\n-            //~^ ERROR expected struct, variant or union type, found Self\n+            //~^ ERROR expected struct, variant or union type, found type parameter\n         }\n     }\n }"}, {"sha": "8c88cacc69e315f8607e7e91de664c50908bbef7", "filename": "src/test/ui/structs/struct-path-self.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -1,4 +1,4 @@\n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:5:17\n    |\n LL |         let s = Self {};\n@@ -10,13 +10,13 @@ error[E0109]: type arguments are not allowed for this type\n LL |         let z = Self::<u8> {};\n    |                        ^^ type argument not allowed\n \n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:7:17\n    |\n LL |         let z = Self::<u8> {};\n    |                 ^^^^^^^^^^ not a struct\n \n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:11:13\n    |\n LL |             Self { .. } => {}"}, {"sha": "71fb7f380aeac6e72a36a6f6c8371bfc82f50ecb", "filename": "src/test/ui/type/type-params-in-different-spaces-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -5,7 +5,7 @@ trait BrokenAdd: Copy + Add<Output=Self> {\n         *self + rhs //~  ERROR mismatched types\n                     //~| expected type `Self`\n                     //~| found type `T`\n-                    //~| expected Self, found type parameter\n+                    //~| expected type parameter, found a different type parameter\n     }\n }\n "}, {"sha": "0448a28ea8e2721b7722fa7ab09c2dd484f89bd9", "filename": "src/test/ui/type/type-params-in-different-spaces-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/type-params-in-different-spaces-1.rs:5:17\n    |\n LL |         *self + rhs\n-   |                 ^^^ expected Self, found type parameter\n+   |                 ^^^ expected type parameter, found a different type parameter\n    |\n    = note: expected type `Self`\n               found type `T`"}, {"sha": "e25f79947c73233c0128a9f253b06fe9c42219f2", "filename": "src/test/ui/type/type-params-in-different-spaces-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a807902dd6b4222179776c3f3c33da8dafdd4da1/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr?ref=a807902dd6b4222179776c3f3c33da8dafdd4da1", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL |     fn test<X>(u: X) -> Self {\n    |                         ---- expected `Self` because of return type\n LL |         u\n-   |         ^ expected Self, found type parameter\n+   |         ^ expected type parameter, found a different type parameter\n    |\n    = note: expected type `Self`\n               found type `X`"}]}