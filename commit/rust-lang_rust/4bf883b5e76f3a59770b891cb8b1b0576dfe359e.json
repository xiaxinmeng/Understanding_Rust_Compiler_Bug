{"sha": "4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZjg4M2I1ZTc2ZjNhNTk3NzBiODkxY2I4YjFiMDU3NmRmZTM1OWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-03T21:46:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-03T21:46:21Z"}, "message": "Auto merge of #54391 - davidtwco:issue-54230, r=petrochenkov\n\nsuggest `crate::...` for \"local\" paths in 2018\n\nFixes #54230.\n\nThis commit adds suggestions for unresolved imports in the cases where\nthere could be a missing `crate::`, `super::`, `self::` or a missing\nexternal crate name before an import.\n\nr? @nikomatsakis", "tree": {"sha": "3b6125ee8253e3533aa8a464501f9deea79b1c5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b6125ee8253e3533aa8a464501f9deea79b1c5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "html_url": "https://github.com/rust-lang/rust/commit/4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5597ee8a6483238421750fce4eb7031b12852428", "url": "https://api.github.com/repos/rust-lang/rust/commits/5597ee8a6483238421750fce4eb7031b12852428", "html_url": "https://github.com/rust-lang/rust/commit/5597ee8a6483238421750fce4eb7031b12852428"}, {"sha": "5872d3eacd61113c8c241444b2d2403aaec2fbfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5872d3eacd61113c8c241444b2d2403aaec2fbfd", "html_url": "https://github.com/rust-lang/rust/commit/5872d3eacd61113c8c241444b2d2403aaec2fbfd"}], "stats": {"total": 315, "additions": 296, "deletions": 19}, "files": [{"sha": "b9194fdfc15d73d9e0986c0f3955a47620af368e", "filename": "src/librustc_resolve/error_reporting.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {CrateLint, PathResult};\n+\n+use std::collections::BTreeSet;\n+\n+use syntax::ast::Ident;\n+use syntax::symbol::{keywords, Symbol};\n+use syntax_pos::Span;\n+\n+use resolve_imports::ImportResolver;\n+\n+impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n+    /// Add suggestions for a path that cannot be resolved.\n+    pub(crate) fn make_path_suggestion(\n+        &mut self,\n+        span: Span,\n+        path: Vec<Ident>\n+    ) -> Option<Vec<Ident>> {\n+        debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n+        // If we don't have a path to suggest changes to, then return.\n+        if path.is_empty() {\n+            return None;\n+        }\n+\n+        // Check whether a ident is a path segment that is not root.\n+        let is_special = |ident: Ident| ident.is_path_segment_keyword() &&\n+                                        ident.name != keywords::CrateRoot.name();\n+\n+        match (path.get(0), path.get(1)) {\n+            // Make suggestions that require at least two non-special path segments.\n+            (Some(fst), Some(snd)) if !is_special(*fst) && !is_special(*snd) => {\n+                debug!(\"make_path_suggestion: fst={:?} snd={:?}\", fst, snd);\n+\n+                self.make_missing_self_suggestion(span, path.clone())\n+                    .or_else(|| self.make_missing_crate_suggestion(span, path.clone()))\n+                    .or_else(|| self.make_missing_super_suggestion(span, path.clone()))\n+                    .or_else(|| self.make_external_crate_suggestion(span, path.clone()))\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    /// Suggest a missing `self::` if that resolves to an correct module.\n+    ///\n+    /// ```\n+    ///    |\n+    /// LL | use foo::Bar;\n+    ///    |     ^^^ Did you mean `self::foo`?\n+    /// ```\n+    fn make_missing_self_suggestion(\n+        &mut self,\n+        span: Span,\n+        mut path: Vec<Ident>\n+    ) -> Option<Vec<Ident>> {\n+        // Replace first ident with `self` and check if that is valid.\n+        path[0].name = keywords::SelfValue.name();\n+        let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+        debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n+        if let PathResult::Module(..) = result {\n+            Some(path)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Suggest a missing `crate::` if that resolves to an correct module.\n+    ///\n+    /// ```\n+    ///    |\n+    /// LL | use foo::Bar;\n+    ///    |     ^^^ Did you mean `crate::foo`?\n+    /// ```\n+    fn make_missing_crate_suggestion(\n+        &mut self,\n+        span: Span,\n+        mut path: Vec<Ident>\n+    ) -> Option<Vec<Ident>> {\n+        // Replace first ident with `crate` and check if that is valid.\n+        path[0].name = keywords::Crate.name();\n+        let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+        debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n+        if let PathResult::Module(..) = result {\n+            Some(path)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Suggest a missing `super::` if that resolves to an correct module.\n+    ///\n+    /// ```\n+    ///    |\n+    /// LL | use foo::Bar;\n+    ///    |     ^^^ Did you mean `super::foo`?\n+    /// ```\n+    fn make_missing_super_suggestion(\n+        &mut self,\n+        span: Span,\n+        mut path: Vec<Ident>\n+    ) -> Option<Vec<Ident>> {\n+        // Replace first ident with `crate` and check if that is valid.\n+        path[0].name = keywords::Super.name();\n+        let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+        debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n+        if let PathResult::Module(..) = result {\n+            Some(path)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Suggest a missing external crate name if that resolves to an correct module.\n+    ///\n+    /// ```\n+    ///    |\n+    /// LL | use foobar::Baz;\n+    ///    |     ^^^^^^ Did you mean `baz::foobar`?\n+    /// ```\n+    ///\n+    /// Used when importing a submodule of an external crate but missing that crate's\n+    /// name as the first part of path.\n+    fn make_external_crate_suggestion(\n+        &mut self,\n+        span: Span,\n+        mut path: Vec<Ident>\n+    ) -> Option<Vec<Ident>> {\n+        // Need to clone else we can't call `resolve_path` without a borrow error. We also store\n+        // into a `BTreeMap` so we can get consistent ordering (and therefore the same diagnostic)\n+        // each time.\n+        let external_crate_names: BTreeSet<Symbol> = self.resolver.session.extern_prelude\n+            .clone().drain().collect();\n+\n+        // Insert a new path segment that we can replace.\n+        let new_path_segment = path[0].clone();\n+        path.insert(1, new_path_segment);\n+\n+        // Iterate in reverse so that we start with crates at the end of the alphabet. This means\n+        // that we'll always get `std` before `core`.\n+        for name in external_crate_names.iter().rev() {\n+            let ident = Ident::with_empty_ctxt(*name);\n+            // Calling `maybe_process_path_extern` ensures that we're only running `resolve_path`\n+            // on a crate name that won't ICE.\n+            if let Some(_) = self.crate_loader.maybe_process_path_extern(*name, ident.span) {\n+                // Replace the first after root (a placeholder we inserted) with a crate name\n+                // and check if that is valid.\n+                path[1].name = *name;\n+                let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+                debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n+                       name, path, result);\n+                if let PathResult::Module(..) = result {\n+                    return Some(path)\n+                }\n+            }\n+        }\n+\n+        // Remove our placeholder segment.\n+        path.remove(1);\n+        None\n+    }\n+}"}, {"sha": "ece0188fa626d15f599f899ef564e5d434bf4386", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "patch": "@@ -84,7 +84,7 @@ use macros::{InvocationData, LegacyBinding, ParentScope};\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n mod diagnostics;\n-\n+mod error_reporting;\n mod macros;\n mod check_unused;\n mod build_reduced_graph;"}, {"sha": "333131398151affa682ca0c4292e83302f0ebfcf", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "patch": "@@ -958,17 +958,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 return None;\n             }\n             PathResult::Failed(span, msg, true) => {\n-                let (mut self_path, mut self_result) = (module_path.clone(), None);\n-                let is_special = |ident: Ident| ident.is_path_segment_keyword() &&\n-                                                ident.name != keywords::CrateRoot.name();\n-                if !self_path.is_empty() && !is_special(self_path[0]) &&\n-                   !(self_path.len() > 1 && is_special(self_path[1])) {\n-                    self_path[0].name = keywords::SelfValue.name();\n-                    self_result = Some(self.resolve_path(None, &self_path, None, false,\n-                                                         span, CrateLint::No));\n-                }\n-                return if let Some(PathResult::Module(..)) = self_result {\n-                    Some((span, format!(\"Did you mean `{}`?\", names_to_string(&self_path[..]))))\n+                return if let Some(suggested_path) = self.make_path_suggestion(\n+                    span, module_path.clone()\n+                ) {\n+                    Some((\n+                        span,\n+                        format!(\"Did you mean `{}`?\", names_to_string(&suggested_path[..]))\n+                    ))\n                 } else {\n                     Some((span, msg))\n                 };"}, {"sha": "a30e73cf02d12d00121afff6a39ef2f5c81e048a", "filename": "src/test/ui/resolve_self_super_hint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs?ref=4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "patch": "@@ -19,15 +19,15 @@ mod a {\n     mod b {\n         use alloc::HashMap;\n         //~^ ERROR unresolved import `alloc` [E0432]\n-        //~| Did you mean `a::alloc`?\n+        //~| Did you mean `super::alloc`?\n         mod c {\n             use alloc::HashMap;\n             //~^ ERROR unresolved import `alloc` [E0432]\n-            //~| Did you mean `a::alloc`?\n+            //~| Did you mean `std::alloc`?\n             mod d {\n                 use alloc::HashMap;\n                 //~^ ERROR unresolved import `alloc` [E0432]\n-                //~| Did you mean `a::alloc`?\n+                //~| Did you mean `std::alloc`?\n             }\n         }\n     }"}, {"sha": "b58a23724e413d9acd3decf1716cd64b5af31590", "filename": "src/test/ui/resolve_self_super_hint.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr?ref=4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "patch": "@@ -8,19 +8,19 @@ error[E0432]: unresolved import `alloc`\n   --> $DIR/resolve_self_super_hint.rs:20:13\n    |\n LL |         use alloc::HashMap;\n-   |             ^^^^^ Did you mean `a::alloc`?\n+   |             ^^^^^ Did you mean `super::alloc`?\n \n error[E0432]: unresolved import `alloc`\n   --> $DIR/resolve_self_super_hint.rs:24:17\n    |\n LL |             use alloc::HashMap;\n-   |                 ^^^^^ Did you mean `a::alloc`?\n+   |                 ^^^^^ Did you mean `std::alloc`?\n \n error[E0432]: unresolved import `alloc`\n   --> $DIR/resolve_self_super_hint.rs:28:21\n    |\n LL |                 use alloc::HashMap;\n-   |                     ^^^^^ Did you mean `a::alloc`?\n+   |                     ^^^^^ Did you mean `std::alloc`?\n \n error: aborting due to 4 previous errors\n "}, {"sha": "4ee9c051c65684d05575f3fa83c84799d46db97a", "filename": "src/test/ui/rust-2018/auxiliary/baz.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Fauxiliary%2Fbaz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Fauxiliary%2Fbaz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fauxiliary%2Fbaz.rs?ref=4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file is used as part of the local-path-suggestions.rs test.\n+\n+pub mod foobar {\n+    pub struct Baz;\n+}"}, {"sha": "37bf19e61f8d84d765ee585df142245eb2e5dc8c", "filename": "src/test/ui/rust-2018/issue-54006.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Fissue-54006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Fissue-54006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fissue-54006.stderr?ref=4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `alloc`\n   --> $DIR/issue-54006.rs:16:5\n    |\n LL | use alloc::vec;\n-   |     ^^^^^ Could not find `alloc` in `{{root}}`\n+   |     ^^^^^ Did you mean `std::alloc`?\n \n error: cannot determine resolution for the macro `vec`\n   --> $DIR/issue-54006.rs:20:18"}, {"sha": "c691d2948229cb33e375951c9376bddb9c33d476", "filename": "src/test/ui/rust-2018/local-path-suggestions-2015.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.rs?ref=4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:baz.rs\n+// compile-flags:--extern baz\n+// edition:2015\n+\n+// This test exists to demonstrate the behaviour of the import suggestions\n+// from the `local-path-suggestions-2018.rs` test when not using the 2018 edition.\n+\n+extern crate baz as aux_baz;\n+\n+mod foo {\n+    pub type Bar = u32;\n+}\n+\n+mod baz {\n+    use foo::Bar;\n+\n+    fn baz() {\n+        let x: Bar = 22;\n+    }\n+}\n+\n+use foo::Bar;\n+\n+use foobar::Baz;\n+\n+fn main() { }"}, {"sha": "d7580507ce4259dc9b5a5b268ba38764a47a698f", "filename": "src/test/ui/rust-2018/local-path-suggestions-2015.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.stderr?ref=4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "patch": "@@ -0,0 +1,9 @@\n+error[E0432]: unresolved import `foobar`\n+  --> $DIR/local-path-suggestions-2015.rs:34:5\n+   |\n+LL | use foobar::Baz;\n+   |     ^^^^^^ Did you mean `aux_baz::foobar`?\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "147dae401f6ac79bbe27db2f0f78898a084238cf", "filename": "src/test/ui/rust-2018/local-path-suggestions-2018.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.rs?ref=4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:baz.rs\n+// compile-flags:--extern baz\n+// edition:2018\n+\n+mod foo {\n+    pub type Bar = u32;\n+}\n+\n+mod baz {\n+    use foo::Bar;\n+\n+    fn baz() {\n+        let x: Bar = 22;\n+    }\n+}\n+\n+use foo::Bar;\n+\n+use foobar::Baz;\n+\n+fn main() { }"}, {"sha": "97bf748881f29907490b26b2f3da80f2814cc72f", "filename": "src/test/ui/rust-2018/local-path-suggestions-2018.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bf883b5e76f3a59770b891cb8b1b0576dfe359e/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr?ref=4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "patch": "@@ -0,0 +1,21 @@\n+error[E0432]: unresolved import `foo`\n+  --> $DIR/local-path-suggestions-2018.rs:20:9\n+   |\n+LL |     use foo::Bar;\n+   |         ^^^ Did you mean `crate::foo`?\n+\n+error[E0432]: unresolved import `foo`\n+  --> $DIR/local-path-suggestions-2018.rs:27:5\n+   |\n+LL | use foo::Bar;\n+   |     ^^^ Did you mean `self::foo`?\n+\n+error[E0432]: unresolved import `foobar`\n+  --> $DIR/local-path-suggestions-2018.rs:29:5\n+   |\n+LL | use foobar::Baz;\n+   |     ^^^^^^ Did you mean `baz::foobar`?\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0432`."}]}