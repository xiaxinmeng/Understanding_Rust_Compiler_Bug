{"sha": "94c3c84b6a9c382862b1f750f782c33256fa58bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YzNjODRiNmE5YzM4Mjg2MmIxZjc1MGY3ODJjMzMyNTZmYTU4YmQ=", "commit": {"author": {"name": "Shaun Steenkamp", "email": "theguywholikeslinux@gmail.com", "date": "2018-02-13T16:33:00Z"}, "committer": {"name": "Shaun Steenkamp", "email": "theguywholikeslinux@gmail.com", "date": "2018-02-13T16:40:02Z"}, "message": "38880 hashmap check size=0, not just capacity=0", "tree": {"sha": "6710bd3d746b0c147a94f2c8af4c58af250022b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6710bd3d746b0c147a94f2c8af4c58af250022b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94c3c84b6a9c382862b1f750f782c33256fa58bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94c3c84b6a9c382862b1f750f782c33256fa58bd", "html_url": "https://github.com/rust-lang/rust/commit/94c3c84b6a9c382862b1f750f782c33256fa58bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94c3c84b6a9c382862b1f750f782c33256fa58bd/comments", "author": {"login": "technicalguy", "id": 5120940, "node_id": "MDQ6VXNlcjUxMjA5NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/5120940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/technicalguy", "html_url": "https://github.com/technicalguy", "followers_url": "https://api.github.com/users/technicalguy/followers", "following_url": "https://api.github.com/users/technicalguy/following{/other_user}", "gists_url": "https://api.github.com/users/technicalguy/gists{/gist_id}", "starred_url": "https://api.github.com/users/technicalguy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/technicalguy/subscriptions", "organizations_url": "https://api.github.com/users/technicalguy/orgs", "repos_url": "https://api.github.com/users/technicalguy/repos", "events_url": "https://api.github.com/users/technicalguy/events{/privacy}", "received_events_url": "https://api.github.com/users/technicalguy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "technicalguy", "id": 5120940, "node_id": "MDQ6VXNlcjUxMjA5NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/5120940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/technicalguy", "html_url": "https://github.com/technicalguy", "followers_url": "https://api.github.com/users/technicalguy/followers", "following_url": "https://api.github.com/users/technicalguy/following{/other_user}", "gists_url": "https://api.github.com/users/technicalguy/gists{/gist_id}", "starred_url": "https://api.github.com/users/technicalguy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/technicalguy/subscriptions", "organizations_url": "https://api.github.com/users/technicalguy/orgs", "repos_url": "https://api.github.com/users/technicalguy/repos", "events_url": "https://api.github.com/users/technicalguy/events{/privacy}", "received_events_url": "https://api.github.com/users/technicalguy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a295ec1ec9d7616474a620a8acd15944aaf0c638", "url": "https://api.github.com/repos/rust-lang/rust/commits/a295ec1ec9d7616474a620a8acd15944aaf0c638", "html_url": "https://github.com/rust-lang/rust/commit/a295ec1ec9d7616474a620a8acd15944aaf0c638"}], "stats": {"total": 54, "additions": 24, "deletions": 30}, "files": [{"sha": "fdc62be3dd96095fe60e140790f368bf44c845c9", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/94c3c84b6a9c382862b1f750f782c33256fa58bd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c3c84b6a9c382862b1f750f782c33256fa58bd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=94c3c84b6a9c382862b1f750f782c33256fa58bd", "patch": "@@ -414,7 +414,6 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalE\n     search_hashed_nonempty(table, hash, is_match)\n }\n \n-\n /// Search for a pre-hashed key when the hash map is known to be non-empty.\n #[inline]\n fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n@@ -557,32 +556,36 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n-    /// If you already have the hash for the key lying around, use\n-    /// search_hashed.\n+    /// If you already have the hash for the key lying around, or if you need an\n+    /// InternalEntry, use search_hashed or search_hashed_nonempty.\n     #[inline]\n-    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> InternalEntry<K, V, &'a RawTable<K, V>>\n+    fn search<'a, Q: ?Sized>(&'a self, q: &Q)\n+        -> Option<FullBucket<K, V, &'a RawTable<K, V>>>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n     {\n-        if self.table.capacity() != 0 {\n-            let hash = self.make_hash(q);\n-            search_hashed_nonempty(&self.table, hash, |k| q.eq(k.borrow()))\n-        } else {\n-            InternalEntry::TableIsEmpty\n+        if !self.is_empty() {\n+            return None;\n         }\n+\n+        let hash = self.make_hash(q);\n+        search_hashed_nonempty(&self.table, hash, |k| q.eq(k.borrow()))\n+            .into_occupied_bucket()\n     }\n \n     #[inline]\n-    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> InternalEntry<K, V, &'a mut RawTable<K, V>>\n+    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q)\n+        -> Option<FullBucket<K, V, &'a mut RawTable<K, V>>>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n     {\n-        if self.table.capacity() != 0 {\n-            let hash = self.make_hash(q);\n-            search_hashed_nonempty(&mut self.table, hash, |k| q.eq(k.borrow()))\n-        } else {\n-            InternalEntry::TableIsEmpty\n+        if self.is_empty() {\n+            return None;\n         }\n+\n+        let hash = self.make_hash(q);\n+        search_hashed_nonempty(&mut self.table, hash, |k| q.eq(k.borrow()))\n+            .into_occupied_bucket()\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold\n@@ -1140,7 +1143,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search(k).into_occupied_bucket().map(|bucket| bucket.into_refs().1)\n+        self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n \n     /// Returns true if the map contains a value for the specified key.\n@@ -1167,7 +1170,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search(k).into_occupied_bucket().is_some()\n+        self.search(k).is_some()\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -1196,7 +1199,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search_mut(k).into_occupied_bucket().map(|bucket| bucket.into_mut_refs().1)\n+        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n \n     /// Inserts a key-value pair into the map.\n@@ -1256,11 +1259,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        if self.table.size() == 0 {\n-            return None;\n-        }\n-\n-        self.search_mut(k).into_occupied_bucket().map(|bucket| pop_internal(bucket).1)\n+        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n     }\n \n     /// Removes a key from the map, returning the stored key and value if the\n@@ -1296,7 +1295,6 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n \n         self.search_mut(k)\n-            .into_occupied_bucket()\n             .map(|bucket| {\n                 let (k, v, _) = pop_internal(bucket);\n                 (k, v)\n@@ -2654,15 +2652,11 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n \n     #[inline]\n     fn get(&self, key: &Q) -> Option<&K> {\n-        self.search(key).into_occupied_bucket().map(|bucket| bucket.into_refs().0)\n+        self.search(key).map(|bucket| bucket.into_refs().0)\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n-        if self.table.size() == 0 {\n-            return None;\n-        }\n-\n-        self.search_mut(key).into_occupied_bucket().map(|bucket| pop_internal(bucket).0)\n+        self.search_mut(key).map(|bucket| pop_internal(bucket).0)\n     }\n \n     #[inline]"}]}