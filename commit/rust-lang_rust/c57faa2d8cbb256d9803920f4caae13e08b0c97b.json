{"sha": "c57faa2d8cbb256d9803920f4caae13e08b0c97b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1N2ZhYTJkOGNiYjI1NmQ5ODAzOTIwZjRjYWFlMTNlMDhiMGM5N2I=", "commit": {"author": {"name": "chromatic", "email": "chromatic@wgz.org", "date": "2014-02-11T00:20:34Z"}, "committer": {"name": "chromatic", "email": "chromatic@wgz.org", "date": "2014-02-11T00:21:18Z"}, "message": "Revised Crate section of tutorial for clarity.", "tree": {"sha": "d54cebe2414ad08e9ee0443579a6cbcc38954746", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d54cebe2414ad08e9ee0443579a6cbcc38954746"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c57faa2d8cbb256d9803920f4caae13e08b0c97b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c57faa2d8cbb256d9803920f4caae13e08b0c97b", "html_url": "https://github.com/rust-lang/rust/commit/c57faa2d8cbb256d9803920f4caae13e08b0c97b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c57faa2d8cbb256d9803920f4caae13e08b0c97b/comments", "author": {"login": "chromatic", "id": 50255, "node_id": "MDQ6VXNlcjUwMjU1", "avatar_url": "https://avatars.githubusercontent.com/u/50255?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chromatic", "html_url": "https://github.com/chromatic", "followers_url": "https://api.github.com/users/chromatic/followers", "following_url": "https://api.github.com/users/chromatic/following{/other_user}", "gists_url": "https://api.github.com/users/chromatic/gists{/gist_id}", "starred_url": "https://api.github.com/users/chromatic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chromatic/subscriptions", "organizations_url": "https://api.github.com/users/chromatic/orgs", "repos_url": "https://api.github.com/users/chromatic/repos", "events_url": "https://api.github.com/users/chromatic/events{/privacy}", "received_events_url": "https://api.github.com/users/chromatic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chromatic", "id": 50255, "node_id": "MDQ6VXNlcjUwMjU1", "avatar_url": "https://avatars.githubusercontent.com/u/50255?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chromatic", "html_url": "https://github.com/chromatic", "followers_url": "https://api.github.com/users/chromatic/followers", "following_url": "https://api.github.com/users/chromatic/following{/other_user}", "gists_url": "https://api.github.com/users/chromatic/gists{/gist_id}", "starred_url": "https://api.github.com/users/chromatic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chromatic/subscriptions", "organizations_url": "https://api.github.com/users/chromatic/orgs", "repos_url": "https://api.github.com/users/chromatic/repos", "events_url": "https://api.github.com/users/chromatic/events{/privacy}", "received_events_url": "https://api.github.com/users/chromatic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38ed4674e8054ee854871303401bffed7c05b01b", "url": "https://api.github.com/repos/rust-lang/rust/commits/38ed4674e8054ee854871303401bffed7c05b01b", "html_url": "https://github.com/rust-lang/rust/commit/38ed4674e8054ee854871303401bffed7c05b01b"}], "stats": {"total": 73, "additions": 34, "deletions": 39}, "files": [{"sha": "8942d780ddeedb571c9d2125c55e0fd40ea476d1", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c57faa2d8cbb256d9803920f4caae13e08b0c97b/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/c57faa2d8cbb256d9803920f4caae13e08b0c97b/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=c57faa2d8cbb256d9803920f4caae13e08b0c97b", "patch": "@@ -2679,25 +2679,24 @@ manual.\n \n ## Files and modules\n \n-One important aspect about Rusts module system is that source files are not important:\n-You define a module hierarchy, populate it with all your definitions, define visibility,\n-maybe put in a `fn main()`, and that's it: No need to think about source files.\n+One important aspect of Rust's module system is that source files and modules are not the same thing. You define a module hierarchy, populate it with all your definitions, define visibility, maybe put in a `fn main()`, and that's it.\n \n-The only file that's relevant is the one that contains the body of your crate root,\n-and it's only relevant because you have to pass that file to `rustc` to compile your crate.\n+The only file that's relevant when compiling is the one that contains the body\n+of your crate root, and it's only relevant because you have to pass that file\n+to `rustc` to compile your crate.\n \n-And in principle, that's all you need: You can write any Rust program as one giant source file that contains your\n-crate root and everything below it in `mod ... { ... }` declarations.\n+In principle, that's all you need: You can write any Rust program as one giant source file that contains your\n+crate root and everything else in `mod ... { ... }` declarations.\n \n-However, in practice you usually want to split you code up into multiple source files to make it more manageable.\n-In order to do that, Rust allows you to move the body of any module into it's own source file, which works like this:\n+However, in practice you usually want to split up your code into multiple\n+source files to make it more manageable. Rust allows you to move the body of\n+any module into its own source file. If you declare a module without its body,\n+like `mod foo;`, the compiler will look for the files `foo.rs` and `foo/mod.rs`\n+inside some directory (usually the same as of the source file containing the\n+`mod foo;` declaration). If it finds either, it uses the content of that file\n+as the body of the module. If it finds both, that's a compile error.\n \n-If you declare a module without its body, like `mod foo;`, the compiler will look for the\n-files `foo.rs` and `foo/mod.rs` inside some directory (usually the same as of the source file containing\n-the `mod foo;`). If it finds either, it uses the content of that file as the body of the module.\n-If it finds both, that's a compile error.\n-\n-So, if we want to move the content of `mod farm` into it's own file, it would look like this:\n+To move the content of `mod farm` into its own file, you can write:\n \n ~~~~ {.ignore}\n // `main.rs` - contains body of the crate root\n@@ -2722,17 +2721,13 @@ pub mod barn {\n \n In short, `mod foo;` is just syntactic sugar for `mod foo { /* content of <...>/foo.rs or <...>/foo/mod.rs */ }`.\n \n-This also means that having two or more identical `mod foo;` somewhere\n-in your crate hierarchy is generally a bad idea,\n-just like copy-and-paste-ing a module into two or more places is one.\n+This also means that having two or more identical `mod foo;` declarations somewhere in your crate hierarchy is generally a bad idea,\n+just like copy-and-paste-ing a module into multiple places is a bad idea.\n Both will result in duplicate and mutually incompatible definitions.\n \n-The directory the compiler looks in for those two files is determined by starting with\n-the same directory as the source file that contains the `mod foo;` declaration, and concatenating to that a\n-path equivalent to the relative path of all nested `mod { ... }` declarations the `mod foo;`\n-is contained in, if any.\n-\n-For example, given a file with this module body:\n+When `rustc` resolves these module declarations, it starts by looking in the\n+parent directory of the file containing the `mod foo` declaration. For example,\n+given a file with the module body:\n \n ~~~ {.ignore}\n // `src/main.rs`\n@@ -2745,7 +2740,7 @@ mod animals {\n }\n ~~~\n \n-The compiler would then try all these files:\n+The compiler will look for these files, in this order:\n \n ~~~ {.notrust}\n src/plants.rs\n@@ -2758,9 +2753,9 @@ src/animals/mammals/humans.rs\n src/animals/mammals/humans/mod.rs\n ~~~\n \n-Keep in mind that identical module hierachies can still lead to different path lookups\n-depending on how and where you've moved a module body to its own file.\n-For example, if we move the `animals` module above into its own file...\n+Keep in mind that identical module hierarchies can still lead to different path\n+lookups depending on how and where you've moved a module body to its own file.\n+For example, if you move the `animals` module into its own file:\n \n ~~~ {.ignore}\n // `src/main.rs`\n@@ -2776,21 +2771,21 @@ mod mammals {\n }\n ~~~\n \n-...then the source files of `mod animals`'s submodules can\n-either be placed right next to that of its parents, or in a subdirectory if `animals` source file is:\n+...then the source files of `mod animals`'s submodules can either be in the same directory as the animals source file or in a subdirectory of its directory. If the animals file is `src/animals.rs`, `rustc` will look for:\n \n ~~~ {.notrust}\n-src/plants.rs\n-src/plants/mod.rs\n-\n-src/animals.rs - if file sits next to that of parent module's:\n+src/animals.rs\n     src/fish.rs\n     src/fish/mod.rs\n \n     src/mammals/humans.rs\n     src/mammals/humans/mod.rs\n+~~\n+\n+If the animals file is `src/animals/mod.rs`, `rustc` will look for:\n \n-src/animals/mod.rs - if file is in it's own subdirectory:\n+~~ {.notrust}\n+src/animals/mod.rs\n     src/animals/fish.rs\n     src/animals/fish/mod.rs\n \n@@ -2799,11 +2794,11 @@ src/animals/mod.rs - if file is in it's own subdirectory:\n \n ~~~\n \n-These rules allow you to have both small modules that only need\n-to consist of one source file each and can be conveniently placed right next to each other,\n-and big complicated modules that group the source files of submodules in subdirectories.\n+These rules allow you to write small modules consisting of single source files which can live in the same directory as well as large modules which group submodule source files in subdirectories.\n \n-If you need to circumvent the defaults, you can also overwrite the path a `mod foo;` would take:\n+If you need to override where `rustc` will look for the file containing a\n+module's source code, use the `path` compiler directive. For example, to load a\n+`classified` module from a different file:\n \n ~~~ {.ignore}\n #[path=\"../../area51/alien.rs\"]"}]}