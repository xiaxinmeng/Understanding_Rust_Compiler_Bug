{"sha": "d413bb6f5716261f2740eb67540df1da1469ce12", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MTNiYjZmNTcxNjI2MWYyNzQwZWI2NzU0MGRmMWRhMTQ2OWNlMTI=", "commit": {"author": {"name": "chansuke", "email": "chansuke@georepublic.de", "date": "2020-07-18T12:59:53Z"}, "committer": {"name": "chansuke", "email": "chansuke@georepublic.de", "date": "2020-10-24T02:50:09Z"}, "message": "`#[deny(unsafe_op_in_unsafe_fn)]` in sys/wasm", "tree": {"sha": "1ceb0509a20a24e399b6a3dc16c27b80a7777346", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ceb0509a20a24e399b6a3dc16c27b80a7777346"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d413bb6f5716261f2740eb67540df1da1469ce12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d413bb6f5716261f2740eb67540df1da1469ce12", "html_url": "https://github.com/rust-lang/rust/commit/d413bb6f5716261f2740eb67540df1da1469ce12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d413bb6f5716261f2740eb67540df1da1469ce12/comments", "author": null, "committer": null, "parents": [{"sha": "7bade6ef730cff83f3591479a98916920f66decd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bade6ef730cff83f3591479a98916920f66decd", "html_url": "https://github.com/rust-lang/rust/commit/7bade6ef730cff83f3591479a98916920f66decd"}], "stats": {"total": 50, "additions": 32, "deletions": 18}, "files": [{"sha": "e12af19718a7cd34ae4fd364faf82bb72bda447c", "filename": "library/std/src/sys/wasm/alloc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d413bb6f5716261f2740eb67540df1da1469ce12/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d413bb6f5716261f2740eb67540df1da1469ce12/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Falloc.rs?ref=d413bb6f5716261f2740eb67540df1da1469ce12", "patch": "@@ -25,25 +25,25 @@ unsafe impl GlobalAlloc for System {\n     #[inline]\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n         let _lock = lock::lock();\n-        DLMALLOC.malloc(layout.size(), layout.align())\n+        unsafe { DLMALLOC.malloc(layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n         let _lock = lock::lock();\n-        DLMALLOC.calloc(layout.size(), layout.align())\n+        unsafe { DLMALLOC.calloc(layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         let _lock = lock::lock();\n-        DLMALLOC.free(ptr, layout.size(), layout.align())\n+        unsafe { DLMALLOC.free(ptr, layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n         let _lock = lock::lock();\n-        DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n+        unsafe { DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size) }\n     }\n }\n "}, {"sha": "b9133e9fb7dbce7ab46170ffcc0b18fc5f95305e", "filename": "library/std/src/sys/wasm/condvar_atomics.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d413bb6f5716261f2740eb67540df1da1469ce12/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d413bb6f5716261f2740eb67540df1da1469ce12/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs?ref=d413bb6f5716261f2740eb67540df1da1469ce12", "patch": "@@ -44,13 +44,18 @@ impl Condvar {\n \n     pub unsafe fn notify_one(&self) {\n         self.cnt.fetch_add(1, SeqCst);\n-        wasm32::memory_atomic_notify(self.ptr(), 1);\n+        // SAFETY: ptr() is always valid\n+        unsafe {\n+            wasm32::memory_atomic_notify(self.ptr(), 1);\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn notify_all(&self) {\n-        self.cnt.fetch_add(1, SeqCst);\n-        wasm32::memory_atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n+        unsafe {\n+            self.cnt.fetch_add(1, SeqCst);\n+            wasm32::memory_atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n+        }\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {"}, {"sha": "82683c0f624cf88487ca777b748493eb5a4d4d4a", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d413bb6f5716261f2740eb67540df1da1469ce12/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d413bb6f5716261f2740eb67540df1da1469ce12/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=d413bb6f5716261f2740eb67540df1da1469ce12", "patch": "@@ -14,6 +14,8 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n pub mod alloc;\n pub mod args;\n #[path = \"../unsupported/cmath.rs\"]"}, {"sha": "11d7f4c389decb536e64547ee56b2bbc32fa20db", "filename": "library/std/src/sys/wasm/mutex_atomics.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d413bb6f5716261f2740eb67540df1da1469ce12/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d413bb6f5716261f2740eb67540df1da1469ce12/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=d413bb6f5716261f2740eb67540df1da1469ce12", "patch": "@@ -28,11 +28,14 @@ impl Mutex {\n \n     pub unsafe fn lock(&self) {\n         while !self.try_lock() {\n-            let val = wasm32::memory_atomic_wait32(\n-                self.ptr(),\n-                1,  // we expect our mutex is locked\n-                -1, // wait infinitely\n-            );\n+            // SAFETY: the caller must uphold the safety contract for `memory_atomic_wait32`.\n+            let val = unsafe {\n+                wasm32::memory_atomic_wait32(\n+                    self.ptr(),\n+                    1,  // we expect our mutex is locked\n+                    -1, // wait infinitely\n+                )\n+            };\n             // we should have either woke up (0) or got a not-equal due to a\n             // race (1). We should never time out (2)\n             debug_assert!(val == 0 || val == 1);\n@@ -47,7 +50,7 @@ impl Mutex {\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        self.locked.compare_exchange(0, 1, SeqCst, SeqCst).is_ok()\n+        unsafe { self.locked.compare_exchange(0, 1, SeqCst, SeqCst).is_ok() }\n     }\n \n     #[inline]\n@@ -83,7 +86,7 @@ unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n     pub const unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { owner: AtomicU32::new(0), recursions: UnsafeCell::new(0) }\n+        unsafe { ReentrantMutex { owner: AtomicU32::new(0), recursions: UnsafeCell::new(0) } }\n     }\n \n     pub unsafe fn init(&self) {\n@@ -93,19 +96,20 @@ impl ReentrantMutex {\n     pub unsafe fn lock(&self) {\n         let me = thread::my_id();\n         while let Err(owner) = self._try_lock(me) {\n-            let val = wasm32::memory_atomic_wait32(self.ptr(), owner as i32, -1);\n+            // SAFETY: the caller must gurantee that `self.ptr()` and `owner` are valid i32.\n+            let val = unsafe { wasm32::memory_atomic_wait32(self.ptr(), owner as i32, -1) };\n             debug_assert!(val == 0 || val == 1);\n         }\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        self._try_lock(thread::my_id()).is_ok()\n+        unsafe { self._try_lock(thread::my_id()).is_ok() }\n     }\n \n     #[inline]\n     unsafe fn _try_lock(&self, id: u32) -> Result<(), u32> {\n-        let id = id.checked_add(1).unwrap(); // make sure `id` isn't 0\n+        let id = id.checked_add(1).unwrap();\n         match self.owner.compare_exchange(0, id, SeqCst, SeqCst) {\n             // we transitioned from unlocked to locked\n             Ok(_) => {\n@@ -132,7 +136,10 @@ impl ReentrantMutex {\n         match *self.recursions.get() {\n             0 => {\n                 self.owner.swap(0, SeqCst);\n-                wasm32::memory_atomic_notify(self.ptr() as *mut i32, 1); // wake up one waiter, if any\n+                // SAFETY: the caller must gurantee that `self.ptr()` is valid i32.\n+                unsafe {\n+                    wasm32::atomic_notify(self.ptr() as *mut i32, 1);\n+                } // wake up one waiter, if any\n             }\n             ref mut n => *n -= 1,\n         }"}]}