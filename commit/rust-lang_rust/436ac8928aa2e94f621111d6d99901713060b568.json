{"sha": "436ac8928aa2e94f621111d6d99901713060b568", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNmFjODkyOGFhMmU5NGY2MjExMTFkNmQ5OTkwMTcxMzA2MGI1Njg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-28T08:04:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-28T08:04:58Z"}, "message": "Auto merge of #46123 - Gankro:c-repr, r=eddyb\n\nImplement the special repr(C)-non-clike-enum layout\n\nThis is the second half of https://github.com/rust-lang/rfcs/pull/2195\n\nwhich specifies that\n\n```rust\n#[repr(C, u8)]\n#[derive(Copy, Clone, Eq, PartialEq, Debug)]\nenum MyEnum {\n    A(u32),                 // Single primitive value\n    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n    C,                      // Empty\n    D(Option<u32>),         // Contains an enum\n    E(Duration),            // Contains a struct\n}\n```\n\nHas the same layout as\n\n```rust\n#[repr(C)]\nstruct MyEnumRepr {\n    tag: MyEnumTag,\n    payload: MyEnumPayload,\n}\n\n#[repr(C)]\n#[allow(non_snake_case)]\nunion MyEnumPayload {\n    A: MyEnumVariantA,\n    B: MyEnumVariantB,\n    D: MyEnumVariantD,\n    E: MyEnumVariantE,\n}\n\n#[repr(u8)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(u32);\n#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16 }\n#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(Option<u32>);\n#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(Duration);\n\n```", "tree": {"sha": "f0abcf68b1f974a58c02d5f7571cf2f30fee373e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0abcf68b1f974a58c02d5f7571cf2f30fee373e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/436ac8928aa2e94f621111d6d99901713060b568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/436ac8928aa2e94f621111d6d99901713060b568", "html_url": "https://github.com/rust-lang/rust/commit/436ac8928aa2e94f621111d6d99901713060b568", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/436ac8928aa2e94f621111d6d99901713060b568/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7745a7a8177259cd2ea0b48eaf35dd943eec2896", "url": "https://api.github.com/repos/rust-lang/rust/commits/7745a7a8177259cd2ea0b48eaf35dd943eec2896", "html_url": "https://github.com/rust-lang/rust/commit/7745a7a8177259cd2ea0b48eaf35dd943eec2896"}, {"sha": "0e63d2727c3215fab617a64c0a159ea871f4819c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e63d2727c3215fab617a64c0a159ea871f4819c", "html_url": "https://github.com/rust-lang/rust/commit/0e63d2727c3215fab617a64c0a159ea871f4819c"}], "stats": {"total": 478, "additions": 454, "deletions": 24}, "files": [{"sha": "003255f87966fb753bf5cf1808b2d32c9f4bafbb", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/436ac8928aa2e94f621111d6d99901713060b568/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/436ac8928aa2e94f621111d6d99901713060b568/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=436ac8928aa2e94f621111d6d99901713060b568", "patch": "@@ -75,7 +75,9 @@ impl<'a> CheckAttrVisitor<'a> {\n             }\n         };\n \n-        let mut conflicting_reprs = 0;\n+        let mut int_reprs = 0;\n+        let mut is_c = false;\n+        let mut is_simd = false;\n \n         for word in words {\n \n@@ -86,7 +88,7 @@ impl<'a> CheckAttrVisitor<'a> {\n \n             let (message, label) = match &*name.as_str() {\n                 \"C\" => {\n-                    conflicting_reprs += 1;\n+                    is_c = true;\n                     if target != Target::Struct &&\n                             target != Target::Union &&\n                             target != Target::Enum {\n@@ -108,7 +110,7 @@ impl<'a> CheckAttrVisitor<'a> {\n                     }\n                 }\n                 \"simd\" => {\n-                    conflicting_reprs += 1;\n+                    is_simd = true;\n                     if target != Target::Struct {\n                         (\"attribute should be applied to struct\",\n                          \"a struct\")\n@@ -128,7 +130,7 @@ impl<'a> CheckAttrVisitor<'a> {\n                 \"i8\" | \"u8\" | \"i16\" | \"u16\" |\n                 \"i32\" | \"u32\" | \"i64\" | \"u64\" |\n                 \"isize\" | \"usize\" => {\n-                    conflicting_reprs += 1;\n+                    int_reprs += 1;\n                     if target != Target::Enum {\n                         (\"attribute should be applied to enum\",\n                          \"an enum\")\n@@ -142,7 +144,11 @@ impl<'a> CheckAttrVisitor<'a> {\n                 .span_label(item.span, format!(\"not {}\", label))\n                 .emit();\n         }\n-        if conflicting_reprs > 1 {\n+\n+        // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n+        if (int_reprs > 1)\n+           || (is_simd && is_c)\n+           || (int_reprs == 1 && is_c && is_c_like_enum(item)) {\n             span_warn!(self.sess, attr.span, E0566,\n                        \"conflicting representation hints\");\n         }\n@@ -162,3 +168,17 @@ impl<'a> Visitor<'a> for CheckAttrVisitor<'a> {\n pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n     visit::walk_crate(&mut CheckAttrVisitor { sess: sess }, krate);\n }\n+\n+fn is_c_like_enum(item: &ast::Item) -> bool {\n+    if let ast::ItemKind::Enum(ref def, _) = item.node {\n+        for variant in &def.variants {\n+            match variant.node.data {\n+                ast::VariantData::Unit(_) => { /* continue */ }\n+                _ => { return false; }\n+            }\n+        }\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "7d262adffdb989df46a792f1c73f141ecb7e3613", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/436ac8928aa2e94f621111d6d99901713060b568/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/436ac8928aa2e94f621111d6d99901713060b568/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=436ac8928aa2e94f621111d6d99901713060b568", "patch": "@@ -942,8 +942,8 @@ impl<'a, 'tcx> LayoutDetails {\n             AlwaysSized,\n             /// A univariant, the last field of which may be coerced to unsized.\n             MaybeUnsized,\n-            /// A univariant, but part of an enum.\n-            EnumVariant(Integer),\n+            /// A univariant, but with a prefix of an arbitrary size & alignment (e.g. enum tag).\n+            Prefixed(Size, Align),\n         }\n         let univariant_uninterned = |fields: &[TyLayout], repr: &ReprOptions, kind| {\n             let packed = repr.packed();\n@@ -962,14 +962,11 @@ impl<'a, 'tcx> LayoutDetails {\n             let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n             // Anything with repr(C) or repr(packed) doesn't optimize.\n-            let optimize = match kind {\n-                StructKind::AlwaysSized |\n-                StructKind::MaybeUnsized |\n-                StructKind::EnumVariant(I8) => {\n-                    (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty()\n-                }\n-                StructKind::EnumVariant(_) => false\n-            };\n+            let mut optimize = (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty();\n+            if let StructKind::Prefixed(_, align) = kind {\n+                optimize &= align.abi() == 1;\n+            }\n+\n             if optimize {\n                 let end = if let StructKind::MaybeUnsized = kind {\n                     fields.len() - 1\n@@ -987,7 +984,7 @@ impl<'a, 'tcx> LayoutDetails {\n                             (!f.is_zst(), cmp::Reverse(f.align.abi()))\n                         })\n                     }\n-                    StructKind::EnumVariant(_) => {\n+                    StructKind::Prefixed(..) => {\n                         optimizing.sort_by_key(|&x| fields[x as usize].align.abi());\n                     }\n                 }\n@@ -1001,12 +998,11 @@ impl<'a, 'tcx> LayoutDetails {\n \n             let mut offset = Size::from_bytes(0);\n \n-            if let StructKind::EnumVariant(discr) = kind {\n-                offset = discr.size();\n+            if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n                 if !packed {\n-                    let discr_align = discr.align(dl);\n-                    align = align.max(discr_align);\n+                    align = align.max(prefix_align);\n                 }\n+                offset = prefix_size.abi_align(prefix_align);\n             }\n \n             for &i in &inverse_memory_index {\n@@ -1558,10 +1554,24 @@ impl<'a, 'tcx> LayoutDetails {\n                 let mut start_align = Align::from_bytes(256, 256).unwrap();\n                 assert_eq!(Integer::for_abi_align(dl, start_align), None);\n \n+                // repr(C) on an enum tells us to make a (tag, union) layout,\n+                // so we need to grow the prefix alignment to be at least\n+                // the alignment of the union. (This value is used both for\n+                // determining the alignment of the overall enum, and the\n+                // determining the alignment of the payload after the tag.)\n+                let mut prefix_align = min_ity.align(dl);\n+                if def.repr.c() {\n+                    for fields in &variants {\n+                        for field in fields {\n+                            prefix_align = prefix_align.max(field.align);\n+                        }\n+                    }\n+                }\n+\n                 // Create the set of structs that represent each variant.\n                 let mut variants = variants.into_iter().enumerate().map(|(i, field_layouts)| {\n                     let mut st = univariant_uninterned(&field_layouts,\n-                        &def.repr, StructKind::EnumVariant(min_ity))?;\n+                        &def.repr, StructKind::Prefixed(min_ity.size(), prefix_align))?;\n                     st.variants = Variants::Single { index: i };\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant."}, {"sha": "86453fdf6fae6903efc259472fba31aac627f83e", "filename": "src/test/run-pass/enum-non-c-like-repr-c-and-int.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/436ac8928aa2e94f621111d6d99901713060b568/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c-and-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/436ac8928aa2e94f621111d6d99901713060b568/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c-and-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c-and-int.rs?ref=436ac8928aa2e94f621111d6d99901713060b568", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test deserializes an enum in-place by transmuting to a union that\n+// should have the same layout, and manipulating the tag and payloads\n+// independently. This verifies that `repr(some_int)` has a stable representation,\n+// and that we don't miscompile these kinds of manipulations.\n+\n+use std::time::Duration;\n+use std::mem;\n+\n+#[repr(C, u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+enum MyEnum {\n+    A(u32),                 // Single primitive value\n+    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n+    C,                      // Empty\n+    D(Option<u32>),         // Contains an enum\n+    E(Duration),            // Contains a struct\n+}\n+\n+#[repr(C)]\n+struct MyEnumRepr {\n+    tag: MyEnumTag,\n+    payload: MyEnumPayload,\n+}\n+\n+#[repr(C)]\n+#[allow(non_snake_case)]\n+union MyEnumPayload {\n+    A: MyEnumVariantA,\n+    B: MyEnumVariantB,\n+    D: MyEnumVariantD,\n+    E: MyEnumVariantE,\n+}\n+\n+#[repr(u8)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(u32);\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16 }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(Option<u32>);\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(Duration);\n+\n+fn main() {\n+    let result: Vec<Result<MyEnum, ()>> = vec![\n+        Ok(MyEnum::A(17)),\n+        Ok(MyEnum::B { x: 206, y: 1145 }),\n+        Ok(MyEnum::C),\n+        Err(()),\n+        Ok(MyEnum::D(Some(407))),\n+        Ok(MyEnum::D(None)),\n+        Ok(MyEnum::E(Duration::from_secs(100))),\n+        Err(()),\n+    ];\n+\n+    // Binary serialized version of the above (little-endian)\n+    let input: Vec<u8> = vec![\n+        0,  17, 0, 0, 0,\n+        1,  206,  121, 4,\n+        2,\n+        8,  /* invalid tag value */\n+        3,  0,  151, 1, 0, 0,\n+        3,  1,\n+        4,  100, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,\n+        0,  /* incomplete value */\n+    ];\n+\n+    let mut output = vec![];\n+    let mut buf = &input[..];\n+\n+    unsafe {\n+        // This should be safe, because we don't match on it unless it's fully formed,\n+        // and it doesn't have a destructor.\n+        let mut dest: MyEnum = mem::uninitialized();\n+        while buf.len() > 0 {\n+            match parse_my_enum(&mut dest, &mut buf) {\n+                Ok(()) => output.push(Ok(dest)),\n+                Err(()) => output.push(Err(())),\n+            }\n+        }\n+    }\n+\n+    assert_eq!(output, result);\n+}\n+\n+fn parse_my_enum<'a>(dest: &'a mut MyEnum, buf: &mut &[u8]) -> Result<(), ()> {\n+    unsafe {\n+        // Should be correct to do this transmute.\n+        let dest: &'a mut MyEnumRepr = mem::transmute(dest);\n+        let tag = read_u8(buf)?;\n+\n+        dest.tag = match tag {\n+            0 => MyEnumTag::A,\n+            1 => MyEnumTag::B,\n+            2 => MyEnumTag::C,\n+            3 => MyEnumTag::D,\n+            4 => MyEnumTag::E,\n+            _ => return Err(()),\n+        };\n+\n+        match dest.tag {\n+            MyEnumTag::A => {\n+                dest.payload.A.0 = read_u32_le(buf)?;\n+            }\n+            MyEnumTag::B => {\n+                dest.payload.B.x = read_u8(buf)?;\n+                dest.payload.B.y = read_u16_le(buf)? as i16;\n+            }\n+            MyEnumTag::C => {\n+                /* do nothing */\n+            }\n+            MyEnumTag::D => {\n+                let is_some = read_u8(buf)? == 0;\n+                if is_some {\n+                    dest.payload.D.0 = Some(read_u32_le(buf)?);\n+                } else {\n+                    dest.payload.D.0 = None;\n+                }\n+            }\n+            MyEnumTag::E => {\n+                let secs = read_u64_le(buf)?;\n+                let nanos = read_u32_le(buf)?;\n+                dest.payload.E.0 = Duration::new(secs, nanos);\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+\n+\n+// reader helpers\n+\n+fn read_u64_le(buf: &mut &[u8]) -> Result<u64, ()> {\n+    if buf.len() < 8 { return Err(()) }\n+    let val = (buf[0] as u64) << 0\n+            | (buf[1] as u64) << 8\n+            | (buf[2] as u64) << 16\n+            | (buf[3] as u64) << 24\n+            | (buf[4] as u64) << 32\n+            | (buf[5] as u64) << 40\n+            | (buf[6] as u64) << 48\n+            | (buf[7] as u64) << 56;\n+    *buf = &buf[8..];\n+    Ok(val)\n+}\n+\n+fn read_u32_le(buf: &mut &[u8]) -> Result<u32, ()> {\n+    if buf.len() < 4 { return Err(()) }\n+    let val = (buf[0] as u32) << 0\n+            | (buf[1] as u32) << 8\n+            | (buf[2] as u32) << 16\n+            | (buf[3] as u32) << 24;\n+    *buf = &buf[4..];\n+    Ok(val)\n+}\n+\n+fn read_u16_le(buf: &mut &[u8]) -> Result<u16, ()> {\n+    if buf.len() < 2 { return Err(()) }\n+    let val = (buf[0] as u16) << 0\n+            | (buf[1] as u16) << 8;\n+    *buf = &buf[2..];\n+    Ok(val)\n+}\n+\n+fn read_u8(buf: &mut &[u8]) -> Result<u8, ()> {\n+    if buf.len() < 1 { return Err(()) }\n+    let val = buf[0];\n+    *buf = &buf[1..];\n+    Ok(val)\n+}"}, {"sha": "b4e0fe8d4572a4271430b5804ef5dfbb5487e948", "filename": "src/test/run-pass/enum-non-c-like-repr-c.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/436ac8928aa2e94f621111d6d99901713060b568/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/436ac8928aa2e94f621111d6d99901713060b568/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-non-c-like-repr-c.rs?ref=436ac8928aa2e94f621111d6d99901713060b568", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test deserializes an enum in-place by transmuting to a union that\n+// should have the same layout, and manipulating the tag and payloads\n+// independently. This verifies that `repr(some_int)` has a stable representation,\n+// and that we don't miscompile these kinds of manipulations.\n+\n+use std::time::Duration;\n+use std::mem;\n+\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+enum MyEnum {\n+    A(u32),                 // Single primitive value\n+    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n+    C,                      // Empty\n+    D(Option<u32>),         // Contains an enum\n+    E(Duration),            // Contains a struct\n+}\n+\n+#[repr(C)]\n+struct MyEnumRepr {\n+    tag: MyEnumTag,\n+    payload: MyEnumPayload,\n+}\n+\n+#[repr(C)]\n+#[allow(non_snake_case)]\n+union MyEnumPayload {\n+    A: MyEnumVariantA,\n+    B: MyEnumVariantB,\n+    D: MyEnumVariantD,\n+    E: MyEnumVariantE,\n+}\n+\n+#[repr(C)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(u32);\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16 }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(Option<u32>);\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(Duration);\n+\n+fn main() {\n+    let result: Vec<Result<MyEnum, ()>> = vec![\n+        Ok(MyEnum::A(17)),\n+        Ok(MyEnum::B { x: 206, y: 1145 }),\n+        Ok(MyEnum::C),\n+        Err(()),\n+        Ok(MyEnum::D(Some(407))),\n+        Ok(MyEnum::D(None)),\n+        Ok(MyEnum::E(Duration::from_secs(100))),\n+        Err(()),\n+    ];\n+\n+    // Binary serialized version of the above (little-endian)\n+    let input: Vec<u8> = vec![\n+        0,  17, 0, 0, 0,\n+        1,  206,  121, 4,\n+        2,\n+        8,  /* invalid tag value */\n+        3,  0,  151, 1, 0, 0,\n+        3,  1,\n+        4,  100, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,\n+        0,  /* incomplete value */\n+    ];\n+\n+    let mut output = vec![];\n+    let mut buf = &input[..];\n+\n+    unsafe {\n+        // This should be safe, because we don't match on it unless it's fully formed,\n+        // and it doesn't have a destructor.\n+        let mut dest: MyEnum = mem::uninitialized();\n+        while buf.len() > 0 {\n+            match parse_my_enum(&mut dest, &mut buf) {\n+                Ok(()) => output.push(Ok(dest)),\n+                Err(()) => output.push(Err(())),\n+            }\n+        }\n+    }\n+\n+    assert_eq!(output, result);\n+}\n+\n+fn parse_my_enum<'a>(dest: &'a mut MyEnum, buf: &mut &[u8]) -> Result<(), ()> {\n+    unsafe {\n+        // Should be correct to do this transmute.\n+        let dest: &'a mut MyEnumRepr = mem::transmute(dest);\n+        let tag = read_u8(buf)?;\n+\n+        dest.tag = match tag {\n+            0 => MyEnumTag::A,\n+            1 => MyEnumTag::B,\n+            2 => MyEnumTag::C,\n+            3 => MyEnumTag::D,\n+            4 => MyEnumTag::E,\n+            _ => return Err(()),\n+        };\n+\n+        match dest.tag {\n+            MyEnumTag::A => {\n+                dest.payload.A.0 = read_u32_le(buf)?;\n+            }\n+            MyEnumTag::B => {\n+                dest.payload.B.x = read_u8(buf)?;\n+                dest.payload.B.y = read_u16_le(buf)? as i16;\n+            }\n+            MyEnumTag::C => {\n+                /* do nothing */\n+            }\n+            MyEnumTag::D => {\n+                let is_some = read_u8(buf)? == 0;\n+                if is_some {\n+                    dest.payload.D.0 = Some(read_u32_le(buf)?);\n+                } else {\n+                    dest.payload.D.0 = None;\n+                }\n+            }\n+            MyEnumTag::E => {\n+                let secs = read_u64_le(buf)?;\n+                let nanos = read_u32_le(buf)?;\n+                dest.payload.E.0 = Duration::new(secs, nanos);\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+\n+\n+// reader helpers\n+\n+fn read_u64_le(buf: &mut &[u8]) -> Result<u64, ()> {\n+    if buf.len() < 8 { return Err(()) }\n+    let val = (buf[0] as u64) << 0\n+            | (buf[1] as u64) << 8\n+            | (buf[2] as u64) << 16\n+            | (buf[3] as u64) << 24\n+            | (buf[4] as u64) << 32\n+            | (buf[5] as u64) << 40\n+            | (buf[6] as u64) << 48\n+            | (buf[7] as u64) << 56;\n+    *buf = &buf[8..];\n+    Ok(val)\n+}\n+\n+fn read_u32_le(buf: &mut &[u8]) -> Result<u32, ()> {\n+    if buf.len() < 4 { return Err(()) }\n+    let val = (buf[0] as u32) << 0\n+            | (buf[1] as u32) << 8\n+            | (buf[2] as u32) << 16\n+            | (buf[3] as u32) << 24;\n+    *buf = &buf[4..];\n+    Ok(val)\n+}\n+\n+fn read_u16_le(buf: &mut &[u8]) -> Result<u16, ()> {\n+    if buf.len() < 2 { return Err(()) }\n+    let val = (buf[0] as u16) << 0\n+            | (buf[1] as u16) << 8;\n+    *buf = &buf[2..];\n+    Ok(val)\n+}\n+\n+fn read_u8(buf: &mut &[u8]) -> Result<u8, ()> {\n+    if buf.len() < 1 { return Err(()) }\n+    let val = buf[0];\n+    *buf = &buf[1..];\n+    Ok(val)\n+}"}, {"sha": "d8eafb806f74765432735847d64814f03c4e89b0", "filename": "src/test/run-pass/multiple-reprs.rs", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/436ac8928aa2e94f621111d6d99901713060b568/src%2Ftest%2Frun-pass%2Fmultiple-reprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/436ac8928aa2e94f621111d6d99901713060b568/src%2Ftest%2Frun-pass%2Fmultiple-reprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultiple-reprs.rs?ref=436ac8928aa2e94f621111d6d99901713060b568", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n \n-use std::mem::size_of;\n+use std::mem::{size_of, align_of};\n+use std::os::raw::c_int;\n \n // The two enums that follow are designed so that bugs trigger layout optimization.\n // Specifically, if either of the following reprs used here is not detected by the compiler,\n@@ -27,6 +28,38 @@ enum E2 {\n     B(u8, u16, u8)\n }\n \n+// Check that repr(int) and repr(C) are in fact different from the above\n+\n+#[repr(u8)]\n+enum E3 {\n+    A(u8, u16, u8),\n+    B(u8, u16, u8)\n+}\n+\n+#[repr(u16)]\n+enum E4 {\n+    A(u8, u16, u8),\n+    B(u8, u16, u8)\n+}\n+\n+#[repr(u32)]\n+enum E5 {\n+    A(u8, u16, u8),\n+    B(u8, u16, u8)\n+}\n+\n+#[repr(u64)]\n+enum E6 {\n+    A(u8, u16, u8),\n+    B(u8, u16, u8)\n+}\n+\n+#[repr(C)]\n+enum E7 {\n+    A(u8, u16, u8),\n+    B(u8, u16, u8)\n+}\n+\n // From pr 37429\n \n #[repr(C,packed)]\n@@ -37,7 +70,20 @@ pub struct p0f_api_query {\n }\n \n pub fn main() {\n-    assert_eq!(size_of::<E1>(), 6);\n-    assert_eq!(size_of::<E2>(), 6);\n+    assert_eq!(size_of::<E1>(), 8);\n+    assert_eq!(size_of::<E2>(), 8);\n+    assert_eq!(size_of::<E3>(), 6);\n+    assert_eq!(size_of::<E4>(), 8);\n+    assert_eq!(size_of::<E5>(), align_size(10, align_of::<u32>()));\n+    assert_eq!(size_of::<E6>(), align_size(14, align_of::<u64>()));\n+    assert_eq!(size_of::<E7>(), align_size(6 + size_of::<c_int>(), align_of::<c_int>()));\n     assert_eq!(size_of::<p0f_api_query>(), 21);\n }\n+\n+fn align_size(size: usize, align: usize) -> usize {\n+    if size % align != 0 {\n+        size + (align - (size % align))\n+    } else {\n+        size\n+    }\n+}"}]}