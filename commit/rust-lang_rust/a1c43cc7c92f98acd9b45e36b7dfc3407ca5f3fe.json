{"sha": "a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYzQzY2M3YzkyZjk4YWNkOWI0NWUzNmI3ZGZjMzQwN2NhNWYzZmU=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-19T22:48:54Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T22:23:23Z"}, "message": "std: dump old std::uv API.. move remaining tests into uv::ll", "tree": {"sha": "aba1a256fe5a28454e930ba86805643a28ed1121", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aba1a256fe5a28454e930ba86805643a28ed1121"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe", "html_url": "https://github.com/rust-lang/rust/commit/a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "791ea3466d01fb1d0f39d342cbeda07ec6629f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/791ea3466d01fb1d0f39d342cbeda07ec6629f2f", "html_url": "https://github.com/rust-lang/rust/commit/791ea3466d01fb1d0f39d342cbeda07ec6629f2f"}], "stats": {"total": 1850, "additions": 610, "deletions": 1240}, "files": [{"sha": "29eb90a1a6801f98a485dafc0badf73bba52cbf8", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 0, "deletions": 1238, "changes": 1238, "blob_url": "https://github.com/rust-lang/rust/blob/a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe", "patch": "@@ -23,11 +23,6 @@ rust-idiomatic abstractions for utilizes libuv's asynchronous IO\n facilities.\n \"];\n \n-import map::hashmap;\n-export loop_new, loop_delete, run, close, run_in_bg;\n-export async_init, async_send;\n-export timer_init, timer_start, timer_stop;\n-\n import ll = uv_ll;\n export ll;\n \n@@ -36,1236 +31,3 @@ export hl;\n \n import global_loop = uv_global_loop;\n export global_loop;\n-\n-#[nolink]\n-native mod rustrt {\n-    fn rust_uv_loop_new() -> *libc::c_void;\n-    fn rust_uv_loop_delete(lp: *libc::c_void);\n-    fn rust_uv_loop_set_data(\n-        lp: *libc::c_void,\n-        data: *uv_loop_data);\n-    fn rust_uv_bind_op_cb(lp: *libc::c_void, cb: *u8)\n-        -> *libc::c_void;\n-    fn rust_uv_stop_op_cb(handle: *libc::c_void);\n-    fn rust_uv_run(loop_handle: *libc::c_void);\n-    fn rust_uv_hilvl_close(handle: *libc::c_void, cb: *u8);\n-    fn rust_uv_hilvl_close_async(handle: *libc::c_void);\n-    fn rust_uv_hilvl_close_timer(handle: *libc::c_void);\n-    fn rust_uv_async_send(handle: *ll::uv_async_t);\n-    fn rust_uv_hilvl_async_init(\n-        loop_handle: *libc::c_void,\n-        cb: *u8,\n-        id: *u8) -> *libc::c_void;\n-    fn rust_uv_hilvl_timer_init(\n-        loop_handle: *libc::c_void,\n-        cb: *u8,\n-        id: *u8) -> *libc::c_void;\n-    fn rust_uv_hilvl_timer_start(\n-        timer_handle: *libc::c_void,\n-        timeout: libc::c_uint,\n-        repeat: libc::c_uint);\n-    fn rust_uv_timer_stop(handle: *ll::uv_timer_t) -> libc::c_int;\n-    fn rust_uv_free(ptr: *libc::c_void);\n-    // sizeof testing helpers\n-    fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_connect_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_buf_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_write_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_async_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_timer_t_size() -> libc::c_uint;\n-}\n-\n-\n-// these are processed solely in the\n-// process_operation() crust fn below\n-enum uv_operation {\n-    op_async_init([u8]),\n-    op_close(uv_handle, *libc::c_void),\n-    op_timer_init([u8]),\n-    op_timer_start([u8], *libc::c_void, u32, u32),\n-    op_timer_stop([u8], *libc::c_void, fn~(uv_handle)),\n-    op_teardown(*libc::c_void)\n-}\n-\n-enum uv_handle {\n-    uv_async([u8], uv_loop),\n-    uv_timer([u8], uv_loop),\n-}\n-\n-enum uv_msg {\n-    // requests from library users\n-    msg_run(comm::chan<bool>),\n-    msg_run_in_bg(),\n-    msg_async_init(fn~(uv_handle), fn~(uv_handle)),\n-    msg_async_send([u8]),\n-    msg_close(uv_handle, fn~()),\n-    msg_timer_init(fn~(uv_handle)),\n-    msg_timer_start([u8], u32, u32, fn~(uv_handle)),\n-    msg_timer_stop([u8], fn~(uv_handle)),\n-\n-    // dispatches from libuv\n-    uv_async_init([u8], *libc::c_void),\n-    uv_async_send([u8]),\n-    uv_close([u8]),\n-    uv_timer_init([u8], *libc::c_void),\n-    uv_timer_call([u8]),\n-    uv_timer_stop([u8], fn~(uv_handle)),\n-    uv_end(),\n-    uv_teardown_check()\n-}\n-\n-type uv_loop_data = {\n-    operation_port: comm::port<uv_operation>,\n-    rust_loop_chan: comm::chan<uv_msg>\n-};\n-\n-enum uv_loop {\n-    uv_loop_new(comm::chan<uv_msg>, *libc::c_void)\n-}\n-\n-// public functions\n-fn loop_new() -> uv_loop unsafe {\n-    let ret_recv_port: comm::port<uv_loop> =\n-        comm::port();\n-    let ret_recv_chan: comm::chan<uv_loop> =\n-        comm::chan(ret_recv_port);\n-\n-    task::spawn_sched(task::manual_threads(1u)) {||\n-        // our beloved uv_loop_t ptr\n-        let loop_handle = rustrt::\n-            rust_uv_loop_new();\n-\n-        // this port/chan pair are used to send messages to\n-        // libuv. libuv processes any pending messages on the\n-        // port (via crust) after receiving an async \"wakeup\"\n-        // on a special uv_async_t handle created below\n-        let operation_port = comm::port::<uv_operation>();\n-        let operation_chan = comm::chan::<uv_operation>(\n-            operation_port);\n-\n-        // this port/chan pair as used in the while() loop\n-        // below. It takes dispatches, originating from libuv\n-        // callbacks, to invoke handles registered by the\n-        // user\n-        let rust_loop_port = comm::port::<uv_msg>();\n-        let rust_loop_chan =\n-            comm::chan::<uv_msg>(rust_loop_port);\n-        // let the task-spawner return\n-        let user_uv_loop = uv_loop_new(rust_loop_chan, loop_handle);\n-        comm::send(ret_recv_chan, copy(user_uv_loop));\n-\n-        // create our \"special\" async handle that will\n-        // allow all operations against libuv to be\n-        // \"buffered\" in the operation_port, for processing\n-        // from the thread that libuv runs on\n-        let loop_data: uv_loop_data = {\n-            operation_port: operation_port,\n-            rust_loop_chan: rust_loop_chan\n-        };\n-        rustrt::rust_uv_loop_set_data(\n-            loop_handle,\n-            ptr::addr_of(loop_data)); // pass an opaque C-ptr\n-                                      // to libuv, this will be\n-                                      // in the process_operation\n-                                      // crust fn\n-        let op_handle = rustrt::rust_uv_bind_op_cb(\n-            loop_handle,\n-            process_operation);\n-\n-        // all state goes here\n-        let handles: map::hashmap<[u8], *libc::c_void> =\n-            map::bytes_hash();\n-        let id_to_handle: map::hashmap<[u8], uv_handle> =\n-            map::bytes_hash();\n-        let after_cbs: map::hashmap<[u8], fn~(uv_handle)> =\n-            map::bytes_hash();\n-        let close_callbacks: map::hashmap<[u8], fn~()> =\n-            map::bytes_hash();\n-        let async_cbs: map::hashmap<[u8], fn~(uv_handle)> =\n-            map::bytes_hash();\n-        let timer_cbs: map::hashmap<[u8], fn~(uv_handle)> =\n-            map::bytes_hash();\n-\n-        // the main loop that this task blocks on.\n-        // should have the same lifetime as the C libuv\n-        // event loop.\n-        let mut keep_going = true;\n-        while keep_going {\n-            alt comm::recv(rust_loop_port) {\n-              msg_run(end_chan) {\n-                // start the libuv event loop\n-                // we'll also do a uv_async_send with\n-                // the operation handle to have the\n-                // loop process any pending operations\n-                // once its up and running\n-                task::spawn_sched(task::manual_threads(1u)) {||\n-                    // make sure we didn't start the loop\n-                    // without the user registering handles\n-                    comm::send(rust_loop_chan, uv_teardown_check);\n-                    // this call blocks\n-                    rustrt::rust_uv_run(loop_handle);\n-                    // when we're done, msg the\n-                    // end chan\n-                    comm::send(end_chan, true);\n-                    comm::send(rust_loop_chan, uv_end);\n-                };\n-              }\n-\n-              msg_run_in_bg {\n-                task::spawn_sched(task::manual_threads(1u)) {||\n-                    // see note above\n-                    comm::send(rust_loop_chan, uv_teardown_check);\n-                    // this call blocks\n-                    rustrt::rust_uv_run(loop_handle);\n-                };\n-              }\n-\n-              msg_close(handle, cb) {\n-                let id = get_id_from_handle(handle);\n-                close_callbacks.insert(id, cb);\n-                let handle_ptr = handles.get(id);\n-                let op = op_close(handle, handle_ptr);\n-\n-                pass_to_libuv(op_handle, operation_chan, op);\n-              }\n-              uv_close(id) {\n-                handles.remove(id);\n-                let handle = id_to_handle.get(id);\n-                id_to_handle.remove(id);\n-                alt handle {\n-                  uv_async(id, _) {\n-                    async_cbs.remove(id);\n-                  }\n-                  uv_timer(id, _) {\n-                    timer_cbs.remove(id);\n-                  }\n-                  _ {\n-                    fail \"unknown form of uv_handle encountered \"\n-                        + \"in uv_close handler\";\n-                  }\n-                }\n-                let cb = close_callbacks.get(id);\n-                close_callbacks.remove(id);\n-                task::spawn {||\n-                    cb();\n-                };\n-                // ask the rust loop to check and see if there\n-                // are no more user-registered handles\n-                comm::send(rust_loop_chan, uv_teardown_check);\n-              }\n-\n-              msg_async_init(callback, after_cb) {\n-                // create a new async handle\n-                // with the id as the handle's\n-                // data and save the callback for\n-                // invocation on msg_async_send\n-                let id = gen_handle_id();\n-                handles.insert(id, ptr::null());\n-                async_cbs.insert(id, callback);\n-                after_cbs.insert(id, after_cb);\n-                let op = op_async_init(id);\n-                pass_to_libuv(op_handle, operation_chan, op);\n-              }\n-              uv_async_init(id, async_handle) {\n-                // libuv created a handle, which is\n-                // passed back to us. save it and\n-                // then invoke the supplied callback\n-                // for after completion\n-                handles.insert(id, async_handle);\n-                let after_cb = after_cbs.get(id);\n-                after_cbs.remove(id);\n-                let async = uv_async(id, user_uv_loop);\n-                id_to_handle.insert(id, copy(async));\n-                task::spawn {||\n-                    after_cb(async);\n-                };\n-              }\n-\n-              msg_async_send(id) {\n-                let async_handle = handles.get(id);\n-                do_send(async_handle);\n-              }\n-              uv_async_send(id) {\n-                let async_cb = async_cbs.get(id);\n-                task::spawn {||\n-                    let the_loop = user_uv_loop;\n-                    async_cb(uv_async(id, the_loop));\n-                };\n-              }\n-\n-              msg_timer_init(after_cb) {\n-                let id = gen_handle_id();\n-                handles.insert(id, ptr::null());\n-                after_cbs.insert(id, after_cb);\n-                let op = op_timer_init(id);\n-                pass_to_libuv(op_handle, operation_chan, op);\n-              }\n-              uv_timer_init(id, handle) {\n-                handles.insert(id, handle);\n-                let after_cb = after_cbs.get(id);\n-                after_cbs.remove(id);\n-                let new_timer = uv_timer(id, user_uv_loop);\n-                id_to_handle.insert(id, copy(new_timer));\n-                task::spawn {||\n-                    after_cb(new_timer);\n-                };\n-              }\n-\n-              uv_timer_call(id) {\n-                let cb = timer_cbs.get(id);\n-                let the_timer = id_to_handle.get(id);\n-                task::spawn {||\n-                    cb(the_timer);\n-                };\n-              }\n-\n-              msg_timer_start(id, timeout, repeat, timer_call_cb) {\n-                timer_cbs.insert(id, timer_call_cb);\n-                let handle = handles.get(id);\n-                let op = op_timer_start(id, handle, timeout,\n-                                        repeat);\n-                pass_to_libuv(op_handle, operation_chan, op);\n-              }\n-\n-              msg_timer_stop(id, after_cb) {\n-                let handle = handles.get(id);\n-                let op = op_timer_stop(id, handle, after_cb);\n-                pass_to_libuv(op_handle, operation_chan, op);\n-              }\n-              uv_timer_stop(id, after_cb) {\n-                let the_timer = id_to_handle.get(id);\n-                after_cb(the_timer);\n-              }\n-\n-              uv_teardown_check() {\n-                // here we're checking if there are no user-registered\n-                // handles (and the loop is running), if this is the\n-                // case, then we need to unregister the op_handle via\n-                // a uv_close() call, thus allowing libuv to return\n-                // on its own.\n-                if (handles.size() == 0u) {\n-                    let op = op_teardown(op_handle);\n-                    pass_to_libuv(op_handle, operation_chan, op);\n-                }\n-              }\n-\n-              uv_end() {\n-                keep_going = false;\n-              }\n-\n-              _ { fail \"unknown form of uv_msg received\"; }\n-            }\n-        }\n-    };\n-    ret comm::recv(ret_recv_port);\n-}\n-\n-fn loop_delete(lp: uv_loop) {\n-    let loop_ptr = get_loop_ptr_from_uv_loop(lp);\n-    rustrt::rust_uv_loop_delete(loop_ptr);\n-}\n-\n-fn run(lp: uv_loop) {\n-    let end_port = comm::port::<bool>();\n-    let end_chan = comm::chan::<bool>(end_port);\n-    let loop_chan = get_loop_chan_from_uv_loop(lp);\n-    comm::send(loop_chan, msg_run(end_chan));\n-    comm::recv(end_port);\n-}\n-\n-fn run_in_bg(lp: uv_loop) {\n-    let loop_chan = get_loop_chan_from_uv_loop(lp);\n-    comm::send(loop_chan, msg_run_in_bg);\n-}\n-\n-fn async_init (\n-    lp: uv_loop,\n-    async_cb: fn~(uv_handle),\n-    after_cb: fn~(uv_handle)) {\n-    let msg = msg_async_init(async_cb, after_cb);\n-    let loop_chan = get_loop_chan_from_uv_loop(lp);\n-    comm::send(loop_chan, msg);\n-}\n-\n-fn async_send(async: uv_handle) {\n-    alt async {\n-      uv_async(id, lp) {\n-        let loop_chan = get_loop_chan_from_uv_loop(lp);\n-        comm::send(loop_chan, msg_async_send(id));\n-      }\n-      _ {\n-        fail \"attempting to call async_send() with a\" +\n-            \" uv_async uv_handle\";\n-      }\n-    }\n-}\n-\n-fn close(h: uv_handle, cb: fn~()) {\n-    let loop_chan = get_loop_chan_from_handle(h);\n-    comm::send(loop_chan, msg_close(h, cb));\n-}\n-\n-fn timer_init(lp: uv_loop, after_cb: fn~(uv_handle)) {\n-    let msg = msg_timer_init(after_cb);\n-    let loop_chan = get_loop_chan_from_uv_loop(lp);\n-    comm::send(loop_chan, msg);\n-}\n-\n-fn timer_start(the_timer: uv_handle, timeout: u32, repeat:u32,\n-               timer_cb: fn~(uv_handle)) {\n-    alt the_timer {\n-      uv_timer(id, lp) {\n-        let msg = msg_timer_start(id, timeout, repeat, timer_cb);\n-        let loop_chan = get_loop_chan_from_uv_loop(lp);\n-        comm::send(loop_chan, msg);\n-      }\n-      _ {\n-        fail \"can only pass a uv_timer form of uv_handle to \"+\n-             \" uv::timer_start()\";\n-      }\n-    }\n-}\n-\n-fn timer_stop(the_timer: uv_handle, after_cb: fn~(uv_handle)) {\n-    alt the_timer {\n-      uv_timer(id, lp) {\n-        let loop_chan = get_loop_chan_from_uv_loop(lp);\n-        let msg = msg_timer_stop(id, after_cb);\n-        comm::send(loop_chan, msg);\n-      }\n-      _ {\n-        fail \"only uv_timer form is allowed in calls to \"+\n-             \" uv::timer_stop()\";\n-      }\n-    }\n-}\n-\n-// internal functions\n-fn pass_to_libuv(\n-        op_handle: *libc::c_void,\n-        operation_chan: comm::chan<uv_operation>,\n-        op: uv_operation) unsafe {\n-    comm::send(operation_chan, copy(op));\n-    do_send(op_handle);\n-}\n-fn do_send(h: *libc::c_void) {\n-    rustrt::rust_uv_async_send(h as *ll::uv_async_t);\n-}\n-fn gen_handle_id() -> [u8] {\n-    ret rand::rng().gen_bytes(16u);\n-}\n-fn get_handle_id_from(buf: *u8) -> [u8] unsafe {\n-    ret vec::unsafe::from_buf(buf, 16u);\n-}\n-\n-fn get_loop_chan_from_data(data: *uv_loop_data)\n-        -> comm::chan<uv_msg> unsafe {\n-    ret (*data).rust_loop_chan;\n-}\n-\n-fn get_loop_chan_from_handle(handle: uv_handle)\n-    -> comm::chan<uv_msg> {\n-    alt handle {\n-      uv_async(id,lp) | uv_timer(id,lp) {\n-        let loop_chan = get_loop_chan_from_uv_loop(lp);\n-        ret loop_chan;\n-      }\n-      _ {\n-        fail \"unknown form of uv_handle for get_loop_chan_from \"\n-             + \" handle\";\n-      }\n-    }\n-}\n-\n-fn get_loop_ptr_from_uv_loop(lp: uv_loop) -> *libc::c_void {\n-    alt lp {\n-      uv_loop_new(loop_chan, loop_ptr) {\n-        ret loop_ptr;\n-      }\n-    }\n-}\n-fn get_loop_chan_from_uv_loop(lp: uv_loop) -> comm::chan<uv_msg> {\n-    alt lp {\n-      uv_loop_new(loop_chan, loop_ptr) {\n-        ret loop_chan;\n-      }\n-    }\n-}\n-\n-fn get_id_from_handle(handle: uv_handle) -> [u8] {\n-    alt handle {\n-      uv_async(id,lp) | uv_timer(id,lp) {\n-        ret id;\n-      }\n-      _ {\n-        fail \"unknown form of uv_handle for get_id_from handle\";\n-      }\n-    }\n-}\n-\n-// crust\n-crust fn process_operation(\n-        lp: *libc::c_void,\n-        data: *uv_loop_data) unsafe {\n-    let op_port = (*data).operation_port;\n-    let loop_chan = get_loop_chan_from_data(data);\n-    let mut op_pending = comm::peek(op_port);\n-    while(op_pending) {\n-        alt comm::recv(op_port) {\n-          op_async_init(id) {\n-            let id_ptr = vec::unsafe::to_ptr(id);\n-            let async_handle = rustrt::rust_uv_hilvl_async_init(\n-                lp,\n-                process_async_send,\n-                id_ptr);\n-            comm::send(loop_chan, uv_async_init(\n-                id,\n-                async_handle));\n-          }\n-          op_close(handle, handle_ptr) {\n-            handle_op_close(handle, handle_ptr);\n-          }\n-          op_timer_init(id) {\n-            let id_ptr = vec::unsafe::to_ptr(id);\n-            let timer_handle = rustrt::rust_uv_hilvl_timer_init(\n-                lp,\n-                process_timer_call,\n-                id_ptr);\n-            comm::send(loop_chan, uv_timer_init(\n-                id,\n-                timer_handle));\n-          }\n-          op_timer_start(id, handle, timeout, repeat) {\n-            rustrt::rust_uv_hilvl_timer_start(handle, timeout,\n-                                              repeat);\n-          }\n-          op_timer_stop(id, handle, after_cb) {\n-            rustrt::rust_uv_timer_stop(handle as *ll::uv_timer_t);\n-            comm::send(loop_chan, uv_timer_stop(id, after_cb));\n-          }\n-          op_teardown(op_handle) {\n-            // this is the last msg that'll be processed by\n-            // this fn, in the current lifetime of the handle's\n-            // uv_loop_t\n-            rustrt::rust_uv_stop_op_cb(op_handle);\n-          }\n-          _ { fail \"unknown form of uv_operation received\"; }\n-        }\n-        op_pending = comm::peek(op_port);\n-    }\n-}\n-\n-fn handle_op_close(handle: uv_handle, handle_ptr: *libc::c_void) {\n-    // it's just like im doing C\n-    alt handle {\n-      uv_async(id, lp) {\n-        let cb = process_close_async;\n-        rustrt::rust_uv_hilvl_close(\n-            handle_ptr, cb);\n-      }\n-      uv_timer(id, lp) {\n-        let cb = process_close_timer;\n-        rustrt::rust_uv_hilvl_close(\n-            handle_ptr, cb);\n-      }\n-      _ {\n-        fail \"unknown form of uv_handle encountered \" +\n-            \"in process_operation/op_close\";\n-      }\n-    }\n-}\n-\n-crust fn process_async_send(id_buf: *u8, data: *uv_loop_data)\n-    unsafe {\n-    let handle_id = get_handle_id_from(id_buf);\n-    let loop_chan = get_loop_chan_from_data(data);\n-    comm::send(loop_chan, uv_async_send(handle_id));\n-}\n-\n-crust fn process_timer_call(id_buf: *u8, data: *uv_loop_data)\n-    unsafe {\n-    let handle_id = get_handle_id_from(id_buf);\n-    let loop_chan = get_loop_chan_from_data(data);\n-    comm::send(loop_chan, uv_timer_call(handle_id));\n-}\n-\n-fn process_close_common(id: [u8], data: *uv_loop_data)\n-    unsafe {\n-    // notify the rust loop that their handle is closed, then\n-    // the caller will invoke a per-handle-type c++ func to\n-    // free allocated memory\n-    let loop_chan = get_loop_chan_from_data(data);\n-    comm::send(loop_chan, uv_close(id));\n-}\n-\n-crust fn process_close_async(\n-    id_buf: *u8,\n-    handle_ptr: *libc::c_void,\n-    data: *uv_loop_data)\n-    unsafe {\n-    let id = get_handle_id_from(id_buf);\n-    rustrt::rust_uv_hilvl_close_async(handle_ptr);\n-    // at this point, the handle and its data has been\n-    // released. notify the rust loop to remove the\n-    // handle and its data and call the user-supplied\n-    // close cb\n-    process_close_common(id, data);\n-}\n-\n-crust fn process_close_timer(\n-    id_buf: *u8,\n-    handle_ptr: *libc::c_void,\n-    data: *uv_loop_data)\n-    unsafe {\n-    let id = get_handle_id_from(id_buf);\n-    rustrt::rust_uv_hilvl_close_timer(handle_ptr);\n-    process_close_common(id, data);\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    #[test]\n-    fn test_uv_new_loop_no_handles() {\n-        let test_loop = uv::loop_new();\n-        uv::run(test_loop); // this should return immediately\n-                        // since there aren't any handles..\n-        uv::loop_delete(test_loop);\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(target_os = \"freebsd\"))]\n-    fn test_uv_simple_async() {\n-        let test_loop = uv::loop_new();\n-        let exit_port = comm::port::<bool>();\n-        let exit_chan = comm::chan::<bool>(exit_port);\n-        uv::async_init(test_loop, {|new_async|\n-            uv::close(new_async) {||\n-                comm::send(exit_chan, true);\n-            };\n-        }, {|new_async|\n-            uv::async_send(new_async);\n-        });\n-        uv::run(test_loop);\n-        let result = comm::recv(exit_port);\n-        assert result;\n-        uv::loop_delete(test_loop);\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(target_os = \"freebsd\"))]\n-    fn test_uv_timer() {\n-        let test_loop = uv::loop_new();\n-        let exit_port = comm::port::<bool>();\n-        let exit_chan = comm::chan::<bool>(exit_port);\n-        uv::timer_init(test_loop) {|new_timer|\n-            uv::timer_start(new_timer, 1u32, 0u32) {|started_timer|\n-                uv::timer_stop(started_timer) {|stopped_timer|\n-                    uv::close(stopped_timer) {||\n-                        comm::send(exit_chan, true);\n-                    };\n-                };\n-            };\n-        };\n-        uv::run(test_loop);\n-        assert comm::recv(exit_port);\n-        uv::loop_delete(test_loop);\n-    }\n-\n-    enum tcp_read_data {\n-        tcp_read_eof,\n-        tcp_read_more([u8]),\n-        tcp_read_error\n-    }\n-\n-    type request_wrapper = {\n-        write_req: *ll::uv_write_t,\n-        req_buf: *[ll::uv_buf_t],\n-        read_chan: *comm::chan<str>\n-    };\n-\n-    crust fn after_close_cb(handle: *libc::c_void) {\n-        log(debug, #fmt(\"after uv_close! handle ptr: %?\",\n-                        handle));\n-    }\n-\n-    crust fn on_alloc_cb(handle: *libc::c_void,\n-                         ++suggested_size: libc::size_t)\n-        -> ll::uv_buf_t unsafe {\n-        log(debug, \"on_alloc_cb!\");\n-        let char_ptr = ll::malloc_buf_base_of(suggested_size);\n-        log(debug, #fmt(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n-                         handle,\n-                         char_ptr as uint,\n-                         suggested_size as uint));\n-        ret ll::buf_init(char_ptr, suggested_size);\n-    }\n-\n-    crust fn on_read_cb(stream: *ll::uv_stream_t,\n-                        nread: libc::ssize_t,\n-                        ++buf: ll::uv_buf_t) unsafe {\n-        log(debug, #fmt(\"CLIENT entering on_read_cb nred: %d\", nread));\n-        if (nread > 0) {\n-            // we have data\n-            log(debug, #fmt(\"CLIENT read: data! nread: %d\", nread));\n-            ll::read_stop(stream);\n-            let client_data = ll::\n-                get_data_for_uv_handle(stream as *libc::c_void)\n-                  as *request_wrapper;\n-            let buf_base = ll::get_base_from_buf(buf);\n-            let buf_len = ll::get_len_from_buf(buf);\n-            let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n-            let read_chan = *((*client_data).read_chan);\n-            let msg_from_server = str::from_bytes(bytes);\n-            comm::send(read_chan, msg_from_server);\n-            ll::close(stream as *libc::c_void, after_close_cb)\n-        }\n-        else if (nread == -1) {\n-            // err .. possibly EOF\n-            log(debug, \"read: eof!\");\n-        }\n-        else {\n-            // nread == 0 .. do nothing, just free buf as below\n-            log(debug, \"read: do nothing!\");\n-        }\n-        // when we're done\n-        ll::free_base_of_buf(buf);\n-        log(debug, \"CLIENT exiting on_read_cb\");\n-    }\n-\n-    crust fn on_write_complete_cb(write_req: *ll::uv_write_t,\n-                                  status: libc::c_int) unsafe {\n-        log(debug, #fmt(\"CLIENT beginning on_write_complete_cb status: %d\",\n-                         status as int));\n-        let stream = ll::get_stream_handle_from_write_req(write_req);\n-        log(debug, #fmt(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n-            stream as int, write_req as int));\n-        let result = ll::read_start(stream, on_alloc_cb, on_read_cb);\n-        log(debug, #fmt(\"CLIENT ending on_write_complete_cb .. status: %d\",\n-                         result as int));\n-    }\n-\n-    crust fn on_connect_cb(connect_req_ptr: *ll::uv_connect_t,\n-                                 status: libc::c_int) unsafe {\n-        log(debug, #fmt(\"beginning on_connect_cb .. status: %d\",\n-                         status as int));\n-        let stream =\n-            ll::get_stream_handle_from_connect_req(connect_req_ptr);\n-        if (status == 0i32) {\n-            log(debug, \"on_connect_cb: in status=0 if..\");\n-            let client_data = ll::get_data_for_req(\n-                connect_req_ptr as *libc::c_void)\n-                as *request_wrapper;\n-            let write_handle = (*client_data).write_req as *libc::c_void;\n-            log(debug, #fmt(\"on_connect_cb: tcp: %d write_hdl: %d\",\n-                            stream as int, write_handle as int));\n-            let write_result = ll::write(write_handle,\n-                              stream as *libc::c_void,\n-                              (*client_data).req_buf,\n-                              on_write_complete_cb);\n-            log(debug, #fmt(\"on_connect_cb: ll::write() status: %d\",\n-                             write_result as int));\n-        }\n-        else {\n-            let test_loop = ll::get_loop_for_uv_handle(\n-                stream as *libc::c_void);\n-            let err_msg = ll::get_last_err_info(test_loop);\n-            log(debug, err_msg);\n-            assert false;\n-        }\n-        log(debug, \"finishing on_connect_cb\");\n-    }\n-\n-    fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n-                          client_chan: *comm::chan<str>) unsafe {\n-        let test_loop = ll::loop_new();\n-        let tcp_handle = ll::tcp_t();\n-        let tcp_handle_ptr = ptr::addr_of(tcp_handle);\n-        let connect_handle = ll::connect_t();\n-        let connect_req_ptr = ptr::addr_of(connect_handle);\n-\n-        // this is the persistent payload of data that we\n-        // need to pass around to get this example to work.\n-        // In C, this would be a malloc'd or stack-allocated\n-        // struct that we'd cast to a void* and store as the\n-        // data field in our uv_connect_t struct\n-        let req_str_bytes = str::bytes(req_str);\n-        let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str_bytes);\n-        log(debug, #fmt(\"req_msg ptr: %u\", req_msg_ptr as uint));\n-        let req_msg = [\n-            ll::buf_init(req_msg_ptr, vec::len(req_str_bytes))\n-        ];\n-        // this is the enclosing record, we'll pass a ptr to\n-        // this to C..\n-        let write_handle = ll::write_t();\n-        let write_handle_ptr = ptr::addr_of(write_handle);\n-        log(debug, #fmt(\"tcp req: tcp stream: %d write_handle: %d\",\n-                         tcp_handle_ptr as int,\n-                         write_handle_ptr as int));\n-        let client_data = { writer_handle: write_handle_ptr,\n-                    req_buf: ptr::addr_of(req_msg),\n-                    read_chan: client_chan };\n-\n-        let tcp_init_result = ll::tcp_init(\n-            test_loop as *libc::c_void, tcp_handle_ptr);\n-        if (tcp_init_result == 0i32) {\n-            log(debug, \"sucessful tcp_init_result\");\n-\n-            log(debug, \"building addr...\");\n-            let addr = ll::ip4_addr(ip, port);\n-            // FIXME ref #2064\n-            let addr_ptr = ptr::addr_of(addr);\n-            log(debug, #fmt(\"after build addr in rust. port: %u\",\n-                             addr.sin_port as uint));\n-\n-            // this should set up the connection request..\n-            log(debug, #fmt(\"b4 call tcp_connect connect cb: %u \",\n-                            on_connect_cb as uint));\n-            let tcp_connect_result = ll::tcp_connect(\n-                connect_req_ptr, tcp_handle_ptr,\n-                addr_ptr, on_connect_cb);\n-            if (tcp_connect_result == 0i32) {\n-                // not set the data on the connect_req\n-                // until its initialized\n-                ll::set_data_for_req(\n-                    connect_req_ptr as *libc::c_void,\n-                    ptr::addr_of(client_data) as *libc::c_void);\n-                ll::set_data_for_uv_handle(\n-                    tcp_handle_ptr as *libc::c_void,\n-                    ptr::addr_of(client_data) as *libc::c_void);\n-                log(debug, \"before run tcp req loop\");\n-                ll::run(test_loop);\n-                log(debug, \"after run tcp req loop\");\n-            }\n-            else {\n-               log(debug, \"ll::tcp_connect() failure\");\n-               assert false;\n-            }\n-        }\n-        else {\n-            log(debug, \"ll::tcp_init() failure\");\n-            assert false;\n-        }\n-        ll::loop_delete(test_loop);\n-\n-    }\n-\n-    crust fn server_after_close_cb(handle: *libc::c_void) unsafe {\n-        log(debug, #fmt(\"SERVER server stream closed, should exit.. h: %?\",\n-                   handle));\n-    }\n-\n-    crust fn client_stream_after_close_cb(handle: *libc::c_void)\n-        unsafe {\n-        log(debug, \"SERVER: closed client stream, now closing server stream\");\n-        let client_data = ll::get_data_for_uv_handle(\n-            handle) as\n-            *tcp_server_data;\n-        ll::close((*client_data).server as *libc::c_void,\n-                      server_after_close_cb);\n-    }\n-\n-    crust fn after_server_resp_write(req: *ll::uv_write_t) unsafe {\n-        let client_stream_ptr =\n-            ll::get_stream_handle_from_write_req(req);\n-        log(debug, \"SERVER: resp sent... closing client stream\");\n-        ll::close(client_stream_ptr as *libc::c_void,\n-                      client_stream_after_close_cb)\n-    }\n-\n-    crust fn on_server_read_cb(client_stream_ptr: *ll::uv_stream_t,\n-                               nread: libc::ssize_t,\n-                               ++buf: ll::uv_buf_t) unsafe {\n-        if (nread > 0) {\n-            // we have data\n-            log(debug, #fmt(\"SERVER read: data! nread: %d\", nread));\n-\n-            // pull out the contents of the write from the client\n-            let buf_base = ll::get_base_from_buf(buf);\n-            let buf_len = ll::get_len_from_buf(buf);\n-            log(debug, #fmt(\"SERVER buf base: %u, len: %u, nread: %d\",\n-                             buf_base as uint,\n-                             buf_len as uint,\n-                             nread));\n-            let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n-            let request_str = str::from_bytes(bytes);\n-\n-            let client_data = ll::get_data_for_uv_handle(\n-                client_stream_ptr as *libc::c_void) as *tcp_server_data;\n-\n-            let server_kill_msg = (*client_data).server_kill_msg;\n-            let write_req = (*client_data).server_write_req;\n-            if (str::contains(request_str, server_kill_msg)) {\n-                log(debug, \"SERVER: client req contains kill_msg!\");\n-                log(debug, \"SERVER: sending response to client\");\n-                ll::read_stop(client_stream_ptr);\n-                let server_chan = *((*client_data).server_chan);\n-                comm::send(server_chan, request_str);\n-                let write_result = ll::write(\n-                    write_req as *libc::c_void,\n-                    client_stream_ptr as *libc::c_void,\n-                    (*client_data).server_resp_buf,\n-                    after_server_resp_write);\n-                log(debug, #fmt(\"SERVER: resp write result: %d\",\n-                            write_result as int));\n-                if (write_result != 0i32) {\n-                    log(debug, \"bad result for server resp ll::write()\");\n-                    log(debug, ll::get_last_err_info(\n-                        ll::get_loop_for_uv_handle(client_stream_ptr\n-                            as *libc::c_void)));\n-                    assert false;\n-                }\n-            }\n-            else {\n-                log(debug, \"SERVER: client req !contain kill_msg!\");\n-            }\n-        }\n-        else if (nread == -1) {\n-            // err .. possibly EOF\n-            log(debug, \"read: eof!\");\n-        }\n-        else {\n-            // nread == 0 .. do nothing, just free buf as below\n-            log(debug, \"read: do nothing!\");\n-        }\n-        // when we're done\n-        ll::free_base_of_buf(buf);\n-        log(debug, \"SERVER exiting on_read_cb\");\n-    }\n-\n-    crust fn server_connection_cb(server_stream_ptr:\n-                                    *ll::uv_stream_t,\n-                                  status: libc::c_int) unsafe {\n-        log(debug, \"client connecting!\");\n-        let test_loop = ll::get_loop_for_uv_handle(\n-                               server_stream_ptr as *libc::c_void);\n-        if status != 0i32 {\n-            let err_msg = ll::get_last_err_info(test_loop);\n-            log(debug, #fmt(\"server_connect_cb: non-zero status: %?\",\n-                         err_msg));\n-            ret;\n-        }\n-        let server_data = ll::get_data_for_uv_handle(\n-            server_stream_ptr as *libc::c_void) as *tcp_server_data;\n-        let client_stream_ptr = (*server_data).client;\n-        let client_init_result = ll::tcp_init(test_loop,\n-                                                  client_stream_ptr);\n-        ll::set_data_for_uv_handle(\n-            client_stream_ptr as *libc::c_void,\n-            server_data as *libc::c_void);\n-        if (client_init_result == 0i32) {\n-            log(debug, \"successfully initialized client stream\");\n-            let accept_result = ll::accept(server_stream_ptr as\n-                                                 *libc::c_void,\n-                                               client_stream_ptr as\n-                                                 *libc::c_void);\n-            if (accept_result == 0i32) {\n-                // start reading\n-                let read_result = ll::read_start(\n-                    client_stream_ptr as *ll::uv_stream_t,\n-                                                     on_alloc_cb,\n-                                                     on_server_read_cb);\n-                if (read_result == 0i32) {\n-                    log(debug, \"successful server read start\");\n-                }\n-                else {\n-                    log(debug, #fmt(\"server_connection_cb: bad read:%d\",\n-                                    read_result as int));\n-                    assert false;\n-                }\n-            }\n-            else {\n-                log(debug, #fmt(\"server_connection_cb: bad accept: %d\",\n-                            accept_result as int));\n-                assert false;\n-            }\n-        }\n-        else {\n-            log(debug, #fmt(\"server_connection_cb: bad client init: %d\",\n-                        client_init_result as int));\n-            assert false;\n-        }\n-    }\n-\n-    type tcp_server_data = {\n-        client: *ll::uv_tcp_t,\n-        server: *ll::uv_tcp_t,\n-        server_kill_msg: str,\n-        server_resp_buf: *[ll::uv_buf_t],\n-        server_chan: *comm::chan<str>,\n-        server_write_req: *ll::uv_write_t\n-    };\n-\n-    type async_handle_data = {\n-        continue_chan: *comm::chan<bool>\n-    };\n-\n-    crust fn async_close_cb(handle: *libc::c_void) {\n-        log(debug, #fmt(\"SERVER: closing async cb... h: %?\",\n-                   handle));\n-    }\n-\n-    crust fn continue_async_cb(async_handle: *ll::uv_async_t,\n-                               status: libc::c_int) unsafe {\n-        // once we're in the body of this callback,\n-        // the tcp server's loop is set up, so we\n-        // can continue on to let the tcp client\n-        // do its thang\n-        let data = ll::get_data_for_uv_handle(\n-            async_handle as *libc::c_void) as *async_handle_data;\n-        let continue_chan = *((*data).continue_chan);\n-        let should_continue = status == 0i32;\n-        comm::send(continue_chan, should_continue);\n-        ll::close(async_handle as *libc::c_void, async_close_cb);\n-    }\n-\n-    fn impl_uv_tcp_server(server_ip: str,\n-                          server_port: int,\n-                          kill_server_msg: str,\n-                          server_resp_msg: str,\n-                          server_chan: *comm::chan<str>,\n-                          continue_chan: *comm::chan<bool>) unsafe {\n-        let test_loop = ll::loop_new();\n-        let tcp_server = ll::tcp_t();\n-        let tcp_server_ptr = ptr::addr_of(tcp_server);\n-\n-        let tcp_client = ll::tcp_t();\n-        let tcp_client_ptr = ptr::addr_of(tcp_client);\n-\n-        let server_write_req = ll::write_t();\n-        let server_write_req_ptr = ptr::addr_of(server_write_req);\n-\n-        let resp_str_bytes = str::bytes(server_resp_msg);\n-        let resp_msg_ptr: *u8 = vec::unsafe::to_ptr(resp_str_bytes);\n-        log(debug, #fmt(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n-        let resp_msg = [\n-            ll::buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n-        ];\n-\n-        let continue_async_handle = ll::async_t();\n-        let continue_async_handle_ptr =\n-            ptr::addr_of(continue_async_handle);\n-        let async_data =\n-            { continue_chan: continue_chan };\n-        let async_data_ptr = ptr::addr_of(async_data);\n-\n-        let server_data: tcp_server_data = {\n-            client: tcp_client_ptr,\n-            server: tcp_server_ptr,\n-            server_kill_msg: kill_server_msg,\n-            server_resp_buf: ptr::addr_of(resp_msg),\n-            server_chan: server_chan,\n-            server_write_req: server_write_req_ptr\n-        };\n-        let server_data_ptr = ptr::addr_of(server_data);\n-        ll::set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n-                                       server_data_ptr as *libc::c_void);\n-\n-        // uv_tcp_init()\n-        let tcp_init_result = ll::tcp_init(\n-            test_loop as *libc::c_void, tcp_server_ptr);\n-        if (tcp_init_result == 0i32) {\n-            let server_addr = ll::ip4_addr(server_ip, server_port);\n-            // FIXME ref #2064\n-            let server_addr_ptr = ptr::addr_of(server_addr);\n-\n-            // uv_tcp_bind()\n-            let bind_result = ll::tcp_bind(tcp_server_ptr,\n-                                               server_addr_ptr);\n-            if (bind_result == 0i32) {\n-                log(debug, \"successful uv_tcp_bind, listening\");\n-\n-                // uv_listen()\n-                let listen_result = ll::listen(tcp_server_ptr as\n-                                                     *libc::c_void,\n-                                                   128i32,\n-                                                   server_connection_cb);\n-                if (listen_result == 0i32) {\n-                    // let the test know it can set up the tcp server,\n-                    // now.. this may still present a race, not sure..\n-                    let async_result = ll::async_init(test_loop,\n-                                       continue_async_handle_ptr,\n-                                       continue_async_cb);\n-                    if (async_result == 0i32) {\n-                        ll::set_data_for_uv_handle(\n-                            continue_async_handle_ptr as *libc::c_void,\n-                            async_data_ptr as *libc::c_void);\n-                        ll::async_send(continue_async_handle_ptr);\n-                        // uv_run()\n-                        ll::run(test_loop);\n-                        log(debug, \"server uv::run() has returned\");\n-                    }\n-                    else {\n-                        log(debug, #fmt(\"uv_async_init failure: %d\",\n-                                async_result as int));\n-                        assert false;\n-                    }\n-                }\n-                else {\n-                    log(debug, #fmt(\"non-zero result on uv_listen: %d\",\n-                                listen_result as int));\n-                    assert false;\n-                }\n-            }\n-            else {\n-                log(debug, #fmt(\"non-zero result on uv_tcp_bind: %d\",\n-                            bind_result as int));\n-                assert false;\n-            }\n-        }\n-        else {\n-            log(debug, #fmt(\"non-zero result on uv_tcp_init: %d\",\n-                        tcp_init_result as int));\n-            assert false;\n-        }\n-        ll::loop_delete(test_loop);\n-    }\n-\n-    // this is the impl for a test that is (maybe) ran on a\n-    // per-platform/arch basis below\n-    fn impl_uv_tcp_server_and_request() unsafe {\n-        let bind_ip = \"0.0.0.0\";\n-        let request_ip = \"127.0.0.1\";\n-        let port = 8888;\n-        let kill_server_msg = \"does a dog have buddha nature?\";\n-        let server_resp_msg = \"mu!\";\n-        let client_port = comm::port::<str>();\n-        let client_chan = comm::chan::<str>(client_port);\n-        let server_port = comm::port::<str>();\n-        let server_chan = comm::chan::<str>(server_port);\n-\n-        let continue_port = comm::port::<bool>();\n-        let continue_chan = comm::chan::<bool>(continue_port);\n-        let continue_chan_ptr = ptr::addr_of(continue_chan);\n-\n-        task::spawn_sched(task::manual_threads(1u)) {||\n-            impl_uv_tcp_server(bind_ip, port,\n-                               kill_server_msg,\n-                               server_resp_msg,\n-                               ptr::addr_of(server_chan),\n-                               continue_chan_ptr);\n-        };\n-\n-        // block until the server up is.. possibly a race?\n-        log(debug, \"before receiving on server continue_port\");\n-        comm::recv(continue_port);\n-        log(debug, \"received on continue port, set up tcp client\");\n-\n-        task::spawn_sched(task::manual_threads(1u)) {||\n-            impl_uv_tcp_request(request_ip, port,\n-                               kill_server_msg,\n-                               ptr::addr_of(client_chan));\n-        };\n-\n-        let msg_from_client = comm::recv(server_port);\n-        let msg_from_server = comm::recv(client_port);\n-\n-        assert str::contains(msg_from_client, kill_server_msg);\n-        assert str::contains(msg_from_server, server_resp_msg);\n-    }\n-\n-    // don't run this test on fbsd or 32bit linux\n-    #[cfg(target_os=\"win32\")]\n-    #[cfg(target_os=\"darwin\")]\n-    #[cfg(target_os=\"linux\")]\n-    mod tcp_and_server_client_test {\n-        #[cfg(target_arch=\"x86_64\")]\n-        mod impl64 {\n-            #[test]\n-            fn test_uv_tcp_server_and_request() unsafe {\n-                impl_uv_tcp_server_and_request();\n-            }\n-        }\n-        #[cfg(target_arch=\"x86\")]\n-        mod impl32 {\n-            #[test]\n-            #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_uv_tcp_server_and_request() unsafe {\n-                impl_uv_tcp_server_and_request();\n-            }\n-        }\n-    }\n-\n-    // struct size tests\n-    #[test]\n-    #[ignore(cfg(target_os = \"freebsd\"))]\n-    fn test_uv_struct_size_uv_tcp_t() {\n-        let native_handle_size = rustrt::rust_uv_helper_uv_tcp_t_size();\n-        let rust_handle_size = sys::size_of::<ll::uv_tcp_t>();\n-        let output = #fmt(\"uv_tcp_t -- native: %u rust: %u\",\n-                          native_handle_size as uint, rust_handle_size);\n-        log(debug, output);\n-        assert native_handle_size as uint == rust_handle_size;\n-    }\n-    #[test]\n-    #[ignore(cfg(target_os = \"freebsd\"))]\n-    fn test_uv_struct_size_uv_connect_t() {\n-        let native_handle_size =\n-            rustrt::rust_uv_helper_uv_connect_t_size();\n-        let rust_handle_size = sys::size_of::<ll::uv_connect_t>();\n-        let output = #fmt(\"uv_connect_t -- native: %u rust: %u\",\n-                          native_handle_size as uint, rust_handle_size);\n-        log(debug, output);\n-        assert native_handle_size as uint == rust_handle_size;\n-    }\n-    #[test]\n-    #[ignore(cfg(target_os = \"freebsd\"))]\n-    fn test_uv_struct_size_uv_buf_t() {\n-        let native_handle_size =\n-            rustrt::rust_uv_helper_uv_buf_t_size();\n-        let rust_handle_size = sys::size_of::<ll::uv_buf_t>();\n-        let output = #fmt(\"uv_buf_t -- native: %u rust: %u\",\n-                          native_handle_size as uint, rust_handle_size);\n-        log(debug, output);\n-        assert native_handle_size as uint == rust_handle_size;\n-    }\n-    #[test]\n-    #[ignore(cfg(target_os = \"freebsd\"))]\n-    fn test_uv_struct_size_uv_write_t() {\n-        let native_handle_size =\n-            rustrt::rust_uv_helper_uv_write_t_size();\n-        let rust_handle_size = sys::size_of::<ll::uv_write_t>();\n-        let output = #fmt(\"uv_write_t -- native: %u rust: %u\",\n-                          native_handle_size as uint, rust_handle_size);\n-        log(debug, output);\n-        assert native_handle_size as uint == rust_handle_size;\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(target_os = \"freebsd\"))]\n-    fn test_uv_struct_size_sockaddr_in() {\n-        let native_handle_size =\n-            rustrt::rust_uv_helper_sockaddr_in_size();\n-        let rust_handle_size = sys::size_of::<ll::sockaddr_in>();\n-        let output = #fmt(\"sockaddr_in -- native: %u rust: %u\",\n-                          native_handle_size as uint, rust_handle_size);\n-        log(debug, output);\n-        assert native_handle_size as uint == rust_handle_size;\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(target_os = \"freebsd\"))]\n-    fn test_uv_struct_size_uv_async_t() {\n-        let native_handle_size =\n-            rustrt::rust_uv_helper_uv_async_t_size();\n-        let rust_handle_size = sys::size_of::<ll::uv_async_t>();\n-        let output = #fmt(\"uv_async_t -- native: %u rust: %u\",\n-                          native_handle_size as uint, rust_handle_size);\n-        log(debug, output);\n-        assert native_handle_size as uint == rust_handle_size;\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(target_os = \"freebsd\"))]\n-    fn test_uv_struct_size_uv_timer_t() {\n-        let native_handle_size =\n-            rustrt::rust_uv_helper_uv_timer_t_size();\n-        let rust_handle_size = sys::size_of::<ll::uv_timer_t>();\n-        let output = #fmt(\"uv_timer_t -- native: %u rust: %u\",\n-                          native_handle_size as uint, rust_handle_size);\n-        log(debug, output);\n-        assert native_handle_size as uint == rust_handle_size;\n-    }\n-\n-}"}, {"sha": "a003185a1759afa6425120e51ed983271d9aa9f5", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 610, "deletions": 2, "changes": 612, "blob_url": "https://github.com/rust-lang/rust/blob/a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe", "patch": "@@ -581,6 +581,16 @@ native mod rustrt {\n                                 data: *libc::c_void);\n     fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n     fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n+\n+    // sizeof testing helpers\n+    fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_connect_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_buf_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_write_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_async_t_size() -> libc::c_uint;\n+    fn rust_uv_helper_uv_timer_t_size() -> libc::c_uint;\n }\n \n unsafe fn loop_new() -> *libc::c_void {\n@@ -673,7 +683,7 @@ unsafe fn async_send(async_handle: *uv_async_t) {\n unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = { base: ptr::null(), len: 0 as libc::size_t };\n     let out_buf_ptr = ptr::addr_of(out_buf);\n-    log(debug, #fmt(\"ll::buf_init - input %u len %u out_buf: %u\",\n+    log(debug, #fmt(\"buf_init - input %u len %u out_buf: %u\",\n                      input as uint,\n                      len as uint,\n                      out_buf_ptr as uint));\n@@ -684,7 +694,7 @@ unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n     let res_base = get_base_from_buf(out_buf);\n     let res_len = get_len_from_buf(out_buf);\n     //let res_base = get_base_from_buf(result);\n-    log(debug, #fmt(\"ll::buf_init - result %u len %u\",\n+    log(debug, #fmt(\"buf_init - result %u len %u\",\n                      res_base as uint,\n                      res_len as uint));\n     ret out_buf;\n@@ -790,4 +800,602 @@ unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> str {\n     let err_msg = str::unsafe::from_c_str(strerror(err_ptr));\n     ret #fmt(\"LIBUV ERROR: name: %s msg: %s\",\n                     err_name, err_msg);\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    enum tcp_read_data {\n+        tcp_read_eof,\n+        tcp_read_more([u8]),\n+        tcp_read_error\n+    }\n+\n+    type request_wrapper = {\n+        write_req: *uv_write_t,\n+        req_buf: *[uv_buf_t],\n+        read_chan: *comm::chan<str>\n+    };\n+\n+    crust fn after_close_cb(handle: *libc::c_void) {\n+        log(debug, #fmt(\"after uv_close! handle ptr: %?\",\n+                        handle));\n+    }\n+\n+    crust fn on_alloc_cb(handle: *libc::c_void,\n+                         ++suggested_size: libc::size_t)\n+        -> uv_buf_t unsafe {\n+        log(debug, \"on_alloc_cb!\");\n+        let char_ptr = malloc_buf_base_of(suggested_size);\n+        log(debug, #fmt(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n+                         handle,\n+                         char_ptr as uint,\n+                         suggested_size as uint));\n+        ret buf_init(char_ptr, suggested_size);\n+    }\n+\n+    crust fn on_read_cb(stream: *uv_stream_t,\n+                        nread: libc::ssize_t,\n+                        ++buf: uv_buf_t) unsafe {\n+        log(debug, #fmt(\"CLIENT entering on_read_cb nred: %d\", nread));\n+        if (nread > 0) {\n+            // we have data\n+            log(debug, #fmt(\"CLIENT read: data! nread: %d\", nread));\n+            read_stop(stream);\n+            let client_data = \n+                get_data_for_uv_handle(stream as *libc::c_void)\n+                  as *request_wrapper;\n+            let buf_base = get_base_from_buf(buf);\n+            let buf_len = get_len_from_buf(buf);\n+            let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n+            let read_chan = *((*client_data).read_chan);\n+            let msg_from_server = str::from_bytes(bytes);\n+            comm::send(read_chan, msg_from_server);\n+            close(stream as *libc::c_void, after_close_cb)\n+        }\n+        else if (nread == -1) {\n+            // err .. possibly EOF\n+            log(debug, \"read: eof!\");\n+        }\n+        else {\n+            // nread == 0 .. do nothing, just free buf as below\n+            log(debug, \"read: do nothing!\");\n+        }\n+        // when we're done\n+        free_base_of_buf(buf);\n+        log(debug, \"CLIENT exiting on_read_cb\");\n+    }\n+\n+    crust fn on_write_complete_cb(write_req: *uv_write_t,\n+                                  status: libc::c_int) unsafe {\n+        log(debug, #fmt(\"CLIENT beginning on_write_complete_cb status: %d\",\n+                         status as int));\n+        let stream = get_stream_handle_from_write_req(write_req);\n+        log(debug, #fmt(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n+            stream as int, write_req as int));\n+        let result = read_start(stream, on_alloc_cb, on_read_cb);\n+        log(debug, #fmt(\"CLIENT ending on_write_complete_cb .. status: %d\",\n+                         result as int));\n+    }\n+\n+    crust fn on_connect_cb(connect_req_ptr: *uv_connect_t,\n+                                 status: libc::c_int) unsafe {\n+        log(debug, #fmt(\"beginning on_connect_cb .. status: %d\",\n+                         status as int));\n+        let stream =\n+            get_stream_handle_from_connect_req(connect_req_ptr);\n+        if (status == 0i32) {\n+            log(debug, \"on_connect_cb: in status=0 if..\");\n+            let client_data = get_data_for_req(\n+                connect_req_ptr as *libc::c_void)\n+                as *request_wrapper;\n+            let write_handle = (*client_data).write_req as *libc::c_void;\n+            log(debug, #fmt(\"on_connect_cb: tcp: %d write_hdl: %d\",\n+                            stream as int, write_handle as int));\n+            let write_result = write(write_handle,\n+                              stream as *libc::c_void,\n+                              (*client_data).req_buf,\n+                              on_write_complete_cb);\n+            log(debug, #fmt(\"on_connect_cb: write() status: %d\",\n+                             write_result as int));\n+        }\n+        else {\n+            let test_loop = get_loop_for_uv_handle(\n+                stream as *libc::c_void);\n+            let err_msg = get_last_err_info(test_loop);\n+            log(debug, err_msg);\n+            assert false;\n+        }\n+        log(debug, \"finishing on_connect_cb\");\n+    }\n+\n+    fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n+                          client_chan: *comm::chan<str>) unsafe {\n+        let test_loop = loop_new();\n+        let tcp_handle = tcp_t();\n+        let tcp_handle_ptr = ptr::addr_of(tcp_handle);\n+        let connect_handle = connect_t();\n+        let connect_req_ptr = ptr::addr_of(connect_handle);\n+\n+        // this is the persistent payload of data that we\n+        // need to pass around to get this example to work.\n+        // In C, this would be a malloc'd or stack-allocated\n+        // struct that we'd cast to a void* and store as the\n+        // data field in our uv_connect_t struct\n+        let req_str_bytes = str::bytes(req_str);\n+        let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str_bytes);\n+        log(debug, #fmt(\"req_msg ptr: %u\", req_msg_ptr as uint));\n+        let req_msg = [\n+            buf_init(req_msg_ptr, vec::len(req_str_bytes))\n+        ];\n+        // this is the enclosing record, we'll pass a ptr to\n+        // this to C..\n+        let write_handle = write_t();\n+        let write_handle_ptr = ptr::addr_of(write_handle);\n+        log(debug, #fmt(\"tcp req: tcp stream: %d write_handle: %d\",\n+                         tcp_handle_ptr as int,\n+                         write_handle_ptr as int));\n+        let client_data = { writer_handle: write_handle_ptr,\n+                    req_buf: ptr::addr_of(req_msg),\n+                    read_chan: client_chan };\n+\n+        let tcp_init_result = tcp_init(\n+            test_loop as *libc::c_void, tcp_handle_ptr);\n+        if (tcp_init_result == 0i32) {\n+            log(debug, \"sucessful tcp_init_result\");\n+\n+            log(debug, \"building addr...\");\n+            let addr = ip4_addr(ip, port);\n+            // FIXME ref #2064\n+            let addr_ptr = ptr::addr_of(addr);\n+            log(debug, #fmt(\"after build addr in rust. port: %u\",\n+                             addr.sin_port as uint));\n+\n+            // this should set up the connection request..\n+            log(debug, #fmt(\"b4 call tcp_connect connect cb: %u \",\n+                            on_connect_cb as uint));\n+            let tcp_connect_result = tcp_connect(\n+                connect_req_ptr, tcp_handle_ptr,\n+                addr_ptr, on_connect_cb);\n+            if (tcp_connect_result == 0i32) {\n+                // not set the data on the connect_req\n+                // until its initialized\n+                set_data_for_req(\n+                    connect_req_ptr as *libc::c_void,\n+                    ptr::addr_of(client_data) as *libc::c_void);\n+                set_data_for_uv_handle(\n+                    tcp_handle_ptr as *libc::c_void,\n+                    ptr::addr_of(client_data) as *libc::c_void);\n+                log(debug, \"before run tcp req loop\");\n+                run(test_loop);\n+                log(debug, \"after run tcp req loop\");\n+            }\n+            else {\n+               log(debug, \"tcp_connect() failure\");\n+               assert false;\n+            }\n+        }\n+        else {\n+            log(debug, \"tcp_init() failure\");\n+            assert false;\n+        }\n+        loop_delete(test_loop);\n+\n+    }\n+\n+    crust fn server_after_close_cb(handle: *libc::c_void) unsafe {\n+        log(debug, #fmt(\"SERVER server stream closed, should exit.. h: %?\",\n+                   handle));\n+    }\n+\n+    crust fn client_stream_after_close_cb(handle: *libc::c_void)\n+        unsafe {\n+        log(debug, \"SERVER: closed client stream, now closing server stream\");\n+        let client_data = get_data_for_uv_handle(\n+            handle) as\n+            *tcp_server_data;\n+        close((*client_data).server as *libc::c_void,\n+                      server_after_close_cb);\n+    }\n+\n+    crust fn after_server_resp_write(req: *uv_write_t) unsafe {\n+        let client_stream_ptr =\n+            get_stream_handle_from_write_req(req);\n+        log(debug, \"SERVER: resp sent... closing client stream\");\n+        close(client_stream_ptr as *libc::c_void,\n+                      client_stream_after_close_cb)\n+    }\n+\n+    crust fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n+                               nread: libc::ssize_t,\n+                               ++buf: uv_buf_t) unsafe {\n+        if (nread > 0) {\n+            // we have data\n+            log(debug, #fmt(\"SERVER read: data! nread: %d\", nread));\n+\n+            // pull out the contents of the write from the client\n+            let buf_base = get_base_from_buf(buf);\n+            let buf_len = get_len_from_buf(buf);\n+            log(debug, #fmt(\"SERVER buf base: %u, len: %u, nread: %d\",\n+                             buf_base as uint,\n+                             buf_len as uint,\n+                             nread));\n+            let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n+            let request_str = str::from_bytes(bytes);\n+\n+            let client_data = get_data_for_uv_handle(\n+                client_stream_ptr as *libc::c_void) as *tcp_server_data;\n+\n+            let server_kill_msg = (*client_data).server_kill_msg;\n+            let write_req = (*client_data).server_write_req;\n+            if (str::contains(request_str, server_kill_msg)) {\n+                log(debug, \"SERVER: client req contains kill_msg!\");\n+                log(debug, \"SERVER: sending response to client\");\n+                read_stop(client_stream_ptr);\n+                let server_chan = *((*client_data).server_chan);\n+                comm::send(server_chan, request_str);\n+                let write_result = write(\n+                    write_req as *libc::c_void,\n+                    client_stream_ptr as *libc::c_void,\n+                    (*client_data).server_resp_buf,\n+                    after_server_resp_write);\n+                log(debug, #fmt(\"SERVER: resp write result: %d\",\n+                            write_result as int));\n+                if (write_result != 0i32) {\n+                    log(debug, \"bad result for server resp write()\");\n+                    log(debug, get_last_err_info(\n+                        get_loop_for_uv_handle(client_stream_ptr\n+                            as *libc::c_void)));\n+                    assert false;\n+                }\n+            }\n+            else {\n+                log(debug, \"SERVER: client req !contain kill_msg!\");\n+            }\n+        }\n+        else if (nread == -1) {\n+            // err .. possibly EOF\n+            log(debug, \"read: eof!\");\n+        }\n+        else {\n+            // nread == 0 .. do nothing, just free buf as below\n+            log(debug, \"read: do nothing!\");\n+        }\n+        // when we're done\n+        free_base_of_buf(buf);\n+        log(debug, \"SERVER exiting on_read_cb\");\n+    }\n+\n+    crust fn server_connection_cb(server_stream_ptr:\n+                                    *uv_stream_t,\n+                                  status: libc::c_int) unsafe {\n+        log(debug, \"client connecting!\");\n+        let test_loop = get_loop_for_uv_handle(\n+                               server_stream_ptr as *libc::c_void);\n+        if status != 0i32 {\n+            let err_msg = get_last_err_info(test_loop);\n+            log(debug, #fmt(\"server_connect_cb: non-zero status: %?\",\n+                         err_msg));\n+            ret;\n+        }\n+        let server_data = get_data_for_uv_handle(\n+            server_stream_ptr as *libc::c_void) as *tcp_server_data;\n+        let client_stream_ptr = (*server_data).client;\n+        let client_init_result = tcp_init(test_loop,\n+                                                  client_stream_ptr);\n+        set_data_for_uv_handle(\n+            client_stream_ptr as *libc::c_void,\n+            server_data as *libc::c_void);\n+        if (client_init_result == 0i32) {\n+            log(debug, \"successfully initialized client stream\");\n+            let accept_result = accept(server_stream_ptr as\n+                                                 *libc::c_void,\n+                                               client_stream_ptr as\n+                                                 *libc::c_void);\n+            if (accept_result == 0i32) {\n+                // start reading\n+                let read_result = read_start(\n+                    client_stream_ptr as *uv_stream_t,\n+                                                     on_alloc_cb,\n+                                                     on_server_read_cb);\n+                if (read_result == 0i32) {\n+                    log(debug, \"successful server read start\");\n+                }\n+                else {\n+                    log(debug, #fmt(\"server_connection_cb: bad read:%d\",\n+                                    read_result as int));\n+                    assert false;\n+                }\n+            }\n+            else {\n+                log(debug, #fmt(\"server_connection_cb: bad accept: %d\",\n+                            accept_result as int));\n+                assert false;\n+            }\n+        }\n+        else {\n+            log(debug, #fmt(\"server_connection_cb: bad client init: %d\",\n+                        client_init_result as int));\n+            assert false;\n+        }\n+    }\n+\n+    type tcp_server_data = {\n+        client: *uv_tcp_t,\n+        server: *uv_tcp_t,\n+        server_kill_msg: str,\n+        server_resp_buf: *[uv_buf_t],\n+        server_chan: *comm::chan<str>,\n+        server_write_req: *uv_write_t\n+    };\n+\n+    type async_handle_data = {\n+        continue_chan: *comm::chan<bool>\n+    };\n+\n+    crust fn async_close_cb(handle: *libc::c_void) {\n+        log(debug, #fmt(\"SERVER: closing async cb... h: %?\",\n+                   handle));\n+    }\n+\n+    crust fn continue_async_cb(async_handle: *uv_async_t,\n+                               status: libc::c_int) unsafe {\n+        // once we're in the body of this callback,\n+        // the tcp server's loop is set up, so we\n+        // can continue on to let the tcp client\n+        // do its thang\n+        let data = get_data_for_uv_handle(\n+            async_handle as *libc::c_void) as *async_handle_data;\n+        let continue_chan = *((*data).continue_chan);\n+        let should_continue = status == 0i32;\n+        comm::send(continue_chan, should_continue);\n+        close(async_handle as *libc::c_void, async_close_cb);\n+    }\n+\n+    fn impl_uv_tcp_server(server_ip: str,\n+                          server_port: int,\n+                          kill_server_msg: str,\n+                          server_resp_msg: str,\n+                          server_chan: *comm::chan<str>,\n+                          continue_chan: *comm::chan<bool>) unsafe {\n+        let test_loop = loop_new();\n+        let tcp_server = tcp_t();\n+        let tcp_server_ptr = ptr::addr_of(tcp_server);\n+\n+        let tcp_client = tcp_t();\n+        let tcp_client_ptr = ptr::addr_of(tcp_client);\n+\n+        let server_write_req = write_t();\n+        let server_write_req_ptr = ptr::addr_of(server_write_req);\n+\n+        let resp_str_bytes = str::bytes(server_resp_msg);\n+        let resp_msg_ptr: *u8 = vec::unsafe::to_ptr(resp_str_bytes);\n+        log(debug, #fmt(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n+        let resp_msg = [\n+            buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n+        ];\n+\n+        let continue_async_handle = async_t();\n+        let continue_async_handle_ptr =\n+            ptr::addr_of(continue_async_handle);\n+        let async_data =\n+            { continue_chan: continue_chan };\n+        let async_data_ptr = ptr::addr_of(async_data);\n+\n+        let server_data: tcp_server_data = {\n+            client: tcp_client_ptr,\n+            server: tcp_server_ptr,\n+            server_kill_msg: kill_server_msg,\n+            server_resp_buf: ptr::addr_of(resp_msg),\n+            server_chan: server_chan,\n+            server_write_req: server_write_req_ptr\n+        };\n+        let server_data_ptr = ptr::addr_of(server_data);\n+        set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n+                                       server_data_ptr as *libc::c_void);\n+\n+        // uv_tcp_init()\n+        let tcp_init_result = tcp_init(\n+            test_loop as *libc::c_void, tcp_server_ptr);\n+        if (tcp_init_result == 0i32) {\n+            let server_addr = ip4_addr(server_ip, server_port);\n+            // FIXME ref #2064\n+            let server_addr_ptr = ptr::addr_of(server_addr);\n+\n+            // uv_tcp_bind()\n+            let bind_result = tcp_bind(tcp_server_ptr,\n+                                               server_addr_ptr);\n+            if (bind_result == 0i32) {\n+                log(debug, \"successful uv_tcp_bind, listening\");\n+\n+                // uv_listen()\n+                let listen_result = listen(tcp_server_ptr as\n+                                                     *libc::c_void,\n+                                                   128i32,\n+                                                   server_connection_cb);\n+                if (listen_result == 0i32) {\n+                    // let the test know it can set up the tcp server,\n+                    // now.. this may still present a race, not sure..\n+                    let async_result = async_init(test_loop,\n+                                       continue_async_handle_ptr,\n+                                       continue_async_cb);\n+                    if (async_result == 0i32) {\n+                        set_data_for_uv_handle(\n+                            continue_async_handle_ptr as *libc::c_void,\n+                            async_data_ptr as *libc::c_void);\n+                        async_send(continue_async_handle_ptr);\n+                        // uv_run()\n+                        run(test_loop);\n+                        log(debug, \"server uv::run() has returned\");\n+                    }\n+                    else {\n+                        log(debug, #fmt(\"uv_async_init failure: %d\",\n+                                async_result as int));\n+                        assert false;\n+                    }\n+                }\n+                else {\n+                    log(debug, #fmt(\"non-zero result on uv_listen: %d\",\n+                                listen_result as int));\n+                    assert false;\n+                }\n+            }\n+            else {\n+                log(debug, #fmt(\"non-zero result on uv_tcp_bind: %d\",\n+                            bind_result as int));\n+                assert false;\n+            }\n+        }\n+        else {\n+            log(debug, #fmt(\"non-zero result on uv_tcp_init: %d\",\n+                        tcp_init_result as int));\n+            assert false;\n+        }\n+        loop_delete(test_loop);\n+    }\n+\n+    // this is the impl for a test that is (maybe) ran on a\n+    // per-platform/arch basis below\n+    fn impl_uv_tcp_server_and_request() unsafe {\n+        let bind_ip = \"0.0.0.0\";\n+        let request_ip = \"127.0.0.1\";\n+        let port = 8888;\n+        let kill_server_msg = \"does a dog have buddha nature?\";\n+        let server_resp_msg = \"mu!\";\n+        let client_port = comm::port::<str>();\n+        let client_chan = comm::chan::<str>(client_port);\n+        let server_port = comm::port::<str>();\n+        let server_chan = comm::chan::<str>(server_port);\n+\n+        let continue_port = comm::port::<bool>();\n+        let continue_chan = comm::chan::<bool>(continue_port);\n+        let continue_chan_ptr = ptr::addr_of(continue_chan);\n+\n+        task::spawn_sched(task::manual_threads(1u)) {||\n+            impl_uv_tcp_server(bind_ip, port,\n+                               kill_server_msg,\n+                               server_resp_msg,\n+                               ptr::addr_of(server_chan),\n+                               continue_chan_ptr);\n+        };\n+\n+        // block until the server up is.. possibly a race?\n+        log(debug, \"before receiving on server continue_port\");\n+        comm::recv(continue_port);\n+        log(debug, \"received on continue port, set up tcp client\");\n+\n+        task::spawn_sched(task::manual_threads(1u)) {||\n+            impl_uv_tcp_request(request_ip, port,\n+                               kill_server_msg,\n+                               ptr::addr_of(client_chan));\n+        };\n+\n+        let msg_from_client = comm::recv(server_port);\n+        let msg_from_server = comm::recv(client_port);\n+\n+        assert str::contains(msg_from_client, kill_server_msg);\n+        assert str::contains(msg_from_server, server_resp_msg);\n+    }\n+\n+    // don't run this test on fbsd or 32bit linux\n+    #[cfg(target_os=\"win32\")]\n+    #[cfg(target_os=\"darwin\")]\n+    #[cfg(target_os=\"linux\")]\n+    mod tcp_and_server_client_test {\n+        #[cfg(target_arch=\"x86_64\")]\n+        mod impl64 {\n+            #[test]\n+            fn test_uv_ll_tcp_server_and_request() unsafe {\n+                impl_uv_tcp_server_and_request();\n+            }\n+        }\n+        #[cfg(target_arch=\"x86\")]\n+        mod impl32 {\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n+            fn test_uv_ll_tcp_server_and_request() unsafe {\n+                impl_uv_tcp_server_and_request();\n+            }\n+        }\n+    }\n+\n+    // struct size tests\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_ll_struct_size_uv_tcp_t() {\n+        let native_handle_size = rustrt::rust_uv_helper_uv_tcp_t_size();\n+        let rust_handle_size = sys::size_of::<uv_tcp_t>();\n+        let output = #fmt(\"uv_tcp_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_ll_struct_size_uv_connect_t() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_uv_connect_t_size();\n+        let rust_handle_size = sys::size_of::<uv_connect_t>();\n+        let output = #fmt(\"uv_connect_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_ll_struct_size_uv_buf_t() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_uv_buf_t_size();\n+        let rust_handle_size = sys::size_of::<uv_buf_t>();\n+        let output = #fmt(\"uv_buf_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_ll_struct_size_uv_write_t() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_uv_write_t_size();\n+        let rust_handle_size = sys::size_of::<uv_write_t>();\n+        let output = #fmt(\"uv_write_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_ll_struct_size_sockaddr_in() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_sockaddr_in_size();\n+        let rust_handle_size = sys::size_of::<sockaddr_in>();\n+        let output = #fmt(\"sockaddr_in -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_ll_struct_size_uv_async_t() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_uv_async_t_size();\n+        let rust_handle_size = sys::size_of::<uv_async_t>();\n+        let output = #fmt(\"uv_async_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_ll_struct_size_uv_timer_t() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_uv_timer_t_size();\n+        let rust_handle_size = sys::size_of::<uv_timer_t>();\n+        let output = #fmt(\"uv_timer_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n }\n\\ No newline at end of file"}]}