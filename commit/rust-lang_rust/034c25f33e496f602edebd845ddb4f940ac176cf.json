{"sha": "034c25f33e496f602edebd845ddb4f940ac176cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNGMyNWYzM2U0OTZmNjAyZWRlYmQ4NDVkZGI0Zjk0MGFjMTc2Y2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-05-07T10:12:19Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-20T13:44:34Z"}, "message": "make `to_predicate` take a `tcx` argument", "tree": {"sha": "5ac585d4924a97d3fccd56d6453b701622cdb947", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ac585d4924a97d3fccd56d6453b701622cdb947"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/034c25f33e496f602edebd845ddb4f940ac176cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/034c25f33e496f602edebd845ddb4f940ac176cf", "html_url": "https://github.com/rust-lang/rust/commit/034c25f33e496f602edebd845ddb4f940ac176cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/034c25f33e496f602edebd845ddb4f940ac176cf/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "url": "https://api.github.com/repos/rust-lang/rust/commits/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "html_url": "https://github.com/rust-lang/rust/commit/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72"}], "stats": {"total": 194, "additions": 102, "deletions": 92}, "files": [{"sha": "2710debea9478b44e2106bcd26b37726d7768104", "filename": "src/librustc_infer/traits/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fengine.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -33,7 +33,7 @@ pub trait TraitEngine<'tcx>: 'tcx {\n                 cause,\n                 recursion_depth: 0,\n                 param_env,\n-                predicate: trait_ref.without_const().to_predicate(),\n+                predicate: trait_ref.without_const().to_predicate(infcx.tcx),\n             },\n         );\n     }"}, {"sha": "b9cafc530cd475f0c58c48c25afb799145734b30", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -99,14 +99,14 @@ pub fn elaborate_trait_ref<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> Elaborator<'tcx> {\n-    elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate()))\n+    elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate(tcx)))\n }\n \n pub fn elaborate_trait_refs<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n ) -> Elaborator<'tcx> {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate());\n+    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate(tcx));\n     elaborate_predicates(tcx, predicates)\n }\n "}, {"sha": "16a44328b82facda346b2126779000f484f0f828", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -1295,11 +1295,11 @@ impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n }\n \n pub trait ToPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx>;\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx>;\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n+    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         ty::PredicateKind::Trait(\n             ty::Binder::dummy(ty::TraitPredicate { trait_ref: self.value }),\n             self.constness,\n@@ -1308,7 +1308,7 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&TraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n+    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         ty::PredicateKind::Trait(\n             ty::Binder::dummy(ty::TraitPredicate { trait_ref: *self.value }),\n             self.constness,\n@@ -1317,31 +1317,31 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&TraitRef<'tcx>> {\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n+    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&PolyTraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n+    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n+    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         PredicateKind::RegionOutlives(*self)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n+    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         PredicateKind::TypeOutlives(*self)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n+    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         PredicateKind::Projection(*self)\n     }\n }\n@@ -1619,7 +1619,7 @@ pub struct ConstnessAnd<T> {\n     pub value: T,\n }\n \n-// FIXME(ecstaticmorse): Audit all occurrences of `without_const().to_predicate()` to ensure that\n+// FIXME(ecstaticmorse): Audit all occurrences of `without_const().to_predicate(tcx)` to ensure that\n // the constness of trait bounds is being propagated correctly.\n pub trait WithConstness: Sized {\n     #[inline]"}, {"sha": "1e4aaa60545254d8b29b9ddfd6248eec36e5305c", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -612,15 +612,15 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n         use crate::ty::ToPredicate;\n         match *self.skip_binder() {\n             ExistentialPredicate::Trait(tr) => {\n-                Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate()\n+                Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n             }\n             ExistentialPredicate::Projection(p) => {\n                 ty::PredicateKind::Projection(Binder(p.with_self_ty(tcx, self_ty)))\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n                 let trait_ref =\n                     Binder(ty::TraitRef { def_id: did, substs: tcx.mk_substs_trait(self_ty, &[]) });\n-                trait_ref.without_const().to_predicate()\n+                trait_ref.without_const().to_predicate(tcx)\n             }\n         }\n     }"}, {"sha": "f997fbadd89fcaefaf091b41b4748176240cd45b", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             \"{}\",\n                             message.unwrap_or_else(|| format!(\n                                 \"the trait bound `{}` is not satisfied{}\",\n-                                trait_ref.without_const().to_predicate(),\n+                                trait_ref.without_const().to_predicate(tcx),\n                                 post_message,\n                             ))\n                         );\n@@ -1021,13 +1021,13 @@ trait InferCtxtPrivExt<'tcx> {\n \n     fn note_obligation_cause(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n     fn suggest_unsized_bound_if_applicable(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n@@ -1390,7 +1390,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> PredicateObligation<'tcx> {\n         let new_trait_ref =\n             ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n-        Obligation::new(cause, param_env, new_trait_ref.without_const().to_predicate())\n+        Obligation::new(cause, param_env, new_trait_ref.without_const().to_predicate(self.tcx))\n     }\n \n     fn maybe_report_ambiguity(\n@@ -1629,7 +1629,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let obligation = Obligation::new(\n                 ObligationCause::dummy(),\n                 param_env,\n-                cleaned_pred.without_const().to_predicate(),\n+                cleaned_pred.without_const().to_predicate(selcx.tcx()),\n             );\n \n             self.predicate_may_hold(&obligation)\n@@ -1638,7 +1638,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn note_obligation_cause(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         // First, attempt to add note to this error with an async-await-specific\n@@ -1656,7 +1656,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn suggest_unsized_bound_if_applicable(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         if let ("}, {"sha": "cbc93278353be7af7f1d2f698e12ad2af0a6cd6b", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -38,14 +38,14 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::PolyTraitRef<'_>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         body_id: hir::HirId,\n     );\n \n     fn suggest_borrow_on_unsized_slice(\n         &self,\n         code: &ObligationCauseCode<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n     );\n \n     fn get_closure_name(\n@@ -66,7 +66,7 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n         has_custom_message: bool,\n@@ -75,22 +75,22 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_remove_reference(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     );\n \n     fn suggest_change_mut(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     );\n \n     fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     );\n@@ -99,15 +99,15 @@ pub trait InferCtxtExt<'tcx> {\n \n     fn suggest_impl_trait(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     ) -> bool;\n \n     fn point_at_returns_when_relevant(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n@@ -138,11 +138,11 @@ pub trait InferCtxtExt<'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         interior_or_upvar_span: GeneratorInteriorOrUpvar,\n         interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n-        inner_generator_body: Option<&hir::Body<'_>>,\n+        inner_generator_body: Option<&hir::Body<'tcx>>,\n         outer_generator: Option<DefId>,\n-        trait_ref: ty::TraitRef<'_>,\n+        trait_ref: ty::TraitRef<'tcx>,\n         target_ty: Ty<'tcx>,\n-        tables: &ty::TypeckTables<'_>,\n+        tables: &ty::TypeckTables<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n     );\n@@ -183,12 +183,13 @@ fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, St\n /// it can also be an `impl Trait` param that needs to be decomposed to a type\n /// param for cleaner code.\n fn suggest_restriction(\n-    generics: &hir::Generics<'_>,\n+    tcx: TyCtxt<'tcx>,\n+    generics: &hir::Generics<'tcx>,\n     msg: &str,\n     err: &mut DiagnosticBuilder<'_>,\n     fn_sig: Option<&hir::FnSig<'_>>,\n     projection: Option<&ty::ProjectionTy<'_>>,\n-    trait_ref: ty::PolyTraitRef<'_>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n     super_traits: Option<(&Ident, &hir::GenericBounds<'_>)>,\n ) {\n     // When we are dealing with a trait, `super_traits` will be `Some`:\n@@ -243,7 +244,7 @@ fn suggest_restriction(\n \n         // FIXME: modify the `trait_ref` instead of string shenanigans.\n         // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n-        let pred = trait_ref.without_const().to_predicate().to_string();\n+        let pred = trait_ref.without_const().to_predicate(tcx).to_string();\n         let pred = pred.replace(&impl_trait_str, &type_param_name);\n         let mut sugg = vec![\n             match generics\n@@ -285,9 +286,10 @@ fn suggest_restriction(\n     } else {\n         // Trivial case: `T` needs an extra bound: `T: Bound`.\n         let (sp, suggestion) = match super_traits {\n-            None => {\n-                predicate_constraint(generics, trait_ref.without_const().to_predicate().to_string())\n-            }\n+            None => predicate_constraint(\n+                generics,\n+                trait_ref.without_const().to_predicate(tcx).to_string(),\n+            ),\n             Some((ident, bounds)) => match bounds {\n                 [.., bound] => (\n                     bound.span().shrink_to_hi(),\n@@ -313,7 +315,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         mut err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::PolyTraitRef<'_>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         body_id: hir::HirId,\n     ) {\n         let self_ty = trait_ref.self_ty();\n@@ -336,6 +338,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     assert!(param_ty);\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n+                        self.tcx,\n                         &generics,\n                         \"`Self`\",\n                         err,\n@@ -355,7 +358,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     assert!(param_ty);\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n-                        &generics, \"`Self`\", err, None, projection, trait_ref, None,\n+                        self.tcx, &generics, \"`Self`\", err, None, projection, trait_ref, None,\n                     );\n                     return;\n                 }\n@@ -375,6 +378,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }) if projection.is_some() => {\n                     // Missing restriction on associated type of type parameter (unmet projection).\n                     suggest_restriction(\n+                        self.tcx,\n                         &generics,\n                         \"the associated type\",\n                         err,\n@@ -393,6 +397,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }) if projection.is_some() => {\n                     // Missing restriction on associated type of type parameter (unmet projection).\n                     suggest_restriction(\n+                        self.tcx,\n                         &generics,\n                         \"the associated type\",\n                         err,\n@@ -450,7 +455,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_borrow_on_unsized_slice(\n         &self,\n         code: &ObligationCauseCode<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n     ) {\n         if let &ObligationCauseCode::VariableType(hir_id) = code {\n             let parent_node = self.tcx.hir().get_parent_node(hir_id);\n@@ -601,7 +606,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n         has_custom_message: bool,\n@@ -624,7 +629,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let new_obligation = Obligation::new(\n                 ObligationCause::dummy(),\n                 param_env,\n-                new_trait_ref.without_const().to_predicate(),\n+                new_trait_ref.without_const().to_predicate(self.tcx),\n             );\n             if self.predicate_must_hold_modulo_regions(&new_obligation) {\n                 if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n@@ -673,7 +678,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_remove_reference(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     ) {\n         let trait_ref = trait_ref.skip_binder();\n@@ -735,7 +740,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_change_mut(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     ) {\n@@ -806,7 +811,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     ) {\n@@ -852,7 +857,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// emitted.\n     fn suggest_impl_trait(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n@@ -1048,7 +1053,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn point_at_returns_when_relevant(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         match obligation.cause.code.peel_derives() {\n@@ -1430,11 +1435,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         interior_or_upvar_span: GeneratorInteriorOrUpvar,\n         interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n-        inner_generator_body: Option<&hir::Body<'_>>,\n+        inner_generator_body: Option<&hir::Body<'tcx>>,\n         outer_generator: Option<DefId>,\n-        trait_ref: ty::TraitRef<'_>,\n+        trait_ref: ty::TraitRef<'tcx>,\n         target_ty: Ty<'tcx>,\n-        tables: &ty::TypeckTables<'_>,\n+        tables: &ty::TypeckTables<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n     ) {\n@@ -1788,7 +1793,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err.note(&format!(\"required because it appears within the type `{}`\", ty));\n                 obligated_types.push(ty);\n \n-                let parent_predicate = parent_trait_ref.without_const().to_predicate();\n+                let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n                 if !self.is_recursive_obligation(obligated_types, &data.parent_code) {\n                     self.note_obligation_cause_code(\n                         err,\n@@ -1805,7 +1810,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     parent_trait_ref.print_only_trait_path(),\n                     parent_trait_ref.skip_binder().self_ty()\n                 ));\n-                let parent_predicate = parent_trait_ref.without_const().to_predicate();\n+                let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n                 self.note_obligation_cause_code(\n                     err,\n                     &parent_predicate,\n@@ -1815,7 +1820,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             ObligationCauseCode::DerivedObligation(ref data) => {\n                 let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n-                let parent_predicate = parent_trait_ref.without_const().to_predicate();\n+                let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n                 self.note_obligation_cause_code(\n                     err,\n                     &parent_predicate,\n@@ -2061,7 +2066,7 @@ impl NextTypeParamName for &[hir::GenericParam<'_>] {\n }\n \n fn suggest_trait_object_return_type_alternatives(\n-    err: &mut DiagnosticBuilder<'tcx>,\n+    err: &mut DiagnosticBuilder<'_>,\n     ret_ty: Span,\n     trait_obj: &str,\n     is_object_safe: bool,"}, {"sha": "f67669769a10dd7498cc445d0ac02107bde07802", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -143,7 +143,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n         param_env,\n         cause: ObligationCause::misc(span, hir::CRATE_HIR_ID),\n         recursion_depth: 0,\n-        predicate: trait_ref.without_const().to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(infcx.tcx),\n     };\n \n     let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n@@ -557,7 +557,7 @@ fn type_implements_trait<'tcx>(\n         cause: ObligationCause::dummy(),\n         param_env,\n         recursion_depth: 0,\n-        predicate: trait_ref.without_const().to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(tcx),\n     };\n     tcx.infer_ctxt().enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n }"}, {"sha": "4839a25d85fc91d486a53a1d7a743f023779e6cb", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -636,7 +636,7 @@ fn receiver_is_dispatchable<'tcx>(\n             substs: tcx.mk_substs_trait(tcx.types.self_param, &[unsized_self_ty.into()]),\n         }\n         .without_const()\n-        .to_predicate();\n+        .to_predicate(tcx);\n \n         // U: Trait<Arg1, ..., ArgN>\n         let trait_predicate = {\n@@ -649,7 +649,7 @@ fn receiver_is_dispatchable<'tcx>(\n                     }\n                 });\n \n-            ty::TraitRef { def_id: unsize_did, substs }.without_const().to_predicate()\n+            ty::TraitRef { def_id: unsize_did, substs }.without_const().to_predicate(tcx)\n         };\n \n         let caller_bounds: Vec<Predicate<'tcx>> = param_env\n@@ -672,7 +672,7 @@ fn receiver_is_dispatchable<'tcx>(\n             substs: tcx.mk_substs_trait(receiver_ty, &[unsized_receiver_ty.into()]),\n         }\n         .without_const()\n-        .to_predicate();\n+        .to_predicate(tcx);\n \n         Obligation::new(ObligationCause::dummy(), param_env, predicate)\n     };"}, {"sha": "79b6ac3f7ad090e00f46f320328ce4b0436fc79f", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -432,7 +432,7 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n         });\n         let projection = ty::Binder::dummy(ty::ProjectionPredicate { projection_ty, ty: ty_var });\n         let obligation =\n-            Obligation::with_depth(cause, depth + 1, param_env, projection.to_predicate());\n+            Obligation::with_depth(cause, depth + 1, param_env, projection.to_predicate(tcx));\n         obligations.push(obligation);\n         ty_var\n     })\n@@ -722,7 +722,7 @@ fn get_paranoid_cache_value_obligation<'a, 'tcx>(\n         cause,\n         recursion_depth: depth,\n         param_env,\n-        predicate: trait_ref.without_const().to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(infcx.tcx),\n     }\n }\n \n@@ -757,7 +757,7 @@ fn normalize_to_error<'a, 'tcx>(\n         cause,\n         recursion_depth: depth,\n         param_env,\n-        predicate: trait_ref.without_const().to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(selcx.tcx()),\n     };\n     let tcx = selcx.infcx().tcx;\n     let def_id = projection_ty.item_def_id;\n@@ -1158,8 +1158,9 @@ fn confirm_object_candidate<'cx, 'tcx>(\n             object_ty\n         ),\n     };\n-    let env_predicates =\n-        data.projection_bounds().map(|p| p.with_self_ty(selcx.tcx(), object_ty).to_predicate());\n+    let env_predicates = data\n+        .projection_bounds()\n+        .map(|p| p.with_self_ty(selcx.tcx(), object_ty).to_predicate(selcx.tcx()));\n     let env_predicate = {\n         let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n "}, {"sha": "2aae0f2703152125b249b2809170bf22a34a5d46", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -3031,7 +3031,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     cause,\n                     obligation.recursion_depth + 1,\n                     obligation.param_env,\n-                    ty::Binder::bind(outlives).to_predicate(),\n+                    ty::Binder::bind(outlives).to_predicate(tcx),\n                 ));\n             }\n \n@@ -3074,12 +3074,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                     tcx.mk_substs_trait(source, &[]),\n                 );\n-                nested.push(predicate_to_obligation(tr.without_const().to_predicate()));\n+                nested.push(predicate_to_obligation(tr.without_const().to_predicate(tcx)));\n \n                 // If the type is `Foo + 'a`, ensure that the type\n                 // being cast to `Foo + 'a` outlives `'a`:\n                 let outlives = ty::OutlivesPredicate(source, r);\n-                nested.push(predicate_to_obligation(ty::Binder::dummy(outlives).to_predicate()));\n+                nested.push(predicate_to_obligation(ty::Binder::dummy(outlives).to_predicate(tcx)));\n             }\n \n             // `[T; n]` -> `[T]`"}, {"sha": "f2d3f0e1116e2fb03f8f41602816c7ef72d6df9a", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -97,7 +97,7 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n     fn expand(&mut self, item: &TraitAliasExpansionInfo<'tcx>) -> bool {\n         let tcx = self.tcx;\n         let trait_ref = item.trait_ref();\n-        let pred = trait_ref.without_const().to_predicate();\n+        let pred = trait_ref.without_const().to_predicate(tcx);\n \n         debug!(\"expand_trait_aliases: trait_ref={:?}\", trait_ref);\n \n@@ -110,7 +110,7 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n         // Don't recurse if this trait alias is already on the stack for the DFS search.\n         let anon_pred = anonymize_predicate(tcx, &pred);\n         if item.path.iter().rev().skip(1).any(|(tr, _)| {\n-            anonymize_predicate(tcx, &tr.without_const().to_predicate()) == anon_pred\n+            anonymize_predicate(tcx, &tr.without_const().to_predicate(tcx)) == anon_pred\n         }) {\n             return false;\n         }\n@@ -234,6 +234,7 @@ pub fn predicates_for_generics<'tcx>(\n }\n \n pub fn predicate_for_trait_ref<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n@@ -243,7 +244,7 @@ pub fn predicate_for_trait_ref<'tcx>(\n         cause,\n         param_env,\n         recursion_depth,\n-        predicate: trait_ref.without_const().to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(tcx),\n     }\n }\n \n@@ -258,7 +259,7 @@ pub fn predicate_for_trait_def(\n ) -> PredicateObligation<'tcx> {\n     let trait_ref =\n         ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(self_ty, params) };\n-    predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n+    predicate_for_trait_ref(tcx, cause, param_env, trait_ref, recursion_depth)\n }\n \n /// Casts a trait reference into a reference to one of its super"}, {"sha": "a6f4819277c2042b6edcb8181c0c371ad8dc00cb", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -292,7 +292,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         self.compute_trait_ref(&trait_ref, Elaborate::None);\n \n         if !data.has_escaping_bound_vars() {\n-            let predicate = trait_ref.without_const().to_predicate();\n+            let predicate = trait_ref.without_const().to_predicate(self.infcx.tcx);\n             let cause = self.cause(traits::ProjectionWf(data));\n             self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n@@ -323,7 +323,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             self.out.push(traits::Obligation::new(\n                 cause,\n                 self.param_env,\n-                trait_ref.without_const().to_predicate(),\n+                trait_ref.without_const().to_predicate(self.infcx.tcx),\n             ));\n         }\n     }\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 self.out.push(traits::Obligation::new(\n                     cause,\n                     self.param_env,\n-                    outlives.to_predicate(),\n+                    outlives.to_predicate(self.infcx.tcx),\n                 ));\n             }\n         }"}, {"sha": "3da5da2d9efb8f62c8fbc6f597be2d0d38e20aab", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -61,7 +61,7 @@ fn sized_constraint_for_ty<'tcx>(\n                 substs: tcx.mk_substs_trait(ty, &[]),\n             })\n             .without_const()\n-            .to_predicate();\n+            .to_predicate(tcx);\n             let predicates = tcx.predicates_of(adtdef.did).predicates;\n             if predicates.iter().any(|(p, _)| *p == sized_predicate) { vec![] } else { vec![ty] }\n         }"}, {"sha": "f8144d4aade4e2e51ccd6a2aa9f573c2d20b705c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -3042,7 +3042,7 @@ impl<'tcx> Bounds<'tcx> {\n                     def_id: sized,\n                     substs: tcx.mk_substs_trait(param_ty, &[]),\n                 });\n-                (trait_ref.without_const().to_predicate(), span)\n+                (trait_ref.without_const().to_predicate(tcx), span)\n             })\n         });\n \n@@ -3057,16 +3057,16 @@ impl<'tcx> Bounds<'tcx> {\n                         // or it's a generic associated type that deliberately has escaping bound vars.\n                         let region_bound = ty::fold::shift_region(tcx, region_bound, 1);\n                         let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n-                        (ty::Binder::bind(outlives).to_predicate(), span)\n+                        (ty::Binder::bind(outlives).to_predicate(tcx), span)\n                     })\n                     .chain(self.trait_bounds.iter().map(|&(bound_trait_ref, span, constness)| {\n-                        let predicate = bound_trait_ref.with_constness(constness).to_predicate();\n+                        let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);\n                         (predicate, span)\n                     }))\n                     .chain(\n                         self.projection_bounds\n                             .iter()\n-                            .map(|&(projection, span)| (projection.to_predicate(), span)),\n+                            .map(|&(projection, span)| (projection.to_predicate(tcx), span)),\n                     ),\n             )\n             .collect()"}, {"sha": "8ca0861090605e1e5a00d6ae8616bb23b1bb90d7", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         let obligation = traits::Obligation::new(\n             cause.clone(),\n             self.param_env,\n-            trait_ref.without_const().to_predicate(),\n+            trait_ref.without_const().to_predicate(tcx),\n         );\n         if !self.infcx.predicate_may_hold(&obligation) {\n             debug!(\"overloaded_deref_ty: cannot match obligation\");"}, {"sha": "d1da0bbda540a1c5b039fc350134752e1f64369a", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -324,7 +324,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             span,\n             self.body_id,\n             self.param_env,\n-            poly_trait_ref.without_const().to_predicate(),\n+            poly_trait_ref.without_const().to_predicate(self.tcx),\n         );\n \n         // Now we want to know if this can be matched"}, {"sha": "f1a1c48da166a5c1865af289ec1012e27cb660d4", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -1374,7 +1374,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 }\n \n                 TraitCandidate(trait_ref) => {\n-                    let predicate = trait_ref.without_const().to_predicate();\n+                    let predicate = trait_ref.without_const().to_predicate(self.tcx);\n                     let obligation = traits::Obligation::new(cause, self.param_env, predicate);\n                     if !self.predicate_may_hold(&obligation) {\n                         result = ProbeResult::NoMatch;"}, {"sha": "321cc7a3c4bf5a5aaee2403a75a88b29b47c1c05", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             span,\n                             self.body_id,\n                             self.param_env,\n-                            poly_trait_ref.without_const().to_predicate(),\n+                            poly_trait_ref.without_const().to_predicate(tcx),\n                         );\n                         self.predicate_may_hold(&obligation)\n                     })"}, {"sha": "b9055722bb571795487873cd257689eba20a2320", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -1458,7 +1458,7 @@ fn check_fn<'a, 'tcx>(\n                 inherited.register_predicate(traits::Obligation::new(\n                     cause,\n                     param_env,\n-                    trait_ref.without_const().to_predicate(),\n+                    trait_ref.without_const().to_predicate(tcx),\n                 ));\n             }\n         }"}, {"sha": "aa3865059392f6bf9305f2a2cc7e8ae0d9d8be50", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -1174,8 +1174,11 @@ fn receiver_is_implemented(\n         substs: fcx.tcx.mk_substs_trait(receiver_ty, &[]),\n     };\n \n-    let obligation =\n-        traits::Obligation::new(cause, fcx.param_env, trait_ref.without_const().to_predicate());\n+    let obligation = traits::Obligation::new(\n+        cause,\n+        fcx.param_env,\n+        trait_ref.without_const().to_predicate(fcx.tcx),\n+    );\n \n     if fcx.predicate_must_hold_modulo_regions(&obligation) {\n         true"}, {"sha": "529c9f9f5050801a5ccaa38c6a03fbbedb3450c5", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -528,7 +528,7 @@ fn type_param_predicates(\n                     if param_id == item_hir_id {\n                         let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n                         extend =\n-                            Some((identity_trait_ref.without_const().to_predicate(), item.span));\n+                            Some((identity_trait_ref.without_const().to_predicate(tcx), item.span));\n                     }\n                     generics\n                 }\n@@ -1657,7 +1657,7 @@ fn predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n         let span = tcx.sess.source_map().guess_head_span(tcx.def_span(def_id));\n         result.predicates =\n             tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(std::iter::once((\n-                ty::TraitRef::identity(tcx, def_id).without_const().to_predicate(),\n+                ty::TraitRef::identity(tcx, def_id).without_const().to_predicate(tcx),\n                 span,\n             ))));\n     }\n@@ -1832,7 +1832,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     // set of defaults that can be incorporated into another impl.\n     if let Some(trait_ref) = is_default_impl_trait {\n         predicates.push((\n-            trait_ref.to_poly_trait_ref().without_const().to_predicate(),\n+            trait_ref.to_poly_trait_ref().without_const().to_predicate(tcx),\n             tcx.def_span(def_id),\n         ));\n     }\n@@ -1855,7 +1855,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                     hir::GenericBound::Outlives(lt) => {\n                         let bound = AstConv::ast_region_to_region(&icx, &lt, None);\n                         let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound));\n-                        predicates.push((outlives.to_predicate(), lt.span));\n+                        predicates.push((outlives.to_predicate(tcx), lt.span));\n                     }\n                     _ => bug!(),\n                 });"}, {"sha": "3d2785541beead356ebe8452800deb9897fe3a31", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034c25f33e496f602edebd845ddb4f940ac176cf/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=034c25f33e496f602edebd845ddb4f940ac176cf", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         match infcx.evaluate_obligation(&traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            trait_ref.without_const().to_predicate(),\n+                            trait_ref.without_const().to_predicate(infcx.tcx),\n                         )) {\n                             Ok(eval_result) => eval_result.may_apply(),\n                             Err(traits::OverflowError) => true, // overflow doesn't mean yes *or* no"}]}