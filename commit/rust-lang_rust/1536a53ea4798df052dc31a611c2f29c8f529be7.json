{"sha": "1536a53ea4798df052dc31a611c2f29c8f529be7", "node_id": "C_kwDOAAsO6NoAKDE1MzZhNTNlYTQ3OThkZjA1MmRjMzFhNjExYzJmMjljOGY1MjliZTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-29T05:12:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-29T05:12:30Z"}, "message": "Auto merge of #102450 - JohnTitor:rollup-ahleg93, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #98368 (Make `std::os::fd` public.)\n - #102085 (Code refactoring smart_resolve_report_errors)\n - #102351 (Improve E0585 help)\n - #102368 (Add a niche to `Duration`, unix `SystemTime`, and non-apple `Instant`)\n - #102393 (Add regression test for issue 94923)\n - #102399 (Account for use of index-based lifetime names in print of binder)\n - #102416 (remove FIXME, improve documentation)\n - #102433 (env::temp_dir: fix a typo)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9708e8b6f8ad3d9c0a55dfc4234808ceb37aa104", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9708e8b6f8ad3d9c0a55dfc4234808ceb37aa104"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1536a53ea4798df052dc31a611c2f29c8f529be7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1536a53ea4798df052dc31a611c2f29c8f529be7", "html_url": "https://github.com/rust-lang/rust/commit/1536a53ea4798df052dc31a611c2f29c8f529be7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1536a53ea4798df052dc31a611c2f29c8f529be7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf40408165aacd48440e7fba4c1abcf293d8929c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf40408165aacd48440e7fba4c1abcf293d8929c", "html_url": "https://github.com/rust-lang/rust/commit/bf40408165aacd48440e7fba4c1abcf293d8929c"}, {"sha": "5c731cd796820a2968f880468efd1c2996c5efce", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c731cd796820a2968f880468efd1c2996c5efce", "html_url": "https://github.com/rust-lang/rust/commit/5c731cd796820a2968f880468efd1c2996c5efce"}], "stats": {"total": 980, "additions": 591, "deletions": 389}, "files": [{"sha": "13c368d1c58501ab6fbd011d3273985e8c29b6d9", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -245,7 +245,7 @@ parser_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is no\n parser_expected_statement_after_outer_attr = expected statement after outer attribute\n \n parser_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n-    .help = doc comments must come before what they document, maybe a comment was intended with `//`?\n+    .help = doc comments must come before what they document, if a comment was intended use `//`\n     .suggestion = missing comma here\n \n parser_const_let_mutually_exclusive = `const` and `let` are mutually exclusive"}, {"sha": "f69ac0768204a3a832a32d4b1870282d5449f0da", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -2173,10 +2173,16 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n \n         let mut region_index = self.region_index;\n         let mut next_name = |this: &Self| {\n-            let name = name_by_region_index(region_index, &mut available_names, num_available);\n-            debug!(?name);\n-            region_index += 1;\n-            assert!(!this.used_region_names.contains(&name));\n+            let mut name;\n+\n+            loop {\n+                name = name_by_region_index(region_index, &mut available_names, num_available);\n+                region_index += 1;\n+\n+                if !this.used_region_names.contains(&name) {\n+                    break;\n+                }\n+            }\n \n             name\n         };"}, {"sha": "c8a8e00b1fa0368d2fc2f084aceb4e21a6b7caf9", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -760,8 +760,8 @@ impl<'a> Parser<'a> {\n                 )\n                 .span_label(self.token.span, \"this doc comment doesn't document anything\")\n                 .help(\n-                    \"doc comments must come before what they document, maybe a \\\n-                    comment was intended with `//`?\",\n+                    \"doc comments must come before what they document, if a comment was \\\n+                    intended use `//`\",\n                 )\n                 .emit();\n                 self.bump();"}, {"sha": "824cebd7e0a5bfb55f8ff52d59bf9710b89164b6", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 366, "deletions": 247, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -130,6 +130,16 @@ pub(super) enum LifetimeElisionCandidate {\n     Missing(MissingLifetime),\n }\n \n+/// Only used for diagnostics.\n+struct BaseError {\n+    msg: String,\n+    fallback_label: String,\n+    span: Span,\n+    span_label: Option<(Span, &'static str)>,\n+    could_be_expr: bool,\n+    suggestion: Option<(Span, &'static str, String)>,\n+}\n+\n impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     fn def_span(&self, def_id: DefId) -> Option<Span> {\n         match def_id.krate {\n@@ -138,35 +148,18 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n \n-    /// Handles error reporting for `smart_resolve_path_fragment` function.\n-    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n-    pub(crate) fn smart_resolve_report_errors(\n+    fn make_base_error(\n         &mut self,\n         path: &[Segment],\n         span: Span,\n         source: PathSource<'_>,\n         res: Option<Res>,\n-    ) -> (DiagnosticBuilder<'a, ErrorGuaranteed>, Vec<ImportSuggestion>) {\n-        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n-        let ns = source.namespace();\n-        let is_expected = &|res| source.is_expected(res);\n-        let is_enum_variant = &|res| matches!(res, Res::Def(DefKind::Variant, _));\n-\n-        debug!(?res, ?source);\n-\n+    ) -> BaseError {\n         // Make the base error.\n-        struct BaseError<'a> {\n-            msg: String,\n-            fallback_label: String,\n-            span: Span,\n-            span_label: Option<(Span, &'a str)>,\n-            could_be_expr: bool,\n-            suggestion: Option<(Span, &'a str, String)>,\n-        }\n         let mut expected = source.descr_expected();\n         let path_str = Segment::names_to_string(path);\n         let item_str = path.last().unwrap().ident;\n-        let base_error = if let Some(res) = res {\n+        if let Some(res) = res {\n             BaseError {\n                 msg: format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n                 fallback_label: format!(\"not a {expected}\"),\n@@ -277,8 +270,20 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 could_be_expr: false,\n                 suggestion,\n             }\n-        };\n+        }\n+    }\n \n+    /// Handles error reporting for `smart_resolve_path_fragment` function.\n+    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n+    pub(crate) fn smart_resolve_report_errors(\n+        &mut self,\n+        path: &[Segment],\n+        span: Span,\n+        source: PathSource<'_>,\n+        res: Option<Res>,\n+    ) -> (DiagnosticBuilder<'a, ErrorGuaranteed>, Vec<ImportSuggestion>) {\n+        debug!(?res, ?source);\n+        let base_error = self.make_base_error(path, span, source, res);\n         let code = source.error_code(res.is_some());\n         let mut err =\n             self.r.session.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n@@ -289,41 +294,79 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             err.span_label(span, label);\n         }\n \n-        if let Some(sugg) = base_error.suggestion {\n-            err.span_suggestion_verbose(sugg.0, sugg.1, sugg.2, Applicability::MaybeIncorrect);\n+        if let Some(ref sugg) = base_error.suggestion {\n+            err.span_suggestion_verbose(sugg.0, sugg.1, &sugg.2, Applicability::MaybeIncorrect);\n         }\n \n-        if let Some(span) = self.diagnostic_metadata.current_block_could_be_bare_struct_literal {\n-            err.multipart_suggestion(\n-                \"you might have meant to write a `struct` literal\",\n-                vec![\n-                    (span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n-                    (span.shrink_to_hi(), \"}\".to_string()),\n-                ],\n-                Applicability::HasPlaceholders,\n-            );\n+        self.suggest_bare_struct_literal(&mut err);\n+        self.suggest_pattern_match_with_let(&mut err, source, span);\n+\n+        self.suggest_self_or_self_ref(&mut err, path, span);\n+        self.detect_assoct_type_constraint_meant_as_path(&mut err, &base_error);\n+        if self.suggest_self_ty(&mut err, source, path, span)\n+            || self.suggest_self_value(&mut err, source, path, span)\n+        {\n+            return (err, Vec::new());\n         }\n-        match (source, self.diagnostic_metadata.in_if_condition) {\n-            (\n-                PathSource::Expr(_),\n-                Some(Expr { span: expr_span, kind: ExprKind::Assign(lhs, _, _), .. }),\n-            ) => {\n-                // Icky heuristic so we don't suggest:\n-                // `if (i + 2) = 2` => `if let (i + 2) = 2` (approximately pattern)\n-                // `if 2 = i` => `if let 2 = i` (lhs needs to contain error span)\n-                if lhs.is_approximately_pattern() && lhs.span.contains(span) {\n-                    err.span_suggestion_verbose(\n-                        expr_span.shrink_to_lo(),\n-                        \"you might have meant to use pattern matching\",\n-                        \"let \",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+\n+        let (found, candidates) =\n+            self.try_lookup_name_relaxed(&mut err, source, path, span, res, &base_error);\n+        if found {\n+            return (err, candidates);\n+        }\n+\n+        if !self.type_ascription_suggestion(&mut err, base_error.span) {\n+            let mut fallback =\n+                self.suggest_trait_and_bounds(&mut err, source, res, span, &base_error);\n+            fallback |= self.suggest_typo(&mut err, source, path, span, &base_error);\n+            if fallback {\n+                // Fallback label.\n+                err.span_label(base_error.span, &base_error.fallback_label);\n+            }\n+        }\n+        self.err_code_special_cases(&mut err, source, path, span);\n+\n+        (err, candidates)\n+    }\n+\n+    fn detect_assoct_type_constraint_meant_as_path(\n+        &self,\n+        err: &mut Diagnostic,\n+        base_error: &BaseError,\n+    ) {\n+        let Some(ty) = self.diagnostic_metadata.current_type_path else { return; };\n+        let TyKind::Path(_, path) = &ty.kind else { return; };\n+        for segment in &path.segments {\n+            let Some(params) = &segment.args else { continue; };\n+            let ast::GenericArgs::AngleBracketed(ref params) = params.deref() else { continue; };\n+            for param in &params.args {\n+                let ast::AngleBracketedArg::Constraint(constraint) = param else { continue; };\n+                let ast::AssocConstraintKind::Bound { bounds } = &constraint.kind else {\n+                    continue;\n+                };\n+                for bound in bounds {\n+                    let ast::GenericBound::Trait(trait_ref, ast::TraitBoundModifier::None)\n+                        = bound else\n+                    {\n+                        continue;\n+                    };\n+                    if base_error.span == trait_ref.span {\n+                        err.span_suggestion_verbose(\n+                            constraint.ident.span.between(trait_ref.span),\n+                            \"you might have meant to write a path instead of an associated type bound\",\n+                            \"::\",\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n                 }\n             }\n-            _ => {}\n         }\n+    }\n \n+    fn suggest_self_or_self_ref(&mut self, err: &mut Diagnostic, path: &[Segment], span: Span) {\n         let is_assoc_fn = self.self_type_is_available();\n+        let Some(path_last_segment) = path.last() else { return };\n+        let item_str = path_last_segment.ident;\n         // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n         if [\"this\", \"my\"].contains(&item_str.as_str()) && is_assoc_fn {\n             err.span_suggestion_short(\n@@ -358,96 +401,25 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 }\n             }\n         }\n+    }\n \n-        self.detect_assoct_type_constraint_meant_as_path(base_error.span, &mut err);\n-\n-        // Emit special messages for unresolved `Self` and `self`.\n-        if is_self_type(path, ns) {\n-            err.code(rustc_errors::error_code!(E0411));\n-            err.span_label(\n-                span,\n-                \"`Self` is only available in impls, traits, and type definitions\".to_string(),\n-            );\n-            if let Some(item_kind) = self.diagnostic_metadata.current_item {\n-                err.span_label(\n-                    item_kind.ident.span,\n-                    format!(\n-                        \"`Self` not allowed in {} {}\",\n-                        item_kind.kind.article(),\n-                        item_kind.kind.descr()\n-                    ),\n-                );\n-            }\n-            return (err, Vec::new());\n-        }\n-        if is_self_value(path, ns) {\n-            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n-\n-            err.code(rustc_errors::error_code!(E0424));\n-            err.span_label(span, match source {\n-                PathSource::Pat => \"`self` value is a keyword and may not be bound to variables or shadowed\",\n-                _ => \"`self` value is a keyword only available in methods with a `self` parameter\",\n-            });\n-            if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n-                // The current function has a `self' parameter, but we were unable to resolve\n-                // a reference to `self`. This can only happen if the `self` identifier we\n-                // are resolving came from a different hygiene context.\n-                if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {\n-                    err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n-                } else {\n-                    let doesnt = if is_assoc_fn {\n-                        let (span, sugg) = fn_kind\n-                            .decl()\n-                            .inputs\n-                            .get(0)\n-                            .map(|p| (p.span.shrink_to_lo(), \"&self, \"))\n-                            .unwrap_or_else(|| {\n-                                // Try to look for the \"(\" after the function name, if possible.\n-                                // This avoids placing the suggestion into the visibility specifier.\n-                                let span = fn_kind\n-                                    .ident()\n-                                    .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n-                                (\n-                                    self.r\n-                                        .session\n-                                        .source_map()\n-                                        .span_through_char(span, '(')\n-                                        .shrink_to_hi(),\n-                                    \"&self\",\n-                                )\n-                            });\n-                        err.span_suggestion_verbose(\n-                            span,\n-                            \"add a `self` receiver parameter to make the associated `fn` a method\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        \"doesn't\"\n-                    } else {\n-                        \"can't\"\n-                    };\n-                    if let Some(ident) = fn_kind.ident() {\n-                        err.span_label(\n-                            ident.span,\n-                            &format!(\"this function {} have a `self` parameter\", doesnt),\n-                        );\n-                    }\n-                }\n-            } else if let Some(item_kind) = self.diagnostic_metadata.current_item {\n-                err.span_label(\n-                    item_kind.ident.span,\n-                    format!(\n-                        \"`self` not allowed in {} {}\",\n-                        item_kind.kind.article(),\n-                        item_kind.kind.descr()\n-                    ),\n-                );\n-            }\n-            return (err, Vec::new());\n-        }\n-\n+    fn try_lookup_name_relaxed(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+        res: Option<Res>,\n+        base_error: &BaseError,\n+    ) -> (bool, Vec<ImportSuggestion>) {\n         // Try to lookup name in more relaxed fashion for better error reporting.\n         let ident = path.last().unwrap().ident;\n+        let is_expected = &|res| source.is_expected(res);\n+        let ns = source.namespace();\n+        let is_enum_variant = &|res| matches!(res, Res::Def(DefKind::Variant, _));\n+        let path_str = Segment::names_to_string(path);\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n+\n         let mut candidates = self\n             .r\n             .lookup_import_candidates(ident, ns, &self.parent_scope, is_expected)\n@@ -494,7 +466,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     {\n                         // Already reported this issue on the lhs of the type ascription.\n                         err.delay_as_bug();\n-                        return (err, candidates);\n+                        return (true, candidates);\n                     }\n                 }\n \n@@ -522,8 +494,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 );\n             }\n         }\n+\n         // Try Levenshtein algorithm.\n-        let typo_sugg = self.lookup_typo_candidate(path, ns, is_expected);\n+        let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n         if path.len() == 1 && self.self_type_is_available() {\n             if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n                 let self_is_available = self.self_value_is_available(path[0].ident.span);\n@@ -560,8 +533,8 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         );\n                     }\n                 }\n-                self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span);\n-                return (err, candidates);\n+                self.r.add_typo_suggestion(err, typo_sugg, ident_span);\n+                return (true, candidates);\n             }\n \n             // If the first argument in call is `self` suggest calling a method.\n@@ -579,121 +552,150 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     format!(\"self.{path_str}({args_snippet})\"),\n                     Applicability::MachineApplicable,\n                 );\n-                return (err, candidates);\n+                return (true, candidates);\n             }\n         }\n \n         // Try context-dependent help if relaxed lookup didn't work.\n         if let Some(res) = res {\n             if self.smart_resolve_context_dependent_help(\n-                &mut err,\n+                err,\n                 span,\n                 source,\n                 res,\n                 &path_str,\n                 &base_error.fallback_label,\n             ) {\n                 // We do this to avoid losing a secondary span when we override the main error span.\n-                self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span);\n-                return (err, candidates);\n+                self.r.add_typo_suggestion(err, typo_sugg, ident_span);\n+                return (true, candidates);\n             }\n         }\n+        return (false, candidates);\n+    }\n \n+    fn suggest_trait_and_bounds(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        res: Option<Res>,\n+        span: Span,\n+        base_error: &BaseError,\n+    ) -> bool {\n         let is_macro =\n             base_error.span.from_expansion() && base_error.span.desugaring_kind().is_none();\n-        if !self.type_ascription_suggestion(&mut err, base_error.span) {\n-            let mut fallback = false;\n-            if let (\n-                PathSource::Trait(AliasPossibility::Maybe),\n-                Some(Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, _)),\n-                false,\n-            ) = (source, res, is_macro)\n-            {\n-                if let Some(bounds @ [_, .., _]) = self.diagnostic_metadata.current_trait_object {\n-                    fallback = true;\n-                    let spans: Vec<Span> = bounds\n-                        .iter()\n-                        .map(|bound| bound.span())\n-                        .filter(|&sp| sp != base_error.span)\n-                        .collect();\n+        let mut fallback = false;\n \n-                    let start_span = bounds[0].span();\n-                    // `end_span` is the end of the poly trait ref (Foo + 'baz + Bar><)\n-                    let end_span = bounds.last().unwrap().span();\n-                    // `last_bound_span` is the last bound of the poly trait ref (Foo + >'baz< + Bar)\n-                    let last_bound_span = spans.last().cloned().unwrap();\n-                    let mut multi_span: MultiSpan = spans.clone().into();\n-                    for sp in spans {\n-                        let msg = if sp == last_bound_span {\n-                            format!(\n-                                \"...because of {these} bound{s}\",\n-                                these = pluralize!(\"this\", bounds.len() - 1),\n-                                s = pluralize!(bounds.len() - 1),\n-                            )\n-                        } else {\n-                            String::new()\n-                        };\n-                        multi_span.push_span_label(sp, msg);\n-                    }\n-                    multi_span\n-                        .push_span_label(base_error.span, \"expected this type to be a trait...\");\n-                    err.span_help(\n-                        multi_span,\n-                        \"`+` is used to constrain a \\\"trait object\\\" type with lifetimes or \\\n-                         auto-traits; structs and enums can't be bound in that way\",\n-                    );\n-                    if bounds.iter().all(|bound| match bound {\n-                        ast::GenericBound::Outlives(_) => true,\n-                        ast::GenericBound::Trait(tr, _) => tr.span == base_error.span,\n-                    }) {\n-                        let mut sugg = vec![];\n-                        if base_error.span != start_span {\n-                            sugg.push((start_span.until(base_error.span), String::new()));\n-                        }\n-                        if base_error.span != end_span {\n-                            sugg.push((base_error.span.shrink_to_hi().to(end_span), String::new()));\n-                        }\n+        if let (\n+            PathSource::Trait(AliasPossibility::Maybe),\n+            Some(Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, _)),\n+            false,\n+        ) = (source, res, is_macro)\n+        {\n+            if let Some(bounds @ [_, .., _]) = self.diagnostic_metadata.current_trait_object {\n+                fallback = true;\n+                let spans: Vec<Span> = bounds\n+                    .iter()\n+                    .map(|bound| bound.span())\n+                    .filter(|&sp| sp != base_error.span)\n+                    .collect();\n \n-                        err.multipart_suggestion(\n-                            \"if you meant to use a type and not a trait here, remove the bounds\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                let start_span = bounds[0].span();\n+                // `end_span` is the end of the poly trait ref (Foo + 'baz + Bar><)\n+                let end_span = bounds.last().unwrap().span();\n+                // `last_bound_span` is the last bound of the poly trait ref (Foo + >'baz< + Bar)\n+                let last_bound_span = spans.last().cloned().unwrap();\n+                let mut multi_span: MultiSpan = spans.clone().into();\n+                for sp in spans {\n+                    let msg = if sp == last_bound_span {\n+                        format!(\n+                            \"...because of {these} bound{s}\",\n+                            these = pluralize!(\"this\", bounds.len() - 1),\n+                            s = pluralize!(bounds.len() - 1),\n+                        )\n+                    } else {\n+                        String::new()\n+                    };\n+                    multi_span.push_span_label(sp, msg);\n+                }\n+                multi_span.push_span_label(base_error.span, \"expected this type to be a trait...\");\n+                err.span_help(\n+                    multi_span,\n+                    \"`+` is used to constrain a \\\"trait object\\\" type with lifetimes or \\\n+                        auto-traits; structs and enums can't be bound in that way\",\n+                );\n+                if bounds.iter().all(|bound| match bound {\n+                    ast::GenericBound::Outlives(_) => true,\n+                    ast::GenericBound::Trait(tr, _) => tr.span == base_error.span,\n+                }) {\n+                    let mut sugg = vec![];\n+                    if base_error.span != start_span {\n+                        sugg.push((start_span.until(base_error.span), String::new()));\n                     }\n+                    if base_error.span != end_span {\n+                        sugg.push((base_error.span.shrink_to_hi().to(end_span), String::new()));\n+                    }\n+\n+                    err.multipart_suggestion(\n+                        \"if you meant to use a type and not a trait here, remove the bounds\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n+        }\n \n-            fallback |= self.restrict_assoc_type_in_where_clause(span, &mut err);\n+        fallback |= self.restrict_assoc_type_in_where_clause(span, err);\n+        fallback\n+    }\n \n-            if !self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span) {\n-                fallback = true;\n-                match self.diagnostic_metadata.current_let_binding {\n-                    Some((pat_sp, Some(ty_sp), None))\n-                        if ty_sp.contains(base_error.span) && base_error.could_be_expr =>\n-                    {\n-                        err.span_suggestion_short(\n-                            pat_sp.between(ty_sp),\n-                            \"use `=` if you meant to assign\",\n-                            \" = \",\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    _ => {}\n+    fn suggest_typo(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+        base_error: &BaseError,\n+    ) -> bool {\n+        let is_expected = &|res| source.is_expected(res);\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n+        let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n+        let mut fallback = false;\n+        if !self.r.add_typo_suggestion(err, typo_sugg, ident_span) {\n+            fallback = true;\n+            match self.diagnostic_metadata.current_let_binding {\n+                Some((pat_sp, Some(ty_sp), None))\n+                    if ty_sp.contains(base_error.span) && base_error.could_be_expr =>\n+                {\n+                    err.span_suggestion_short(\n+                        pat_sp.between(ty_sp),\n+                        \"use `=` if you meant to assign\",\n+                        \" = \",\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n-\n-                // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n-                let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n-                self.r.add_typo_suggestion(&mut err, suggestion, ident_span);\n-            }\n-            if fallback {\n-                // Fallback label.\n-                err.span_label(base_error.span, base_error.fallback_label);\n+                _ => {}\n             }\n+\n+            // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n+            let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n+            self.r.add_typo_suggestion(err, suggestion, ident_span);\n         }\n+        fallback\n+    }\n+\n+    fn err_code_special_cases(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+    ) {\n         if let Some(err_code) = &err.code {\n             if err_code == &rustc_errors::error_code!(E0425) {\n                 for label_rib in &self.label_ribs {\n                     for (label_ident, node_id) in &label_rib.bindings {\n+                        let ident = path.last().unwrap().ident;\n                         if format!(\"'{}\", ident) == label_ident.to_string() {\n                             err.span_label(label_ident.span, \"a label with a similar name exists\");\n                             if let PathSource::Expr(Some(Expr {\n@@ -724,38 +726,116 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 }\n             }\n         }\n+    }\n \n-        (err, candidates)\n+    /// Emit special messages for unresolved `Self` and `self`.\n+    fn suggest_self_ty(\n+        &mut self,\n+        err: &mut Diagnostic,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+    ) -> bool {\n+        if !is_self_type(path, source.namespace()) {\n+            return false;\n+        }\n+        err.code(rustc_errors::error_code!(E0411));\n+        err.span_label(\n+            span,\n+            \"`Self` is only available in impls, traits, and type definitions\".to_string(),\n+        );\n+        if let Some(item_kind) = self.diagnostic_metadata.current_item {\n+            err.span_label(\n+                item_kind.ident.span,\n+                format!(\n+                    \"`Self` not allowed in {} {}\",\n+                    item_kind.kind.article(),\n+                    item_kind.kind.descr()\n+                ),\n+            );\n+        }\n+        true\n     }\n \n-    fn detect_assoct_type_constraint_meant_as_path(&self, base_span: Span, err: &mut Diagnostic) {\n-        let Some(ty) = self.diagnostic_metadata.current_type_path else { return; };\n-        let TyKind::Path(_, path) = &ty.kind else { return; };\n-        for segment in &path.segments {\n-            let Some(params) = &segment.args else { continue; };\n-            let ast::GenericArgs::AngleBracketed(ref params) = params.deref() else { continue; };\n-            for param in &params.args {\n-                let ast::AngleBracketedArg::Constraint(constraint) = param else { continue; };\n-                let ast::AssocConstraintKind::Bound { bounds } = &constraint.kind else {\n-                    continue;\n+    fn suggest_self_value(\n+        &mut self,\n+        err: &mut Diagnostic,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+    ) -> bool {\n+        if !is_self_value(path, source.namespace()) {\n+            return false;\n+        }\n+\n+        debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n+        err.code(rustc_errors::error_code!(E0424));\n+        err.span_label(\n+            span,\n+            match source {\n+                PathSource::Pat => {\n+                    \"`self` value is a keyword and may not be bound to variables or shadowed\"\n+                }\n+                _ => \"`self` value is a keyword only available in methods with a `self` parameter\",\n+            },\n+        );\n+        let is_assoc_fn = self.self_type_is_available();\n+        if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n+            // The current function has a `self' parameter, but we were unable to resolve\n+            // a reference to `self`. This can only happen if the `self` identifier we\n+            // are resolving came from a different hygiene context.\n+            if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {\n+                err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n+            } else {\n+                let doesnt = if is_assoc_fn {\n+                    let (span, sugg) = fn_kind\n+                        .decl()\n+                        .inputs\n+                        .get(0)\n+                        .map(|p| (p.span.shrink_to_lo(), \"&self, \"))\n+                        .unwrap_or_else(|| {\n+                            // Try to look for the \"(\" after the function name, if possible.\n+                            // This avoids placing the suggestion into the visibility specifier.\n+                            let span = fn_kind\n+                                .ident()\n+                                .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n+                            (\n+                                self.r\n+                                    .session\n+                                    .source_map()\n+                                    .span_through_char(span, '(')\n+                                    .shrink_to_hi(),\n+                                \"&self\",\n+                            )\n+                        });\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        \"add a `self` receiver parameter to make the associated `fn` a method\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    \"doesn't\"\n+                } else {\n+                    \"can't\"\n                 };\n-                for bound in bounds {\n-                    let ast::GenericBound::Trait(trait_ref, ast::TraitBoundModifier::None)\n-                        = bound else\n-                    {\n-                        continue;\n-                    };\n-                    if base_span == trait_ref.span {\n-                        err.span_suggestion_verbose(\n-                            constraint.ident.span.between(trait_ref.span),\n-                            \"you might have meant to write a path instead of an associated type bound\",\n-                            \"::\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+                if let Some(ident) = fn_kind.ident() {\n+                    err.span_label(\n+                        ident.span,\n+                        &format!(\"this function {} have a `self` parameter\", doesnt),\n+                    );\n                 }\n             }\n+        } else if let Some(item_kind) = self.diagnostic_metadata.current_item {\n+            err.span_label(\n+                item_kind.ident.span,\n+                format!(\n+                    \"`self` not allowed in {} {}\",\n+                    item_kind.kind.article(),\n+                    item_kind.kind.descr()\n+                ),\n+            );\n         }\n+        true\n     }\n \n     fn suggest_swapping_misplaced_self_ty_and_trait(\n@@ -787,6 +867,45 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n \n+    fn suggest_bare_struct_literal(&mut self, err: &mut Diagnostic) {\n+        if let Some(span) = self.diagnostic_metadata.current_block_could_be_bare_struct_literal {\n+            err.multipart_suggestion(\n+                \"you might have meant to write a `struct` literal\",\n+                vec![\n+                    (span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n+                    (span.shrink_to_hi(), \"}\".to_string()),\n+                ],\n+                Applicability::HasPlaceholders,\n+            );\n+        }\n+    }\n+\n+    fn suggest_pattern_match_with_let(\n+        &mut self,\n+        err: &mut Diagnostic,\n+        source: PathSource<'_>,\n+        span: Span,\n+    ) {\n+        if let PathSource::Expr(_) = source &&\n+        let Some(Expr {\n+                    span: expr_span,\n+                    kind: ExprKind::Assign(lhs, _, _),\n+                    ..\n+                })  = self.diagnostic_metadata.in_if_condition {\n+            // Icky heuristic so we don't suggest:\n+            // `if (i + 2) = 2` => `if let (i + 2) = 2` (approximately pattern)\n+            // `if 2 = i` => `if let 2 = i` (lhs needs to contain error span)\n+            if lhs.is_approximately_pattern() && lhs.span.contains(span) {\n+                err.span_suggestion_verbose(\n+                    expr_span.shrink_to_lo(),\n+                    \"you might have meant to use pattern matching\",\n+                    \"let \",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+\n     fn get_single_associated_item(\n         &mut self,\n         path: &[Segment],"}, {"sha": "0ed59223337a5951a20c99e90bc3a42dd8a896c0", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -1737,12 +1737,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             (&ImplCandidate(other_def), &ImplCandidate(victim_def)) => {\n                 // See if we can toss out `victim` based on specialization.\n-                // This requires us to know *for sure* that the `other` impl applies\n-                // i.e., `EvaluatedToOk`.\n+                // While this requires us to know *for sure* that the `other` impl applies\n+                // we still use modulo regions here.\n                 //\n-                // FIXME(@lcnr): Using `modulo_regions` here seems kind of scary\n-                // to me but is required for `std` to compile, so I didn't change it\n-                // for now.\n+                // This is fine as specialization currently assumes that specializing\n+                // impls have to be always applicable, meaning that the only allowed\n+                // region constraints may be constraints also present on the default impl.\n                 let tcx = self.tcx();\n                 if other.evaluation.must_apply_modulo_regions() {\n                     if tcx.specializes((other_def, victim_def)) {"}, {"sha": "2b85d6e22258ffd8ce4a0afc40fb9fefe0a609bb", "filename": "library/core/src/time.rs", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -29,6 +29,20 @@ const NANOS_PER_MICRO: u32 = 1_000;\n const MILLIS_PER_SEC: u64 = 1_000;\n const MICROS_PER_SEC: u64 = 1_000_000;\n \n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(0)]\n+#[rustc_layout_scalar_valid_range_end(999_999_999)]\n+struct Nanoseconds(u32);\n+\n+impl Default for Nanoseconds {\n+    #[inline]\n+    fn default() -> Self {\n+        // SAFETY: 0 is within the valid range\n+        unsafe { Nanoseconds(0) }\n+    }\n+}\n+\n /// A `Duration` type to represent a span of time, typically used for system\n /// timeouts.\n ///\n@@ -71,7 +85,7 @@ const MICROS_PER_SEC: u64 = 1_000_000;\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Duration\")]\n pub struct Duration {\n     secs: u64,\n-    nanos: u32, // Always 0 <= nanos < NANOS_PER_SEC\n+    nanos: Nanoseconds, // Always 0 <= nanos < NANOS_PER_SEC\n }\n \n impl Duration {\n@@ -188,7 +202,8 @@ impl Duration {\n             None => panic!(\"overflow in Duration::new\"),\n         };\n         let nanos = nanos % NANOS_PER_SEC;\n-        Duration { secs, nanos }\n+        // SAFETY: nanos % NANOS_PER_SEC < NANOS_PER_SEC, therefore nanos is within the valid range\n+        Duration { secs, nanos: unsafe { Nanoseconds(nanos) } }\n     }\n \n     /// Creates a new `Duration` from the specified number of whole seconds.\n@@ -208,7 +223,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     pub const fn from_secs(secs: u64) -> Duration {\n-        Duration { secs, nanos: 0 }\n+        Duration::new(secs, 0)\n     }\n \n     /// Creates a new `Duration` from the specified number of milliseconds.\n@@ -228,10 +243,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     pub const fn from_millis(millis: u64) -> Duration {\n-        Duration {\n-            secs: millis / MILLIS_PER_SEC,\n-            nanos: ((millis % MILLIS_PER_SEC) as u32) * NANOS_PER_MILLI,\n-        }\n+        Duration::new(millis / MILLIS_PER_SEC, ((millis % MILLIS_PER_SEC) as u32) * NANOS_PER_MILLI)\n     }\n \n     /// Creates a new `Duration` from the specified number of microseconds.\n@@ -251,10 +263,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     pub const fn from_micros(micros: u64) -> Duration {\n-        Duration {\n-            secs: micros / MICROS_PER_SEC,\n-            nanos: ((micros % MICROS_PER_SEC) as u32) * NANOS_PER_MICRO,\n-        }\n+        Duration::new(micros / MICROS_PER_SEC, ((micros % MICROS_PER_SEC) as u32) * NANOS_PER_MICRO)\n     }\n \n     /// Creates a new `Duration` from the specified number of nanoseconds.\n@@ -274,10 +283,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     pub const fn from_nanos(nanos: u64) -> Duration {\n-        Duration {\n-            secs: nanos / (NANOS_PER_SEC as u64),\n-            nanos: (nanos % (NANOS_PER_SEC as u64)) as u32,\n-        }\n+        Duration::new(nanos / (NANOS_PER_SEC as u64), (nanos % (NANOS_PER_SEC as u64)) as u32)\n     }\n \n     /// Returns true if this `Duration` spans no time.\n@@ -301,7 +307,7 @@ impl Duration {\n     #[rustc_const_stable(feature = \"duration_zero\", since = \"1.53.0\")]\n     #[inline]\n     pub const fn is_zero(&self) -> bool {\n-        self.secs == 0 && self.nanos == 0\n+        self.secs == 0 && self.nanos.0 == 0\n     }\n \n     /// Returns the number of _whole_ seconds contained by this `Duration`.\n@@ -352,7 +358,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn subsec_millis(&self) -> u32 {\n-        self.nanos / NANOS_PER_MILLI\n+        self.nanos.0 / NANOS_PER_MILLI\n     }\n \n     /// Returns the fractional part of this `Duration`, in whole microseconds.\n@@ -375,7 +381,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn subsec_micros(&self) -> u32 {\n-        self.nanos / NANOS_PER_MICRO\n+        self.nanos.0 / NANOS_PER_MICRO\n     }\n \n     /// Returns the fractional part of this `Duration`, in nanoseconds.\n@@ -398,7 +404,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn subsec_nanos(&self) -> u32 {\n-        self.nanos\n+        self.nanos.0\n     }\n \n     /// Returns the total number of whole milliseconds contained by this `Duration`.\n@@ -416,7 +422,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn as_millis(&self) -> u128 {\n-        self.secs as u128 * MILLIS_PER_SEC as u128 + (self.nanos / NANOS_PER_MILLI) as u128\n+        self.secs as u128 * MILLIS_PER_SEC as u128 + (self.nanos.0 / NANOS_PER_MILLI) as u128\n     }\n \n     /// Returns the total number of whole microseconds contained by this `Duration`.\n@@ -434,7 +440,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn as_micros(&self) -> u128 {\n-        self.secs as u128 * MICROS_PER_SEC as u128 + (self.nanos / NANOS_PER_MICRO) as u128\n+        self.secs as u128 * MICROS_PER_SEC as u128 + (self.nanos.0 / NANOS_PER_MICRO) as u128\n     }\n \n     /// Returns the total number of nanoseconds contained by this `Duration`.\n@@ -452,7 +458,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn as_nanos(&self) -> u128 {\n-        self.secs as u128 * NANOS_PER_SEC as u128 + self.nanos as u128\n+        self.secs as u128 * NANOS_PER_SEC as u128 + self.nanos.0 as u128\n     }\n \n     /// Checked `Duration` addition. Computes `self + other`, returning [`None`]\n@@ -475,7 +481,7 @@ impl Duration {\n     #[rustc_const_stable(feature = \"duration_consts_2\", since = \"1.58.0\")]\n     pub const fn checked_add(self, rhs: Duration) -> Option<Duration> {\n         if let Some(mut secs) = self.secs.checked_add(rhs.secs) {\n-            let mut nanos = self.nanos + rhs.nanos;\n+            let mut nanos = self.nanos.0 + rhs.nanos.0;\n             if nanos >= NANOS_PER_SEC {\n                 nanos -= NANOS_PER_SEC;\n                 if let Some(new_secs) = secs.checked_add(1) {\n@@ -485,7 +491,7 @@ impl Duration {\n                 }\n             }\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration { secs, nanos })\n+            Some(Duration::new(secs, nanos))\n         } else {\n             None\n         }\n@@ -535,16 +541,16 @@ impl Duration {\n     #[rustc_const_stable(feature = \"duration_consts_2\", since = \"1.58.0\")]\n     pub const fn checked_sub(self, rhs: Duration) -> Option<Duration> {\n         if let Some(mut secs) = self.secs.checked_sub(rhs.secs) {\n-            let nanos = if self.nanos >= rhs.nanos {\n-                self.nanos - rhs.nanos\n+            let nanos = if self.nanos.0 >= rhs.nanos.0 {\n+                self.nanos.0 - rhs.nanos.0\n             } else if let Some(sub_secs) = secs.checked_sub(1) {\n                 secs = sub_secs;\n-                self.nanos + NANOS_PER_SEC - rhs.nanos\n+                self.nanos.0 + NANOS_PER_SEC - rhs.nanos.0\n             } else {\n                 return None;\n             };\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration { secs, nanos })\n+            Some(Duration::new(secs, nanos))\n         } else {\n             None\n         }\n@@ -593,13 +599,13 @@ impl Duration {\n     #[rustc_const_stable(feature = \"duration_consts_2\", since = \"1.58.0\")]\n     pub const fn checked_mul(self, rhs: u32) -> Option<Duration> {\n         // Multiply nanoseconds as u64, because it cannot overflow that way.\n-        let total_nanos = self.nanos as u64 * rhs as u64;\n+        let total_nanos = self.nanos.0 as u64 * rhs as u64;\n         let extra_secs = total_nanos / (NANOS_PER_SEC as u64);\n         let nanos = (total_nanos % (NANOS_PER_SEC as u64)) as u32;\n         if let Some(s) = self.secs.checked_mul(rhs as u64) {\n             if let Some(secs) = s.checked_add(extra_secs) {\n                 debug_assert!(nanos < NANOS_PER_SEC);\n-                return Some(Duration { secs, nanos });\n+                return Some(Duration::new(secs, nanos));\n             }\n         }\n         None\n@@ -653,9 +659,9 @@ impl Duration {\n             let secs = self.secs / (rhs as u64);\n             let carry = self.secs - secs * (rhs as u64);\n             let extra_nanos = carry * (NANOS_PER_SEC as u64) / (rhs as u64);\n-            let nanos = self.nanos / rhs + (extra_nanos as u32);\n+            let nanos = self.nanos.0 / rhs + (extra_nanos as u32);\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration { secs, nanos })\n+            Some(Duration::new(secs, nanos))\n         } else {\n             None\n         }\n@@ -677,7 +683,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n     pub const fn as_secs_f64(&self) -> f64 {\n-        (self.secs as f64) + (self.nanos as f64) / (NANOS_PER_SEC as f64)\n+        (self.secs as f64) + (self.nanos.0 as f64) / (NANOS_PER_SEC as f64)\n     }\n \n     /// Returns the number of seconds contained by this `Duration` as `f32`.\n@@ -696,7 +702,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n     pub const fn as_secs_f32(&self) -> f32 {\n-        (self.secs as f32) + (self.nanos as f32) / (NANOS_PER_SEC as f32)\n+        (self.secs as f32) + (self.nanos.0 as f32) / (NANOS_PER_SEC as f32)\n     }\n \n     /// Creates a new `Duration` from the specified number of seconds represented\n@@ -987,21 +993,21 @@ macro_rules! sum_durations {\n         for entry in $iter {\n             total_secs =\n                 total_secs.checked_add(entry.secs).expect(\"overflow in iter::sum over durations\");\n-            total_nanos = match total_nanos.checked_add(entry.nanos as u64) {\n+            total_nanos = match total_nanos.checked_add(entry.nanos.0 as u64) {\n                 Some(n) => n,\n                 None => {\n                     total_secs = total_secs\n                         .checked_add(total_nanos / NANOS_PER_SEC as u64)\n                         .expect(\"overflow in iter::sum over durations\");\n-                    (total_nanos % NANOS_PER_SEC as u64) + entry.nanos as u64\n+                    (total_nanos % NANOS_PER_SEC as u64) + entry.nanos.0 as u64\n                 }\n             };\n         }\n         total_secs = total_secs\n             .checked_add(total_nanos / NANOS_PER_SEC as u64)\n             .expect(\"overflow in iter::sum over durations\");\n         total_nanos = total_nanos % NANOS_PER_SEC as u64;\n-        Duration { secs: total_secs, nanos: total_nanos as u32 }\n+        Duration::new(total_secs, total_nanos as u32)\n     }};\n }\n \n@@ -1166,27 +1172,27 @@ impl fmt::Debug for Duration {\n         let prefix = if f.sign_plus() { \"+\" } else { \"\" };\n \n         if self.secs > 0 {\n-            fmt_decimal(f, self.secs, self.nanos, NANOS_PER_SEC / 10, prefix, \"s\")\n-        } else if self.nanos >= NANOS_PER_MILLI {\n+            fmt_decimal(f, self.secs, self.nanos.0, NANOS_PER_SEC / 10, prefix, \"s\")\n+        } else if self.nanos.0 >= NANOS_PER_MILLI {\n             fmt_decimal(\n                 f,\n-                (self.nanos / NANOS_PER_MILLI) as u64,\n-                self.nanos % NANOS_PER_MILLI,\n+                (self.nanos.0 / NANOS_PER_MILLI) as u64,\n+                self.nanos.0 % NANOS_PER_MILLI,\n                 NANOS_PER_MILLI / 10,\n                 prefix,\n                 \"ms\",\n             )\n-        } else if self.nanos >= NANOS_PER_MICRO {\n+        } else if self.nanos.0 >= NANOS_PER_MICRO {\n             fmt_decimal(\n                 f,\n-                (self.nanos / NANOS_PER_MICRO) as u64,\n-                self.nanos % NANOS_PER_MICRO,\n+                (self.nanos.0 / NANOS_PER_MICRO) as u64,\n+                self.nanos.0 % NANOS_PER_MICRO,\n                 NANOS_PER_MICRO / 10,\n                 prefix,\n                 \"\u00b5s\",\n             )\n         } else {\n-            fmt_decimal(f, self.nanos as u64, 0, 1, prefix, \"ns\")\n+            fmt_decimal(f, self.nanos.0 as u64, 0, 1, prefix, \"ns\")\n         }\n     }\n }\n@@ -1317,7 +1323,7 @@ macro_rules! try_from_secs {\n             return Err(FromFloatSecsError { kind: FromFloatSecsErrorKind::OverflowOrNan });\n         };\n \n-        Ok(Duration { secs, nanos })\n+        Ok(Duration::new(secs, nanos))\n     }};\n }\n "}, {"sha": "6eb7cbea6269d7c92531fe00f1cb6a7edccb7f26", "filename": "library/std/src/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fenv.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -603,7 +603,7 @@ pub fn home_dir() -> Option<PathBuf> {\n /// # Platform-specific behavior\n ///\n /// On Unix, returns the value of the `TMPDIR` environment variable if it is\n-/// set, otherwise for non-Android it returns `/tmp`. If Android, since there\n+/// set, otherwise for non-Android it returns `/tmp`. On Android, since there\n /// is no global temporary folder (it is usually allocated per-app), it returns\n /// `/data/local/tmp`.\n /// On Windows, the behavior is equivalent to that of [`GetTempPath2`][GetTempPath2] /"}, {"sha": "c6aa7c77dbc41d74ff1fb776de1d82c13be3a8bc", "filename": "library/std/src/os/fd/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -1,16 +1,25 @@\n //! Owned and borrowed Unix-like file descriptors.\n+//!\n+//! This module is supported on Unix platforms and WASI, which both use a\n+//! similar file descriptor system for referencing OS resources.\n \n #![stable(feature = \"io_safety\", since = \"1.63.0\")]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n // `RawFd`, `AsRawFd`, etc.\n-pub mod raw;\n+mod raw;\n \n // `OwnedFd`, `AsFd`, etc.\n-pub mod owned;\n+mod owned;\n \n // Implementations for `AsRawFd` etc. for network types.\n mod net;\n \n #[cfg(test)]\n mod tests;\n+\n+// Export the types and traits for the public API.\n+#[unstable(feature = \"os_fd\", issue = \"98699\")]\n+pub use owned::*;\n+#[unstable(feature = \"os_fd\", issue = \"98699\")]\n+pub use raw::*;"}, {"sha": "9875c389d8aaf7273b7f0812f3f9217cc0ea13df", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -206,10 +206,8 @@ pub trait AsFd {\n     /// ```rust,no_run\n     /// use std::fs::File;\n     /// # use std::io;\n-    /// # #[cfg(target_os = \"wasi\")]\n-    /// # use std::os::wasi::io::{AsFd, BorrowedFd};\n-    /// # #[cfg(unix)]\n-    /// # use std::os::unix::io::{AsFd, BorrowedFd};\n+    /// # #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// # use std::os::fd::{AsFd, BorrowedFd};\n     ///\n     /// let mut f = File::open(\"foo.txt\")?;\n     /// # #[cfg(any(unix, target_os = \"wasi\"))]"}, {"sha": "f92a05066706d276cb98599992d518e37ee4b6a4", "filename": "library/std/src/os/fd/raw.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -42,10 +42,8 @@ pub trait AsRawFd {\n     /// ```no_run\n     /// use std::fs::File;\n     /// # use std::io;\n-    /// #[cfg(unix)]\n-    /// use std::os::unix::io::{AsRawFd, RawFd};\n-    /// #[cfg(target_os = \"wasi\")]\n-    /// use std::os::wasi::io::{AsRawFd, RawFd};\n+    /// #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// use std::os::fd::{AsRawFd, RawFd};\n     ///\n     /// let mut f = File::open(\"foo.txt\")?;\n     /// // Note that `raw_fd` is only valid as long as `f` exists.\n@@ -83,10 +81,8 @@ pub trait FromRawFd {\n     /// ```no_run\n     /// use std::fs::File;\n     /// # use std::io;\n-    /// #[cfg(unix)]\n-    /// use std::os::unix::io::{FromRawFd, IntoRawFd, RawFd};\n-    /// #[cfg(target_os = \"wasi\")]\n-    /// use std::os::wasi::io::{FromRawFd, IntoRawFd, RawFd};\n+    /// #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// use std::os::fd::{FromRawFd, IntoRawFd, RawFd};\n     ///\n     /// let f = File::open(\"foo.txt\")?;\n     /// # #[cfg(any(unix, target_os = \"wasi\"))]\n@@ -121,10 +117,8 @@ pub trait IntoRawFd {\n     /// ```no_run\n     /// use std::fs::File;\n     /// # use std::io;\n-    /// #[cfg(unix)]\n-    /// use std::os::unix::io::{IntoRawFd, RawFd};\n-    /// #[cfg(target_os = \"wasi\")]\n-    /// use std::os::wasi::io::{IntoRawFd, RawFd};\n+    /// #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// use std::os::fd::{IntoRawFd, RawFd};\n     ///\n     /// let f = File::open(\"foo.txt\")?;\n     /// #[cfg(any(unix, target_os = \"wasi\"))]"}, {"sha": "f62f5af774f0e4a171000d2394613dc916dde08f", "filename": "library/std/src/os/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmod.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -147,7 +147,7 @@ pub mod solid;\n pub mod vxworks;\n \n #[cfg(any(unix, target_os = \"wasi\", doc))]\n-mod fd;\n+pub mod fd;\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\", doc))]\n mod net;"}, {"sha": "d4cb696459b7e6c3f0f91ddc93fe2d729a8bea08", "filename": "library/std/src/os/unix/io/fd.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf40408165aacd48440e7fba4c1abcf293d8929c/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf40408165aacd48440e7fba4c1abcf293d8929c/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd.rs?ref=bf40408165aacd48440e7fba4c1abcf293d8929c", "patch": "@@ -1,8 +0,0 @@\n-//! Owned and borrowed file descriptors.\n-\n-// Tests for this module\n-#[cfg(test)]\n-mod tests;\n-\n-#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n-pub use crate::os::fd::owned::*;"}, {"sha": "25b5dbff14f309d185d79f833ea419981586dc0d", "filename": "library/std/src/os/unix/io/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -77,10 +77,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-mod fd;\n-mod raw;\n-\n-#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n-pub use fd::*;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use raw::*;\n+pub use crate::os::fd::*;\n+\n+// Tests for this module\n+#[cfg(test)]\n+mod tests;"}, {"sha": "a4d2ba797d9c470362bb82916cdb52e333aac634", "filename": "library/std/src/os/unix/io/raw.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf40408165aacd48440e7fba4c1abcf293d8929c/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf40408165aacd48440e7fba4c1abcf293d8929c/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fraw.rs?ref=bf40408165aacd48440e7fba4c1abcf293d8929c", "patch": "@@ -1,6 +0,0 @@\n-//! Unix-specific extensions to general I/O primitives.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use crate::os::fd::raw::*;"}, {"sha": "84d2a7a1a91b4f391f5c79161708c01664d93273", "filename": "library/std/src/os/unix/io/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ftests.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "previous_filename": "library/std/src/os/unix/io/fd/tests.rs"}, {"sha": "d528590d75b9ab6c37673ef48eb1cee89c5ae262", "filename": "library/std/src/os/wasi/io/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Fmod.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -1,12 +1,6 @@\n //! WASI-specific extensions to general I/O primitives.\n \n-#![deny(unsafe_op_in_unsafe_fn)]\n #![unstable(feature = \"wasi_ext\", issue = \"71213\")]\n \n-mod fd;\n-mod raw;\n-\n-#[unstable(feature = \"wasi_ext\", issue = \"71213\")]\n-pub use fd::*;\n #[unstable(feature = \"wasi_ext\", issue = \"71213\")]\n-pub use raw::*;\n+pub use crate::os::fd::*;"}, {"sha": "cca9c67670161161522d930666161cac896e7596", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -6,6 +6,12 @@ pub use self::inner::Instant;\n const NSEC_PER_SEC: u64 = 1_000_000_000;\n pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n \n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(0)]\n+#[rustc_layout_scalar_valid_range_end(999_999_999)]\n+struct Nanoseconds(u32);\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct SystemTime {\n     pub(in crate::sys::unix) t: Timespec,\n@@ -14,7 +20,7 @@ pub struct SystemTime {\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub(in crate::sys::unix) struct Timespec {\n     tv_sec: i64,\n-    tv_nsec: i64,\n+    tv_nsec: Nanoseconds,\n }\n \n impl SystemTime {\n@@ -46,18 +52,20 @@ impl fmt::Debug for SystemTime {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"SystemTime\")\n             .field(\"tv_sec\", &self.t.tv_sec)\n-            .field(\"tv_nsec\", &self.t.tv_nsec)\n+            .field(\"tv_nsec\", &self.t.tv_nsec.0)\n             .finish()\n     }\n }\n \n impl Timespec {\n     pub const fn zero() -> Timespec {\n-        Timespec { tv_sec: 0, tv_nsec: 0 }\n+        Timespec::new(0, 0)\n     }\n \n-    fn new(tv_sec: i64, tv_nsec: i64) -> Timespec {\n-        Timespec { tv_sec, tv_nsec }\n+    const fn new(tv_sec: i64, tv_nsec: i64) -> Timespec {\n+        assert!(tv_nsec >= 0 && tv_nsec < NSEC_PER_SEC as i64);\n+        // SAFETY: The assert above checks tv_nsec is within the valid range\n+        Timespec { tv_sec, tv_nsec: unsafe { Nanoseconds(tv_nsec as u32) } }\n     }\n \n     pub fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n@@ -75,12 +83,12 @@ impl Timespec {\n             //\n             // Ideally this code could be rearranged such that it more\n             // directly expresses the lower-cost behavior we want from it.\n-            let (secs, nsec) = if self.tv_nsec >= other.tv_nsec {\n-                ((self.tv_sec - other.tv_sec) as u64, (self.tv_nsec - other.tv_nsec) as u32)\n+            let (secs, nsec) = if self.tv_nsec.0 >= other.tv_nsec.0 {\n+                ((self.tv_sec - other.tv_sec) as u64, self.tv_nsec.0 - other.tv_nsec.0)\n             } else {\n                 (\n                     (self.tv_sec - other.tv_sec - 1) as u64,\n-                    self.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.tv_nsec as u32,\n+                    self.tv_nsec.0 + (NSEC_PER_SEC as u32) - other.tv_nsec.0,\n                 )\n             };\n \n@@ -102,7 +110,7 @@ impl Timespec {\n \n         // Nano calculations can't overflow because nanos are <1B which fit\n         // in a u32.\n-        let mut nsec = other.subsec_nanos() + self.tv_nsec as u32;\n+        let mut nsec = other.subsec_nanos() + self.tv_nsec.0;\n         if nsec >= NSEC_PER_SEC as u32 {\n             nsec -= NSEC_PER_SEC as u32;\n             secs = secs.checked_add(1)?;\n@@ -118,7 +126,7 @@ impl Timespec {\n             .and_then(|secs| self.tv_sec.checked_sub(secs))?;\n \n         // Similar to above, nanos can't overflow.\n-        let mut nsec = self.tv_nsec as i32 - other.subsec_nanos() as i32;\n+        let mut nsec = self.tv_nsec.0 as i32 - other.subsec_nanos() as i32;\n         if nsec < 0 {\n             nsec += NSEC_PER_SEC as i32;\n             secs = secs.checked_sub(1)?;\n@@ -130,7 +138,7 @@ impl Timespec {\n     pub fn to_timespec(&self) -> Option<libc::timespec> {\n         Some(libc::timespec {\n             tv_sec: self.tv_sec.try_into().ok()?,\n-            tv_nsec: self.tv_nsec.try_into().ok()?,\n+            tv_nsec: self.tv_nsec.0.try_into().ok()?,\n         })\n     }\n }\n@@ -293,7 +301,7 @@ mod inner {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             f.debug_struct(\"Instant\")\n                 .field(\"tv_sec\", &self.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.tv_nsec)\n+                .field(\"tv_nsec\", &self.t.tv_nsec.0)\n                 .finish()\n         }\n     }\n@@ -334,7 +342,7 @@ mod inner {\n                     let mut t = MaybeUninit::uninit();\n                     cvt(unsafe { clock_gettime64(clock, t.as_mut_ptr()) }).unwrap();\n                     let t = unsafe { t.assume_init() };\n-                    return Timespec { tv_sec: t.tv_sec, tv_nsec: t.tv_nsec as i64 };\n+                    return Timespec::new(t.tv_sec, t.tv_nsec as i64);\n                 }\n             }\n "}, {"sha": "624d8cc5cc55a942d77d40494678922c113fd925", "filename": "src/etc/natvis/libcore.natvis", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Fetc%2Fnatvis%2Flibcore.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Fetc%2Fnatvis%2Flibcore.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibcore.natvis?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -154,10 +154,10 @@\n   </Type>\n \n   <Type Name=\"core::time::Duration\">\n-    <DisplayString>{secs,d}s {nanos,d}ns</DisplayString>\n+    <DisplayString>{secs,d}s {nanos.__0,d}ns</DisplayString>\n     <Expand>\n       <Item Name=\"seconds\">secs,d</Item>\n-      <Item Name=\"nanoseconds\">nanos,d</Item>\n+      <Item Name=\"nanoseconds\">nanos.__0,d</Item>\n     </Expand>\n   </Type>\n </AutoVisualizer>"}, {"sha": "369a34f9c6eb7e64f318bba62cb2ce8f7c67c580", "filename": "src/test/rustdoc-js-std/asrawfd.js", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Frustdoc-js-std%2Fasrawfd.js", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Frustdoc-js-std%2Fasrawfd.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fasrawfd.js?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -6,9 +6,9 @@ const EXPECTED = {\n     'others': [\n         // Reproduction test for https://github.com/rust-lang/rust/issues/78724\n         // Validate that type alias methods get the correct path.\n-        { 'path': 'std::os::unix::io::AsRawFd', 'name': 'as_raw_fd' },\n-        { 'path': 'std::os::wasi::io::AsRawFd', 'name': 'as_raw_fd' },\n+        { 'path': 'std::os::fd::AsRawFd', 'name': 'as_raw_fd' },\n+        { 'path': 'std::os::fd::AsRawFd', 'name': 'as_raw_fd' },\n         { 'path': 'std::os::linux::process::PidFd', 'name': 'as_raw_fd' },\n-        { 'path': 'std::os::unix::io::RawFd', 'name': 'as_raw_fd' },\n+        { 'path': 'std::os::fd::RawFd', 'name': 'as_raw_fd' },\n     ],\n };"}, {"sha": "53c82fb416b81f3f0fbff11b2556c25b01fbe80f", "filename": "src/test/ui/error-codes/E0585.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Ferror-codes%2FE0585.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Ferror-codes%2FE0585.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0585.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -4,7 +4,7 @@ error[E0585]: found a documentation comment that doesn't document anything\n LL |     /// Hello! I'm useless...\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error: aborting due to previous error\n "}, {"sha": "d337a5dffc934116d1c490f8520c980318e728cc", "filename": "src/test/ui/generics/issue-94923.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fgenerics%2Fissue-94923.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fgenerics%2Fissue-94923.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-94923.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -0,0 +1,49 @@\n+// run-pass\n+// regression test for issue #94923\n+// min-llvm-version: 15.0.0\n+// compile-flags: -C opt-level=3\n+\n+fn f0<T>(mut x: usize) -> usize {\n+    for _ in 0..1000 {\n+        x *= 123;\n+        x %= 99\n+    }\n+    x + 321 // function composition is not just longer iteration\n+}\n+\n+fn f1<T>(x: usize) -> usize {\n+    f0::<(i8, T)>(f0::<(u8, T)>(x))\n+}\n+\n+fn f2<T>(x: usize) -> usize {\n+    f1::<(i8, T)>(f1::<(u8, T)>(x))\n+}\n+\n+fn f3<T>(x: usize) -> usize {\n+    f2::<(i8, T)>(f2::<(u8, T)>(x))\n+}\n+\n+fn f4<T>(x: usize) -> usize {\n+    f3::<(i8, T)>(f3::<(u8, T)>(x))\n+}\n+\n+fn f5<T>(x: usize) -> usize {\n+    f4::<(i8, T)>(f4::<(u8, T)>(x))\n+}\n+\n+fn f6<T>(x: usize) -> usize {\n+    f5::<(i8, T)>(f5::<(u8, T)>(x))\n+}\n+\n+fn f7<T>(x: usize) -> usize {\n+    f6::<(i8, T)>(f6::<(u8, T)>(x))\n+}\n+\n+fn f8<T>(x: usize) -> usize {\n+    f7::<(i8, T)>(f7::<(u8, T)>(x))\n+}\n+\n+fn main() {\n+    let y = f8::<()>(1);\n+    assert_eq!(y, 348);\n+}"}, {"sha": "03faa6733e21feaceba53a6f4bcb2f94251a77df", "filename": "src/test/ui/parser/doc-after-struct-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-after-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-after-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-after-struct-field.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -1,13 +1,13 @@\n struct X {\n     a: u8 /** document a */,\n     //~^ ERROR found a documentation comment that doesn't document anything\n-    //~| HELP maybe a comment was intended\n+    //~| HELP if a comment was intended use `//`\n }\n \n struct Y {\n     a: u8 /// document a\n     //~^ ERROR found a documentation comment that doesn't document anything\n-    //~| HELP maybe a comment was intended\n+    //~| HELP if a comment was intended use `//`\n }\n \n fn main() {"}, {"sha": "ae177f1a2d1ebbb2cd11afd8561233b8c39cd252", "filename": "src/test/ui/parser/doc-after-struct-field.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-after-struct-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-after-struct-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-after-struct-field.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -4,15 +4,15 @@ error[E0585]: found a documentation comment that doesn't document anything\n LL |     a: u8 /** document a */,\n    |           ^^^^^^^^^^^^^^^^^\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error[E0585]: found a documentation comment that doesn't document anything\n   --> $DIR/doc-after-struct-field.rs:8:11\n    |\n LL |     a: u8 /// document a\n    |           ^^^^^^^^^^^^^^\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8fa12ec261e0996c600d41eec24d52cf2c691fd4", "filename": "src/test/ui/parser/doc-before-extern-rbrace.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -4,7 +4,7 @@ error[E0584]: found a documentation comment that doesn't document anything\n LL |     /// hi\n    |     ^^^^^^ this doc comment doesn't document anything\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error: aborting due to previous error\n "}, {"sha": "c8502164854521af2287b758f5c2f5795bb07405", "filename": "src/test/ui/parser/doc-before-fn-rbrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-fn-rbrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-fn-rbrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-fn-rbrace.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     /// document\n     //~^ ERROR found a documentation comment that doesn't document anything\n-    //~| HELP maybe a comment was intended\n+    //~| HELP if a comment was intended use `//`\n }"}, {"sha": "6ea68e42b4cd3317a91c440d8270768e085a7d44", "filename": "src/test/ui/parser/doc-before-fn-rbrace.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-fn-rbrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-fn-rbrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-fn-rbrace.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -4,7 +4,7 @@ error[E0585]: found a documentation comment that doesn't document anything\n LL |     /// document\n    |     ^^^^^^^^^^^^\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error: aborting due to previous error\n "}, {"sha": "570306f2cdf83d14fbcf7f0d89a7604229005da1", "filename": "src/test/ui/parser/doc-before-rbrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-rbrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-rbrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-rbrace.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     println!(\"Hi\"); /// hi\n     //~^ ERROR found a documentation comment that doesn't document anything\n-    //~| HELP maybe a comment was intended\n+    //~| HELP if a comment was intended use `//`\n }"}, {"sha": "4d4741dfe59cd63f7269138158ebaa23ff1ecfea", "filename": "src/test/ui/parser/doc-before-rbrace.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-rbrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-rbrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-rbrace.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -4,7 +4,7 @@ error[E0585]: found a documentation comment that doesn't document anything\n LL |     println!(\"Hi\"); /// hi\n    |                     ^^^^^^\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error: aborting due to previous error\n "}, {"sha": "444b5874ea2862aa20fe086b7f307f67bddc3da3", "filename": "src/test/ui/parser/doc-before-semi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     /// hi\n     //~^ ERROR found a documentation comment that doesn't document anything\n-    //~| HELP maybe a comment was intended\n+    //~| HELP if a comment was intended use `//`\n     ;\n }"}, {"sha": "a879e13ffbd6230d3b1fb9617f8a9dc36efee1d6", "filename": "src/test/ui/parser/doc-before-semi.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -4,7 +4,7 @@ error[E0585]: found a documentation comment that doesn't document anything\n LL |     /// hi\n    |     ^^^^^^\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error: aborting due to previous error\n "}, {"sha": "0c8d90c3b037157cb258b6ddb061175754464371", "filename": "src/test/ui/parser/doc-before-struct-rbrace-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-1.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -2,7 +2,7 @@ struct X {\n     a: u8,\n     /// document\n     //~^ ERROR found a documentation comment that doesn't document anything\n-    //~| HELP maybe a comment was intended\n+    //~| HELP if a comment was intended use `//`\n }\n \n fn main() {"}, {"sha": "94934f734b3948248081dd47679b77a207035069", "filename": "src/test/ui/parser/doc-before-struct-rbrace-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-1.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -7,7 +7,7 @@ LL |     a: u8,\n LL |     /// document\n    |     ^^^^^^^^^^^^\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error: aborting due to previous error\n "}, {"sha": "2b2aadf7984a2933c366e9c34b04367a6c56d9d6", "filename": "src/test/ui/parser/doc-before-struct-rbrace-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-2.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -1,7 +1,7 @@\n struct X {\n     a: u8 /// document\n     //~^ ERROR found a documentation comment that doesn't document anything\n-    //~| HELP maybe a comment was intended\n+    //~| HELP if a comment was intended use `//`\n }\n \n fn main() {"}, {"sha": "6b5c8c1f8b53117fa0c8ac7a6ad7ecac313ca5a7", "filename": "src/test/ui/parser/doc-before-struct-rbrace-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-struct-rbrace-2.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -4,7 +4,7 @@ error[E0585]: found a documentation comment that doesn't document anything\n LL |     a: u8 /// document\n    |           ^^^^^^^^^^^^\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error: aborting due to previous error\n "}, {"sha": "900124adcc3b8c361e56a51848258da6ec432750", "filename": "src/test/ui/parser/doc-inside-trait-item.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -4,7 +4,7 @@ error[E0584]: found a documentation comment that doesn't document anything\n LL |     /// empty doc\n    |     ^^^^^^^^^^^^^ this doc comment doesn't document anything\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error: aborting due to previous error\n "}, {"sha": "b451484ba224b55cdac1dced95731b4456190739", "filename": "src/test/ui/parser/issues/issue-34222-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-34222-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-34222-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-34222-1.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -4,7 +4,7 @@ error[E0585]: found a documentation comment that doesn't document anything\n LL |     /// comment\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error: aborting due to previous error\n "}, {"sha": "6177870d1cee99735ce648f58aa6df8d9a943bbc", "filename": "src/test/ui/parser/issues/issue-48636.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-48636.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-48636.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-48636.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -8,7 +8,7 @@ LL |     x: u8\n LL |     /// The ID of the parent core\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+   = help: doc comments must come before what they document, if a comment was intended use `//`\n \n error: aborting due to previous error\n "}, {"sha": "e0a1164211a2cad83dacf482db3542e60eb791e7", "filename": "src/test/ui/regions/issue-102374.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fregions%2Fissue-102374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fregions%2Fissue-102374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fissue-102374.rs?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -0,0 +1,20 @@\n+use std::cell::Cell;\n+\n+#[rustfmt::skip]\n+fn f(\n+    f: for<'a, 'b, 'c, 'd, 'e, 'f, 'g,\n+           'h, 'i, 'j, 'k, 'l, 'm, 'n,\n+           'o, 'p, 'q, 'r, 's, 't, 'u,\n+           'v, 'w, 'x, 'y, 'z, 'z0>\n+        fn(Cell<(&   i32, &'a i32, &'b i32, &'c i32, &'d i32,\n+                 &'e i32, &'f i32, &'g i32, &'h i32, &'i i32,\n+                 &'j i32, &'k i32, &'l i32, &'m i32, &'n i32,\n+                 &'o i32, &'p i32, &'q i32, &'r i32, &'s i32,\n+                 &'t i32, &'u i32, &'v i32, &'w i32, &'x i32,\n+                 &'y i32, &'z i32, &'z0 i32)>),\n+) -> i32 {\n+    f\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "31b855c36bead701fb95d1399bda114653a697b5", "filename": "src/test/ui/regions/issue-102374.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fregions%2Fissue-102374.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1536a53ea4798df052dc31a611c2f29c8f529be7/src%2Ftest%2Fui%2Fregions%2Fissue-102374.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fissue-102374.stderr?ref=1536a53ea4798df052dc31a611c2f29c8f529be7", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-102374.rs:16:5\n+   |\n+LL | ) -> i32 {\n+   |      --- expected `i32` because of return type\n+LL |     f\n+   |     ^ expected `i32`, found fn pointer\n+   |\n+   = note:    expected type `i32`\n+           found fn pointer `for<'z1, 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y, 'z, 'z0> fn(Cell<(&'z1 i32, &'a i32, &'b i32, &'c i32, &'d i32, &'e i32, &'f i32, &'g i32, &'h i32, &'i i32, &'j i32, &'k i32, &'l i32, &'m i32, &'n i32, &'o i32, &'p i32, &'q i32, &'r i32, &'s i32, &'t i32, &'u i32, &'v i32, &'w i32, &'x i32, &'y i32, &'z i32, &'z0 i32)>)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}