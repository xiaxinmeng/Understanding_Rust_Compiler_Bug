{"sha": "30f2480fd879359f8773d5c29807130c3a489785", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZjI0ODBmZDg3OTM1OWY4NzczZDVjMjk4MDcxMzBjM2E0ODk3ODU=", "commit": {"author": {"name": "Phil Turnbull", "email": "philip.turnbull@gmail.com", "date": "2017-01-22T18:36:50Z"}, "committer": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2018-04-15T11:01:09Z"}, "message": "Lint closures that return nil", "tree": {"sha": "117fbb0ec0f08eb49dc6c307966685808bea19e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/117fbb0ec0f08eb49dc6c307966685808bea19e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30f2480fd879359f8773d5c29807130c3a489785", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJa0zD1AAoJELb6Bqbg4mZbRQAP/1mYqtcYz23ovw+fSwuU2aHh\nxh1cRkdVRIB3l+MUoQTheKMFWKuddCPzdCMIMS6aVo7VYJLUhmCH4sKAIikmsy0L\n3TxHHV1qEGyZ4oURFd/nghxsRwpc9I998H9sZ7nrW+uqzbmrNyReNyC5mnIh4aUs\nxW4ZGp5j2KOmfQube4vfv9ZbmRrkRU7YGvLGCWQhtHrnCScZCFxcqqy11o3Ss9/6\nJqrWNjigwg3l5VZEkWlOmdTHbaU1E+X92DCSwtdh2WxKfydCicbhr0UxRC8dofrw\n4vk1V8XRHzWwywf0Gp5fwGUBKcurCyYB8uUiU8jvqmDEh1p/KXtRQ8RUytaCogkk\nwBfxPFa4XGDj3rBP+gXtFR5VL0o5vfwH9z2hJpco6No19sO5E371q4JLpIKC6R6E\ne0N1xX0yvdBwlu04XibIDWr20txkLl4eN3NzMJSjEoJJV24kq4eW1gcpZT2ma1wT\n4lmk5uxk3j42XXzxMeOTOj9PWvnH3JxSg1fmm+shQUyoHXcq9WY2wt9ZC4JvZNFf\nVx2aMhDd09i+CgV+HXnxU26lHJDzN8e3HULWaJCoZE2gvp6vrYOUwkOYCOhviAJh\nsr45qmopMYuFLvXVN4g08QcIuFXAdGn+lkeiHXKmJPWYnUVqMEkRzoLSgYM2U9Xj\nRi86j059kGDgUbHVfsZr\n=bTSm\n-----END PGP SIGNATURE-----", "payload": "tree 117fbb0ec0f08eb49dc6c307966685808bea19e5\nparent 302f5d05f57b4debbe2890f7ebabbedb2059737f\nauthor Phil Turnbull <philip.turnbull@gmail.com> 1485110210 -0500\ncommitter Philipp Hansch <dev@phansch.net> 1523790069 +0200\n\nLint closures that return nil\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30f2480fd879359f8773d5c29807130c3a489785", "html_url": "https://github.com/rust-lang/rust/commit/30f2480fd879359f8773d5c29807130c3a489785", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30f2480fd879359f8773d5c29807130c3a489785/comments", "author": {"login": "philipturnbull", "id": 45588, "node_id": "MDQ6VXNlcjQ1NTg4", "avatar_url": "https://avatars.githubusercontent.com/u/45588?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philipturnbull", "html_url": "https://github.com/philipturnbull", "followers_url": "https://api.github.com/users/philipturnbull/followers", "following_url": "https://api.github.com/users/philipturnbull/following{/other_user}", "gists_url": "https://api.github.com/users/philipturnbull/gists{/gist_id}", "starred_url": "https://api.github.com/users/philipturnbull/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philipturnbull/subscriptions", "organizations_url": "https://api.github.com/users/philipturnbull/orgs", "repos_url": "https://api.github.com/users/philipturnbull/repos", "events_url": "https://api.github.com/users/philipturnbull/events{/privacy}", "received_events_url": "https://api.github.com/users/philipturnbull/received_events", "type": "User", "site_admin": false}, "committer": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "302f5d05f57b4debbe2890f7ebabbedb2059737f", "url": "https://api.github.com/repos/rust-lang/rust/commits/302f5d05f57b4debbe2890f7ebabbedb2059737f", "html_url": "https://github.com/rust-lang/rust/commit/302f5d05f57b4debbe2890f7ebabbedb2059737f"}], "stats": {"total": 211, "additions": 194, "deletions": 17}, "files": [{"sha": "4423aeece6fd9c77de5d5feb0539717d40d61a1e", "filename": "clippy_lints/src/map_nil_fn.rs", "status": "modified", "additions": 110, "deletions": 17, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/30f2480fd879359f8773d5c29807130c3a489785/clippy_lints%2Fsrc%2Fmap_nil_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f2480fd879359f8773d5c29807130c3a489785/clippy_lints%2Fsrc%2Fmap_nil_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_nil_fn.rs?ref=30f2480fd879359f8773d5c29807130c3a489785", "patch": "@@ -1,36 +1,41 @@\n use rustc::hir;\n use rustc::lint::*;\n use rustc::ty;\n-use utils::{in_macro, match_type, method_chain_args, snippet, span_lint_and_then};\n+use std::borrow::Cow;\n+use utils::{in_macro, iter_input_pats, match_type, method_chain_args, snippet, span_lint_and_then};\n use utils::paths;\n \n #[derive(Clone)]\n pub struct Pass;\n \n /// **What it does:** Checks for usage of `Option.map(f)` where f is a nil\n-/// function\n+/// function or closure\n ///\n /// **Why is this bad?** Readability, this can be written more clearly with\n /// an if statement\n ///\n-/// **Known problems:** None.\n+/// **Known problems:** Closures with multiple statements are not handled\n ///\n /// **Example:**\n /// ```rust\n /// let x : Option<&str> = do_stuff();\n /// x.map(log_err_msg);\n+/// x.map(|msg| log_err_msg(format_msg(msg)))\n /// ```\n /// The correct use would be:\n /// ```rust\n /// let x : Option<&str> = do_stuff();\n /// if let Some(msg) = x {\n ///     log_err_msg(msg)\n /// }\n+/// if let Some(msg) = x {\n+///     log_err_msg(format_msg(msg))\n+/// }\n /// ```\n declare_lint! {\n     pub OPTION_MAP_NIL_FN,\n     Allow,\n-    \"using `Option.map(f)`, where f is a nil function\"\n+    \"using `Option.map(f)`, where f is a nil function or closure\"\n }\n \n \n@@ -40,17 +45,94 @@ impl LintPass for Pass {\n     }\n }\n \n+fn is_nil_type(ty: ty::Ty) -> bool {\n+    match ty.sty {\n+        ty::TyTuple(slice) => slice.is_empty(),\n+        ty::TyNever => true,\n+        _ => false,\n+    }\n+}\n+\n fn is_nil_function(cx: &LateContext, expr: &hir::Expr) -> bool {\n     let ty = cx.tables.expr_ty(expr);\n \n     if let ty::TyFnDef(_, _, bare) = ty.sty {\n         if let Some(fn_type) = cx.tcx.no_late_bound_regions(&bare.sig) {\n-            return fn_type.output().is_nil() || fn_type.output().is_never();\n+            return is_nil_type(fn_type.output());\n         }\n     }\n     false\n }\n \n+fn is_nil_expression(cx: &LateContext, expr: &hir::Expr) -> bool {\n+    is_nil_type(cx.tables.expr_ty(expr))\n+}\n+\n+// The expression inside a closure may or may not have surrounding braces and\n+// semicolons, which causes problems when generating a suggestion. Given an\n+// expression that evaluates to '()' or '!', recursively remove useless braces\n+// and semi-colons until is suitable for including in the suggestion template\n+fn reduce_nil_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<Cow<'a, str>> {\n+    if !is_nil_expression(cx, expr) {\n+        return None;\n+    }\n+\n+    match expr.node {\n+        hir::ExprCall(_, _) |\n+        hir::ExprMethodCall(_, _, _) => {\n+            // Calls can't be reduced any more\n+            Some(snippet(cx, expr.span, \"_\"))\n+        },\n+        hir::ExprBlock(ref block) => {\n+            match (&block.stmts[..], block.expr.as_ref()) {\n+                (&[], Some(inner_expr)) => {\n+                    // Reduce `{ X }` to `X`\n+                    reduce_nil_expression(cx, inner_expr)\n+                },\n+                (&[ref inner_stmt], None) => {\n+                    // Reduce `{ X; }` to `X` or `X;`\n+                    match inner_stmt.node {\n+                        hir::StmtDecl(ref d, _) => Some(snippet(cx, d.span, \"_\")),\n+                        hir::StmtExpr(ref e, _) => Some(snippet(cx, e.span, \"_\")),\n+                        hir::StmtSemi(ref e, _) => {\n+                            if is_nil_expression(cx, e) {\n+                                // `X` returns nil so we can strip the\n+                                // semicolon and reduce further\n+                                reduce_nil_expression(cx, e)\n+                            } else {\n+                                // `X` doesn't return nil so it needs a\n+                                // trailing semicolon\n+                                Some(snippet(cx, inner_stmt.span, \"_\"))\n+                            }\n+                        },\n+                    }\n+                },\n+                _ => None,\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn reduce_nil_closure<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'a hir::Expr\n+) -> Option<(Cow<'a, str>, Cow<'a, str>)> {\n+    if let hir::ExprClosure(_, ref decl, inner_expr_id, _) = expr.node {\n+        let body = cx.tcx.map.body(inner_expr_id);\n+\n+        if_let_chain! {[\n+            decl.inputs.len() == 1,\n+            let Some(binding) = iter_input_pats(&decl, body).next(),\n+            let Some(expr_snippet) = reduce_nil_expression(cx, &body.value),\n+        ], {\n+            let binding_snippet = snippet(cx, binding.pat.span, \"_\");\n+            return Some((binding_snippet, expr_snippet));\n+        }}\n+    }\n+    None\n+}\n+\n fn lint_map_nil_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n     let var_arg = &map_args[0];\n     let fn_arg = &map_args[1];\n@@ -59,19 +141,30 @@ fn lint_map_nil_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_arg\n         return;\n     }\n \n-    let suggestion = if is_nil_function(cx, fn_arg) {\n-        format!(\"if let Some(...) = {0} {{ {1}(...) }}\",\n-                snippet(cx, var_arg.span, \"_\"),\n-                snippet(cx, fn_arg.span, \"_\"))\n-    } else {\n-        return;\n-    };\n+    if is_nil_function(cx, fn_arg) {\n+        let msg = \"called `map(f)` on an Option value where `f` is a nil function\";\n+        let suggestion = format!(\"if let Some(...) = {0} {{ {1}(...) }}\",\n+                                 snippet(cx, var_arg.span, \"_\"),\n+                                 snippet(cx, fn_arg.span, \"_\"));\n \n-    span_lint_and_then(cx,\n-                       OPTION_MAP_NIL_FN,\n-                       expr.span,\n-                       \"called `map(f)` on an Option value where `f` is a nil function\",\n-                       |db| { db.span_suggestion(stmt.span, \"try this\", suggestion); });\n+        span_lint_and_then(cx,\n+                           OPTION_MAP_NIL_FN,\n+                           expr.span,\n+                           msg,\n+                           |db| { db.span_suggestion(stmt.span, \"try this\", suggestion); });\n+    } else if let Some((binding_snippet, expr_snippet)) = reduce_nil_closure(cx, fn_arg) {\n+        let msg = \"called `map(f)` on an Option value where `f` is a nil closure\";\n+        let suggestion = format!(\"if let Some({0}) = {1} {{ {2} }}\",\n+                                 binding_snippet,\n+                                 snippet(cx, var_arg.span, \"_\"),\n+                                 expr_snippet);\n+\n+        span_lint_and_then(cx,\n+                           OPTION_MAP_NIL_FN,\n+                           expr.span,\n+                           msg,\n+                           |db| { db.span_suggestion(stmt.span, \"try this\", suggestion); });\n+    }\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {"}, {"sha": "5ac3913466a587138b13b61dc81236262b6ba1e6", "filename": "tests/compile-fail/map_nil_fn.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/30f2480fd879359f8773d5c29807130c3a489785/tests%2Fcompile-fail%2Fmap_nil_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f2480fd879359f8773d5c29807130c3a489785/tests%2Fcompile-fail%2Fmap_nil_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmap_nil_fn.rs?ref=30f2480fd879359f8773d5c29807130c3a489785", "patch": "@@ -48,4 +48,88 @@ fn main() {\n     //~^ ERROR called `map(f)` on an Option value where `f` is a nil function\n     //~| HELP try this\n     //~| SUGGESTION if let Some(...) = x.field { diverge(...) }\n+\n+    let captured = 10;\n+    if let Some(value) = x.field { do_nothing(value + captured) };\n+    let _ : Option<()> = x.field.map(|value| do_nothing(value + captured));\n+\n+    x.field.map(|value| x.do_option_nothing(value + captured));\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { x.do_option_nothing(value + captured) }\n+\n+    x.field.map(|value| { x.do_option_plus_one(value + captured); });\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { x.do_option_plus_one(value + captured); }\n+\n+\n+    x.field.map(|value| do_nothing(value + captured));\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { do_nothing(value + captured) }\n+\n+    x.field.map(|value| { do_nothing(value + captured) });\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { do_nothing(value + captured) }\n+\n+    x.field.map(|value| { do_nothing(value + captured); });\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { do_nothing(value + captured) }\n+\n+    x.field.map(|value| { { do_nothing(value + captured); } });\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { do_nothing(value + captured) }\n+\n+\n+    x.field.map(|value| diverge(value + captured));\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { diverge(value + captured) }\n+\n+    x.field.map(|value| { diverge(value + captured) });\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { diverge(value + captured) }\n+\n+    x.field.map(|value| { diverge(value + captured); });\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { diverge(value + captured) }\n+\n+    x.field.map(|value| { { diverge(value + captured); } });\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { diverge(value + captured) }\n+\n+\n+    x.field.map(|value| plus_one(value + captured));\n+    x.field.map(|value| { plus_one(value + captured) });\n+    x.field.map(|value| { let y = plus_one(value + captured); });\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { let y = plus_one(value + captured); }\n+\n+    x.field.map(|value| { plus_one(value + captured); });\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { plus_one(value + captured); }\n+\n+    x.field.map(|value| { { plus_one(value + captured); } });\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(value) = x.field { plus_one(value + captured); }\n+\n+\n+    x.field.map(|ref value| { do_nothing(value + captured) });\n+    //~^ ERROR called `map(f)` on an Option value where `f` is a nil closure\n+    //~| HELP try this\n+    //~| SUGGESTION if let Some(ref value) = x.field { do_nothing(value + captured) }\n+\n+\n+    // closures with multiple statements are not linted:\n+    x.field.map(|value| { do_nothing(value); do_nothing(value) });\n }"}]}