{"sha": "5e445697ce5932ce666c94a29ab512abf115a166", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNDQ1Njk3Y2U1OTMyY2U2NjZjOTRhMjlhYjUxMmFiZjExNWExNjY=", "commit": {"author": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2015-07-17T21:10:15Z"}, "committer": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2015-08-27T20:29:07Z"}, "message": "Implement Rewrite for [ast::Attribute]", "tree": {"sha": "f98bfc0bb7f01946fb511058a4e946c6e94ea5c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f98bfc0bb7f01946fb511058a4e946c6e94ea5c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e445697ce5932ce666c94a29ab512abf115a166", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e445697ce5932ce666c94a29ab512abf115a166", "html_url": "https://github.com/rust-lang/rust/commit/5e445697ce5932ce666c94a29ab512abf115a166", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e445697ce5932ce666c94a29ab512abf115a166/comments", "author": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25650c2a8bc2873cd0eb13a4511aeee7e2f94f25", "url": "https://api.github.com/repos/rust-lang/rust/commits/25650c2a8bc2873cd0eb13a4511aeee7e2f94f25", "html_url": "https://github.com/rust-lang/rust/commit/25650c2a8bc2873cd0eb13a4511aeee7e2f94f25"}], "stats": {"total": 189, "additions": 128, "deletions": 61}, "files": [{"sha": "f39dece3272672388d5afc6fbd1fa566e1dd284e", "filename": "src/expr.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5e445697ce5932ce666c94a29ab512abf115a166/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e445697ce5932ce666c94a29ab512abf115a166/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=5e445697ce5932ce666c94a29ab512abf115a166", "patch": "@@ -31,7 +31,7 @@ impl Rewrite for ast::Expr {\n                     ast::Lit_::LitStr(ref is, ast::StrStyle::CookedStr) => {\n                         rewrite_string_lit(context, &is, l.span, width, offset)\n                     }\n-                    _ => context.codemap.span_to_snippet(self.span).ok(),\n+                    _ => Some(context.snippet(self.span)),\n                 }\n             }\n             ast::Expr_::ExprCall(ref callee, ref args) => {\n@@ -137,7 +137,7 @@ impl Rewrite for ast::Expr {\n             _ => {\n                 // We do not format these expressions yet, but they should still\n                 // satisfy our width restrictions.\n-                let snippet = context.codemap.span_to_snippet(self.span).unwrap();\n+                let snippet = context.snippet(self.span);\n \n                 {\n                     let mut lines = snippet.lines();\n@@ -243,7 +243,7 @@ fn rewrite_closure(capture: ast::CaptureClause,\n \n impl Rewrite for ast::Block {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n-        let user_str = context.codemap.span_to_snippet(self.span).unwrap();\n+        let user_str = context.snippet(self.span);\n         if user_str == \"{}\" && width >= 2 {\n             return Some(user_str);\n         }\n@@ -254,7 +254,7 @@ impl Rewrite for ast::Block {\n         let prefix = match self.rules {\n             ast::BlockCheckMode::PushUnsafeBlock(..) |\n             ast::BlockCheckMode::UnsafeBlock(..) => {\n-                let snippet = try_opt!(context.codemap.span_to_snippet(self.span).ok());\n+                let snippet = context.snippet(self.span);\n                 let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n                 visitor.last_pos = self.span.lo + BytePos(open_pos as u32);\n \n@@ -289,7 +289,7 @@ impl Rewrite for ast::Block {\n // FIXME(#18): implement pattern formatting\n impl Rewrite for ast::Pat {\n     fn rewrite(&self, context: &RewriteContext, _: usize, _: usize) -> Option<String> {\n-        context.codemap.span_to_snippet(self.span).ok()\n+        Some(context.snippet(self.span))\n     }\n }\n \n@@ -547,11 +547,9 @@ fn rewrite_match(context: &RewriteContext,\n     for (i, arm) in arms.iter().enumerate() {\n         // Make sure we get the stuff between arms.\n         let missed_str = if i == 0 {\n-            context.codemap.span_to_snippet(mk_sp(open_brace_pos + BytePos(1),\n-                                                  arm_start_pos(arm))).unwrap()\n+            context.snippet(mk_sp(open_brace_pos + BytePos(1), arm_start_pos(arm)))\n         } else {\n-            context.codemap.span_to_snippet(mk_sp(arm_end_pos(&arms[i-1]),\n-                                                  arm_start_pos(arm))).unwrap()\n+            context.snippet(mk_sp(arm_end_pos(&arms[i-1]), arm_start_pos(arm)))\n         };\n         let missed_str = match missed_str.find_uncommented(\",\") {\n             Some(n) => &missed_str[n+1..],\n@@ -582,8 +580,7 @@ fn rewrite_match(context: &RewriteContext,\n             result.push_str(arm_str);\n         } else {\n             // We couldn't format the arm, just reproduce the source.\n-            let snippet = context.codemap.span_to_snippet(mk_sp(arm_start_pos(arm),\n-                                                                arm_end_pos(arm))).unwrap();\n+            let snippet = context.snippet(mk_sp(arm_start_pos(arm), arm_end_pos(arm)));\n             result.push_str(&snippet);\n         }\n     }\n@@ -626,8 +623,7 @@ impl Rewrite for ast::Arm {\n             attr_visitor.last_pos = attrs[0].span.lo;\n             if attr_visitor.visit_attrs(attrs) {\n                 // Attributes included a skip instruction.\n-                let snippet = context.codemap.span_to_snippet(mk_sp(attrs[0].span.lo,\n-                                                                    body.span.hi)).unwrap();\n+                let snippet = context.snippet(mk_sp(attrs[0].span.lo, body.span.hi));\n                 return Some(snippet);\n             }\n             attr_visitor.format_missing(pats[0].span.lo);\n@@ -652,7 +648,7 @@ impl Rewrite for ast::Arm {\n             // If the patterns were previously stacked, keep them stacked.\n             // FIXME should be an option.\n             let pat_span = mk_sp(pats[0].span.lo, pats[pats.len() - 1].span.hi);\n-            let pat_str = context.codemap.span_to_snippet(pat_span).unwrap();\n+            let pat_str = context.snippet(pat_span);\n             vertical = pat_str.find('\\n').is_some();\n         }\n \n@@ -831,7 +827,7 @@ fn rewrite_string_lit(context: &RewriteContext,\n     let l_loc = context.codemap.lookup_char_pos(span.lo);\n     let r_loc = context.codemap.lookup_char_pos(span.hi);\n     if l_loc.line == r_loc.line && r_loc.col.to_usize() <= context.config.max_width {\n-        return context.codemap.span_to_snippet(span).ok();\n+        return Some(context.snippet(span));\n     }\n     let fmt = StringFormat {\n         opener: \"\\\"\",\n@@ -880,7 +876,7 @@ fn rewrite_call(context: &RewriteContext,\n                              // Take old span when rewrite fails.\n                              |item| {\n                                  item.rewrite(inner_context, remaining_width, offset)\n-                                     .unwrap_or(context.codemap.span_to_snippet(item.span).unwrap())\n+                                     .unwrap_or(context.snippet(item.span))\n                              },\n                              callee.span.hi + BytePos(1),\n                              span.hi);\n@@ -977,15 +973,13 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                                  match *item {\n                                      StructLitField::Regular(ref field) => {\n                                          rewrite_field(inner_context, &field, h_budget, indent)\n-                                            .unwrap_or(context.codemap.span_to_snippet(field.span)\n-                                                                      .unwrap())\n+                                            .unwrap_or(context.snippet(field.span))\n                                      }\n                                      StructLitField::Base(ref expr) => {\n                                          // 2 = ..\n                                          expr.rewrite(inner_context, h_budget - 2, indent + 2)\n                                              .map(|s| format!(\"..{}\", s))\n-                                             .unwrap_or(context.codemap.span_to_snippet(expr.span)\n-                                                                       .unwrap())\n+                                             .unwrap_or(context.snippet(expr.span))\n                                      }\n                                  }\n                              },\n@@ -1053,7 +1047,7 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                              |item| {\n                                  let inner_width = context.config.max_width - indent - 1;\n                                  item.rewrite(context, inner_width, indent)\n-                                     .unwrap_or(context.codemap.span_to_snippet(item.span).unwrap())\n+                                     .unwrap_or(context.snippet(item.span))\n                              },\n                              span.lo + BytePos(1), // Remove parens\n                              span.hi - BytePos(1));\n@@ -1072,7 +1066,7 @@ fn rewrite_binary_op(context: &RewriteContext,\n                      -> Option<String> {\n     // FIXME: format comments between operands and operator\n \n-    let operator_str = context.codemap.span_to_snippet(op.span).unwrap();\n+    let operator_str = context.snippet(op.span);\n \n     // Get \"full width\" rhs and see if it fits on the current line. This\n     // usually works fairly well since it tends to place operands of\n@@ -1150,7 +1144,7 @@ fn rewrite_assignment(context: &RewriteContext,\n                       offset: usize)\n                       -> Option<String> {\n     let operator_str = match op {\n-        Some(op) => context.codemap.span_to_snippet(op.span).unwrap(),\n+        Some(op) => context.snippet(op.span),\n         None => \"=\".to_owned(),\n     };\n "}, {"sha": "bcc851a5b3503a06442fa71bbc8927ce85620d62", "filename": "src/items.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e445697ce5932ce666c94a29ab512abf115a166/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e445697ce5932ce666c94a29ab512abf115a166/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=5e445697ce5932ce666c94a29ab512abf115a166", "patch": "@@ -17,7 +17,6 @@ use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic,\n use expr::rewrite_assign_rhs;\n use comment::FindUncommented;\n use visitor::FmtVisitor;\n-\n use rewrite::Rewrite;\n use config::Config;\n \n@@ -699,7 +698,11 @@ impl<'a> FmtVisitor<'a> {\n         let typ = pprust::ty_to_string(&field.node.ty);\n \n         let indent = self.block_indent + self.config.tab_spaces;\n-        let mut attr_str = self.rewrite_attrs(&field.node.attrs, indent);\n+        let mut attr_str = field.node.attrs\n+                                     .rewrite(&self.get_context(),\n+                                              self.config.max_width - indent,\n+                                              indent)\n+                                     .unwrap();\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n             attr_str.push_str(&make_indent(indent));"}, {"sha": "5f1549846b55a65a1e2452e303d342dcb694ac39", "filename": "src/rewrite.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e445697ce5932ce666c94a29ab512abf115a166/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e445697ce5932ce666c94a29ab512abf115a166/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=5e445697ce5932ce666c94a29ab512abf115a166", "patch": "@@ -10,7 +10,7 @@\n \n // A generic trait to abstract the rewriting of an element (of the AST).\n \n-use syntax::codemap::CodeMap;\n+use syntax::codemap::{CodeMap, Span};\n \n use config::Config;\n \n@@ -39,4 +39,8 @@ impl<'a> RewriteContext<'a> {\n             block_indent: self.block_indent + self.config.tab_spaces,\n         }\n     }\n+\n+    pub fn snippet(&self, span: Span) -> String {\n+        self.codemap.span_to_snippet(span).unwrap()\n+    }\n }"}, {"sha": "b773a20fe6fd14b6639cb7b08d782652a76240e5", "filename": "src/visitor.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5e445697ce5932ce666c94a29ab512abf115a166/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e445697ce5932ce666c94a29ab512abf115a166/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=5e445697ce5932ce666c94a29ab512abf115a166", "patch": "@@ -17,6 +17,7 @@ use strings::string_buffer::StringBuffer;\n use utils;\n use config::Config;\n use rewrite::{Rewrite, RewriteContext};\n+use comment::rewrite_comment;\n \n pub struct FmtVisitor<'a> {\n     pub codemap: &'a CodeMap,\n@@ -293,48 +294,17 @@ impl<'a> FmtVisitor<'a> {\n         if utils::contains_skip(attrs) {\n             true\n         } else {\n-            let rewrite = self.rewrite_attrs(attrs, self.block_indent);\n+            let rewrite = attrs.rewrite(&self.get_context(),\n+                                        self.config.max_width - self.block_indent,\n+                                        self.block_indent)\n+                               .unwrap();\n             self.buffer.push_str(&rewrite);\n             let last = attrs.last().unwrap();\n             self.last_pos = last.span.hi;\n             false\n         }\n     }\n \n-    pub fn rewrite_attrs(&self, attrs: &[ast::Attribute], indent: usize) -> String {\n-        let mut result = String::new();\n-        let indent = utils::make_indent(indent);\n-\n-        for (i, a) in attrs.iter().enumerate() {\n-            let a_str = self.snippet(a.span);\n-\n-            if i > 0 {\n-                let comment = self.snippet(codemap::mk_sp(attrs[i-1].span.hi, a.span.lo));\n-                // This particular horror show is to preserve line breaks in between doc\n-                // comments. An alternative would be to force such line breaks to start\n-                // with the usual doc comment token.\n-                let multi_line = a_str.starts_with(\"//\") && comment.matches('\\n').count() > 1;\n-                let comment = comment.trim();\n-                if !comment.is_empty() {\n-                    result.push_str(&indent);\n-                    result.push_str(comment);\n-                    result.push('\\n');\n-                } else if multi_line {\n-                    result.push('\\n');\n-                }\n-                result.push_str(&indent);\n-            }\n-\n-            result.push_str(&a_str);\n-\n-            if i < attrs.len() - 1 {\n-                result.push('\\n');\n-            }\n-        }\n-\n-        result\n-    }\n-\n     fn format_mod(&mut self, m: &ast::Mod, s: Span, ident: ast::Ident) {\n         debug!(\"FmtVisitor::format_mod: ident: {:?}, span: {:?}\", ident, s);\n \n@@ -402,3 +372,46 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n }\n+\n+impl<'a> Rewrite for [ast::Attribute] {\n+    fn rewrite(&self, context: &RewriteContext, _: usize, offset: usize) -> Option<String> {\n+        let mut result = String::new();\n+        if self.is_empty() {\n+            return Some(result);\n+        }\n+        let indent = utils::make_indent(offset);\n+\n+        for (i, a) in self.iter().enumerate() {\n+            let a_str = context.snippet(a.span);\n+\n+            if i > 0 {\n+                let comment = context.snippet(codemap::mk_sp(self[i-1].span.hi, a.span.lo));\n+                // This particular horror show is to preserve line breaks in between doc\n+                // comments. An alternative would be to force such line breaks to start\n+                // with the usual doc comment token.\n+                let multi_line = a_str.starts_with(\"//\") && comment.matches('\\n').count() > 1;\n+                let comment = comment.trim();\n+                if !comment.is_empty() {\n+                    let comment = rewrite_comment(comment,\n+                                                  false,\n+                                                  context.config.max_width - offset,\n+                                                  offset);\n+                    result.push_str(&indent);\n+                    result.push_str(&comment);\n+                    result.push('\\n');\n+                } else if multi_line {\n+                    result.push('\\n');\n+                }\n+                result.push_str(&indent);\n+            }\n+\n+            result.push_str(&a_str);\n+\n+            if i < self.len() - 1 {\n+                result.push('\\n');\n+            }\n+        }\n+\n+        Some(result)\n+    }\n+}"}, {"sha": "ac44a6504fdf7b3c463064e4d6bee1939c90c996", "filename": "tests/source/attrib.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5e445697ce5932ce666c94a29ab512abf115a166/tests%2Fsource%2Fattrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e445697ce5932ce666c94a29ab512abf115a166/tests%2Fsource%2Fattrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fattrib.rs?ref=5e445697ce5932ce666c94a29ab512abf115a166", "patch": "@@ -0,0 +1,43 @@\n+// Test attributes and doc comments are preserved.\n+\n+/// Blah blah blah.\n+/// Blah blah blah.\n+/// Blah blah blah.\n+/// Blah blah blah.\n+\n+/// Blah blah blah.\n+impl Bar {\n+    /// Blah blah blooo.\n+    /// Blah blah blooo.\n+    /// Blah blah blooo.\n+    /// Blah blah blooo.\n+    #[an_attribute]\n+    fn foo(&mut self) -> isize {\n+    }\n+\n+    /// Blah blah bing.\n+    /// Blah blah bing.\n+    /// Blah blah bing.\n+\n+\n+    /// Blah blah bing.\n+    /// Blah blah bing.\n+    /// Blah blah bing.\n+    pub fn f2(self) {\n+        (foo, bar)\n+    }\n+\n+    #[another_attribute]\n+    fn f3(self) -> Dog {\n+    }\n+\n+    /// Blah blah bing.\n+\n+    #[attrib1]\n+    /// Blah blah bing.\n+    #[attrib2]\n+    // Another comment that needs rewrite because it's tooooooooooooooooooooooooooooooo loooooooooooong.\n+    /// Blah blah bing.\n+    fn f4(self) -> Cat {\n+    }\n+}"}, {"sha": "62657ad3b5d1d928667cfdcaebb92492c67e3b52", "filename": "tests/target/attrib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e445697ce5932ce666c94a29ab512abf115a166/tests%2Ftarget%2Fattrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e445697ce5932ce666c94a29ab512abf115a166/tests%2Ftarget%2Fattrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fattrib.rs?ref=5e445697ce5932ce666c94a29ab512abf115a166", "patch": "@@ -29,4 +29,14 @@ impl Bar {\n     #[another_attribute]\n     fn f3(self) -> Dog {\n     }\n+\n+    /// Blah blah bing.\n+    #[attrib1]\n+    /// Blah blah bing.\n+    #[attrib2]\n+    // Another comment that needs rewrite because it's tooooooooooooooooooooooooooooooo\n+    // loooooooooooong.\n+    /// Blah blah bing.\n+    fn f4(self) -> Cat {\n+    }\n }"}]}