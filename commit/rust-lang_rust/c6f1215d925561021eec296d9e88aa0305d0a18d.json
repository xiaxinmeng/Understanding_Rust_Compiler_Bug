{"sha": "c6f1215d925561021eec296d9e88aa0305d0a18d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZjEyMTVkOTI1NTYxMDIxZWVjMjk2ZDllODhhYTAzMDVkMGExOGQ=", "commit": {"author": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-03-06T15:44:22Z"}, "committer": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-03-06T15:48:34Z"}, "message": "perf(dep_graph): Avoid allocating a set on when the number reads are small\n\n`reserve_and_rehash` takes up 1.4% of the runtime on the `packed-simd`\nbenchmark which I believe is due to the number of reads are very low in\nmany cases (see https://github.com/rust-lang/rust/pull/50565 for\ninstance).\n\nThis avoids allocating the set until we start allocating the `reads`\n`SmallVec` but it is possible that a lower limit might be better (not\ntested since the improvement will be hard to spot either way).", "tree": {"sha": "9ee7883d3e6dee0d00732317700876ed476a7245", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ee7883d3e6dee0d00732317700876ed476a7245"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6f1215d925561021eec296d9e88aa0305d0a18d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6f1215d925561021eec296d9e88aa0305d0a18d", "html_url": "https://github.com/rust-lang/rust/commit/c6f1215d925561021eec296d9e88aa0305d0a18d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6f1215d925561021eec296d9e88aa0305d0a18d/comments", "author": null, "committer": null, "parents": [{"sha": "9381e8178b49636d4604e4ec0f1263960691c958", "url": "https://api.github.com/repos/rust-lang/rust/commits/9381e8178b49636d4604e4ec0f1263960691c958", "html_url": "https://github.com/rust-lang/rust/commit/9381e8178b49636d4604e4ec0f1263960691c958"}], "stats": {"total": 19, "additions": 17, "deletions": 2}, "files": [{"sha": "18bf77a8c4fb0a92a41f949047691e7996d30f6d", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c6f1215d925561021eec296d9e88aa0305d0a18d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6f1215d925561021eec296d9e88aa0305d0a18d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=c6f1215d925561021eec296d9e88aa0305d0a18d", "patch": "@@ -1128,11 +1128,25 @@ impl DepGraphData {\n             let icx = if let Some(icx) = icx { icx } else { return };\n             if let Some(task_deps) = icx.task_deps {\n                 let mut task_deps = task_deps.lock();\n+                let task_deps = &mut *task_deps;\n                 if cfg!(debug_assertions) {\n                     self.current.total_read_count.fetch_add(1, Relaxed);\n                 }\n-                if task_deps.read_set.insert(source) {\n+\n+                // As long as we only have a low number of reads we can avoid doing a hash\n+                // insert and potentially allocating/reallocating the hashmap\n+                let new_read = if task_deps.reads.len() < TASK_DEPS_READS_CAP {\n+                    task_deps.reads.iter().all(|other| *other != source)\n+                } else {\n+                    task_deps.read_set.insert(source)\n+                };\n+                if new_read {\n                     task_deps.reads.push(source);\n+                    if task_deps.reads.len() == TASK_DEPS_READS_CAP {\n+                        // Fill `read_set` with what we have so far so we can use the hashset next\n+                        // time\n+                        task_deps.read_set.extend(task_deps.reads.iter().copied());\n+                    }\n \n                     #[cfg(debug_assertions)]\n                     {\n@@ -1154,10 +1168,11 @@ impl DepGraphData {\n     }\n }\n \n+const TASK_DEPS_READS_CAP: usize = 8;\n pub struct TaskDeps {\n     #[cfg(debug_assertions)]\n     node: Option<DepNode>,\n-    reads: SmallVec<[DepNodeIndex; 8]>,\n+    reads: SmallVec<[DepNodeIndex; TASK_DEPS_READS_CAP]>,\n     read_set: FxHashSet<DepNodeIndex>,\n }\n "}]}