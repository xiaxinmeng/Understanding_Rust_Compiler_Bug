{"sha": "18250b0349848fbfca53153cf121724c773dd508", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MjUwYjAzNDk4NDhmYmZjYTUzMTUzY2YxMjE3MjRjNzczZGQ1MDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-18T11:38:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-18T11:38:06Z"}, "message": "Auto merge of #46073 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 4 pull requests\n\n- Successful merges: #45767, #46044, #46066, #46071\n- Failed merges:", "tree": {"sha": "833ec064de51f63cb21a7273153b373221cd6886", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/833ec064de51f63cb21a7273153b373221cd6886"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18250b0349848fbfca53153cf121724c773dd508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18250b0349848fbfca53153cf121724c773dd508", "html_url": "https://github.com/rust-lang/rust/commit/18250b0349848fbfca53153cf121724c773dd508", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18250b0349848fbfca53153cf121724c773dd508/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "130eaaeabae0af23e0cbbb16e2ba9d6c13092e0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/130eaaeabae0af23e0cbbb16e2ba9d6c13092e0f", "html_url": "https://github.com/rust-lang/rust/commit/130eaaeabae0af23e0cbbb16e2ba9d6c13092e0f"}, {"sha": "5f1c37a0fad375619a5015e13cd3c084a0335ca3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1c37a0fad375619a5015e13cd3c084a0335ca3", "html_url": "https://github.com/rust-lang/rust/commit/5f1c37a0fad375619a5015e13cd3c084a0335ca3"}], "stats": {"total": 222, "additions": 115, "deletions": 107}, "files": [{"sha": "9c6b86d6ddc8e0f76e275603c9072b62193d55ae", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -38,17 +38,19 @@ function! Forcing you to write `main` for every example, no matter how small,\n adds friction. So `rustdoc` processes your examples slightly before\n running them. Here's the full algorithm rustdoc uses to preprocess examples:\n \n-1. Any leading `#![foo]` attributes are left intact as crate attributes.\n-2. Some common `allow` attributes are inserted, including\n+1. Some common `allow` attributes are inserted, including\n    `unused_variables`, `unused_assignments`, `unused_mut`,\n    `unused_attributes`, and `dead_code`. Small examples often trigger\n    these lints.\n-3. If the example does not contain `extern crate`, then `extern crate\n+2. Any attributes specified with `#![doc(test(attr(...)))]` are added.\n+3. Any leading `#![foo]` attributes are left intact as crate attributes.\n+4. If the example does not contain `extern crate`, and\n+   `#![doc(test(no_crate_inject))]` was not specified, then `extern crate\n    <mycrate>;` is inserted (note the lack of `#[macro_use]`).\n-4. Finally, if the example does not contain `fn main`, the remainder of the\n+5. Finally, if the example does not contain `fn main`, the remainder of the\n    text is wrapped in `fn main() { your_code }`.\n \n-For more about that caveat in rule 3, see \"Documeting Macros\" below.\n+For more about that caveat in rule 4, see \"Documeting Macros\" below.\n \n ## Hiding portions of the example\n \n@@ -261,4 +263,4 @@ are added.\n The `no_run` attribute will compile your code, but not run it. This is\n important for examples such as \"Here's how to retrieve a web page,\"\n which you would want to ensure compiles, but might be run in a test\n-environment that has no network access.\n\\ No newline at end of file\n+environment that has no network access."}, {"sha": "aadd72d1c902d67ca415ef4b721f4087c85ad3bc", "filename": "src/doc/rustdoc/src/the-doc-attribute.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -103,6 +103,26 @@ to it in the docs. But if you include this:\n \n it will not.\n \n+### `test(no_crate_inject)`\n+\n+By default, `rustdoc` will automatically add a line with `extern crate my_crate;` into each doctest.\n+But if you include this:\n+\n+```rust,ignore\n+#![doc(test(no_crate_inject))]\n+```\n+\n+it will not.\n+\n+### `test(attr(...))`\n+\n+This form of the `doc` attribute allows you to add arbitrary attributes to all your doctests. For\n+example, if you want your doctests to fail if they produce any warnings, you could add this:\n+\n+```rust,ignore\n+#![doc(test(attr(deny(warnings))))]\n+```\n+\n ## At the item level\n \n These forms of the `#[doc]` attribute are used on individual items, to control how"}, {"sha": "21bfc448ae2b4a0c8b2ec4ede7d9285820365286", "filename": "src/etc/indenter", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Fetc%2Findenter", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Fetc%2Findenter", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Findenter?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -13,7 +13,7 @@ while True:\n     if more_re.match(line):\n         indent += 1\n \n-    print \"%03d %s%s\" % (indent, \" \" * indent, line.strip())\n+    print(\"%03d %s%s\" % (indent, \" \" * indent, line.strip()))\n \n     if less_re.match(line):\n         indent -= 1"}, {"sha": "ac2223f4acef3052d32d35689b90eb1227ca4a19", "filename": "src/etc/sugarise-doc-comments.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Fetc%2Fsugarise-doc-comments.py", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Fetc%2Fsugarise-doc-comments.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsugarise-doc-comments.py?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -50,11 +50,11 @@ def block_trim(s):\n         lns = lns[:-1]\n \n     # remove leading horizontal whitespace\n-    n = sys.maxint\n+    n = sys.maxsize\n     for ln in lns:\n         if ln.strip():\n             n = min(n, len(re.search('^\\s*', ln).group()))\n-    if n != sys.maxint:\n+    if n != sys.maxsize:\n         lns = [ln[n:] for ln in lns]\n \n     # strip trailing whitespace"}, {"sha": "75c92b9b15ca28f6731ec75d16f8f03a09768304", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -97,11 +97,15 @@\n from subprocess import Popen, check_call, PIPE\n from glob import glob\n import multiprocessing\n-import Queue\n import threading\n import ctypes\n import binascii\n \n+try:  # Python 3\n+    import queue as Queue\n+except ImportError:  # Python 2\n+    import Queue\n+\n NUM_WORKERS = 2\n UPDATE_EVERY_N = 50000\n INF = namedtuple('INF', '')()"}, {"sha": "355fb570c000bb6944c19a9ad3bb7b3f62392402", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -82,9 +82,6 @@ pub struct Mir<'tcx> {\n     /// in scope, but a separate set of locals.\n     pub promoted: IndexVec<Promoted, Mir<'tcx>>,\n \n-    /// Return type of the function.\n-    pub return_ty: Ty<'tcx>,\n-\n     /// Yield type of the function, if it is a generator.\n     pub yield_ty: Option<Ty<'tcx>>,\n \n@@ -135,7 +132,6 @@ impl<'tcx> Mir<'tcx> {\n                visibility_scope_info: ClearOnDecode<IndexVec<VisibilityScope,\n                                                              VisibilityScopeInfo>>,\n                promoted: IndexVec<Promoted, Mir<'tcx>>,\n-               return_ty: Ty<'tcx>,\n                yield_ty: Option<Ty<'tcx>>,\n                local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n                arg_count: usize,\n@@ -145,14 +141,12 @@ impl<'tcx> Mir<'tcx> {\n         // We need `arg_count` locals, and one for the return pointer\n         assert!(local_decls.len() >= arg_count + 1,\n             \"expected at least {} locals, got {}\", arg_count + 1, local_decls.len());\n-        assert_eq!(local_decls[RETURN_POINTER].ty, return_ty);\n \n         Mir {\n             basic_blocks,\n             visibility_scopes,\n             visibility_scope_info,\n             promoted,\n-            return_ty,\n             yield_ty,\n             generator_drop: None,\n             generator_layout: None,\n@@ -273,6 +267,11 @@ impl<'tcx> Mir<'tcx> {\n             &block.terminator().source_info\n         }\n     }\n+\n+    /// Return the return type, it always return first element from `local_decls` array\n+    pub fn return_ty(&self) -> Ty<'tcx> {\n+        self.local_decls[RETURN_POINTER].ty\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -299,7 +298,6 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     visibility_scopes,\n     visibility_scope_info,\n     promoted,\n-    return_ty,\n     yield_ty,\n     generator_drop,\n     generator_layout,\n@@ -1744,7 +1742,6 @@ impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n             visibility_scopes: self.visibility_scopes.clone(),\n             visibility_scope_info: self.visibility_scope_info.clone(),\n             promoted: self.promoted.fold_with(folder),\n-            return_ty: self.return_ty.fold_with(folder),\n             yield_ty: self.yield_ty.fold_with(folder),\n             generator_drop: self.generator_drop.fold_with(folder),\n             generator_layout: self.generator_layout.fold_with(folder),\n@@ -1763,7 +1760,6 @@ impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n         self.generator_layout.visit_with(visitor) ||\n         self.yield_ty.visit_with(visitor) ||\n         self.promoted.visit_with(visitor)     ||\n-        self.return_ty.visit_with(visitor)    ||\n         self.local_decls.visit_with(visitor)\n     }\n }"}, {"sha": "5f2f5b79cc698580338401d5664d12e2367296ad", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -292,7 +292,7 @@ macro_rules! make_mir_visitor {\n                     self.visit_visibility_scope_data(scope);\n                 }\n \n-                self.visit_ty(&$($mutability)* mir.return_ty, TyContext::ReturnTy(SourceInfo {\n+                self.visit_ty(&$($mutability)* mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n                     span: mir.span,\n                     scope: ARGUMENT_VISIBILITY_SCOPE,\n                 }));"}, {"sha": "287d10831893a7aeee5dc19678665b8509233580", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -444,7 +444,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         }).collect()\n     });\n \n-    let mut mir = builder.finish(upvar_decls, return_ty, yield_ty);\n+    let mut mir = builder.finish(upvar_decls, yield_ty);\n     mir.spread_arg = spread_arg;\n     mir\n }\n@@ -469,7 +469,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     // Constants can't `return` so a return block should not be created.\n     assert_eq!(builder.cached_return_block, None);\n \n-    builder.finish(vec![], ty, None)\n+    builder.finish(vec![], None)\n }\n \n fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n@@ -481,7 +481,7 @@ fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n-    builder.finish(vec![], ty, None)\n+    builder.finish(vec![], None)\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -524,7 +524,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn finish(self,\n               upvar_decls: Vec<UpvarDecl>,\n-              return_ty: Ty<'tcx>,\n               yield_ty: Option<Ty<'tcx>>)\n               -> Mir<'tcx> {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n@@ -537,7 +536,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                  self.visibility_scopes,\n                  ClearOnDecode::Set(self.visibility_scope_info),\n                  IndexVec::new(),\n-                 return_ty,\n                  yield_ty,\n                  self.local_decls,\n                  self.arg_count,"}, {"sha": "d31f3812e9a1dd4953f41619883c958a1a679523", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -197,7 +197,6 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ),\n         ClearOnDecode::Clear,\n         IndexVec::new(),\n-        sig.output(),\n         None,\n         local_decls_for_sig(&sig, span),\n         sig.inputs().len(),\n@@ -345,7 +344,6 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             ),\n             ClearOnDecode::Clear,\n             IndexVec::new(),\n-            self.sig.output(),\n             None,\n             self.local_decls,\n             self.sig.inputs().len(),\n@@ -808,7 +806,6 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ),\n         ClearOnDecode::Clear,\n         IndexVec::new(),\n-        sig.output(),\n         None,\n         local_decls,\n         sig.inputs().len(),\n@@ -881,7 +878,6 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         ),\n         ClearOnDecode::Clear,\n         IndexVec::new(),\n-        sig.output(),\n         None,\n         local_decls,\n         sig.inputs().len(),"}, {"sha": "f676372193a360afb733424d9874581834d2ba03", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -557,7 +557,6 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     }\n \n     // Replace the return variable\n-    mir.return_ty = tcx.mk_nil();\n     mir.local_decls[RETURN_POINTER] = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: tcx.mk_nil(),\n@@ -777,7 +776,7 @@ impl MirPass for StateTransform {\n         let state_did = tcx.lang_items().gen_state().unwrap();\n         let state_adt_ref = tcx.adt_def(state_did);\n         let state_substs = tcx.mk_substs([Kind::from(yield_ty),\n-            Kind::from(mir.return_ty)].iter());\n+            Kind::from(mir.return_ty())].iter());\n         let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n         // We rename RETURN_POINTER which has type mir.return_ty to new_ret_local\n@@ -808,7 +807,6 @@ impl MirPass for StateTransform {\n         transform.visit_mir(mir);\n \n         // Update our MIR struct to reflect the changed we've made\n-        mir.return_ty = ret_ty;\n         mir.yield_ty = None;\n         mir.arg_count = 1;\n         mir.spread_arg = None;"}, {"sha": "70f0c63c765e208b58d2c923410a71b20cc58ea7", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -287,7 +287,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         let span = self.promoted.span;\n         let new_operand = Operand::Constant(box Constant {\n             span,\n-            ty: self.promoted.return_ty,\n+            ty: self.promoted.return_ty(),\n             literal: Literal::Promoted {\n                 index: Promoted::new(self.source.promoted.len())\n             }\n@@ -385,7 +385,6 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 mir.visibility_scopes.clone(),\n                 mir.visibility_scope_info.clone(),\n                 IndexVec::new(),\n-                ty,\n                 None,\n                 initial_locals,\n                 0,"}, {"sha": "97e80de96c5cc0d6ef119eb7c69f2d6bc90cb671", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -380,7 +380,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         // conservative type qualification instead.\n         if self.qualif.intersects(Qualif::CONST_ERROR) {\n             self.qualif = Qualif::empty();\n-            let return_ty = mir.return_ty;\n+            let return_ty = mir.return_ty();\n             self.add_type(return_ty);\n         }\n \n@@ -938,7 +938,7 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // performing the steal.\n     let mir = &tcx.mir_const(def_id).borrow();\n \n-    if mir.return_ty.references_error() {\n+    if mir.return_ty().references_error() {\n         tcx.sess.delay_span_bug(mir.span, \"mir_const_qualif: Mir had errors\");\n         return (Qualif::NOT_CONST.bits(), Rc::new(IdxSetBuf::new_empty(0)));\n     }\n@@ -956,7 +956,7 @@ impl MirPass for QualifyAndPromoteConstants {\n                           src: MirSource,\n                           mir: &mut Mir<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n-        if mir.return_ty.references_error() {\n+        if mir.return_ty().references_error() {\n             tcx.sess.delay_span_bug(mir.span, \"QualifyAndPromoteConstants: Mir had errors\");\n             return;\n         }\n@@ -1045,7 +1045,7 @@ impl MirPass for QualifyAndPromoteConstants {\n                     return;\n                 }\n             }\n-            let ty = mir.return_ty;\n+            let ty = mir.return_ty();\n             tcx.infer_ctxt().enter(|infcx| {\n                 let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n                 let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);"}, {"sha": "b70d0fb9c2c5d8a969848e4bdb63298afed2cbdc", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     }\n \n     fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n-        self.sanitize_type(&\"return type\", mir.return_ty);\n+        self.sanitize_type(&\"return type\", mir.return_ty());\n         for local_decl in &mir.local_decls {\n             self.sanitize_type(local_decl, local_decl.ty);\n         }"}, {"sha": "ea4495b484c39e32a2c956d631eefd85e425307a", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -150,7 +150,7 @@ fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         write!(w, \"{:?}: {}\", Lvalue::Local(arg), escape(&mir.local_decls[arg].ty))?;\n     }\n \n-    write!(w, \") -&gt; {}\", escape(mir.return_ty))?;\n+    write!(w, \") -&gt; {}\", escape(mir.return_ty()))?;\n     write!(w, r#\"<br align=\"left\"/>\"#)?;\n \n     for local in mir.vars_and_temps_iter() {"}, {"sha": "7d9cae6bc19f9f250d82c4ab5fcdf44c7da7eede", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -392,13 +392,13 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n                 write!(w, \"{:?}: {}\", Lvalue::Local(arg), mir.local_decls[arg].ty)?;\n             }\n \n-            write!(w, \") -> {}\", mir.return_ty)\n+            write!(w, \") -> {}\", mir.return_ty())\n         }\n         (hir::BodyOwnerKind::Const, _) |\n         (hir::BodyOwnerKind::Static(_), _) |\n         (_, Some(_)) => {\n             assert_eq!(mir.arg_count, 0);\n-            write!(w, \": {} =\", mir.return_ty)\n+            write!(w, \": {} =\", mir.return_ty())\n         }\n     }\n }"}, {"sha": "a3957ccdcb3c985f9ebdea3849621d2b210b0ce9", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -382,13 +382,6 @@\n                 }\n             }\n \n-            function min(a, b) {\n-                if (a < b) {\n-                    return a;\n-                }\n-                return b;\n-            }\n-\n             function extractGenerics(val) {\n                 val = val.toLowerCase();\n                 if (val.indexOf('<') !== -1) {\n@@ -426,7 +419,7 @@\n                             }\n                             if (lev.pos !== -1) {\n                                 elems.splice(lev.pos, 1);\n-                                lev_distance = min(lev.lev, lev_distance);\n+                                lev_distance = Math.min(lev.lev, lev_distance);\n                             } else {\n                                 return MAX_LEV_DISTANCE + 1;\n                             }\n@@ -489,11 +482,12 @@\n                 var new_lev = levenshtein(obj.name, val.name);\n                 if (new_lev < lev_distance) {\n                     if ((lev = checkGenerics(obj, val)) <= MAX_LEV_DISTANCE) {\n-                        lev_distance = min(min(new_lev, lev), lev_distance);\n+                        lev_distance = Math.min(Math.min(new_lev, lev), lev_distance);\n                     }\n                 } else if (obj.generics && obj.generics.length > 0) {\n                     for (var x = 0; x < obj.generics.length; ++x) {\n-                        lev_distance = min(levenshtein(obj.generics[x], val.name), lev_distance);\n+                        lev_distance = Math.min(levenshtein(obj.generics[x], val.name),\n+                                                lev_distance);\n                     }\n                 }\n                 // Now whatever happens, the returned distance is \"less good\" so we should mark it\n@@ -510,7 +504,7 @@\n                         if (literalSearch === true && tmp === true) {\n                             return true;\n                         }\n-                        lev_distance = min(tmp, lev_distance);\n+                        lev_distance = Math.min(tmp, lev_distance);\n                         if (lev_distance === 0) {\n                             return 0;\n                         }\n@@ -527,7 +521,7 @@\n                     if (literalSearch === true && tmp === true) {\n                         return true;\n                     }\n-                    lev_distance = min(tmp, lev_distance);\n+                    lev_distance = Math.min(tmp, lev_distance);\n                     if (lev_distance === 0) {\n                         return 0;\n                     }\n@@ -568,18 +562,20 @@\n                     var in_args = findArg(searchIndex[i], val, true);\n                     var returned = checkReturned(searchIndex[i], val, true);\n                     var ty = searchIndex[i];\n+                    var fullId = itemTypes[ty.ty] + ty.path + ty.name;\n+\n                     if (searchWords[i] === val.name) {\n                         // filter type: ... queries\n                         if (typePassesFilter(typeFilter, searchIndex[i].ty) &&\n-                            results[ty.path + ty.name] === undefined)\n+                            results[fullId] === undefined)\n                         {\n-                            results[ty.path + ty.name] = {id: i, index: -1};\n+                            results[fullId] = {id: i, index: -1};\n                             results_length += 1;\n                         }\n                     } else if ((in_args === true || returned === true) &&\n                                typePassesFilter(typeFilter, searchIndex[i].ty)) {\n-                        if (results[ty.path + ty.name] === undefined) {\n-                            results[ty.path + ty.name] = {\n+                        if (results[fullId] === undefined) {\n+                            results[fullId] = {\n                                 id: i,\n                                 index: -1,\n                                 dontValidate: true,\n@@ -589,10 +585,10 @@\n                             results_length += 1;\n                         } else {\n                             if (in_args === true) {\n-                                results[ty.path + ty.name].in_args = true;\n+                                results[fullId].in_args = true;\n                             }\n                             if (returned === true) {\n-                                results[ty.path + ty.name].returned = true;\n+                                results[fullId].returned = true;\n                             }\n                         }\n                     }\n@@ -621,6 +617,7 @@\n                     if (!type) {\n                         continue;\n                     }\n+                    var fullId = itemTypes[ty.ty] + ty.path + ty.name;\n \n                     // allow searching for void (no output) functions as well\n                     var typeOutput = type.output ? type.output.name : \"\";\n@@ -639,15 +636,15 @@\n                             in_args = allFound;\n                         }\n                         if (in_args === true || returned === true || module === true) {\n-                            if (results[ty.path + ty.name] !== undefined) {\n+                            if (results[fullId] !== undefined) {\n                                 if (returned === true) {\n-                                    results[ty.path + ty.name].returned = true;\n+                                    results[fullId].returned = true;\n                                 }\n                                 if (in_args === true) {\n-                                    results[ty.path + ty.name].in_args = true;\n+                                    results[fullId].in_args = true;\n                                 }\n                             } else {\n-                                results[ty.path + ty.name] = {\n+                                results[fullId] = {\n                                     id: i,\n                                     index: -1,\n                                     dontValidate: true,\n@@ -682,48 +679,49 @@\n                         var index = -1;\n                         // we want lev results to go lower than others\n                         var lev = MAX_LEV_DISTANCE;\n+                        var fullId = itemTypes[ty.ty] + ty.path + ty.name;\n \n                         if (searchWords[j].indexOf(split[i]) > -1 ||\n                             searchWords[j].indexOf(val) > -1 ||\n                             searchWords[j].replace(/_/g, \"\").indexOf(val) > -1)\n                         {\n                             // filter type: ... queries\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n-                                results[ty.path + ty.name] === undefined) {\n+                            if (typePassesFilter(typeFilter, ty) &&\n+                                results[fullId] === undefined) {\n                                 index = searchWords[j].replace(/_/g, \"\").indexOf(val);\n                             }\n                         }\n                         if ((lev_distance = levenshtein(searchWords[j], val)) <= MAX_LEV_DISTANCE) {\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n-                                (results[ty.path + ty.name] === undefined ||\n-                                 results[ty.path + ty.name].lev > lev_distance)) {\n-                                lev = min(lev, lev_distance);\n-                                index = 0;\n+                            if (typePassesFilter(typeFilter, ty) &&\n+                                (results[fullId] === undefined ||\n+                                 results[fullId].lev > lev_distance)) {\n+                                lev = Math.min(lev, lev_distance);\n+                                index = Math.max(0, index);\n                             }\n                         }\n                         if ((lev_distance = findArg(searchIndex[j], valGenerics))\n                             <= MAX_LEV_DISTANCE) {\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n-                                (results[ty.path + ty.name] === undefined ||\n-                                 results[ty.path + ty.name].lev > lev_distance)) {\n+                            if (typePassesFilter(typeFilter, ty) &&\n+                                (results[fullId] === undefined ||\n+                                 results[fullId].lev > lev_distance)) {\n                                 in_args = true;\n-                                lev = min(lev_distance, lev);\n-                                index = 0;\n+                                lev = Math.min(lev_distance, lev);\n+                                index = Math.max(0, index);\n                             }\n                         }\n                         if ((lev_distance = checkReturned(searchIndex[j], valGenerics)) <=\n                             MAX_LEV_DISTANCE) {\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n-                                (results[ty.path + ty.name] === undefined ||\n-                                 results[ty.path + ty.name].lev > lev_distance)) {\n+                            if (typePassesFilter(typeFilter, ty) &&\n+                                (results[fullId] === undefined ||\n+                                 results[fullId].lev > lev_distance)) {\n                                 returned = true;\n-                                lev = min(lev_distance, lev);\n-                                index = 0;\n+                                lev = Math.min(lev_distance, lev);\n+                                index = Math.max(0, index);\n                             }\n                         }\n                         if (index !== -1) {\n-                            if (results[ty.path + ty.name] === undefined) {\n-                                results[ty.path + ty.name] = {\n+                            if (results[fullId] === undefined) {\n+                                results[fullId] = {\n                                     id: j,\n                                     index: index,\n                                     lev: lev,\n@@ -732,14 +730,14 @@\n                                 };\n                                 results_length += 1;\n                             } else {\n-                                if (results[ty.path + ty.name].lev > lev) {\n-                                    results[ty.path + ty.name].lev = lev;\n+                                if (results[fullId].lev > lev) {\n+                                    results[fullId].lev = lev;\n                                 }\n                                 if (in_args === true) {\n-                                    results[ty.path + ty.name].in_args = true;\n+                                    results[fullId].in_args = true;\n                                 }\n                                 if (returned === true) {\n-                                    results[ty.path + ty.name].returned = true;\n+                                    results[fullId].returned = true;\n                                 }\n                             }\n                         }"}, {"sha": "df79760894e3025c6af5b87f9f7342f4357e480f", "filename": "src/libstd_unicode/unicode.py", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/18250b0349848fbfca53153cf121724c773dd508/src%2Flibstd_unicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/18250b0349848fbfca53153cf121724c773dd508/src%2Flibstd_unicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Funicode.py?ref=18250b0349848fbfca53153cf121724c773dd508", "patch": "@@ -89,7 +89,7 @@ def load_unicode_data(f):\n         if is_surrogate(cp):\n             continue\n         if range_start >= 0:\n-            for i in xrange(range_start, cp):\n+            for i in range(range_start, cp):\n                 udict[i] = data\n             range_start = -1\n         if data[1].endswith(\", First>\"):\n@@ -382,7 +382,7 @@ def compute_trie(rawdata, chunksize):\n     root = []\n     childmap = {}\n     child_data = []\n-    for i in range(len(rawdata) / chunksize):\n+    for i in range(len(rawdata) // chunksize):\n         data = rawdata[i * chunksize: (i + 1) * chunksize]\n         child = '|'.join(map(str, data))\n         if child not in childmap:\n@@ -400,7 +400,7 @@ def emit_bool_trie(f, name, t_data, is_pub=True):\n \n     # convert to bitmap chunks of 64 bits each\n     chunks = []\n-    for i in range(0x110000 / CHUNK):\n+    for i in range(0x110000 // CHUNK):\n         chunk = 0\n         for j in range(64):\n             if rawdata[i * 64 + j]:\n@@ -412,12 +412,12 @@ def emit_bool_trie(f, name, t_data, is_pub=True):\n         pub_string = \"pub \"\n     f.write(\"    %sconst %s: &'static super::BoolTrie = &super::BoolTrie {\\n\" % (pub_string, name))\n     f.write(\"        r1: [\\n\")\n-    data = ','.join('0x%016x' % chunk for chunk in chunks[0:0x800 / CHUNK])\n+    data = ','.join('0x%016x' % chunk for chunk in chunks[0:0x800 // CHUNK])\n     format_table_content(f, data, 12)\n     f.write(\"\\n        ],\\n\")\n \n     # 0x800..0x10000 trie\n-    (r2, r3) = compute_trie(chunks[0x800 / CHUNK : 0x10000 / CHUNK], 64 / CHUNK)\n+    (r2, r3) = compute_trie(chunks[0x800 // CHUNK : 0x10000 // CHUNK], 64 // CHUNK)\n     f.write(\"        r2: [\\n\")\n     data = ','.join(str(node) for node in r2)\n     format_table_content(f, data, 12)\n@@ -428,7 +428,7 @@ def emit_bool_trie(f, name, t_data, is_pub=True):\n     f.write(\"\\n        ],\\n\")\n \n     # 0x10000..0x110000 trie\n-    (mid, r6) = compute_trie(chunks[0x10000 / CHUNK : 0x110000 / CHUNK], 64 / CHUNK)\n+    (mid, r6) = compute_trie(chunks[0x10000 // CHUNK : 0x110000 // CHUNK], 64 // CHUNK)\n     (r4, r5) = compute_trie(mid, 64)\n     f.write(\"        r4: [\\n\")\n     data = ','.join(str(node) for node in r4)\n@@ -446,14 +446,14 @@ def emit_bool_trie(f, name, t_data, is_pub=True):\n     f.write(\"    };\\n\\n\")\n \n def emit_small_bool_trie(f, name, t_data, is_pub=True):\n-    last_chunk = max(int(hi / 64) for (lo, hi) in t_data)\n+    last_chunk = max(hi // 64 for (lo, hi) in t_data)\n     n_chunks = last_chunk + 1\n     chunks = [0] * n_chunks\n     for (lo, hi) in t_data:\n         for cp in range(lo, hi + 1):\n-            if int(cp / 64) >= len(chunks):\n-                print(cp, int(cp / 64), len(chunks), lo, hi)\n-            chunks[int(cp / 64)] |= 1 << (cp & 63)\n+            if cp // 64 >= len(chunks):\n+                print(cp, cp // 64, len(chunks), lo, hi)\n+            chunks[cp // 64] |= 1 << (cp & 63)\n \n     pub_string = \"\"\n     if is_pub:\n@@ -519,32 +519,29 @@ def emit_conversions_module(f, to_upper, to_lower, to_title):\n     pfun = lambda x: \"(%s,[%s,%s,%s])\" % (\n         escape_char(x[0]), escape_char(x[1][0]), escape_char(x[1][1]), escape_char(x[1][2]))\n     emit_table(f, \"to_lowercase_table\",\n-        sorted(to_lower.iteritems(), key=operator.itemgetter(0)),\n+        sorted(to_lower.items(), key=operator.itemgetter(0)),\n         is_pub=False, t_type = t_type, pfun=pfun)\n     emit_table(f, \"to_uppercase_table\",\n-        sorted(to_upper.iteritems(), key=operator.itemgetter(0)),\n+        sorted(to_upper.items(), key=operator.itemgetter(0)),\n         is_pub=False, t_type = t_type, pfun=pfun)\n     f.write(\"}\\n\\n\")\n \n def emit_norm_module(f, canon, compat, combine, norm_props):\n-    canon_keys = canon.keys()\n-    canon_keys.sort()\n+    canon_keys = sorted(canon.keys())\n \n-    compat_keys = compat.keys()\n-    compat_keys.sort()\n+    compat_keys = sorted(compat.keys())\n \n     canon_comp = {}\n     comp_exclusions = norm_props[\"Full_Composition_Exclusion\"]\n     for char in canon_keys:\n-        if True in map(lambda (lo, hi): lo <= char <= hi, comp_exclusions):\n+        if any(lo <= char <= hi for lo, hi in comp_exclusions):\n             continue\n         decomp = canon[char]\n         if len(decomp) == 2:\n-            if not canon_comp.has_key(decomp[0]):\n+            if decomp[0] not in canon_comp:\n                 canon_comp[decomp[0]] = []\n             canon_comp[decomp[0]].append( (decomp[1], char) )\n-    canon_comp_keys = canon_comp.keys()\n-    canon_comp_keys.sort()\n+    canon_comp_keys = sorted(canon_comp.keys())\n \n if __name__ == \"__main__\":\n     r = \"tables.rs\""}]}