{"sha": "ffd21b184ccf159c2574f1062b5f3b188a603148", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZDIxYjE4NGNjZjE1OWMyNTc0ZjEwNjJiNWYzYjE4OGE2MDMxNDg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-06T21:54:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-06T21:54:37Z"}, "message": "add in a \"paranoid\" trait bound", "tree": {"sha": "63ba30452182a74de95a6e1be3975a14c51ff53c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63ba30452182a74de95a6e1be3975a14c51ff53c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffd21b184ccf159c2574f1062b5f3b188a603148", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffd21b184ccf159c2574f1062b5f3b188a603148", "html_url": "https://github.com/rust-lang/rust/commit/ffd21b184ccf159c2574f1062b5f3b188a603148", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffd21b184ccf159c2574f1062b5f3b188a603148/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80447c38aaf680f15c5bd37e154fb0bf01b68573", "url": "https://api.github.com/repos/rust-lang/rust/commits/80447c38aaf680f15c5bd37e154fb0bf01b68573", "html_url": "https://github.com/rust-lang/rust/commit/80447c38aaf680f15c5bd37e154fb0bf01b68573"}], "stats": {"total": 34, "additions": 34, "deletions": 0}, "files": [{"sha": "a8c08387075aeb51889d899e3124a6be924d76e2", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ffd21b184ccf159c2574f1062b5f3b188a603148/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd21b184ccf159c2574f1062b5f3b188a603148/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=ffd21b184ccf159c2574f1062b5f3b188a603148", "patch": "@@ -488,6 +488,13 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 ty.obligations = vec![];\n             }\n \n+            push_paranoid_cache_value_obligation(infcx,\n+                                                 param_env,\n+                                                 projection_ty,\n+                                                 cause,\n+                                                 depth,\n+                                                 &mut ty);\n+\n             return Some(ty);\n         }\n         Err(ProjectionCacheEntry::Error) => {\n@@ -612,6 +619,33 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n     NormalizedTy { value: result.value, obligations }\n }\n \n+/// Whenever we give back a cache result for a projection like `<T as\n+/// Trait>::Item ==> X`, we *always* include the obligation to prove\n+/// that `T: Trait` (we may also include some other obligations). This\n+/// may or may not be necessary -- in principle, all the obligations\n+/// that must be proven to show that `T: Trait` were also returned\n+/// when the cache was first populated.  But there is a vague concern\n+/// that perhaps someone would not have proven those, but also not\n+/// have used a snapshot, in which case the cache could remain\n+/// populated even though `T: Trait` has not been shown. Returning\n+/// this \"paranoid\" obligation ensures that, no matter what has come\n+/// before, if you prove the subobligations, we at least know that `T:\n+/// Trait` is implemented.\n+fn push_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                                                        param_env: ty::ParamEnv<'tcx>,\n+                                                        projection_ty: ty::ProjectionTy<'tcx>,\n+                                                        cause: ObligationCause<'tcx>,\n+                                                        depth: usize,\n+                                                        result: &mut NormalizedTy<'tcx>)\n+{\n+    let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n+    let trait_obligation = Obligation { cause,\n+                                        recursion_depth: depth,\n+                                        param_env,\n+                                        predicate: trait_ref.to_predicate() };\n+    result.obligations.push(trait_obligation);\n+}\n+\n /// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n /// hold. In various error cases, we cannot generate a valid\n /// normalized projection. Therefore, we create an inference variable"}]}