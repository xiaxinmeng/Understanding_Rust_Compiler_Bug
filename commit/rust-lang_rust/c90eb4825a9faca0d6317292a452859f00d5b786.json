{"sha": "c90eb4825a9faca0d6317292a452859f00d5b786", "node_id": "C_kwDOAAsO6NoAKGM5MGViNDgyNWE5ZmFjYTBkNjMxNzI5MmE0NTI4NTlmMDBkNWI3ODY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T21:31:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T21:31:06Z"}, "message": "Auto merge of #108282 - cjgillot:mir-checked-sh, r=tmiasko\n\nImplement checked Shl/Shr at MIR building.\n\nThis does not require any special handling by codegen backends,\nas the overflow behaviour is entirely determined by the rhs (shift amount).\n\nThis allows MIR ConstProp to remove the overflow check for constant shifts.\n\n~There is an existing different behaviour between cg_llvm and cg_clif (cc `@bjorn3).`\nI took cg_llvm's one as reference: overflow if `rhs < 0 || rhs > number_of_bits_in_lhs_ty`.~\n\nEDIT: `cg_llvm` and `cg_clif` implement the overflow check differently. This PR uses `cg_llvm`'s implementation based on a `BitAnd` instead of `cg_clif`'s one based on an unsigned comparison.", "tree": {"sha": "482fef868539e6bd9b3c955a3290efa6d0441fa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/482fef868539e6bd9b3c955a3290efa6d0441fa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c90eb4825a9faca0d6317292a452859f00d5b786", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c90eb4825a9faca0d6317292a452859f00d5b786", "html_url": "https://github.com/rust-lang/rust/commit/c90eb4825a9faca0d6317292a452859f00d5b786", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c90eb4825a9faca0d6317292a452859f00d5b786/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab654863c3d50482f260cf862647f1fe0ff5e010", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab654863c3d50482f260cf862647f1fe0ff5e010", "html_url": "https://github.com/rust-lang/rust/commit/ab654863c3d50482f260cf862647f1fe0ff5e010"}, {"sha": "0422f44dc475f60b9e9dbf5e0015abf9dcdffe44", "url": "https://api.github.com/repos/rust-lang/rust/commits/0422f44dc475f60b9e9dbf5e0015abf9dcdffe44", "html_url": "https://github.com/rust-lang/rust/commit/0422f44dc475f60b9e9dbf5e0015abf9dcdffe44"}], "stats": {"total": 220, "additions": 109, "deletions": 111}, "files": [{"sha": "1357b7be1e0959f5348833fe4b11ce18a71ca883", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=c90eb4825a9faca0d6317292a452859f00d5b786", "patch": "@@ -170,14 +170,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n ) -> CValue<'tcx> {\n-    if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n-        assert_eq!(\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty,\n-            \"checked int binop requires lhs and rhs of same type\"\n-        );\n-    }\n-\n     let lhs = in_lhs.load_scalar(fx);\n     let rhs = in_rhs.load_scalar(fx);\n \n@@ -271,21 +263,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                 _ => unreachable!(\"invalid non-integer type {}\", ty),\n             }\n         }\n-        BinOp::Shl => {\n-            let val = fx.bcx.ins().ishl(lhs, rhs);\n-            let ty = fx.bcx.func.dfg.value_type(val);\n-            let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n-            (val, has_overflow)\n-        }\n-        BinOp::Shr => {\n-            let val =\n-                if !signed { fx.bcx.ins().ushr(lhs, rhs) } else { fx.bcx.ins().sshr(lhs, rhs) };\n-            let ty = fx.bcx.func.dfg.value_type(val);\n-            let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n-            (val, has_overflow)\n-        }\n         _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n "}, {"sha": "13c4fa132d877ffa98f2b2e1b64b8409126755c8", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=c90eb4825a9faca0d6317292a452859f00d5b786", "patch": "@@ -663,17 +663,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 bx.checked_binop(oop, input_ty, lhs, rhs)\n             }\n-            mir::BinOp::Shl | mir::BinOp::Shr => {\n-                let lhs_llty = bx.cx().val_ty(lhs);\n-                let rhs_llty = bx.cx().val_ty(rhs);\n-                let invert_mask = common::shift_mask_val(bx, lhs_llty, rhs_llty, true);\n-                let outer_bits = bx.and(rhs, invert_mask);\n-\n-                let of = bx.icmp(IntPredicate::IntNE, outer_bits, bx.cx().const_null(rhs_llty));\n-                let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n-\n-                (val, of)\n-            }\n             _ => bug!(\"Operator `{:?}` is not a checkable operator\", op),\n         };\n "}, {"sha": "e0939d1d1ba9d5a38aaf0d23fa286eb775a0312d", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=c90eb4825a9faca0d6317292a452859f00d5b786", "patch": "@@ -564,15 +564,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    Shl | Shr => {\n-                        for x in [a, b] {\n-                            check_kinds!(\n-                                x,\n-                                \"Cannot perform checked shift on non-integer type {:?}\",\n-                                ty::Uint(..) | ty::Int(..)\n-                            )\n-                        }\n-                    }\n                     _ => self.fail(location, format!(\"There is no checked version of {:?}\", op)),\n                 }\n             }"}, {"sha": "2205c42f7ce9ce2504d41861ef8a372f35fa0b99", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=c90eb4825a9faca0d6317292a452859f00d5b786", "patch": "@@ -1083,10 +1083,6 @@ pub enum Rvalue<'tcx> {\n     /// For addition, subtraction, and multiplication on integers the error condition is set when\n     /// the infinite precision result would be unequal to the actual result.\n     ///\n-    /// For shift operations on integers the error condition is set when the value of right-hand\n-    /// side is greater than or equal to the number of bits in the type of the left-hand side, or\n-    /// when the value of right-hand side is negative.\n-    ///\n     /// Other combinations of types and operators are unsupported.\n     CheckedBinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n "}, {"sha": "dc585f438f4cdcefd33720ed752a6cb5248f8bf3", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=c90eb4825a9faca0d6317292a452859f00d5b786", "patch": "@@ -60,22 +60,13 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n     }\n }\n \n-fn int_size_and_signed<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> (Size, bool) {\n-    let (int, signed) = match *ty.kind() {\n-        ty::Int(ity) => (Integer::from_int_ty(&tcx, ity), true),\n-        ty::Uint(uty) => (Integer::from_uint_ty(&tcx, uty), false),\n-        _ => bug!(\"non integer discriminant\"),\n-    };\n-    (int.size(), signed)\n-}\n-\n impl<'tcx> Discr<'tcx> {\n     /// Adds `1` to the value and wraps around if the maximum for the type is reached.\n     pub fn wrap_incr(self, tcx: TyCtxt<'tcx>) -> Self {\n         self.checked_add(tcx, 1).0\n     }\n     pub fn checked_add(self, tcx: TyCtxt<'tcx>, n: u128) -> (Self, bool) {\n-        let (size, signed) = int_size_and_signed(tcx, self.ty);\n+        let (size, signed) = self.ty.int_size_and_signed(tcx);\n         let (val, oflo) = if signed {\n             let min = size.signed_int_min();\n             let max = size.signed_int_max();\n@@ -929,12 +920,21 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for OpaqueTypeExpander<'tcx> {\n }\n \n impl<'tcx> Ty<'tcx> {\n+    pub fn int_size_and_signed(self, tcx: TyCtxt<'tcx>) -> (Size, bool) {\n+        let (int, signed) = match *self.kind() {\n+            ty::Int(ity) => (Integer::from_int_ty(&tcx, ity), true),\n+            ty::Uint(uty) => (Integer::from_uint_ty(&tcx, uty), false),\n+            _ => bug!(\"non integer discriminant\"),\n+        };\n+        (int.size(), signed)\n+    }\n+\n     /// Returns the maximum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n     pub fn numeric_max_val(self, tcx: TyCtxt<'tcx>) -> Option<ty::Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n-                let (size, signed) = int_size_and_signed(tcx, self);\n+                let (size, signed) = self.int_size_and_signed(tcx);\n                 let val =\n                     if signed { size.signed_int_max() as u128 } else { size.unsigned_int_max() };\n                 Some(val)\n@@ -955,7 +955,7 @@ impl<'tcx> Ty<'tcx> {\n     pub fn numeric_min_val(self, tcx: TyCtxt<'tcx>) -> Option<ty::Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n-                let (size, signed) = int_size_and_signed(tcx, self);\n+                let (size, signed) = self.int_size_and_signed(tcx);\n                 let val = if signed { size.truncate(size.signed_int_min() as u128) } else { 0 };\n                 Some(val)\n             }"}, {"sha": "259e0f8f75c1b4423050bc6089a4a008758454d6", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 63, "deletions": 22, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90eb4825a9faca0d6317292a452859f00d5b786/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c90eb4825a9faca0d6317292a452859f00d5b786", "patch": "@@ -9,6 +9,7 @@ use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder, NeedsTemporary};\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::middle::region;\n+use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::Place;\n use rustc_middle::mir::*;\n@@ -519,30 +520,68 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> BlockAnd<Rvalue<'tcx>> {\n         let source_info = self.source_info(span);\n         let bool_ty = self.tcx.types.bool;\n-        if self.check_overflow && op.is_checkable() && ty.is_integral() {\n-            let result_tup = self.tcx.mk_tup(&[ty, bool_ty]);\n-            let result_value = self.temp(result_tup, span);\n+        let rvalue = match op {\n+            BinOp::Add | BinOp::Sub | BinOp::Mul if self.check_overflow && ty.is_integral() => {\n+                let result_tup = self.tcx.mk_tup(&[ty, bool_ty]);\n+                let result_value = self.temp(result_tup, span);\n \n-            self.cfg.push_assign(\n-                block,\n-                source_info,\n-                result_value,\n-                Rvalue::CheckedBinaryOp(op, Box::new((lhs.to_copy(), rhs.to_copy()))),\n-            );\n-            let val_fld = Field::new(0);\n-            let of_fld = Field::new(1);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    result_value,\n+                    Rvalue::CheckedBinaryOp(op, Box::new((lhs.to_copy(), rhs.to_copy()))),\n+                );\n+                let val_fld = Field::new(0);\n+                let of_fld = Field::new(1);\n+\n+                let tcx = self.tcx;\n+                let val = tcx.mk_place_field(result_value, val_fld, ty);\n+                let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n \n-            let tcx = self.tcx;\n-            let val = tcx.mk_place_field(result_value, val_fld, ty);\n-            let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n+                let err = AssertKind::Overflow(op, lhs, rhs);\n+                block = self.assert(block, Operand::Move(of), false, err, span);\n \n-            let err = AssertKind::Overflow(op, lhs, rhs);\n+                Rvalue::Use(Operand::Move(val))\n+            }\n+            BinOp::Shl | BinOp::Shr if self.check_overflow && ty.is_integral() => {\n+                // Consider that the shift overflows if `rhs < 0` or `rhs >= bits`.\n+                // This can be encoded as a single operation as `(rhs & -bits) != 0`.\n+                let (size, _) = ty.int_size_and_signed(self.tcx);\n+                let bits = size.bits();\n+                debug_assert!(bits.is_power_of_two());\n+                let mask = !((bits - 1) as u128);\n+\n+                let rhs_ty = rhs.ty(&self.local_decls, self.tcx);\n+                let (rhs_size, _) = rhs_ty.int_size_and_signed(self.tcx);\n+                let mask = Operand::const_from_scalar(\n+                    self.tcx,\n+                    rhs_ty,\n+                    Scalar::from_uint(rhs_size.truncate(mask), rhs_size),\n+                    span,\n+                );\n \n-            block = self.assert(block, Operand::Move(of), false, err, span);\n+                let outer_bits = self.temp(rhs_ty, span);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    outer_bits,\n+                    Rvalue::BinaryOp(BinOp::BitAnd, Box::new((rhs.to_copy(), mask))),\n+                );\n \n-            block.and(Rvalue::Use(Operand::Move(val)))\n-        } else {\n-            if ty.is_integral() && (op == BinOp::Div || op == BinOp::Rem) {\n+                let overflows = self.temp(bool_ty, span);\n+                let zero = self.zero_literal(span, rhs_ty);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    overflows,\n+                    Rvalue::BinaryOp(BinOp::Ne, Box::new((Operand::Move(outer_bits), zero))),\n+                );\n+\n+                let overflow_err = AssertKind::Overflow(op, lhs.to_copy(), rhs.to_copy());\n+                block = self.assert(block, Operand::Move(overflows), false, overflow_err, span);\n+                Rvalue::BinaryOp(op, Box::new((lhs, rhs)))\n+            }\n+            BinOp::Div | BinOp::Rem if ty.is_integral() => {\n                 // Checking division and remainder is more complex, since we 1. always check\n                 // and 2. there are two possible failure cases, divide-by-zero and overflow.\n \n@@ -601,10 +640,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     block = self.assert(block, Operand::Move(of), false, overflow_err, span);\n                 }\n-            }\n \n-            block.and(Rvalue::BinaryOp(op, Box::new((lhs, rhs))))\n-        }\n+                Rvalue::BinaryOp(op, Box::new((lhs, rhs)))\n+            }\n+            _ => Rvalue::BinaryOp(op, Box::new((lhs, rhs))),\n+        };\n+        block.and(rvalue)\n     }\n \n     fn build_zero_repeat("}, {"sha": "fb0b3866e696baf062c0265ee1d5fb87a954bdf2", "filename": "tests/mir-opt/issue_101973.inner.ConstProp.diff", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c90eb4825a9faca0d6317292a452859f00d5b786/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c90eb4825a9faca0d6317292a452859f00d5b786/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=c90eb4825a9faca0d6317292a452859f00d5b786", "patch": "@@ -12,13 +12,14 @@\n       let mut _7: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n       let mut _8: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       let mut _9: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:33: +1:39\n-      let mut _10: (u32, bool);            // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-      let mut _11: (u32, bool);            // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+      let mut _10: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+      let mut _11: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+      let mut _12: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+      let mut _13: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       scope 1 (inlined imm8) {             // at $DIR/issue_101973.rs:14:5: 14:17\n           debug x => _1;                   // in scope 1 at $DIR/issue_101973.rs:5:13: 5:14\n-          let mut _12: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:27\n-          let mut _13: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n-          let mut _14: (u32, bool);        // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n+          let mut _14: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:27\n+          let mut _15: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n           scope 2 {\n               debug out => _4;             // in scope 2 at $DIR/issue_101973.rs:6:9: 6:16\n           }\n@@ -32,43 +33,46 @@\n           StorageLive(_2);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:65\n           StorageLive(_3);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:58\n           StorageLive(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:17\n-          StorageLive(_12);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n-          StorageLive(_13);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          _14 = CheckedShr(_1, const 0_i32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          assert(!move (_14.1: bool), \"attempt to shift right by `{}`, which would overflow\", const 0_i32) -> bb3; // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n+          StorageLive(_14);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n+          StorageLive(_15);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n+          _15 = Shr(_1, const 0_i32);      // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n+          _14 = BitAnd(move _15, const 255_u32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n+          StorageDead(_15);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n+          _4 = BitOr(const 0_u32, move _14); // scope 2 at $DIR/issue_101973.rs:7:5: 7:27\n+          StorageDead(_14);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n+          StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+          StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n+          StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _10 = BitAnd(const 8_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _11 = Ne(move _10, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         assert(!move _11, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _10 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _11 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         assert(!const false, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       }\n   \n       bb1: {\n-          _8 = move (_10.0: u32);          // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+          _8 = Shr(_1, const 8_i32);       // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n           _7 = BitAnd(move _8, const 15_u32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageDead(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:51: +1:52\n-          _11 = CheckedShl(_7, const 1_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-          assert(!move (_11.1: bool), \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _12 = BitAnd(const 1_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _13 = Ne(move _12, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         assert(!move _13, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _12 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _13 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         assert(!const false, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       }\n   \n       bb2: {\n-          _6 = move (_11.0: u32);          // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+          _6 = Shl(move _7, const 1_i32);  // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n           StorageDead(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:56: +1:57\n-          _3 = rotate_right::<u32>(_4, _6) -> bb4; // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          _3 = rotate_right::<u32>(_4, _6) -> bb3; // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n                                            // + literal: Const { ty: extern \"rust-intrinsic\" fn(u32, u32) -> u32 {rotate_right::<u32>}, val: Value(<ZST>) }\n       }\n   \n       bb3: {\n-          _13 = move (_14.0: u32);         // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          _12 = BitAnd(move _13, const 255_u32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n-          StorageDead(_13);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n-          _4 = BitOr(const 0_u32, move _12); // scope 2 at $DIR/issue_101973.rs:7:5: 7:27\n-          StorageDead(_12);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n-          StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-          StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n-          StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-          _10 = CheckedShr(_1, const 8_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-          assert(!move (_10.1: bool), \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-      }\n-  \n-      bb4: {\n           StorageDead(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:57: +1:58\n           StorageDead(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:57: +1:58\n           _2 = move _3 as i32 (IntToInt);  // scope 0 at $DIR/issue_101973.rs:+1:5: +1:65"}, {"sha": "6530084a5857dd27f7346292dc67e58514971dff", "filename": "tests/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c90eb4825a9faca0d6317292a452859f00d5b786/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90eb4825a9faca0d6317292a452859f00d5b786/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=c90eb4825a9faca0d6317292a452859f00d5b786", "patch": "@@ -39,19 +39,19 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:53:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, start_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc18 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc17 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:62:14\n    |\n LL |     unsafe { ptr_offset_from(start_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc21 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc20 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:70:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc24 has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc23 has size 4, so pointer at offset 10 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:79:14"}]}