{"sha": "078bd498b9fa6eab40df147ce6015ab9aae62b40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3OGJkNDk4YjlmYTZlYWI0MGRmMTQ3Y2U2MDE1YWI5YWFlNjJiNDA=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-12T21:59:34Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-17T15:49:49Z"}, "message": "Evaluate # fn in docs\n\nI searched for times when we were hiding functions with # in the documentation,\nand fixed them to not use it unless neccesary.\n\nI also made random improvements whenever I changed something. For example,\nI changed Example to Examples, for consistency.\n\nFixes #13423", "tree": {"sha": "6f3ce07b5482affc2c534e937bf9bb23ccfd8f65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f3ce07b5482affc2c534e937bf9bb23ccfd8f65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/078bd498b9fa6eab40df147ce6015ab9aae62b40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/078bd498b9fa6eab40df147ce6015ab9aae62b40", "html_url": "https://github.com/rust-lang/rust/commit/078bd498b9fa6eab40df147ce6015ab9aae62b40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/078bd498b9fa6eab40df147ce6015ab9aae62b40/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a03701defaf00f323aeaff033d84d93545448b77", "url": "https://api.github.com/repos/rust-lang/rust/commits/a03701defaf00f323aeaff033d84d93545448b77", "html_url": "https://github.com/rust-lang/rust/commit/a03701defaf00f323aeaff033d84d93545448b77"}], "stats": {"total": 197, "additions": 95, "deletions": 102}, "files": [{"sha": "df94e91067c15a0bb3b287e7c73edfd71ddd7293", "filename": "src/doc/trpl/threads.md", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Fdoc%2Ftrpl%2Fthreads.md", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Fdoc%2Ftrpl%2Fthreads.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthreads.md?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -51,13 +51,15 @@ closure is limited to capturing `Send`-able data from its environment\n ensures that `spawn` can safely move the entire closure and all its\n associated state into an entirely different thread for execution.\n \n-```{rust,ignore}\n-# use std::thread::spawn;\n-# fn generate_thread_number() -> int { 0 }\n+```rust\n+use std::thread::Thread;\n+\n+fn generate_thread_number() -> i32 { 4 } // a very simple generation\n+\n // Generate some state locally\n let child_thread_number = generate_thread_number();\n \n-spawn(move || {\n+Thread::spawn(move || {\n     // Capture it in the remote thread. The `move` keyword indicates\n     // that this closure should move `child_thread_number` into its\n     // environment, rather than capturing a reference into the\n@@ -77,40 +79,44 @@ The simplest way to create a channel is to use the `channel` function to create\n of a channel, and a *receiver* is the receiving endpoint. Consider the following\n example of calculating two results concurrently:\n \n-```{rust,ignore}\n-# use std::thread::spawn;\n+```rust\n+use std::thread::Thread;\n+use std::sync::mpsc;\n \n-let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n+let (tx, rx): (mpsc::Sender<u32>, mpsc::Receiver<u32>) = mpsc::channel();\n \n-spawn(move || {\n+Thread::spawn(move || {\n     let result = some_expensive_computation();\n     tx.send(result);\n });\n \n some_other_expensive_computation();\n let result = rx.recv();\n-# fn some_expensive_computation() -> int { 42 }\n-# fn some_other_expensive_computation() {}\n+\n+fn some_expensive_computation() -> u32 { 42 } // very expensive ;)\n+fn some_other_expensive_computation() {}      // even more so\n ```\n \n Let's examine this example in detail. First, the `let` statement creates a\n stream for sending and receiving integers (the left-hand side of the `let`,\n `(tx, rx)`, is an example of a destructuring let: the pattern separates a tuple\n into its component parts).\n \n-```{rust,ignore}\n-let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n+```rust\n+# use std::sync::mpsc;\n+let (tx, rx): (mpsc::Sender<u32>, mpsc::Receiver<u32>) = mpsc::channel();\n ```\n \n The child thread will use the sender to send data to the parent thread, which will\n wait to receive the data on the receiver. The next statement spawns the child\n thread.\n \n-```{rust,ignore}\n-# use std::thread::spawn;\n-# fn some_expensive_computation() -> int { 42 }\n-# let (tx, rx) = channel();\n-spawn(move || {\n+```rust\n+# use std::thread::Thread;\n+# use std::sync::mpsc;\n+# fn some_expensive_computation() -> u32 { 42 }\n+# let (tx, rx) = mpsc::channel();\n+Thread::spawn(move || {\n     let result = some_expensive_computation();\n     tx.send(result);\n });\n@@ -125,9 +131,10 @@ computation, then sends the result over the captured channel.\n Finally, the parent continues with some other expensive computation, then waits\n for the child's result to arrive on the receiver:\n \n-```{rust,ignore}\n+```rust\n+# use std::sync::mpsc;\n # fn some_other_expensive_computation() {}\n-# let (tx, rx) = channel::<int>();\n+# let (tx, rx) = mpsc::channel::<u32>();\n # tx.send(0);\n some_other_expensive_computation();\n let result = rx.recv();\n@@ -140,8 +147,9 @@ single `Receiver` value.  What if our example needed to compute multiple\n results across a number of threads? The following program is ill-typed:\n \n ```{rust,ignore}\n-# fn some_expensive_computation() -> int { 42 }\n-let (tx, rx) = channel();\n+# use std::sync::mpsc;\n+# fn some_expensive_computation() -> u32 { 42 }\n+let (tx, rx) = mpsc::channel();\n \n spawn(move || {\n     tx.send(some_expensive_computation());\n@@ -156,19 +164,22 @@ spawn(move || {\n \n Instead we can clone the `tx`, which allows for multiple senders.\n \n-```{rust,ignore}\n-let (tx, rx) = channel();\n+```rust\n+use std::thread::Thread;\n+use std::sync::mpsc;\n+\n+let (tx, rx) = mpsc::channel();\n \n-for init_val in range(0u, 3) {\n+for init_val in 0 .. 3 {\n     // Create a new channel handle to distribute to the child thread\n     let child_tx = tx.clone();\n-    spawn(move || {\n+    Thread::spawn(move || {\n         child_tx.send(some_expensive_computation(init_val));\n     });\n }\n \n-let result = rx.recv() + rx.recv() + rx.recv();\n-# fn some_expensive_computation(_i: uint) -> int { 42 }\n+let result = rx.recv().unwrap() + rx.recv().unwrap() + rx.recv().unwrap();\n+# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n ```\n \n Cloning a `Sender` produces a new handle to the same channel, allowing multiple\n@@ -181,21 +192,22 @@ Note that the above cloning example is somewhat contrived since you could also\n simply use three `Sender` pairs, but it serves to illustrate the point. For\n reference, written with multiple streams, it might look like the example below.\n \n-```{rust,ignore}\n-# use std::thread::spawn;\n+```rust\n+use std::thread::Thread;\n+use std::sync::mpsc;\n \n // Create a vector of ports, one for each child thread\n-let rxs = Vec::from_fn(3, |init_val| {\n-    let (tx, rx) = channel();\n-    spawn(move || {\n+let rxs = (0 .. 3).map(|&:init_val| {\n+    let (tx, rx) = mpsc::channel();\n+    Thread::spawn(move || {\n         tx.send(some_expensive_computation(init_val));\n     });\n     rx\n-});\n+}).collect::<Vec<_>>();\n \n // Wait on each port, accumulating the results\n-let result = rxs.iter().fold(0, |accum, rx| accum + rx.recv() );\n-# fn some_expensive_computation(_i: uint) -> int { 42 }\n+let result = rxs.iter().fold(0, |&:accum, rx| accum + rx.recv().unwrap() );\n+# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n ```\n \n ## Backgrounding computations: Futures"}, {"sha": "963cb48db0701115347e6fb0dc29d6356e7187f5", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -115,7 +115,6 @@\n //!     }\n //! #   fn calc_span_tree(&self) -> Vec<(uint, uint)> { vec![] }\n //! }\n-//! # fn main() { }\n //! ```\n //!\n //! ## Mutating implementations of `clone`"}, {"sha": "ed3612bded05e93e08458bf2afc2a03b76c06e87", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -23,13 +23,11 @@\n //!\n //! use std::finally::Finally;\n //!\n-//! # fn main() {\n //! (|&mut:| {\n //!     // ...\n //! }).finally(|| {\n //!     // this code is always run\n //! })\n-//! # }\n //! ```\n \n #![deprecated = \"It is unclear if this module is more robust than implementing \\"}, {"sha": "1c37126e8e9020b3b281405a52e09d4978e28045", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -39,13 +39,16 @@ macro_rules! panic {\n /// // the panic message for these assertions is the stringified value of the\n /// // expression given.\n /// assert!(true);\n-/// # fn some_computation() -> bool { true }\n+///\n+/// fn some_computation() -> bool { true } // a very simple function\n+///\n /// assert!(some_computation());\n ///\n /// // assert with a custom message\n-/// # let x = true;\n+/// let x = true;\n /// assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n+///\n+/// let a = 3i; let b = 27i;\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n@@ -108,13 +111,15 @@ macro_rules! assert_eq {\n /// // the panic message for these assertions is the stringified value of the\n /// // expression given.\n /// debug_assert!(true);\n-/// # fn some_expensive_computation() -> bool { true }\n+///\n+/// fn some_expensive_computation() -> bool { true } // a very simple function\n /// debug_assert!(some_expensive_computation());\n ///\n /// // assert with a custom message\n-/// # let x = true;\n+/// let x = true;\n /// debug_assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n+///\n+/// let a = 3; let b = 27;\n /// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]"}, {"sha": "6d272f91698e70d23dff584761889272c5504190", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -210,8 +210,7 @@ impl<T: ?Sized> Clone for ContravariantType<T> {\n /// \"interior\" mutability:\n ///\n /// ```\n-/// pub struct Cell<T> { value: T }\n-/// # fn main() {}\n+/// struct Cell<T> { value: T }\n /// ```\n ///\n /// The type system would infer that `value` is only read here and"}, {"sha": "da3f180d7e127d02d20f16af611572997efc77cb", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -21,11 +21,7 @@\n //! # Example\n //!\n //! ```ignore\n-//! # fn main() {\n-//! #![feature(globs)]\n-//!\n //! use core::prelude::*;\n-//! # }\n //! ```\n \n // Reexported core operators"}, {"sha": "1ab810f937de9a8c715d2e838a6f0ddc543c061a", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -217,11 +217,9 @@\n //! makes it clear:\n //!\n //! ```\n-//! # #![feature(macro_rules)]\n //! macro_rules! try {\n //!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n //! }\n-//! # fn main() { }\n //! ```\n //!\n //! `try!` is imported by the prelude, and is available everywhere."}, {"sha": "36afa0956d2deb7cc77773847dcb1726cf9d203e", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -26,15 +26,13 @@\n //!\n //! Some examples of the `format!` extension are:\n //!\n-//! ```rust\n-//! # fn main() {\n+//! ```\n //! format!(\"Hello\");                  // => \"Hello\"\n //! format!(\"Hello, {}!\", \"world\");    // => \"Hello, world!\"\n //! format!(\"The number is {}\", 1i);   // => \"The number is 1\"\n //! format!(\"{:?}\", (3i, 4i));         // => \"(3i, 4i)\"\n //! format!(\"{value}\", value=4i);      // => \"4\"\n //! format!(\"{} {}\", 1i, 2u);          // => \"1 2\"\n-//! # }\n //! ```\n //!\n //! From these, you can see that the first argument is a format string. It is\n@@ -83,12 +81,10 @@\n //!\n //! For example, the following `format!` expressions all use named argument:\n //!\n-//! ```rust\n-//! # fn main() {\n+//! ```\n //! format!(\"{argument}\", argument = \"test\");   // => \"test\"\n //! format!(\"{name} {}\", 1i, name = 2i);        // => \"2 1\"\n //! format!(\"{a} {c} {b}\", a=\"a\", b='b', c=3i);  // => \"a 3 b\"\n-//! # }\n //! ```\n //!\n //! It is illegal to put positional parameters (those without names) after\n@@ -288,8 +284,6 @@\n //! use std::fmt;\n //! use std::io;\n //!\n-//! # #[allow(unused_must_use)]\n-//! # fn main() {\n //! fmt::format(format_args!(\"this returns {}\", \"String\"));\n //!\n //! let some_writer: &mut io::Writer = &mut io::stdout();\n@@ -299,7 +293,6 @@\n //!     write!(&mut io::stdout(), \"{}\", args);\n //! }\n //! my_fmt_fn(format_args!(\"or a {} too\", \"function\"));\n-//! # }\n //! ```\n //!\n //! The result of the `format_args!` macro is a value of type `fmt::Arguments`."}, {"sha": "e2b71cd43af25e2eedc146755b19d0b9597190db", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -934,16 +934,15 @@ unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -\n /// A `RefReader` is a struct implementing `Reader` which contains a reference\n /// to another reader. This is often useful when composing streams.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n-/// # fn main() {}\n-/// # fn process_input<R: Reader>(r: R) {}\n-/// # fn foo() {\n /// use std::io;\n /// use std::io::ByRefReader;\n /// use std::io::util::LimitReader;\n ///\n+/// fn process_input<R: Reader>(r: R) {}\n+///\n /// let mut stream = io::stdin();\n ///\n /// // Only allow the function to process at most one kilobyte of input\n@@ -953,8 +952,6 @@ unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -\n /// }\n ///\n /// // 'stream' is still available for use here\n-///\n-/// # }\n /// ```\n pub struct RefReader<'a, R:'a> {\n     /// The underlying reader which this is referencing\n@@ -1269,12 +1266,11 @@ impl<'a> Writer for &'a mut (Writer+'a) {\n /// # Example\n ///\n /// ```\n-/// # fn main() {}\n-/// # fn process_input<R: Reader>(r: R) {}\n-/// # fn foo () {\n /// use std::io::util::TeeReader;\n /// use std::io::{stdin, ByRefWriter};\n ///\n+/// fn process_input<R: Reader>(r: R) {}\n+///\n /// let mut output = Vec::new();\n ///\n /// {\n@@ -1285,7 +1281,6 @@ impl<'a> Writer for &'a mut (Writer+'a) {\n /// }\n ///\n /// println!(\"input processed: {:?}\", output);\n-/// # }\n /// ```\n pub struct RefWriter<'a, W:'a> {\n     /// The underlying writer which this is referencing\n@@ -1705,19 +1700,19 @@ pub enum FileType {\n /// A structure used to describe metadata information about a file. This\n /// structure is created through the `stat` method on a `Path`.\n ///\n-/// # Example\n+/// # Examples\n+///\n+/// ```no_run\n+/// # #![allow(unstable)]\n+///\n+/// use std::io::fs::PathExtensions;\n ///\n-/// ```\n-/// # use std::io::fs::PathExtensions;\n-/// # fn main() {}\n-/// # fn foo() {\n /// let info = match Path::new(\"foo.txt\").stat() {\n ///     Ok(stat) => stat,\n ///     Err(e) => panic!(\"couldn't read foo.txt: {}\", e),\n /// };\n ///\n /// println!(\"byte size: {}\", info.size);\n-/// # }\n /// ```\n #[derive(Copy, Hash)]\n pub struct FileStat {"}, {"sha": "61d164d21e320769f8e65fbf610ff104369636de", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -168,9 +168,7 @@ impl UnixListener {\n     /// # Example\n     ///\n     /// ```\n-    /// # fn main() {}\n     /// # fn foo() {\n-    /// # #![allow(unused_must_use)]\n     /// use std::io::net::pipe::UnixListener;\n     /// use std::io::{Listener, Acceptor};\n     ///"}, {"sha": "4978085fa4fbeacd4faa23c602308a3229d9d0a7", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -272,12 +272,10 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n /// A structure representing a socket server. This listener is used to create a\n /// `TcpAcceptor` which can be used to accept sockets on a local port.\n ///\n-/// # Example\n+/// # Examples\n ///\n-/// ```rust\n-/// # fn main() { }\n+/// ```\n /// # fn foo() {\n-/// # #![allow(dead_code)]\n /// use std::io::{TcpListener, TcpStream};\n /// use std::io::{Acceptor, Listener};\n /// use std::thread::Thread;"}, {"sha": "844a97dea2d50eacb54817873e8b5c30c373a37f", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -27,10 +27,9 @@ use sys::timer::Timer as TimerImp;\n /// period of time. Handles to this timer can also be created in the form of\n /// receivers which will receive notifications over time.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n-/// # fn main() {}\n /// # fn foo() {\n /// use std::io::Timer;\n /// use std::time::Duration;\n@@ -54,7 +53,6 @@ use sys::timer::Timer as TimerImp;\n /// the `io::timer` module.\n ///\n /// ```\n-/// # fn main() {}\n /// # fn foo() {\n /// use std::io::timer;\n /// use std::time::Duration;"}, {"sha": "5795b4c38c64f3f7db8e3d950147c0cd5d76daee", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -122,16 +122,18 @@ macro_rules! try {\n /// receivers. It places no restrictions on the types of receivers given to\n /// this macro, this can be viewed as a heterogeneous select.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::thread::Thread;\n-/// use std::sync::mpsc::channel;\n+/// use std::sync::mpsc;\n+///\n+/// // two placeholder functions for now\n+/// fn long_running_task() {}\n+/// fn calculate_the_answer() -> u32 { 42 }\n ///\n-/// let (tx1, rx1) = channel();\n-/// let (tx2, rx2) = channel();\n-/// # fn long_running_task() {}\n-/// # fn calculate_the_answer() -> int { 42i }\n+/// let (tx1, rx1) = mpsc::channel();\n+/// let (tx2, rx2) = mpsc::channel();\n ///\n /// Thread::spawn(move|| { long_running_task(); tx1.send(()).unwrap(); });\n /// Thread::spawn(move|| { tx2.send(calculate_the_answer()).unwrap(); });\n@@ -251,17 +253,15 @@ pub mod builtin {\n     /// statement or expression position, meaning this macro may be difficult to\n     /// use in some situations.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// #![feature(concat_idents)]\n     ///\n-    /// # fn main() {\n-    /// fn foobar() -> int { 23 }\n+    /// fn foobar() -> u32 { 23 }\n     ///\n     /// let f = concat_idents!(foo, bar);\n     /// println!(\"{}\", f());\n-    /// # }\n     /// ```\n     #[macro_export]\n     macro_rules! concat_idents {"}, {"sha": "36bbc5ff5b423952685d0225b7a1c5ab5f94ce3e", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078bd498b9fa6eab40df147ce6015ab9aae62b40/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=078bd498b9fa6eab40df147ce6015ab9aae62b40", "patch": "@@ -11,14 +11,18 @@\n //! A type representing values that may be computed concurrently and operations\n //! for working with them.\n //!\n-//! # Example\n+//! # Examples\n //!\n-//! ```rust\n+//! ```\n //! use std::sync::Future;\n-//! # fn fib(n: uint) -> uint {42};\n-//! # fn make_a_sandwich() {};\n-//! let mut delayed_fib = Future::spawn(move|| { fib(5000) });\n-//! make_a_sandwich();\n+//!\n+//! // a fake, for now\n+//! fn fib(n: u32) -> u32 { 42 };\n+//!\n+//! let mut delayed_fib = Future::spawn(move || fib(5000));\n+//!\n+//! // do stuff...\n+//!\n //! println!(\"fib(5000) = {}\", delayed_fib.get())\n //! ```\n "}]}