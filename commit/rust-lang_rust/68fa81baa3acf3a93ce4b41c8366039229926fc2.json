{"sha": "68fa81baa3acf3a93ce4b41c8366039229926fc2", "node_id": "C_kwDOAAsO6NoAKDY4ZmE4MWJhYTNhY2YzYTkzY2U0YjQxYzgzNjYwMzkyMjk5MjZmYzI", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2022-01-24T09:19:33Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2022-01-24T10:49:10Z"}, "message": "rustc_errors: remove `allow_suggestions` from `DiagnosticBuilder`.", "tree": {"sha": "c5df38fb546f41c444df071d4c0fb15927e46410", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5df38fb546f41c444df071d4c0fb15927e46410"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68fa81baa3acf3a93ce4b41c8366039229926fc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68fa81baa3acf3a93ce4b41c8366039229926fc2", "html_url": "https://github.com/rust-lang/rust/commit/68fa81baa3acf3a93ce4b41c8366039229926fc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68fa81baa3acf3a93ce4b41c8366039229926fc2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "url": "https://api.github.com/repos/rust-lang/rust/commits/42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "html_url": "https://github.com/rust-lang/rust/commit/42313dd29b3edb0ab453a0d43d12876ec7e48ce0"}], "stats": {"total": 192, "additions": 64, "deletions": 128}, "files": [{"sha": "8cfecafd20c86f7bf8f5df29132d33b78699c150", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=68fa81baa3acf3a93ce4b41c8366039229926fc2", "patch": "@@ -11,6 +11,11 @@ use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n \n+/// Error type for `Diagnostic`'s `suggestions` field, indicating that\n+/// `.disable_suggestions()` was called on the `Diagnostic`.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n+pub struct SuggestionsDisabled;\n+\n #[must_use]\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct Diagnostic {\n@@ -19,7 +24,7 @@ pub struct Diagnostic {\n     pub code: Option<DiagnosticId>,\n     pub span: MultiSpan,\n     pub children: Vec<SubDiagnostic>,\n-    pub suggestions: Vec<CodeSuggestion>,\n+    pub suggestions: Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n \n     /// This is not used for highlighting or rendering any error message.  Rather, it can be used\n     /// as a sort key to sort a buffer of diagnostics.  By default, it is the primary span of\n@@ -106,7 +111,7 @@ impl Diagnostic {\n             code,\n             span: MultiSpan::new(),\n             children: vec![],\n-            suggestions: vec![],\n+            suggestions: Ok(vec![]),\n             sort_span: DUMMY_SP,\n             is_lint: false,\n         }\n@@ -300,6 +305,21 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Disallow attaching suggestions this diagnostic.\n+    /// Any suggestions attached e.g. with the `span_suggestion_*` methods\n+    /// (before and after the call to `disable_suggestions`) will be ignored.\n+    pub fn disable_suggestions(&mut self) -> &mut Self {\n+        self.suggestions = Err(SuggestionsDisabled);\n+        self\n+    }\n+\n+    /// Helper for pushing to `self.suggestions`, if available (not disable).\n+    fn push_suggestion(&mut self, suggestion: CodeSuggestion) {\n+        if let Ok(suggestions) = &mut self.suggestions {\n+            suggestions.push(suggestion);\n+        }\n+    }\n+\n     /// Show a suggestion that has multiple parts to it.\n     /// In other words, multiple changes need to be applied as part of this suggestion.\n     pub fn multipart_suggestion(\n@@ -340,7 +360,7 @@ impl Diagnostic {\n         style: SuggestionStyle,\n     ) -> &mut Self {\n         assert!(!suggestion.is_empty());\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: suggestion\n                     .into_iter()\n@@ -368,7 +388,7 @@ impl Diagnostic {\n         applicability: Applicability,\n     ) -> &mut Self {\n         assert!(!suggestion.is_empty());\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: suggestion\n                     .into_iter()\n@@ -426,7 +446,7 @@ impl Diagnostic {\n         applicability: Applicability,\n         style: SuggestionStyle,\n     ) -> &mut Self {\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: vec![SubstitutionPart { snippet: suggestion, span: sp }],\n             }],\n@@ -471,7 +491,7 @@ impl Diagnostic {\n             .into_iter()\n             .map(|snippet| Substitution { parts: vec![SubstitutionPart { snippet, span: sp }] })\n             .collect();\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions,\n             msg: msg.to_owned(),\n             style: SuggestionStyle::ShowCode,\n@@ -489,7 +509,7 @@ impl Diagnostic {\n         suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions: suggestions\n                 .map(|sugg| Substitution {\n                     parts: sugg\n@@ -578,7 +598,7 @@ impl Diagnostic {\n         applicability: Applicability,\n         tool_metadata: Json,\n     ) {\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions: vec![],\n             msg: msg.to_owned(),\n             style: SuggestionStyle::CompletelyHidden,\n@@ -668,7 +688,7 @@ impl Diagnostic {\n         &Vec<(String, Style)>,\n         &Option<DiagnosticId>,\n         &MultiSpan,\n-        &Vec<CodeSuggestion>,\n+        &Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n         Option<&Vec<SubDiagnostic>>,\n     ) {\n         ("}, {"sha": "200c7cbccd97c45c3278db643b17467f7bebb88a", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 25, "deletions": 113, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=68fa81baa3acf3a93ce4b41c8366039229926fc2", "patch": "@@ -22,12 +22,13 @@ pub struct DiagnosticBuilder<'a>(Box<DiagnosticBuilderInner<'a>>);\n /// (RVO) should avoid unnecessary copying. In practice, it does not (at the\n /// time of writing). The split between `DiagnosticBuilder` and\n /// `DiagnosticBuilderInner` exists to avoid many `memcpy` calls.\n+// FIXME(eddyb) try having two pointers in `DiagnosticBuilder`, by only boxing\n+// `Diagnostic` (i.e. `struct DiagnosticBuilder(&Handler, Box<Diagnostic>);`).\n #[must_use]\n #[derive(Clone)]\n struct DiagnosticBuilderInner<'a> {\n     handler: &'a Handler,\n     diagnostic: Diagnostic,\n-    allow_suggestions: bool,\n }\n \n /// In general, the `DiagnosticBuilder` uses deref to allow access to\n@@ -244,164 +245,79 @@ impl<'a> DiagnosticBuilder<'a> {\n     ) -> &mut Self);\n     forward!(pub fn set_is_lint(&mut self,) -> &mut Self);\n \n-    /// See [`Diagnostic::multipart_suggestion()`].\n-    pub fn multipart_suggestion(\n+    forward!(pub fn disable_suggestions(&mut self,) -> &mut Self);\n+\n+    forward!(pub fn multipart_suggestion(\n         &mut self,\n         msg: &str,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.multipart_suggestion(msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::multipart_suggestion()`].\n-    pub fn multipart_suggestion_verbose(\n+    ) -> &mut Self);\n+    forward!(pub fn multipart_suggestion_verbose(\n         &mut self,\n         msg: &str,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.multipart_suggestion_verbose(msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::tool_only_multipart_suggestion()`].\n-    pub fn tool_only_multipart_suggestion(\n+    ) -> &mut Self);\n+    forward!(pub fn tool_only_multipart_suggestion(\n         &mut self,\n         msg: &str,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.tool_only_multipart_suggestion(msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::span_suggestion()`].\n-    pub fn span_suggestion(\n+    ) -> &mut Self);\n+    forward!(pub fn span_suggestion(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.span_suggestion(sp, msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::span_suggestions()`].\n-    pub fn span_suggestions(\n+    ) -> &mut Self);\n+    forward!(pub fn span_suggestions(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestions: impl Iterator<Item = String>,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.span_suggestions(sp, msg, suggestions, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::multipart_suggestions()`].\n-    pub fn multipart_suggestions(\n+    ) -> &mut Self);\n+    forward!(pub fn multipart_suggestions(\n         &mut self,\n         msg: &str,\n         suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.multipart_suggestions(msg, suggestions, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::span_suggestion_short()`].\n-    pub fn span_suggestion_short(\n+    ) -> &mut Self);\n+    forward!(pub fn span_suggestion_short(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.span_suggestion_short(sp, msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::span_suggestion_verbose()`].\n-    pub fn span_suggestion_verbose(\n+    ) -> &mut Self);\n+    forward!(pub fn span_suggestion_verbose(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.span_suggestion_verbose(sp, msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::span_suggestion_hidden()`].\n-    pub fn span_suggestion_hidden(\n+    ) -> &mut Self);\n+    forward!(pub fn span_suggestion_hidden(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.span_suggestion_hidden(sp, msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::tool_only_span_suggestion()`] for more information.\n-    pub fn tool_only_span_suggestion(\n+    ) -> &mut Self);\n+    forward!(pub fn tool_only_span_suggestion(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.tool_only_span_suggestion(sp, msg, suggestion, applicability);\n-        self\n-    }\n+    ) -> &mut Self);\n \n     forward!(pub fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self);\n     forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n     forward!(pub fn code(&mut self, s: DiagnosticId) -> &mut Self);\n \n-    /// Allow attaching suggestions this diagnostic.\n-    /// If this is set to `false`, then any suggestions attached with the `span_suggestion_*`\n-    /// methods after this is set to `false` will be ignored.\n-    pub fn allow_suggestions(&mut self, allow: bool) -> &mut Self {\n-        self.0.allow_suggestions = allow;\n-        self\n-    }\n-\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n     crate fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n@@ -424,11 +340,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// diagnostic.\n     crate fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> DiagnosticBuilder<'a> {\n         debug!(\"Created new diagnostic\");\n-        DiagnosticBuilder(Box::new(DiagnosticBuilderInner {\n-            handler,\n-            diagnostic,\n-            allow_suggestions: true,\n-        }))\n+        DiagnosticBuilder(Box::new(DiagnosticBuilderInner { handler, diagnostic }))\n     }\n }\n "}, {"sha": "f90f4d46a9a0b1cfe70796dc3a8881c88841f90d", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=68fa81baa3acf3a93ce4b41c8366039229926fc2", "patch": "@@ -227,7 +227,8 @@ pub trait Emitter {\n         diag: &'a Diagnostic,\n     ) -> (MultiSpan, &'a [CodeSuggestion]) {\n         let mut primary_span = diag.span.clone();\n-        if let Some((sugg, rest)) = diag.suggestions.split_first() {\n+        let suggestions = diag.suggestions.as_ref().map_or(&[][..], |suggestions| &suggestions[..]);\n+        if let Some((sugg, rest)) = suggestions.split_first() {\n             if rest.is_empty() &&\n                // ^ if there is only one suggestion\n                // don't display multi-suggestions as labels\n@@ -282,10 +283,10 @@ pub trait Emitter {\n                 // to be consistent. We could try to figure out if we can\n                 // make one (or the first one) inline, but that would give\n                 // undue importance to a semi-random suggestion\n-                (primary_span, &diag.suggestions)\n+                (primary_span, suggestions)\n             }\n         } else {\n-            (primary_span, &diag.suggestions)\n+            (primary_span, suggestions)\n         }\n     }\n "}, {"sha": "ff3478073d92baba96ccabd77598c820fb629fd5", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=68fa81baa3acf3a93ce4b41c8366039229926fc2", "patch": "@@ -345,7 +345,7 @@ struct UnusedExterns<'a, 'b, 'c> {\n \n impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n-        let sugg = diag.suggestions.iter().map(|sugg| Diagnostic {\n+        let sugg = diag.suggestions.iter().flatten().map(|sugg| Diagnostic {\n             message: sugg.msg.clone(),\n             code: None,\n             level: \"help\","}, {"sha": "c6226c69f302020ec2cc11742041bfeada4925c4", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=68fa81baa3acf3a93ce4b41c8366039229926fc2", "patch": "@@ -262,7 +262,7 @@ pub fn struct_lint_level<'s, 'd>(\n         if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n             // Any suggestions made here are likely to be incorrect, so anything we\n             // emit shouldn't be automatically fixed by rustfix.\n-            err.allow_suggestions(false);\n+            err.disable_suggestions();\n \n             // If this is a future incompatible that is not an edition fixing lint\n             // it'll become a hard error, so we have to emit *something*. Also,"}, {"sha": "b99e44f2105caff9d1cbb60c14f33709394cfd62", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fa81baa3acf3a93ce4b41c8366039229926fc2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=68fa81baa3acf3a93ce4b41c8366039229926fc2", "patch": "@@ -726,7 +726,10 @@ fn infer_placeholder_type<'a>(\n             if !ty.references_error() {\n                 // The parser provided a sub-optimal `HasPlaceholders` suggestion for the type.\n                 // We are typeck and have the real type, so remove that and suggest the actual type.\n-                err.suggestions.clear();\n+                // FIXME(eddyb) this looks like it should be functionality on `Diagnostic`.\n+                if let Ok(suggestions) = &mut err.suggestions {\n+                    suggestions.clear();\n+                }\n \n                 // Suggesting unnameable types won't help.\n                 let mut mk_nameable = MakeNameable::new(tcx);"}]}