{"sha": "3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjM2VkMTQ5OWE5YjllMjNkNGEyZDIyNDNhN2IwYjFjOTAxNWYzNGI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-31T22:15:30Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-04T18:28:55Z"}, "message": "Move io::file to io::fs and fns out of File\n\nThis renames the `file` module to `fs` because that more accurately describes\nits current purpose (manipulating the filesystem, not just files).\n\nAdditionally, this adds an UnstableFileStat structure as a nested structure of\nFileStat to signify that the fields should not be depended on. The structure is\ncurrently flagged with #[unstable], but it's unlikely that it has much meaning.\n\nCloses #10241", "tree": {"sha": "b349c0b7f6cd8ae46dd05ecc430ecca15ae037c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b349c0b7f6cd8ae46dd05ecc430ecca15ae037c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "html_url": "https://github.com/rust-lang/rust/commit/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f19d0833625c382c5d0a8868924cd4620335e659", "url": "https://api.github.com/repos/rust-lang/rust/commits/f19d0833625c382c5d0a8868924cd4620335e659", "html_url": "https://github.com/rust-lang/rust/commit/f19d0833625c382c5d0a8868924cd4620335e659"}], "stats": {"total": 968, "additions": 491, "deletions": 477}, "files": [{"sha": "f4bd668690eef20e96f9827ca16f0b725a3c3fc4", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -17,7 +17,7 @@ extern mod extra;\n \n use std::os;\n use std::rt;\n-use std::rt::io::file;\n+use std::rt::io::fs;\n \n use extra::getopts;\n use extra::getopts::groups::{optopt, optflag, reqopt};\n@@ -248,7 +248,7 @@ pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n     debug!(\"making tests from {}\",\n            config.src_base.display());\n     let mut tests = ~[];\n-    let dirs = file::readdir(&config.src_base);\n+    let dirs = fs::readdir(&config.src_base);\n     for file in dirs.iter() {\n         let file = file.clone();\n         debug!(\"inspecting file {}\", file.display());"}, {"sha": "1b3e34ad81934c5f05906e5c5c79b15da78f5279", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 5, "deletions": 30, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -20,43 +20,18 @@ use procsrv;\n use util;\n use util::logv;\n \n-use std::cell::Cell;\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::fs;\n use std::rt::io::File;\n use std::os;\n use std::str;\n-use std::task::{spawn_sched, SingleThreaded};\n use std::vec;\n-use std::unstable::running_on_valgrind;\n \n use extra::test::MetricMap;\n \n pub fn run(config: config, testfile: ~str) {\n-    let config = Cell::new(config);\n-    let testfile = Cell::new(testfile);\n-    // FIXME #6436: Creating another thread to run the test because this\n-    // is going to call waitpid. The new scheduler has some strange\n-    // interaction between the blocking tasks and 'friend' schedulers\n-    // that destroys parallelism if we let normal schedulers block.\n-    // It should be possible to remove this spawn once std::run is\n-    // rewritten to be non-blocking.\n-    //\n-    // We do _not_ create another thread if we're running on V because\n-    // it serializes all threads anyways.\n-    if running_on_valgrind() {\n-        let config = config.take();\n-        let testfile = testfile.take();\n-        let mut _mm = MetricMap::new();\n-        run_metrics(config, testfile, &mut _mm);\n-    } else {\n-        do spawn_sched(SingleThreaded) {\n-            let config = config.take();\n-            let testfile = testfile.take();\n-            let mut _mm = MetricMap::new();\n-            run_metrics(config, testfile, &mut _mm);\n-        }\n-    }\n+    let mut _mm = MetricMap::new();\n+    run_metrics(config, testfile, &mut _mm);\n }\n \n pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n@@ -651,7 +626,7 @@ fn compose_and_run_compiler(\n \n fn ensure_dir(path: &Path) {\n     if path.is_dir() { return; }\n-    file::mkdir(path, io::UserRWX);\n+    fs::mkdir(path, io::UserRWX);\n }\n \n fn compose_and_run(config: &config, testfile: &Path,\n@@ -921,7 +896,7 @@ fn _dummy_exec_compiled_test(config: &config, props: &TestProps,\n fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n     let tdir = aux_output_dir_name(config, testfile);\n \n-    let dirs = file::readdir(&tdir);\n+    let dirs = fs::readdir(&tdir);\n     for file in dirs.iter() {\n         if file.extension_str() == Some(\"so\") {\n             // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "1edef5ddbe1b4f4d8de22da761c9cbfbd803c332", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -25,7 +25,7 @@\n \n use std::{os, path};\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::fs;\n use std::path::is_sep;\n \n use sort;\n@@ -148,7 +148,7 @@ impl Iterator<Path> for GlobIterator {\n }\n \n fn list_dir_sorted(path: &Path) -> ~[Path] {\n-    match io::result(|| file::readdir(path)) {\n+    match io::result(|| fs::readdir(path)) {\n         Ok(children) => {\n             let mut children = children;\n             sort::quick_sort(children, |p1, p2| p2.filename() <= p1.filename());"}, {"sha": "fbd65cab98ca7858f522446b3f727762fe647ec9", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -15,7 +15,7 @@ use std::os;\n use std::rand::Rng;\n use std::rand;\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::fs;\n \n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-pased deletion.\n@@ -38,7 +38,7 @@ impl TempDir {\n         let mut r = rand::rng();\n         for _ in range(0u, 1000) {\n             let p = tmpdir.join(r.gen_ascii_str(16) + suffix);\n-            match io::result(|| file::mkdir(&p, io::UserRWX)) {\n+            match io::result(|| fs::mkdir(&p, io::UserRWX)) {\n                 Err(*) => {}\n                 Ok(()) => return Some(TempDir { path: Some(p) })\n             }\n@@ -73,7 +73,7 @@ impl Drop for TempDir {\n     fn drop(&mut self) {\n         for path in self.path.iter() {\n             if path.exists() {\n-                file::rmdir_recursive(path);\n+                fs::rmdir_recursive(path);\n             }\n         }\n     }"}, {"sha": "04b30e5ef7474c911d22541adde858792135902d", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -329,6 +329,6 @@ mod test {\n     #[ignore(reason = \"no ncurses on buildbots, needs a bundled terminfo file to test against\")]\n     fn test_parse() {\n         // FIXME #6870: Distribute a compiled file in src/tests and test there\n-        // parse(io::file_reader(&p(\"/usr/share/terminfo/r/rxvt-256color\")).unwrap(), false);\n+        // parse(io::fs_reader(&p(\"/usr/share/terminfo/r/rxvt-256color\")).unwrap(), false);\n     }\n }"}, {"sha": "eed37a426be2db6252354e5d4541203be6ef24d3", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -19,8 +19,7 @@ use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n use std::{str, task};\n use std::rt::io;\n-use std::rt::io::File;\n-use std::rt::io::Decorator;\n+use std::rt::io::{File, Decorator};\n use std::rt::io::mem::MemWriter;\n \n /**\n@@ -480,14 +479,15 @@ impl<'self, T:Send +\n #[test]\n fn test() {\n     use std::{os, run};\n+    use std::rt::io::fs;\n     use std::str::from_utf8_owned;\n \n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n     fn make_path(filename: ~str) -> Path {\n         let pth = os::self_exe_path().expect(\"workcache::test failed\").with_filename(filename);\n         if pth.exists() {\n-            File::unlink(&pth);\n+            fs::unlink(&pth);\n         }\n         return pth;\n     }"}, {"sha": "5b0f424360b1ebb6398d91ad9f68f672c89bc419", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -31,7 +31,7 @@ use std::ptr;\n use std::run;\n use std::str;\n use std::vec;\n-use std::rt::io::File;\n+use std::rt::io::fs;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n use syntax::attr;\n@@ -950,7 +950,7 @@ pub fn link_binary(sess: Session,\n \n     // Remove the temporary object file if we aren't saving temps\n     if !sess.opts.save_temps {\n-        File::unlink(obj_filename);\n+        fs::unlink(obj_filename);\n     }\n }\n "}, {"sha": "744e192095bb26ae3dfabf49ccab2aa618d0c0a2", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -27,7 +27,7 @@ use util::ppaux;\n \n use std::hashmap::{HashMap,HashSet};\n use std::rt::io;\n-use std::rt::io::File;\n+use std::rt::io::fs;\n use std::rt::io::mem::MemReader;\n use std::os;\n use std::vec;\n@@ -370,7 +370,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n \n         // Remove assembly source unless --save-temps was specified\n         if !sess.opts.save_temps {\n-            File::unlink(&asm_filename);\n+            fs::unlink(&asm_filename);\n         }\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|"}, {"sha": "c9bd5eff4a771f3bf89591aecf6ffd8017a1bf3b", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -12,7 +12,7 @@\n use std::option;\n use std::os;\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::fs;\n use std::hashmap::HashSet;\n \n pub enum FileMatch { FileMatches, FileDoesntMatch }\n@@ -119,7 +119,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n pub fn search(filesearch: @FileSearch, pick: pick) {\n     do filesearch.for_each_lib_search_path() |lib_search_path| {\n         debug!(\"searching {}\", lib_search_path.display());\n-        match io::result(|| file::readdir(lib_search_path)) {\n+        match io::result(|| fs::readdir(lib_search_path)) {\n             Ok(files) => {\n                 let mut rslt = FileDoesntMatch;\n                 for path in files.iter() {"}, {"sha": "0efc52bbe4a676332075f017af341449b541dc03", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -41,7 +41,7 @@ use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n use std::rt::io::buffered::BufferedWriter;\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::fs;\n use std::rt::io::File;\n use std::os;\n use std::str;\n@@ -326,7 +326,7 @@ fn mkdir(path: &Path) {\n         fail!()\n     }).inside {\n         if !path.is_dir() {\n-            file::mkdir(path, io::UserRWX);\n+            fs::mkdir(path, io::UserRWX);\n         }\n     }\n }"}, {"sha": "576d5abe8bdade3960f4d61665fe17d11cbce01c", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -14,12 +14,12 @@ use rustc::metadata::filesearch::rust_path;\n use path_util::*;\n use std::os;\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::fs;\n \n pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n     let workspaces = rust_path();\n     for p in workspaces.iter() {\n-        let binfiles = do io::ignore_io_error { file::readdir(&p.join(\"bin\")) };\n+        let binfiles = do io::ignore_io_error { fs::readdir(&p.join(\"bin\")) };\n         for exec in binfiles.iter() {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             match exec.filestem_str() {\n@@ -31,7 +31,7 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n                 }\n             }\n         }\n-        let libfiles = do io::ignore_io_error { file::readdir(&p.join(\"lib\")) };\n+        let libfiles = do io::ignore_io_error { fs::readdir(&p.join(\"lib\")) };\n         for lib in libfiles.iter() {\n             debug!(\"Full name: {}\", lib.display());\n             match has_library(lib) {\n@@ -55,7 +55,7 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n }\n \n pub fn has_library(p: &Path) -> Option<~str> {\n-    let files = do io::ignore_io_error { file::readdir(p) };\n+    let files = do io::ignore_io_error { fs::readdir(p) };\n     for path in files.iter() {\n         if path.extension_str() == Some(os::consts::DLL_EXTENSION) {\n             let stuff : &str = path.filestem_str().expect(\"has_library: weird path\");"}, {"sha": "d69c8db52c690cbcc91e5056d1c536e802d43fea", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -27,8 +27,7 @@ extern mod syntax;\n use std::{os, result, run, str, task};\n use std::hashmap::HashSet;\n use std::rt::io;\n-use std::rt::io::file;\n-use std::rt::io::File;\n+use std::rt::io::fs;\n pub use std::path::Path;\n \n use extra::workcache;\n@@ -545,7 +544,7 @@ impl CtxMethods for BuildContext {\n         note(format!(\"Cleaning package {} (removing directory {})\",\n                         id.to_str(), dir.display()));\n         if dir.exists() {\n-            file::rmdir_recursive(&dir);\n+            fs::rmdir_recursive(&dir);\n             note(format!(\"Removed directory {}\", dir.display()));\n         }\n \n@@ -661,8 +660,8 @@ impl CtxMethods for BuildContext {\n \n                 for exec in subex.iter() {\n                     debug!(\"Copying: {} -> {}\", exec.display(), sub_target_ex.display());\n-                    file::mkdir_recursive(&sub_target_ex.dir_path(), io::UserRWX);\n-                    File::copy(exec, &sub_target_ex);\n+                    fs::mkdir_recursive(&sub_target_ex.dir_path(), io::UserRWX);\n+                    fs::copy(exec, &sub_target_ex);\n                     // FIXME (#9639): This needs to handle non-utf8 paths\n                     exe_thing.discover_output(\"binary\",\n                         sub_target_ex.as_str().unwrap(),\n@@ -674,8 +673,8 @@ impl CtxMethods for BuildContext {\n                         .clone().expect(format!(\"I built {} but apparently \\\n                                              didn't install it!\", lib.display()));\n                     target_lib.set_filename(lib.filename().expect(\"weird target lib\"));\n-                    file::mkdir_recursive(&target_lib.dir_path(), io::UserRWX);\n-                    File::copy(lib, &target_lib);\n+                    fs::mkdir_recursive(&target_lib.dir_path(), io::UserRWX);\n+                    fs::copy(lib, &target_lib);\n                     debug!(\"3. discovering output {}\", target_lib.display());\n                     exe_thing.discover_output(\"binary\",\n                                               target_lib.as_str().unwrap(),\n@@ -708,10 +707,10 @@ impl CtxMethods for BuildContext {\n     }\n \n     fn init(&self) {\n-        file::mkdir_recursive(&Path::new(\"src\"), io::UserRWX);\n-        file::mkdir_recursive(&Path::new(\"bin\"), io::UserRWX);\n-        file::mkdir_recursive(&Path::new(\"lib\"), io::UserRWX);\n-        file::mkdir_recursive(&Path::new(\"build\"), io::UserRWX);\n+        fs::mkdir_recursive(&Path::new(\"src\"), io::UserRWX);\n+        fs::mkdir_recursive(&Path::new(\"bin\"), io::UserRWX);\n+        fs::mkdir_recursive(&Path::new(\"lib\"), io::UserRWX);\n+        fs::mkdir_recursive(&Path::new(\"build\"), io::UserRWX);\n     }\n \n     fn uninstall(&self, _id: &str, _vers: Option<~str>)  {"}, {"sha": "3023f3ed60c5cd193f5aebd1b79872c050a96bf1", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -13,8 +13,7 @@ extern mod extra;\n use target::*;\n use package_id::PkgId;\n use std::rt::io;\n-use std::rt::io::file;\n-use std::rt::io::File;\n+use std::rt::io::fs;\n use std::os;\n use context::*;\n use crate::Crate;\n@@ -302,7 +301,7 @@ impl PkgSrc {\n                 // Move clone_target to local.\n                 // First, create all ancestor directories.\n                 let moved = make_dir_rwx_recursive(&local.dir_path())\n-                    && io::result(|| File::rename(&clone_target, local)).is_ok();\n+                    && io::result(|| fs::rename(&clone_target, local)).is_ok();\n                 if moved { Some(local.clone()) }\n                     else { None }\n             }\n@@ -351,7 +350,7 @@ impl PkgSrc {\n \n         let prefix = self.start_dir.component_iter().len();\n         debug!(\"Matching against {}\", self.id.short_name);\n-        for pth in file::walk_dir(&self.start_dir) {\n+        for pth in fs::walk_dir(&self.start_dir) {\n             let maybe_known_crate_set = match pth.filename_str() {\n                 Some(filename) if filter(filename) => match filename {\n                     \"lib.rs\" => Some(&mut self.libs),"}, {"sha": "949efacaa1196f7e9c53317fc0f2d70611ba231d", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -20,8 +20,7 @@ use std::libc;\n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::os;\n use std::rt::io;\n-use std::rt::io::file;\n-use std::rt::io::File;\n+use std::rt::io::fs;\n use messages::*;\n \n pub fn default_workspace() -> Path {\n@@ -31,7 +30,7 @@ pub fn default_workspace() -> Path {\n     }\n     let result = p[0];\n     if !result.is_dir() {\n-        file::mkdir_recursive(&result, io::UserRWX);\n+        fs::mkdir_recursive(&result, io::UserRWX);\n     }\n     result\n }\n@@ -46,11 +45,11 @@ pub static U_RWX: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n /// and executable by the user. Returns true iff creation\n /// succeeded.\n pub fn make_dir_rwx(p: &Path) -> bool {\n-    io::result(|| file::mkdir(p, io::UserRWX)).is_ok()\n+    io::result(|| fs::mkdir(p, io::UserRWX)).is_ok()\n }\n \n pub fn make_dir_rwx_recursive(p: &Path) -> bool {\n-    io::result(|| file::mkdir_recursive(p, io::UserRWX)).is_ok()\n+    io::result(|| fs::mkdir_recursive(p, io::UserRWX)).is_ok()\n }\n \n // n.b. The next three functions ignore the package version right\n@@ -73,7 +72,7 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     if !src_dir.is_dir() { return None }\n \n     let mut found = None;\n-    for p in file::walk_dir(&src_dir) {\n+    for p in fs::walk_dir(&src_dir) {\n         if p.is_dir() {\n             if p == src_dir.join(&pkgid.path) || {\n                 let pf = p.filename_str();\n@@ -216,7 +215,7 @@ pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n \n fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n     debug!(\"Listing directory {}\", dir_to_search.display());\n-    let dir_contents = do io::ignore_io_error { file::readdir(dir_to_search) };\n+    let dir_contents = do io::ignore_io_error { fs::readdir(dir_to_search) };\n     debug!(\"dir has {:?} entries\", dir_contents.len());\n \n     let lib_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);\n@@ -339,7 +338,7 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n                 (Install, Lib)  => target_lib_dir(workspace),\n                 (Install, _)    => target_bin_dir(workspace)\n     };\n-    if io::result(|| file::mkdir_recursive(&result, io::UserRWX)).is_err() {\n+    if io::result(|| fs::mkdir_recursive(&result, io::UserRWX)).is_err() {\n         cond.raise((result.clone(), format!(\"target_file_in_workspace couldn't \\\n             create the {} dir (pkgid={}, workspace={}, what={:?}, where={:?}\",\n             subdir, pkgid.to_str(), workspace.display(), what, where)));\n@@ -354,7 +353,7 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     result.push(&pkgid.path);\n     debug!(\"Creating build dir {} for package id {}\", result.display(),\n            pkgid.to_str());\n-    file::mkdir_recursive(&result, io::UserRWX);\n+    fs::mkdir_recursive(&result, io::UserRWX);\n     return result;\n }\n \n@@ -399,12 +398,12 @@ pub fn uninstall_package_from(workspace: &Path, pkgid: &PkgId) {\n     let mut did_something = false;\n     let installed_bin = target_executable_in_workspace(pkgid, workspace);\n     if installed_bin.exists() {\n-        File::unlink(&installed_bin);\n+        fs::unlink(&installed_bin);\n         did_something = true;\n     }\n     let installed_lib = target_library_in_workspace(pkgid, workspace);\n     if installed_lib.exists() {\n-        File::unlink(&installed_lib);\n+        fs::unlink(&installed_lib);\n         did_something = true;\n     }\n     if !did_something {"}, {"sha": "bcda3168bd855c8e686cb3ebef87bdba89129c03", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -12,7 +12,7 @@\n \n use std::{run, str};\n use std::run::{ProcessOutput, ProcessOptions, Process};\n-use std::rt::io::file;\n+use std::rt::io::fs;\n use extra::tempfile::TempDir;\n use version::*;\n use path_util::chmod_read_only;\n@@ -96,7 +96,7 @@ pub enum CloneResult {\n \n pub fn make_read_only(target: &Path) {\n     // Now, make all the files in the target dir read-only\n-    for p in file::walk_dir(target) {\n+    for p in fs::walk_dir(target) {\n         if !p.is_dir() {\n             assert!(chmod_read_only(&p));\n         }"}, {"sha": "fc46346a35eabaf413881aa0b36e1f7f2fb3aa95", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -13,7 +13,7 @@\n use context::{BuildContext, Context, RustcFlags};\n use std::{os, run, str, task};\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::fs;\n use std::rt::io::File;\n use extra::arc::Arc;\n use extra::arc::RWArc;\n@@ -92,7 +92,7 @@ fn writeFile(file_path: &Path, contents: &str) {\n fn mk_emptier_workspace(tag: &str) -> TempDir {\n     let workspace = TempDir::new(tag).expect(\"couldn't create temp dir\");\n     let package_dir = workspace.path().join(\"src\");\n-    file::mkdir_recursive(&package_dir, io::UserRWX);\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n     workspace\n }\n \n@@ -107,7 +107,7 @@ fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let package_dir = workspace.join_many([~\"src\", format!(\"{}-{}\",\n                                            short_name.as_str().unwrap(), version.to_str())]);\n-    file::mkdir_recursive(&package_dir, io::UserRWX);\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n     package_dir\n }\n \n@@ -123,7 +123,7 @@ fn mk_temp_workspace(short_name: &Path, version: &Version) -> (TempDir, Path) {\n            package_dir.is_dir());\n     // Create main, lib, test, and bench files\n     debug!(\"mk_workspace: creating {}\", package_dir.display());\n-    file::mkdir_recursive(&package_dir, io::UserRWX);\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n     debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n            package_dir.is_dir());\n     // Create main, lib, test, and bench files\n@@ -162,7 +162,7 @@ fn init_git_repo(p: &Path) -> TempDir {\n     let tmp = TempDir::new(\"git_local\").expect(\"couldn't create temp dir\");\n     let work_dir = tmp.path().join(p);\n     let work_dir_for_opts = work_dir.clone();\n-    file::mkdir_recursive(&work_dir, io::UserRWX);\n+    fs::mkdir_recursive(&work_dir, io::UserRWX);\n     debug!(\"Running: git init in {}\", work_dir.display());\n     run_git([~\"init\"], None, &work_dir_for_opts,\n         format!(\"Couldn't initialize git repository in {}\", work_dir.display()));\n@@ -311,7 +311,7 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n     let package_dir = pkgdir.join_many([~\"src\", pkgid.to_str()]);\n \n     // Create main, lib, test, and bench files\n-    file::mkdir_recursive(&package_dir, io::UserRWX);\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n     debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n            package_dir.is_dir());\n     // Create main, lib, test, and bench files\n@@ -389,7 +389,7 @@ fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n fn remove_executable_file(p: &PkgId, workspace: &Path) {\n     let exec = target_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n     if exec.exists() {\n-        File::unlink(&exec);\n+        fs::unlink(&exec);\n     }\n }\n \n@@ -410,7 +410,7 @@ fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n fn remove_built_executable_file(p: &PkgId, workspace: &Path) {\n     let exec = built_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n     match exec {\n-        Some(r) => File::unlink(&r),\n+        Some(r) => fs::unlink(&r),\n         None    => ()\n     }\n }\n@@ -495,7 +495,7 @@ fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n-    let contents = file::readdir(&pkg_src_dir);\n+    let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n             // should be able to do this w/o a process\n@@ -514,7 +514,7 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n-    let contents = file::readdir(&pkg_src_dir);\n+    let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n             // should be able to do this w/o a process\n@@ -558,13 +558,13 @@ fn test_make_dir_rwx() {\n     let temp = &os::tmpdir();\n     let dir = temp.join(\"quux\");\n     if dir.exists() {\n-        file::rmdir_recursive(&dir);\n+        fs::rmdir_recursive(&dir);\n     }\n     debug!(\"Trying to make {}\", dir.display());\n     assert!(make_dir_rwx(&dir));\n     assert!(dir.is_dir());\n     assert!(is_rwx(&dir));\n-    file::rmdir_recursive(&dir);\n+    fs::rmdir_recursive(&dir);\n }\n \n // n.b. I ignored the next two tests for now because something funny happens on linux\n@@ -771,7 +771,7 @@ fn test_package_version() {\n     let repo = repo.path();\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n     debug!(\"Writing files in: {}\", repo_subdir.display());\n-    file::mkdir_recursive(&repo_subdir, io::UserRWX);\n+    fs::mkdir_recursive(&repo_subdir, io::UserRWX);\n     writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&repo_subdir.join(\"lib.rs\"),\n@@ -893,7 +893,7 @@ fn package_script_with_default_build() {\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n     debug!(\"package_script_with_default_build: {}\", source.display());\n-    File::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"]));\n+    fs::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"]));\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n     assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n     assert!(target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]).exists());\n@@ -907,7 +907,7 @@ fn rustpkg_build_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_build_no_arg\").expect(\"rustpkg_build_no_arg failed\");\n     let tmp = tmp.path().join(\".rust\");\n     let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    file::mkdir_recursive(&package_dir, io::UserRWX);\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n \n     writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -921,7 +921,7 @@ fn rustpkg_install_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_install_no_arg\").expect(\"rustpkg_install_no_arg failed\");\n     let tmp = tmp.path().join(\".rust\");\n     let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    file::mkdir_recursive(&package_dir, io::UserRWX);\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n     writeFile(&package_dir.join(\"lib.rs\"),\n               \"fn main() { let _x = (); }\");\n     debug!(\"install_no_arg: dir = {}\", package_dir.display());\n@@ -934,7 +934,7 @@ fn rustpkg_clean_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_clean_no_arg\").expect(\"rustpkg_clean_no_arg failed\");\n     let tmp = tmp.path().join(\".rust\");\n     let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    file::mkdir_recursive(&package_dir, io::UserRWX);\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n \n     writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -969,9 +969,9 @@ fn rust_path_test() {\n fn rust_path_contents() {\n     let dir = TempDir::new(\"rust_path\").expect(\"rust_path_contents failed\");\n     let abc = &dir.path().join_many([\"A\", \"B\", \"C\"]);\n-    file::mkdir_recursive(&abc.join(\".rust\"), io::UserRWX);\n-    file::mkdir_recursive(&abc.with_filename(\".rust\"), io::UserRWX);\n-    file::mkdir_recursive(&abc.dir_path().with_filename(\".rust\"), io::UserRWX);\n+    fs::mkdir_recursive(&abc.join(\".rust\"), io::UserRWX);\n+    fs::mkdir_recursive(&abc.with_filename(\".rust\"), io::UserRWX);\n+    fs::mkdir_recursive(&abc.dir_path().with_filename(\".rust\"), io::UserRWX);\n     assert!(os::change_dir(abc));\n \n     let p = rust_path();\n@@ -1223,7 +1223,7 @@ fn test_extern_mod() {\n     let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod\");\n     let lib_depend_dir = lib_depend_dir.path();\n     let aux_dir = lib_depend_dir.join_many([\"src\", \"mockgithub.com\", \"catamorphism\", \"test_pkg\"]);\n-    file::mkdir_recursive(&aux_dir, io::UserRWX);\n+    fs::mkdir_recursive(&aux_dir, io::UserRWX);\n     let aux_pkg_file = aux_dir.join(\"lib.rs\");\n \n     writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n@@ -1272,7 +1272,7 @@ fn test_extern_mod_simpler() {\n     let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod_simpler\");\n     let lib_depend_dir = lib_depend_dir.path();\n     let aux_dir = lib_depend_dir.join_many([\"src\", \"rust-awesomeness\"]);\n-    file::mkdir_recursive(&aux_dir, io::UserRWX);\n+    fs::mkdir_recursive(&aux_dir, io::UserRWX);\n     let aux_pkg_file = aux_dir.join(\"lib.rs\");\n \n     writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n@@ -1422,7 +1422,7 @@ fn rust_path_hack_cwd() {\n    // Same as rust_path_hack_test, but the CWD is the dir to build out of\n    let cwd = TempDir::new(\"foo\").expect(\"rust_path_hack_cwd\");\n    let cwd = cwd.path().join(\"foo\");\n-   file::mkdir_recursive(&cwd, io::UserRWX);\n+   fs::mkdir_recursive(&cwd, io::UserRWX);\n    writeFile(&cwd.join(\"lib.rs\"), \"pub fn f() { }\");\n \n    let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n@@ -1442,7 +1442,7 @@ fn rust_path_hack_multi_path() {\n    // Same as rust_path_hack_test, but with a more complex package ID\n    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_cwd\");\n    let subdir = cwd.path().join_many([\"foo\", \"bar\", \"quux\"]);\n-   file::mkdir_recursive(&subdir, io::UserRWX);\n+   fs::mkdir_recursive(&subdir, io::UserRWX);\n    writeFile(&subdir.join(\"lib.rs\"), \"pub fn f() { }\");\n    let name = ~\"foo/bar/quux\";\n \n@@ -1856,22 +1856,22 @@ fn pkgid_pointing_to_subdir() {\n     // rustpkg should recognize that and treat the part after some_repo/ as a subdir\n     let workspace = TempDir::new(\"parent_repo\").expect(\"Couldn't create temp dir\");\n     let workspace = workspace.path();\n-    file::mkdir_recursive(&workspace.join_many([\"src\", \"mockgithub.com\",\n+    fs::mkdir_recursive(&workspace.join_many([\"src\", \"mockgithub.com\",\n                                                 \"mozilla\", \"some_repo\"]),\n                           io::UserRWX);\n \n     let foo_dir = workspace.join_many([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n                                        \"extras\", \"foo\"]);\n     let bar_dir = workspace.join_many([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n                                        \"extras\", \"bar\"]);\n-    file::mkdir_recursive(&foo_dir, io::UserRWX);\n-    file::mkdir_recursive(&bar_dir, io::UserRWX);\n+    fs::mkdir_recursive(&foo_dir, io::UserRWX);\n+    fs::mkdir_recursive(&bar_dir, io::UserRWX);\n     writeFile(&foo_dir.join(\"lib.rs\"), \"pub fn f() {}\");\n     writeFile(&bar_dir.join(\"lib.rs\"), \"pub fn g() {}\");\n \n     debug!(\"Creating a file in {}\", workspace.display());\n     let testpkg_dir = workspace.join_many([\"src\", \"testpkg-0.1\"]);\n-    file::mkdir_recursive(&testpkg_dir, io::UserRWX);\n+    fs::mkdir_recursive(&testpkg_dir, io::UserRWX);\n \n     writeFile(&testpkg_dir.join(\"main.rs\"),\n               \"extern mod foo = \\\"mockgithub.com/mozilla/some_repo/extras/foo\\\";\\n\n@@ -1946,7 +1946,7 @@ fn test_target_specific_build_dir() {\n                       workspace);\n     assert!(target_build_dir(workspace).is_dir());\n     assert!(built_executable_exists(workspace, \"foo\"));\n-    assert!(file::readdir(&workspace.join(\"build\")).len() == 1);\n+    assert!(fs::readdir(&workspace.join(\"build\")).len() == 1);\n }\n \n #[test]\n@@ -1962,7 +1962,7 @@ fn test_target_specific_install_dir() {\n                       workspace);\n     assert!(workspace.join_many([~\"lib\", host_triple()]).is_dir());\n     assert_lib_exists(workspace, &Path::new(\"foo\"), NoVersion);\n-    assert!(file::readdir(&workspace.join(\"lib\")).len() == 1);\n+    assert!(fs::readdir(&workspace.join(\"lib\")).len() == 1);\n     assert!(workspace.join(\"bin\").is_dir());\n     assert_executable_exists(workspace, \"foo\");\n }\n@@ -1975,7 +1975,7 @@ fn test_dependencies_terminate() {\n     let workspace = workspace.path();\n     let b_dir = workspace.join_many([\"src\", \"b-0.1\"]);\n     let b_subdir = b_dir.join(\"test\");\n-    file::mkdir_recursive(&b_subdir, io::UserRWX);\n+    fs::mkdir_recursive(&b_subdir, io::UserRWX);\n     writeFile(&b_subdir.join(\"test.rs\"),\n               \"extern mod b; use b::f; #[test] fn g() { f() }\");\n     command_line_test([~\"install\", ~\"b\"], workspace);\n@@ -2173,7 +2173,7 @@ fn test_installed_local_changes() {\n     debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n     debug!(\"repo_subdir = {}\", repo_subdir.display());\n-    file::mkdir_recursive(&repo.join_many([\".rust\", \"src\"]), io::UserRWX);\n+    fs::mkdir_recursive(&repo.join_many([\".rust\", \"src\"]), io::UserRWX);\n \n     writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -2256,7 +2256,7 @@ fn find_sources_in_cwd() {\n     let temp_dir = TempDir::new(\"sources\").expect(\"find_sources_in_cwd failed\");\n     let temp_dir = temp_dir.path();\n     let source_dir = temp_dir.join(\"foo\");\n-    file::mkdir_recursive(&source_dir, io::UserRWX);\n+    fs::mkdir_recursive(&source_dir, io::UserRWX);\n     writeFile(&source_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     command_line_test([~\"install\", ~\"foo\"], &source_dir);\n@@ -2279,7 +2279,7 @@ fn test_c_dependency_ok() {\n     debug!(\"dir = {}\", dir.display());\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    File::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n+    fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n@@ -2300,7 +2300,7 @@ fn test_c_dependency_no_rebuilding() {\n     debug!(\"dir = {}\", dir.display());\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    File::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n+    fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n@@ -2333,7 +2333,7 @@ fn test_c_dependency_yes_rebuilding() {\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n     let target = dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]);\n     debug!(\"Copying {} -> {}\", source.display(), target.display());\n-    File::copy(&source, &target);\n+    fs::copy(&source, &target);\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n@@ -2357,5 +2357,5 @@ fn test_c_dependency_yes_rebuilding() {\n \n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n-    p.exists() && p.stat().perm & io::UserExec == io::UserExec\n+    p.exists() && p.stat().perm & io::UserExecute == io::UserExecute\n }"}, {"sha": "3b233c9f6a88ac9788d1a74a4b3dad26911fb7b6", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n pub fn do_nothing() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ec7771c2ab5e470f1d6784ca6901cbf08387d36e", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -11,7 +11,7 @@\n use std::libc;\n use std::os;\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::fs;\n use extra::workcache;\n use rustc::driver::{driver, session};\n use extra::getopts::groups::getopts;\n@@ -185,7 +185,7 @@ pub fn compile_input(context: &BuildContext,\n     let mut out_dir = target_build_dir(workspace);\n     out_dir.push(&pkg_id.path);\n     // Make the output directory if it doesn't exist already\n-    file::mkdir_recursive(&out_dir, io::UserRWX);\n+    fs::mkdir_recursive(&out_dir, io::UserRWX);\n \n     let binary = os::args()[0].to_managed();\n \n@@ -261,7 +261,7 @@ pub fn compile_input(context: &BuildContext,\n             assert!(p.is_dir())\n         }\n         else {\n-            file::mkdir_recursive(p, io::UserRWX);\n+            fs::mkdir_recursive(p, io::UserRWX);\n         }\n     }\n "}, {"sha": "8c9302e123815f8b3e5d9c6c2267f78ec495ae75", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -257,6 +257,7 @@ impl FsRequest {\n             uvll::uv_fs_symlink(loop_.native_handle(), self.native_handle(),\n                                 src.with_ref(|p| p),\n                                 dst.with_ref(|p| p),\n+                                0,\n                                 complete_cb_ptr)\n         }, 0);\n     }"}, {"sha": "15d5fe702a536b0d1069a9017ee462bbe2d91840", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -464,16 +464,18 @@ fn fs_mkstat(f: &mut FsRequest) -> FileStat {\n         created: to_msec(stat.st_birthtim),\n         modified: to_msec(stat.st_mtim),\n         accessed: to_msec(stat.st_atim),\n-        device: stat.st_dev as u64,\n-        inode: stat.st_ino as u64,\n-        rdev: stat.st_rdev as u64,\n-        nlink: stat.st_nlink as u64,\n-        uid: stat.st_uid as u64,\n-        gid: stat.st_gid as u64,\n-        blksize: stat.st_blksize as u64,\n-        blocks: stat.st_blocks as u64,\n-        flags: stat.st_flags as u64,\n-        gen: stat.st_gen as u64,\n+        unstable: io::UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: stat.st_blksize as u64,\n+            blocks: stat.st_blocks as u64,\n+            flags: stat.st_flags as u64,\n+            gen: stat.st_gen as u64,\n+        }\n     }\n }\n \n@@ -764,7 +766,7 @@ impl IoFactory for UvIoFactory {\n     }\n     fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError> {\n         fn getlink(f: &mut FsRequest) -> Path {\n-            Path::new(unsafe { CString::new(f.get_path(), false) })\n+            Path::new(unsafe { CString::new(f.get_ptr() as *libc::c_char, false) })\n         }\n         do uv_fs_helper(self.uv_loop(), getlink) |req, l, cb| {\n             req.readlink(l, path, cb)"}, {"sha": "2d850383766f5ace35d22e32364e844b7a7982a8", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -1207,7 +1207,7 @@ externfn!(fn uv_fs_ftruncate(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n externfn!(fn uv_fs_readlink(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n                             cb: *u8) -> c_int)\n externfn!(fn uv_fs_symlink(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n-                           dst: *c_char, cb: *u8) -> c_int)\n+                           dst: *c_char, flags: c_int, cb: *u8) -> c_int)\n externfn!(fn uv_fs_link(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n                         dst: *c_char, cb: *u8) -> c_int)\n externfn!(fn uv_fs_chown(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,"}, {"sha": "b066685f6ef640d981e8bb7039e63777fd89d384", "filename": "src/libstd/os.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -42,7 +42,6 @@ use ptr;\n use str;\n use to_str;\n use unstable::finally::Finally;\n-use vec;\n \n pub use os::consts::*;\n \n@@ -382,6 +381,7 @@ pub fn self_exe_path() -> Option<Path> {\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n+            use vec;\n             let mib = ~[CTL_KERN as c_int,\n                         KERN_PROC as c_int,\n                         KERN_PROC_PATHNAME as c_int, -1 as c_int];\n@@ -405,23 +405,11 @@ pub fn self_exe_path() -> Option<Path> {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn load_self() -> Option<~[u8]> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            use libc::funcs::posix01::unistd::readlink;\n-\n-            let mut path: ~[u8] = vec::with_capacity(TMPBUF_SZ);\n+        use std::rt::io;\n \n-            let len = do path.as_mut_buf |buf, _| {\n-                do \"/proc/self/exe\".with_c_str |proc_self_buf| {\n-                    readlink(proc_self_buf, buf as *mut c_char, TMPBUF_SZ as size_t) as uint\n-                }\n-            };\n-            if len == -1 {\n-                None\n-            } else {\n-                vec::raw::set_len(&mut path, len as uint);\n-                Some(path)\n-            }\n+        match io::result(|| io::fs::readlink(&Path::new(\"/proc/self/exe\"))) {\n+            Ok(Some(path)) => Some(path.as_vec().to_owned()),\n+            Ok(None) | Err(*) => None\n         }\n     }\n \n@@ -430,6 +418,7 @@ pub fn self_exe_path() -> Option<Path> {\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use libc::funcs::extra::_NSGetExecutablePath;\n+            use vec;\n             let mut sz: u32 = 0;\n             _NSGetExecutablePath(ptr::mut_null(), &mut sz);\n             if sz == 0 { return None; }\n@@ -814,6 +803,7 @@ fn real_args() -> ~[~str] {\n #[cfg(windows)]\n fn real_args() -> ~[~str] {\n     #[fixed_stack_segment]; #[inline(never)];\n+    use vec;\n \n     let mut nArgs: c_int = 0;\n     let lpArgCount: *mut c_int = &mut nArgs;\n@@ -1495,7 +1485,8 @@ mod tests {\n         use result::{Ok, Err};\n         use os::*;\n         use libc::*;\n-        use rt::io::File;\n+        use rt::io;\n+        use rt::io::fs;\n \n         #[cfg(unix)]\n         #[fixed_stack_segment]\n@@ -1544,7 +1535,7 @@ mod tests {\n             assert!(*chunk.data == 0xbe);\n             close(fd);\n         }\n-        File::unlink(&path);\n+        do io::ignore_io_error { fs::unlink(&path); }\n     }\n \n     // More recursive_mkdir tests are in extra::tempfile"}, {"sha": "22d7ea55f3b450859f2f8d95c78064390e3e30a2", "filename": "src/libstd/rt/io/fs.rs", "status": "renamed", "additions": 326, "deletions": 294, "changes": 620, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frt%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frt%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffs.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -25,6 +25,24 @@ defined in `std::path::Path`. The impl adds useful methods about inspecting the\n metadata of a file. This includes getting the `stat` information, reading off\n particular bits of it, etc.\n \n+# Example\n+\n+    use std::rt::io::{File, fs};\n+\n+    let path = Path::new(\"foo.txt\");\n+\n+    // create the file, whether it exists or not\n+    let mut file = File::create(&path);\n+    file.write(bytes!(\"foobar\"));\n+\n+    // open the file in read-only mode\n+    let mut file = File::open(&path);\n+    file.read_to_end();\n+\n+    println!(\"{}\", path.stat().size);\n+    fs::symlink(&path, &Path::new(\"bar.txt\"));\n+    fs::unlink(&path);\n+\n */\n \n use c_str::ToCStr;\n@@ -42,16 +60,14 @@ use vec::OwnedVector;\n \n /// Unconstrained file access type that exposes read and write operations\n ///\n-/// Can be retreived via `File::open()` and `Path.File::open_mode()`.\n+/// Can be constructed via `File::open()`, `File::create()`, and\n+/// `File::open_mode()`.\n ///\n /// # Errors\n ///\n /// This type will raise an io_error condition if operations are attempted against\n /// it for which its underlying file descriptor was not configured at creation\n-/// time, via the `FileAccess` parameter to `file::open()`.\n-///\n-/// For this reason, it is best to use the access-constrained wrappers that are\n-/// exposed via `Path.open()` and `Path.create()`.\n+/// time, via the `FileAccess` parameter to `File::open_mode()`.\n pub struct File {\n     priv fd: ~RtioFileStream,\n     priv path: Path,\n@@ -140,7 +156,7 @@ impl File {\n     ///\n     ///     use std::rt::io::File;\n     ///\n-    ///     let contents = File::open(\"foo.txt\").read_to_end();\n+    ///     let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n     pub fn open(path: &Path) -> Option<File> {\n         File::open_mode(path, Open, Read)\n     }\n@@ -155,239 +171,12 @@ impl File {\n     ///\n     ///     use std::rt::io::File;\n     ///\n-    ///     File::create(\"foo.txt\").write(bytes!(\"This is a sample file\"));\n+    ///     let mut f = File::create(&Path::new(\"foo.txt\"));\n+    ///     f.write(bytes!(\"This is a sample file\"));\n     pub fn create(path: &Path) -> Option<File> {\n         File::open_mode(path, Truncate, Write)\n     }\n \n-    /// Unlink a file from the underlying filesystem.\n-    ///\n-    /// # Example\n-    ///\n-    ///     use std::rt::io::File;\n-    ///\n-    ///     let p = Path::new(\"/some/file/path.txt\");\n-    ///     File::unlink(&p);\n-    ///     // if we made it here without failing, then the\n-    ///     // unlink operation was successful\n-    ///\n-    /// Note that, just because an unlink call was successful, it is not\n-    /// guaranteed that a file is immediately deleted (e.g. depending on\n-    /// platform, other open file descriptors may prevent immediate removal)\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will raise an `io_error` condition if the path points to a\n-    /// directory, the user lacks permissions to remove the file, or if some\n-    /// other filesystem-level error occurs.\n-    pub fn unlink(path: &Path) {\n-        do io_raise |io| { io.fs_unlink(&path.to_c_str()) };\n-    }\n-\n-    /// Given a path, query the file system to get information about a file,\n-    /// directory, etc. This function will traverse symlinks to query\n-    /// information about the destination file.\n-    ///\n-    /// Returns a fully-filled out stat structure on succes, and on failure it\n-    /// will return a dummy stat structure (it is expected that the condition\n-    /// raised is handled as well).\n-    ///\n-    /// # Example\n-    ///\n-    ///     use std::rt::io::{File, io_error};\n-    ///\n-    ///     let p = Path::new(\"/some/file/path.txt\");\n-    ///\n-    ///     do io_error::cond.trap(|_| {\n-    ///         // hoo-boy...\n-    ///     }).inside {\n-    ///         let info = File::stat(p);\n-    ///         if info.is_file {\n-    ///             // just imagine the possibilities ...\n-    ///         }\n-    ///     }\n-    ///\n-    /// # Errors\n-    ///\n-    /// This call will raise an `io_error` condition if the user lacks the\n-    /// requisite permissions to perform a `stat` call on the given path or if\n-    /// there is no entry in the filesystem at the provided path.\n-    pub fn stat(path: &Path) -> FileStat {\n-        do io_raise |io| {\n-            io.fs_stat(&path.to_c_str())\n-        }.unwrap_or_else(File::dummystat)\n-    }\n-\n-    fn dummystat() -> FileStat {\n-        FileStat {\n-            path: Path::new(\"\"),\n-            size: 0,\n-            kind: io::TypeFile,\n-            perm: 0,\n-            created: 0,\n-            modified: 0,\n-            accessed: 0,\n-            device: 0,\n-            inode: 0,\n-            rdev: 0,\n-            nlink: 0,\n-            uid: 0,\n-            gid: 0,\n-            blksize: 0,\n-            blocks: 0,\n-            flags: 0,\n-            gen: 0,\n-        }\n-    }\n-\n-    /// Perform the same operation as the `stat` function, except that this\n-    /// function does not traverse through symlinks. This will return\n-    /// information about the symlink file instead of the file that it points\n-    /// to.\n-    ///\n-    /// # Errors\n-    ///\n-    /// See `stat`\n-    pub fn lstat(path: &Path) -> FileStat {\n-        do io_raise |io| {\n-            io.fs_lstat(&path.to_c_str())\n-        }.unwrap_or_else(File::dummystat)\n-    }\n-\n-    /// Rename a file or directory to a new name.\n-    ///\n-    /// # Example\n-    ///\n-    ///     use std::rt::io::File;\n-    ///\n-    ///     File::rename(Path::new(\"foo\"), Path::new(\"bar\"));\n-    ///     // Oh boy, nothing was raised!\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will raise an `io_error` condition if the provided `path` doesn't exist,\n-    /// the process lacks permissions to view the contents, or if some other\n-    /// intermittent I/O error occurs.\n-    pub fn rename(from: &Path, to: &Path) {\n-        do io_raise |io| {\n-            io.fs_rename(&from.to_c_str(), &to.to_c_str())\n-        };\n-    }\n-\n-    /// Copies the contents of one file to another. This function will also\n-    /// copy the permission bits of the original file to the destination file.\n-    ///\n-    /// Note that if `from` and `to` both point to the same file, then the file\n-    /// will likely get truncated by this operation.\n-    ///\n-    /// # Example\n-    ///\n-    ///     use std::rt::io::File;\n-    ///\n-    ///     File::copy(Path::new(\"foo.txt\"), Path::new(\"bar.txt\"));\n-    ///     // Oh boy, nothing was raised!\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will raise an `io_error` condition is the following situtations, but is\n-    /// not limited to just these cases:\n-    ///\n-    /// * The `from` path is not a file\n-    /// * The `from` file does not exist\n-    /// * The current process does not have the permission rights to access\n-    ///   `from` or write `to`\n-    ///\n-    /// Note that this copy is not atomic in that once the destination is\n-    /// ensured to not exist, the is nothing preventing the destination from\n-    /// being created and then destroyed by this operation.\n-    pub fn copy(from: &Path, to: &Path) {\n-        if !from.is_file() {\n-            return io_error::cond.raise(IoError {\n-                kind: io::MismatchedFileTypeForOperation,\n-                desc: \"the source path is not an existing file\",\n-                detail: None,\n-            });\n-        }\n-\n-        let mut reader = match File::open(from) { Some(f) => f, None => return };\n-        let mut writer = match File::create(to) { Some(f) => f, None => return };\n-        let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n-\n-        loop {\n-            match reader.read(buf) {\n-                Some(amt) => writer.write(buf.slice_to(amt)),\n-                None => break\n-            }\n-        }\n-\n-        File::chmod(to, from.stat().perm)\n-    }\n-\n-    /// Changes the permission mode bits found on a file or a directory. This\n-    /// function takes a mask from the `io` module\n-    ///\n-    /// # Example\n-    ///\n-    ///     use std::rt::io;\n-    ///     use std::rt::io::File;\n-    ///\n-    ///     File::chmod(&Path::new(\"file.txt\"), io::UserFile);\n-    ///     File::chmod(&Path::new(\"file.txt\"), io::UserRead | io::UserWrite);\n-    ///     File::chmod(&Path::new(\"dir\"),      io::UserDir);\n-    ///     File::chmod(&Path::new(\"file.exe\"), io::UserExec);\n-    ///\n-    /// # Errors\n-    ///\n-    /// If this funciton encounters an I/O error, it will raise on the `io_error`\n-    /// condition. Some possible error situations are not having the permission to\n-    /// change the attributes of a file or the file not existing.\n-    pub fn chmod(path: &Path, mode: io::FilePermission) {\n-        do io_raise |io| {\n-            io.fs_chmod(&path.to_c_str(), mode)\n-        };\n-    }\n-\n-    /// Change the user and group owners of a file at the specified path.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This funtion will raise on the `io_error` condition on failure.\n-    pub fn chown(path: &Path, uid: int, gid: int) {\n-        do io_raise |io| { io.fs_chown(&path.to_c_str(), uid, gid) };\n-    }\n-\n-    /// Creates a new hard link on the filesystem. The `dst` path will be a\n-    /// link pointing to the `src` path. Note that systems often require these\n-    /// two paths to both be located on the same filesystem.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will raise on the `io_error` condition on failure.\n-    pub fn link(src: &Path, dst: &Path) {\n-        do io_raise |io| { io.fs_link(&src.to_c_str(), &dst.to_c_str()) };\n-    }\n-\n-    /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n-    /// symlink pointing to the `src` path.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will raise on the `io_error` condition on failure.\n-    pub fn symlink(src: &Path, dst: &Path) {\n-        do io_raise |io| { io.fs_symlink(&src.to_c_str(), &dst.to_c_str()) };\n-    }\n-\n-    /// Reads a symlink, returning the file that the symlink points to.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will raise on the `io_error` condition on failure.\n-    ///\n-    /// XXX: does this fail if called on files.\n-    pub fn readlink(path: &Path) -> Option<Path> {\n-        do io_raise |io| { io.fs_readlink(&path.to_c_str()) }\n-    }\n-\n     /// Returns the original path which was used to open this file.\n     pub fn path<'a>(&'a self) -> &'a Path {\n         &self.path\n@@ -433,15 +222,241 @@ impl File {\n     }\n }\n \n+/// Unlink a file from the underlying filesystem.\n+///\n+/// # Example\n+///\n+///     use std::rt::io::fs;\n+///\n+///     let p = Path::new(\"/some/file/path.txt\");\n+///     fs::unlink(&p);\n+///     // if we made it here without failing, then the\n+///     // unlink operation was successful\n+///\n+/// Note that, just because an unlink call was successful, it is not\n+/// guaranteed that a file is immediately deleted (e.g. depending on\n+/// platform, other open file descriptors may prevent immediate removal)\n+///\n+/// # Errors\n+///\n+/// This function will raise an `io_error` condition if the path points to a\n+/// directory, the user lacks permissions to remove the file, or if some\n+/// other filesystem-level error occurs.\n+pub fn unlink(path: &Path) {\n+    do io_raise |io| { io.fs_unlink(&path.to_c_str()) };\n+}\n+\n+/// Given a path, query the file system to get information about a file,\n+/// directory, etc. This function will traverse symlinks to query\n+/// information about the destination file.\n+///\n+/// Returns a fully-filled out stat structure on succes, and on failure it\n+/// will return a dummy stat structure (it is expected that the condition\n+/// raised is handled as well).\n+///\n+/// # Example\n+///\n+///     use std::rt::io;\n+///     use std::rt::io::fs;\n+///\n+///     let p = Path::new(\"/some/file/path.txt\");\n+///     match io::result(|| fs::stat(&p)) {\n+///         Ok(stat) => { /* ... */ }\n+///         Err(e) => { /* handle error */ }\n+///     }\n+///\n+/// # Errors\n+///\n+/// This call will raise an `io_error` condition if the user lacks the\n+/// requisite permissions to perform a `stat` call on the given path or if\n+/// there is no entry in the filesystem at the provided path.\n+pub fn stat(path: &Path) -> FileStat {\n+    do io_raise |io| {\n+        io.fs_stat(&path.to_c_str())\n+    }.unwrap_or_else(dummystat)\n+}\n+\n+fn dummystat() -> FileStat {\n+    FileStat {\n+        path: Path::new(\"\"),\n+        size: 0,\n+        kind: io::TypeFile,\n+        perm: 0,\n+        created: 0,\n+        modified: 0,\n+        accessed: 0,\n+        unstable: io::UnstableFileStat {\n+            device: 0,\n+            inode: 0,\n+            rdev: 0,\n+            nlink: 0,\n+            uid: 0,\n+            gid: 0,\n+            blksize: 0,\n+            blocks: 0,\n+            flags: 0,\n+            gen: 0,\n+        }\n+    }\n+}\n+\n+/// Perform the same operation as the `stat` function, except that this\n+/// function does not traverse through symlinks. This will return\n+/// information about the symlink file instead of the file that it points\n+/// to.\n+///\n+/// # Errors\n+///\n+/// See `stat`\n+pub fn lstat(path: &Path) -> FileStat {\n+    do io_raise |io| {\n+        io.fs_lstat(&path.to_c_str())\n+    }.unwrap_or_else(dummystat)\n+}\n+\n+/// Rename a file or directory to a new name.\n+///\n+/// # Example\n+///\n+///     use std::rt::io::fs;\n+///\n+///     fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n+///     // Oh boy, nothing was raised!\n+///\n+/// # Errors\n+///\n+/// Will raise an `io_error` condition if the provided `path` doesn't exist,\n+/// the process lacks permissions to view the contents, or if some other\n+/// intermittent I/O error occurs.\n+pub fn rename(from: &Path, to: &Path) {\n+    do io_raise |io| {\n+        io.fs_rename(&from.to_c_str(), &to.to_c_str())\n+    };\n+}\n+\n+/// Copies the contents of one file to another. This function will also\n+/// copy the permission bits of the original file to the destination file.\n+///\n+/// Note that if `from` and `to` both point to the same file, then the file\n+/// will likely get truncated by this operation.\n+///\n+/// # Example\n+///\n+///     use std::rt::io::fs;\n+///\n+///     fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n+///     // Oh boy, nothing was raised!\n+///\n+/// # Errors\n+///\n+/// Will raise an `io_error` condition is the following situtations, but is\n+/// not limited to just these cases:\n+///\n+/// * The `from` path is not a file\n+/// * The `from` file does not exist\n+/// * The current process does not have the permission rights to access\n+///   `from` or write `to`\n+///\n+/// Note that this copy is not atomic in that once the destination is\n+/// ensured to not exist, there is nothing preventing the destination from\n+/// being created and then destroyed by this operation.\n+pub fn copy(from: &Path, to: &Path) {\n+    if !from.is_file() {\n+        return io_error::cond.raise(IoError {\n+            kind: io::MismatchedFileTypeForOperation,\n+            desc: \"the source path is not an existing file\",\n+            detail: None,\n+        });\n+    }\n+\n+    let mut reader = match File::open(from) { Some(f) => f, None => return };\n+    let mut writer = match File::create(to) { Some(f) => f, None => return };\n+    let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n+\n+    loop {\n+        match reader.read(buf) {\n+            Some(amt) => writer.write(buf.slice_to(amt)),\n+            None => break\n+        }\n+    }\n+\n+    chmod(to, from.stat().perm)\n+}\n+\n+/// Changes the permission mode bits found on a file or a directory. This\n+/// function takes a mask from the `io` module\n+///\n+/// # Example\n+///\n+///     use std::rt::io;\n+///     use std::rt::io::fs;\n+///\n+///     fs::chmod(&Path::new(\"file.txt\"), io::UserFile);\n+///     fs::chmod(&Path::new(\"file.txt\"), io::UserRead | io::UserWrite);\n+///     fs::chmod(&Path::new(\"dir\"),      io::UserDir);\n+///     fs::chmod(&Path::new(\"file.exe\"), io::UserExec);\n+///\n+/// # Errors\n+///\n+/// If this funciton encounters an I/O error, it will raise on the `io_error`\n+/// condition. Some possible error situations are not having the permission to\n+/// change the attributes of a file or the file not existing.\n+pub fn chmod(path: &Path, mode: io::FilePermission) {\n+    do io_raise |io| {\n+        io.fs_chmod(&path.to_c_str(), mode)\n+    };\n+}\n+\n+/// Change the user and group owners of a file at the specified path.\n+///\n+/// # Errors\n+///\n+/// This funtion will raise on the `io_error` condition on failure.\n+pub fn chown(path: &Path, uid: int, gid: int) {\n+    do io_raise |io| { io.fs_chown(&path.to_c_str(), uid, gid) };\n+}\n+\n+/// Creates a new hard link on the filesystem. The `dst` path will be a\n+/// link pointing to the `src` path. Note that systems often require these\n+/// two paths to both be located on the same filesystem.\n+///\n+/// # Errors\n+///\n+/// This function will raise on the `io_error` condition on failure.\n+pub fn link(src: &Path, dst: &Path) {\n+    do io_raise |io| { io.fs_link(&src.to_c_str(), &dst.to_c_str()) };\n+}\n+\n+/// Creates a new symbolic link on the filesystem. The `dst` path will be a\n+/// symlink pointing to the `src` path.\n+///\n+/// # Errors\n+///\n+/// This function will raise on the `io_error` condition on failure.\n+pub fn symlink(src: &Path, dst: &Path) {\n+    do io_raise |io| { io.fs_symlink(&src.to_c_str(), &dst.to_c_str()) };\n+}\n+\n+/// Reads a symlink, returning the file that the symlink points to.\n+///\n+/// # Errors\n+///\n+/// This function will raise on the `io_error` condition on failure. Failure\n+/// conditions include reading a file that does not exist or reading a file\n+/// which is not a symlink.\n+pub fn readlink(path: &Path) -> Option<Path> {\n+    do io_raise |io| { io.fs_readlink(&path.to_c_str()) }\n+}\n+\n /// Create a new, empty directory at the provided path\n ///\n /// # Example\n ///\n ///     use std::libc::S_IRWXU;\n-///     use std::rt::io::file;\n+///     use std::rt::io::fs;\n ///\n ///     let p = Path::new(\"/some/dir\");\n-///     file::mkdir(&p, S_IRWXU as int);\n+///     fs::mkdir(&p, S_IRWXU as int);\n ///     // If we got here, our directory exists! Horray!\n ///\n /// # Errors\n@@ -459,10 +474,10 @@ pub fn mkdir(path: &Path, mode: FilePermission) {\n ///\n /// # Example\n ///\n-///     use std::rt::io::file;\n+///     use std::rt::io::fs;\n ///\n ///     let p = Path::new(\"/some/dir\");\n-///     file::rmdir(&p);\n+///     fs::rmdir(&p);\n ///     // good riddance, you mean ol' directory\n ///\n /// # Errors\n@@ -480,11 +495,12 @@ pub fn rmdir(path: &Path) {\n ///\n /// # Example\n ///\n-///     use std::rt::io::file;\n+///     use std::rt::io::fs;\n ///\n+///     // one possible implementation of fs::walk_dir only visiting files\n ///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n ///         if dir.is_dir() {\n-///             let contents = file::readdir(dir).unwrap();\n+///             let contents = fs::readdir(dir).unwrap();\n ///             for entry in contents.iter() {\n ///                 if entry.is_dir() { visit_dirs(entry, cb); }\n ///                 else { cb(entry); }\n@@ -536,7 +552,7 @@ impl Iterator<Path> for WalkIterator {\n /// # Errors\n ///\n /// This function will raise on the `io_error` condition if an error\n-/// happens, see `file::mkdir` for more information about error conditions\n+/// happens, see `fs::mkdir` for more information about error conditions\n /// and performance.\n pub fn mkdir_recursive(path: &Path, mode: FilePermission) {\n     // tjc: if directory exists but with different permissions,\n@@ -556,15 +572,15 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) {\n /// # Errors\n ///\n /// This function will raise on the `io_error` condition if an error\n-/// happens. See `file::unlink` and `file::readdir` for possible error\n+/// happens. See `file::unlink` and `fs::readdir` for possible error\n /// conditions.\n pub fn rmdir_recursive(path: &Path) {\n     let children = readdir(path);\n     for child in children.iter() {\n         if child.is_dir() {\n             rmdir_recursive(child);\n         } else {\n-            File::unlink(child);\n+            unlink(child);\n         }\n     }\n     // Directory should now be empty\n@@ -637,7 +653,7 @@ impl path::Path {\n     /// Consult the `file::stat` documentation for more info.\n     ///\n     /// This call preserves identical runtime/error semantics with `file::stat`.\n-    pub fn stat(&self) -> FileStat { File::stat(self) }\n+    pub fn stat(&self) -> FileStat { stat(self) }\n \n     /// Boolean value indicator whether the underlying file exists on the local\n     /// filesystem. This will return true if the path points to either a\n@@ -687,7 +703,9 @@ mod test {\n     use rt::io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open, ReadWrite};\n     use rt::io;\n     use str;\n-    use super::{File, rmdir, mkdir, readdir, rmdir_recursive, mkdir_recursive};\n+    use super::{File, rmdir, mkdir, readdir, rmdir_recursive, mkdir_recursive,\n+                copy, unlink, stat, symlink, link, readlink, chmod, chown,\n+                lstat};\n \n     fn tmpdir() -> Path {\n         use os;\n@@ -697,6 +715,8 @@ mod test {\n         ret\n     }\n \n+    fn free<T>(_: T) {}\n+\n     #[test]\n     fn file_test_io_smoke_test() {\n         let message = \"it's alright. have a good time\";\n@@ -714,7 +734,7 @@ mod test {\n             };\n             assert!(read_str == message.to_owned());\n         }\n-        File::unlink(filename);\n+        unlink(filename);\n     }\n \n     #[test]\n@@ -737,7 +757,7 @@ mod test {\n         do io_error::cond.trap(|_| {\n             called = true;\n         }).inside {\n-            File::unlink(filename);\n+            unlink(filename);\n         }\n         assert!(called);\n     }\n@@ -762,7 +782,7 @@ mod test {\n                 read_stream.read(read_buf);\n             }\n         }\n-        File::unlink(filename);\n+        unlink(filename);\n         let read_str = str::from_utf8(read_mem);\n         assert!(read_str == message.to_owned());\n     }\n@@ -786,7 +806,7 @@ mod test {\n             read_stream.read(read_mem);\n             tell_pos_post_read = read_stream.tell();\n         }\n-        File::unlink(filename);\n+        unlink(filename);\n         let read_str = str::from_utf8(read_mem);\n         assert!(read_str == message.slice(4, 8).to_owned());\n         assert!(tell_pos_pre_read == set_cursor);\n@@ -811,7 +831,7 @@ mod test {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             read_stream.read(read_mem);\n         }\n-        File::unlink(filename);\n+        unlink(filename);\n         let read_str = str::from_utf8(read_mem);\n         assert!(read_str == final_msg.to_owned());\n     }\n@@ -847,7 +867,7 @@ mod test {\n             let read_str = str::from_utf8(read_mem);\n             assert!(read_str == chunk_one.to_owned());\n         }\n-        File::unlink(filename);\n+        unlink(filename);\n     }\n \n     #[test]\n@@ -858,9 +878,9 @@ mod test {\n             let msg = \"hw\";\n             fs.write(msg.as_bytes());\n         }\n-        let stat_res = File::stat(filename);\n+        let stat_res = stat(filename);\n         assert_eq!(stat_res.kind, io::TypeFile);\n-        File::unlink(filename);\n+        unlink(filename);\n     }\n \n     #[test]\n@@ -885,7 +905,7 @@ mod test {\n         let file = &Path::new(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n         File::create(file).write(bytes!(\"foo\"));\n         assert!(file.exists());\n-        File::unlink(file);\n+        unlink(file);\n         assert!(!file.exists());\n     }\n \n@@ -926,7 +946,7 @@ mod test {\n                 };\n                 assert!(expected == read_str);\n             }\n-            File::unlink(f);\n+            unlink(f);\n         }\n         rmdir(dir);\n     }\n@@ -975,7 +995,7 @@ mod test {\n     fn copy_file_does_not_exist() {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n-        match io::result(|| File::copy(&from, &to)) {\n+        match io::result(|| copy(&from, &to)) {\n             Ok(*) => fail!(),\n             Err(*) => {\n                 assert!(!from.exists());\n@@ -991,7 +1011,7 @@ mod test {\n         let out = tmpdir.join(\"out.txt\");\n \n         File::create(&input).write(bytes!(\"hello\"));\n-        File::copy(&input, &out);\n+        copy(&input, &out);\n         let contents = File::open(&out).read_to_end();\n         assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n \n@@ -1005,7 +1025,7 @@ mod test {\n         let out = tmpdir.join(\"out\");\n \n         File::create(&out);\n-        match io::result(|| File::copy(&out, &tmpdir)) {\n+        match io::result(|| copy(&out, &tmpdir)) {\n             Ok(*) => fail!(), Err(*) => {}\n         }\n         rmdir_recursive(&tmpdir);\n@@ -1019,7 +1039,7 @@ mod test {\n \n         File::create(&input).write(\"foo\".as_bytes());\n         File::create(&output).write(\"bar\".as_bytes());\n-        File::copy(&input, &output);\n+        copy(&input, &output);\n \n         assert_eq!(File::open(&output).read_to_end(),\n                    (bytes!(\"foo\")).to_owned());\n@@ -1032,7 +1052,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n-        match io::result(|| File::copy(&tmpdir, &out)) {\n+        match io::result(|| copy(&tmpdir, &out)) {\n             Ok(*) => fail!(), Err(*) => {}\n         }\n         assert!(!out.exists());\n@@ -1046,40 +1066,48 @@ mod test {\n         let out = tmpdir.join(\"out.txt\");\n \n         File::create(&input);\n-        File::chmod(&input, io::UserExec);\n-        File::copy(&input, &out);\n-        assert_eq!(out.stat().perm, io::UserExec);\n+        chmod(&input, io::UserRead);\n+        copy(&input, &out);\n+        assert!(out.stat().perm & io::UserWrite == 0);\n \n+        chmod(&input, io::UserFile);\n+        chmod(&out, io::UserFile);\n         rmdir_recursive(&tmpdir);\n     }\n \n     #[test]\n+    #[ignore(cfg(windows))] // FIXME(#10264) operation not permitted?\n     fn symlinks_work() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n         File::create(&input).write(\"foobar\".as_bytes());\n-        File::symlink(&input, &out);\n-        assert_eq!(File::lstat(&out).kind, io::TypeSymlink);\n-        assert_eq!(File::stat(&out).size, File::stat(&input).size);\n+        symlink(&input, &out);\n+        assert_eq!(lstat(&out).kind, io::TypeSymlink);\n+        assert_eq!(stat(&out).size, stat(&input).size);\n         assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n \n-        // can't link to yourself\n-        match io::result(|| File::symlink(&input, &input)) {\n-            Ok(*) => fail!(\"wanted a failure\"),\n-            Err(*) => {}\n-        }\n-        // symlinks can point to things that don't exist\n-        File::symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"));\n+        rmdir_recursive(&tmpdir);\n+    }\n \n-        assert!(File::readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"bar\"));\n+    #[test]\n+    #[ignore(cfg(windows))] // apparently windows doesn't like symlinks\n+    fn symlink_noexist() {\n+        let tmpdir = tmpdir();\n+        // symlinks can point to things that don't exist\n+        symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"));\n+        assert!(readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"foo\"));\n+        rmdir_recursive(&tmpdir);\n+    }\n \n-        match io::result(|| File::readlink(&tmpdir)) {\n+    #[test]\n+    fn readlink_not_symlink() {\n+        let tmpdir = tmpdir();\n+        match io::result(|| readlink(&tmpdir)) {\n             Ok(*) => fail!(\"wanted a failure\"),\n             Err(*) => {}\n         }\n-\n         rmdir_recursive(&tmpdir);\n     }\n \n@@ -1090,19 +1118,19 @@ mod test {\n         let out = tmpdir.join(\"out.txt\");\n \n         File::create(&input).write(\"foobar\".as_bytes());\n-        File::link(&input, &out);\n-        assert_eq!(File::lstat(&out).kind, io::TypeFile);\n-        assert_eq!(File::stat(&out).size, File::stat(&input).size);\n-        assert_eq!(File::stat(&out).nlink, 2);\n+        link(&input, &out);\n+        assert_eq!(lstat(&out).kind, io::TypeFile);\n+        assert_eq!(stat(&out).size, stat(&input).size);\n+        assert_eq!(stat(&out).unstable.nlink, 2);\n         assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n \n         // can't link to yourself\n-        match io::result(|| File::link(&input, &input)) {\n+        match io::result(|| link(&input, &input)) {\n             Ok(*) => fail!(\"wanted a failure\"),\n             Err(*) => {}\n         }\n         // can't link to something that doesn't exist\n-        match io::result(|| File::link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"))) {\n+        match io::result(|| link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"))) {\n             Ok(*) => fail!(\"wanted a failure\"),\n             Err(*) => {}\n         }\n@@ -1116,14 +1144,16 @@ mod test {\n         let file = tmpdir.join(\"in.txt\");\n \n         File::create(&file);\n-        File::chmod(&file, io::UserRWX);\n-        assert_eq!(File::stat(&file).perm, io::UserRWX);\n+        assert!(stat(&file).perm & io::UserWrite == io::UserWrite);\n+        chmod(&file, io::UserRead);\n+        assert!(stat(&file).perm & io::UserWrite == 0);\n \n-        match io::result(|| File::chmod(&tmpdir.join(\"foo\"), io::UserRWX)) {\n+        match io::result(|| chmod(&tmpdir.join(\"foo\"), io::UserRWX)) {\n             Ok(*) => fail!(\"wanted a failure\"),\n             Err(*) => {}\n         }\n \n+        chmod(&file, io::UserFile);\n         rmdir_recursive(&tmpdir);\n     }\n \n@@ -1138,6 +1168,7 @@ mod test {\n         file.write(bytes!(\"foo\"));\n         file.fsync();\n         file.datasync();\n+        free(file);\n \n         rmdir_recursive(&tmpdir);\n     }\n@@ -1151,23 +1182,24 @@ mod test {\n         file.write(bytes!(\"foo\"));\n \n         // Do some simple things with truncation\n-        assert_eq!(File::stat(&path).size, 3);\n+        assert_eq!(stat(&path).size, 3);\n         file.truncate(10);\n-        assert_eq!(File::stat(&path).size, 10);\n+        assert_eq!(stat(&path).size, 10);\n         file.write(bytes!(\"bar\"));\n-        assert_eq!(File::stat(&path).size, 10);\n+        assert_eq!(stat(&path).size, 10);\n         assert_eq!(File::open(&path).read_to_end(),\n                    (bytes!(\"foobar\", 0, 0, 0, 0)).to_owned());\n \n         // Truncate to a smaller length, don't seek, and then write something.\n         // Ensure that the intermediate zeroes are all filled in (we're seeked\n         // past the end of the file).\n         file.truncate(2);\n-        assert_eq!(File::stat(&path).size, 2);\n+        assert_eq!(stat(&path).size, 2);\n         file.write(bytes!(\"wut\"));\n-        assert_eq!(File::stat(&path).size, 9);\n+        assert_eq!(stat(&path).size, 9);\n         assert_eq!(File::open(&path).read_to_end(),\n                    (bytes!(\"fo\", 0, 0, 0, 0, \"wut\")).to_owned());\n+        free(file);\n \n         rmdir_recursive(&tmpdir);\n     }\n@@ -1196,19 +1228,19 @@ mod test {\n                 Ok(*) => fail!(), Err(*) => {}\n             }\n         }\n-        assert_eq!(File::stat(&tmpdir.join(\"h\")).size, 3);\n+        assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n         {\n             let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Append,\n                                         io::Write).unwrap();\n             f.write(\"bar\".as_bytes());\n         }\n-        assert_eq!(File::stat(&tmpdir.join(\"h\")).size, 6);\n+        assert_eq!(stat(&tmpdir.join(\"h\")).size, 6);\n         {\n             let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n                                         io::Write).unwrap();\n             f.write(\"bar\".as_bytes());\n         }\n-        assert_eq!(File::stat(&tmpdir.join(\"h\")).size, 3);\n+        assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n \n         rmdir_recursive(&tmpdir);\n     }", "previous_filename": "src/libstd/rt/io/file.rs"}, {"sha": "f01ce5012eb25378918f5487848e1b77eb7643f5", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -259,7 +259,7 @@ pub use self::stdio::stderr;\n pub use self::stdio::print;\n pub use self::stdio::println;\n \n-pub use self::file::File;\n+pub use self::fs::File;\n pub use self::timer::Timer;\n pub use self::net::ip::IpAddr;\n pub use self::net::tcp::TcpListener;\n@@ -268,8 +268,8 @@ pub use self::net::udp::UdpStream;\n pub use self::pipe::PipeStream;\n pub use self::process::Process;\n \n-/// Synchronous, non-blocking file I/O.\n-pub mod file;\n+/// Synchronous, non-blocking filesystem operations.\n+pub mod fs;\n \n /// Synchronous, in-memory I/O.\n pub mod pipe;\n@@ -1155,7 +1155,23 @@ pub struct FileStat {\n     /// milliseconds\n     accessed: u64,\n \n-    // Various filesytem info\n+    /// Information returned by stat() which is not guaranteed to be\n+    /// platform-independent. This information may be useful on some platforms,\n+    /// but it may have different meanings or no meaning at all on other\n+    /// platforms.\n+    ///\n+    /// Usage of this field is discouraged, but if access is desired then the\n+    /// fields are located here.\n+    #[unstable]\n+    unstable: UnstableFileStat,\n+}\n+\n+/// This structure represents all of the possible information which can be\n+/// returned from a `stat` syscall which is not contained in the `FileStat`\n+/// structure. This information is not necessarily platform independent, and may\n+/// have different meanings or no meaning at all on some platforms.\n+#[unstable]\n+pub struct UnstableFileStat {\n     device: u64,\n     inode: u64,\n     rdev: u64,"}, {"sha": "35057f475cf5a8b05f29d107dea8f39089a59c29", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -737,7 +737,7 @@ mod old_os {\n \n     #[test]\n     fn test_path_is_dir() {\n-        use rt::io::file::{mkdir_recursive};\n+        use rt::io::fs::{mkdir_recursive};\n         use rt::io::{File, UserRWX};\n \n         assert!((path_is_dir(&Path::new(\".\"))));\n@@ -765,7 +765,7 @@ mod old_os {\n \n     #[test]\n     fn test_path_exists() {\n-        use rt::io::file::mkdir_recursive;\n+        use rt::io::fs::mkdir_recursive;\n         use rt::io::UserRWX;\n \n         assert!((path_exists(&Path::new(\".\"))));"}, {"sha": "0f48f83a57e0e63abb6f43320596bdc31c4db818", "filename": "src/libstd/rt/io/signal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsignal.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -208,6 +208,7 @@ mod test {\n     #[cfg(windows)]\n     #[test]\n     fn test_io_signal_invalid_signum() {\n+        use rt::io;\n         use super::User1;\n         let mut s = Listener::new();\n         let mut called = false;"}, {"sha": "e71cd92589c338723467cd2bf5d0d998ad42667e", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -836,7 +836,7 @@ impl ClosureConverter for UnsafeTaskReceiver {\n }\n \n // On unix, we read randomness straight from /dev/urandom, but the\n-// default constructor of an XorShiftRng does this via io::file, which\n+// default constructor of an XorShiftRng does this via io::fs, which\n // relies on the scheduler existing, so we have to manually load\n // randomness. Windows has its own C API for this, so we don't need to\n // worry there."}, {"sha": "74f4ed3d55e4bb93d163308eac6aa7c8ba38f775", "filename": "src/libstd/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -607,8 +607,8 @@ mod tests {\n         let parent_stat = parent_dir.stat();\n         let child_stat = child_dir.stat();\n \n-        assert_eq!(parent_stat.device, child_stat.device);\n-        assert_eq!(parent_stat.inode, child_stat.inode);\n+        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n+        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n     }\n \n     #[test]\n@@ -624,8 +624,8 @@ mod tests {\n         let parent_stat = parent_dir.stat();\n         let child_stat = child_dir.stat();\n \n-        assert_eq!(parent_stat.device, child_stat.device);\n-        assert_eq!(parent_stat.inode, child_stat.inode);\n+        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n+        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n     }\n \n     #[cfg(unix,not(target_os=\"android\"))]"}, {"sha": "897ee9cb88b06609f5ff16ba611cbb7e927eb1a1", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -21,7 +21,7 @@ use std::rt::io;\n pub fn main() {\n     fn mk_file(path: &str, directory: bool) {\n         if directory {\n-            io::file::mkdir(&Path::new(path), io::UserRWX);\n+            io::fs::mkdir(&Path::new(path), io::UserRWX);\n         } else {\n             io::File::create(&Path::new(path));\n         }"}, {"sha": "fcb57152daa5faf39aa6feee4b6778e9719b7516", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -18,8 +18,7 @@ use extra::tempfile::TempDir;\n use std::os;\n use std::libc;\n use std::rt::io;\n-use std::rt::io::file;\n-use std::rt::io::File;\n+use std::rt::io::fs;\n \n fn rename_directory() {\n     #[fixed_stack_segment];\n@@ -29,7 +28,7 @@ fn rename_directory() {\n         let tmpdir = TempDir::new(\"rename_directory\").expect(\"rename_directory failed\");\n         let tmpdir = tmpdir.path();\n         let old_path = tmpdir.join_many([\"foo\", \"bar\", \"baz\"]);\n-        file::mkdir_recursive(&old_path, io::UserRWX);\n+        fs::mkdir_recursive(&old_path, io::UserRWX);\n         let test_file = &old_path.join(\"temp.txt\");\n \n         /* Write the temp input file */\n@@ -50,8 +49,8 @@ fn rename_directory() {\n         assert_eq!(libc::fclose(ostream), (0u as libc::c_int));\n \n         let new_path = tmpdir.join_many([\"quux\", \"blat\"]);\n-        file::mkdir_recursive(&new_path, io::UserRWX);\n-        File::rename(&old_path, &new_path.join(\"newdir\"));\n+        fs::mkdir_recursive(&new_path, io::UserRWX);\n+        fs::rename(&old_path, &new_path.join(\"newdir\"));\n         assert!(new_path.join(\"newdir\").is_dir());\n         assert!(new_path.join_many([\"newdir\", \"temp.txt\"]).exists());\n     }"}, {"sha": "3a115ab29cf54635a06c541e6fc0fee7a3a22d34", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "patch": "@@ -25,7 +25,7 @@ use std::os;\n use std::task;\n use std::cell::Cell;\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::fs;\n \n fn test_tempdir() {\n     let path = {\n@@ -75,7 +75,7 @@ fn test_rm_tempdir() {\n         path = tmp.unwrap();\n     }\n     assert!(path.exists());\n-    file::rmdir_recursive(&path);\n+    fs::rmdir_recursive(&path);\n     assert!(!path.exists());\n }\n \n@@ -86,31 +86,31 @@ fn recursive_mkdir_rel() {\n     let cwd = os::getcwd();\n     debug!(\"recursive_mkdir_rel: Making: {} in cwd {} [{:?}]\", path.display(),\n            cwd.display(), path.exists());\n-    file::mkdir_recursive(&path, io::UserRWX);\n+    fs::mkdir_recursive(&path, io::UserRWX);\n     assert!(path.is_dir());\n-    file::mkdir_recursive(&path, io::UserRWX);\n+    fs::mkdir_recursive(&path, io::UserRWX);\n     assert!(path.is_dir());\n }\n \n fn recursive_mkdir_dot() {\n     let dot = Path::new(\".\");\n-    file::mkdir_recursive(&dot, io::UserRWX);\n+    fs::mkdir_recursive(&dot, io::UserRWX);\n     let dotdot = Path::new(\"..\");\n-    file::mkdir_recursive(&dotdot, io::UserRWX);\n+    fs::mkdir_recursive(&dotdot, io::UserRWX);\n }\n \n fn recursive_mkdir_rel_2() {\n     let path = Path::new(\"./frob/baz\");\n     let cwd = os::getcwd();\n     debug!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{:?}]\", path.display(),\n            cwd.display(), path.exists());\n-    file::mkdir_recursive(&path, io::UserRWX);\n+    fs::mkdir_recursive(&path, io::UserRWX);\n     assert!(path.is_dir());\n     assert!(path.dir_path().is_dir());\n     let path2 = Path::new(\"quux/blat\");\n     debug!(\"recursive_mkdir_rel_2: Making: {} in cwd {}\", path2.display(),\n            cwd.display());\n-    file::mkdir_recursive(&path2, io::UserRWX);\n+    fs::mkdir_recursive(&path2, io::UserRWX);\n     assert!(path2.is_dir());\n     assert!(path2.dir_path().is_dir());\n }\n@@ -125,11 +125,11 @@ pub fn test_rmdir_recursive_ok() {\n     let root = tmpdir.join(\"foo\");\n \n     debug!(\"making {}\", root.display());\n-    file::mkdir(&root, rwx);\n-    file::mkdir(&root.join(\"foo\"), rwx);\n-    file::mkdir(&root.join(\"foo\").join(\"bar\"), rwx);\n-    file::mkdir(&root.join(\"foo\").join(\"bar\").join(\"blat\"), rwx);\n-    file::rmdir_recursive(&root);\n+    fs::mkdir(&root, rwx);\n+    fs::mkdir(&root.join(\"foo\"), rwx);\n+    fs::mkdir(&root.join(\"foo\").join(\"bar\"), rwx);\n+    fs::mkdir(&root.join(\"foo\").join(\"bar\").join(\"blat\"), rwx);\n+    fs::rmdir_recursive(&root);\n     assert!(!root.exists());\n     assert!(!root.join(\"bar\").exists());\n     assert!(!root.join(\"bar\").join(\"blat\").exists());"}]}