{"sha": "790084ced18ca391c30d8e1045c04cbf2111499e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MDA4NGNlZDE4Y2EzOTFjMzBkOGUxMDQ1YzA0Y2JmMjExMTQ5OWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-15T19:23:00Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-15T20:01:31Z"}, "message": "rustc: Make fold_ty no longer use an object; introduce walk_ty", "tree": {"sha": "c9f845a7d24125514c6181159927cd8811928ef4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9f845a7d24125514c6181159927cd8811928ef4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/790084ced18ca391c30d8e1045c04cbf2111499e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/790084ced18ca391c30d8e1045c04cbf2111499e", "html_url": "https://github.com/rust-lang/rust/commit/790084ced18ca391c30d8e1045c04cbf2111499e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/790084ced18ca391c30d8e1045c04cbf2111499e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "232c4509574bd27605dfa93890670e1ae1366e31", "url": "https://api.github.com/repos/rust-lang/rust/commits/232c4509574bd27605dfa93890670e1ae1366e31", "html_url": "https://github.com/rust-lang/rust/commit/232c4509574bd27605dfa93890670e1ae1366e31"}], "stats": {"total": 275, "additions": 160, "deletions": 115}, "files": [{"sha": "71ad468c979b897011f6227540a4398497e36f46", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/790084ced18ca391c30d8e1045c04cbf2111499e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790084ced18ca391c30d8e1045c04cbf2111499e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=790084ced18ca391c30d8e1045c04cbf2111499e", "patch": "@@ -1477,24 +1477,21 @@ fn linearize_ty_params(@block_ctxt cx, @ty.t t) ->\n                   mutable vec[ValueRef] vals,\n                   mutable vec[uint] defs);\n \n-    state obj folder(@rr r) {\n-        fn fold_simple_ty(@ty.t t) -> @ty.t {\n-            alt(t.struct) {\n-                case (ty.ty_param(?pid)) {\n-                    let bool seen = false;\n-                    for (uint d in r.defs) {\n-                        if (d == pid) {\n-                            seen = true;\n-                        }\n-                    }\n-                    if (!seen) {\n-                        r.vals += vec(r.cx.fcx.lltydescs.get(pid));\n-                        r.defs += vec(pid);\n+    fn linearizer(@rr r, @ty.t t) {\n+        alt(t.struct) {\n+            case (ty.ty_param(?pid)) {\n+                let bool seen = false;\n+                for (uint d in r.defs) {\n+                    if (d == pid) {\n+                        seen = true;\n                     }\n                 }\n-                case (_) { }\n+                if (!seen) {\n+                    r.vals += vec(r.cx.fcx.lltydescs.get(pid));\n+                    r.defs += vec(pid);\n+                }\n             }\n-            ret t;\n+            case (_) { }\n         }\n     }\n \n@@ -1503,7 +1500,8 @@ fn linearize_ty_params(@block_ctxt cx, @ty.t t) ->\n                   mutable vals = param_vals,\n                   mutable defs = param_defs);\n \n-    ty.fold_ty(folder(x), t);\n+    auto f = bind linearizer(x, _);\n+    ty.walk_ty(f, t);\n \n     ret tup(x.defs, x.vals);\n }"}, {"sha": "d4eb62e73616aa2546356e59a0a4f1f2332f663e", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 136, "deletions": 86, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/790084ced18ca391c30d8e1045c04cbf2111499e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790084ced18ca391c30d8e1045c04cbf2111499e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=790084ced18ca391c30d8e1045c04cbf2111499e", "patch": "@@ -261,52 +261,114 @@ fn ty_to_str(&@t typ) -> str {\n \n // Type folds\n \n-type ty_fold = state obj {\n-    fn fold_simple_ty(@t ty) -> @t;\n-};\n+type ty_walk = fn(@t);\n+\n+fn walk_ty(ty_walk walker, @t ty) {\n+    alt (ty.struct) {\n+        case (ty_nil)           { /* no-op */ }\n+        case (ty_bool)          { /* no-op */ }\n+        case (ty_int)           { /* no-op */ }\n+        case (ty_uint)          { /* no-op */ }\n+        case (ty_float)         { /* no-op */ }\n+        case (ty_machine(_))    { /* no-op */ }\n+        case (ty_char)          { /* no-op */ }\n+        case (ty_str)           { /* no-op */ }\n+        case (ty_type)          { /* no-op */ }\n+        case (ty_native)        { /* no-op */ }\n+        case (ty_box(?tm))      { walk_ty(walker, tm.ty); }\n+        case (ty_vec(?tm))      { walk_ty(walker, tm.ty); }\n+        case (ty_port(?subty))  { walk_ty(walker, subty); }\n+        case (ty_chan(?subty))  { walk_ty(walker, subty); }\n+        case (ty_tag(?tid, ?subtys)) {\n+            for (@t subty in subtys) {\n+                walk_ty(walker, subty);\n+            }\n+        }\n+        case (ty_tup(?mts)) {\n+            for (mt tm in mts) {\n+                walk_ty(walker, tm.ty);\n+            }\n+        }\n+        case (ty_rec(?fields)) {\n+            for (field fl in fields) {\n+                walk_ty(walker, fl.mt.ty);\n+            }\n+        }\n+        case (ty_fn(?proto, ?args, ?ret_ty)) {\n+            for (arg a in args) {\n+                walk_ty(walker, a.ty);\n+            }\n+            walk_ty(walker, ret_ty);\n+        }\n+        case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n+            for (arg a in args) {\n+                walk_ty(walker, a.ty);\n+            }\n+            walk_ty(walker, ret_ty);\n+        }\n+        case (ty_obj(?methods)) {\n+            let vec[method] new_methods = vec();\n+            for (method m in methods) {\n+                for (arg a in m.inputs) {\n+                    walk_ty(walker, a.ty);\n+                }\n+                walk_ty(walker, m.output);\n+            }\n+        }\n+        case (ty_var(_))         { /* no-op */ }\n+        case (ty_local(_))       { /* no-op */ }\n+        case (ty_param(_))       { /* no-op */ }\n+        case (ty_bound_param(_)) { /* no-op */ }\n+    }\n \n-fn fold_ty(ty_fold fld, @t ty) -> @t {\n+    walker(ty);\n+}\n+\n+type ty_fold = fn(@t) -> @t;\n+\n+fn fold_ty(ty_fold fld, @t ty_0) -> @t {\n     fn rewrap(@t orig, &sty new) -> @t {\n         ret @rec(struct=new, cname=orig.cname);\n     }\n \n+    auto ty = ty_0;\n     alt (ty.struct) {\n-        case (ty_nil)           { ret fld.fold_simple_ty(ty); }\n-        case (ty_bool)          { ret fld.fold_simple_ty(ty); }\n-        case (ty_int)           { ret fld.fold_simple_ty(ty); }\n-        case (ty_uint)          { ret fld.fold_simple_ty(ty); }\n-        case (ty_float)         { ret fld.fold_simple_ty(ty); }\n-        case (ty_machine(_))    { ret fld.fold_simple_ty(ty); }\n-        case (ty_char)          { ret fld.fold_simple_ty(ty); }\n-        case (ty_str)           { ret fld.fold_simple_ty(ty); }\n-        case (ty_type)          { ret fld.fold_simple_ty(ty); }\n-        case (ty_native)        { ret fld.fold_simple_ty(ty); }\n+        case (ty_nil)           { /* no-op */ }\n+        case (ty_bool)          { /* no-op */ }\n+        case (ty_int)           { /* no-op */ }\n+        case (ty_uint)          { /* no-op */ }\n+        case (ty_float)         { /* no-op */ }\n+        case (ty_machine(_))    { /* no-op */ }\n+        case (ty_char)          { /* no-op */ }\n+        case (ty_str)           { /* no-op */ }\n+        case (ty_type)          { /* no-op */ }\n+        case (ty_native)        { /* no-op */ }\n         case (ty_box(?tm)) {\n-            ret rewrap(ty, ty_box(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)));\n+            ty = rewrap(ty, ty_box(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)));\n         }\n         case (ty_vec(?tm)) {\n-            ret rewrap(ty, ty_vec(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)));\n+            ty = rewrap(ty, ty_vec(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)));\n         }\n         case (ty_port(?subty)) {\n-            ret rewrap(ty, ty_port(fold_ty(fld, subty)));\n+            ty = rewrap(ty, ty_port(fold_ty(fld, subty)));\n         }\n         case (ty_chan(?subty)) {\n-            ret rewrap(ty, ty_chan(fold_ty(fld, subty)));\n+            ty = rewrap(ty, ty_chan(fold_ty(fld, subty)));\n         }\n         case (ty_tag(?tid, ?subtys)) {\n             let vec[@t] new_subtys = vec();\n             for (@t subty in subtys) {\n                 new_subtys += vec(fold_ty(fld, subty));\n             }\n-            ret rewrap(ty, ty_tag(tid, new_subtys));\n+            ty = rewrap(ty, ty_tag(tid, new_subtys));\n         }\n         case (ty_tup(?mts)) {\n             let vec[mt] new_mts = vec();\n             for (mt tm in mts) {\n                 auto new_subty = fold_ty(fld, tm.ty);\n                 new_mts += vec(rec(ty=new_subty, mut=tm.mut));\n             }\n-            ret rewrap(ty, ty_tup(new_mts));\n+            ty = rewrap(ty, ty_tup(new_mts));\n         }\n         case (ty_rec(?fields)) {\n             let vec[field] new_fields = vec();\n@@ -315,23 +377,24 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n                 auto new_mt = rec(ty=new_ty, mut=fl.mt.mut);\n                 new_fields += vec(rec(ident=fl.ident, mt=new_mt));\n             }\n-            ret rewrap(ty, ty_rec(new_fields));\n+            ty = rewrap(ty, ty_rec(new_fields));\n         }\n         case (ty_fn(?proto, ?args, ?ret_ty)) {\n             let vec[arg] new_args = vec();\n             for (arg a in args) {\n                 auto new_ty = fold_ty(fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ret rewrap(ty, ty_fn(proto, new_args, fold_ty(fld, ret_ty)));\n+            ty = rewrap(ty, ty_fn(proto, new_args, fold_ty(fld, ret_ty)));\n         }\n         case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n             let vec[arg] new_args = vec();\n             for (arg a in args) {\n                 auto new_ty = fold_ty(fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ret rewrap(ty, ty_native_fn(abi, new_args, fold_ty(fld, ret_ty)));\n+            ty = rewrap(ty, ty_native_fn(abi, new_args,\n+                                         fold_ty(fld, ret_ty)));\n         }\n         case (ty_obj(?methods)) {\n             let vec[method] new_methods = vec();\n@@ -344,15 +407,15 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n                                        inputs=new_args,\n                                        output=fold_ty(fld, m.output)));\n             }\n-            ret rewrap(ty, ty_obj(new_methods));\n+            ty = rewrap(ty, ty_obj(new_methods));\n         }\n-        case (ty_var(_))         { ret fld.fold_simple_ty(ty); }\n-        case (ty_local(_))       { ret fld.fold_simple_ty(ty); }\n-        case (ty_param(_))       { ret fld.fold_simple_ty(ty); }\n-        case (ty_bound_param(_)) { ret fld.fold_simple_ty(ty); }\n+        case (ty_var(_))         { /* no-op */ }\n+        case (ty_local(_))       { /* no-op */ }\n+        case (ty_param(_))       { /* no-op */ }\n+        case (ty_bound_param(_)) { /* no-op */ }\n     }\n \n-    fail;\n+    ret fld(ty);\n }\n \n // Type utilities\n@@ -655,45 +718,41 @@ fn triv_ann(@ty.t typ) -> ast.ann {\n \n // Returns the number of distinct type parameters in the given type.\n fn count_ty_params(@t ty) -> uint {\n-    state obj ty_param_counter(@mutable vec[uint] param_indices) {\n-        fn fold_simple_ty(@t ty) -> @t {\n-            alt (ty.struct) {\n-                case (ty_param(?param_idx)) {\n-                    auto seen = false;\n-                    for (uint other_param_idx in *param_indices) {\n-                        if (param_idx == other_param_idx) {\n-                            seen = true;\n-                        }\n-                    }\n-                    if (!seen) {\n-                        *param_indices += vec(param_idx);\n+    fn counter(@mutable vec[uint] param_indices, @t ty) {\n+        alt (ty.struct) {\n+            case (ty_param(?param_idx)) {\n+                auto seen = false;\n+                for (uint other_param_idx in *param_indices) {\n+                    if (param_idx == other_param_idx) {\n+                        seen = true;\n                     }\n                 }\n-                case (_) { /* fall through */ }\n+                if (!seen) {\n+                    *param_indices += vec(param_idx);\n+                }\n             }\n-            ret ty;\n+            case (_) { /* fall through */ }\n         }\n     }\n \n     let vec[uint] v = vec();    // FIXME: typechecker botch\n     let @mutable vec[uint] param_indices = @mutable v;\n-    fold_ty(ty_param_counter(param_indices), ty);\n+    auto f = bind counter(param_indices, _);\n+    walk_ty(f, ty);\n     ret _vec.len[uint](*param_indices);\n }\n \n fn type_contains_vars(@t typ) -> bool {\n-    state obj ty_var_counter(@mutable bool flag) {\n-        fn fold_simple_ty(@t typ) -> @t {\n-            alt (typ.struct) {\n+    fn checker(@mutable bool flag, @t typ) {\n+        alt (typ.struct) {\n             case (ty_var(_)) { *flag = true; }\n             case (_) { /* fall through */ }\n-            }\n-            ret typ;\n         }\n     }\n \n     let @mutable bool flag = @mutable false;\n-    fold_ty(ty_var_counter(flag), typ);\n+    auto f = bind checker(flag, _);\n+    walk_ty(f, typ);\n     ret *flag;\n }\n \n@@ -1684,26 +1743,23 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n \n     // Performs type binding substitution.\n     fn substitute(var_bindings bindings, vec[@t] set_types, @t typ) -> @t {\n-        state obj folder(tup(var_bindings, vec[@t]) env) {\n-            fn fold_simple_ty(@t typ) -> @t {\n-                auto bindings = env._0;\n-                auto types = env._1;\n-                alt (typ.struct) {\n+        fn substituter(var_bindings bindings, vec[@t] types, @t typ) -> @t {\n+            alt (typ.struct) {\n                 case (ty_var(?id)) {\n                     alt (bindings.var_ids.find(id)) {\n-                    case (some[uint](?n)) {\n-                        auto root = UFind.find(bindings.sets, n);\n-                        ret types.(root);\n-                    }\n-                    case (none[uint]) { ret typ; }\n+                        case (some[uint](?n)) {\n+                            auto root = UFind.find(bindings.sets, n);\n+                            ret types.(root);\n+                        }\n+                        case (none[uint]) { ret typ; }\n                     }\n                 }\n                 case (_) { ret typ; }\n-                }\n             }\n         }\n \n-        ret ty.fold_ty(folder(tup(bindings, set_types)), typ);\n+        auto f = bind substituter(bindings, set_types, _);\n+        ret fold_ty(f, typ);\n     }\n \n     fn unify_sets(&var_bindings bindings) -> vec[@t] {\n@@ -1804,41 +1860,35 @@ fn type_err_to_str(&ty.type_err err) -> str {\n // Performs bound type parameter replacement using the supplied mapping from\n // parameter IDs to types.\n fn substitute_type_params(vec[@t] bindings, @t typ) -> @t {\n-    state obj param_replacer(vec[@t] bindings) {\n-        fn fold_simple_ty(@t typ) -> @t {\n-            alt (typ.struct) {\n-                case (ty_bound_param(?param_index)) {\n-                    ret bindings.(param_index);\n-                }\n-                case (_) { ret typ; }\n+    fn replacer(vec[@t] bindings, @t typ) -> @t {\n+        alt (typ.struct) {\n+            case (ty_bound_param(?param_index)) {\n+                ret bindings.(param_index);\n             }\n+            case (_) { ret typ; }\n         }\n     }\n-    auto replacer = param_replacer(bindings);\n-    ret fold_ty(replacer, typ);\n+\n+    auto f = bind replacer(bindings, _);\n+    ret fold_ty(f, typ);\n }\n \n // Converts type parameters in a type to bound type parameters.\n fn bind_params_in_type(@t typ) -> @t {\n-    state obj folder(() env) {\n-        fn fold_simple_ty(@t typ) -> @t {\n-            alt (typ.struct) {\n-                case (ty_bound_param(?index)) {\n-                    log \"bind_params_in_type() called on type that already \" +\n-                        \"has bound params in it\";\n-                    fail;\n-                }\n-                case (ty_param(?index)) {\n-                    ret plain_ty(ty_bound_param(index));\n-                }\n-                case (_) {\n-                    ret typ;\n-                }\n+    fn binder(@t typ) -> @t {\n+        alt (typ.struct) {\n+            case (ty_bound_param(?index)) {\n+                log \"bind_params_in_type() called on type that already \" +\n+                    \"has bound params in it\";\n+                fail;\n             }\n+            case (ty_param(?index)) { ret plain_ty(ty_bound_param(index)); }\n+            case (_) { ret typ; }\n         }\n     }\n \n-    ret fold_ty(folder(()), typ);\n+    auto f = binder;\n+    ret fold_ty(f, typ);\n }\n \n "}, {"sha": "1a2f420781572c1a839b36d964bde1dad2f89aa5", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/790084ced18ca391c30d8e1045c04cbf2111499e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790084ced18ca391c30d8e1045c04cbf2111499e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=790084ced18ca391c30d8e1045c04cbf2111499e", "patch": "@@ -76,12 +76,10 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n                         uint ty_param_count,\n                         vec[@ty.t] supplied,\n                         &span sp) -> @ty.t {\n-    state obj ty_substituter(@crate_ctxt ccx, vec[@ty.t] supplied) {\n-        fn fold_simple_ty(@ty.t typ) -> @ty.t {\n-            alt (typ.struct) {\n-                case (ty.ty_bound_param(?pid)) { ret supplied.(pid); }\n-                case (_) { ret typ; }\n-            }\n+    fn substituter(@crate_ctxt ccx, vec[@ty.t] supplied, @ty.t typ) -> @ty.t {\n+        alt (typ.struct) {\n+            case (ty.ty_bound_param(?pid)) { ret supplied.(pid); }\n+            case (_) { ret typ; }\n         }\n     }\n \n@@ -94,8 +92,8 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n         fail;\n     }\n \n-    auto substituter = ty_substituter(ccx, supplied);\n-    ret ty.fold_ty(substituter, typ);\n+    auto f = bind substituter(ccx, supplied, _);\n+    ret ty.fold_ty(f, typ);\n }\n \n \n@@ -1498,12 +1496,10 @@ fn writeback_local(&option.t[@fn_ctxt] env, &span sp, @ast.local local)\n \n fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n         -> ast.ann {\n-    state obj folder(@fn_ctxt fcx) {\n-        fn fold_simple_ty(@ty.t typ) -> @ty.t {\n-            alt (typ.struct) {\n+    fn resolver(@fn_ctxt fcx, @ty.t typ) -> @ty.t {\n+        alt (typ.struct) {\n             case (ty.ty_local(?lid)) { ret fcx.locals.get(lid); }\n             case (_)                 { ret typ; }\n-            }\n         }\n     }\n \n@@ -1514,7 +1510,8 @@ fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n             ret ann;\n         }\n         case (ast.ann_type(?typ, ?tps, ?ts_info)) {\n-            auto new_type = ty.fold_ty(folder(fcx), ann_to_type(ann));\n+            auto f = bind resolver(fcx, _);\n+            auto new_type = ty.fold_ty(f, ann_to_type(ann));\n             ret ast.ann_type(new_type, tps, ts_info);\n         }\n     }"}]}