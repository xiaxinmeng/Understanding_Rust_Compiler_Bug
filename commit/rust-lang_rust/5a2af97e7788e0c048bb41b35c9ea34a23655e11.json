{"sha": "5a2af97e7788e0c048bb41b35c9ea34a23655e11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMmFmOTdlNzc4OGUwYzA0OGJiNDFiMzVjOWVhMzRhMjM2NTVlMTE=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2019-12-10T19:33:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-10T19:33:03Z"}, "message": "Rollup merge of #67178 - GuillaumeGomez:move-non-clean-impls, r=kinnison\n\nMove non clean impls items\n\nThis is another (and should be the last for the `clean` module) rustdoc cleanup.\n\nI tried to follow the same commit pattern as the last one to make the review as easy as possible.\n\nr? @kinnison", "tree": {"sha": "d9cfa159820e71024763ecc7f1d6925f3a406189", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9cfa159820e71024763ecc7f1d6925f3a406189"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a2af97e7788e0c048bb41b35c9ea34a23655e11", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd7/LvCRBK7hj4Ov3rIwAAdHIIAK9y3PvZmyfqAfLMcCwX4+ip\nQCkyxDgqGjauVJQVijHkVm5D8grh4Pd4zpJ3tvvaTeXzDJ/Yi6T3Y9UMcdeC4ffl\nJQfxpz+gSy9snX9wWsTEg7oBb2ICj+k8gQtMsOUxnnUS5s0gK/VDXFwrcOExSZUS\nETCBg096DaqctF7SRX1pRcuDPyHI0i9riJd+BK4axHD0KjCXu0txjBlesI8J4QN4\n9yys75KxxOiE2GyNNIkCJcNb00XUbZTn/8Su5HkKzgSOIJztwuofNuGUu1wbY6zL\nJF7oQGeUSjNJjV+YkG8w6Ipt0juU1sS7PjN21qs+jqzBZhT6g5aeGHg5HT8FJ8A=\n=4LTm\n-----END PGP SIGNATURE-----\n", "payload": "tree d9cfa159820e71024763ecc7f1d6925f3a406189\nparent 2af31dafc7bfdf88b73a1bd1aa8a882a1ff0b609\nparent f0babc8be487d5b78644059cb7a5d6e0c0ea57fd\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1576006383 +0900\ncommitter GitHub <noreply@github.com> 1576006383 +0900\n\nRollup merge of #67178 - GuillaumeGomez:move-non-clean-impls, r=kinnison\n\nMove non clean impls items\n\nThis is another (and should be the last for the `clean` module) rustdoc cleanup.\n\nI tried to follow the same commit pattern as the last one to make the review as easy as possible.\n\nr? @kinnison\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a2af97e7788e0c048bb41b35c9ea34a23655e11", "html_url": "https://github.com/rust-lang/rust/commit/5a2af97e7788e0c048bb41b35c9ea34a23655e11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a2af97e7788e0c048bb41b35c9ea34a23655e11/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2af31dafc7bfdf88b73a1bd1aa8a882a1ff0b609", "url": "https://api.github.com/repos/rust-lang/rust/commits/2af31dafc7bfdf88b73a1bd1aa8a882a1ff0b609", "html_url": "https://github.com/rust-lang/rust/commit/2af31dafc7bfdf88b73a1bd1aa8a882a1ff0b609"}, {"sha": "f0babc8be487d5b78644059cb7a5d6e0c0ea57fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0babc8be487d5b78644059cb7a5d6e0c0ea57fd", "html_url": "https://github.com/rust-lang/rust/commit/f0babc8be487d5b78644059cb7a5d6e0c0ea57fd"}], "stats": {"total": 1196, "additions": 608, "deletions": 588}, "files": [{"sha": "e198b008753ede7c0b0dabe8c9a9bb40e01173bb", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a2af97e7788e0c048bb41b35c9ea34a23655e11/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2af97e7788e0c048bb41b35c9ea34a23655e11/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=5a2af97e7788e0c048bb41b35c9ea34a23655e11", "patch": "@@ -1,10 +1,24 @@\n use rustc::hir;\n use rustc::traits::auto_trait::{self, AutoTraitResult};\n-use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::{self, Region, RegionVid, TypeFoldable};\n+use rustc::util::nodemap::FxHashSet;\n+\n use std::fmt::Debug;\n \n use super::*;\n \n+#[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n+enum RegionTarget<'tcx> {\n+    Region(Region<'tcx>),\n+    RegionVid(RegionVid)\n+}\n+\n+#[derive(Default, Debug, Clone)]\n+struct RegionDeps<'tcx> {\n+    larger: FxHashSet<RegionTarget<'tcx>>,\n+    smaller: FxHashSet<RegionTarget<'tcx>>\n+}\n+\n pub struct AutoTraitFinder<'a, 'tcx> {\n     pub cx: &'a core::DocContext<'tcx>,\n     pub f: auto_trait::AutoTraitFinder<'tcx>,"}, {"sha": "e5f684cbca87bffb3b7ab372417e2b430bdc8f4e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 587, "changes": 595, "blob_url": "https://github.com/rust-lang/rust/blob/5a2af97e7788e0c048bb41b35c9ea34a23655e11/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2af97e7788e0c048bb41b35c9ea34a23655e11/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5a2af97e7788e0c048bb41b35c9ea34a23655e11", "patch": "@@ -1,10 +1,9 @@\n-// ignore-tidy-filelength\n-\n //! This module contains the \"cleaned\" pieces of the AST, and the functions\n //! that clean them.\n \n pub mod inline;\n pub mod cfg;\n+pub mod utils;\n mod auto_trait;\n mod blanket_impl;\n mod simplify;\n@@ -19,15 +18,15 @@ use rustc::middle::stability;\n use rustc::mir::interpret::GlobalId;\n use rustc::hir;\n use rustc::hir::def::{CtorKind, DefKind, Res};\n-use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc::hir::ptr::P;\n-use rustc::ty::subst::{InternalSubsts, SubstsRef, GenericArgKind};\n-use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n+use rustc::ty::subst::InternalSubsts;\n+use rustc::ty::{self, TyCtxt, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax_pos::symbol::{Symbol, kw, sym};\n+use syntax_pos::symbol::{kw, sym};\n use syntax_pos::hygiene::MacroKind;\n use syntax_pos::{self, Pos};\n \n@@ -41,8 +40,9 @@ use std::u32;\n use crate::core::{self, DocContext, ImplTraitParam};\n use crate::doctree;\n \n-use self::auto_trait::AutoTraitFinder;\n-use self::blanket_impl::BlanketImplFinder;\n+use utils::*;\n+\n+pub use utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n \n pub use self::types::*;\n pub use self::types::Type::*;\n@@ -54,15 +54,6 @@ pub use self::types::Visibility::{Public, Inherited};\n \n const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n-// extract the stability index for a node from tcx, if possible\n-fn get_stability(cx: &DocContext<'_>, def_id: DefId) -> Option<Stability> {\n-    cx.tcx.lookup_stability(def_id).clean(cx)\n-}\n-\n-fn get_deprecation(cx: &DocContext<'_>, def_id: DefId) -> Option<Deprecation> {\n-    cx.tcx.lookup_deprecation(def_id).clean(cx)\n-}\n-\n pub trait Clean<T> {\n     fn clean(&self, cx: &DocContext<'_>) -> T;\n }\n@@ -109,91 +100,6 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n     }\n }\n \n-pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n-    use crate::visit_lib::LibEmbargoVisitor;\n-\n-    let krate = cx.tcx.hir().krate();\n-    let module = crate::visit_ast::RustdocVisitor::new(&mut cx).visit(krate);\n-\n-    let mut r = cx.renderinfo.get_mut();\n-    r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n-    r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n-    r.owned_box_did = cx.tcx.lang_items().owned_box();\n-\n-    let mut externs = Vec::new();\n-    for &cnum in cx.tcx.crates().iter() {\n-        externs.push((cnum, cnum.clean(cx)));\n-        // Analyze doc-reachability for extern items\n-        LibEmbargoVisitor::new(&mut cx).visit_lib(cnum);\n-    }\n-    externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n-\n-    // Clean the crate, translating the entire libsyntax AST to one that is\n-    // understood by rustdoc.\n-    let mut module = module.clean(cx);\n-    let mut masked_crates = FxHashSet::default();\n-\n-    match module.inner {\n-        ModuleItem(ref module) => {\n-            for it in &module.items {\n-                // `compiler_builtins` should be masked too, but we can't apply\n-                // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n-                if it.is_extern_crate()\n-                    && (it.attrs.has_doc_flag(sym::masked)\n-                        || cx.tcx.is_compiler_builtins(it.def_id.krate))\n-                {\n-                    masked_crates.insert(it.def_id.krate);\n-                }\n-            }\n-        }\n-        _ => unreachable!(),\n-    }\n-\n-    let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n-    {\n-        let m = match module.inner {\n-            ModuleItem(ref mut m) => m,\n-            _ => unreachable!(),\n-        };\n-        m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| {\n-            Item {\n-                source: Span::empty(),\n-                name: Some(prim.to_url_str().to_string()),\n-                attrs: attrs.clone(),\n-                visibility: Public,\n-                stability: get_stability(cx, def_id),\n-                deprecation: get_deprecation(cx, def_id),\n-                def_id,\n-                inner: PrimitiveItem(prim),\n-            }\n-        }));\n-        m.items.extend(keywords.into_iter().map(|(def_id, kw, attrs)| {\n-            Item {\n-                source: Span::empty(),\n-                name: Some(kw.clone()),\n-                attrs,\n-                visibility: Public,\n-                stability: get_stability(cx, def_id),\n-                deprecation: get_deprecation(cx, def_id),\n-                def_id,\n-                inner: KeywordItem(kw),\n-            }\n-        }));\n-    }\n-\n-    Crate {\n-        name,\n-        version: None,\n-        src,\n-        module: Some(module),\n-        externs,\n-        primitives,\n-        external_traits: cx.external_traits.clone(),\n-        masked_crates,\n-        collapsed: false,\n-    }\n-}\n-\n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext<'_>) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n@@ -394,66 +300,6 @@ impl Clean<GenericBound> for hir::GenericBound {\n     }\n }\n \n-fn external_generic_args(\n-    cx: &DocContext<'_>,\n-    trait_did: Option<DefId>,\n-    has_self: bool,\n-    bindings: Vec<TypeBinding>,\n-    substs: SubstsRef<'_>,\n-) -> GenericArgs {\n-    let mut skip_self = has_self;\n-    let mut ty_kind = None;\n-    let args: Vec<_> = substs.iter().filter_map(|kind| match kind.unpack() {\n-        GenericArgKind::Lifetime(lt) => {\n-            lt.clean(cx).and_then(|lt| Some(GenericArg::Lifetime(lt)))\n-        }\n-        GenericArgKind::Type(_) if skip_self => {\n-            skip_self = false;\n-            None\n-        }\n-        GenericArgKind::Type(ty) => {\n-            ty_kind = Some(&ty.kind);\n-            Some(GenericArg::Type(ty.clean(cx)))\n-        }\n-        GenericArgKind::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n-    }).collect();\n-\n-    match trait_did {\n-        // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n-            assert!(ty_kind.is_some());\n-            let inputs = match ty_kind {\n-                Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n-                _ => return GenericArgs::AngleBracketed { args, bindings },\n-            };\n-            let output = None;\n-            // FIXME(#20299) return type comes from a projection now\n-            // match types[1].kind {\n-            //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n-            //     _ => Some(types[1].clean(cx))\n-            // };\n-            GenericArgs::Parenthesized { inputs, output }\n-        },\n-        _ => {\n-            GenericArgs::AngleBracketed { args, bindings }\n-        }\n-    }\n-}\n-\n-// trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n-// from Fn<(A, B,), C> to Fn(A, B) -> C\n-fn external_path(cx: &DocContext<'_>, name: Symbol, trait_did: Option<DefId>, has_self: bool,\n-                 bindings: Vec<TypeBinding>, substs: SubstsRef<'_>) -> Path {\n-    Path {\n-        global: false,\n-        res: Res::Err,\n-        segments: vec![PathSegment {\n-            name: name.to_string(),\n-            args: external_generic_args(cx, trait_did, has_self, bindings, substs)\n-        }],\n-    }\n-}\n-\n impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>) {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n         let (trait_ref, ref bounds) = *self;\n@@ -1036,118 +882,6 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n     }\n }\n \n-/// The point of this function is to replace bounds with types.\n-///\n-/// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n-/// `[Display, Option]` (we just returns the list of the types, we don't care about the\n-/// wrapped types in here).\n-fn get_real_types(\n-    generics: &Generics,\n-    arg: &Type,\n-    cx: &DocContext<'_>,\n-    recurse: i32,\n-) -> FxHashSet<Type> {\n-    let arg_s = arg.print().to_string();\n-    let mut res = FxHashSet::default();\n-    if recurse >= 10 { // FIXME: remove this whole recurse thing when the recursion bug is fixed\n-        return res;\n-    }\n-    if arg.is_full_generic() {\n-        if let Some(where_pred) = generics.where_predicates.iter().find(|g| {\n-            match g {\n-                &WherePredicate::BoundPredicate { ref ty, .. } => ty.def_id() == arg.def_id(),\n-                _ => false,\n-            }\n-        }) {\n-            let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n-            for bound in bounds.iter() {\n-                match *bound {\n-                    GenericBound::TraitBound(ref poly_trait, _) => {\n-                        for x in poly_trait.generic_params.iter() {\n-                            if !x.is_type() {\n-                                continue\n-                            }\n-                            if let Some(ty) = x.get_type() {\n-                                let adds = get_real_types(generics, &ty, cx, recurse + 1);\n-                                if !adds.is_empty() {\n-                                    res.extend(adds);\n-                                } else if !ty.is_full_generic() {\n-                                    res.insert(ty);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        if let Some(bound) = generics.params.iter().find(|g| {\n-            g.is_type() && g.name == arg_s\n-        }) {\n-            for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n-                if let Some(ty) = bound.get_trait_type() {\n-                    let adds = get_real_types(generics, &ty, cx, recurse + 1);\n-                    if !adds.is_empty() {\n-                        res.extend(adds);\n-                    } else if !ty.is_full_generic() {\n-                        res.insert(ty.clone());\n-                    }\n-                }\n-            }\n-        }\n-    } else {\n-        res.insert(arg.clone());\n-        if let Some(gens) = arg.generics() {\n-            for gen in gens.iter() {\n-                if gen.is_full_generic() {\n-                    let adds = get_real_types(generics, gen, cx, recurse + 1);\n-                    if !adds.is_empty() {\n-                        res.extend(adds);\n-                    }\n-                } else {\n-                    res.insert(gen.clone());\n-                }\n-            }\n-        }\n-    }\n-    res\n-}\n-\n-/// Return the full list of types when bounds have been resolved.\n-///\n-/// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n-/// `[u32, Display, Option]`.\n-pub fn get_all_types(\n-    generics: &Generics,\n-    decl: &FnDecl,\n-    cx: &DocContext<'_>,\n-) -> (Vec<Type>, Vec<Type>) {\n-    let mut all_types = FxHashSet::default();\n-    for arg in decl.inputs.values.iter() {\n-        if arg.type_.is_self_type() {\n-            continue;\n-        }\n-        let args = get_real_types(generics, &arg.type_, cx, 0);\n-        if !args.is_empty() {\n-            all_types.extend(args);\n-        } else {\n-            all_types.insert(arg.type_.clone());\n-        }\n-    }\n-\n-    let ret_types = match decl.output {\n-        FunctionRetTy::Return(ref return_type) => {\n-            let mut ret = get_real_types(generics, &return_type, cx, 0);\n-            if ret.is_empty() {\n-                ret.insert(return_type.clone());\n-            }\n-            ret.into_iter().collect()\n-        }\n-        _ => Vec::new(),\n-    };\n-    (all_types.into_iter().collect(), ret_types)\n-}\n-\n impl<'a> Clean<Method> for (&'a hir::FnSig, &'a hir::Generics, hir::BodyId,\n                             Option<hir::Defaultness>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Method {\n@@ -2262,66 +1996,6 @@ impl Clean<PathSegment> for hir::PathSegment {\n     }\n }\n \n-fn strip_type(ty: Type) -> Type {\n-    match ty {\n-        Type::ResolvedPath { path, param_names, did, is_generic } => {\n-            Type::ResolvedPath { path: strip_path(&path), param_names, did, is_generic }\n-        }\n-        Type::Tuple(inner_tys) => {\n-            Type::Tuple(inner_tys.iter().map(|t| strip_type(t.clone())).collect())\n-        }\n-        Type::Slice(inner_ty) => Type::Slice(Box::new(strip_type(*inner_ty))),\n-        Type::Array(inner_ty, s) => Type::Array(Box::new(strip_type(*inner_ty)), s),\n-        Type::RawPointer(m, inner_ty) => Type::RawPointer(m, Box::new(strip_type(*inner_ty))),\n-        Type::BorrowedRef { lifetime, mutability, type_ } => {\n-            Type::BorrowedRef { lifetime, mutability, type_: Box::new(strip_type(*type_)) }\n-        }\n-        Type::QPath { name, self_type, trait_ } => {\n-            Type::QPath {\n-                name,\n-                self_type: Box::new(strip_type(*self_type)), trait_: Box::new(strip_type(*trait_))\n-            }\n-        }\n-        _ => ty\n-    }\n-}\n-\n-fn strip_path(path: &Path) -> Path {\n-    let segments = path.segments.iter().map(|s| {\n-        PathSegment {\n-            name: s.name.clone(),\n-            args: GenericArgs::AngleBracketed {\n-                args: vec![],\n-                bindings: vec![],\n-            }\n-        }\n-    }).collect();\n-\n-    Path {\n-        global: path.global,\n-        res: path.res.clone(),\n-        segments,\n-    }\n-}\n-\n-fn qpath_to_string(p: &hir::QPath) -> String {\n-    let segments = match *p {\n-        hir::QPath::Resolved(_, ref path) => &path.segments,\n-        hir::QPath::TypeRelative(_, ref segment) => return segment.ident.to_string(),\n-    };\n-\n-    let mut s = String::new();\n-    for (i, seg) in segments.iter().enumerate() {\n-        if i > 0 {\n-            s.push_str(\"::\");\n-        }\n-        if seg.ident.name != kw::PathRoot {\n-            s.push_str(&seg.ident.as_str());\n-        }\n-    }\n-    s\n-}\n-\n impl Clean<String> for Ident {\n     #[inline]\n     fn clean(&self, cx: &DocContext<'_>) -> String {\n@@ -2444,15 +2118,6 @@ impl Clean<ImplPolarity> for ty::ImplPolarity {\n     }\n }\n \n-pub fn get_auto_trait_and_blanket_impls(\n-    cx: &DocContext<'tcx>,\n-    ty: Ty<'tcx>,\n-    param_env_def_id: DefId,\n-) -> impl Iterator<Item = Item> {\n-    AutoTraitFinder::new(cx).get_auto_trait_impls(ty, param_env_def_id).into_iter()\n-        .chain(BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id))\n-}\n-\n impl Clean<Vec<Item>> for doctree::Impl<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         let mut ret = Vec::new();\n@@ -2497,63 +2162,6 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n     }\n }\n \n-fn build_deref_target_impls(cx: &DocContext<'_>,\n-                            items: &[Item],\n-                            ret: &mut Vec<Item>) {\n-    use self::PrimitiveType::*;\n-    let tcx = cx.tcx;\n-\n-    for item in items {\n-        let target = match item.inner {\n-            TypedefItem(ref t, true) => &t.type_,\n-            _ => continue,\n-        };\n-        let primitive = match *target {\n-            ResolvedPath { did, .. } if did.is_local() => continue,\n-            ResolvedPath { did, .. } => {\n-                ret.extend(inline::build_impls(cx, did, None));\n-                continue\n-            }\n-            _ => match target.primitive_type() {\n-                Some(prim) => prim,\n-                None => continue,\n-            }\n-        };\n-        let did = match primitive {\n-            Isize => tcx.lang_items().isize_impl(),\n-            I8 => tcx.lang_items().i8_impl(),\n-            I16 => tcx.lang_items().i16_impl(),\n-            I32 => tcx.lang_items().i32_impl(),\n-            I64 => tcx.lang_items().i64_impl(),\n-            I128 => tcx.lang_items().i128_impl(),\n-            Usize => tcx.lang_items().usize_impl(),\n-            U8 => tcx.lang_items().u8_impl(),\n-            U16 => tcx.lang_items().u16_impl(),\n-            U32 => tcx.lang_items().u32_impl(),\n-            U64 => tcx.lang_items().u64_impl(),\n-            U128 => tcx.lang_items().u128_impl(),\n-            F32 => tcx.lang_items().f32_impl(),\n-            F64 => tcx.lang_items().f64_impl(),\n-            Char => tcx.lang_items().char_impl(),\n-            Bool => tcx.lang_items().bool_impl(),\n-            Str => tcx.lang_items().str_impl(),\n-            Slice => tcx.lang_items().slice_impl(),\n-            Array => tcx.lang_items().slice_impl(),\n-            Tuple => None,\n-            Unit => None,\n-            RawPointer => tcx.lang_items().const_ptr_impl(),\n-            Reference => None,\n-            Fn => None,\n-            Never => None,\n-        };\n-        if let Some(did) = did {\n-            if !did.is_local() {\n-                inline::build_impl(cx, did, None, ret);\n-            }\n-        }\n-    }\n-}\n-\n impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n \n@@ -2710,170 +2318,6 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n     }\n }\n \n-// Utilities\n-\n-pub trait ToSource {\n-    fn to_src(&self, cx: &DocContext<'_>) -> String;\n-}\n-\n-impl ToSource for syntax_pos::Span {\n-    fn to_src(&self, cx: &DocContext<'_>) -> String {\n-        debug!(\"converting span {:?} to snippet\", self.clean(cx));\n-        let sn = match cx.sess().source_map().span_to_snippet(*self) {\n-            Ok(x) => x,\n-            Err(_) => String::new()\n-        };\n-        debug!(\"got snippet {}\", sn);\n-        sn\n-    }\n-}\n-\n-fn name_from_pat(p: &hir::Pat) -> String {\n-    use rustc::hir::*;\n-    debug!(\"trying to get a name from pattern: {:?}\", p);\n-\n-    match p.kind {\n-        PatKind::Wild => \"_\".to_string(),\n-        PatKind::Binding(_, _, ident, _) => ident.to_string(),\n-        PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n-        PatKind::Struct(ref name, ref fields, etc) => {\n-            format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n-                fields.iter().map(|fp| format!(\"{}: {}\", fp.ident, name_from_pat(&fp.pat)))\n-                             .collect::<Vec<String>>().join(\", \"),\n-                if etc { \", ..\" } else { \"\" }\n-            )\n-        }\n-        PatKind::Or(ref pats) => {\n-            pats.iter().map(|p| name_from_pat(&**p)).collect::<Vec<String>>().join(\" | \")\n-        }\n-        PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n-                                            .collect::<Vec<String>>().join(\", \")),\n-        PatKind::Box(ref p) => name_from_pat(&**p),\n-        PatKind::Ref(ref p, _) => name_from_pat(&**p),\n-        PatKind::Lit(..) => {\n-            warn!(\"tried to get argument name from PatKind::Lit, \\\n-                  which is silly in function arguments\");\n-            \"()\".to_string()\n-        },\n-        PatKind::Range(..) => panic!(\"tried to get argument name from PatKind::Range, \\\n-                              which is not allowed in function arguments\"),\n-        PatKind::Slice(ref begin, ref mid, ref end) => {\n-            let begin = begin.iter().map(|p| name_from_pat(&**p));\n-            let mid = mid.as_ref().map(|p| format!(\"..{}\", name_from_pat(&**p))).into_iter();\n-            let end = end.iter().map(|p| name_from_pat(&**p));\n-            format!(\"[{}]\", begin.chain(mid).chain(end).collect::<Vec<_>>().join(\", \"))\n-        },\n-    }\n-}\n-\n-fn print_const(cx: &DocContext<'_>, n: &ty::Const<'_>) -> String {\n-    match n.val {\n-        ty::ConstKind::Unevaluated(def_id, _) => {\n-            if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n-                print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n-            } else {\n-                inline::print_inlined_const(cx, def_id)\n-            }\n-        },\n-        _ => {\n-            let mut s = n.to_string();\n-            // array lengths are obviously usize\n-            if s.ends_with(\"usize\") {\n-                let n = s.len() - \"usize\".len();\n-                s.truncate(n);\n-                if s.ends_with(\": \") {\n-                    let n = s.len() - \": \".len();\n-                    s.truncate(n);\n-                }\n-            }\n-            s\n-        },\n-    }\n-}\n-\n-fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n-    cx.tcx.hir().hir_to_pretty_string(body.hir_id)\n-}\n-\n-/// Given a type Path, resolve it to a Type using the TyCtxt\n-fn resolve_type(cx: &DocContext<'_>,\n-                path: Path,\n-                id: hir::HirId) -> Type {\n-    if id == hir::DUMMY_HIR_ID {\n-        debug!(\"resolve_type({:?})\", path);\n-    } else {\n-        debug!(\"resolve_type({:?},{:?})\", path, id);\n-    }\n-\n-    let is_generic = match path.res {\n-        Res::PrimTy(p) => match p {\n-            hir::Str => return Primitive(PrimitiveType::Str),\n-            hir::Bool => return Primitive(PrimitiveType::Bool),\n-            hir::Char => return Primitive(PrimitiveType::Char),\n-            hir::Int(int_ty) => return Primitive(int_ty.into()),\n-            hir::Uint(uint_ty) => return Primitive(uint_ty.into()),\n-            hir::Float(float_ty) => return Primitive(float_ty.into()),\n-        },\n-        Res::SelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(kw::SelfUpper.to_string());\n-        }\n-        Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n-            return Generic(format!(\"{:#}\", path.print()));\n-        }\n-        Res::SelfTy(..)\n-        | Res::Def(DefKind::TyParam, _)\n-        | Res::Def(DefKind::AssocTy, _) => true,\n-        _ => false,\n-    };\n-    let did = register_res(&*cx, path.res);\n-    ResolvedPath { path, param_names: None, did, is_generic }\n-}\n-\n-pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n-    debug!(\"register_res({:?})\", res);\n-\n-    let (did, kind) = match res {\n-        Res::Def(DefKind::Fn, i) => (i, TypeKind::Function),\n-        Res::Def(DefKind::TyAlias, i) => (i, TypeKind::Typedef),\n-        Res::Def(DefKind::Enum, i) => (i, TypeKind::Enum),\n-        Res::Def(DefKind::Trait, i) => (i, TypeKind::Trait),\n-        Res::Def(DefKind::Struct, i) => (i, TypeKind::Struct),\n-        Res::Def(DefKind::Union, i) => (i, TypeKind::Union),\n-        Res::Def(DefKind::Mod, i) => (i, TypeKind::Module),\n-        Res::Def(DefKind::ForeignTy, i) => (i, TypeKind::Foreign),\n-        Res::Def(DefKind::Const, i) => (i, TypeKind::Const),\n-        Res::Def(DefKind::Static, i) => (i, TypeKind::Static),\n-        Res::Def(DefKind::Variant, i) => (cx.tcx.parent(i).expect(\"cannot get parent def id\"),\n-                            TypeKind::Enum),\n-        Res::Def(DefKind::Macro(mac_kind), i) => match mac_kind {\n-            MacroKind::Bang => (i, TypeKind::Macro),\n-            MacroKind::Attr => (i, TypeKind::Attr),\n-            MacroKind::Derive => (i, TypeKind::Derive),\n-        },\n-        Res::Def(DefKind::TraitAlias, i) => (i, TypeKind::TraitAlias),\n-        Res::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n-        Res::SelfTy(_, Some(impl_def_id)) => return impl_def_id,\n-        _ => return res.def_id()\n-    };\n-    if did.is_local() { return did }\n-    inline::record_extern_fqn(cx, did, kind);\n-    if let TypeKind::Trait = kind {\n-        inline::record_extern_trait(cx, did);\n-    }\n-    did\n-}\n-\n-fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n-    ImportSource {\n-        did: if path.res.opt_def_id().is_none() {\n-            None\n-        } else {\n-            Some(register_res(cx, path.res))\n-        },\n-        path,\n-    }\n-}\n-\n impl Clean<Item> for doctree::Macro<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let name = self.name.clean(cx);\n@@ -2981,29 +2425,6 @@ impl Clean<TypeBindingKind> for hir::TypeBindingKind {\n     }\n }\n \n-pub fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n-where\n-    F: FnOnce() -> R,\n-{\n-    let old_bounds = mem::take(&mut *cx.impl_trait_bounds.borrow_mut());\n-    let r = f();\n-    assert!(cx.impl_trait_bounds.borrow().is_empty());\n-    *cx.impl_trait_bounds.borrow_mut() = old_bounds;\n-    r\n-}\n-\n-#[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n-enum RegionTarget<'tcx> {\n-    Region(Region<'tcx>),\n-    RegionVid(RegionVid)\n-}\n-\n-#[derive(Default, Debug, Clone)]\n-struct RegionDeps<'tcx> {\n-    larger: FxHashSet<RegionTarget<'tcx>>,\n-    smaller: FxHashSet<RegionTarget<'tcx>>\n-}\n-\n enum SimpleBound {\n     TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParamDef>, hir::TraitBoundModifier),\n     Outlives(Lifetime),"}, {"sha": "e46300a8a5713062478fe558ad73f938eac6f0ad", "filename": "src/librustdoc/clean/utils.rs", "status": "added", "additions": 585, "deletions": 0, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/5a2af97e7788e0c048bb41b35c9ea34a23655e11/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2af97e7788e0c048bb41b35c9ea34a23655e11/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=5a2af97e7788e0c048bb41b35c9ea34a23655e11", "patch": "@@ -0,0 +1,585 @@\n+use crate::core::DocContext;\n+use crate::clean::{\n+    Clean, Crate, Deprecation, ExternalCrate, FnDecl, FunctionRetTy, Generic, GenericArg,\n+    GenericArgs, Generics, GenericBound, GetDefId, ImportSource, Item, ItemEnum, MacroKind, Path,\n+    PathSegment, Primitive, PrimitiveType, ResolvedPath, Span, Stability, Type, TypeBinding,\n+    TypeKind, Visibility, WherePredicate, inline,\n+};\n+use crate::clean::blanket_impl::BlanketImplFinder;\n+use crate::clean::auto_trait::AutoTraitFinder;\n+\n+use rustc::hir;\n+use rustc::hir::def::{DefKind, Res};\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::ty::{self, DefIdTree, Ty};\n+use rustc::ty::subst::{SubstsRef, GenericArgKind};\n+use rustc::util::nodemap::FxHashSet;\n+use syntax_pos;\n+use syntax_pos::symbol::{Symbol, kw, sym};\n+\n+use std::mem;\n+\n+pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n+    use crate::visit_lib::LibEmbargoVisitor;\n+\n+    let krate = cx.tcx.hir().krate();\n+    let module = crate::visit_ast::RustdocVisitor::new(&mut cx).visit(krate);\n+\n+    let mut r = cx.renderinfo.get_mut();\n+    r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n+    r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n+    r.owned_box_did = cx.tcx.lang_items().owned_box();\n+\n+    let mut externs = Vec::new();\n+    for &cnum in cx.tcx.crates().iter() {\n+        externs.push((cnum, cnum.clean(cx)));\n+        // Analyze doc-reachability for extern items\n+        LibEmbargoVisitor::new(&mut cx).visit_lib(cnum);\n+    }\n+    externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n+\n+    // Clean the crate, translating the entire libsyntax AST to one that is\n+    // understood by rustdoc.\n+    let mut module = module.clean(cx);\n+    let mut masked_crates = FxHashSet::default();\n+\n+    match module.inner {\n+        ItemEnum::ModuleItem(ref module) => {\n+            for it in &module.items {\n+                // `compiler_builtins` should be masked too, but we can't apply\n+                // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n+                if it.is_extern_crate()\n+                    && (it.attrs.has_doc_flag(sym::masked)\n+                        || cx.tcx.is_compiler_builtins(it.def_id.krate))\n+                {\n+                    masked_crates.insert(it.def_id.krate);\n+                }\n+            }\n+        }\n+        _ => unreachable!(),\n+    }\n+\n+    let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n+    {\n+        let m = match module.inner {\n+            ItemEnum::ModuleItem(ref mut m) => m,\n+            _ => unreachable!(),\n+        };\n+        m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| {\n+            Item {\n+                source: Span::empty(),\n+                name: Some(prim.to_url_str().to_string()),\n+                attrs: attrs.clone(),\n+                visibility: Visibility::Public,\n+                stability: get_stability(cx, def_id),\n+                deprecation: get_deprecation(cx, def_id),\n+                def_id,\n+                inner: ItemEnum::PrimitiveItem(prim),\n+            }\n+        }));\n+        m.items.extend(keywords.into_iter().map(|(def_id, kw, attrs)| {\n+            Item {\n+                source: Span::empty(),\n+                name: Some(kw.clone()),\n+                attrs,\n+                visibility: Visibility::Public,\n+                stability: get_stability(cx, def_id),\n+                deprecation: get_deprecation(cx, def_id),\n+                def_id,\n+                inner: ItemEnum::KeywordItem(kw),\n+            }\n+        }));\n+    }\n+\n+    Crate {\n+        name,\n+        version: None,\n+        src,\n+        module: Some(module),\n+        externs,\n+        primitives,\n+        external_traits: cx.external_traits.clone(),\n+        masked_crates,\n+        collapsed: false,\n+    }\n+}\n+\n+// extract the stability index for a node from tcx, if possible\n+pub fn get_stability(cx: &DocContext<'_>, def_id: DefId) -> Option<Stability> {\n+    cx.tcx.lookup_stability(def_id).clean(cx)\n+}\n+\n+pub fn get_deprecation(cx: &DocContext<'_>, def_id: DefId) -> Option<Deprecation> {\n+    cx.tcx.lookup_deprecation(def_id).clean(cx)\n+}\n+\n+pub fn external_generic_args(\n+    cx: &DocContext<'_>,\n+    trait_did: Option<DefId>,\n+    has_self: bool,\n+    bindings: Vec<TypeBinding>,\n+    substs: SubstsRef<'_>,\n+) -> GenericArgs {\n+    let mut skip_self = has_self;\n+    let mut ty_kind = None;\n+    let args: Vec<_> = substs.iter().filter_map(|kind| match kind.unpack() {\n+        GenericArgKind::Lifetime(lt) => {\n+            lt.clean(cx).and_then(|lt| Some(GenericArg::Lifetime(lt)))\n+        }\n+        GenericArgKind::Type(_) if skip_self => {\n+            skip_self = false;\n+            None\n+        }\n+        GenericArgKind::Type(ty) => {\n+            ty_kind = Some(&ty.kind);\n+            Some(GenericArg::Type(ty.clean(cx)))\n+        }\n+        GenericArgKind::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n+    }).collect();\n+\n+    match trait_did {\n+        // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n+        Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n+            assert!(ty_kind.is_some());\n+            let inputs = match ty_kind {\n+                Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n+                _ => return GenericArgs::AngleBracketed { args, bindings },\n+            };\n+            let output = None;\n+            // FIXME(#20299) return type comes from a projection now\n+            // match types[1].kind {\n+            //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n+            //     _ => Some(types[1].clean(cx))\n+            // };\n+            GenericArgs::Parenthesized { inputs, output }\n+        },\n+        _ => {\n+            GenericArgs::AngleBracketed { args, bindings }\n+        }\n+    }\n+}\n+\n+// trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n+// from Fn<(A, B,), C> to Fn(A, B) -> C\n+pub fn external_path(cx: &DocContext<'_>, name: Symbol, trait_did: Option<DefId>, has_self: bool,\n+                     bindings: Vec<TypeBinding>, substs: SubstsRef<'_>) -> Path {\n+    Path {\n+        global: false,\n+        res: Res::Err,\n+        segments: vec![PathSegment {\n+            name: name.to_string(),\n+            args: external_generic_args(cx, trait_did, has_self, bindings, substs)\n+        }],\n+    }\n+}\n+\n+/// The point of this function is to replace bounds with types.\n+///\n+/// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n+/// `[Display, Option]` (we just returns the list of the types, we don't care about the\n+/// wrapped types in here).\n+pub fn get_real_types(\n+    generics: &Generics,\n+    arg: &Type,\n+    cx: &DocContext<'_>,\n+    recurse: i32,\n+) -> FxHashSet<Type> {\n+    let arg_s = arg.print().to_string();\n+    let mut res = FxHashSet::default();\n+    if recurse >= 10 { // FIXME: remove this whole recurse thing when the recursion bug is fixed\n+        return res;\n+    }\n+    if arg.is_full_generic() {\n+        if let Some(where_pred) = generics.where_predicates.iter().find(|g| {\n+            match g {\n+                &WherePredicate::BoundPredicate { ref ty, .. } => ty.def_id() == arg.def_id(),\n+                _ => false,\n+            }\n+        }) {\n+            let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n+            for bound in bounds.iter() {\n+                match *bound {\n+                    GenericBound::TraitBound(ref poly_trait, _) => {\n+                        for x in poly_trait.generic_params.iter() {\n+                            if !x.is_type() {\n+                                continue\n+                            }\n+                            if let Some(ty) = x.get_type() {\n+                                let adds = get_real_types(generics, &ty, cx, recurse + 1);\n+                                if !adds.is_empty() {\n+                                    res.extend(adds);\n+                                } else if !ty.is_full_generic() {\n+                                    res.insert(ty);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        if let Some(bound) = generics.params.iter().find(|g| {\n+            g.is_type() && g.name == arg_s\n+        }) {\n+            for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n+                if let Some(ty) = bound.get_trait_type() {\n+                    let adds = get_real_types(generics, &ty, cx, recurse + 1);\n+                    if !adds.is_empty() {\n+                        res.extend(adds);\n+                    } else if !ty.is_full_generic() {\n+                        res.insert(ty.clone());\n+                    }\n+                }\n+            }\n+        }\n+    } else {\n+        res.insert(arg.clone());\n+        if let Some(gens) = arg.generics() {\n+            for gen in gens.iter() {\n+                if gen.is_full_generic() {\n+                    let adds = get_real_types(generics, gen, cx, recurse + 1);\n+                    if !adds.is_empty() {\n+                        res.extend(adds);\n+                    }\n+                } else {\n+                    res.insert(gen.clone());\n+                }\n+            }\n+        }\n+    }\n+    res\n+}\n+\n+/// Return the full list of types when bounds have been resolved.\n+///\n+/// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n+/// `[u32, Display, Option]`.\n+pub fn get_all_types(\n+    generics: &Generics,\n+    decl: &FnDecl,\n+    cx: &DocContext<'_>,\n+) -> (Vec<Type>, Vec<Type>) {\n+    let mut all_types = FxHashSet::default();\n+    for arg in decl.inputs.values.iter() {\n+        if arg.type_.is_self_type() {\n+            continue;\n+        }\n+        let args = get_real_types(generics, &arg.type_, cx, 0);\n+        if !args.is_empty() {\n+            all_types.extend(args);\n+        } else {\n+            all_types.insert(arg.type_.clone());\n+        }\n+    }\n+\n+    let ret_types = match decl.output {\n+        FunctionRetTy::Return(ref return_type) => {\n+            let mut ret = get_real_types(generics, &return_type, cx, 0);\n+            if ret.is_empty() {\n+                ret.insert(return_type.clone());\n+            }\n+            ret.into_iter().collect()\n+        }\n+        _ => Vec::new(),\n+    };\n+    (all_types.into_iter().collect(), ret_types)\n+}\n+\n+pub fn strip_type(ty: Type) -> Type {\n+    match ty {\n+        Type::ResolvedPath { path, param_names, did, is_generic } => {\n+            Type::ResolvedPath { path: strip_path(&path), param_names, did, is_generic }\n+        }\n+        Type::Tuple(inner_tys) => {\n+            Type::Tuple(inner_tys.iter().map(|t| strip_type(t.clone())).collect())\n+        }\n+        Type::Slice(inner_ty) => Type::Slice(Box::new(strip_type(*inner_ty))),\n+        Type::Array(inner_ty, s) => Type::Array(Box::new(strip_type(*inner_ty)), s),\n+        Type::RawPointer(m, inner_ty) => Type::RawPointer(m, Box::new(strip_type(*inner_ty))),\n+        Type::BorrowedRef { lifetime, mutability, type_ } => {\n+            Type::BorrowedRef { lifetime, mutability, type_: Box::new(strip_type(*type_)) }\n+        }\n+        Type::QPath { name, self_type, trait_ } => {\n+            Type::QPath {\n+                name,\n+                self_type: Box::new(strip_type(*self_type)), trait_: Box::new(strip_type(*trait_))\n+            }\n+        }\n+        _ => ty\n+    }\n+}\n+\n+pub fn strip_path(path: &Path) -> Path {\n+    let segments = path.segments.iter().map(|s| {\n+        PathSegment {\n+            name: s.name.clone(),\n+            args: GenericArgs::AngleBracketed {\n+                args: vec![],\n+                bindings: vec![],\n+            }\n+        }\n+    }).collect();\n+\n+    Path {\n+        global: path.global,\n+        res: path.res.clone(),\n+        segments,\n+    }\n+}\n+\n+pub fn qpath_to_string(p: &hir::QPath) -> String {\n+    let segments = match *p {\n+        hir::QPath::Resolved(_, ref path) => &path.segments,\n+        hir::QPath::TypeRelative(_, ref segment) => return segment.ident.to_string(),\n+    };\n+\n+    let mut s = String::new();\n+    for (i, seg) in segments.iter().enumerate() {\n+        if i > 0 {\n+            s.push_str(\"::\");\n+        }\n+        if seg.ident.name != kw::PathRoot {\n+            s.push_str(&seg.ident.as_str());\n+        }\n+    }\n+    s\n+}\n+\n+pub fn build_deref_target_impls(cx: &DocContext<'_>,\n+                                items: &[Item],\n+                                ret: &mut Vec<Item>) {\n+    use self::PrimitiveType::*;\n+    let tcx = cx.tcx;\n+\n+    for item in items {\n+        let target = match item.inner {\n+            ItemEnum::TypedefItem(ref t, true) => &t.type_,\n+            _ => continue,\n+        };\n+        let primitive = match *target {\n+            ResolvedPath { did, .. } if did.is_local() => continue,\n+            ResolvedPath { did, .. } => {\n+                ret.extend(inline::build_impls(cx, did, None));\n+                continue\n+            }\n+            _ => match target.primitive_type() {\n+                Some(prim) => prim,\n+                None => continue,\n+            }\n+        };\n+        let did = match primitive {\n+            Isize => tcx.lang_items().isize_impl(),\n+            I8 => tcx.lang_items().i8_impl(),\n+            I16 => tcx.lang_items().i16_impl(),\n+            I32 => tcx.lang_items().i32_impl(),\n+            I64 => tcx.lang_items().i64_impl(),\n+            I128 => tcx.lang_items().i128_impl(),\n+            Usize => tcx.lang_items().usize_impl(),\n+            U8 => tcx.lang_items().u8_impl(),\n+            U16 => tcx.lang_items().u16_impl(),\n+            U32 => tcx.lang_items().u32_impl(),\n+            U64 => tcx.lang_items().u64_impl(),\n+            U128 => tcx.lang_items().u128_impl(),\n+            F32 => tcx.lang_items().f32_impl(),\n+            F64 => tcx.lang_items().f64_impl(),\n+            Char => tcx.lang_items().char_impl(),\n+            Bool => tcx.lang_items().bool_impl(),\n+            Str => tcx.lang_items().str_impl(),\n+            Slice => tcx.lang_items().slice_impl(),\n+            Array => tcx.lang_items().slice_impl(),\n+            Tuple => None,\n+            Unit => None,\n+            RawPointer => tcx.lang_items().const_ptr_impl(),\n+            Reference => None,\n+            Fn => None,\n+            Never => None,\n+        };\n+        if let Some(did) = did {\n+            if !did.is_local() {\n+                inline::build_impl(cx, did, None, ret);\n+            }\n+        }\n+    }\n+}\n+\n+pub trait ToSource {\n+    fn to_src(&self, cx: &DocContext<'_>) -> String;\n+}\n+\n+impl ToSource for syntax_pos::Span {\n+    fn to_src(&self, cx: &DocContext<'_>) -> String {\n+        debug!(\"converting span {:?} to snippet\", self.clean(cx));\n+        let sn = match cx.sess().source_map().span_to_snippet(*self) {\n+            Ok(x) => x,\n+            Err(_) => String::new()\n+        };\n+        debug!(\"got snippet {}\", sn);\n+        sn\n+    }\n+}\n+\n+pub fn name_from_pat(p: &hir::Pat) -> String {\n+    use rustc::hir::*;\n+    debug!(\"trying to get a name from pattern: {:?}\", p);\n+\n+    match p.kind {\n+        PatKind::Wild => \"_\".to_string(),\n+        PatKind::Binding(_, _, ident, _) => ident.to_string(),\n+        PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n+        PatKind::Struct(ref name, ref fields, etc) => {\n+            format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n+                fields.iter().map(|fp| format!(\"{}: {}\", fp.ident, name_from_pat(&fp.pat)))\n+                             .collect::<Vec<String>>().join(\", \"),\n+                if etc { \", ..\" } else { \"\" }\n+            )\n+        }\n+        PatKind::Or(ref pats) => {\n+            pats.iter().map(|p| name_from_pat(&**p)).collect::<Vec<String>>().join(\" | \")\n+        }\n+        PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n+                                            .collect::<Vec<String>>().join(\", \")),\n+        PatKind::Box(ref p) => name_from_pat(&**p),\n+        PatKind::Ref(ref p, _) => name_from_pat(&**p),\n+        PatKind::Lit(..) => {\n+            warn!(\"tried to get argument name from PatKind::Lit, \\\n+                  which is silly in function arguments\");\n+            \"()\".to_string()\n+        },\n+        PatKind::Range(..) => panic!(\"tried to get argument name from PatKind::Range, \\\n+                              which is not allowed in function arguments\"),\n+        PatKind::Slice(ref begin, ref mid, ref end) => {\n+            let begin = begin.iter().map(|p| name_from_pat(&**p));\n+            let mid = mid.as_ref().map(|p| format!(\"..{}\", name_from_pat(&**p))).into_iter();\n+            let end = end.iter().map(|p| name_from_pat(&**p));\n+            format!(\"[{}]\", begin.chain(mid).chain(end).collect::<Vec<_>>().join(\", \"))\n+        },\n+    }\n+}\n+\n+pub fn print_const(cx: &DocContext<'_>, n: &ty::Const<'_>) -> String {\n+    match n.val {\n+        ty::ConstKind::Unevaluated(def_id, _) => {\n+            if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n+                print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n+            } else {\n+                inline::print_inlined_const(cx, def_id)\n+            }\n+        },\n+        _ => {\n+            let mut s = n.to_string();\n+            // array lengths are obviously usize\n+            if s.ends_with(\"usize\") {\n+                let n = s.len() - \"usize\".len();\n+                s.truncate(n);\n+                if s.ends_with(\": \") {\n+                    let n = s.len() - \": \".len();\n+                    s.truncate(n);\n+                }\n+            }\n+            s\n+        },\n+    }\n+}\n+\n+pub fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n+    cx.tcx.hir().hir_to_pretty_string(body.hir_id)\n+}\n+\n+/// Given a type Path, resolve it to a Type using the TyCtxt\n+pub fn resolve_type(cx: &DocContext<'_>,\n+                    path: Path,\n+                    id: hir::HirId) -> Type {\n+    if id == hir::DUMMY_HIR_ID {\n+        debug!(\"resolve_type({:?})\", path);\n+    } else {\n+        debug!(\"resolve_type({:?},{:?})\", path, id);\n+    }\n+\n+    let is_generic = match path.res {\n+        Res::PrimTy(p) => match p {\n+            hir::Str => return Primitive(PrimitiveType::Str),\n+            hir::Bool => return Primitive(PrimitiveType::Bool),\n+            hir::Char => return Primitive(PrimitiveType::Char),\n+            hir::Int(int_ty) => return Primitive(int_ty.into()),\n+            hir::Uint(uint_ty) => return Primitive(uint_ty.into()),\n+            hir::Float(float_ty) => return Primitive(float_ty.into()),\n+        },\n+        Res::SelfTy(..) if path.segments.len() == 1 => {\n+            return Generic(kw::SelfUpper.to_string());\n+        }\n+        Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n+            return Generic(format!(\"{:#}\", path.print()));\n+        }\n+        Res::SelfTy(..)\n+        | Res::Def(DefKind::TyParam, _)\n+        | Res::Def(DefKind::AssocTy, _) => true,\n+        _ => false,\n+    };\n+    let did = register_res(&*cx, path.res);\n+    ResolvedPath { path, param_names: None, did, is_generic }\n+}\n+\n+pub fn get_auto_trait_and_blanket_impls(\n+    cx: &DocContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    param_env_def_id: DefId,\n+) -> impl Iterator<Item = Item> {\n+    AutoTraitFinder::new(cx).get_auto_trait_impls(ty, param_env_def_id).into_iter()\n+        .chain(BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id))\n+}\n+\n+pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n+    debug!(\"register_res({:?})\", res);\n+\n+    let (did, kind) = match res {\n+        Res::Def(DefKind::Fn, i) => (i, TypeKind::Function),\n+        Res::Def(DefKind::TyAlias, i) => (i, TypeKind::Typedef),\n+        Res::Def(DefKind::Enum, i) => (i, TypeKind::Enum),\n+        Res::Def(DefKind::Trait, i) => (i, TypeKind::Trait),\n+        Res::Def(DefKind::Struct, i) => (i, TypeKind::Struct),\n+        Res::Def(DefKind::Union, i) => (i, TypeKind::Union),\n+        Res::Def(DefKind::Mod, i) => (i, TypeKind::Module),\n+        Res::Def(DefKind::ForeignTy, i) => (i, TypeKind::Foreign),\n+        Res::Def(DefKind::Const, i) => (i, TypeKind::Const),\n+        Res::Def(DefKind::Static, i) => (i, TypeKind::Static),\n+        Res::Def(DefKind::Variant, i) => (cx.tcx.parent(i).expect(\"cannot get parent def id\"),\n+                            TypeKind::Enum),\n+        Res::Def(DefKind::Macro(mac_kind), i) => match mac_kind {\n+            MacroKind::Bang => (i, TypeKind::Macro),\n+            MacroKind::Attr => (i, TypeKind::Attr),\n+            MacroKind::Derive => (i, TypeKind::Derive),\n+        },\n+        Res::Def(DefKind::TraitAlias, i) => (i, TypeKind::TraitAlias),\n+        Res::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n+        Res::SelfTy(_, Some(impl_def_id)) => return impl_def_id,\n+        _ => return res.def_id()\n+    };\n+    if did.is_local() { return did }\n+    inline::record_extern_fqn(cx, did, kind);\n+    if let TypeKind::Trait = kind {\n+        inline::record_extern_trait(cx, did);\n+    }\n+    did\n+}\n+\n+pub fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n+    ImportSource {\n+        did: if path.res.opt_def_id().is_none() {\n+            None\n+        } else {\n+            Some(register_res(cx, path.res))\n+        },\n+        path,\n+    }\n+}\n+\n+pub fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n+where\n+    F: FnOnce() -> R,\n+{\n+    let old_bounds = mem::take(&mut *cx.impl_trait_bounds.borrow_mut());\n+    let r = f();\n+    assert!(cx.impl_trait_bounds.borrow().is_empty());\n+    *cx.impl_trait_bounds.borrow_mut() = old_bounds;\n+    r\n+}"}]}