{"sha": "04f17634091587053ae7d7d35d2318406e8d7d0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZjE3NjM0MDkxNTg3MDUzYWU3ZDdkMzVkMjMxODQwNmU4ZDdkMGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-10T19:25:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-10T19:59:17Z"}, "message": "Combine the vtable_origins from impl + method.\n\nNot as clean as it could be, but fixes #3314.", "tree": {"sha": "85e535ba26527a72ca4b80866916291dee3034ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85e535ba26527a72ca4b80866916291dee3034ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04f17634091587053ae7d7d35d2318406e8d7d0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04f17634091587053ae7d7d35d2318406e8d7d0d", "html_url": "https://github.com/rust-lang/rust/commit/04f17634091587053ae7d7d35d2318406e8d7d0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04f17634091587053ae7d7d35d2318406e8d7d0d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22b875770543ec1fe93cfb35fd07c692db5675e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/22b875770543ec1fe93cfb35fd07c692db5675e2", "html_url": "https://github.com/rust-lang/rust/commit/22b875770543ec1fe93cfb35fd07c692db5675e2"}], "stats": {"total": 382, "additions": 298, "deletions": 84}, "files": [{"sha": "874eb86a18cebdda6a6eff03795f54938e154c32", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=04f17634091587053ae7d7d35d2318406e8d7d0d", "patch": "@@ -120,21 +120,18 @@ fn trans_fn_ref_to_callee(bcx: block,\n fn trans_fn_ref(bcx: block,\n                 def_id: ast::def_id,\n                 ref_id: ast::node_id) -> FnData {\n-    //!\n-    //\n-    // Translates a reference (with id `ref_id`) to the fn/method\n-    // with id `def_id` into a function pointer.  This may require\n-    // monomorphization or inlining.\n+    /*!\n+     *\n+     * Translates a reference (with id `ref_id`) to the fn/method\n+     * with id `def_id` into a function pointer.  This may require\n+     * monomorphization or inlining. */\n \n     let _icx = bcx.insn_ctxt(\"trans_fn\");\n \n     let type_params = node_id_type_params(bcx, ref_id);\n \n-    let raw_vtables = bcx.ccx().maps.vtable_map.find(ref_id);\n-    let resolved_vtables = raw_vtables.map(\n-        |vts| impl::resolve_vtables_in_fn_ctxt(bcx.fcx, vts));\n-    trans_fn_ref_with_vtables(bcx, def_id, ref_id, type_params,\n-                              resolved_vtables)\n+    let vtables = node_vtables(bcx, ref_id);\n+    trans_fn_ref_with_vtables(bcx, def_id, ref_id, type_params, vtables)\n }\n \n fn trans_fn_ref_with_vtables_to_callee(bcx: block,\n@@ -174,6 +171,13 @@ fn trans_fn_ref_with_vtables(\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n+    debug!(\"trans_fn_ref_with_vtables(bcx=%s, def_id=%?, ref_id=%?, \\\n+            type_params=%?, vtables=%?)\",\n+           bcx.to_str(), def_id, ref_id,\n+           type_params.map(|t| bcx.ty_to_str(t)),\n+           vtables);\n+    let _indenter = indenter();\n+\n     // Polytype of the function item (may have type params)\n     let fn_tpt = ty::lookup_item_type(tcx, def_id);\n "}, {"sha": "064b3006431d74c21f8a6ec1f1cea910f8873ba8", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=04f17634091587053ae7d7d35d2318406e8d7d0d", "patch": "@@ -187,6 +187,13 @@ type param_substs = {tys: ~[ty::t],\n                      vtables: Option<typeck::vtable_res>,\n                      bounds: @~[ty::param_bounds]};\n \n+fn param_substs_to_str(tcx: ty::ctxt, substs: &param_substs) -> ~str {\n+    fmt!(\"param_substs {tys:%?, vtables:%?, bounds:%?}\",\n+         substs.tys.map(|t| ty_to_str(tcx, t)),\n+         substs.vtables.map(|vs| vs.map(|v| v.to_str(tcx))),\n+         substs.bounds.map(|b| ty::param_bounds_to_str(tcx, b)))\n+}\n+\n // Function context.  Every LLVM function we create will have one of\n // these.\n type fn_ctxt = @{\n@@ -1181,9 +1188,11 @@ fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n       _ => { assert !ty::type_has_params(t); t }\n     }\n }\n+\n fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n+\n fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n@@ -1195,6 +1204,71 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     }\n }\n \n+fn node_vtables(bcx: block, id: ast::node_id) -> Option<typeck::vtable_res> {\n+    let raw_vtables = bcx.ccx().maps.vtable_map.find(id);\n+    raw_vtables.map(\n+        |vts| impl::resolve_vtables_in_fn_ctxt(bcx.fcx, vts))\n+}\n+\n+fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n+    -> typeck::vtable_res\n+{\n+    @vec::map(*vts, |d| resolve_vtable_in_fn_ctxt(fcx, d))\n+}\n+\n+// Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n+// eliminate any vtable_params.\n+fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n+    -> typeck::vtable_origin\n+{\n+    let tcx = fcx.ccx.tcx;\n+    match vt {\n+        typeck::vtable_static(trait_id, tys, sub) => {\n+            let tys = match fcx.param_substs {\n+                Some(substs) => {\n+                    vec::map(tys, |t| ty::subst_tps(tcx, substs.tys, t))\n+                }\n+                _ => tys\n+            };\n+            typeck::vtable_static(trait_id, tys,\n+                                  resolve_vtables_in_fn_ctxt(fcx, sub))\n+        }\n+        typeck::vtable_param(n_param, n_bound) => {\n+            match fcx.param_substs {\n+                Some(ref substs) => {\n+                    find_vtable(tcx, substs, n_param, n_bound)\n+                }\n+                _ => {\n+                    tcx.sess.bug(fmt!(\n+                        \"resolve_vtable_in_fn_ctxt: asked to lookup %? but \\\n+                         no vtables in the fn_ctxt!\", vt))\n+                }\n+            }\n+        }\n+        _ => vt\n+    }\n+}\n+\n+fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n+               n_param: uint, n_bound: uint)\n+    -> typeck::vtable_origin\n+{\n+    debug!(\"find_vtable_in_fn_ctxt(n_param=%u, n_bound=%u, ps=%?)\",\n+           n_param, n_bound, param_substs_to_str(tcx, ps));\n+\n+    let mut vtable_off = n_bound, i = 0u;\n+    // Vtables are stored in a flat array, finding the right one is\n+    // somewhat awkward\n+    for vec::each(*ps.bounds) |bounds| {\n+        if i >= n_param { break; }\n+        for vec::each(*bounds) |bound| {\n+            match bound { ty::bound_trait(_) => vtable_off += 1u, _ => () }\n+        }\n+        i += 1u;\n+    }\n+    option::get(ps.vtables)[vtable_off]\n+}\n+\n fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n     {self_r: Some(ty::re_bound(ty::br_self)),\n      self_ty: None,"}, {"sha": "f821d74af067aaf110d488be4c6fb9c8eeed3da9", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 106, "deletions": 72, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=04f17634091587053ae7d7d35d2318406e8d7d0d", "patch": "@@ -134,8 +134,8 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n         typeck::method_param({trait_id:trait_id, method_num:off,\n                               param_num:p, bound_num:b}) => {\n             match bcx.fcx.param_substs {\n-                Some(substs) => {\n-                    let vtbl = find_vtable_in_fn_ctxt(substs, p, b);\n+                Some(ref substs) => {\n+                    let vtbl = base::find_vtable(bcx.tcx(), substs, p, b);\n                     trans_monomorphized_callee(bcx, callee_id, self, mentry,\n                                                trait_id, off, vtbl)\n                 }\n@@ -177,19 +177,17 @@ fn trans_static_method_callee(bcx: block,\n         bcx.fcx, ccx.maps.vtable_map.get(callee_id));\n \n     match vtbls[0] { // is index 0 always the one we want?\n-        typeck::vtable_static(impl_did, impl_substs, sub_origins) => {\n+        typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n \n             let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n-            let n_m_tps = method_ty_param_count(ccx, mth_id, impl_did);\n-            let node_substs = node_id_type_params(bcx, callee_id);\n-            let ty_substs\n-                = vec::append(impl_substs,\n-                              vec::tailn(node_substs,\n-                                         node_substs.len() - n_m_tps));\n+            let callee_substs = combine_impl_and_methods_tps(\n+                bcx, mth_id, impl_did, callee_id, rcvr_substs);\n+            let callee_origins = combine_impl_and_methods_origins(\n+                bcx, mth_id, impl_did, callee_id, rcvr_origins);\n \n             let FnData {llfn: lval} =\n                 trans_fn_ref_with_vtables(bcx, mth_id, callee_id,\n-                                          ty_substs, Some(sub_origins));\n+                                          callee_substs, Some(callee_origins));\n \n             let callee_ty = node_id_type(bcx, callee_id);\n             let llty = T_ptr(type_of_fn_from_ty(ccx, callee_ty));\n@@ -248,8 +246,8 @@ fn trans_monomorphized_callee(bcx: block,\n     -> Callee\n {\n     let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n-    match vtbl {\n-      typeck::vtable_static(impl_did, impl_substs, sub_origins) => {\n+    return match vtbl {\n+      typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n           let mname = ty::trait_methods(ccx.tcx, trait_id)[n_method].ident;\n           let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n@@ -260,20 +258,14 @@ fn trans_monomorphized_callee(bcx: block,\n \n           // create a concatenated set of substitutions which includes\n           // those from the impl and those from the method:\n-          let n_m_tps = method_ty_param_count(ccx, mth_id, impl_did);\n-          let node_substs = node_id_type_params(bcx, callee_id);\n-          let ty_substs\n-              = vec::append(impl_substs,\n-                            vec::tailn(node_substs,\n-                                       node_substs.len() - n_m_tps));\n-          debug!(\"n_m_tps=%?\", n_m_tps);\n-          debug!(\"impl_substs=%?\", impl_substs.map(|t| bcx.ty_to_str(t)));\n-          debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(t)));\n-          debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(t)));\n+          let callee_substs = combine_impl_and_methods_tps(\n+              bcx, mth_id, impl_did, callee_id, rcvr_substs);\n+          let callee_origins = combine_impl_and_methods_origins(\n+              bcx, mth_id, impl_did, callee_id, rcvr_origins);\n \n           // translate the function\n           let callee = trans_fn_ref_with_vtables(\n-              bcx, mth_id, callee_id, ty_substs, Some(sub_origins));\n+              bcx, mth_id, callee_id, callee_substs, Some(callee_origins));\n \n           // create a llvalue that represents the fn ptr\n           let fn_ty = node_id_type(bcx, callee_id);\n@@ -297,9 +289,99 @@ fn trans_monomorphized_callee(bcx: block,\n       typeck::vtable_param(*) => {\n           fail ~\"vtable_param left in monomorphized function's vtable substs\";\n       }\n-    }\n+    };\n+\n+}\n+\n+fn combine_impl_and_methods_tps(bcx: block,\n+                                mth_did: ast::def_id,\n+                                impl_did: ast::def_id,\n+                                callee_id: ast::node_id,\n+                                rcvr_substs: ~[ty::t])\n+    -> ~[ty::t]\n+{\n+    /*!\n+    *\n+    * Creates a concatenated set of substitutions which includes\n+    * those from the impl and those from the method.  This are\n+    * some subtle complications here.  Statically, we have a list\n+    * of type parameters like `[T0, T1, T2, M1, M2, M3]` where\n+    * `Tn` are type parameters that appear on the receiver.  For\n+    * example, if the receiver is a method parameter `A` with a\n+    * bound like `trait<B,C,D>` then `Tn` would be `[B,C,D]`.\n+    *\n+    * The weird part is that the type `A` might now be bound to\n+    * any other type, such as `foo<X>`.  In that case, the vector\n+    * we want is: `[X, M1, M2, M3]`.  Therefore, what we do now is\n+    * to slice off the method type parameters and append them to\n+    * the type parameters from the type that the receiver is\n+    * mapped to. */\n+\n+    let ccx = bcx.ccx();\n+    let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n+    let node_substs = node_id_type_params(bcx, callee_id);\n+    let ty_substs\n+        = vec::append(rcvr_substs,\n+                      vec::tailn(node_substs,\n+                                 node_substs.len() - n_m_tps));\n+    debug!(\"n_m_tps=%?\", n_m_tps);\n+    debug!(\"rcvr_substs=%?\", rcvr_substs.map(|t| bcx.ty_to_str(t)));\n+    debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(t)));\n+    debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(t)));\n+\n+    return ty_substs;\n+}\n+\n+fn combine_impl_and_methods_origins(bcx: block,\n+                                    mth_did: ast::def_id,\n+                                    impl_did: ast::def_id,\n+                                    callee_id: ast::node_id,\n+                                    rcvr_origins: typeck::vtable_res)\n+    -> typeck::vtable_res\n+{\n+    /*!\n+     *\n+     * Similar to `combine_impl_and_methods_tps`, but for vtables.\n+     * This is much messier because of the flattened layout we are\n+     * currently using (for some reason that I fail to understand).\n+     * The proper fix is described in #3446.\n+     */\n+\n+\n+    // Find the bounds for the method, which are the tail of the\n+    // bounds found in the item type, as the item type combines the\n+    // rcvr + method bounds.\n+    let ccx = bcx.ccx(), tcx = bcx.tcx();\n+    let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n+    let {bounds: r_m_bounds, _} = ty::lookup_item_type(tcx, mth_did);\n+    let n_r_m_tps = r_m_bounds.len(); // rcvr + method tps\n+    let m_boundss = vec::view(*r_m_bounds, n_r_m_tps - n_m_tps, n_r_m_tps);\n+\n+    // Flatten out to find the number of vtables the method expects.\n+    let m_vtables = m_boundss.foldl(0, |sum, m_bounds| {\n+        m_bounds.foldl(sum, |sum, m_bound| {\n+            sum + match m_bound {\n+                ty::bound_copy | ty::bound_owned |\n+                ty::bound_send | ty::bound_const => 0,\n+                ty::bound_trait(_) => 1\n+            }\n+        })\n+    });\n+\n+    // Find the vtables we computed at type check time and monomorphize them\n+    let r_m_origins = match node_vtables(bcx, callee_id) {\n+        Some(vt) => vt,\n+        None => @~[]\n+    };\n+\n+    // Extract those that belong to method:\n+    let m_origins = vec::tailn(*r_m_origins, r_m_origins.len() - m_vtables);\n+\n+    // Combine rcvr + method to find the final result:\n+    @vec::append(*rcvr_origins, m_origins)\n }\n \n+\n fn trans_trait_callee(bcx: block,\n                       callee_id: ast::node_id,\n                       n_method: uint,\n@@ -367,54 +449,6 @@ fn trans_trait_callee_from_llval(bcx: block,\n     };\n }\n \n-fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n-    -> typeck::vtable_origin\n-{\n-    let mut vtable_off = n_bound, i = 0u;\n-    // Vtables are stored in a flat array, finding the right one is\n-    // somewhat awkward\n-    for vec::each(*ps.bounds) |bounds| {\n-        if i >= n_param { break; }\n-        for vec::each(*bounds) |bound| {\n-            match bound { ty::bound_trait(_) => vtable_off += 1u, _ => () }\n-        }\n-        i += 1u;\n-    }\n-    option::get(ps.vtables)[vtable_off]\n-}\n-\n-fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n-    -> typeck::vtable_res {\n-    @vec::map(*vts, |d| resolve_vtable_in_fn_ctxt(fcx, d))\n-}\n-\n-// Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n-// eliminate any vtable_params.\n-fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n-    -> typeck::vtable_origin {\n-    match vt {\n-      typeck::vtable_static(trait_id, tys, sub) => {\n-        let tys = match fcx.param_substs {\n-          Some(substs) => {\n-            vec::map(tys, |t| ty::subst_tps(fcx.ccx.tcx, substs.tys, t))\n-          }\n-          _ => tys\n-        };\n-        typeck::vtable_static(trait_id, tys,\n-                              resolve_vtables_in_fn_ctxt(fcx, sub))\n-      }\n-      typeck::vtable_param(n_param, n_bound) => {\n-        match fcx.param_substs {\n-          Some(substs) => {\n-            find_vtable_in_fn_ctxt(substs, n_param, n_bound)\n-          }\n-          _ => fail ~\"resolve_vtable_in_fn_ctxt: no substs\"\n-        }\n-      }\n-      _ => vt\n-    }\n-}\n-\n fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n     match origin {\n         typeck::vtable_static(impl_id, substs, sub_vtables) => {"}, {"sha": "4a322a74cec229ac98063f332377c4117a00698f", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=04f17634091587053ae7d7d35d2318406e8d7d0d", "patch": "@@ -156,6 +156,7 @@ export ck_block;\n export ck_box;\n export ck_uniq;\n export param_bound, param_bounds, bound_copy, bound_owned;\n+export param_bounds_to_str, param_bound_to_str;\n export bound_send, bound_trait;\n export param_bounds_to_kind;\n export default_arg_mode_for_ty;\n@@ -1338,6 +1339,20 @@ fn substs_to_str(cx: ctxt, substs: &substs) -> ~str {\n          substs.tps.map(|t| ty_to_str(cx, t)))\n }\n \n+fn param_bound_to_str(cx: ctxt, pb: &param_bound) -> ~str {\n+    match *pb {\n+        bound_copy => ~\"copy\",\n+        bound_owned => ~\"owned\",\n+        bound_send => ~\"send\",\n+        bound_const => ~\"const\",\n+        bound_trait(t) => ty_to_str(cx, t)\n+    }\n+}\n+\n+fn param_bounds_to_str(cx: ctxt, pbs: param_bounds) -> ~str {\n+    fmt!(\"%?\", pbs.map(|pb| param_bound_to_str(cx, &pb)))\n+}\n+\n fn subst(cx: ctxt,\n          substs: &substs,\n          typ: t) -> t {"}, {"sha": "4dfa17a9034246e283a854e307678147ace23227", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=04f17634091587053ae7d7d35d2318406e8d7d0d", "patch": "@@ -150,6 +150,29 @@ enum vtable_origin {\n     vtable_trait(ast::def_id, ~[ty::t]),\n }\n \n+impl vtable_origin {\n+    fn to_str(tcx: ty::ctxt) -> ~str {\n+        match self {\n+            vtable_static(def_id, ref tys, ref vtable_res) => {\n+                fmt!(\"vtable_static(%?:%s, %?, %?)\",\n+                     def_id, ty::item_path_str(tcx, def_id),\n+                     tys,\n+                     vtable_res.map(|o| o.to_str(tcx)))\n+            }\n+\n+            vtable_param(x, y) => {\n+                fmt!(\"vtable_param(%?, %?)\", x, y)\n+            }\n+\n+            vtable_trait(def_id, ref tys) => {\n+                fmt!(\"vtable_trait(%?:%s, %?)\",\n+                     def_id, ty::item_path_str(tcx, def_id),\n+                     tys.map(|t| ty_to_str(tcx, t)))\n+            }\n+        }\n+    }\n+}\n+\n type vtable_map = hashmap<ast::node_id, vtable_res>;\n \n // Stores information about provided methods, aka \"default methods\" in traits.\n@@ -182,6 +205,8 @@ fn write_substs_to_tcx(tcx: ty::ctxt,\n                        node_id: ast::node_id,\n                        +substs: ~[ty::t]) {\n     if substs.len() > 0u {\n+        debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n+               substs.map(|t| ty_to_str(tcx, t)));\n         tcx.node_type_substs.insert(node_id, substs);\n     }\n }"}, {"sha": "4d4409e499cf2882cab0394943749e41f0b34de2", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=04f17634091587053ae7d7d35d2318406e8d7d0d", "patch": "@@ -76,6 +76,7 @@ use rscope::{in_binding_rscope, region_scope, type_rscope,\n use syntax::ast::ty_i;\n use typeck::infer::{resolve_type, force_tvar};\n use result::{Result, Ok, Err};\n+use syntax::print::pprust;\n \n use std::map::{str_hash, uint_hash};\n \n@@ -587,9 +588,16 @@ impl @fn_ctxt: region_scope {\n \n impl @fn_ctxt {\n     fn tag() -> ~str { fmt!(\"%x\", ptr::addr_of(*self) as uint) }\n+\n+    fn expr_to_str(expr: @ast::expr) -> ~str {\n+        fmt!(\"expr(%?:%s)\", expr.id,\n+             pprust::expr_to_str(expr, self.tcx().sess.intr()))\n+    }\n+\n     fn block_region() -> ty::region {\n         ty::re_scope(self.region_lb)\n     }\n+\n     #[inline(always)]\n     fn write_ty(node_id: ast::node_id, ty: ty::t) {\n         debug!(\"write_ty(%d, %s) in fcx %s\",\n@@ -598,6 +606,10 @@ impl @fn_ctxt {\n     }\n     fn write_substs(node_id: ast::node_id, +substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n+            debug!(\"write_substs(%d, %s) in fcx %s\",\n+                   node_id,\n+                   ty::substs_to_str(self.tcx(), &substs),\n+                   self.tag());\n             self.inh.node_type_substs.insert(node_id, substs);\n         }\n     }"}, {"sha": "6feffc9c067bffc014cf69d95cd76f49cee3a0b7", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=04f17634091587053ae7d7d35d2318406e8d7d0d", "patch": "@@ -34,7 +34,16 @@ fn lookup_vtables(fcx: @fn_ctxt,\n                   bounds: @~[ty::param_bounds],\n                   substs: &ty::substs,\n                   allow_unsafe: bool,\n-                  is_early: bool) -> vtable_res {\n+                  is_early: bool) -> vtable_res\n+{\n+    debug!(\"lookup_vtables(expr=%?/%s, \\\n+            # bounds=%?, \\\n+            substs=%s\",\n+           expr.id, fcx.expr_to_str(expr),\n+           bounds.len(),\n+           ty::substs_to_str(fcx.tcx(), substs));\n+    let _i = indenter();\n+\n     let tcx = fcx.ccx.tcx;\n     let mut result = ~[], i = 0u;\n     for substs.tps.each |ty| {\n@@ -391,6 +400,12 @@ fn connect_trait_tps(fcx: @fn_ctxt, expr: @ast::expr, impl_tys: ~[ty::t],\n     }\n }\n \n+fn insert_vtables(ccx: @crate_ctxt, callee_id: ast::node_id, vtables: vtable_res) {\n+    debug!(\"insert_vtables(callee_id=%d, vtables=%?)\",\n+           callee_id, vtables.map(|v| v.to_str(ccx.tcx)));\n+    ccx.vtable_map.insert(callee_id, vtables);\n+}\n+\n fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id %? (early: %b): %s\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n@@ -424,7 +439,9 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                 let substs = fcx.node_ty_substs(callee_id);\n                 let vtbls = lookup_vtables(fcx, ex, bounds,\n                                            &substs, false, is_early);\n-                if !is_early { cx.vtable_map.insert(callee_id, vtbls); }\n+                if !is_early {\n+                    insert_vtables(cx, callee_id, vtbls);\n+                }\n             }\n           }\n           None => ()"}, {"sha": "08b2afc773e460af2ee3ddb6b729db0e6fa40fbd", "filename": "src/test/run-pass/monomorphized-callees-with-ty-params-3314.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f17634091587053ae7d7d35d2318406e8d7d0d/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs?ref=04f17634091587053ae7d7d35d2318406e8d7d0d", "patch": "@@ -0,0 +1,33 @@\n+use std;\n+\n+trait Serializer {\n+}\n+\n+trait Serializable {\n+    fn serialize<S: Serializer>(s: S);\n+}\n+\n+impl int: Serializable {\n+    fn serialize<S: Serializer>(_s: S) { }\n+}\n+\n+struct F<A> { a: A }\n+\n+impl<A: copy Serializable> F<A>: Serializable {\n+    fn serialize<S: Serializer>(s: S) {\n+        self.a.serialize(s);\n+    }\n+}\n+\n+impl io::Writer: Serializer {\n+}\n+\n+fn main() {\n+    do io::with_str_writer |wr| {\n+        let foo = F { a: 1 };\n+        foo.serialize(wr);\n+\n+        let bar = F { a: F {a: 1 } };\n+        bar.serialize(wr);\n+    };\n+}"}]}