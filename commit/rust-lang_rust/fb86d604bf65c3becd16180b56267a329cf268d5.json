{"sha": "fb86d604bf65c3becd16180b56267a329cf268d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiODZkNjA0YmY2NWMzYmVjZDE2MTgwYjU2MjY3YTMyOWNmMjY4ZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-27T19:47:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-27T19:47:56Z"}, "message": "Auto merge of #56384 - scalexm:chalk, r=nikomatsakis\n\nImplement the new-style trait solver\n\nFinal PR of what I believe to be a minimally working implementation of the new-style trait solver.\n\nThe new trait solver can be used by providing the `-Z chalk` command line flag. It is currently used everywhere in `rustc_typeck`, and for everything relying on `rustc::infer::canonical::query_response::enter_canonical_trait_query`.\n\nThe trait solver is invoked in rustc by using the `evaluate_goal` canonical query. This is not optimal because each call to `evaluate_goal` creates a new `chalk_engine::Forest`, hence rustc cannot use answers to intermediate goals produced by the root goal. We'll need to change that but I guess that's ok for now.\n\nSome next steps, I think, are:\n* handle region constraints: region constraints are computed but are completely ignored for now, I think we may need additional support from `chalk_engine` (as a side effect, types or trait references with outlive requirements cannot be proved well-formed)\n* deactivate eager normalization in the presence of `-Z chalk` in order to leverage the lazy normalization strategy of the new-style trait solver\n* add the remaining built-in impls (only `Sized` is supported currently)\n* transition the compiler to using generic goals instead of predicates that still refer to named type parameters etc\n\nI added a few very simple tests to check that the new solver has the right behavior, they won't be needed anymore once it is mature enough. Additionally it shows off that we get [implied bounds](https://github.com/rust-lang/rust/issues/44491) for free.\n\nr? @nikomatsakis", "tree": {"sha": "d7659486d99e8a64b3fd70fa00e8e92a46d02be8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7659486d99e8a64b3fd70fa00e8e92a46d02be8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb86d604bf65c3becd16180b56267a329cf268d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb86d604bf65c3becd16180b56267a329cf268d5", "html_url": "https://github.com/rust-lang/rust/commit/fb86d604bf65c3becd16180b56267a329cf268d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb86d604bf65c3becd16180b56267a329cf268d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc09637e21ddbde4d561d71a222f12a5f0d12022", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc09637e21ddbde4d561d71a222f12a5f0d12022", "html_url": "https://github.com/rust-lang/rust/commit/bc09637e21ddbde4d561d71a222f12a5f0d12022"}, {"sha": "993d213fdac8dfcecfa134087be385dc609e4f7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/993d213fdac8dfcecfa134087be385dc609e4f7b", "html_url": "https://github.com/rust-lang/rust/commit/993d213fdac8dfcecfa134087be385dc609e4f7b"}], "stats": {"total": 1604, "additions": 1311, "deletions": 293}, "files": [{"sha": "f19238140b8069008cbee0814140de7325be884a", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -273,7 +273,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.8.0\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"chalk-macros 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2067,7 +2067,7 @@ dependencies = [\n  \"backtrace 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"chalk-engine 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"chalk-engine 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n@@ -2640,7 +2640,7 @@ name = \"rustc_traits\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"chalk-engine 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"chalk-engine 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n@@ -3403,7 +3403,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cargo_metadata 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7d8dfe3adeb30f7938e6c1dd5327f29235d8ada3e898aeb08c343005ec2915a2\"\n \"checksum cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f159dfd43363c4d08055a07703eb7a3406b0dac4d0584d96965a3262db3c9d16\"\n \"checksum cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"082bb9b28e00d3c9d39cc03e64ce4cea0f1bb9b3fde493f0cbc008472d22bdf4\"\n-\"checksum chalk-engine 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6749eb72e7d4355d944a99f15fbaea701b978c18c5e184a025fcde942b0c9779\"\n+\"checksum chalk-engine 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"17ec698a6f053a23bfbe646d9f2fde4b02abc19125595270a99e6f44ae0bdd1a\"\n \"checksum chalk-macros 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"295635afd6853aa9f20baeb7f0204862440c0fe994c5a253d5f479dac41d047e\"\n \"checksum chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"45912881121cb26fad7c38c17ba7daa18764771836b34fab7d3fbd93ed633878\"\n \"checksum clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b957d88f4b6a63b9d70d5f454ac8011819c6efa7727858f458ab71c756ce2d3e\""}, {"sha": "8604efbc5742dd4ae0d0898b4976079d0d9169bc", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -30,7 +30,7 @@ syntax_pos = { path = \"../libsyntax_pos\" }\n backtrace = \"0.3.3\"\n parking_lot = \"0.6\"\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n-chalk-engine = { version = \"0.8.0\", default-features=false }\n+chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n "}, {"sha": "e5fd0aa3c9cbd8d8af9d26d7a854d1504048c0d4", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -648,6 +648,7 @@ define_dep_nodes!( <'tcx>\n     [] ImpliedOutlivesBounds(CanonicalTyGoal<'tcx>),\n     [] DropckOutlives(CanonicalTyGoal<'tcx>),\n     [] EvaluateObligation(CanonicalPredicateGoal<'tcx>),\n+    [] EvaluateGoal(traits::ChalkCanonicalGoal<'tcx>),\n     [] TypeOpAscribeUserType(CanonicalTypeOpAscribeUserTypeGoal<'tcx>),\n     [] TypeOpEq(CanonicalTypeOpEqGoal<'tcx>),\n     [] TypeOpSubtype(CanonicalTypeOpSubtypeGoal<'tcx>),"}, {"sha": "65b8f04e30a12f2c51a8955315a5c8973eebdfa5", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -885,7 +885,8 @@ for ty::steal::Steal<T>\n \n impl_stable_hash_for!(struct ty::ParamEnv<'tcx> {\n     caller_bounds,\n-    reveal\n+    reveal,\n+    def_id\n });\n \n impl_stable_hash_for!(enum traits::Reveal {\n@@ -1194,6 +1195,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n                 quantifier.hash_stable(hcx, hasher);\n                 goal.hash_stable(hcx, hasher);\n             },\n+            Subtype(a, b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n             CannotProve => { },\n         }\n     }\n@@ -1239,3 +1244,10 @@ impl_stable_hash_for!(\n         clauses,\n     }\n );\n+\n+impl_stable_hash_for!(\n+    impl<'tcx, G> for struct traits::InEnvironment<'tcx, G> {\n+        environment,\n+        goal,\n+    }\n+);"}, {"sha": "408cba42ae04b3d7779311e1ae2375a7291458a2", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -330,9 +330,13 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n             ty::Infer(ty::TyVar(vid)) => {\n+                debug!(\"canonical: type var found with vid {:?}\", vid);\n                 match self.infcx.unwrap().probe_ty_var(vid) {\n                     // `t` could be a float / int variable: canonicalize that instead\n-                    Ok(t) => self.fold_ty(t),\n+                    Ok(t) => {\n+                        debug!(\"(resolved to {:?})\", t);\n+                        self.fold_ty(t)\n+                    }\n \n                     // `TyVar(vid)` is unresolved, track its universe index in the canonicalized\n                     // result\n@@ -448,7 +452,12 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n \n         // Fast path: nothing that needs to be canonicalized.\n         if !value.has_type_flags(needs_canonical_flags) {\n-            let out_value = gcx.lift(value).unwrap();\n+            let out_value = gcx.lift(value).unwrap_or_else(|| {\n+                bug!(\n+                    \"failed to lift `{:?}` (nothing to canonicalize)\",\n+                    value\n+                )\n+            });\n             let canon_value = Canonical {\n                 max_universe: ty::UniverseIndex::ROOT,\n                 variables: List::empty(),"}, {"sha": "eaf72f5a687106d4377eee0a51e39a7ae7c6790b", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -420,9 +420,33 @@ BraceStructLiftImpl! {\n }\n \n impl<'tcx> CanonicalVarValues<'tcx> {\n-    fn len(&self) -> usize {\n+    pub fn len(&self) -> usize {\n         self.var_values.len()\n     }\n+\n+    /// Make an identity substitution from this one: each bound var\n+    /// is matched to the same bound var, preserving the original kinds.\n+    /// For example, if we have:\n+    /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n+    /// we'll return a substitution `subst` with:\n+    /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n+    pub fn make_identity<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        use ty::subst::UnpackedKind;\n+\n+        CanonicalVarValues {\n+            var_values: self.var_values.iter()\n+                .zip(0..)\n+                .map(|(kind, i)| match kind.unpack() {\n+                    UnpackedKind::Type(..) => tcx.mk_ty(\n+                        ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())\n+                    ).into(),\n+                    UnpackedKind::Lifetime(..) => tcx.mk_region(\n+                        ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i))\n+                    ).into(),\n+                })\n+                .collect()\n+        }\n+    }\n }\n \n impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {"}, {"sha": "7f113f07276d8f3ab46bec18fc782e7b678762d9", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::sync::Lrc;\n use std::fmt::Debug;\n use syntax_pos::DUMMY_SP;\n use traits::query::{Fallible, NoSolution};\n-use traits::{FulfillmentContext, TraitEngine};\n+use traits::TraitEngine;\n use traits::{Obligation, ObligationCause, PredicateObligation};\n use ty::fold::TypeFoldable;\n use ty::subst::{Kind, UnpackedKind};\n@@ -48,7 +48,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n     pub fn enter_canonical_trait_query<K, R>(\n         &'tcx mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'_, 'gcx, 'tcx>, &mut FulfillmentContext<'tcx>, K)\n+        operation: impl FnOnce(&InferCtxt<'_, 'gcx, 'tcx>, &mut dyn TraitEngine<'tcx>, K)\n             -> Fallible<R>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, R>>\n     where\n@@ -59,9 +59,13 @@ impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n             DUMMY_SP,\n             canonical_key,\n             |ref infcx, key, canonical_inference_vars| {\n-                let fulfill_cx = &mut FulfillmentContext::new();\n-                let value = operation(infcx, fulfill_cx, key)?;\n-                infcx.make_canonicalized_query_response(canonical_inference_vars, value, fulfill_cx)\n+                let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n+                let value = operation(infcx, &mut *fulfill_cx, key)?;\n+                infcx.make_canonicalized_query_response(\n+                    canonical_inference_vars,\n+                    value,\n+                    &mut *fulfill_cx\n+                )\n             },\n         )\n     }\n@@ -91,7 +95,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n-        fulfill_cx: &mut FulfillmentContext<'tcx>,\n+        fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, T>>\n     where\n         T: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n@@ -138,7 +142,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n-        fulfill_cx: &mut FulfillmentContext<'tcx>,\n+        fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> Result<QueryResponse<'tcx, T>, NoSolution>\n     where\n         T: Debug + TypeFoldable<'tcx> + Lift<'gcx>,"}, {"sha": "c000e3aa013f8538f8d725b0257f7515a9543a1a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -581,7 +581,7 @@ impl<'tcx, T> InferOk<'tcx, T> {\n     pub fn into_value_registering_obligations(\n         self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        fulfill_cx: &mut impl TraitEngine<'tcx>,\n+        fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> T {\n         let InferOk { value, obligations } = self;\n         for obligation in obligations {"}, {"sha": "f96c4e9014b36488b19b8b17234c011319656b4f", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -388,12 +388,17 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             computed_preds.extend(user_computed_preds.iter().cloned());\n             let normalized_preds =\n                 elaborate_predicates(tcx, computed_preds.clone().into_iter().collect());\n-            new_env = ty::ParamEnv::new(tcx.mk_predicates(normalized_preds), param_env.reveal);\n+            new_env = ty::ParamEnv::new(\n+                tcx.mk_predicates(normalized_preds),\n+                param_env.reveal,\n+                None\n+            );\n         }\n \n         let final_user_env = ty::ParamEnv::new(\n             tcx.mk_predicates(user_computed_preds.into_iter()),\n             user_env.reveal,\n+            None\n         );\n         debug!(\n             \"evaluate_nested_obligations(ty_did={:?}, trait_did={:?}): succeeded with '{:?}' \\"}, {"sha": "df4e08e0eb5f30f49e019d6f375910d07e33618e", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,165 @@\n+use traits::{\n+    Environment,\n+    InEnvironment,\n+    TraitEngine,\n+    ObligationCause,\n+    PredicateObligation,\n+    FulfillmentError,\n+    FulfillmentErrorCode,\n+    SelectionError,\n+};\n+use traits::query::NoSolution;\n+use infer::InferCtxt;\n+use infer::canonical::{Canonical, OriginalQueryValues};\n+use ty::{self, Ty};\n+use rustc_data_structures::fx::FxHashSet;\n+\n+pub type CanonicalGoal<'tcx> = Canonical<'tcx, InEnvironment<'tcx, ty::Predicate<'tcx>>>;\n+\n+pub struct FulfillmentContext<'tcx> {\n+    obligations: FxHashSet<InEnvironment<'tcx, PredicateObligation<'tcx>>>,\n+}\n+\n+impl FulfillmentContext<'tcx> {\n+    crate fn new() -> Self {\n+        FulfillmentContext {\n+            obligations: FxHashSet::default(),\n+        }\n+    }\n+}\n+\n+fn in_environment(\n+    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    obligation: PredicateObligation<'tcx>\n+) -> InEnvironment<'tcx, PredicateObligation<'tcx>> {\n+    assert!(!infcx.is_in_snapshot());\n+    let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n+\n+    let environment = match obligation.param_env.def_id {\n+        Some(def_id) => infcx.tcx.environment(def_id),\n+        None if obligation.param_env.caller_bounds.is_empty() => Environment {\n+            clauses: ty::List::empty(),\n+        },\n+        _ => bug!(\"non-empty `ParamEnv` with no def-id\"),\n+    };\n+\n+    InEnvironment {\n+        environment,\n+        goal: obligation,\n+    }\n+}\n+\n+impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n+    fn normalize_projection_type(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        _param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        _cause: ObligationCause<'tcx>,\n+    ) -> Ty<'tcx> {\n+        infcx.tcx.mk_ty(ty::Projection(projection_ty))\n+    }\n+\n+    fn register_predicate_obligation(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    ) {\n+        self.obligations.insert(in_environment(infcx, obligation));\n+    }\n+\n+    fn select_all_or_error(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        self.select_where_possible(infcx)?;\n+\n+        if self.obligations.is_empty() {\n+            Ok(())\n+        } else {\n+            let errors = self.obligations.iter()\n+                .map(|obligation| FulfillmentError {\n+                    obligation: obligation.goal.clone(),\n+                    code: FulfillmentErrorCode::CodeAmbiguity,\n+                })\n+                .collect();\n+            Err(errors)\n+        }\n+    }\n+\n+    fn select_where_possible(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        let mut errors = Vec::new();\n+        let mut next_round = FxHashSet::default();\n+        let mut making_progress;\n+\n+        loop {\n+            making_progress = false;\n+\n+            // We iterate over all obligations, and record if we are able\n+            // to unambiguously prove at least one obligation.\n+            for obligation in self.obligations.drain() {\n+                let mut orig_values = OriginalQueryValues::default();\n+                let canonical_goal = infcx.canonicalize_query(&InEnvironment {\n+                    environment: obligation.environment,\n+                    goal: obligation.goal.predicate,\n+                }, &mut orig_values);\n+\n+                match infcx.tcx.global_tcx().evaluate_goal(canonical_goal) {\n+                    Ok(response) => {\n+                        if response.is_proven() {\n+                            making_progress = true;\n+\n+                            match infcx.instantiate_query_response_and_region_obligations(\n+                                &obligation.goal.cause,\n+                                obligation.goal.param_env,\n+                                &orig_values,\n+                                &response\n+                            ) {\n+                                Ok(infer_ok) => next_round.extend(\n+                                    infer_ok.obligations\n+                                        .into_iter()\n+                                        .map(|obligation| in_environment(infcx, obligation))\n+                                ),\n+\n+                                Err(_err) => errors.push(FulfillmentError {\n+                                    obligation: obligation.goal,\n+                                    code: FulfillmentErrorCode::CodeSelectionError(\n+                                        SelectionError::Unimplemented\n+                                    ),\n+                                }),\n+                            }\n+                        } else {\n+                            // Ambiguous: retry at next round.\n+                            next_round.insert(obligation);\n+                        }\n+                    }\n+\n+                    Err(NoSolution) => errors.push(FulfillmentError {\n+                        obligation: obligation.goal,\n+                        code: FulfillmentErrorCode::CodeSelectionError(\n+                            SelectionError::Unimplemented\n+                        ),\n+                    })\n+                }\n+            }\n+            next_round = std::mem::replace(&mut self.obligations, next_round);\n+\n+            if !making_progress {\n+                break;\n+            }\n+        }\n+\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+\n+    fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n+        self.obligations.iter().map(|obligation| obligation.goal.clone()).collect()\n+    }\n+}"}, {"sha": "c759a9ddf2ce6427469116a67e1d5916ec316187", "filename": "src/librustc/traits/engine.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -1,8 +1,9 @@\n use infer::InferCtxt;\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, Ty, TyCtxt, ToPredicate};\n+use traits::Obligation;\n use hir::def_id::DefId;\n \n-use super::{FulfillmentContext, FulfillmentError};\n+use super::{ChalkFulfillmentContext, FulfillmentContext, FulfillmentError};\n use super::{ObligationCause, PredicateObligation};\n \n pub trait TraitEngine<'tcx>: 'tcx {\n@@ -14,14 +15,28 @@ pub trait TraitEngine<'tcx>: 'tcx {\n         cause: ObligationCause<'tcx>,\n     ) -> Ty<'tcx>;\n \n+    /// Requires that `ty` must implement the trait with `def_id` in\n+    /// the given environment. This trait must not have any type\n+    /// parameters (except for `Self`).\n     fn register_bound(\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         ty: Ty<'tcx>,\n         def_id: DefId,\n         cause: ObligationCause<'tcx>,\n-    );\n+    ) {\n+        let trait_ref = ty::TraitRef {\n+            def_id,\n+            substs: infcx.tcx.mk_substs_trait(ty, &[]),\n+        };\n+        self.register_predicate_obligation(infcx, Obligation {\n+            cause,\n+            recursion_depth: 0,\n+            param_env,\n+            predicate: trait_ref.to_predicate()\n+        });\n+    }\n \n     fn register_predicate_obligation(\n         &mut self,\n@@ -63,7 +78,11 @@ impl<T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n }\n \n impl dyn TraitEngine<'tcx> {\n-    pub fn new(_tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n-        Box::new(FulfillmentContext::new())\n+    pub fn new(tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n+        if tcx.sess.opts.debugging_opts.chalk {\n+            Box::new(ChalkFulfillmentContext::new())\n+        } else {\n+            Box::new(FulfillmentContext::new())\n+        }\n     }\n }"}, {"sha": "0e63ef666c75a02b2a9449a259982eaa8cba2ae9", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -796,12 +796,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     ty::Predicate::WellFormed(ty) => {\n-                        // WF predicates cannot themselves make\n-                        // errors. They can only block due to\n-                        // ambiguity; otherwise, they always\n-                        // degenerate into other obligations\n-                        // (which may fail).\n-                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        if !self.tcx.sess.opts.debugging_opts.chalk {\n+                            // WF predicates cannot themselves make\n+                            // errors. They can only block due to\n+                            // ambiguity; otherwise, they always\n+                            // degenerate into other obligations\n+                            // (which may fail).\n+                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        } else {\n+                            // FIXME: we'll need a better message which takes into account\n+                            // which bounds actually failed to hold.\n+                            self.tcx.sess.struct_span_err(\n+                                span,\n+                                &format!(\"the type `{}` is not well-formed (chalk)\", ty)\n+                            )\n+                        }\n                     }\n \n                     ty::Predicate::ConstEvaluatable(..) => {"}, {"sha": "556b97dc9bcf1b4f4bae89d213f161c47643fd9f", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -1,19 +1,18 @@\n use infer::InferCtxt;\n use mir::interpret::{GlobalId, ErrorHandled};\n-use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n+use ty::{self, Ty, TypeFoldable, ToPolyTraitRef};\n use ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n use rustc_data_structures::obligation_forest::{ProcessResult};\n use std::marker::PhantomData;\n-use hir::def_id::DefId;\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n use super::engine::{TraitEngine, TraitEngineExt};\n use super::{FulfillmentError, FulfillmentErrorCode};\n-use super::{ObligationCause, PredicateObligation, Obligation};\n+use super::{ObligationCause, PredicateObligation};\n use super::project;\n use super::select::SelectionContext;\n use super::{Unimplemented, ConstEvalFailure};\n@@ -173,28 +172,6 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         normalized_ty\n     }\n \n-    /// Requires that `ty` must implement the trait with `def_id` in\n-    /// the given environment. This trait must not have any type\n-    /// parameters (except for `Self`).\n-    fn register_bound<'a, 'gcx>(&mut self,\n-                      infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                      param_env: ty::ParamEnv<'tcx>,\n-                      ty: Ty<'tcx>,\n-                      def_id: DefId,\n-                      cause: ObligationCause<'tcx>)\n-    {\n-        let trait_ref = ty::TraitRef {\n-            def_id,\n-            substs: infcx.tcx.mk_substs_trait(ty, &[]),\n-        };\n-        self.register_predicate_obligation(infcx, Obligation {\n-            cause,\n-            recursion_depth: 0,\n-            param_env,\n-            predicate: trait_ref.to_predicate()\n-        });\n-    }\n-\n     fn register_predicate_obligation<'a, 'gcx>(&mut self,\n                                      infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                      obligation: PredicateObligation<'tcx>)\n@@ -213,9 +190,10 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         });\n     }\n \n-    fn select_all_or_error<'a, 'gcx>(&mut self,\n-                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                                     -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    fn select_all_or_error<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>\n+    ) -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         self.select_where_possible(infcx)?;\n "}, {"sha": "49bd04782b28e66a8fefdc66b00e85f2abe74d70", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -4,6 +4,7 @@\n \n #[allow(dead_code)]\n pub mod auto_trait;\n+mod chalk_fulfill;\n mod coherence;\n pub mod error_reporting;\n mod engine;\n@@ -61,6 +62,11 @@ pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_\n pub use self::util::{supertraits, supertrait_def_ids, transitive_bounds,\n                      Supertraits, SupertraitDefIds};\n \n+pub use self::chalk_fulfill::{\n+    CanonicalGoal as ChalkCanonicalGoal,\n+    FulfillmentContext as ChalkFulfillmentContext\n+};\n+\n pub use self::ObligationCauseCode::*;\n pub use self::FulfillmentErrorCode::*;\n pub use self::SelectionError::*;\n@@ -318,6 +324,7 @@ pub enum GoalKind<'tcx> {\n     Not(Goal<'tcx>),\n     DomainGoal(DomainGoal<'tcx>),\n     Quantified(QuantifierKind, ty::Binder<Goal<'tcx>>),\n+    Subtype(Ty<'tcx>, Ty<'tcx>),\n     CannotProve,\n }\n \n@@ -340,9 +347,9 @@ impl<'tcx> DomainGoal<'tcx> {\n }\n \n impl<'tcx> GoalKind<'tcx> {\n-    pub fn from_poly_domain_goal<'a>(\n+    pub fn from_poly_domain_goal<'a, 'gcx>(\n         domain_goal: PolyDomainGoal<'tcx>,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     ) -> GoalKind<'tcx> {\n         match domain_goal.no_bound_vars() {\n             Some(p) => p.into_goal(),\n@@ -804,8 +811,11 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\",\n            predicates);\n \n-    let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n-                                           unnormalized_env.reveal);\n+    let elaborated_env = ty::ParamEnv::new(\n+        tcx.intern_predicates(&predicates),\n+        unnormalized_env.reveal,\n+        unnormalized_env.def_id\n+    );\n \n     // HACK: we are trying to normalize the param-env inside *itself*. The problem is that\n     // normalization expects its param-env to be already normalized, which means we have\n@@ -852,8 +862,11 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // predicates here anyway. Keeping them here anyway because it seems safer.\n     let outlives_env: Vec<_> =\n         non_outlives_predicates.iter().chain(&outlives_predicates).cloned().collect();\n-    let outlives_env = ty::ParamEnv::new(tcx.intern_predicates(&outlives_env),\n-                                         unnormalized_env.reveal);\n+    let outlives_env = ty::ParamEnv::new(\n+        tcx.intern_predicates(&outlives_env),\n+        unnormalized_env.reveal,\n+        None\n+    );\n     let outlives_predicates =\n         match do_normalize_predicates(tcx, region_context, cause,\n                                       outlives_env, outlives_predicates) {\n@@ -869,7 +882,11 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut predicates = non_outlives_predicates;\n     predicates.extend(outlives_predicates);\n     debug!(\"normalize_param_env_or_error: final predicates={:?}\", predicates);\n-    ty::ParamEnv::new(tcx.intern_predicates(&predicates), unnormalized_env.reveal)\n+    ty::ParamEnv::new(\n+        tcx.intern_predicates(&predicates),\n+        unnormalized_env.reveal,\n+        unnormalized_env.def_id\n+    )\n }\n \n pub fn fully_normalize<'a, 'gcx, 'tcx, T>(\n@@ -1164,14 +1181,26 @@ where\n     ) -> bool;\n }\n \n-pub trait ExClauseLift<'tcx>\n+pub trait ChalkContextLift<'tcx>\n where\n     Self: chalk_engine::context::Context + Clone,\n {\n     type LiftedExClause: Debug + 'tcx;\n+    type LiftedDelayedLiteral: Debug + 'tcx;\n+    type LiftedLiteral: Debug + 'tcx;\n \n     fn lift_ex_clause_to_tcx<'a, 'gcx>(\n         ex_clause: &chalk_engine::ExClause<Self>,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     ) -> Option<Self::LiftedExClause>;\n+\n+    fn lift_delayed_literal_to_tcx<'a, 'gcx>(\n+        ex_clause: &chalk_engine::DelayedLiteral<Self>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Option<Self::LiftedDelayedLiteral>;\n+\n+    fn lift_literal_to_tcx<'a, 'gcx>(\n+        ex_clause: &chalk_engine::Literal<Self>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Option<Self::LiftedLiteral>;\n }"}, {"sha": "bd347764cc6810f6bce7914c6038c682c78ad33d", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -3243,11 +3243,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             trait_ref,\n         )?);\n \n-        obligations.push(Obligation::new(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n-        ));\n+        // FIXME: chalk\n+        if !self.tcx().sess.opts.debugging_opts.chalk {\n+            obligations.push(Obligation::new(\n+                obligation.cause.clone(),\n+                obligation.param_env,\n+                ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n+            ));\n+        }\n \n         Ok(VtableClosureData {\n             closure_def_id,"}, {"sha": "ae2b83e105773ac3c31b8df5cc83c3e842edf339", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -395,6 +395,7 @@ impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n \n                 Ok(())\n             }\n+            Subtype(a, b) => write!(fmt, \"{} <: {}\", a, b),\n             CannotProve => write!(fmt, \"CannotProve\"),\n         }\n     }\n@@ -668,6 +669,7 @@ EnumLiftImpl! {\n         (traits::GoalKind::Not)(goal),\n         (traits::GoalKind::DomainGoal)(domain_goal),\n         (traits::GoalKind::Quantified)(kind, goal),\n+        (traits::GoalKind::Subtype)(a, b),\n         (traits::GoalKind::CannotProve),\n     }\n }\n@@ -700,12 +702,36 @@ impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n where\n     C: chalk_engine::context::Context + Clone,\n-    C: traits::ExClauseLift<'tcx>,\n+    C: traits::ChalkContextLift<'tcx>,\n {\n     type Lifted = C::LiftedExClause;\n \n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ExClauseLift>::lift_ex_clause_to_tcx(self, tcx)\n+        <C as traits::ChalkContextLift>::lift_ex_clause_to_tcx(self, tcx)\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::DelayedLiteral<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ChalkContextLift<'tcx>,\n+{\n+    type Lifted = C::LiftedDelayedLiteral;\n+\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ChalkContextLift>::lift_delayed_literal_to_tcx(self, tcx)\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::Literal<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ChalkContextLift<'tcx>,\n+{\n+    type Lifted = C::LiftedLiteral;\n+\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ChalkContextLift>::lift_literal_to_tcx(self, tcx)\n     }\n }\n \n@@ -840,6 +866,7 @@ EnumTypeFoldableImpl! {\n         (traits::GoalKind::Not)(goal),\n         (traits::GoalKind::DomainGoal)(domain_goal),\n         (traits::GoalKind::Quantified)(qkind, goal),\n+        (traits::GoalKind::Subtype)(a, b),\n         (traits::GoalKind::CannotProve),\n     }\n }"}, {"sha": "289ef4da9922766cceeb3e92bd3ec7b392ea0468", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -1714,6 +1714,10 @@ impl<'a, 'tcx> Lift<'tcx> for &'a List<Goal<'a>> {\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'tcx>,\n     ) -> Option<&'tcx List<Goal<'tcx>>> {\n+        if self.is_empty() {\n+            return Some(List::empty());\n+        }\n+\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n@@ -1732,6 +1736,10 @@ impl<'a, 'tcx> Lift<'tcx> for &'a List<Clause<'a>> {\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'tcx>,\n     ) -> Option<&'tcx List<Clause<'tcx>>> {\n+        if self.is_empty() {\n+            return Some(List::empty());\n+        }\n+\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }"}, {"sha": "0a72f733b51e5e8afe3d009ee98905b6cfc0f627", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -533,18 +533,25 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n               G: FnMut(ty::BoundTy) -> ty::Ty<'tcx>,\n               T: TypeFoldable<'tcx>\n     {\n-        let mut map = BTreeMap::new();\n+        use rustc_data_structures::fx::FxHashMap;\n+\n+        let mut region_map = BTreeMap::new();\n+        let mut type_map = FxHashMap::default();\n \n         if !value.has_escaping_bound_vars() {\n-            (value.clone(), map)\n+            (value.clone(), region_map)\n         } else {\n             let mut real_fld_r = |br| {\n-                *map.entry(br).or_insert_with(|| fld_r(br))\n+                *region_map.entry(br).or_insert_with(|| fld_r(br))\n+            };\n+\n+            let mut real_fld_t = |bound_ty| {\n+                *type_map.entry(bound_ty).or_insert_with(|| fld_t(bound_ty))\n             };\n \n-            let mut replacer = BoundVarReplacer::new(self, &mut real_fld_r, &mut fld_t);\n+            let mut replacer = BoundVarReplacer::new(self, &mut real_fld_r, &mut real_fld_t);\n             let result = value.fold_with(&mut replacer);\n-            (result, map)\n+            (result, region_map)\n         }\n     }\n "}, {"sha": "fd8a7db1b47604aab061e7433a5d992a38a3e41b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -1617,6 +1617,11 @@ pub struct ParamEnv<'tcx> {\n     /// want `Reveal::All` -- note that this is always paired with an\n     /// empty environment. To get that, use `ParamEnv::reveal()`.\n     pub reveal: traits::Reveal,\n+\n+    /// If this `ParamEnv` comes from a call to `tcx.param_env(def_id)`,\n+    /// register that `def_id` (useful for transitioning to the chalk trait\n+    /// solver).\n+    pub def_id: Option<DefId>,\n }\n \n impl<'tcx> ParamEnv<'tcx> {\n@@ -1626,7 +1631,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// type-checking.\n     #[inline]\n     pub fn empty() -> Self {\n-        Self::new(List::empty(), Reveal::UserFacing)\n+        Self::new(List::empty(), Reveal::UserFacing, None)\n     }\n \n     /// Construct a trait environment with no where clauses in scope\n@@ -1638,15 +1643,17 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// or invoke `param_env.with_reveal_all()`.\n     #[inline]\n     pub fn reveal_all() -> Self {\n-        Self::new(List::empty(), Reveal::All)\n+        Self::new(List::empty(), Reveal::All, None)\n     }\n \n     /// Construct a trait environment with the given set of predicates.\n     #[inline]\n-    pub fn new(caller_bounds: &'tcx List<ty::Predicate<'tcx>>,\n-               reveal: Reveal)\n-               -> Self {\n-        ty::ParamEnv { caller_bounds, reveal }\n+    pub fn new(\n+        caller_bounds: &'tcx List<ty::Predicate<'tcx>>,\n+        reveal: Reveal,\n+        def_id: Option<DefId>\n+    ) -> Self {\n+        ty::ParamEnv { caller_bounds, reveal, def_id }\n     }\n \n     /// Returns a new parameter environment with the same clauses, but\n@@ -3148,8 +3155,11 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // are any errors at that point, so after type checking you can be\n     // sure that this will succeed without errors anyway.\n \n-    let unnormalized_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n-                                             traits::Reveal::UserFacing);\n+    let unnormalized_env = ty::ParamEnv::new(\n+        tcx.intern_predicates(&predicates),\n+        traits::Reveal::UserFacing,\n+        if tcx.sess.opts.debugging_opts.chalk { Some(def_id) } else { None }\n+    );\n \n     let body_id = tcx.hir().as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n         tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.node_id)"}, {"sha": "3464464aa229c9cc77dd5f0b47c26318dffd763b", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -106,6 +106,15 @@ impl<'tcx> QueryDescription<'tcx> for queries::evaluate_obligation<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::evaluate_goal<'tcx> {\n+    fn describe(\n+        _tcx: TyCtxt<'_, '_, '_>,\n+        goal: traits::ChalkCanonicalGoal<'tcx>\n+    ) -> Cow<'static, str> {\n+        format!(\"evaluating trait selection obligation `{}`\", goal.value.goal).into()\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::type_op_ascribe_user_type<'tcx> {\n     fn describe(\n         _tcx: TyCtxt<'_, '_, '_>,"}, {"sha": "cbdec2ef2ba81cf8e0be9cacc0ab3e24b331e4a3", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -593,6 +593,13 @@ define_queries! { <'tcx>\n             CanonicalPredicateGoal<'tcx>\n         ) -> Result<traits::EvaluationResult, traits::OverflowError>,\n \n+        [] fn evaluate_goal: EvaluateGoal(\n+            traits::ChalkCanonicalGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution\n+        >,\n+\n         /// Do not call this query directly: part of the `Eq` type-op\n         [] fn type_op_ascribe_user_type: TypeOpAscribeUserType(\n             CanonicalTypeOpAscribeUserTypeGoal<'tcx>\n@@ -684,7 +691,7 @@ define_queries! { <'tcx>\n         ) -> Clauses<'tcx>,\n \n         // Get the chalk-style environment of the given item.\n-        [] fn environment: Environment(DefId) -> ty::Binder<traits::Environment<'tcx>>,\n+        [] fn environment: Environment(DefId) -> traits::Environment<'tcx>,\n     },\n \n     Linking {"}, {"sha": "99da77491ca54866aa8c4f8875beb81fd72e5224", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -1103,6 +1103,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ImpliedOutlivesBounds |\n         DepKind::DropckOutlives |\n         DepKind::EvaluateObligation |\n+        DepKind::EvaluateGoal |\n         DepKind::TypeOpAscribeUserType |\n         DepKind::TypeOpEq |\n         DepKind::TypeOpSubtype |"}, {"sha": "4755adc4cd10d6d70c915bd2176a093b9368ba0d", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -276,6 +276,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n             ty::ParamEnv {\n                 reveal: self.reveal,\n                 caller_bounds,\n+                def_id: self.def_id,\n             }\n         })\n     }\n@@ -589,7 +590,7 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n }\n \n BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> { reveal, caller_bounds }\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> { reveal, caller_bounds, def_id }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {"}, {"sha": "bf946d39806ecd1991791856a4fc0a91f7387907", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -17,5 +17,5 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-chalk-engine = { version = \"0.8.0\", default-features=false }\n+chalk-engine = { version = \"0.9.0\", default-features=false }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "303920b5842c969636ad962d4da249299f3e3b02", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 176, "deletions": 37, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -2,14 +2,15 @@ mod program_clauses;\n mod resolvent_ops;\n mod unify;\n \n-use chalk_engine::fallible::{Fallible, NoSolution};\n+use chalk_engine::fallible::Fallible;\n use chalk_engine::{\n     context,\n     hh::HhGoal,\n     DelayedLiteral,\n     Literal,\n-    ExClause\n+    ExClause,\n };\n+use chalk_engine::forest::Forest;\n use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n use rustc::infer::canonical::{\n     Canonical,\n@@ -19,19 +20,23 @@ use rustc::infer::canonical::{\n     Certainty,\n };\n use rustc::traits::{\n+    self,\n     DomainGoal,\n     ExClauseFold,\n-    ExClauseLift,\n+    ChalkContextLift,\n     Goal,\n     GoalKind,\n     Clause,\n     QuantifierKind,\n     Environment,\n     InEnvironment,\n+    ChalkCanonicalGoal,\n };\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc::ty::query::Providers;\n use rustc::ty::subst::{Kind, UnpackedKind};\n+use rustc_data_structures::sync::Lrc;\n use syntax_pos::DUMMY_SP;\n \n use std::fmt::{self, Debug};\n@@ -111,6 +116,8 @@ impl context::Context for ChalkArenas<'tcx> {\n \n     type UnificationResult = UnificationResult<'tcx>;\n \n+    type Variance = ty::Variance;\n+\n     fn goal_in_environment(\n         env: &Environment<'tcx>,\n         goal: Goal<'tcx>,\n@@ -122,45 +129,77 @@ impl context::Context for ChalkArenas<'tcx> {\n impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     fn make_solution(\n         &self,\n-        _root_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n+        root_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n         mut simplified_answers: impl context::AnswerStream<ChalkArenas<'gcx>>,\n     ) -> Option<Canonical<'gcx, QueryResponse<'gcx, ()>>> {\n         use chalk_engine::SimplifiedAnswer;\n \n+        debug!(\"make_solution(root_goal = {:?})\", root_goal);\n+\n         if simplified_answers.peek_answer().is_none() {\n             return None;\n         }\n \n-        let SimplifiedAnswer { subst, ambiguous } = simplified_answers\n+        let SimplifiedAnswer { subst: constrained_subst, ambiguous } = simplified_answers\n             .next_answer()\n             .unwrap();\n \n+        debug!(\"make_solution: ambiguous flag = {}\", ambiguous);\n+\n         let ambiguous = simplified_answers.peek_answer().is_some() || ambiguous;\n \n-        Some(subst.unchecked_map(|subst| {\n-            QueryResponse {\n-                var_values: subst.subst,\n-                region_constraints: subst.constraints\n-                    .into_iter()\n-                    .map(|c| ty::Binder::bind(c))\n-                    .collect(),\n-                certainty: match ambiguous {\n-                    true => Certainty::Ambiguous,\n-                    false => Certainty::Proven,\n-                },\n+        let solution = constrained_subst.unchecked_map(|cs| match ambiguous {\n+            true => QueryResponse {\n+                var_values: cs.subst.make_identity(self.tcx),\n+                region_constraints: Vec::new(),\n+                certainty: Certainty::Ambiguous,\n                 value: (),\n-            }\n-        }))\n+            },\n+\n+            false => QueryResponse {\n+                var_values: cs.subst,\n+                region_constraints: Vec::new(),\n+\n+                // FIXME: restore this later once we get better at handling regions\n+                // region_constraints: cs.constraints\n+                //     .into_iter()\n+                //     .map(|c| ty::Binder::bind(c))\n+                //     .collect(),\n+                certainty: Certainty::Proven,\n+                value: (),\n+            },\n+        });\n+\n+        debug!(\"make_solution: solution = {:?}\", solution);\n+\n+        Some(solution)\n     }\n }\n \n impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n-    /// True if this is a coinductive goal -- e.g., proving an auto trait.\n+    /// True if this is a coinductive goal: basically proving that an auto trait\n+    /// is implemented or proving that a trait reference is well-formed.\n     fn is_coinductive(\n         &self,\n-        _goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>\n+        goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>\n     ) -> bool {\n-        unimplemented!()\n+        use rustc::traits::{WellFormed, WhereClause};\n+\n+        let mut goal = goal.value.goal;\n+        loop {\n+            match goal {\n+                GoalKind::DomainGoal(domain_goal) => match domain_goal {\n+                    DomainGoal::WellFormed(WellFormed::Trait(..)) => return true,\n+                    DomainGoal::Holds(WhereClause::Implemented(trait_predicate)) => {\n+                        return self.tcx.trait_is_auto(trait_predicate.def_id());\n+                    }\n+                    _ => return false,\n+                }\n+\n+                GoalKind::Quantified(_, bound_goal) => goal = *bound_goal.skip_binder(),\n+                _ => return false,\n+            }\n+        }\n     }\n \n     /// Create an inference table for processing a new goal and instantiate that goal\n@@ -295,6 +334,11 @@ impl context::InferenceTable<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n             GoalKind::DomainGoal(d) => HhGoal::DomainGoal(d),\n             GoalKind::Quantified(QuantifierKind::Universal, binder) => HhGoal::ForAll(binder),\n             GoalKind::Quantified(QuantifierKind::Existential, binder) => HhGoal::Exists(binder),\n+            GoalKind::Subtype(a, b) => HhGoal::Unify(\n+                ty::Variance::Covariant,\n+                a.into(),\n+                b.into()\n+            ),\n             GoalKind::CannotProve => HhGoal::CannotProve,\n         }\n     }\n@@ -317,16 +361,16 @@ impl context::TruncateOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n {\n     fn truncate_goal(\n         &mut self,\n-        subgoal: &InEnvironment<'tcx, Goal<'tcx>>,\n+        _subgoal: &InEnvironment<'tcx, Goal<'tcx>>,\n     ) -> Option<InEnvironment<'tcx, Goal<'tcx>>> {\n-        Some(*subgoal) // FIXME we should truncate at some point!\n+        None // FIXME we should truncate at some point!\n     }\n \n     fn truncate_answer(\n         &mut self,\n-        subst: &CanonicalVarValues<'tcx>,\n+        _subst: &CanonicalVarValues<'tcx>,\n     ) -> Option<CanonicalVarValues<'tcx>> {\n-        Some(subst.clone()) // FIXME we should truncate at some point!\n+        None // FIXME we should truncate at some point!\n     }\n }\n \n@@ -407,11 +451,13 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     fn unify_parameters(\n         &mut self,\n         environment: &Environment<'tcx>,\n+        variance: ty::Variance,\n         a: &Kind<'tcx>,\n         b: &Kind<'tcx>,\n     ) -> Fallible<UnificationResult<'tcx>> {\n         self.infcx.commit_if_ok(|_| {\n-            unify(self.infcx, *environment, a, b).map_err(|_| NoSolution)\n+            unify(self.infcx, *environment, variance, a, b)\n+                .map_err(|_| chalk_engine::fallible::NoSolution)\n         })\n     }\n \n@@ -424,9 +470,12 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n \n     fn lift_delayed_literal(\n         &self,\n-        _value: DelayedLiteral<ChalkArenas<'tcx>>,\n+        value: DelayedLiteral<ChalkArenas<'tcx>>,\n     ) -> DelayedLiteral<ChalkArenas<'gcx>> {\n-        panic!(\"lift\")\n+        match self.infcx.tcx.lift_to_global(&value) {\n+            Some(literal) => literal,\n+            None => bug!(\"cannot lift {:?}\", value),\n+        }\n     }\n \n     fn into_ex_clause(\n@@ -442,7 +491,10 @@ crate fn into_ex_clause(result: UnificationResult<'tcx>, ex_clause: &mut ChalkEx\n     ex_clause.subgoals.extend(\n         result.goals.into_iter().map(Literal::Positive)\n     );\n-    ex_clause.constraints.extend(result.constraints);\n+\n+    // FIXME: restore this later once we get better at handling regions\n+    let _ = result.constraints.len(); // trick `-D dead-code`\n+    // ex_clause.constraints.extend(result.constraints);\n }\n \n type ChalkHhGoal<'tcx> = HhGoal<ChalkArenas<'tcx>>;\n@@ -461,14 +513,45 @@ impl Debug for ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl ExClauseLift<'gcx> for ChalkArenas<'a> {\n-    type LiftedExClause = ChalkExClause<'gcx>;\n+impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n+    type LiftedExClause = ChalkExClause<'tcx>;\n+    type LiftedDelayedLiteral = DelayedLiteral<ChalkArenas<'tcx>>;\n+    type LiftedLiteral = Literal<ChalkArenas<'tcx>>;\n \n     fn lift_ex_clause_to_tcx(\n-        _ex_clause: &ChalkExClause<'a>,\n-        _tcx: TyCtxt<'_, '_, 'tcx>,\n+        ex_clause: &ChalkExClause<'a>,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>\n     ) -> Option<Self::LiftedExClause> {\n-        panic!()\n+        Some(ChalkExClause {\n+            subst: tcx.lift(&ex_clause.subst)?,\n+            delayed_literals: tcx.lift(&ex_clause.delayed_literals)?,\n+            constraints: tcx.lift(&ex_clause.constraints)?,\n+            subgoals: tcx.lift(&ex_clause.subgoals)?,\n+        })\n+    }\n+\n+    fn lift_delayed_literal_to_tcx(\n+        literal: &DelayedLiteral<ChalkArenas<'a>>,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>\n+    ) -> Option<Self::LiftedDelayedLiteral> {\n+        Some(match literal {\n+            DelayedLiteral::CannotProve(()) => DelayedLiteral::CannotProve(()),\n+            DelayedLiteral::Negative(index) => DelayedLiteral::Negative(*index),\n+            DelayedLiteral::Positive(index, subst) => DelayedLiteral::Positive(\n+                *index,\n+                tcx.lift(subst)?\n+            )\n+        })\n+    }\n+\n+    fn lift_literal_to_tcx(\n+        literal: &Literal<ChalkArenas<'a>>,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    ) -> Option<Self::LiftedLiteral> {\n+        Some(match literal {\n+            Literal::Negative(goal) => Literal::Negative(tcx.lift(goal)?),\n+            Literal::Positive(goal) =>  Literal::Positive(tcx.lift(goal)?),\n+        })\n     }\n }\n \n@@ -496,9 +579,9 @@ impl ExClauseFold<'tcx> for ChalkArenas<'tcx> {\n             subgoals,\n         } = ex_clause;\n         subst.visit_with(visitor)\n-            && delayed_literals.visit_with(visitor)\n-            && constraints.visit_with(visitor)\n-            && subgoals.visit_with(visitor)\n+            || delayed_literals.visit_with(visitor)\n+            || constraints.visit_with(visitor)\n+            || subgoals.visit_with(visitor)\n     }\n }\n \n@@ -574,3 +657,59 @@ impl<'tcx, 'gcx: 'tcx, T> Upcast<'tcx, 'gcx> for Canonical<'gcx, T>\n         }\n     }\n }\n+\n+crate fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        evaluate_goal,\n+        ..*p\n+    };\n+}\n+\n+crate fn evaluate_goal<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    goal: ChalkCanonicalGoal<'tcx>\n+) -> Result<\n+    Lrc<Canonical<'tcx, QueryResponse<'tcx, ()>>>,\n+    traits::query::NoSolution\n+> {\n+    use crate::lowering::Lower;\n+    use rustc::traits::WellFormed;\n+\n+    let goal = goal.unchecked_map(|goal| InEnvironment {\n+        environment: goal.environment,\n+        goal: match goal.goal {\n+            ty::Predicate::WellFormed(ty) => tcx.mk_goal(\n+                GoalKind::DomainGoal(DomainGoal::WellFormed(WellFormed::Ty(ty)))\n+            ),\n+\n+            ty::Predicate::Subtype(predicate) => tcx.mk_goal(\n+                GoalKind::Quantified(\n+                    QuantifierKind::Universal,\n+                    predicate.map_bound(|pred| tcx.mk_goal(GoalKind::Subtype(pred.a, pred.b)))\n+                )\n+            ),\n+\n+            other => tcx.mk_goal(\n+                GoalKind::from_poly_domain_goal(other.lower(), tcx)\n+            ),\n+        },\n+    });\n+\n+\n+    debug!(\"evaluate_goal(goal = {:?})\", goal);\n+\n+    let context = ChalkContext {\n+        _arenas: ChalkArenas {\n+            _phantom: PhantomData,\n+        },\n+        tcx,\n+    };\n+\n+    let mut forest = Forest::new(context);\n+    let solution = forest.solve(&goal);\n+\n+    debug!(\"evaluate_goal: solution = {:?}\", solution);\n+\n+    solution.map(|ok| Ok(Lrc::new(ok)))\n+        .unwrap_or(Err(traits::query::NoSolution))\n+}"}, {"sha": "98a2f4bf0a15b119da1f1c20aea08170febd31a3", "filename": "src/librustc_traits/chalk_context/program_clauses.rs", "status": "modified", "additions": 231, "deletions": 80, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -10,11 +10,13 @@ use rustc::traits::{\n     Environment,\n };\n use rustc::ty;\n+use rustc::ty::subst::{Substs, Subst};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc_target::spec::abi;\n use super::ChalkInferenceContext;\n use crate::lowering::Lower;\n+use crate::generic_types;\n use std::iter;\n \n fn assemble_clauses_from_impls<'tcx>(\n@@ -47,50 +49,152 @@ fn assemble_clauses_from_assoc_ty_values<'tcx>(\n     });\n }\n \n-fn program_clauses_for_raw_ptr<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n-    let ty = ty::Bound(\n-        ty::INNERMOST,\n-        ty::BoundVar::from_u32(0).into()\n-    );\n-    let ty = tcx.mk_ty(ty);\n+fn assemble_builtin_sized_impls<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    sized_def_id: DefId,\n+    ty: ty::Ty<'tcx>,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[ty::Ty<'tcx>]| {\n+        let clause = ProgramClause {\n+            goal: ty::TraitPredicate {\n+                trait_ref: ty::TraitRef {\n+                    def_id: sized_def_id,\n+                    substs: tcx.mk_substs_trait(ty, &[]),\n+                },\n+            }.lower(),\n+            hypotheses: tcx.mk_goals(\n+                nested.iter()\n+                    .cloned()\n+                    .map(|nested_ty| ty::TraitRef {\n+                        def_id: sized_def_id,\n+                        substs: tcx.mk_substs_trait(nested_ty, &[]),\n+                    })\n+                    .map(|trait_ref| ty::TraitPredicate { trait_ref })\n+                    .map(|pred| GoalKind::DomainGoal(pred.lower()))\n+                    .map(|goal_kind| tcx.mk_goal(goal_kind))\n+            ),\n+            category: ProgramClauseCategory::Other,\n+        };\n+        // Bind innermost bound vars that may exist in `ty` and `nested`.\n+        clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n+    };\n \n-    let ptr_ty = tcx.mk_ptr(ty::TypeAndMut {\n-        ty,\n-        mutbl: hir::Mutability::MutImmutable,\n-    });\n+    match &ty.sty {\n+        // Non parametric primitive types.\n+        ty::Bool |\n+        ty::Char |\n+        ty::Int(..) |\n+        ty::Uint(..) |\n+        ty::Float(..) |\n+        ty::Error |\n+        ty::Never => push_builtin_impl(ty, &[]),\n+\n+        // These ones are always `Sized`.\n+        &ty::Array(_, length) => {\n+            push_builtin_impl(tcx.mk_ty(ty::Array(generic_types::bound(tcx, 0), length)), &[]);\n+        }\n+        ty::RawPtr(ptr) => {\n+            push_builtin_impl(generic_types::raw_ptr(tcx, ptr.mutbl), &[]);\n+        }\n+        &ty::Ref(_, _, mutbl) => {\n+            push_builtin_impl(generic_types::ref_ty(tcx, mutbl), &[]);\n+        }\n+        ty::FnPtr(fn_ptr) => {\n+            let fn_ptr = fn_ptr.skip_binder();\n+            let fn_ptr = generic_types::fn_ptr(\n+                tcx,\n+                fn_ptr.inputs_and_output.len(),\n+                fn_ptr.variadic,\n+                fn_ptr.unsafety,\n+                fn_ptr.abi\n+            );\n+            push_builtin_impl(fn_ptr, &[]);\n+        }\n+        &ty::FnDef(def_id, ..) => {\n+            push_builtin_impl(generic_types::fn_def(tcx, def_id), &[]);\n+        }\n+        &ty::Closure(def_id, ..) => {\n+            push_builtin_impl(generic_types::closure(tcx, def_id), &[]);\n+        }\n+        &ty::Generator(def_id, ..) => {\n+            push_builtin_impl(generic_types::generator(tcx, def_id), &[]);\n+        }\n+\n+        // `Sized` if the last type is `Sized` (because else we will get a WF error anyway).\n+        &ty::Tuple(type_list) => {\n+            let type_list = generic_types::type_list(tcx, type_list.len());\n+            push_builtin_impl(tcx.mk_ty(ty::Tuple(type_list)), &**type_list);\n+        }\n+\n+        // Struct def\n+        ty::Adt(adt_def, _) => {\n+            let substs = Substs::bound_vars_for_item(tcx, adt_def.did);\n+            let adt = tcx.mk_ty(ty::Adt(adt_def, substs));\n+            let sized_constraint = adt_def.sized_constraint(tcx)\n+                .iter()\n+                .map(|ty| ty.subst(tcx, substs))\n+                .collect::<Vec<_>>();\n+            push_builtin_impl(adt, &sized_constraint);\n+        }\n+\n+        // Artificially trigger an ambiguity.\n+        ty::Infer(..) => {\n+            // Everybody can find at least two types to unify against:\n+            // general ty vars, int vars and float vars.\n+            push_builtin_impl(tcx.types.i32, &[]);\n+            push_builtin_impl(tcx.types.u32, &[]);\n+            push_builtin_impl(tcx.types.f32, &[]);\n+            push_builtin_impl(tcx.types.f64, &[]);\n+        }\n+\n+        ty::Projection(_projection_ty) => {\n+            // FIXME: add builtin impls from the associated type values found in\n+            // trait impls of `projection_ty.trait_ref(tcx)`.\n+        }\n+\n+        // The `Sized` bound can only come from the environment.\n+        ty::Param(..) |\n+        ty::Placeholder(..) |\n+        ty::UnnormalizedProjection(..) => (),\n+\n+        // Definitely not `Sized`.\n+        ty::Foreign(..) |\n+        ty::Str |\n+        ty::Slice(..) |\n+        ty::Dynamic(..) |\n+        ty::Opaque(..) => (),\n+\n+        ty::Bound(..) |\n+        ty::GeneratorWitness(..) => bug!(\"unexpected type {:?}\", ty),\n+    }\n+}\n+\n+fn wf_clause_for_raw_ptr<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    mutbl: hir::Mutability\n+) -> Clauses<'tcx> {\n+    let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n \n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(ptr_ty)),\n         hypotheses: ty::List::empty(),\n         category: ProgramClauseCategory::WellFormed,\n     };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+    let wf_clause = Clause::Implies(wf_clause);\n \n     // `forall<T> { WellFormed(*const T). }`\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-fn program_clauses_for_fn_ptr<'tcx>(\n+fn wf_clause_for_fn_ptr<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     arity_and_output: usize,\n     variadic: bool,\n     unsafety: hir::Unsafety,\n     abi: abi::Abi\n ) -> Clauses<'tcx> {\n-    let inputs_and_output = tcx.mk_type_list(\n-        (0..arity_and_output).into_iter()\n-            .map(|i| ty::BoundVar::from(i))\n-            // DebruijnIndex(1) because we are going to inject these in a `PolyFnSig`\n-            .map(|var| tcx.mk_ty(ty::Bound(ty::DebruijnIndex::from(1usize), var.into())))\n-    );\n-\n-    let fn_sig = ty::Binder::bind(ty::FnSig {\n-        inputs_and_output,\n-        variadic,\n-        unsafety,\n-        abi,\n-    });\n-    let fn_ptr = tcx.mk_fn_ptr(fn_sig);\n+    let fn_ptr = generic_types::fn_ptr(tcx, arity_and_output, variadic, unsafety, abi);\n \n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(fn_ptr)),\n@@ -104,13 +208,8 @@ fn program_clauses_for_fn_ptr<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-fn program_clauses_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n-    let ty = ty::Bound(\n-        ty::INNERMOST,\n-        ty::BoundVar::from_u32(0).into()\n-    );\n-    let ty = tcx.mk_ty(ty);\n-\n+fn wf_clause_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+    let ty = generic_types::bound(tcx, 0);\n     let slice_ty = tcx.mk_slice(ty);\n \n     let sized_trait = match tcx.lang_items().sized_trait() {\n@@ -138,16 +237,11 @@ fn program_clauses_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tc\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-fn program_clauses_for_array<'tcx>(\n+fn wf_clause_for_array<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     length: &'tcx ty::Const<'tcx>\n ) -> Clauses<'tcx> {\n-    let ty = ty::Bound(\n-        ty::INNERMOST,\n-        ty::BoundVar::from_u32(0).into()\n-    );\n-    let ty = tcx.mk_ty(ty);\n-\n+    let ty = generic_types::bound(tcx, 0);\n     let array_ty = tcx.mk_ty(ty::Array(ty, length));\n \n     let sized_trait = match tcx.lang_items().sized_trait() {\n@@ -175,23 +269,21 @@ fn program_clauses_for_array<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-fn program_clauses_for_tuple<'tcx>(\n+fn wf_clause_for_tuple<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     arity: usize\n ) -> Clauses<'tcx> {\n-    let type_list = tcx.mk_type_list(\n-        (0..arity).into_iter()\n-            .map(|i| ty::BoundVar::from(i))\n-            .map(|var| tcx.mk_ty(ty::Bound(ty::INNERMOST, var.into())))\n-    );\n-\n+    let type_list = generic_types::type_list(tcx, arity);\n     let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n \n     let sized_trait = match tcx.lang_items().sized_trait() {\n         Some(def_id) => def_id,\n         None => return ty::List::empty(),\n     };\n-    let sized_implemented = type_list[0..arity - 1].iter()\n+\n+    // If `arity == 0` (i.e. the unit type) or `arity == 1`, this list of\n+    // hypotheses is actually empty.\n+    let sized_implemented = type_list[0 .. std::cmp::max(arity, 1) - 1].iter()\n         .map(|ty| ty::TraitRef {\n             def_id: sized_trait,\n             substs: tcx.mk_substs_trait(*ty, ty::List::empty()),\n@@ -221,40 +313,66 @@ fn program_clauses_for_tuple<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-fn program_clauses_for_ref<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+fn wf_clause_for_ref<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    mutbl: hir::Mutability\n+) -> Clauses<'tcx> {\n     let region = tcx.mk_region(\n         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n     );\n-    let ty = tcx.mk_ty(\n-        ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(1).into())\n-    );\n-\n+    let ty = generic_types::bound(tcx, 1);\n     let ref_ty = tcx.mk_ref(region, ty::TypeAndMut {\n         ty,\n-        mutbl: hir::Mutability::MutImmutable,\n+        mutbl,\n     });\n \n-    let outlives: DomainGoal = ty::OutlivesPredicate(ty, region).lower();\n+    let _outlives: DomainGoal = ty::OutlivesPredicate(ty, region).lower();\n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(ref_ty)),\n-        hypotheses: tcx.mk_goals(\n-            iter::once(tcx.mk_goal(outlives.into_goal()))\n-        ),\n-        category: ProgramClauseCategory::ImpliedBound,\n+        hypotheses: ty::List::empty(),\n+\n+        // FIXME: restore this later once we get better at handling regions\n+        // hypotheses: tcx.mk_goals(\n+        //     iter::once(tcx.mk_goal(outlives.into_goal()))\n+        // ),\n+        category: ProgramClauseCategory::WellFormed,\n     };\n     let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n \n     // `forall<'a, T> { WellFormed(&'a T) :- Outlives(T: 'a). }`\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n+fn wf_clause_for_fn_def<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    def_id: DefId\n+) -> Clauses<'tcx> {\n+    let fn_def = generic_types::fn_def(tcx, def_id);\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_def)),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall <T1, ..., Tn+1> { WellFormed(fn some_fn(T1, ..., Tn) -> Tn+1). }`\n+    // where `def_id` maps to the `some_fn` function definition\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n     pub(super) fn program_clauses_impl(\n         &self,\n         environment: &Environment<'tcx>,\n         goal: &DomainGoal<'tcx>,\n     ) -> Vec<Clause<'tcx>> {\n         use rustc::traits::WhereClause::*;\n+        use rustc::infer::canonical::OriginalQueryValues;\n+\n+        let goal = self.infcx.resolve_type_vars_if_possible(goal);\n+\n+        debug!(\"program_clauses(goal = {:?})\", goal);\n \n         let mut clauses = match goal {\n             DomainGoal::Holds(Implemented(trait_predicate)) => {\n@@ -263,12 +381,22 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                 // * the trait decl (rule `Implemented-From-Env`)\n \n                 let mut clauses = vec![];\n+\n                 assemble_clauses_from_impls(\n                     self.infcx.tcx,\n                     trait_predicate.def_id(),\n                     &mut clauses\n                 );\n \n+                if Some(trait_predicate.def_id()) == self.infcx.tcx.lang_items().sized_trait() {\n+                    assemble_builtin_sized_impls(\n+                        self.infcx.tcx,\n+                        trait_predicate.def_id(),\n+                        trait_predicate.self_ty(),\n+                        &mut clauses\n+                    );\n+                }\n+\n                 // FIXME: we need to add special rules for builtin impls:\n                 // * `Copy` / `Clone`\n                 // * `Sized`\n@@ -345,31 +473,34 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                         self.infcx.tcx.program_clauses_for(data.item_def_id)\n                     }\n \n-                    // These types are always WF and non-parametric.\n+                    // These types are always WF.\n                     ty::Bool |\n                     ty::Char |\n                     ty::Int(..) |\n                     ty::Uint(..) |\n                     ty::Float(..) |\n                     ty::Str |\n+                    ty::Param(..) |\n+                    ty::Placeholder(..) |\n+                    ty::Error |\n                     ty::Never => {\n                         let wf_clause = ProgramClause {\n                             goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n                             hypotheses: ty::List::empty(),\n                             category: ProgramClauseCategory::WellFormed,\n                         };\n-                        let wf_clause = Clause::ForAll(ty::Binder::dummy(wf_clause));\n+                        let wf_clause = Clause::Implies(wf_clause);\n \n                         self.infcx.tcx.mk_clauses(iter::once(wf_clause))\n                     }\n \n                     // Always WF (recall that we do not check for parameters to be WF).\n-                    ty::RawPtr(..) => program_clauses_for_raw_ptr(self.infcx.tcx),\n+                    ty::RawPtr(ptr) => wf_clause_for_raw_ptr(self.infcx.tcx, ptr.mutbl),\n \n                     // Always WF (recall that we do not check for parameters to be WF).\n                     ty::FnPtr(fn_ptr) => {\n                         let fn_ptr = fn_ptr.skip_binder();\n-                        program_clauses_for_fn_ptr(\n+                        wf_clause_for_fn_ptr(\n                             self.infcx.tcx,\n                             fn_ptr.inputs_and_output.len(),\n                             fn_ptr.variadic,\n@@ -379,19 +510,21 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                     }\n \n                     // WF if inner type is `Sized`.\n-                    ty::Slice(..) => program_clauses_for_slice(self.infcx.tcx),\n+                    ty::Slice(..) => wf_clause_for_slice(self.infcx.tcx),\n \n                     // WF if inner type is `Sized`.\n-                    ty::Array(_, length) => program_clauses_for_array(self.infcx.tcx, length),\n+                    ty::Array(_, length) => wf_clause_for_array(self.infcx.tcx, length),\n \n                     // WF if all types but the last one are `Sized`.\n-                    ty::Tuple(types) => program_clauses_for_tuple(\n+                    ty::Tuple(types) => wf_clause_for_tuple(\n                         self.infcx.tcx,\n                         types.len()\n                     ),\n \n                     // WF if `sub_ty` outlives `region`.\n-                    ty::Ref(..) => program_clauses_for_ref(self.infcx.tcx),\n+                    ty::Ref(_, _, mutbl) => wf_clause_for_ref(self.infcx.tcx, mutbl),\n+\n+                    ty::FnDef(def_id, ..) => wf_clause_for_fn_def(self.infcx.tcx, def_id),\n \n                     ty::Dynamic(..) => {\n                         // FIXME: no rules yet for trait objects\n@@ -402,21 +535,32 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                         self.infcx.tcx.program_clauses_for(def.did)\n                     }\n \n+                    // FIXME: these are probably wrong\n                     ty::Foreign(def_id) |\n-                    ty::FnDef(def_id, ..) |\n                     ty::Closure(def_id, ..) |\n                     ty::Generator(def_id, ..) |\n                     ty::Opaque(def_id, ..) => {\n                         self.infcx.tcx.program_clauses_for(def_id)\n                     }\n \n+                    // Artificially trigger an ambiguity.\n+                    ty::Infer(..) => {\n+                        let tcx = self.infcx.tcx;\n+                        let types = [tcx.types.i32, tcx.types.u32, tcx.types.f32, tcx.types.f64];\n+                        let clauses = types.iter()\n+                            .cloned()\n+                            .map(|ty| ProgramClause {\n+                                goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n+                                hypotheses: ty::List::empty(),\n+                                category: ProgramClauseCategory::WellFormed,\n+                            })\n+                            .map(|clause| Clause::Implies(clause));\n+                        tcx.mk_clauses(clauses)\n+                    }\n+\n                     ty::GeneratorWitness(..) |\n-                    ty::Placeholder(..) |\n                     ty::UnnormalizedProjection(..) |\n-                    ty::Infer(..) |\n-                    ty::Bound(..) |\n-                    ty::Param(..) |\n-                    ty::Error => {\n+                    ty::Bound(..) => {\n                         bug!(\"unexpected type {:?}\", ty)\n                     }\n                 };\n@@ -458,13 +602,20 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n             }\n         };\n \n-        let environment = self.infcx.tcx.lift_to_global(environment)\n-            .expect(\"environment is not global\");\n-        clauses.extend(\n-            self.infcx.tcx.program_clauses_for_env(environment)\n-                .into_iter()\n-                .cloned()\n-        );\n+        debug!(\"program_clauses: clauses = {:?}\", clauses);\n+        debug!(\"program_clauses: adding clauses from environment = {:?}\", environment);\n+\n+        let mut _orig_query_values = OriginalQueryValues::default();\n+        let canonical_environment = self.infcx.canonicalize_query(\n+            environment,\n+            &mut _orig_query_values\n+        ).value;\n+        let env_clauses = self.infcx.tcx.program_clauses_for_env(canonical_environment);\n+\n+        debug!(\"program_clauses: env_clauses = {:?}\", env_clauses);\n+\n+        clauses.extend(env_clauses.into_iter().cloned());\n+        clauses.extend(environment.clauses.iter().cloned());\n         clauses\n     }\n }"}, {"sha": "f7bbf621c09734bff8d46d4a09410aac4581590b", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -35,7 +35,9 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     ) -> Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n         use chalk_engine::context::UnificationOps;\n \n-        self.infcx.probe(|_| {\n+        debug!(\"resolvent_clause(goal = {:?}, clause = {:?})\", goal, clause);\n+\n+        let result = self.infcx.probe(|_| {\n             let ProgramClause {\n                 goal: consequence,\n                 hypotheses,\n@@ -49,8 +51,13 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n                 ).0,\n             };\n \n-            let result = unify(self.infcx, *environment, goal, &consequence)\n-                .map_err(|_| NoSolution)?;\n+            let result = unify(\n+                self.infcx,\n+                *environment,\n+                ty::Variance::Invariant,\n+                goal,\n+                &consequence\n+            ).map_err(|_| NoSolution)?;\n \n             let mut ex_clause = ExClause {\n                 subst: subst.clone(),\n@@ -70,7 +77,10 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n \n             let canonical_ex_clause = self.canonicalize_ex_clause(&ex_clause);\n             Ok(canonical_ex_clause)\n-        })\n+        });\n+\n+        debug!(\"resolvent_clause: result = {:?}\", result);\n+        result\n     }\n \n     fn apply_answer_subst(\n@@ -80,6 +90,12 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         answer_table_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n         canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n     ) -> Fallible<ChalkExClause<'tcx>> {\n+        debug!(\n+            \"apply_answer_subst(ex_clause = {:?}, selected_goal = {:?})\",\n+            self.infcx.resolve_type_vars_if_possible(&ex_clause),\n+            self.infcx.resolve_type_vars_if_possible(selected_goal)\n+        );\n+\n         let (answer_subst, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n             DUMMY_SP,\n             canonical_answer_subst\n@@ -96,8 +112,12 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         substitutor.relate(&answer_table_goal.value, &selected_goal)\n             .map_err(|_| NoSolution)?;\n \n-        let mut ex_clause = substitutor.ex_clause;\n-        ex_clause.constraints.extend(answer_subst.constraints);\n+        let ex_clause = substitutor.ex_clause;\n+\n+        // FIXME: restore this later once we get better at handling regions\n+        // ex_clause.constraints.extend(answer_subst.constraints);\n+\n+        debug!(\"apply_answer_subst: ex_clause = {:?}\", ex_clause);\n         Ok(ex_clause)\n     }\n }\n@@ -124,7 +144,7 @@ impl AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n         );\n \n         super::into_ex_clause(\n-            unify(self.infcx, self.environment, answer_param, pending)?,\n+            unify(self.infcx, self.environment, ty::Variance::Invariant, answer_param, pending)?,\n             &mut self.ex_clause\n         );\n \n@@ -172,6 +192,7 @@ impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let b = self.infcx.shallow_resolve(b);\n+        debug!(\"AnswerSubstitutor::tys(a = {:?}, b = {:?})\", a, b);\n \n         if let &ty::Bound(debruijn, bound_ty) = &a.sty {\n             // Free bound var"}, {"sha": "abb4812734123c5d9b35dff708bbcc14e270132a", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -13,9 +13,16 @@ crate struct UnificationResult<'tcx> {\n crate fn unify<'me, 'gcx, 'tcx, T: Relate<'tcx>>(\n     infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n     environment: Environment<'tcx>,\n+    variance: ty::Variance,\n     a: &T,\n     b: &T\n ) -> RelateResult<'tcx, UnificationResult<'tcx>> {\n+    debug!(\"unify(\n+        a = {:?},\n+        b = {:?},\n+        environment = {:?},\n+    )\", a, b, environment);\n+\n     let mut delegate = ChalkTypeRelatingDelegate::new(\n         infcx,\n         environment\n@@ -24,9 +31,11 @@ crate fn unify<'me, 'gcx, 'tcx, T: Relate<'tcx>>(\n     TypeRelating::new(\n         infcx,\n         &mut delegate,\n-        ty::Variance::Invariant\n+        variance\n     ).relate(a, b)?;\n \n+    debug!(\"unify: goals = {:?}, constraints = {:?}\", delegate.goals, delegate.constraints);\n+\n     Ok(UnificationResult {\n         goals: delegate.goals,\n         constraints: delegate.constraints,"}, {"sha": "7979fe4a750731a3783f42259cbe33d150cda367", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::traits::query::dropck_outlives::{DropckOutlivesResult, DtorckConstraint};\n use rustc::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc::traits::{FulfillmentContext, Normalized, ObligationCause, TraitEngineExt};\n+use rustc::traits::{TraitEngine, Normalized, ObligationCause, TraitEngineExt};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n@@ -78,7 +78,7 @@ fn dropck_outlives<'tcx>(\n             // Set used to detect infinite recursion.\n             let mut ty_set = FxHashSet::default();\n \n-            let fulfill_cx = &mut FulfillmentContext::new();\n+            let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n \n             let cause = ObligationCause::dummy();\n             while let Some((ty, depth)) = ty_stack.pop() {\n@@ -136,7 +136,11 @@ fn dropck_outlives<'tcx>(\n \n             debug!(\"dropck_outlives: result = {:#?}\", result);\n \n-            infcx.make_canonicalized_query_response(canonical_inference_vars, result, fulfill_cx)\n+            infcx.make_canonicalized_query_response(\n+                canonical_inference_vars,\n+                result,\n+                &mut *fulfill_cx\n+            )\n         },\n     )\n }"}, {"sha": "03511e1d76d0562cf26fcd1b30046c768a1554d2", "filename": "src/librustc_traits/generic_types.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,80 @@\n+//! Utilities for creating generic types with bound vars in place of parameter values.\n+\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Substs;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc_target::spec::abi;\n+\n+crate fn bound(tcx: ty::TyCtxt<'_, '_, 'tcx>, index: u32) -> Ty<'tcx> {\n+    let ty = ty::Bound(\n+        ty::INNERMOST,\n+        ty::BoundVar::from_u32(index).into()\n+    );\n+    tcx.mk_ty(ty)\n+}\n+\n+crate fn raw_ptr(tcx: TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n+    tcx.mk_ptr(ty::TypeAndMut {\n+        ty: bound(tcx, 0),\n+        mutbl,\n+    })\n+}\n+\n+crate fn fn_ptr(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    arity_and_output: usize,\n+    variadic: bool,\n+    unsafety: hir::Unsafety,\n+    abi: abi::Abi\n+) -> Ty<'tcx> {\n+    let inputs_and_output = tcx.mk_type_list(\n+        (0..arity_and_output).into_iter()\n+            .map(|i| ty::BoundVar::from(i))\n+            // DebruijnIndex(1) because we are going to inject these in a `PolyFnSig`\n+            .map(|var| tcx.mk_ty(ty::Bound(ty::DebruijnIndex::from(1usize), var.into())))\n+    );\n+\n+    let fn_sig = ty::Binder::bind(ty::FnSig {\n+        inputs_and_output,\n+        variadic,\n+        unsafety,\n+        abi,\n+    });\n+    tcx.mk_fn_ptr(fn_sig)\n+}\n+\n+crate fn type_list(tcx: ty::TyCtxt<'_, '_, 'tcx>, arity: usize) -> &'tcx ty::List<Ty<'tcx>> {\n+    tcx.mk_type_list(\n+        (0..arity).into_iter()\n+            .map(|i| ty::BoundVar::from(i))\n+            .map(|var| tcx.mk_ty(ty::Bound(ty::INNERMOST, var.into())))\n+    )\n+}\n+\n+crate fn ref_ty(tcx: ty::TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n+    let region = tcx.mk_region(\n+        ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n+    );\n+\n+    tcx.mk_ref(region, ty::TypeAndMut {\n+        ty: bound(tcx, 1),\n+        mutbl,\n+    })\n+}\n+\n+crate fn fn_def(tcx: ty::TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+    tcx.mk_ty(ty::FnDef(def_id, Substs::bound_vars_for_item(tcx, def_id)))\n+}\n+\n+crate fn closure(tcx: ty::TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+    tcx.mk_closure(def_id, ty::ClosureSubsts {\n+        substs: Substs::bound_vars_for_item(tcx, def_id),\n+    })\n+}\n+\n+crate fn generator(tcx: ty::TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+    tcx.mk_generator(def_id, ty::GeneratorSubsts {\n+        substs: Substs::bound_vars_for_item(tcx, def_id),\n+    }, hir::GeneratorMovability::Movable)\n+}"}, {"sha": "a220b9219136948785a9d98a88c270623c3ae678", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -25,6 +25,7 @@ mod implied_outlives_bounds;\n mod normalize_projection_ty;\n mod normalize_erasing_regions;\n pub mod lowering;\n+mod generic_types;\n mod type_op;\n \n use rustc::ty::query::Providers;\n@@ -34,6 +35,7 @@ pub fn provide(p: &mut Providers) {\n     evaluate_obligation::provide(p);\n     implied_outlives_bounds::provide(p);\n     lowering::provide(p);\n+    chalk_context::provide(p);\n     normalize_projection_ty::provide(p);\n     normalize_erasing_regions::provide(p);\n     type_op::provide(p);"}, {"sha": "962a145814c8b53028c36f2e5e5069431c97abf3", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 61, "deletions": 54, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -11,6 +11,7 @@ use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashSet;\n use super::Lower;\n+use crate::generic_types;\n use std::iter;\n \n struct ClauseVisitor<'set, 'a, 'tcx: 'a + 'set> {\n@@ -38,20 +39,16 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n             }\n \n             // forall<'a, T> { `Outlives(T: 'a) :- FromEnv(&'a T)` }\n-            ty::Ref(..) => {\n-                use rustc::hir;\n-\n+            ty::Ref(_, _, mutbl) => {\n                 let region = self.tcx.mk_region(\n                     ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n                 );\n-                let ty = self.tcx.mk_ty(\n-                    ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(1).into())\n-                );\n-\n+                let ty = generic_types::bound(self.tcx, 1);\n                 let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut {\n                     ty,\n-                    mutbl: hir::Mutability::MutImmutable,\n+                    mutbl,\n                 });\n+\n                 let from_env = DomainGoal::FromEnv(FromEnv::Ty(ref_ty));\n \n                 let clause = ProgramClause {\n@@ -105,11 +102,11 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n             ty::Never |\n             ty::Infer(..) |\n             ty::Placeholder(..) |\n+            ty::Param(..) |\n             ty::Bound(..) => (),\n \n             ty::GeneratorWitness(..) |\n             ty::UnnormalizedProjection(..) |\n-            ty::Param(..) |\n             ty::Error => {\n                 bug!(\"unexpected type {:?}\", ty);\n             }\n@@ -192,25 +189,23 @@ crate fn program_clauses_for_env<'a, 'tcx>(\n crate fn environment<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId\n-) -> ty::Binder<Environment<'tcx>> {\n+) -> Environment<'tcx> {\n     use super::{Lower, IntoFromEnvGoal};\n     use rustc::hir::{Node, TraitItemKind, ImplItemKind, ItemKind, ForeignItemKind};\n-    use rustc::ty::subst::{Subst, Substs};\n+\n+    debug!(\"environment(def_id = {:?})\", def_id);\n \n     // The environment of an impl Trait type is its defining function's environment.\n     if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n         return environment(tcx, parent);\n     }\n \n-    let bound_vars = Substs::bound_vars_for_item(tcx, def_id);\n-\n     // Compute the bounds on `Self` and the type parameters.\n     let ty::InstantiatedPredicates { predicates } = tcx.predicates_of(def_id)\n         .instantiate_identity(tcx);\n \n     let clauses = predicates.into_iter()\n         .map(|predicate| predicate.lower())\n-        .map(|predicate| predicate.subst(tcx, bound_vars))\n         .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_from_env_goal()))\n         .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_program_clause()))\n \n@@ -221,73 +216,85 @@ crate fn environment<'a, 'tcx>(\n     let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n     let node = tcx.hir().get(node_id);\n \n-    let mut is_fn = false;\n-    let mut is_impl = false;\n-    match node {\n+    enum NodeKind {\n+        TraitImpl,\n+        InherentImpl,\n+        Fn,\n+        Other,\n+    };\n+\n+    let node_kind = match node {\n         Node::TraitItem(item) => match item.node {\n-            TraitItemKind::Method(..) => is_fn = true,\n-            _ => (),\n+            TraitItemKind::Method(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n         }\n \n         Node::ImplItem(item) => match item.node {\n-            ImplItemKind::Method(..) => is_fn = true,\n-            _ => (),\n+            ImplItemKind::Method(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n         }\n \n         Node::Item(item) => match item.node {\n-            ItemKind::Impl(..) => is_impl = true,\n-            ItemKind::Fn(..) => is_fn = true,\n-            _ => (),\n+            ItemKind::Impl(.., Some(..), _, _) => NodeKind::TraitImpl,\n+            ItemKind::Impl(.., None, _, _) => NodeKind::InherentImpl,\n+            ItemKind::Fn(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n         }\n \n         Node::ForeignItem(item) => match item.node {\n-            ForeignItemKind::Fn(..) => is_fn = true,\n-            _ => (),\n+            ForeignItemKind::Fn(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n         }\n \n         // FIXME: closures?\n-        _ => (),\n-    }\n+        _ => NodeKind::Other,\n+    };\n \n     let mut input_tys = FxHashSet::default();\n \n-    // In an impl, we assume that the header trait ref and all its constituents\n-    // are well-formed.\n-    if is_impl {\n-        let trait_ref = tcx.impl_trait_ref(def_id)\n-            .expect(\"not an impl\")\n-            .subst(tcx, bound_vars);\n+    match node_kind {\n+        // In a trait impl, we assume that the header trait ref and all its\n+        // constituents are well-formed.\n+        NodeKind::TraitImpl => {\n+            let trait_ref = tcx.impl_trait_ref(def_id)\n+                .expect(\"not an impl\");\n \n-        input_tys.extend(\n-            trait_ref.substs.types().flat_map(|ty| ty.walk())\n-        );\n-    }\n+            input_tys.extend(\n+                trait_ref.input_types().flat_map(|ty| ty.walk())\n+            );\n+        }\n \n-    // In an fn, we assume that the arguments and all their constituents are\n-    // well-formed.\n-    if is_fn {\n-        // `skip_binder` because we move region parameters to the root binder,\n-        // restored in the return type of this query\n-        let fn_sig = tcx.fn_sig(def_id).skip_binder().subst(tcx, bound_vars);\n+        // In an inherent impl, we assume that the receiver type and all its\n+        // constituents are well-formed.\n+        NodeKind::InherentImpl => {\n+            let self_ty = tcx.type_of(def_id);\n+            input_tys.extend(self_ty.walk());\n+        }\n \n-        input_tys.extend(\n-            fn_sig.inputs().iter().flat_map(|ty| ty.walk())\n-        );\n+        // In an fn, we assume that the arguments and all their constituents are\n+        // well-formed.\n+        NodeKind::Fn => {\n+            let fn_sig = tcx.fn_sig(def_id);\n+            let fn_sig = tcx.liberate_late_bound_regions(def_id, &fn_sig);\n+\n+            input_tys.extend(\n+                fn_sig.inputs().iter().flat_map(|ty| ty.walk())\n+            );\n+        }\n+\n+        NodeKind::Other => (),\n     }\n \n     let clauses = clauses.chain(\n         input_tys.into_iter()\n-            // Filter out type parameters\n-            .filter(|ty| match ty.sty {\n-                ty::Bound(..) => false,\n-                _ => true,\n-            })\n             .map(|ty| DomainGoal::FromEnv(FromEnv::Ty(ty)))\n             .map(|domain_goal| domain_goal.into_program_clause())\n             .map(Clause::Implies)\n     );\n \n-    ty::Binder::bind(Environment {\n+    debug!(\"environment: clauses = {:?}\", clauses);\n+\n+    Environment {\n         clauses: tcx.mk_clauses(clauses),\n-    })\n+    }\n }"}, {"sha": "5502a1d186eeef2c3bd1776921cc86d7f1b5df08", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -211,7 +211,6 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     let where_clauses = &predicates\n         .iter()\n         .map(|(wc, _)| wc.lower())\n-        .map(|wc| wc.subst(tcx, bound_vars))\n         .collect::<Vec<_>>();\n \n     // Rule Implied-Bound-From-Trait\n@@ -232,14 +231,13 @@ fn program_clauses_for_trait<'a, 'tcx>(\n         .map(|wc| {\n             // we move binders to the left\n             wc.map_bound(|goal| ProgramClause {\n-                goal: goal.into_from_env_goal(),\n-\n-                // FIXME: As where clauses can only bind lifetimes for now,\n-                // and that named bound regions have a def-id, it is safe\n-                // to just inject `hypotheses` (which contains named vars bound at index `0`)\n-                // into this binding level. This may change if we ever allow where clauses\n-                // to bind types (e.g., for GATs things), because bound types only use a `BoundVar`\n+                // FIXME: As where clauses can only bind lifetimes for now, and that named\n+                // bound regions have a def-id, it is safe to just inject `bound_vars` and\n+                // `hypotheses` (which contain named vars bound at index `0`) into this\n+                // binding level. This may change if we ever allow where clauses to bind\n+                // types (e.g. for GATs things), because bound types only use a `BoundVar`\n                 // index (no def-id).\n+                goal: goal.subst(tcx, bound_vars).into_from_env_goal(),\n                 hypotheses,\n \n                 category: ProgramClauseCategory::ImpliedBound,\n@@ -346,7 +344,6 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n     let where_clauses = tcx.predicates_of(def_id).predicates\n         .iter()\n         .map(|(wc, _)| wc.lower())\n-        .map(|wc| wc.subst(tcx, bound_vars))\n         .collect::<Vec<_>>();\n \n     // `WellFormed(Ty<...>) :- WC1, ..., WCm`\n@@ -355,7 +352,7 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n         hypotheses: tcx.mk_goals(\n             where_clauses\n                 .iter()\n-                .cloned()\n+                .map(|wc| wc.subst(tcx, bound_vars))\n                 .map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n         ),\n         category: ProgramClauseCategory::WellFormed,\n@@ -383,11 +380,10 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n         .map(|wc| {\n             // move the binders to the left\n             wc.map_bound(|goal| ProgramClause {\n-                goal: goal.into_from_env_goal(),\n-\n-                // FIXME: we inject `hypotheses` into this binding level,\n-                // which may be incorrect in the future: see the FIXME in\n-                // `program_clauses_for_trait`\n+                // FIXME: we inject `bound_vars` and `hypotheses` into this binding\n+                // level, which may be incorrect in the future: see the FIXME in\n+                // `program_clauses_for_trait`.\n+                goal: goal.subst(tcx, bound_vars).into_from_env_goal(),\n                 hypotheses,\n \n                 category: ProgramClauseCategory::ImpliedBound,\n@@ -626,7 +622,7 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n \n             if attr.check_name(\"rustc_dump_env_program_clauses\") {\n                 let environment = self.tcx.environment(def_id);\n-                clauses = Some(self.tcx.program_clauses_for_env(*environment.skip_binder()));\n+                clauses = Some(self.tcx.program_clauses_for_env(environment));\n             }\n \n             if let Some(clauses) = clauses {"}, {"sha": "d38ce3478d93d29116f1cd5e29d5172399932174", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -11,7 +11,7 @@ use rustc::traits::query::type_op::prove_predicate::ProvePredicate;\n use rustc::traits::query::type_op::subtype::Subtype;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{\n-    FulfillmentContext, Normalized, Obligation, ObligationCause, TraitEngine, TraitEngineExt,\n+    Normalized, Obligation, ObligationCause, TraitEngine, TraitEngineExt,\n };\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{Kind, Subst, UserSelfTy, UserSubsts};\n@@ -75,7 +75,7 @@ fn type_op_ascribe_user_type<'tcx>(\n struct AscribeUserTypeCx<'me, 'gcx: 'tcx, 'tcx: 'me> {\n     infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n-    fulfill_cx: &'me mut FulfillmentContext<'tcx>,\n+    fulfill_cx: &'me mut dyn TraitEngine<'tcx>,\n }\n \n impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n@@ -231,7 +231,7 @@ fn type_op_eq<'tcx>(\n \n fn type_op_normalize<T>(\n     infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    fulfill_cx: &mut FulfillmentContext<'tcx>,\n+    fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     key: ParamEnvAnd<'tcx, Normalize<T>>,\n ) -> Fallible<T>\n where"}, {"sha": "8c193cc8ff1a3b790debb2eb566d6698a77140f9", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -206,8 +206,11 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n     let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n-    let param_env = ty::ParamEnv::new(tcx.intern_predicates(&hybrid_preds.predicates),\n-                                      Reveal::UserFacing);\n+    let param_env = ty::ParamEnv::new(\n+        tcx.intern_predicates(&hybrid_preds.predicates),\n+        Reveal::UserFacing,\n+        None\n+    );\n     let param_env = traits::normalize_param_env_or_error(tcx,\n                                                          impl_m.def_id,\n                                                          param_env,"}, {"sha": "df25bad622b3d09e83d3d6090f176f5cf914e887", "filename": "src/test/compile-fail/chalkify/chalk_initial_program.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fchalk_initial_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fchalk_initial_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fchalk_initial_program.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl Foo for i32 { }\n+\n+impl Foo for u32 { }\n+\n+fn gimme<F: Foo>() { }\n+\n+// Note: this also tests that `std::process::Termination` is implemented for `()`.\n+fn main() {\n+    gimme::<i32>();\n+    gimme::<u32>();\n+    gimme::<f32>(); //~ERROR the trait bound `f32: Foo` is not satisfied\n+}"}, {"sha": "d70c6f8055ddf92adfd332a3d1963888ed08ce93", "filename": "src/test/compile-fail/chalkify/generic_impls.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fgeneric_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fgeneric_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fgeneric_impls.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl<T> Foo for (T, u32) { }\n+\n+fn gimme<F: Foo>() { }\n+\n+fn foo<T>() {\n+    gimme::<(T, u32)>();\n+    gimme::<(Option<T>, u32)>();\n+    gimme::<(Option<T>, f32)>(); //~ ERROR\n+}\n+\n+fn main() {\n+    gimme::<(i32, u32)>();\n+    gimme::<(i32, f32)>(); //~ ERROR\n+}"}, {"sha": "96b1b2533712bd3407f9520990fc94b1c7f331ae", "filename": "src/test/compile-fail/chalkify/impl_wf.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fimpl_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fimpl_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fimpl_wf.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,38 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo: Sized { }\n+\n+trait Bar {\n+    type Item: Foo;\n+}\n+\n+impl Foo for i32 { }\n+\n+impl Foo for str { }\n+//~^ ERROR the size for values of type `str` cannot be known at compilation time\n+\n+// Implicit `T: Sized` bound.\n+impl<T> Foo for Option<T> { }\n+\n+impl Bar for () {\n+    type Item = i32;\n+}\n+\n+impl<T> Bar for Option<T> {\n+    type Item = Option<T>;\n+}\n+\n+impl Bar for f32 {\n+//~^ ERROR the trait bound `f32: Foo` is not satisfied\n+    type Item = f32;\n+}\n+\n+trait Baz<U: ?Sized> where U: Foo { }\n+\n+impl Baz<i32> for i32 { }\n+\n+impl Baz<f32> for f32 { }\n+//~^ ERROR the trait bound `f32: Foo` is not satisfied\n+\n+fn main() {\n+}"}, {"sha": "d1aa975ddc24d701a54f68b7b67db019dd53a7cf", "filename": "src/test/compile-fail/chalkify/type_wf.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fcompile-fail%2Fchalkify%2Ftype_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fcompile-fail%2Fchalkify%2Ftype_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchalkify%2Ftype_wf.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,24 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+struct S<T: Foo> {\n+    x: T,\n+}\n+\n+impl Foo for i32 { }\n+impl<T> Foo for Option<T> { }\n+\n+fn main() {\n+    let s = S {\n+       x: 5,\n+    };\n+\n+    let s = S { //~ ERROR the trait bound `{float}: Foo` is not satisfied\n+        x: 5.0,\n+    };\n+\n+    let s = S {\n+        x: Some(5.0),\n+    };\n+}"}, {"sha": "fbe30f115444e52392433878aa8b417fdcf7ab61", "filename": "src/test/run-pass/chalkify/inherent_impl.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Frun-pass%2Fchalkify%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Frun-pass%2Fchalkify%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchalkify%2Finherent_impl.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,41 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl Foo for i32 { }\n+\n+struct S<T: Foo> {\n+    x: T,\n+}\n+\n+fn only_foo<T: Foo>(_x: &T) { }\n+\n+impl<T> S<T> {\n+    // Test that we have the correct environment inside an inherent method.\n+    fn dummy_foo(&self) {\n+        only_foo(&self.x)\n+    }\n+}\n+\n+trait Bar { }\n+impl Bar for u32 { }\n+\n+fn only_bar<T: Bar>() { }\n+\n+impl<T> S<T> {\n+    // Test that the environment of `dummy_bar` adds up with the environment\n+    // of the inherent impl.\n+    fn dummy_bar<U: Bar>(&self) {\n+        only_foo(&self.x);\n+        only_bar::<U>();\n+    }\n+}\n+\n+fn main() {\n+    let s = S {\n+        x: 5,\n+    };\n+\n+    s.dummy_foo();\n+    s.dummy_bar::<u32>();\n+}"}, {"sha": "a598f68d3f98796fb6cf41e6f8e0be794207c750", "filename": "src/test/run-pass/chalkify/projection.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Frun-pass%2Fchalkify%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Frun-pass%2Fchalkify%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchalkify%2Fprojection.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,24 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+trait Bar {\n+    type Item: Foo;\n+}\n+\n+impl Foo for i32 { }\n+impl Bar for i32 {\n+    type Item = i32;\n+}\n+\n+fn only_foo<T: Foo>() { }\n+\n+fn only_bar<T: Bar>() {\n+    // `T` implements `Bar` hence `<T as Bar>::Item` must also implement `Bar`\n+    only_foo::<T::Item>()\n+}\n+\n+fn main() {\n+    only_bar::<i32>();\n+    only_foo::<<i32 as Bar>::Item>();\n+}"}, {"sha": "441d61ef24893fbbfd9961e3d5941eaec29fb2e6", "filename": "src/test/run-pass/chalkify/super_trait.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Frun-pass%2Fchalkify%2Fsuper_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Frun-pass%2Fchalkify%2Fsuper_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchalkify%2Fsuper_trait.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+trait Bar: Foo { }\n+\n+impl Foo for i32 { }\n+impl Bar for i32 { }\n+\n+fn only_foo<T: Foo>() { }\n+\n+fn only_bar<T: Bar>() {\n+    // `T` implements `Bar` hence `T` must also implement `Foo`\n+    only_foo::<T>()\n+}\n+\n+fn main() {\n+    only_bar::<i32>()\n+}"}, {"sha": "f82453792ff4c3b65d2d82260d4f10b5d4738791", "filename": "src/test/run-pass/chalkify/trait_implied_bound.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Frun-pass%2Fchalkify%2Ftrait_implied_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Frun-pass%2Fchalkify%2Ftrait_implied_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchalkify%2Ftrait_implied_bound.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+trait Bar<U> where U: Foo { }\n+\n+impl Foo for i32 { }\n+impl Bar<i32> for i32 { }\n+\n+fn only_foo<T: Foo>() { }\n+\n+fn only_bar<U, T: Bar<U>>() {\n+    only_foo::<U>()\n+}\n+\n+fn main() {\n+    only_bar::<i32, i32>()\n+}"}, {"sha": "94d976d3242710bc8567bb7ba812e897309b62a1", "filename": "src/test/run-pass/chalkify/type_implied_bound.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Frun-pass%2Fchalkify%2Ftype_implied_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Frun-pass%2Fchalkify%2Ftype_implied_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchalkify%2Ftype_implied_bound.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,28 @@\n+// compile-flags: -Z chalk\n+\n+trait Eq { }\n+trait Hash: Eq { }\n+\n+impl Eq for i32 { }\n+impl Hash for i32 { }\n+\n+struct Set<T: Hash> {\n+    _x: T,\n+}\n+\n+fn only_eq<T: Eq>() { }\n+\n+fn take_a_set<T>(_: &Set<T>) {\n+    // `Set<T>` is an input type of `take_a_set`, hence we know that\n+    // `T` must implement `Hash`, and we know in turn that `T` must\n+    // implement `Eq`.\n+    only_eq::<T>()\n+}\n+\n+fn main() {\n+    let set = Set {\n+        _x: 5,\n+    };\n+\n+    take_a_set(&set);\n+}"}, {"sha": "62a53ec0317b3f5942c100ca2e2db3ec3e7cd5fc", "filename": "src/test/ui/chalkify/type_inference.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,26 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+impl Foo for i32 { }\n+\n+trait Bar { }\n+impl Bar for i32 { }\n+impl Bar for u32 { }\n+\n+fn only_foo<T: Foo>(_x: T) { }\n+\n+fn only_bar<T: Bar>(_x: T) { }\n+\n+fn main() {\n+    let x = 5.0;\n+\n+    // The only type which implements `Foo` is `i32`, so the chalk trait solver\n+    // is expecting a variable of type `i32`. This behavior differs from the\n+    // old-style trait solver. I guess this will change, that's why I'm\n+    // adding that test.\n+    only_foo(x); //~ ERROR mismatched types\n+\n+    // Here we have two solutions so we get back the behavior of the old-style\n+    // trait solver.\n+    only_bar(x); //~ ERROR the trait bound `{float}: Bar` is not satisfied\n+}"}, {"sha": "49ed97d71680b72426399675c39978d2dcf62ebc", "filename": "src/test/ui/chalkify/type_inference.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -0,0 +1,28 @@\n+error[E0308]: mismatched types\n+  --> $DIR/type_inference.rs:21:14\n+   |\n+LL |     only_foo(x); //~ ERROR mismatched types\n+   |              ^ expected i32, found floating-point variable\n+   |\n+   = note: expected type `i32`\n+              found type `{float}`\n+\n+error[E0277]: the trait bound `{float}: Bar` is not satisfied\n+  --> $DIR/type_inference.rs:25:5\n+   |\n+LL |     only_bar(x); //~ ERROR the trait bound `{float}: Bar` is not satisfied\n+   |     ^^^^^^^^ the trait `Bar` is not implemented for `{float}`\n+   |\n+   = help: the following implementations were found:\n+             <i32 as Bar>\n+             <u32 as Bar>\n+note: required by `only_bar`\n+  --> $DIR/type_inference.rs:12:1\n+   |\n+LL | fn only_bar<T: Bar>(_x: T) { }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0277, E0308.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "8f9498e834d8ff11bcdc6c80727b9e80eda9b566", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -10,7 +10,7 @@ note: ...which requires const-evaluating `Foo::bytes::{{constant}}`...\n LL |     intrinsics::size_of::<T>()\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires computing layout of `Foo`...\n-note: ...which requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All }, value: [u8; _] }`...\n+note: ...which requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All, def_id: None }, value: [u8; _] }`...\n note: ...which requires const-evaluating + checking `Foo::bytes::{{constant}}`...\n   --> $DIR/const-size_of-cycle.rs:6:17\n    |"}, {"sha": "441f1b2a06960b27cffdff60690e4898005abb87", "filename": "src/test/ui/issues/issue-44415.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fui%2Fissues%2Fissue-44415.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb86d604bf65c3becd16180b56267a329cf268d5/src%2Ftest%2Fui%2Fissues%2Fissue-44415.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44415.stderr?ref=fb86d604bf65c3becd16180b56267a329cf268d5", "patch": "@@ -10,7 +10,7 @@ note: ...which requires const-evaluating `Foo::bytes::{{constant}}`...\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires computing layout of `Foo`...\n-note: ...which requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All }, value: [u8; _] }`...\n+note: ...which requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All, def_id: None }, value: [u8; _] }`...\n note: ...which requires const-evaluating + checking `Foo::bytes::{{constant}}`...\n   --> $DIR/issue-44415.rs:6:17\n    |"}]}