{"sha": "1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "node_id": "C_kwDOAAsO6NoAKDFjNGNhMjgzZGY0ZTkxOGNlMmZkYmExYzU4MjZjOTU3YThkYWFkM2Q", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-06-22T21:48:54Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-07-06T19:24:53Z"}, "message": "Support #[target(enable)] function attribute", "tree": {"sha": "9900d7d6b3de9e7dedf6b7d9e2563ceebaf03494", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9900d7d6b3de9e7dedf6b7d9e2563ceebaf03494"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "html_url": "https://github.com/rust-lang/rust/commit/1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4094923789f99cc64b5a8c9353d232a22b820a93", "url": "https://api.github.com/repos/rust-lang/rust/commits/4094923789f99cc64b5a8c9353d232a22b820a93", "html_url": "https://github.com/rust-lang/rust/commit/4094923789f99cc64b5a8c9353d232a22b820a93"}], "stats": {"total": 195, "additions": 174, "deletions": 21}, "files": [{"sha": "e52e742ec6cec153c016ce68a1aaa720bb12c0c0", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "patch": "@@ -41,15 +41,13 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -215,6 +213,7 @@ dependencies = [\n  \"ar\",\n  \"gccjit\",\n  \"lang_tester\",\n+ \"smallvec\",\n  \"target-lexicon\",\n  \"tempfile\",\n ]\n@@ -228,6 +227,12 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"smallvec\"\n+version = \"1.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f2dd574626839106c320a323308629dcb1acfc96e32a8cba364ddc61ac23ee83\"\n+\n [[package]]\n name = \"target-lexicon\"\n version = \"0.10.0\""}, {"sha": "26a0e92923d53059033032231b9e198fe8d81989", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "patch": "@@ -22,11 +22,12 @@ default = [\"master\"]\n master = [\"gccjit/master\"]\n \n [dependencies]\n-gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n+#gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n \n # Local copy.\n-#gccjit = { path = \"../gccjit.rs\" }\n+gccjit = { path = \"../gccjit.rs\" }\n \n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n target-lexicon = \"0.10.0\"\n \n ar = \"0.8.0\""}, {"sha": "c52b10ee20a8389e119b29575ed21cf0a3f0cbde", "filename": "src/attributes.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattributes.rs?ref=1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "patch": "@@ -0,0 +1,114 @@\n+use gccjit::{FnAttribute, Function};\n+use rustc_attr::InstructionSetAttr;\n+use rustc_codegen_ssa::target_features::tied_target_features;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty;\n+use rustc_session::Session;\n+use rustc_span::symbol::sym;\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::context::CodegenCx;\n+\n+// Given a map from target_features to whether they are enabled or disabled,\n+// ensure only valid combinations are allowed.\n+pub fn check_tied_features(\n+    sess: &Session,\n+    features: &FxHashMap<&str, bool>,\n+) -> Option<&'static [&'static str]> {\n+    for tied in tied_target_features(sess) {\n+        // Tied features must be set to the same value, or not set at all\n+        let mut tied_iter = tied.iter();\n+        let enabled = features.get(tied_iter.next().unwrap());\n+        if tied_iter.any(|f| enabled != features.get(f)) {\n+            return Some(tied);\n+        }\n+    }\n+    None\n+}\n+\n+// TODO: maybe move to a new module gcc_util.\n+// To find a list of GCC's names, check https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html\n+fn to_gcc_features<'a>(sess: &Session, s: &'a str) -> SmallVec<[&'a str; 2]> {\n+    let arch = if sess.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.arch };\n+    match (arch, s) {\n+        (\"x86\", \"sse4.2\") => smallvec![\"sse4.2\", \"crc32\"],\n+        (\"x86\", \"pclmulqdq\") => smallvec![\"pclmul\"],\n+        (\"x86\", \"rdrand\") => smallvec![\"rdrnd\"],\n+        (\"x86\", \"bmi1\") => smallvec![\"bmi\"],\n+        (\"x86\", \"cmpxchg16b\") => smallvec![\"cx16\"],\n+        (\"x86\", \"avx512vaes\") => smallvec![\"vaes\"],\n+        (\"x86\", \"avx512gfni\") => smallvec![\"gfni\"],\n+        (\"x86\", \"avx512vpclmulqdq\") => smallvec![\"vpclmulqdq\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512vbmi2'.\n+        (\"x86\", \"avx512vbmi2\") => smallvec![\"avx512vbmi2\", \"avx512bw\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512bitalg'.\n+        (\"x86\", \"avx512bitalg\") => smallvec![\"avx512bitalg\", \"avx512bw\"],\n+        (\"aarch64\", \"rcpc2\") => smallvec![\"rcpc-immo\"],\n+        (\"aarch64\", \"dpb\") => smallvec![\"ccpp\"],\n+        (\"aarch64\", \"dpb2\") => smallvec![\"ccdp\"],\n+        (\"aarch64\", \"frintts\") => smallvec![\"fptoint\"],\n+        (\"aarch64\", \"fcma\") => smallvec![\"complxnum\"],\n+        (\"aarch64\", \"pmuv3\") => smallvec![\"perfmon\"],\n+        (\"aarch64\", \"paca\") => smallvec![\"pauth\"],\n+        (\"aarch64\", \"pacg\") => smallvec![\"pauth\"],\n+        // Rust ties fp and neon together. In LLVM neon implicitly enables fp,\n+        // but we manually enable neon when a feature only implicitly enables fp\n+        (\"aarch64\", \"f32mm\") => smallvec![\"f32mm\", \"neon\"],\n+        (\"aarch64\", \"f64mm\") => smallvec![\"f64mm\", \"neon\"],\n+        (\"aarch64\", \"fhm\") => smallvec![\"fp16fml\", \"neon\"],\n+        (\"aarch64\", \"fp16\") => smallvec![\"fullfp16\", \"neon\"],\n+        (\"aarch64\", \"jsconv\") => smallvec![\"jsconv\", \"neon\"],\n+        (\"aarch64\", \"sve\") => smallvec![\"sve\", \"neon\"],\n+        (\"aarch64\", \"sve2\") => smallvec![\"sve2\", \"neon\"],\n+        (\"aarch64\", \"sve2-aes\") => smallvec![\"sve2-aes\", \"neon\"],\n+        (\"aarch64\", \"sve2-sm4\") => smallvec![\"sve2-sm4\", \"neon\"],\n+        (\"aarch64\", \"sve2-sha3\") => smallvec![\"sve2-sha3\", \"neon\"],\n+        (\"aarch64\", \"sve2-bitperm\") => smallvec![\"sve2-bitperm\", \"neon\"],\n+        (_, s) => smallvec![s],\n+    }\n+}\n+\n+/// Composite function which sets GCC attributes for function depending on its AST (`#[attribute]`)\n+/// attributes.\n+pub fn from_fn_attrs<'gcc, 'tcx>(\n+    cx: &CodegenCx<'gcc, 'tcx>,\n+    func: Function<'gcc>,\n+    instance: ty::Instance<'tcx>,\n+) {\n+    let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n+\n+    let function_features =\n+        codegen_fn_attrs.target_features.iter().map(|f| f.as_str()).collect::<Vec<&str>>();\n+\n+    if let Some(f) = check_tied_features(cx.tcx.sess, &function_features.iter().map(|f| (*f, true)).collect()) {\n+        let span = cx.tcx\n+            .get_attr(instance.def_id(), sym::target_feature)\n+            .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n+        let msg = format!(\n+            \"the target features {} must all be either enabled or disabled together\",\n+            f.join(\", \")\n+        );\n+        let mut err = cx.tcx.sess.struct_span_err(span, &msg);\n+        err.help(\"add the missing features in a `target_feature` attribute\");\n+        err.emit();\n+        return;\n+    }\n+\n+    let mut function_features = function_features\n+        .iter()\n+        .flat_map(|feat| to_gcc_features(cx.tcx.sess, feat).into_iter())\n+        .chain(codegen_fn_attrs.instruction_set.iter().map(|x| match x {\n+            InstructionSetAttr::ArmA32 => \"-thumb-mode\", // TODO: support removing feature.\n+            InstructionSetAttr::ArmT32 => \"thumb-mode\",\n+        }))\n+        .collect::<Vec<_>>();\n+\n+    // TODO(antoyo): check if we really need global backend features. (Maybe they could be applied\n+    // globally?)\n+    let mut global_features = cx.tcx.global_backend_features(()).iter().map(|s| s.as_str());\n+    function_features.extend(&mut global_features);\n+    let target_features = function_features.join(\",\");\n+    if !target_features.is_empty() {\n+        func.add_attribute(FnAttribute::Target, &target_features);\n+    }\n+}"}, {"sha": "2f77978df1edb3ee703ce099aa224d3d509afb9e", "filename": "src/base.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "patch": "@@ -79,37 +79,41 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_\n         // TODO(antoyo): only set on x86 platforms.\n         context.add_command_line_option(\"-masm=intel\");\n         // TODO(antoyo): only add the following cli argument if the feature is supported.\n-        context.add_command_line_option(\"-msse2\");\n+        /*context.add_command_line_option(\"-msse2\");\n         context.add_command_line_option(\"-mavx2\");\n         // FIXME(antoyo): the following causes an illegal instruction on vmovdqu64 in std_example on my CPU.\n         // Only add if the CPU supports it.\n-        //context.add_command_line_option(\"-mavx512f\");\n         context.add_command_line_option(\"-msha\");\n         context.add_command_line_option(\"-mpclmul\");\n         context.add_command_line_option(\"-mfma\");\n         context.add_command_line_option(\"-mfma4\");\n-        //context.add_command_line_option(\"-mavx512vpopcntdq\");\n-        //context.add_command_line_option(\"-mavx512vl\");\n         context.add_command_line_option(\"-m64\");\n         context.add_command_line_option(\"-mbmi\");\n         context.add_command_line_option(\"-mgfni\");\n         context.add_command_line_option(\"-mavxvnni\");\n-        //context.add_command_line_option(\"-mavx512vnni\");\n-        //context.add_command_line_option(\"-mavx512bw\");\n         context.add_command_line_option(\"-mf16c\");\n-        //context.add_command_line_option(\"-mavx512bitalg\");\n         context.add_command_line_option(\"-maes\");\n         context.add_command_line_option(\"-mxsavec\");\n         context.add_command_line_option(\"-mbmi2\");\n-        //context.add_command_line_option(\"-mavx512bf16\");\n         context.add_command_line_option(\"-mrtm\");\n         context.add_command_line_option(\"-mvaes\");\n         context.add_command_line_option(\"-mvpclmulqdq\");\n         context.add_command_line_option(\"-mavx\");\n-        //context.add_command_line_option(\"-mavx512vbmi2\");\n-        //context.add_command_line_option(\"-mavx512vbmi\");\n-        //context.add_command_line_option(\"-mavx512ifma\");\n-        //context.add_command_line_option(\"-mavx512cd\");\n+\n+        if env::var(\"CG_GCCJIT_ENABLE_AVX512\").as_deref() == Ok(\"1\") {\n+            context.add_command_line_option(\"-mavx512f\");\n+            context.add_command_line_option(\"-mavx512vpopcntdq\");\n+            context.add_command_line_option(\"-mavx512vl\");\n+            context.add_command_line_option(\"-mavx512vnni\");\n+            context.add_command_line_option(\"-mavx512bw\");\n+            context.add_command_line_option(\"-mavx512bitalg\");\n+            context.add_command_line_option(\"-mavx512bf16\");\n+            context.add_command_line_option(\"-mavx512vbmi2\");\n+            context.add_command_line_option(\"-mavx512vbmi\");\n+            context.add_command_line_option(\"-mavx512ifma\");\n+            context.add_command_line_option(\"-mavx512cd\");\n+        }*/\n+\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }"}, {"sha": "5557f886b2877aa7d191fb1c8e4513d5e7ae66bf", "filename": "src/callee.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcallee.rs?ref=1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "patch": "@@ -4,6 +4,7 @@ use rustc_middle::ty::{self, Instance, TypeFoldable};\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n \n use crate::abi::FnAbiGccExt;\n+use crate::attributes;\n use crate::context::CodegenCx;\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n@@ -67,8 +68,12 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n             cx.linkage.set(FunctionType::Extern);\n             let func = cx.declare_fn(&sym, &fn_abi);\n \n+            attributes::from_fn_attrs(cx, func, instance);\n+\n             // TODO(antoyo): set linkage and attributes.\n-            func\n+\n+            // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n+            unsafe { std::mem::transmute(func) }\n         };\n \n     cx.function_instances.borrow_mut().insert(instance, func);"}, {"sha": "5f6360a7da5309cb1d2c684b7c1cbdb8cf637523", "filename": "src/declare.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdeclare.rs?ref=1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "patch": "@@ -79,12 +79,11 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         unsafe { std::mem::transmute(func) }\n     }\n \n-    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> RValue<'gcc> {\n+    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Function<'gcc> {\n         let (return_type, params, variadic, on_stack_param_indices) = fn_abi.gcc_type(self);\n         let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n         self.on_stack_function_params.borrow_mut().insert(func, on_stack_param_indices);\n-        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-        unsafe { std::mem::transmute(func) }\n+        func\n     }\n \n     pub fn define_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {"}, {"sha": "1ca2394abdc23b7e3ae03f87eb002d8bc5419f74", "filename": "src/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "patch": "@@ -13,6 +13,7 @@\n #![warn(unused_lifetimes)]\n \n extern crate rustc_ast;\n+extern crate rustc_attr;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n@@ -32,6 +33,7 @@ mod abi;\n mod allocator;\n mod archive;\n mod asm;\n+mod attributes;\n mod back;\n mod base;\n mod builder;\n@@ -188,6 +190,24 @@ pub struct GccContext {\n     context: Context<'static>,\n }\n \n+impl GccContext {\n+    fn new<'tcx>(tcx: TyCtxt<'tcx>) -> Self {\n+        let context = create_context(tcx);\n+        Self {\n+            context,\n+        }\n+    }\n+}\n+\n+fn create_context<'gcc, 'tcx>(tcx: TyCtxt<'tcx>) -> Context<'gcc> {\n+    let context = Context::default();\n+    if tcx.sess.target.is_builtin {\n+        //let features = global_gcc_features(sess, false);\n+        println!(\"Features: {:?}\", tcx.sess.opts.cg.target_feature);\n+    }\n+    context\n+}\n+\n unsafe impl Send for GccContext {}\n // FIXME(antoyo): that shouldn't be Sync. Parallel compilation is currently disabled with \"-Zno-parallel-llvm\". Try to disable it here.\n unsafe impl Sync for GccContext {}\n@@ -302,6 +322,8 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n         .filter(|_feature| {\n             // TODO(antoyo): implement a way to get enabled feature in libgccjit.\n             // Probably using the equivalent of __builtin_cpu_supports.\n+            // TODO: maybe use whatever outputs the following command:\n+            // gcc -march=native -Q --help=target\n             #[cfg(feature=\"master\")]\n             {\n                 (_feature.contains(\"sse\") || _feature.contains(\"avx\")) && !_feature.contains(\"avx512\")"}, {"sha": "60a42846bd3d1df735c32e8c43871b92b96abe6c", "filename": "src/mono_item.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4ca283df4e918ce2fdba1c5826c957a8daad3d/src%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_item.rs?ref=1c4ca283df4e918ce2fdba1c5826c957a8daad3d", "patch": "@@ -5,6 +5,7 @@ use rustc_middle::ty::{self, Instance, TypeFoldable};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_span::def_id::DefId;\n \n+use crate::attributes;\n use crate::base;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n@@ -28,9 +29,11 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));\n-        let _decl = self.declare_fn(symbol_name, &fn_abi);\n+        let decl = self.declare_fn(symbol_name, &fn_abi);\n         //let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n \n+        attributes::from_fn_attrs(self, decl, instance);\n+\n         // TODO(antoyo): call set_link_section() to allow initializing argc/argv.\n         // TODO(antoyo): set unique comdat.\n         // TODO(antoyo): use inline attribute from there in linkage.set() above."}]}