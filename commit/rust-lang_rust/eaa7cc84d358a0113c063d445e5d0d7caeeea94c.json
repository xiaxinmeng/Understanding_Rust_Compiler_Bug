{"sha": "eaa7cc84d358a0113c063d445e5d0d7caeeea94c", "node_id": "C_kwDOAAsO6NoAKGVhYTdjYzg0ZDM1OGEwMTEzYzA2M2Q0NDVlNWQwZDdjYWVlZWE5NGM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-12T20:43:44Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-13T00:39:54Z"}, "message": "Add logic to make IMPLIED_BOUNDS_ENTAILMENT easier to understand", "tree": {"sha": "2708bcad7c8a5045feb7e214d3a3592baf3f4280", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2708bcad7c8a5045feb7e214d3a3592baf3f4280"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eaa7cc84d358a0113c063d445e5d0d7caeeea94c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eaa7cc84d358a0113c063d445e5d0d7caeeea94c", "html_url": "https://github.com/rust-lang/rust/commit/eaa7cc84d358a0113c063d445e5d0d7caeeea94c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eaa7cc84d358a0113c063d445e5d0d7caeeea94c/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54571407b2ac4bd29f6509b680a19b49d7fbaa16", "url": "https://api.github.com/repos/rust-lang/rust/commits/54571407b2ac4bd29f6509b680a19b49d7fbaa16", "html_url": "https://github.com/rust-lang/rust/commit/54571407b2ac4bd29f6509b680a19b49d7fbaa16"}], "stats": {"total": 176, "additions": 156, "deletions": 20}, "files": [{"sha": "2cdf75794713fe67666bc377a607976422e188ba", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 148, "deletions": 12, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/eaa7cc84d358a0113c063d445e5d0d7caeeea94c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa7cc84d358a0113c063d445e5d0d7caeeea94c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=eaa7cc84d358a0113c063d445e5d0d7caeeea94c", "patch": "@@ -2,7 +2,9 @@ use super::potentially_plural_count;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n use hir::def_id::{DefId, LocalDefId};\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n+use rustc_errors::{\n+    pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed, MultiSpan,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n@@ -320,15 +322,6 @@ fn compare_method_predicate_entailment<'tcx>(\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(unnormalized_impl_fty.into())),\n         ));\n     }\n-    let emit_implied_wf_lint = || {\n-        infcx.tcx.struct_span_lint_hir(\n-            rustc_session::lint::builtin::IMPLIED_BOUNDS_ENTAILMENT,\n-            impl_m_hir_id,\n-            infcx.tcx.def_span(impl_m.def_id),\n-            \"impl method assumes more implied bounds than the corresponding trait method\",\n-            |lint| lint,\n-        );\n-    };\n \n     // Check that all obligations are satisfied by the implementation's\n     // version.\n@@ -346,7 +339,7 @@ fn compare_method_predicate_entailment<'tcx>(\n                 )\n                 .map(|()| {\n                     // If the skip-mode was successful, emit a lint.\n-                    emit_implied_wf_lint();\n+                    emit_implied_wf_lint(infcx.tcx, impl_m, impl_m_hir_id, vec![]);\n                 });\n             }\n             CheckImpliedWfMode::Skip => {\n@@ -382,8 +375,16 @@ fn compare_method_predicate_entailment<'tcx>(\n                     CheckImpliedWfMode::Skip,\n                 )\n                 .map(|()| {\n+                    let bad_args = extract_bad_args_for_implies_lint(\n+                        tcx,\n+                        &errors,\n+                        (trait_m, trait_sig),\n+                        // Unnormalized impl sig corresponds to the HIR types written\n+                        (impl_m, unnormalized_impl_sig),\n+                        impl_m_hir_id,\n+                    );\n                     // If the skip-mode was successful, emit a lint.\n-                    emit_implied_wf_lint();\n+                    emit_implied_wf_lint(tcx, impl_m, impl_m_hir_id, bad_args);\n                 });\n             }\n             CheckImpliedWfMode::Skip => {\n@@ -400,6 +401,141 @@ fn compare_method_predicate_entailment<'tcx>(\n     Ok(())\n }\n \n+fn extract_bad_args_for_implies_lint<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    errors: &[infer::RegionResolutionError<'tcx>],\n+    (trait_m, trait_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    (impl_m, impl_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    hir_id: hir::HirId,\n+) -> Vec<(Span, Option<String>)> {\n+    let mut blame_generics = vec![];\n+    for error in errors {\n+        // Look for the subregion origin that contains an input/output type\n+        let origin = match error {\n+            infer::RegionResolutionError::ConcreteFailure(o, ..) => o,\n+            infer::RegionResolutionError::GenericBoundFailure(o, ..) => o,\n+            infer::RegionResolutionError::SubSupConflict(_, _, o, ..) => o,\n+            infer::RegionResolutionError::UpperBoundUniverseConflict(.., o, _) => o,\n+        };\n+        // Extract (possible) input/output types from origin\n+        match origin {\n+            infer::SubregionOrigin::Subtype(trace) => {\n+                if let Some((a, b)) = trace.values.ty() {\n+                    blame_generics.extend([a, b]);\n+                }\n+            }\n+            infer::SubregionOrigin::RelateParamBound(_, ty, _) => blame_generics.push(*ty),\n+            infer::SubregionOrigin::ReferenceOutlivesReferent(ty, _) => blame_generics.push(*ty),\n+            _ => {}\n+        }\n+    }\n+\n+    let fn_decl = tcx.hir().fn_decl_by_hir_id(hir_id).unwrap();\n+    let opt_ret_ty = match fn_decl.output {\n+        hir::FnRetTy::DefaultReturn(_) => None,\n+        hir::FnRetTy::Return(ty) => Some(ty),\n+    };\n+\n+    // Map late-bound regions from trait to impl, so the names are right.\n+    let mapping = std::iter::zip(\n+        tcx.fn_sig(trait_m.def_id).bound_vars(),\n+        tcx.fn_sig(impl_m.def_id).bound_vars(),\n+    )\n+    .filter_map(|(impl_bv, trait_bv)| {\n+        if let ty::BoundVariableKind::Region(impl_bv) = impl_bv\n+            && let ty::BoundVariableKind::Region(trait_bv) = trait_bv\n+        {\n+            Some((impl_bv, trait_bv))\n+        } else {\n+            None\n+        }\n+    })\n+    .collect();\n+\n+    // For each arg, see if it was in the \"blame\" of any of the region errors.\n+    // If so, then try to produce a suggestion to replace the argument type with\n+    // one from the trait.\n+    let mut bad_args = vec![];\n+    for (idx, (ty, hir_ty)) in\n+        std::iter::zip(impl_sig.inputs_and_output, fn_decl.inputs.iter().chain(opt_ret_ty))\n+            .enumerate()\n+    {\n+        let expected_ty = trait_sig.inputs_and_output[idx]\n+            .fold_with(&mut RemapLateBound { tcx, mapping: &mapping });\n+        if blame_generics.iter().any(|blame| ty.contains(*blame)) {\n+            let expected_ty_sugg = expected_ty.to_string();\n+            bad_args.push((\n+                hir_ty.span,\n+                // Only suggest something if it actually changed.\n+                (expected_ty_sugg != ty.to_string()).then_some(expected_ty_sugg),\n+            ));\n+        }\n+    }\n+\n+    bad_args\n+}\n+\n+struct RemapLateBound<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    mapping: &'a FxHashMap<ty::BoundRegionKind, ty::BoundRegionKind>,\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for RemapLateBound<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        if let ty::ReFree(fr) = *r {\n+            self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n+                bound_region: self\n+                    .mapping\n+                    .get(&fr.bound_region)\n+                    .copied()\n+                    .unwrap_or(fr.bound_region),\n+                ..fr\n+            }))\n+        } else {\n+            r\n+        }\n+    }\n+}\n+\n+fn emit_implied_wf_lint<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_m: &ty::AssocItem,\n+    hir_id: hir::HirId,\n+    bad_args: Vec<(Span, Option<String>)>,\n+) {\n+    let span: MultiSpan = if bad_args.is_empty() {\n+        tcx.def_span(impl_m.def_id).into()\n+    } else {\n+        bad_args.iter().map(|(span, _)| *span).collect::<Vec<_>>().into()\n+    };\n+    tcx.struct_span_lint_hir(\n+        rustc_session::lint::builtin::IMPLIED_BOUNDS_ENTAILMENT,\n+        hir_id,\n+        span,\n+        \"impl method assumes more implied bounds than the corresponding trait method\",\n+        |lint| {\n+            let bad_args: Vec<_> =\n+                bad_args.into_iter().filter_map(|(span, sugg)| Some((span, sugg?))).collect();\n+            if !bad_args.is_empty() {\n+                lint.multipart_suggestion(\n+                    format!(\n+                        \"replace {} type{} to make the impl signature compatible\",\n+                        pluralize!(\"this\", bad_args.len()),\n+                        pluralize!(bad_args.len())\n+                    ),\n+                    bad_args,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            lint\n+        },\n+    );\n+}\n+\n #[derive(Debug, PartialEq, Eq)]\n enum CheckImpliedWfMode {\n     /// Checks implied well-formedness of the impl method. If it fails, we will"}, {"sha": "ebe07027d2fa1ba036fd2a950a02b388863f6699", "filename": "tests/ui/implied-bounds/impl-implied-bounds-compatibility-unnormalized.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eaa7cc84d358a0113c063d445e5d0d7caeeea94c/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eaa7cc84d358a0113c063d445e5d0d7caeeea94c/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr?ref=eaa7cc84d358a0113c063d445e5d0d7caeeea94c", "patch": "@@ -1,8 +1,8 @@\n error: impl method assumes more implied bounds than the corresponding trait method\n-  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:5\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:31\n    |\n LL |     fn get<'s>(s: &'s str, _: <&'static &'s () as Project>::Ty) -> &'static str {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `()`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n@@ -16,10 +16,10 @@ error: aborting due to previous error\n \n Future incompatibility report: Future breakage diagnostic:\n error: impl method assumes more implied bounds than the corresponding trait method\n-  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:5\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:31\n    |\n LL |     fn get<'s>(s: &'s str, _: <&'static &'s () as Project>::Ty) -> &'static str {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `()`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>"}, {"sha": "43d3e058ffeb3f10adc89c2b7a1968f9b781aff1", "filename": "tests/ui/implied-bounds/impl-implied-bounds-compatibility.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eaa7cc84d358a0113c063d445e5d0d7caeeea94c/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eaa7cc84d358a0113c063d445e5d0d7caeeea94c/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr?ref=eaa7cc84d358a0113c063d445e5d0d7caeeea94c", "patch": "@@ -1,8 +1,8 @@\n error: impl method assumes more implied bounds than the corresponding trait method\n-  --> $DIR/impl-implied-bounds-compatibility.rs:14:5\n+  --> $DIR/impl-implied-bounds-compatibility.rs:14:35\n    |\n LL |     fn listeners<'b>(&'b self) -> &'a MessageListeners<'b> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `&'b MessageListeners<'b>`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n@@ -16,10 +16,10 @@ error: aborting due to previous error\n \n Future incompatibility report: Future breakage diagnostic:\n error: impl method assumes more implied bounds than the corresponding trait method\n-  --> $DIR/impl-implied-bounds-compatibility.rs:14:5\n+  --> $DIR/impl-implied-bounds-compatibility.rs:14:35\n    |\n LL |     fn listeners<'b>(&'b self) -> &'a MessageListeners<'b> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `&'b MessageListeners<'b>`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>"}]}