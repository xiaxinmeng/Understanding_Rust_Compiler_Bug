{"sha": "63849b6ecf03e2df98f65bd0e6e89a7d12986f9e", "node_id": "C_kwDOAAsO6NoAKDYzODQ5YjZlY2YwM2UyZGY5OGY2NWJkMGU2ZTg5YTdkMTI5ODZmOWU", "commit": {"author": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-04-28T15:00:12Z"}, "committer": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-05-06T16:10:59Z"}, "message": "remove ItemLikeVisitor impl for InherentCollect\n\nSigned-off-by: Miguel Guarniz <mi9uel9@gmail.com>", "tree": {"sha": "bf02ae11cf610898452cb406a6120774e163b015", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf02ae11cf610898452cb406a6120774e163b015"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e", "html_url": "https://github.com/rust-lang/rust/commit/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e/comments", "author": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c27f30835ccd356aba802146242cd369b52e224e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c27f30835ccd356aba802146242cd369b52e224e", "html_url": "https://github.com/rust-lang/rust/commit/c27f30835ccd356aba802146242cd369b52e224e"}], "stats": {"total": 162, "additions": 84, "deletions": 78}, "files": [{"sha": "19549038c9d112057ad26cb5c4b64afa79e07014", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 74, "deletions": 75, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=63849b6ecf03e2df98f65bd0e6e89a7d12986f9e", "patch": "@@ -9,8 +9,8 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n@@ -19,7 +19,9 @@ use rustc_span::Span;\n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n pub fn crate_inherent_impls(tcx: TyCtxt<'_>, (): ()) -> CrateInherentImpls {\n     let mut collect = InherentCollect { tcx, impls_map: Default::default() };\n-    tcx.hir().visit_all_item_likes(&mut collect);\n+    for id in tcx.hir().items() {\n+        collect.check_item(id);\n+    }\n     collect.impls_map\n }\n \n@@ -46,79 +48,6 @@ struct InherentCollect<'tcx> {\n     impls_map: CrateInherentImpls,\n }\n \n-impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, ref items, .. }) = item.kind else {\n-            return;\n-        };\n-\n-        let self_ty = self.tcx.type_of(item.def_id);\n-        match *self_ty.kind() {\n-            ty::Adt(def, _) => {\n-                self.check_def_id(item, self_ty, def.did());\n-            }\n-            ty::Foreign(did) => {\n-                self.check_def_id(item, self_ty, did);\n-            }\n-            ty::Dynamic(data, ..) if data.principal_def_id().is_some() => {\n-                self.check_def_id(item, self_ty, data.principal_def_id().unwrap());\n-            }\n-            ty::Dynamic(..) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    ty.span,\n-                    E0785,\n-                    \"cannot define inherent `impl` for a dyn auto trait\"\n-                )\n-                .span_label(ty.span, \"impl requires at least one non-auto trait\")\n-                .note(\"define and implement a new trait or type instead\")\n-                .emit();\n-            }\n-            ty::Bool\n-            | ty::Char\n-            | ty::Int(_)\n-            | ty::Uint(_)\n-            | ty::Float(_)\n-            | ty::Str\n-            | ty::Array(..)\n-            | ty::Slice(_)\n-            | ty::RawPtr(_)\n-            | ty::Ref(..)\n-            | ty::Never\n-            | ty::Tuple(..) => self.check_primitive_impl(item.def_id, self_ty, items, ty.span),\n-            ty::FnPtr(_) | ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    ty.span,\n-                    E0118,\n-                    \"no nominal type found for inherent implementation\"\n-                );\n-\n-                err.span_label(ty.span, \"impl requires a nominal type\")\n-                    .note(\"either implement a trait on it or create a newtype to wrap it instead\");\n-\n-                err.emit();\n-            }\n-            ty::FnDef(..)\n-            | ty::Closure(..)\n-            | ty::Generator(..)\n-            | ty::GeneratorWitness(..)\n-            | ty::Bound(..)\n-            | ty::Placeholder(_)\n-            | ty::Infer(_) => {\n-                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.def_id, self_ty);\n-            }\n-            ty::Error(_) => {}\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {}\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n-}\n-\n const INTO_CORE: &str = \"consider moving this inherent impl into `core` if possible\";\n const INTO_DEFINING_CRATE: &str =\n     \"consider moving this inherent impl into the crate defining the type if possible\";\n@@ -246,4 +175,74 @@ impl<'tcx> InherentCollect<'tcx> {\n             bug!(\"unexpected primitive type: {:?}\", ty);\n         }\n     }\n+\n+    fn check_item(&mut self, id: hir::ItemId) {\n+        if !matches!(self.tcx.hir().def_kind(id.def_id), DefKind::Impl) {\n+            return;\n+        }\n+\n+        let item = self.tcx.hir().item(id);\n+        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, ref items, .. }) = item.kind else {\n+            return;\n+        };\n+\n+        let self_ty = self.tcx.type_of(item.def_id);\n+        match *self_ty.kind() {\n+            ty::Adt(def, _) => {\n+                self.check_def_id(item, self_ty, def.did());\n+            }\n+            ty::Foreign(did) => {\n+                self.check_def_id(item, self_ty, did);\n+            }\n+            ty::Dynamic(data, ..) if data.principal_def_id().is_some() => {\n+                self.check_def_id(item, self_ty, data.principal_def_id().unwrap());\n+            }\n+            ty::Dynamic(..) => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    ty.span,\n+                    E0785,\n+                    \"cannot define inherent `impl` for a dyn auto trait\"\n+                )\n+                .span_label(ty.span, \"impl requires at least one non-auto trait\")\n+                .note(\"define and implement a new trait or type instead\")\n+                .emit();\n+            }\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::Never\n+            | ty::Tuple(..) => self.check_primitive_impl(item.def_id, self_ty, items, ty.span),\n+            ty::FnPtr(_) | ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    ty.span,\n+                    E0118,\n+                    \"no nominal type found for inherent implementation\"\n+                );\n+\n+                err.span_label(ty.span, \"impl requires a nominal type\")\n+                    .note(\"either implement a trait on it or create a newtype to wrap it instead\");\n+\n+                err.emit();\n+            }\n+            ty::FnDef(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::Bound(..)\n+            | ty::Placeholder(_)\n+            | ty::Infer(_) => {\n+                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.def_id, self_ty);\n+            }\n+            ty::Error(_) => {}\n+        }\n+    }\n }"}, {"sha": "b9236d4024ecb01601be08adc18eeeee823838f5", "filename": "compiler/rustc_typeck/src/outlives/test.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs?ref=63849b6ecf03e2df98f65bd0e6e89a7d12986f9e", "patch": "@@ -8,7 +8,14 @@ pub fn test_inferred_outlives(tcx: TyCtxt<'_>) {\n         // attribute and report an error with various results if found.\n         if tcx.has_attr(id.def_id.to_def_id(), sym::rustc_outlives) {\n             let inferred_outlives_of = tcx.inferred_outlives_of(id.def_id);\n-            struct_span_err!(tcx.sess, tcx.hir().span(id.hir_id()), E0640, \"{:?}\", inferred_outlives_of).emit();\n+            struct_span_err!(\n+                tcx.sess,\n+                tcx.hir().span(id.hir_id()),\n+                E0640,\n+                \"{:?}\",\n+                inferred_outlives_of\n+            )\n+            .emit();\n         }\n     }\n }"}, {"sha": "590475fa03a3ea9947525e40cce3e2748a43fb81", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs?ref=63849b6ecf03e2df98f65bd0e6e89a7d12986f9e", "patch": "@@ -29,7 +29,7 @@ mod x {\n mod y {\n     use {Foo, Bar};\n \n-    #[rustc_then_this_would_need(typeck)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     pub fn call_bar() {\n         char::bar('a');\n     }"}, {"sha": "4e10437362c6ba0af51171037bd3c20f8419e289", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr?ref=63849b6ecf03e2df98f65bd0e6e89a7d12986f9e", "patch": "@@ -1,4 +1,4 @@\n-error: no path from `x::<impl Foo for char>` to `typeck`\n+error: OK\n   --> $DIR/dep-graph-trait-impl-two-traits.rs:32:5\n    |\n LL |     #[rustc_then_this_would_need(typeck)]"}]}