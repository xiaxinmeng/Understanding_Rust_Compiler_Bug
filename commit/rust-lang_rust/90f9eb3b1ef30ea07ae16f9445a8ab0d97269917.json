{"sha": "90f9eb3b1ef30ea07ae16f9445a8ab0d97269917", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZjllYjNiMWVmMzBlYTA3YWUxNmY5NDQ1YThhYjBkOTcyNjk5MTc=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-11-29T14:52:38Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-11-29T16:33:36Z"}, "message": "Removed a few macro-expanding-to-module workarounds\n\nAlso documented a few issues", "tree": {"sha": "1d6901495c610291d32b14765bc9d44444f7f6d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d6901495c610291d32b14765bc9d44444f7f6d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917", "html_url": "https://github.com/rust-lang/rust/commit/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf6964ecb67f4ffce6be75130ab7a3be793960ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf6964ecb67f4ffce6be75130ab7a3be793960ff", "html_url": "https://github.com/rust-lang/rust/commit/bf6964ecb67f4ffce6be75130ab7a3be793960ff"}], "stats": {"total": 328, "additions": 143, "deletions": 185}, "files": [{"sha": "2d37d82e172c644e8405964d58d18e707b46058e", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=90f9eb3b1ef30ea07ae16f9445a8ab0d97269917", "patch": "@@ -1036,31 +1036,26 @@ pub fn upperhex(buf: &[u8], f: &mut Formatter) {\n     f.pad_integral(local.slice_to(buf.len()), \"0x\", true);\n }\n \n-// FIXME(#4375) shouldn't need an inner module\n macro_rules! integer(($signed:ident, $unsigned:ident) => {\n-    mod $signed {\n-        use super::*;\n-\n-        // Signed is special because it actuall emits the negative sign,\n-        // nothing else should do that, however.\n-        impl Signed for $signed {\n-            fn fmt(c: &$signed, f: &mut Formatter) {\n-                ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10, |buf| {\n-                    f.pad_integral(buf, \"\", *c >= 0);\n-                })\n-            }\n+    // Signed is special because it actuall emits the negative sign,\n+    // nothing else should do that, however.\n+    impl Signed for $signed {\n+        fn fmt(c: &$signed, f: &mut Formatter) {\n+            ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10, |buf| {\n+                f.pad_integral(buf, \"\", *c >= 0);\n+            })\n         }\n-        int_base!($signed, $unsigned, 2, Binary, \"0b\")\n-        int_base!($signed, $unsigned, 8, Octal, \"0o\")\n-        int_base!($signed, $unsigned, 16, LowerHex, \"0x\")\n-        upper_hex!($signed, $unsigned)\n-\n-        int_base!($unsigned, $unsigned, 2, Binary, \"0b\")\n-        int_base!($unsigned, $unsigned, 8, Octal, \"0o\")\n-        int_base!($unsigned, $unsigned, 10, Unsigned, \"\")\n-        int_base!($unsigned, $unsigned, 16, LowerHex, \"0x\")\n-        upper_hex!($unsigned, $unsigned)\n     }\n+    int_base!($signed, $unsigned, 2, Binary, \"0b\")\n+    int_base!($signed, $unsigned, 8, Octal, \"0o\")\n+    int_base!($signed, $unsigned, 16, LowerHex, \"0x\")\n+    upper_hex!($signed, $unsigned)\n+\n+    int_base!($unsigned, $unsigned, 2, Binary, \"0b\")\n+    int_base!($unsigned, $unsigned, 8, Octal, \"0o\")\n+    int_base!($unsigned, $unsigned, 10, Unsigned, \"\")\n+    int_base!($unsigned, $unsigned, 16, LowerHex, \"0x\")\n+    upper_hex!($unsigned, $unsigned)\n })\n \n integer!(int, uint)"}, {"sha": "53bd2d3dc086547fec42e8d68f0b7a99f6c7ce7e", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=90f9eb3b1ef30ea07ae16f9445a8ab0d97269917", "patch": "@@ -11,18 +11,19 @@\n //! Operations and constants for `f32`\n #[allow(missing_doc)];\n \n+use prelude::*;\n+\n+use cmath::c_float_utils;\n use default::Default;\n-use libc::c_int;\n-use num::{Zero, One, strconv};\n+use libc::{c_float, c_int};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n+use num::{Zero, One, strconv};\n use num;\n-use prelude::*;\n use to_str;\n+use unstable::intrinsics;\n \n pub use cmath::c_float_targ_consts::*;\n \n-use self::delegated::*;\n-\n macro_rules! delegate(\n     (\n         $(\n@@ -33,22 +34,14 @@ macro_rules! delegate(\n             ) -> $rv:ty = $bound_name:path\n         ),*\n     ) => (\n-        // An inner module is required to get the #[inline] attribute on the\n-        // functions.\n-        mod delegated {\n-            use cmath::c_float_utils;\n-            use libc::{c_float, c_int};\n-            use unstable::intrinsics;\n-\n-            $(\n-                #[inline]\n-                pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n-                    unsafe {\n-                        $bound_name($( $arg ),*)\n-                    }\n+        $(\n+            #[inline]\n+            pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n+                unsafe {\n+                    $bound_name($( $arg ),*)\n                 }\n-            )*\n-        }\n+            }\n+        )*\n     )\n )\n "}, {"sha": "49b20b2c4f473be111aefa67766449465a6401a8", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=90f9eb3b1ef30ea07ae16f9445a8ab0d97269917", "patch": "@@ -12,19 +12,20 @@\n \n #[allow(missing_doc)];\n \n+use prelude::*;\n+\n+use cmath::c_double_utils;\n use default::Default;\n-use libc::c_int;\n-use num::{Zero, One, strconv};\n+use libc::{c_double, c_int};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n+use num::{Zero, One, strconv};\n use num;\n-use prelude::*;\n use to_str;\n+use unstable::intrinsics;\n \n pub use cmath::c_double_targ_consts::*;\n pub use cmp::{min, max};\n \n-use self::delegated::*;\n-\n macro_rules! delegate(\n     (\n         $(\n@@ -35,22 +36,14 @@ macro_rules! delegate(\n             ) -> $rv:ty = $bound_name:path\n         ),*\n     ) => (\n-        // An inner module is required to get the #[inline] attribute on the\n-        // functions.\n-        mod delegated {\n-            use cmath::c_double_utils;\n-            use libc::{c_double, c_int};\n-            use unstable::intrinsics;\n-\n-            $(\n-                #[inline]\n-                pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n-                    unsafe {\n-                        $bound_name($( $arg ),*)\n-                    }\n+        $(\n+            #[inline]\n+            pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n+                unsafe {\n+                    $bound_name($( $arg ),*)\n                 }\n-            )*\n-        }\n+            }\n+        )*\n     )\n )\n "}, {"sha": "42f0ed95d1e0f191d19b5911f4021193f1081920", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=90f9eb3b1ef30ea07ae16f9445a8ab0d97269917", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME(#4375): this shouldn't have to be a nested module named 'generated'\n+// FIXME(#4375):  This shouldn't have to be a nested module named 'generated'...\n+// FIXME(#10716): ... but now that we could solve that, the import lines and\n+//                attributes still prevent a removal of that module.\n \n #[macro_escape];\n #[doc(hidden)];"}, {"sha": "0a21aa9fcc8a892cbe60a9e39fb3f4e19a0c0596", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=90f9eb3b1ef30ea07ae16f9445a8ab0d97269917", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME(#4375): this shouldn't have to be a nested module named 'generated'\n+// FIXME(#4375):  This shouldn't have to be a nested module named 'generated'...\n+// FIXME(#10716): ... but now that we could solve that, the import lines and\n+//                attributes still prevent a removal of that module.\n \n #[macro_escape];\n #[doc(hidden)];"}, {"sha": "313fd9c79b46a6768c5eb074503225f98545e1c6", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 89, "deletions": 95, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=90f9eb3b1ef30ea07ae16f9445a8ab0d97269917", "patch": "@@ -13,8 +13,9 @@\n #[allow(missing_doc)];\n \n use clone::Clone;\n-\n-pub use self::inner::*;\n+#[cfg(not(test))] use cmp::*;\n+#[cfg(not(test))] use default::Default;\n+#[cfg(not(test))] use num::Zero;\n \n /// Method extensions to pairs where both types satisfy the `Clone` bound\n pub trait CopyableTuple<T, U> {\n@@ -86,116 +87,109 @@ macro_rules! tuple_impls {\n             })+\n         }\n     )+) => {\n-        pub mod inner {\n-            use clone::Clone;\n-            #[cfg(not(test))] use cmp::*;\n-            #[cfg(not(test))] use default::Default;\n-            #[cfg(not(test))] use num::Zero;\n-\n-            $(\n-                pub trait $move_trait<$($T),+> {\n-                    $(fn $get_fn(self) -> $T;)+\n-                }\n+        $(\n+            pub trait $move_trait<$($T),+> {\n+                $(fn $get_fn(self) -> $T;)+\n+            }\n \n-                impl<$($T),+> $move_trait<$($T),+> for ($($T,)+) {\n-                    $(\n-                        #[inline]\n-                        fn $get_fn(self) -> $T {\n-                            let $move_pattern = self;\n-                            $ret\n-                        }\n-                    )+\n-                }\n-\n-                pub trait $immutable_trait<$($T),+> {\n-                    $(fn $get_ref_fn<'a>(&'a self) -> &'a $T;)+\n-                }\n+            impl<$($T),+> $move_trait<$($T),+> for ($($T,)+) {\n+                $(\n+                    #[inline]\n+                    fn $get_fn(self) -> $T {\n+                        let $move_pattern = self;\n+                        $ret\n+                    }\n+                )+\n+            }\n \n-                impl<$($T),+> $immutable_trait<$($T),+> for ($($T,)+) {\n-                    $(\n-                        #[inline]\n-                        fn $get_ref_fn<'a>(&'a self) -> &'a $T {\n-                            let $ref_pattern = *self;\n-                            $ret\n-                        }\n-                    )+\n-                }\n+            pub trait $immutable_trait<$($T),+> {\n+                $(fn $get_ref_fn<'a>(&'a self) -> &'a $T;)+\n+            }\n \n-                impl<$($T:Clone),+> Clone for ($($T,)+) {\n-                    fn clone(&self) -> ($($T,)+) {\n-                        ($(self.$get_ref_fn().clone(),)+)\n+            impl<$($T),+> $immutable_trait<$($T),+> for ($($T,)+) {\n+                $(\n+                    #[inline]\n+                    fn $get_ref_fn<'a>(&'a self) -> &'a $T {\n+                        let $ref_pattern = *self;\n+                        $ret\n                     }\n+                )+\n+            }\n+\n+            impl<$($T:Clone),+> Clone for ($($T,)+) {\n+                fn clone(&self) -> ($($T,)+) {\n+                    ($(self.$get_ref_fn().clone(),)+)\n                 }\n+            }\n \n-                #[cfg(not(test))]\n-                impl<$($T:Eq),+> Eq for ($($T,)+) {\n-                    #[inline]\n-                    fn eq(&self, other: &($($T,)+)) -> bool {\n-                        $(*self.$get_ref_fn() == *other.$get_ref_fn())&&+\n-                    }\n-                    #[inline]\n-                    fn ne(&self, other: &($($T,)+)) -> bool {\n-                        $(*self.$get_ref_fn() != *other.$get_ref_fn())||+\n-                    }\n+            #[cfg(not(test))]\n+            impl<$($T:Eq),+> Eq for ($($T,)+) {\n+                #[inline]\n+                fn eq(&self, other: &($($T,)+)) -> bool {\n+                    $(*self.$get_ref_fn() == *other.$get_ref_fn())&&+\n+                }\n+                #[inline]\n+                fn ne(&self, other: &($($T,)+)) -> bool {\n+                    $(*self.$get_ref_fn() != *other.$get_ref_fn())||+\n                 }\n+            }\n \n-                #[cfg(not(test))]\n-                impl<$($T:TotalEq),+> TotalEq for ($($T,)+) {\n-                    #[inline]\n-                    fn equals(&self, other: &($($T,)+)) -> bool {\n-                        $(self.$get_ref_fn().equals(other.$get_ref_fn()))&&+\n-                    }\n+            #[cfg(not(test))]\n+            impl<$($T:TotalEq),+> TotalEq for ($($T,)+) {\n+                #[inline]\n+                fn equals(&self, other: &($($T,)+)) -> bool {\n+                    $(self.$get_ref_fn().equals(other.$get_ref_fn()))&&+\n                 }\n+            }\n \n-                #[cfg(not(test))]\n-                impl<$($T:Ord + Eq),+> Ord for ($($T,)+) {\n-                    #[inline]\n-                    fn lt(&self, other: &($($T,)+)) -> bool {\n-                        lexical_ord!(lt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n-                    }\n-                    #[inline]\n-                    fn le(&self, other: &($($T,)+)) -> bool {\n-                        lexical_ord!(le, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n-                    }\n-                    #[inline]\n-                    fn ge(&self, other: &($($T,)+)) -> bool {\n-                        lexical_ord!(ge, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n-                    }\n-                    #[inline]\n-                    fn gt(&self, other: &($($T,)+)) -> bool {\n-                        lexical_ord!(gt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n-                    }\n+            #[cfg(not(test))]\n+            impl<$($T:Ord + Eq),+> Ord for ($($T,)+) {\n+                #[inline]\n+                fn lt(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(lt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                }\n+                #[inline]\n+                fn le(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(le, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                }\n+                #[inline]\n+                fn ge(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(ge, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                 }\n+                #[inline]\n+                fn gt(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(gt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                }\n+            }\n \n-                #[cfg(not(test))]\n-                impl<$($T:TotalOrd),+> TotalOrd for ($($T,)+) {\n-                    #[inline]\n-                    fn cmp(&self, other: &($($T,)+)) -> Ordering {\n-                        lexical_cmp!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n-                    }\n+            #[cfg(not(test))]\n+            impl<$($T:TotalOrd),+> TotalOrd for ($($T,)+) {\n+                #[inline]\n+                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n+                    lexical_cmp!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                 }\n+            }\n \n-                #[cfg(not(test))]\n-                impl<$($T:Default),+> Default for ($($T,)+) {\n-                    #[inline]\n-                    fn default() -> ($($T,)+) {\n-                        ($({ let x: $T = Default::default(); x},)+)\n-                    }\n+            #[cfg(not(test))]\n+            impl<$($T:Default),+> Default for ($($T,)+) {\n+                #[inline]\n+                fn default() -> ($($T,)+) {\n+                    ($({ let x: $T = Default::default(); x},)+)\n                 }\n+            }\n \n-                #[cfg(not(test))]\n-                impl<$($T:Zero),+> Zero for ($($T,)+) {\n-                    #[inline]\n-                    fn zero() -> ($($T,)+) {\n-                        ($({ let x: $T = Zero::zero(); x},)+)\n-                    }\n-                    #[inline]\n-                    fn is_zero(&self) -> bool {\n-                        $(self.$get_ref_fn().is_zero())&&+\n-                    }\n+            #[cfg(not(test))]\n+            impl<$($T:Zero),+> Zero for ($($T,)+) {\n+                #[inline]\n+                fn zero() -> ($($T,)+) {\n+                    ($({ let x: $T = Zero::zero(); x},)+)\n                 }\n-            )+\n-        }\n+                #[inline]\n+                fn is_zero(&self) -> bool {\n+                    $(self.$get_ref_fn().is_zero())&&+\n+                }\n+            }\n+        )+\n     }\n }\n "}, {"sha": "293c9ed98172865ec51461bbcc9c197aa93bd95d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f9eb3b1ef30ea07ae16f9445a8ab0d97269917/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=90f9eb3b1ef30ea07ae16f9445a8ab0d97269917", "patch": "@@ -2463,15 +2463,14 @@ impl<A> Default for @[A] {\n }\n \n macro_rules! iterator {\n-    /* FIXME: #4375 Cannot attach documentation/attributes to a macro generated struct.\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n+        /// An iterator for iterating over a vector.\n         pub struct $name<'self, T> {\n             priv ptr: $ptr,\n             priv end: $ptr,\n-            priv lifetime: $elem // FIXME: #5922\n+            priv lifetime: Option<$elem> // FIXME: #5922\n         }\n-    };*/\n-    (impl $name:ident -> $elem:ty) => {\n+\n         impl<'self, T> Iterator<$elem> for $name<'self, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n@@ -2502,11 +2501,7 @@ macro_rules! iterator {\n                 (exact, Some(exact))\n             }\n         }\n-    }\n-}\n \n-macro_rules! double_ended_iterator {\n-    (impl $name:ident -> $elem:ty) => {\n         impl<'self, T> DoubleEndedIterator<$elem> for $name<'self, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -2548,15 +2543,7 @@ impl<'self, T> RandomAccessIterator<&'self T> for VecIterator<'self, T> {\n     }\n }\n \n-//iterator!{struct VecIterator -> *T, &'self T}\n-/// An iterator for iterating over a vector.\n-pub struct VecIterator<'self, T> {\n-    priv ptr: *T,\n-    priv end: *T,\n-    priv lifetime: Option<&'self ()> // FIXME: #5922\n-}\n-iterator!{impl VecIterator -> &'self T}\n-double_ended_iterator!{impl VecIterator -> &'self T}\n+iterator!{struct VecIterator -> *T, &'self T}\n pub type RevIterator<'self, T> = Invert<VecIterator<'self, T>>;\n \n impl<'self, T> ExactSize<&'self T> for VecIterator<'self, T> {}\n@@ -2566,15 +2553,7 @@ impl<'self, T> Clone for VecIterator<'self, T> {\n     fn clone(&self) -> VecIterator<'self, T> { *self }\n }\n \n-//iterator!{struct VecMutIterator -> *mut T, &'self mut T}\n-/// An iterator for mutating the elements of a vector.\n-pub struct VecMutIterator<'self, T> {\n-    priv ptr: *mut T,\n-    priv end: *mut T,\n-    priv lifetime: Option<&'self mut ()> // FIXME: #5922\n-}\n-iterator!{impl VecMutIterator -> &'self mut T}\n-double_ended_iterator!{impl VecMutIterator -> &'self mut T}\n+iterator!{struct VecMutIterator -> *mut T, &'self mut T}\n pub type MutRevIterator<'self, T> = Invert<VecMutIterator<'self, T>>;\n \n /// An iterator that moves out of a vector."}]}