{"sha": "8f031bf96205ed4cb990c2c7aded84d5ac079254", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMDMxYmY5NjIwNWVkNGNiOTkwYzJjN2FkZWQ4NGQ1YWMwNzkyNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-15T01:18:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-15T01:18:01Z"}, "message": "Auto merge of #30105 - faineance:master, r=nrc\n\nIssue: #30058\nUpdated for:\n - Stmt\n - BinOp_\n - UnOp\n - UintTy, IntTy and FloatTy\n - Lit\n - Generics\n\nA possible inconsistancy?\nThe `Stmt` methods are on the spanned varient:\n```rust\npub type Stmt = Spanned<Stmt_>;\n\nimpl Stmt {\n    pub fn id(s: &Stmt) -> Option<NodeId> {\n        match s.node {\n          StmtDecl(_, id) => Some(id),\n          StmtExpr(_, id) => Some(id),\n          StmtSemi(_, id) => Some(id),\n          StmtMac(..) => None,\n      }\n  }\n}\n```\nWhilst the methods for BinOp are on the non spanned version.\n````rust\nimpl BinOp_ {\n    pub fn to_string(op: BinOp_) -> &'static str { ... }\n    pub fn lazy(b: BinOp_) -> bool { ... }\n\n    pub fn is_shift(b: BinOp_) -> bool { ... }\n    pub fn is_comparison(b: BinOp_) -> bool { ... }\n    /// Returns `true` if the binary operator takes its arguments by value\n    pub fn is_by_value(b: BinOp_) -> bool { ... }\n\n}\npub type BinOp = Spanned<BinOp_>;\n````\nr? @Manishearth", "tree": {"sha": "0d8942d514c60919c8e6855926ed7252d2e227ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d8942d514c60919c8e6855926ed7252d2e227ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f031bf96205ed4cb990c2c7aded84d5ac079254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f031bf96205ed4cb990c2c7aded84d5ac079254", "html_url": "https://github.com/rust-lang/rust/commit/8f031bf96205ed4cb990c2c7aded84d5ac079254", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f031bf96205ed4cb990c2c7aded84d5ac079254/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44d9601ad3b388df34b7e7b9a1a1bfed32b4bce9", "url": "https://api.github.com/repos/rust-lang/rust/commits/44d9601ad3b388df34b7e7b9a1a1bfed32b4bce9", "html_url": "https://github.com/rust-lang/rust/commit/44d9601ad3b388df34b7e7b9a1a1bfed32b4bce9"}, {"sha": "ec8ea22c7f59fd898670060bceb6810cef68ca0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec8ea22c7f59fd898670060bceb6810cef68ca0a", "html_url": "https://github.com/rust-lang/rust/commit/ec8ea22c7f59fd898670060bceb6810cef68ca0a"}], "stats": {"total": 383, "additions": 191, "deletions": 192}, "files": [{"sha": "7b4347459e6f00cfb25f6256856ad07450fa246c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8f031bf96205ed4cb990c2c7aded84d5ac079254", "patch": "@@ -24,7 +24,7 @@ use middle::ty::{self, TypeAndMut, Ty, HasTypeFlags};\n use middle::ty::fold::TypeFoldable;\n \n use std::fmt;\n-use syntax::{abi, ast_util};\n+use syntax::{abi};\n use syntax::parse::token;\n use syntax::ast::CRATE_NODE_ID;\n use rustc_front::hir;\n@@ -778,9 +778,9 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n         match *self {\n             TyBool => write!(f, \"bool\"),\n             TyChar => write!(f, \"char\"),\n-            TyInt(t) => write!(f, \"{}\", ast_util::int_ty_to_string(t)),\n-            TyUint(t) => write!(f, \"{}\", ast_util::uint_ty_to_string(t)),\n-            TyFloat(t) => write!(f, \"{}\", ast_util::float_ty_to_string(t)),\n+            TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n+            TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n+            TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n             TyBox(typ) => write!(f, \"Box<{}>\",  typ),\n             TyRawPtr(ref tm) => {\n                 write!(f, \"*{} {}\", match tm.mutbl {"}, {"sha": "5284971f2c21929e52867780fce2004ef0afdd45", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=8f031bf96205ed4cb990c2c7aded84d5ac079254", "patch": "@@ -46,7 +46,7 @@ use std::rc::Rc;\n use syntax;\n use syntax::util::interner::Interner;\n use syntax::codemap::Span;\n-use syntax::{ast, ast_util, codemap};\n+use syntax::{ast, codemap};\n use syntax::parse::token;\n \n \n@@ -936,13 +936,13 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyBool => (\"bool\", DW_ATE_boolean),\n         ty::TyChar => (\"char\", DW_ATE_unsigned_char),\n         ty::TyInt(int_ty) => {\n-            (ast_util::int_ty_to_string(int_ty), DW_ATE_signed)\n+            (int_ty.ty_to_string(), DW_ATE_signed)\n         },\n         ty::TyUint(uint_ty) => {\n-            (ast_util::uint_ty_to_string(uint_ty), DW_ATE_unsigned)\n+            (uint_ty.ty_to_string(), DW_ATE_unsigned)\n         },\n         ty::TyFloat(float_ty) => {\n-            (ast_util::float_ty_to_string(float_ty), DW_ATE_float)\n+            (float_ty.ty_to_string(), DW_ATE_float)\n         },\n         _ => cx.sess().bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };"}, {"sha": "518a78f8fd4c7752941776521e372a72eaa029d0", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=8f031bf96205ed4cb990c2c7aded84d5ac079254", "patch": "@@ -19,7 +19,6 @@ use middle::subst::{self, Substs};\n use middle::ty::{self, Ty};\n \n use rustc_front::hir;\n-use syntax::ast_util;\n \n // Compute the name of the type as it should be stored in debuginfo. Does not do\n // any caching, i.e. calling the function twice with the same type will also do\n@@ -44,9 +43,9 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyBool => output.push_str(\"bool\"),\n         ty::TyChar => output.push_str(\"char\"),\n         ty::TyStr => output.push_str(\"str\"),\n-        ty::TyInt(int_ty) => output.push_str(ast_util::int_ty_to_string(int_ty)),\n-        ty::TyUint(uint_ty) => output.push_str(ast_util::uint_ty_to_string(uint_ty)),\n-        ty::TyFloat(float_ty) => output.push_str(ast_util::float_ty_to_string(float_ty)),\n+        ty::TyInt(int_ty) => output.push_str(int_ty.ty_to_string()),\n+        ty::TyUint(uint_ty) => output.push_str(uint_ty.ty_to_string()),\n+        ty::TyFloat(float_ty) => output.push_str(float_ty.ty_to_string()),\n         ty::TyStruct(def, substs) |\n         ty::TyEnum(def, substs) => {\n             push_item_name(cx, def.did, qualified, output);"}, {"sha": "d2cbb9892f6a60834390a242125d8b0c26c14179", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=8f031bf96205ed4cb990c2c7aded84d5ac079254", "patch": "@@ -83,7 +83,7 @@ use trans::type_::Type;\n use rustc_front;\n use rustc_front::hir;\n \n-use syntax::{ast, ast_util, codemap};\n+use syntax::{ast, codemap};\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::parse::token;\n@@ -2622,7 +2622,7 @@ fn expr_kind(tcx: &ty::ctxt, expr: &hir::Expr) -> ExprKind {\n             ExprKind::RvalueDps\n         }\n \n-        hir::ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {\n+        hir::ExprLit(ref lit) if lit.node.is_str() => {\n             ExprKind::RvalueDps\n         }\n "}, {"sha": "b56846327c3b0e23e8261b1a9708b91ca595d417", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 161, "deletions": 5, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8f031bf96205ed4cb990c2c7aded84d5ac079254", "patch": "@@ -48,7 +48,6 @@ pub use self::PathParameters::*;\n use attr::ThinAttributes;\n use codemap::{Span, Spanned, DUMMY_SP, ExpnId};\n use abi::Abi;\n-use ast_util;\n use ext::base;\n use ext::tt::macro_parser;\n use owned_slice::OwnedSlice;\n@@ -427,6 +426,19 @@ impl Generics {\n     }\n }\n \n+impl Default for Generics {\n+    fn default() ->  Generics {\n+        Generics {\n+            lifetimes: Vec::new(),\n+            ty_params: OwnedSlice::empty(),\n+            where_clause: WhereClause {\n+                id: DUMMY_NODE_ID,\n+                predicates: Vec::new(),\n+            }\n+        }\n+    }\n+}\n+\n /// A `where` clause in a definition\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {\n@@ -657,6 +669,57 @@ pub enum BinOp_ {\n     BiGt,\n }\n \n+impl BinOp_ {\n+    pub fn to_string(&self) -> &'static str {\n+        match *self {\n+            BiAdd => \"+\",\n+            BiSub => \"-\",\n+            BiMul => \"*\",\n+            BiDiv => \"/\",\n+            BiRem => \"%\",\n+            BiAnd => \"&&\",\n+            BiOr => \"||\",\n+            BiBitXor => \"^\",\n+            BiBitAnd => \"&\",\n+            BiBitOr => \"|\",\n+            BiShl => \"<<\",\n+            BiShr => \">>\",\n+            BiEq => \"==\",\n+            BiLt => \"<\",\n+            BiLe => \"<=\",\n+            BiNe => \"!=\",\n+            BiGe => \">=\",\n+            BiGt => \">\"\n+        }\n+    }\n+    pub fn lazy(&self) -> bool {\n+        match *self {\n+            BiAnd | BiOr => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_shift(&self) -> bool {\n+        match *self {\n+            BiShl | BiShr => true,\n+            _ => false\n+        }\n+    }\n+    pub fn is_comparison(&self) -> bool {\n+        match *self {\n+            BiEq | BiLt | BiLe | BiNe | BiGt | BiGe =>\n+            true,\n+            BiAnd | BiOr | BiAdd | BiSub | BiMul | BiDiv | BiRem |\n+            BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr =>\n+            false,\n+        }\n+    }\n+    /// Returns `true` if the binary operator takes its arguments by value\n+    pub fn is_by_value(&self) -> bool {\n+        !BinOp_::is_comparison(self)\n+    }\n+}\n+\n pub type BinOp = Spanned<BinOp_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -669,13 +732,31 @@ pub enum UnOp {\n     UnNeg\n }\n \n+impl UnOp {\n+    /// Returns `true` if the unary operator takes its argument by value\n+    pub fn is_by_value(u: UnOp) -> bool {\n+        match u {\n+            UnNeg | UnNot => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn to_string(op: UnOp) -> &'static str {\n+        match op {\n+            UnDeref => \"*\",\n+            UnNot => \"!\",\n+            UnNeg => \"-\",\n+        }\n+    }\n+}\n+\n /// A statement\n pub type Stmt = Spanned<Stmt_>;\n \n impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"stmt({}: {})\",\n-               ast_util::stmt_id(self)\n+               self.node.id()\n                    .map_or(Cow::Borrowed(\"<macro>\"),|id|Cow::Owned(id.to_string())),\n                pprust::stmt_to_string(self))\n     }\n@@ -697,6 +778,15 @@ pub enum Stmt_ {\n }\n \n impl Stmt_ {\n+    pub fn id(&self) -> Option<NodeId> {\n+        match *self {\n+            StmtDecl(_, id) => Some(id),\n+            StmtExpr(_, id) => Some(id),\n+            StmtSemi(_, id) => Some(id),\n+            StmtMac(..) => None,\n+        }\n+    }\n+\n     pub fn attrs(&self) -> &[Attribute] {\n         match *self {\n             StmtDecl(ref d, _) => d.attrs(),\n@@ -1226,6 +1316,16 @@ pub enum Lit_ {\n     LitBool(bool),\n }\n \n+impl Lit_ {\n+    /// Returns true if this literal is a string and false otherwise.\n+    pub fn is_str(&self) -> bool {\n+        match *self {\n+            LitStr(..) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1301,11 +1401,37 @@ impl fmt::Debug for IntTy {\n \n impl fmt::Display for IntTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", ast_util::int_ty_to_string(*self))\n+        write!(f, \"{}\", self.ty_to_string())\n     }\n }\n \n impl IntTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            TyIs => \"isize\",\n+            TyI8 => \"i8\",\n+            TyI16 => \"i16\",\n+            TyI32 => \"i32\",\n+            TyI64 => \"i64\"\n+        }\n+    }\n+\n+    pub fn val_to_string(&self, val: i64) -> String {\n+        // cast to a u64 so we can correctly print INT64_MIN. All integral types\n+        // are parsed as u64, so we wouldn't want to print an extra negative\n+        // sign.\n+        format!(\"{}{}\", val as u64, self.ty_to_string())\n+    }\n+\n+    pub fn ty_max(&self) -> u64 {\n+        match *self {\n+            TyI8 => 0x80,\n+            TyI16 => 0x8000,\n+            TyIs | TyI32 => 0x80000000, // actually ni about TyIs\n+            TyI64 => 0x8000000000000000\n+        }\n+    }\n+\n     pub fn bit_width(&self) -> Option<usize> {\n         Some(match *self {\n             TyIs => return None,\n@@ -1327,6 +1453,29 @@ pub enum UintTy {\n }\n \n impl UintTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            TyUs => \"usize\",\n+            TyU8 => \"u8\",\n+            TyU16 => \"u16\",\n+            TyU32 => \"u32\",\n+            TyU64 => \"u64\"\n+        }\n+    }\n+\n+    pub fn val_to_string(&self, val: u64) -> String {\n+        format!(\"{}{}\", val, self.ty_to_string())\n+    }\n+\n+    pub fn ty_max(&self) -> u64 {\n+        match *self {\n+            TyU8 => 0xff,\n+            TyU16 => 0xffff,\n+            TyUs | TyU32 => 0xffffffff, // actually ni about TyUs\n+            TyU64 => 0xffffffffffffffff\n+        }\n+    }\n+\n     pub fn bit_width(&self) -> Option<usize> {\n         Some(match *self {\n             TyUs => return None,\n@@ -1346,7 +1495,7 @@ impl fmt::Debug for UintTy {\n \n impl fmt::Display for UintTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", ast_util::uint_ty_to_string(*self))\n+        write!(f, \"{}\", self.ty_to_string())\n     }\n }\n \n@@ -1364,11 +1513,18 @@ impl fmt::Debug for FloatTy {\n \n impl fmt::Display for FloatTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", ast_util::float_ty_to_string(*self))\n+        write!(f, \"{}\", self.ty_to_string())\n     }\n }\n \n impl FloatTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            TyF32 => \"f32\",\n+            TyF64 => \"f64\",\n+        }\n+    }\n+\n     pub fn bit_width(&self) -> usize {\n         match *self {\n             TyF32 => 32,"}, {"sha": "3d3d53477494d2baf584568289e8fa751c8510ec", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 155, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8f031bf96205ed4cb990c2c7aded84d5ac079254", "patch": "@@ -10,7 +10,6 @@\n \n use ast::*;\n use ast;\n-use ast_util;\n use codemap;\n use codemap::Span;\n use owned_slice::OwnedSlice;\n@@ -28,144 +27,10 @@ pub fn path_name_i(idents: &[Ident]) -> String {\n     idents.iter().map(|i| i.to_string()).collect::<Vec<String>>().join(\"::\")\n }\n \n-pub fn stmt_id(s: &Stmt) -> Option<NodeId> {\n-    match s.node {\n-      StmtDecl(_, id) => Some(id),\n-      StmtExpr(_, id) => Some(id),\n-      StmtSemi(_, id) => Some(id),\n-      StmtMac(..) => None,\n-    }\n-}\n-\n-pub fn binop_to_string(op: BinOp_) -> &'static str {\n-    match op {\n-        BiAdd => \"+\",\n-        BiSub => \"-\",\n-        BiMul => \"*\",\n-        BiDiv => \"/\",\n-        BiRem => \"%\",\n-        BiAnd => \"&&\",\n-        BiOr => \"||\",\n-        BiBitXor => \"^\",\n-        BiBitAnd => \"&\",\n-        BiBitOr => \"|\",\n-        BiShl => \"<<\",\n-        BiShr => \">>\",\n-        BiEq => \"==\",\n-        BiLt => \"<\",\n-        BiLe => \"<=\",\n-        BiNe => \"!=\",\n-        BiGe => \">=\",\n-        BiGt => \">\"\n-    }\n-}\n-\n-pub fn lazy_binop(b: BinOp_) -> bool {\n-    match b {\n-      BiAnd => true,\n-      BiOr => true,\n-      _ => false\n-    }\n-}\n-\n-pub fn is_shift_binop(b: BinOp_) -> bool {\n-    match b {\n-      BiShl => true,\n-      BiShr => true,\n-      _ => false\n-    }\n-}\n-\n-pub fn is_comparison_binop(b: BinOp_) -> bool {\n-    match b {\n-        BiEq | BiLt | BiLe | BiNe | BiGt | BiGe =>\n-            true,\n-        BiAnd | BiOr | BiAdd | BiSub | BiMul | BiDiv | BiRem |\n-        BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr =>\n-            false,\n-    }\n-}\n-\n-/// Returns `true` if the binary operator takes its arguments by value\n-pub fn is_by_value_binop(b: BinOp_) -> bool {\n-    !is_comparison_binop(b)\n-}\n-\n-/// Returns `true` if the unary operator takes its argument by value\n-pub fn is_by_value_unop(u: UnOp) -> bool {\n-    match u {\n-        UnNeg | UnNot => true,\n-        _ => false,\n-    }\n-}\n-\n-pub fn unop_to_string(op: UnOp) -> &'static str {\n-    match op {\n-        UnDeref => \"*\",\n-        UnNot => \"!\",\n-        UnNeg => \"-\",\n-    }\n-}\n-\n pub fn is_path(e: P<Expr>) -> bool {\n     match e.node { ExprPath(..) => true, _ => false }\n }\n \n-pub fn int_ty_to_string(t: IntTy) -> &'static str {\n-    match t {\n-        TyIs => \"isize\",\n-        TyI8 => \"i8\",\n-        TyI16 => \"i16\",\n-        TyI32 => \"i32\",\n-        TyI64 => \"i64\"\n-    }\n-}\n-\n-pub fn int_val_to_string(t: IntTy, val: i64) -> String {\n-    // cast to a u64 so we can correctly print INT64_MIN. All integral types\n-    // are parsed as u64, so we wouldn't want to print an extra negative\n-    // sign.\n-    format!(\"{}{}\", val as u64, int_ty_to_string(t))\n-}\n-\n-pub fn int_ty_max(t: IntTy) -> u64 {\n-    match t {\n-        TyI8 => 0x80,\n-        TyI16 => 0x8000,\n-        TyIs | TyI32 => 0x80000000, // actually ni about TyIs\n-        TyI64 => 0x8000000000000000\n-    }\n-}\n-\n-pub fn uint_ty_to_string(t: UintTy) -> &'static str {\n-    match t {\n-        TyUs => \"usize\",\n-        TyU8 => \"u8\",\n-        TyU16 => \"u16\",\n-        TyU32 => \"u32\",\n-        TyU64 => \"u64\"\n-    }\n-}\n-\n-pub fn uint_val_to_string(t: UintTy, val: u64) -> String {\n-    format!(\"{}{}\", val, uint_ty_to_string(t))\n-}\n-\n-pub fn uint_ty_max(t: UintTy) -> u64 {\n-    match t {\n-        TyU8 => 0xff,\n-        TyU16 => 0xffff,\n-        TyUs | TyU32 => 0xffffffff, // actually ni about TyUs\n-        TyU64 => 0xffffffffffffffff\n-    }\n-}\n-\n-pub fn float_ty_to_string(t: FloatTy) -> &'static str {\n-    match t {\n-        TyF32 => \"f32\",\n-        TyF64 => \"f64\",\n-    }\n-}\n \n // convert a span and an identifier to the corresponding\n // 1-segment path\n@@ -236,17 +101,6 @@ pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n     }\n }\n \n-pub fn empty_generics() -> Generics {\n-    Generics {\n-        lifetimes: Vec::new(),\n-        ty_params: OwnedSlice::empty(),\n-        where_clause: WhereClause {\n-            id: DUMMY_NODE_ID,\n-            predicates: Vec::new(),\n-        }\n-    }\n-}\n-\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n@@ -351,7 +205,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n \n     fn visit_stmt(&mut self, statement: &Stmt) {\n         self.operation\n-            .visit_id(ast_util::stmt_id(statement).expect(\"attempted to visit unexpanded stmt\"));\n+            .visit_id(statement.node.id().expect(\"attempted to visit unexpanded stmt\"));\n         visit::walk_stmt(self, statement)\n     }\n \n@@ -519,14 +373,6 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n     })\n }\n \n-/// Returns true if this literal is a string and false otherwise.\n-pub fn lit_is_str(lit: &Lit) -> bool {\n-    match lit.node {\n-        LitStr(..) => true,\n-        _ => false,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use ast::*;"}, {"sha": "cdc9cb024530d8b578f6ca483fd897913fae49fc", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8f031bf96205ed4cb990c2c7aded84d5ac079254", "patch": "@@ -11,7 +11,6 @@\n use abi;\n use ast::{Ident, Generics, Expr};\n use ast;\n-use ast_util;\n use attr;\n use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n use ext::base::ExtCtxt;\n@@ -991,7 +990,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             name,\n             inputs,\n             output,\n-            ast_util::empty_generics(),\n+            Generics::default(),\n             body)\n     }\n \n@@ -1029,7 +1028,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn item_enum(&self, span: Span, name: Ident,\n                  enum_definition: ast::EnumDef) -> P<ast::Item> {\n         self.item_enum_poly(span, name, enum_definition,\n-                            ast_util::empty_generics())\n+                            Generics::default())\n     }\n \n     fn item_struct(&self, span: Span, name: Ident,\n@@ -1038,7 +1037,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             span,\n             name,\n             struct_def,\n-            ast_util::empty_generics()\n+            Generics::default()\n         )\n     }\n \n@@ -1086,7 +1085,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item> {\n-        self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n+        self.item_ty_poly(span, name, ty, Generics::default())\n     }\n \n     fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute {"}, {"sha": "9398f1a5733359921d477316398f917a245cff10", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8f031bf96205ed4cb990c2c7aded84d5ac079254", "patch": "@@ -2872,7 +2872,7 @@ impl<'a> Parser<'a> {\n     fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: &AssocOp) {\n         debug_assert!(outer_op.is_comparison());\n         match lhs.node {\n-            ExprBinary(op, _, _) if ast_util::is_comparison_binop(op.node) => {\n+            ExprBinary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n                 let op_span = mk_sp(op.span.lo, self.span.hi);\n                 self.span_err(op_span,\n@@ -4000,7 +4000,7 @@ impl<'a> Parser<'a> {\n                 }\n             })\n         } else {\n-            Ok(ast_util::empty_generics())\n+            Ok(ast::Generics::default())\n         }\n     }\n "}, {"sha": "0be62bc0a7f0860a54f5f5ce313df3aae1f90ee3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8f031bf96205ed4cb990c2c7aded84d5ac079254", "patch": "@@ -15,7 +15,6 @@ use ast::{self, TokenTree};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n use attr::ThinAttributesExt;\n-use ast_util;\n use util::parser::AssocOp;\n use attr;\n use owned_slice::OwnedSlice;\n@@ -649,15 +648,15 @@ pub trait PrintState<'a> {\n                 match t {\n                     ast::SignedIntLit(st, ast::Plus) => {\n                         word(self.writer(),\n-                             &ast_util::int_val_to_string(st, i as i64))\n+                             &st.val_to_string(i as i64))\n                     }\n                     ast::SignedIntLit(st, ast::Minus) => {\n-                        let istr = ast_util::int_val_to_string(st, -(i as i64));\n+                        let istr = st.val_to_string(-(i as i64));\n                         word(self.writer(),\n                              &format!(\"-{}\", istr))\n                     }\n                     ast::UnsignedIntLit(ut) => {\n-                        word(self.writer(), &ast_util::uint_val_to_string(ut, i))\n+                        word(self.writer(), &ut.val_to_string(i))\n                     }\n                     ast::UnsuffixedIntLit(ast::Plus) => {\n                         word(self.writer(), &format!(\"{}\", i))\n@@ -672,7 +671,7 @@ pub trait PrintState<'a> {\n                      &format!(\n                          \"{}{}\",\n                          &f,\n-                         &ast_util::float_ty_to_string(t)))\n+                         t.ty_to_string()))\n             }\n             ast::LitFloatUnsuffixed(ref f) => word(self.writer(), &f[..]),\n             ast::LitBool(val) => {\n@@ -1528,7 +1527,7 @@ impl<'a> State<'a> {\n \n     pub fn print_variant(&mut self, v: &ast::Variant) -> io::Result<()> {\n         try!(self.head(\"\"));\n-        let generics = ast_util::empty_generics();\n+        let generics = ast::Generics::default();\n         try!(self.print_struct(&v.node.data, &generics, v.node.name, v.span, false));\n         match v.node.disr_expr {\n             Some(ref d) => {\n@@ -1948,7 +1947,7 @@ impl<'a> State<'a> {\n             try!(self.print_expr(lhs));\n         }\n         try!(space(&mut self.s));\n-        try!(self.word_space(ast_util::binop_to_string(op.node)));\n+        try!(self.word_space(op.node.to_string()));\n         if self.check_expr_bin_needs_paren(rhs, op) {\n             self.print_expr_maybe_paren(rhs)\n         } else {\n@@ -1959,7 +1958,7 @@ impl<'a> State<'a> {\n     fn print_expr_unary(&mut self,\n                         op: ast::UnOp,\n                         expr: &ast::Expr) -> io::Result<()> {\n-        try!(word(&mut self.s, ast_util::unop_to_string(op)));\n+        try!(word(&mut self.s, ast::UnOp::to_string(op)));\n         self.print_expr_maybe_paren(expr)\n     }\n \n@@ -2151,7 +2150,7 @@ impl<'a> State<'a> {\n             ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n-                try!(word(&mut self.s, ast_util::binop_to_string(op.node)));\n+                try!(word(&mut self.s, op.node.to_string()));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**rhs));\n             }\n@@ -3159,7 +3158,7 @@ mod tests {\n             output: ast::DefaultReturn(codemap::DUMMY_SP),\n             variadic: false\n         };\n-        let generics = ast_util::empty_generics();\n+        let generics = ast::Generics::default();\n         assert_eq!(fun_to_string(&decl, ast::Unsafety::Normal,\n                                  ast::Constness::NotConst,\n                                  abba_ident,"}, {"sha": "63fbe284a09fd6f4f0e9e0d057d0c2ef2859c8bc", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f031bf96205ed4cb990c2c7aded84d5ac079254/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=8f031bf96205ed4cb990c2c7aded84d5ac079254", "patch": "@@ -500,7 +500,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let main = ast::ItemFn(ecx.fn_decl(vec![], main_ret_ty),\n                            ast::Unsafety::Normal,\n                            ast::Constness::NotConst,\n-                           ::abi::Rust, empty_generics(), main_body);\n+                           ::abi::Rust, ast::Generics::default(), main_body);\n     let main = P(ast::Item {\n         ident: token::str_to_ident(\"main\"),\n         attrs: vec![main_attr],"}]}