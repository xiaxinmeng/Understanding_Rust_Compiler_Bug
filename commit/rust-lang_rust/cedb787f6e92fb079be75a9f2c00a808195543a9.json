{"sha": "cedb787f6e92fb079be75a9f2c00a808195543a9", "node_id": "C_kwDOAAsO6NoAKGNlZGI3ODdmNmU5MmZiMDc5YmU3NWE5ZjJjMDBhODA4MTk1NTQzYTk", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-18T21:56:24Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-20T23:08:29Z"}, "message": "Remove `MatcherPosHandle`.\n\nThis type was a small performance win for `html5ever`, which uses a\nmacro with hundreds of very simple rules that don't contain any\nmetavariables. But this type is complicated (extra lifetimes) and\nperf-neutral for macros that do have metavariables.\n\nThis commit removes `MatcherPosHandle`, simplifying things a lot. This\nincreases the allocation rate for `html5ever` and similar cases a bit,\nbut makes things easier for follow-up changes that will improve\nperformance more than what we lost here.", "tree": {"sha": "f17811b81d3d8f033da7f4f000b8aa52a5e5d97e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f17811b81d3d8f033da7f4f000b8aa52a5e5d97e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cedb787f6e92fb079be75a9f2c00a808195543a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cedb787f6e92fb079be75a9f2c00a808195543a9", "html_url": "https://github.com/rust-lang/rust/commit/cedb787f6e92fb079be75a9f2c00a808195543a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cedb787f6e92fb079be75a9f2c00a808195543a9/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10644e0789a3c722e11f74968f24c1382f9ccb11", "url": "https://api.github.com/repos/rust-lang/rust/commits/10644e0789a3c722e11f74968f24c1382f9ccb11", "html_url": "https://github.com/rust-lang/rust/commit/10644e0789a3c722e11f74968f24c1382f9ccb11"}], "stats": {"total": 111, "additions": 23, "deletions": 88}, "files": [{"sha": "14b3f720f83a14b35d6e6a8b0e85342323e9e9af", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cedb787f6e92fb079be75a9f2c00a808195543a9/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cedb787f6e92fb079be75a9f2c00a808195543a9/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=cedb787f6e92fb079be75a9f2c00a808195543a9", "patch": "@@ -1,5 +1,6 @@\n #![feature(associated_type_bounds)]\n #![feature(associated_type_defaults)]\n+#![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(if_let_guard)]"}, {"sha": "267b468ca99674332f0359b6073376c0adcd29d8", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 22, "deletions": 88, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/cedb787f6e92fb079be75a9f2c00a808195543a9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cedb787f6e92fb079be75a9f2c00a808195543a9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=cedb787f6e92fb079be75a9f2c00a808195543a9", "patch": "@@ -89,7 +89,6 @@ use rustc_span::symbol::Ident;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem;\n-use std::ops::{Deref, DerefMut};\n \n // To avoid costly uniqueness checks, we require that `MatchSeq` always has a nonempty body.\n \n@@ -136,24 +135,8 @@ type NamedMatchVec = SmallVec<[NamedMatch; 4]>;\n \n /// Represents a single \"position\" (aka \"matcher position\", aka \"item\"), as\n /// described in the module documentation.\n-///\n-/// Here:\n-///\n-/// - `'root` represents the lifetime of the stack slot that holds the root\n-///   `MatcherPos`. As described in `MatcherPosHandle`, the root `MatcherPos`\n-///   structure is stored on the stack, but subsequent instances are put into\n-///   the heap.\n-/// - `'tt` represents the lifetime of the token trees that this matcher\n-///   position refers to.\n-///\n-/// It is important to distinguish these two lifetimes because we have a\n-/// `SmallVec<TokenTreeOrTokenTreeSlice<'tt>>` below, and the destructor of\n-/// that is considered to possibly access the data from its elements (it lacks\n-/// a `#[may_dangle]` attribute). As a result, the compiler needs to know that\n-/// all the elements in that `SmallVec` strictly outlive the root stack slot\n-/// lifetime. By separating `'tt` from `'root`, we can show that.\n #[derive(Clone)]\n-struct MatcherPos<'root, 'tt> {\n+struct MatcherPos<'tt> {\n     /// The token or slice of tokens that make up the matcher. `elts` is short for \"elements\".\n     top_elts: TokenTreeOrTokenTreeSlice<'tt>,\n \n@@ -185,7 +168,7 @@ struct MatcherPos<'root, 'tt> {\n     match_hi: usize,\n \n     /// This field is only used if we are matching a repetition.\n-    repetition: Option<MatcherPosRepetition<'root, 'tt>>,\n+    repetition: Option<MatcherPosRepetition<'tt>>,\n \n     /// Specifically used to \"unzip\" token trees. By \"unzip\", we mean to unwrap the delimiters from\n     /// a delimited token tree (e.g., something wrapped in `(` `)`) or to get the contents of a doc\n@@ -200,9 +183,9 @@ struct MatcherPos<'root, 'tt> {\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MatcherPos<'_, '_>, 240);\n+rustc_data_structures::static_assert_size!(MatcherPos<'_>, 232);\n \n-impl<'root, 'tt> MatcherPos<'root, 'tt> {\n+impl<'tt> MatcherPos<'tt> {\n     /// `len` `Vec`s (initially shared and empty) that will store matches of metavars.\n     fn create_matches(len: usize) -> Box<[Lrc<NamedMatchVec>]> {\n         if len == 0 {\n@@ -241,11 +224,7 @@ impl<'root, 'tt> MatcherPos<'root, 'tt> {\n         }\n     }\n \n-    fn repetition(\n-        up: MatcherPosHandle<'root, 'tt>,\n-        sp: DelimSpan,\n-        seq: Lrc<SequenceRepetition>,\n-    ) -> Self {\n+    fn repetition(up: Box<MatcherPos<'tt>>, sp: DelimSpan, seq: Lrc<SequenceRepetition>) -> Self {\n         MatcherPos {\n             stack: smallvec![],\n             idx: 0,\n@@ -270,7 +249,7 @@ impl<'root, 'tt> MatcherPos<'root, 'tt> {\n }\n \n #[derive(Clone)]\n-struct MatcherPosRepetition<'root, 'tt> {\n+struct MatcherPosRepetition<'tt> {\n     /// The KleeneOp of this sequence.\n     seq_op: mbe::KleeneOp,\n \n@@ -279,55 +258,12 @@ struct MatcherPosRepetition<'root, 'tt> {\n \n     /// The \"parent\" matcher position. That is, the matcher position just before we enter the\n     /// sequence.\n-    up: MatcherPosHandle<'root, 'tt>,\n-}\n-\n-// Lots of MatcherPos instances are created at runtime. Allocating them on the\n-// heap is slow. Furthermore, using SmallVec<MatcherPos> to allocate them all\n-// on the stack is also slow, because MatcherPos is quite a large type and\n-// instances get moved around a lot between vectors, which requires lots of\n-// slow memcpy calls.\n-//\n-// Therefore, the initial MatcherPos is always allocated on the stack,\n-// subsequent ones (of which there aren't that many) are allocated on the heap,\n-// and this type is used to encapsulate both cases.\n-enum MatcherPosHandle<'root, 'tt> {\n-    Ref(&'root mut MatcherPos<'root, 'tt>),\n-    Box(Box<MatcherPos<'root, 'tt>>),\n+    up: Box<MatcherPos<'tt>>,\n }\n \n-impl<'root, 'tt> Clone for MatcherPosHandle<'root, 'tt> {\n-    // This always produces a new Box.\n-    fn clone(&self) -> Self {\n-        MatcherPosHandle::Box(match *self {\n-            MatcherPosHandle::Ref(ref r) => Box::new((**r).clone()),\n-            MatcherPosHandle::Box(ref b) => b.clone(),\n-        })\n-    }\n-}\n-\n-impl<'root, 'tt> Deref for MatcherPosHandle<'root, 'tt> {\n-    type Target = MatcherPos<'root, 'tt>;\n-    fn deref(&self) -> &Self::Target {\n-        match *self {\n-            MatcherPosHandle::Ref(ref r) => r,\n-            MatcherPosHandle::Box(ref b) => b,\n-        }\n-    }\n-}\n-\n-impl<'root, 'tt> DerefMut for MatcherPosHandle<'root, 'tt> {\n-    fn deref_mut(&mut self) -> &mut MatcherPos<'root, 'tt> {\n-        match *self {\n-            MatcherPosHandle::Ref(ref mut r) => r,\n-            MatcherPosHandle::Box(ref mut b) => b,\n-        }\n-    }\n-}\n-\n-enum EofItems<'root, 'tt> {\n+enum EofItems<'tt> {\n     None,\n-    One(MatcherPosHandle<'root, 'tt>),\n+    One(Box<MatcherPos<'tt>>),\n     Multiple,\n }\n \n@@ -494,6 +430,10 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n \n pub struct TtParser {\n     macro_name: Ident,\n+\n+    cur_items: Vec<Box<MatcherPos<'tt>>>,\n+    next_items: Vec<Box<MatcherPos<'tt>>>,\n+    bb_items: Vec<Box<MatcherPos<'tt>>>,\n }\n \n impl TtParser {\n@@ -520,13 +460,13 @@ impl TtParser {\n     ///\n     /// `Some(result)` if everything is finished, `None` otherwise. Note that matches are kept\n     /// track of through the items generated.\n-    fn parse_tt_inner<'root, 'tt>(\n+    fn parse_tt_inner<'tt>(\n         &self,\n         sess: &ParseSess,\n         ms: &[TokenTree],\n-        cur_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-        next_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-        bb_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n+        cur_items: &mut SmallVec<[Box<MatcherPos<'tt>>; 1]>,\n+        next_items: &mut SmallVec<[Box<MatcherPos<'tt>>; 1]>,\n+        bb_items: &mut SmallVec<[Box<MatcherPos<'tt>>; 1]>,\n         token: &Token,\n     ) -> Option<NamedParseResult> {\n         // Matcher positions that would be valid if the macro invocation was over now. Only\n@@ -570,9 +510,7 @@ impl TtParser {\n                         }\n \n                         // Allow for the possibility of one or more matches of this sequence.\n-                        cur_items.push(MatcherPosHandle::Box(Box::new(MatcherPos::repetition(\n-                            item, sp, seq,\n-                        ))));\n+                        cur_items.push(box MatcherPos::repetition(item, sp, seq));\n                     }\n \n                     TokenTree::MetaVarDecl(span, _, None) => {\n@@ -706,11 +644,7 @@ impl TtParser {\n         // `parse_tt_inner` then processes all of these possible matcher positions and produces\n         // possible next positions into `next_items`. After some post-processing, the contents of\n         // `next_items` replenish `cur_items` and we start over again.\n-        //\n-        // This MatcherPos instance is allocated on the stack. All others -- and there are\n-        // frequently *no* others! -- are allocated on the heap.\n-        let mut initial = MatcherPos::new(ms);\n-        let mut cur_items = smallvec![MatcherPosHandle::Ref(&mut initial)];\n+        let mut cur_items = smallvec![box MatcherPos::new(ms)];\n \n         loop {\n             let mut next_items = SmallVec::new();\n@@ -793,10 +727,10 @@ impl TtParser {\n         }\n     }\n \n-    fn ambiguity_error<'root, 'tt>(\n+    fn ambiguity_error<'tt>(\n         &self,\n-        next_items: SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-        bb_items: SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n+        next_items: SmallVec<[Box<MatcherPos<'tt>>; 1]>,\n+        bb_items: SmallVec<[Box<MatcherPos<'tt>>; 1]>,\n         token_span: rustc_span::Span,\n     ) -> NamedParseResult {\n         let nts = bb_items"}]}