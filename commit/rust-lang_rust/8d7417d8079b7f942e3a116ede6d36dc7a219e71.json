{"sha": "8d7417d8079b7f942e3a116ede6d36dc7a219e71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNzQxN2Q4MDc5YjdmOTQyZTNhMTE2ZWRlNmQzNmRjN2EyMTllNzE=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-01-11T04:32:23Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-01-11T04:32:23Z"}, "message": "Add: single_match will suggest using if .. == .. instead of if let when applicable", "tree": {"sha": "4559c5088287a8e31ec212b81518fdb18ec98102", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4559c5088287a8e31ec212b81518fdb18ec98102"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d7417d8079b7f942e3a116ede6d36dc7a219e71", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAl/71NoACgkQ2lnoZDo37QZw8wD6AoE4bpyvPRCvppU0+2EokSUp\ne+7pSHQiNr9jaTO0YE0BALBu2HSTdQmj1XS5zUIKt8CkA1tkqjxd4jsxBstBkWQA\n=ZyUA\n-----END PGP SIGNATURE-----", "payload": "tree 4559c5088287a8e31ec212b81518fdb18ec98102\nparent 2950c8e1cb32e864b599c4b4dae896d29d86e5e7\nauthor Jason Newcomb <jsnewcomb@pm.me> 1610339543 -0500\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1610339543 -0500\n\nAdd: single_match will suggest using if .. == .. instead of if let when applicable\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d7417d8079b7f942e3a116ede6d36dc7a219e71", "html_url": "https://github.com/rust-lang/rust/commit/8d7417d8079b7f942e3a116ede6d36dc7a219e71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d7417d8079b7f942e3a116ede6d36dc7a219e71/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2950c8e1cb32e864b599c4b4dae896d29d86e5e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2950c8e1cb32e864b599c4b4dae896d29d86e5e7", "html_url": "https://github.com/rust-lang/rust/commit/2950c8e1cb32e864b599c4b4dae896d29d86e5e7"}], "stats": {"total": 160, "additions": 146, "deletions": 14}, "files": [{"sha": "2239b519632b2e0aaa48a98d74c3ad8fcebe4d32", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 66, "deletions": 13, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8d7417d8079b7f942e3a116ede6d36dc7a219e71/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7417d8079b7f942e3a116ede6d36dc7a219e71/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=8d7417d8079b7f942e3a116ede6d36dc7a219e71", "patch": "@@ -2,10 +2,10 @@ use crate::consts::{constant, miri_to_const, Constant};\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::is_unused;\n use crate::utils::{\n-    expr_block, get_arg_name, get_parent_expr, in_macro, indent_of, is_allowed, is_expn_of, is_refutable,\n-    is_type_diagnostic_item, is_wild, match_qpath, match_type, match_var, meets_msrv, multispan_sugg, remove_blocks,\n-    snippet, snippet_block, snippet_opt, snippet_with_applicability, span_lint_and_help, span_lint_and_note,\n-    span_lint_and_sugg, span_lint_and_then,\n+    expr_block, get_arg_name, get_parent_expr, implements_trait, in_macro, indent_of, is_allowed, is_expn_of,\n+    is_refutable, is_type_diagnostic_item, is_wild, match_qpath, match_type, match_var, meets_msrv, multispan_sugg,\n+    remove_blocks, snippet, snippet_block, snippet_opt, snippet_with_applicability, span_lint_and_help,\n+    span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n use crate::utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n@@ -717,6 +717,28 @@ fn check_single_match_single_pattern(\n     }\n }\n \n+fn peel_pat_refs(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n+    fn peel(pat: &'a Pat<'a>, count: usize) -> (&'a Pat<'a>, usize) {\n+        if let PatKind::Ref(pat, _) = pat.kind {\n+            peel(pat, count + 1)\n+        } else {\n+            (pat, count)\n+        }\n+    }\n+    peel(pat, 0)\n+}\n+\n+fn peel_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n+    fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n+        if let ty::Ref(_, ty, _) = ty.kind() {\n+            peel(ty, count + 1)\n+        } else {\n+            (ty, count)\n+        }\n+    }\n+    peel(ty, 0)\n+}\n+\n fn report_single_match_single_pattern(\n     cx: &LateContext<'_>,\n     ex: &Expr<'_>,\n@@ -728,20 +750,51 @@ fn report_single_match_single_pattern(\n     let els_str = els.map_or(String::new(), |els| {\n         format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n     });\n+\n+    let (msg, sugg) = if_chain! {\n+        let (pat, pat_ref_count) = peel_pat_refs(arms[0].pat);\n+        if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n+        let (ty, ty_ref_count) = peel_ty_refs(cx.typeck_results().expr_ty(ex));\n+        if let Some(trait_id) = cx.tcx.lang_items().structural_peq_trait();\n+        if ty.is_integral() || ty.is_char() || ty.is_str() || implements_trait(cx, ty, trait_id, &[]);\n+        then {\n+            // scrutinee derives PartialEq and the pattern is a constant.\n+            let pat_ref_count = match pat.kind {\n+                // string literals are already a reference.\n+                PatKind::Lit(Expr { kind: ExprKind::Lit(lit), .. }) if lit.node.is_str() => pat_ref_count + 1,\n+                _ => pat_ref_count,\n+            };\n+            let msg = \"you seem to be trying to use match for an equality check. Consider using `if`\";\n+            let sugg = format!(\n+                \"if {} == {}{} {}{}\",\n+                snippet(cx, ex.span, \"..\"),\n+                // PartialEq for different reference counts may not exist.\n+                \"&\".repeat(ty_ref_count - pat_ref_count),\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        } else {\n+            let msg = \"you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\";\n+            let sugg = format!(\n+                \"if let {} = {} {}{}\",\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                snippet(cx, ex.span, \"..\"),\n+                expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        }\n+    };\n+\n     span_lint_and_sugg(\n         cx,\n         lint,\n         expr.span,\n-        \"you seem to be trying to use match for destructuring a single pattern. Consider using `if \\\n-         let`\",\n+        msg,\n         \"try this\",\n-        format!(\n-            \"if let {} = {} {}{}\",\n-            snippet(cx, arms[0].pat.span, \"..\"),\n-            snippet(cx, ex.span, \"..\"),\n-            expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n-            els_str,\n-        ),\n+        sugg,\n         Applicability::HasPlaceholders,\n     );\n }"}, {"sha": "02266308fba2837aad1b130d34439b4037aed60a", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8d7417d8079b7f942e3a116ede6d36dc7a219e71/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7417d8079b7f942e3a116ede6d36dc7a219e71/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=8d7417d8079b7f942e3a116ede6d36dc7a219e71", "patch": "@@ -81,6 +81,49 @@ fn single_match_know_enum() {\n     }\n }\n \n+fn issue_173() {\n+    let x = \"test\";\n+    match x {\n+        \"test\" => println!(),\n+        _ => (),\n+    }\n+\n+    #[derive(PartialEq, Eq)]\n+    enum Foo {\n+        A,\n+        B,\n+        C(u32),\n+    }\n+\n+    let x = Foo::A;\n+    match x {\n+        Foo::A => println!(),\n+        _ => (),\n+    }\n+\n+    const FOO_C: Foo = Foo::C(0);\n+    match x {\n+        FOO_C => println!(),\n+        _ => (),\n+    }\n+    enum Bar {\n+        A,\n+        B,\n+    }\n+    impl PartialEq for Bar {\n+        fn eq(&self, rhs: &Self) -> bool {\n+            matches!((self, rhs), (Self::A, Self::A) | (Self::B, Self::B))\n+        }\n+    }\n+    impl Eq for Bar {}\n+\n+    let x = Bar::A;\n+    match x {\n+        Bar::A => println!(),\n+        _ => (),\n+    }\n+}\n+\n macro_rules! single_match {\n     ($num:literal) => {\n         match $num {"}, {"sha": "5eca07ab10957561c77719f905b615d2f5c6b40f", "filename": "tests/ui/single_match.stderr", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8d7417d8079b7f942e3a116ede6d36dc7a219e71/tests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d7417d8079b7f942e3a116ede6d36dc7a219e71/tests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.stderr?ref=8d7417d8079b7f942e3a116ede6d36dc7a219e71", "patch": "@@ -65,5 +65,41 @@ LL | |         Cow::Owned(..) => (),\n LL | |     };\n    | |_____^ help: try this: `if let Cow::Borrowed(..) = c { dummy() }`\n \n-error: aborting due to 6 previous errors\n+error: you seem to be trying to use match for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:86:5\n+   |\n+LL | /     match x {\n+LL | |         \"test\" => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == \"test\" { println!() }`\n+\n+error: you seem to be trying to use match for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:99:5\n+   |\n+LL | /     match x {\n+LL | |         Foo::A => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == Foo::A { println!() }`\n+\n+error: you seem to be trying to use match for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:105:5\n+   |\n+LL | /     match x {\n+LL | |         FOO_C => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == FOO_C { println!() }`\n+\n+error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:121:5\n+   |\n+LL | /     match x {\n+LL | |         Bar::A => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if let Bar::A = x { println!() }`\n+\n+error: aborting due to 10 previous errors\n "}]}