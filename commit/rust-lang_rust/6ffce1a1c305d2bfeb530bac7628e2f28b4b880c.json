{"sha": "6ffce1a1c305d2bfeb530bac7628e2f28b4b880c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmZmNlMWExYzMwNWQyYmZlYjUzMGJhYzc2MjhlMmYyOGI0Yjg4MGM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-04T20:49:37Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-04T20:50:02Z"}, "message": "De-export extfmt. Part of #3583.", "tree": {"sha": "aedcfd71100fbafff3b1cee979e05d83265cc183", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aedcfd71100fbafff3b1cee979e05d83265cc183"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ffce1a1c305d2bfeb530bac7628e2f28b4b880c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ffce1a1c305d2bfeb530bac7628e2f28b4b880c", "html_url": "https://github.com/rust-lang/rust/commit/6ffce1a1c305d2bfeb530bac7628e2f28b4b880c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ffce1a1c305d2bfeb530bac7628e2f28b4b880c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a06b90322cb4b61a3a20e12ab3406cff809c586c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a06b90322cb4b61a3a20e12ab3406cff809c586c", "html_url": "https://github.com/rust-lang/rust/commit/a06b90322cb4b61a3a20e12ab3406cff809c586c"}], "stats": {"total": 139, "additions": 69, "deletions": 70}, "files": [{"sha": "d59eabb22c14c9409961f988167dbf7a2f9543b7", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ffce1a1c305d2bfeb530bac7628e2f28b4b880c/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6ffce1a1c305d2bfeb530bac7628e2f28b4b880c/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=6ffce1a1c305d2bfeb530bac7628e2f28b4b880c", "patch": "@@ -246,7 +246,6 @@ pub mod reflect;\n // Modules supporting compiler-generated code\n // Exported but not part of the public interface\n \n-#[legacy_exports]\n pub mod extfmt;\n // The test harness links against core, so don't include runtime in tests.\n #[cfg(notest)]"}, {"sha": "6bcf260a72906b842f1294fe997440856d814b1c", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6ffce1a1c305d2bfeb530bac7628e2f28b4b880c/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ffce1a1c305d2bfeb530bac7628e2f28b4b880c/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=6ffce1a1c305d2bfeb530bac7628e2f28b4b880c", "patch": "@@ -41,11 +41,10 @@ use option::{Some, None};\n  */\n \n // Functions used by the fmt extension at compile time\n-mod ct {\n-    #[legacy_exports];\n-    enum Signedness { Signed, Unsigned, }\n-    enum Caseness { CaseUpper, CaseLower, }\n-    enum Ty {\n+pub mod ct {\n+    pub enum Signedness { Signed, Unsigned, }\n+    pub enum Caseness { CaseUpper, CaseLower, }\n+    pub enum Ty {\n         TyBool,\n         TyStr,\n         TyChar,\n@@ -56,22 +55,22 @@ mod ct {\n         TyFloat,\n         TyPoly,\n     }\n-    enum Flag {\n+    pub enum Flag {\n         FlagLeftJustify,\n         FlagLeftZeroPad,\n         FlagSpaceForSign,\n         FlagSignAlways,\n         FlagAlternate,\n     }\n-    enum Count {\n+    pub enum Count {\n         CountIs(int),\n         CountIsParam(int),\n         CountIsNextParam,\n         CountImplied,\n     }\n \n     // A formatted conversion from an expression to a string\n-    type Conv =\n+    pub type Conv =\n         {param: Option<int>,\n          flags: ~[Flag],\n          width: Count,\n@@ -80,10 +79,10 @@ mod ct {\n \n \n     // A fragment of the output sequence\n-    enum Piece { PieceString(~str), PieceConv(Conv), }\n-    type ErrorFn = fn@(&str) -> ! ;\n+    pub enum Piece { PieceString(~str), PieceConv(Conv), }\n+    pub type ErrorFn = fn@(&str) -> ! ;\n \n-    fn parse_fmt_string(s: &str, error: ErrorFn) -> ~[Piece] {\n+    pub fn parse_fmt_string(s: &str, error: ErrorFn) -> ~[Piece] {\n         let mut pieces: ~[Piece] = ~[];\n         let lim = str::len(s);\n         let mut buf = ~\"\";\n@@ -118,7 +117,7 @@ mod ct {\n         flush_buf(move buf, &mut pieces);\n         move pieces\n     }\n-    fn peek_num(s: &str, i: uint, lim: uint) ->\n+    pub fn peek_num(s: &str, i: uint, lim: uint) ->\n        Option<{num: uint, next: uint}> {\n         let mut j = i;\n         let mut accum = 0u;\n@@ -140,7 +139,8 @@ mod ct {\n             None\n         }\n     }\n-    fn parse_conversion(s: &str, i: uint, lim: uint, error: ErrorFn) ->\n+    pub fn parse_conversion(s: &str, i: uint, lim: uint,\n+                            error: ErrorFn) ->\n        {piece: Piece, next: uint} {\n         let parm = parse_parameter(s, i, lim);\n         let flags = parse_flags(s, parm.next, lim);\n@@ -155,7 +155,7 @@ mod ct {\n                              ty: ty.ty}),\n              next: ty.next};\n     }\n-    fn parse_parameter(s: &str, i: uint, lim: uint) ->\n+    pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n        {param: Option<int>, next: uint} {\n         if i >= lim { return {param: None, next: i}; }\n         let num = peek_num(s, i, lim);\n@@ -170,7 +170,7 @@ mod ct {\n               }\n             };\n     }\n-    fn parse_flags(s: &str, i: uint, lim: uint) ->\n+    pub fn parse_flags(s: &str, i: uint, lim: uint) ->\n        {flags: ~[Flag], next: uint} {\n         let noflags: ~[Flag] = ~[];\n         if i >= lim { return {flags: move noflags, next: i}; }\n@@ -198,7 +198,7 @@ mod ct {\n                 more(FlagAlternate, s, i, lim)\n             } else { {flags: move noflags, next: i} };\n     }\n-    fn parse_count(s: &str, i: uint, lim: uint)\n+    pub fn parse_count(s: &str, i: uint, lim: uint)\n         -> {count: Count, next: uint} {\n         return if i >= lim {\n                 {count: CountImplied, next: i}\n@@ -220,7 +220,7 @@ mod ct {\n                 }\n             };\n     }\n-    fn parse_precision(s: &str, i: uint, lim: uint) ->\n+    pub fn parse_precision(s: &str, i: uint, lim: uint) ->\n        {count: Count, next: uint} {\n         return if i >= lim {\n                 {count: CountImplied, next: i}\n@@ -236,7 +236,7 @@ mod ct {\n                 }\n             } else { {count: CountImplied, next: i} };\n     }\n-    fn parse_type(s: &str, i: uint, lim: uint, error: ErrorFn) ->\n+    pub fn parse_type(s: &str, i: uint, lim: uint, error: ErrorFn) ->\n        {ty: Ty, next: uint} {\n         if i >= lim { error(~\"missing type in conversion\"); }\n         let tstr = str::slice(s, i, i+1u);\n@@ -274,21 +274,20 @@ mod ct {\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it 0this way, I think.\n-mod rt {\n-    #[legacy_exports];\n-    const flag_none : u32 = 0u32;\n-    const flag_left_justify   : u32 = 0b00000000000000000000000000000001u32;\n-    const flag_left_zero_pad  : u32 = 0b00000000000000000000000000000010u32;\n-    const flag_space_for_sign : u32 = 0b00000000000000000000000000000100u32;\n-    const flag_sign_always    : u32 = 0b00000000000000000000000000001000u32;\n-    const flag_alternate      : u32 = 0b00000000000000000000000000010000u32;\n+pub mod rt {\n+    pub const flag_none : u32 = 0u32;\n+    pub const flag_left_justify   : u32 = 0b00000000000001u32;\n+    pub const flag_left_zero_pad  : u32 = 0b00000000000010u32;\n+    pub const flag_space_for_sign : u32 = 0b00000000000100u32;\n+    pub const flag_sign_always    : u32 = 0b00000000001000u32;\n+    pub const flag_alternate      : u32 = 0b00000000010000u32;\n \n-    enum Count { CountIs(int), CountImplied, }\n-    enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n+    pub enum Count { CountIs(int), CountImplied, }\n+    pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n \n-    type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n+    pub type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n \n-    pure fn conv_int(cv: Conv, i: int) -> ~str {\n+    pub pure fn conv_int(cv: Conv, i: int) -> ~str {\n         let radix = 10;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n@@ -301,7 +300,7 @@ mod rt {\n         }\n         return unsafe { pad(cv, s, PadSigned) };\n     }\n-    pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n+    pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             match cv.ty {\n@@ -313,17 +312,17 @@ mod rt {\n             };\n         return unsafe { pad(cv, rs, PadUnsigned) };\n     }\n-    pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n+    pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         return conv_str(cv, s);\n     }\n-    pure fn conv_char(cv: Conv, c: char) -> ~str {\n+    pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n         return unsafe { pad(cv, s, PadNozero) };\n     }\n-    pure fn conv_str(cv: Conv, s: &str) -> ~str {\n+    pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n@@ -336,7 +335,7 @@ mod rt {\n         };\n         return unsafe { pad(cv, unpadded, PadNozero) };\n     }\n-    pure fn conv_float(cv: Conv, f: float) -> ~str {\n+    pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str, 6u)\n@@ -351,14 +350,14 @@ mod rt {\n         }\n         return unsafe { pad(cv, s, PadFloat) };\n     }\n-    pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n+    pub pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n         let s = sys::log_str(v);\n         return conv_str(cv, s);\n     }\n \n     // Convert an int to string with minimum number of digits. If precision is\n     // 0 and num is 0 then the result is the empty string.\n-    pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n+    pub pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n         return if num < 0 {\n                 ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n             } else { uint_to_str_prec(num as uint, radix, prec) };\n@@ -367,7 +366,8 @@ mod rt {\n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n-    pure fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n+    pub pure fn uint_to_str_prec(num: uint, radix: uint,\n+                                 prec: uint) -> ~str {\n         return if prec == 0u && num == 0u {\n                 ~\"\"\n             } else {\n@@ -380,16 +380,16 @@ mod rt {\n                 } else { move s }\n             };\n     }\n-    pure fn get_int_precision(cv: Conv) -> uint {\n+    pub pure fn get_int_precision(cv: Conv) -> uint {\n         return match cv.precision {\n               CountIs(c) => c as uint,\n               CountImplied => 1u\n             };\n     }\n \n-    enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n+    pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n-    impl PadMode : Eq {\n+    pub impl PadMode : Eq {\n         pure fn eq(other: &PadMode) -> bool {\n             match (self, (*other)) {\n                 (PadSigned, PadSigned) => true,\n@@ -405,7 +405,7 @@ mod rt {\n         pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n     }\n \n-    fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n+    pub fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n         let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n           CountImplied => return s,\n@@ -458,7 +458,7 @@ mod rt {\n         }\n         return padstr + s;\n     }\n-    pure fn have_flag(flags: u32, f: u32) -> bool {\n+    pub pure fn have_flag(flags: u32, f: u32) -> bool {\n         flags & f != 0\n     }\n }\n@@ -469,21 +469,21 @@ mod rt {\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it 0this way, I think.\n-mod rt2 {\n-    #[legacy_exports];\n-    const flag_none : u32 = 0u32;\n-    const flag_left_justify   : u32 = 0b00000000000000000000000000000001u32;\n-    const flag_left_zero_pad  : u32 = 0b00000000000000000000000000000010u32;\n-    const flag_space_for_sign : u32 = 0b00000000000000000000000000000100u32;\n-    const flag_sign_always    : u32 = 0b00000000000000000000000000001000u32;\n-    const flag_alternate      : u32 = 0b00000000000000000000000000010000u32;\n+pub mod rt2 {\n \n-    enum Count { CountIs(int), CountImplied, }\n-    enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n+    pub const flag_none : u32 = 0u32;\n+    pub const flag_left_justify   : u32 = 0b00000000000001u32;\n+    pub const flag_left_zero_pad  : u32 = 0b00000000000010u32;\n+    pub const flag_space_for_sign : u32 = 0b00000000000100u32;\n+    pub const flag_sign_always    : u32 = 0b00000000001000u32;\n+    pub const flag_alternate      : u32 = 0b00000000010000u32;\n \n-    type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n+    pub enum Count { CountIs(int), CountImplied, }\n+    pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n \n-    pure fn conv_int(cv: Conv, i: int) -> ~str {\n+    pub type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n+\n+    pub pure fn conv_int(cv: Conv, i: int) -> ~str {\n         let radix = 10;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n@@ -496,7 +496,7 @@ mod rt2 {\n         }\n         return unsafe { pad(cv, s, PadSigned) };\n     }\n-    pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n+    pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             match cv.ty {\n@@ -508,17 +508,17 @@ mod rt2 {\n             };\n         return unsafe { pad(cv, rs, PadUnsigned) };\n     }\n-    pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n+    pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         return conv_str(cv, s);\n     }\n-    pure fn conv_char(cv: Conv, c: char) -> ~str {\n+    pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n         return unsafe { pad(cv, s, PadNozero) };\n     }\n-    pure fn conv_str(cv: Conv, s: &str) -> ~str {\n+    pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n@@ -531,7 +531,7 @@ mod rt2 {\n         };\n         return unsafe { pad(cv, unpadded, PadNozero) };\n     }\n-    pure fn conv_float(cv: Conv, f: float) -> ~str {\n+    pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str, 6u)\n@@ -546,14 +546,14 @@ mod rt2 {\n         }\n         return unsafe { pad(cv, s, PadFloat) };\n     }\n-    pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n+    pub pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n         let s = sys::log_str(v);\n         return conv_str(cv, s);\n     }\n \n     // Convert an int to string with minimum number of digits. If precision is\n     // 0 and num is 0 then the result is the empty string.\n-    pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n+    pub pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n         return if num < 0 {\n                 ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n             } else { uint_to_str_prec(num as uint, radix, prec) };\n@@ -562,7 +562,8 @@ mod rt2 {\n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n-    pure fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n+    pub pure fn uint_to_str_prec(num: uint, radix: uint,\n+                                 prec: uint) -> ~str {\n         return if prec == 0u && num == 0u {\n                 ~\"\"\n             } else {\n@@ -575,16 +576,16 @@ mod rt2 {\n                 } else { move s }\n             };\n     }\n-    pure fn get_int_precision(cv: Conv) -> uint {\n+    pub pure fn get_int_precision(cv: Conv) -> uint {\n         return match cv.precision {\n               CountIs(c) => c as uint,\n               CountImplied => 1u\n             };\n     }\n \n-    enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n+    pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n-    impl PadMode : Eq {\n+    pub impl PadMode : Eq {\n         pure fn eq(other: &PadMode) -> bool {\n             match (self, (*other)) {\n                 (PadSigned, PadSigned) => true,\n@@ -600,7 +601,7 @@ mod rt2 {\n         pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n     }\n \n-    fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n+    pub fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n         let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n           CountImplied => return s,\n@@ -653,14 +654,13 @@ mod rt2 {\n         }\n         return padstr + s;\n     }\n-    pure fn have_flag(flags: u32, f: u32) -> bool {\n+    pub pure fn have_flag(flags: u32, f: u32) -> bool {\n         flags & f != 0\n     }\n }\n \n #[cfg(test)]\n mod test {\n-    #[legacy_exports];\n     #[test]\n     fn fmt_slice() {\n         let s = \"abc\";"}]}