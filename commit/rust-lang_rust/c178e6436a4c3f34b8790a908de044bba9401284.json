{"sha": "c178e6436a4c3f34b8790a908de044bba9401284", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNzhlNjQzNmE0YzNmMzRiODc5MGE5MDhkZTA0NGJiYTk0MDEyODQ=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-06-10T21:00:59Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-06-19T17:33:09Z"}, "message": "Look for stores between non-conflicting generator saved locals\n\nThis is to prevent the miscompilation in #73137 from reappearing.\nOnly runs with `-Zvalidate-mir`.", "tree": {"sha": "d28df17e8cd910406899ab7489870e19d9e6fc57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d28df17e8cd910406899ab7489870e19d9e6fc57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c178e6436a4c3f34b8790a908de044bba9401284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c178e6436a4c3f34b8790a908de044bba9401284", "html_url": "https://github.com/rust-lang/rust/commit/c178e6436a4c3f34b8790a908de044bba9401284", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c178e6436a4c3f34b8790a908de044bba9401284/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fc2eeb1c81aef42855257adc11791dcffe803cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc2eeb1c81aef42855257adc11791dcffe803cb", "html_url": "https://github.com/rust-lang/rust/commit/8fc2eeb1c81aef42855257adc11791dcffe803cb"}], "stats": {"total": 160, "additions": 147, "deletions": 13}, "files": [{"sha": "9a15fba2bc8a052f0fdbfade1d2d5bb45ab05103", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 147, "deletions": 13, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/c178e6436a4c3f34b8790a908de044bba9401284/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c178e6436a4c3f34b8790a908de044bba9401284/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=c178e6436a4c3f34b8790a908de044bba9401284", "patch": "@@ -64,7 +64,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{GeneratorStateLangItem, PinTypeLangItem};\n use rustc_index::bit_set::{BitMatrix, BitSet};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::mir::visit::{MutVisitor, PlaceContext};\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::GeneratorSubsts;\n@@ -744,27 +744,19 @@ fn sanitize_witness<'tcx>(\n }\n \n fn compute_layout<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    source: MirSource<'tcx>,\n-    upvars: &Vec<Ty<'tcx>>,\n-    interior: Ty<'tcx>,\n-    always_live_locals: &storage::AlwaysLiveLocals,\n-    movable: bool,\n+    liveness: LivenessInfo,\n     body: &mut Body<'tcx>,\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n     IndexVec<BasicBlock, Option<BitSet<Local>>>,\n ) {\n-    // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {\n         saved_locals,\n         live_locals_at_suspension_points,\n         storage_conflicts,\n         storage_liveness,\n-    } = locals_live_across_suspend_points(tcx, body, source, always_live_locals, movable);\n-\n-    sanitize_witness(tcx, body, source.def_id(), interior, upvars, &saved_locals);\n+    } = liveness;\n \n     // Gather live local types and their indices.\n     let mut locals = IndexVec::<GeneratorSavedLocal, _>::new();\n@@ -1280,11 +1272,25 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         let always_live_locals = storage::AlwaysLiveLocals::new(&body);\n \n+        let liveness_info =\n+            locals_live_across_suspend_points(tcx, body, source, &always_live_locals, movable);\n+\n+        sanitize_witness(tcx, body, def_id, interior, &upvars, &liveness_info.saved_locals);\n+\n+        if tcx.sess.opts.debugging_opts.validate_mir {\n+            let mut vis = EnsureGeneratorFieldAssignmentsNeverAlias {\n+                assigned_local: None,\n+                saved_locals: &liveness_info.saved_locals,\n+                storage_conflicts: &liveness_info.storage_conflicts,\n+            };\n+\n+            vis.visit_body(body);\n+        }\n+\n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n         // `storage_liveness` tells us which locals have live storage at suspension points\n-        let (remap, layout, storage_liveness) =\n-            compute_layout(tcx, source, &upvars, interior, &always_live_locals, movable, body);\n+        let (remap, layout, storage_liveness) = compute_layout(liveness_info, body);\n \n         let can_return = can_return(tcx, body);\n \n@@ -1335,3 +1341,131 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         create_generator_resume_function(tcx, transform, source, body, can_return);\n     }\n }\n+\n+/// Looks for any assignments between locals (e.g., `_4 = _5`) that will both be converted to fields\n+/// in the generator state machine but whose storage does not conflict.\n+///\n+/// Validation needs to happen immediately *before* `TransformVisitor` is invoked, not after.\n+///\n+/// This condition would arise when the assignment is the last use of `_5` but the initial\n+/// definition of `_4` if we weren't extra careful to mark all locals used inside a statement as\n+/// conflicting. Non-conflicting generator saved locals may be stored at the same location within\n+/// the generator state machine, which would result in ill-formed MIR: the left-hand and right-hand\n+/// sides of an assignment may not alias. This caused a miscompilation in [#73137].\n+///\n+/// [#73137]: https://github.com/rust-lang/rust/issues/73137\n+struct EnsureGeneratorFieldAssignmentsNeverAlias<'a> {\n+    saved_locals: &'a GeneratorSavedLocals,\n+    storage_conflicts: &'a BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n+    assigned_local: Option<GeneratorSavedLocal>,\n+}\n+\n+impl EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n+    fn saved_local_for_direct_place(&self, place: Place<'_>) -> Option<GeneratorSavedLocal> {\n+        if place.is_indirect() {\n+            return None;\n+        }\n+\n+        self.saved_locals.get(place.local)\n+    }\n+\n+    fn check_assigned_place(&mut self, place: Place<'tcx>, f: impl FnOnce(&mut Self)) {\n+        if let Some(assigned_local) = self.saved_local_for_direct_place(place) {\n+            assert!(self.assigned_local.is_none(), \"`check_assigned_local` must not recurse\");\n+\n+            self.assigned_local = Some(assigned_local);\n+            f(self);\n+            self.assigned_local = None;\n+        }\n+    }\n+}\n+\n+impl Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n+    fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, location: Location) {\n+        let lhs = match self.assigned_local {\n+            Some(l) => l,\n+            None => {\n+                // We should be visiting all places used in the MIR.\n+                assert!(!context.is_use());\n+                return;\n+            }\n+        };\n+\n+        let rhs = match self.saved_local_for_direct_place(*place) {\n+            Some(l) => l,\n+            None => return,\n+        };\n+\n+        if !self.storage_conflicts.contains(lhs, rhs) {\n+            bug!(\n+                \"Assignment between generator saved locals whose storage does not conflict: \\\n+                    {:?}: {:?} = {:?}\",\n+                location,\n+                lhs,\n+                rhs,\n+            );\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        match &statement.kind {\n+            StatementKind::Assign(box (lhs, rhs)) => {\n+                self.check_assigned_place(*lhs, |this| this.visit_rvalue(rhs, location));\n+            }\n+\n+            // FIXME: Does `llvm_asm!` have any aliasing requirements?\n+            StatementKind::LlvmInlineAsm(_) => {}\n+\n+            StatementKind::FakeRead(..)\n+            | StatementKind::SetDiscriminant { .. }\n+            | StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::Retag(..)\n+            | StatementKind::AscribeUserType(..)\n+            | StatementKind::Nop => {}\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        // Checking for aliasing in terminators is probably overkill, but until we have actual\n+        // semantics, we should be conservative here.\n+        match &terminator.kind {\n+            TerminatorKind::Call {\n+                func,\n+                args,\n+                destination: Some((dest, _)),\n+                cleanup: _,\n+                from_hir_call: _,\n+                fn_span: _,\n+            } => {\n+                self.check_assigned_place(*dest, |this| {\n+                    this.visit_operand(func, location);\n+                    for arg in args {\n+                        this.visit_operand(arg, location);\n+                    }\n+                });\n+            }\n+\n+            TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n+                self.check_assigned_place(*resume_arg, |this| this.visit_operand(value, location));\n+            }\n+\n+            // FIXME: Does `asm!` have any aliasing requirements?\n+            TerminatorKind::InlineAsm { .. } => {}\n+\n+            TerminatorKind::Call { .. }\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. } => {}\n+        }\n+    }\n+}"}]}