{"sha": "687f929c9b320fcd11097aee2778e2fc81fa8536", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4N2Y5MjljOWIzMjBmY2QxMTA5N2FlZTI3NzhlMmZjODFmYTg1MzY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-19T16:15:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-19T16:15:14Z"}, "message": "Rollup merge of #73364 - joshtriplett:inline-asm, r=Amanieu\n\nasm: Allow multiple template string arguments; interpret them as newline-separated\n\nAllow the `asm!` macro to accept a series of template arguments, and interpret them as if they were concatenated with a '\\n' between them. This allows writing an `asm!` where each line of assembly appears in a separate template string argument.\n\nThis syntax makes it possible for rustfmt to reliably format and indent each line of assembly, without risking changes to the inside of a template string. It also avoids the complexity of having the user carefully format and indent a multi-line string (including where to put the surrounding quotes), and avoids the extra indentation and lines of a call to `concat!`.\n\nFor example, rewriting the second example from the [blog post on the new inline assembly syntax](https://blog.rust-lang.org/inside-rust/2020/06/08/new-inline-asm.html) using multiple template strings:\n\n```rust\n\nfn main() {\n    let mut bits = [0u8; 64];\n    for value in 0..=1024u64 {\n        let popcnt;\n        unsafe {\n            asm!(\n                \"    popcnt {popcnt}, {v}\",\n                \"2:\",\n                \"    blsi rax, {v}\",\n                \"    jz 1f\",\n                \"    xor {v}, rax\",\n                \"    tzcnt rax, rax\",\n                \"    stosb\",\n                \"    jmp 2b\",\n                \"1:\",\n                v = inout(reg) value => _,\n                popcnt = out(reg) popcnt,\n                out(\"rax\") _, // scratch\n                inout(\"rdi\") bits.as_mut_ptr() => _,\n            );\n        }\n        println!(\"bits of {}: {:?}\", value, &bits[0..popcnt]);\n    }\n}\n```\n\nNote that all the template strings must appear before all other arguments; you cannot, for instance, provide a series of template strings intermixed with the corresponding operands.", "tree": {"sha": "b976f46a42678bc48c3441491a6396e4124d76bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b976f46a42678bc48c3441491a6396e4124d76bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/687f929c9b320fcd11097aee2778e2fc81fa8536", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7OSTCRBK7hj4Ov3rIwAAdHIIAHvEPNX6GlRSCIfPhuxv9SmW\n09M2ImyCD+UgWESzkWy3VDAwOkbga7FwdYQruMry7EO6fUDntCHTXA4WC0rIBeSc\nk6Ac6kzKmpQyp++eS5ibP6hhMFd6wkJG8qyyctqqpeVkj6hoKnh+aK4LQFYAAMkq\nZNYP9YV7fYM9FIPKpu2/z2IUqDA/+bWnUQK1V5Batz2ymBdO8UdNjatZk49EIZs6\nOIQcUxvzUmSYWEICkiH+b6rMm9yHfAfcjtIMoOj+M608PUDXpSn9SZhX4uDNai3X\nCO+TxjuYifkka88OEt/RWRLBFzi7TPV+yDYnndwvdfQ+9wlajobTs8rw2oPBZgY=\n=zaDu\n-----END PGP SIGNATURE-----\n", "payload": "tree b976f46a42678bc48c3441491a6396e4124d76bc\nparent 65c33ed7986d76fdefee6cf93081f77fdec2e0c8\nparent fd9ed30e4b19457cc7059d1b08832edd6d2cbfb8\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592583314 -0700\ncommitter GitHub <noreply@github.com> 1592583314 -0700\n\nRollup merge of #73364 - joshtriplett:inline-asm, r=Amanieu\n\nasm: Allow multiple template string arguments; interpret them as newline-separated\n\nAllow the `asm!` macro to accept a series of template arguments, and interpret them as if they were concatenated with a '\\n' between them. This allows writing an `asm!` where each line of assembly appears in a separate template string argument.\n\nThis syntax makes it possible for rustfmt to reliably format and indent each line of assembly, without risking changes to the inside of a template string. It also avoids the complexity of having the user carefully format and indent a multi-line string (including where to put the surrounding quotes), and avoids the extra indentation and lines of a call to `concat!`.\n\nFor example, rewriting the second example from the [blog post on the new inline assembly syntax](https://blog.rust-lang.org/inside-rust/2020/06/08/new-inline-asm.html) using multiple template strings:\n\n```rust\n\nfn main() {\n    let mut bits = [0u8; 64];\n    for value in 0..=1024u64 {\n        let popcnt;\n        unsafe {\n            asm!(\n                \"    popcnt {popcnt}, {v}\",\n                \"2:\",\n                \"    blsi rax, {v}\",\n                \"    jz 1f\",\n                \"    xor {v}, rax\",\n                \"    tzcnt rax, rax\",\n                \"    stosb\",\n                \"    jmp 2b\",\n                \"1:\",\n                v = inout(reg) value => _,\n                popcnt = out(reg) popcnt,\n                out(\"rax\") _, // scratch\n                inout(\"rdi\") bits.as_mut_ptr() => _,\n            );\n        }\n        println!(\"bits of {}: {:?}\", value, &bits[0..popcnt]);\n    }\n}\n```\n\nNote that all the template strings must appear before all other arguments; you cannot, for instance, provide a series of template strings intermixed with the corresponding operands.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/687f929c9b320fcd11097aee2778e2fc81fa8536", "html_url": "https://github.com/rust-lang/rust/commit/687f929c9b320fcd11097aee2778e2fc81fa8536", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/687f929c9b320fcd11097aee2778e2fc81fa8536/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65c33ed7986d76fdefee6cf93081f77fdec2e0c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/65c33ed7986d76fdefee6cf93081f77fdec2e0c8", "html_url": "https://github.com/rust-lang/rust/commit/65c33ed7986d76fdefee6cf93081f77fdec2e0c8"}, {"sha": "fd9ed30e4b19457cc7059d1b08832edd6d2cbfb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd9ed30e4b19457cc7059d1b08832edd6d2cbfb8", "html_url": "https://github.com/rust-lang/rust/commit/fd9ed30e4b19457cc7059d1b08832edd6d2cbfb8"}], "stats": {"total": 748, "additions": 570, "deletions": 178}, "files": [{"sha": "a941bc9348f2cde0765ae2feb9d9628904882f25", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=687f929c9b320fcd11097aee2778e2fc81fa8536", "patch": "@@ -68,10 +68,13 @@ Let us see another example that also uses an input:\n let i: u64 = 3;\n let o: u64;\n unsafe {\n-    asm!(\"\n-        mov {0}, {1}\n-        add {0}, {number}\n-    \", out(reg) o, in(reg) i, number = const 5);\n+    asm!(\n+        \"mov {0}, {1}\",\n+        \"add {0}, {number}\",\n+        out(reg) o,\n+        in(reg) i,\n+        number = const 5,\n+    );\n }\n assert_eq!(o, 8);\n ```\n@@ -82,13 +85,18 @@ and then adding `5` to it.\n \n The example shows a few things:\n \n-First we can see that inputs are declared by writing `in` instead of `out`.\n+First, we can see that `asm!` allows multiple template string arguments; each\n+one is treated as a separate line of assembly code, as if they were all joined\n+together with newlines between them. This makes it easy to format assembly\n+code.\n+\n+Second, we can see that inputs are declared by writing `in` instead of `out`.\n \n-Second one of our operands has a type we haven't seen yet, `const`.\n+Third, one of our operands has a type we haven't seen yet, `const`.\n This tells the compiler to expand this argument to value directly inside the assembly template.\n This is only possible for constants and literals.\n \n-Third we can see that we can specify an argument number, or name as in any format string.\n+Fourth, we can see that we can specify an argument number, or name as in any format string.\n For inline assembly templates this is particularly useful as arguments are often used more than once.\n For more complex inline assembly using this facility is generally recommended, as it improves\n readability, and allows reordering instructions without changing the argument order.\n@@ -137,10 +145,13 @@ let mut a: u64 = 4;\n let b: u64 = 4;\n let c: u64 = 4;\n unsafe {\n-    asm!(\"\n-        add {0}, {1}\n-        add {0}, {2}\n-    \", inout(reg) a, in(reg) b, in(reg) c);\n+    asm!(\n+        \"add {0}, {1}\",\n+        \"add {0}, {2}\",\n+        inout(reg) a,\n+        in(reg) b,\n+        in(reg) c,\n+    );\n }\n assert_eq!(a, 12);\n ```\n@@ -233,7 +244,7 @@ unsafe {\n         // ECX 0 selects the L0 cache information.\n         inout(\"ecx\") 0 => ecx,\n         lateout(\"ebx\") ebx,\n-        lateout(\"edx\") _\n+        lateout(\"edx\") _,\n     );\n }\n \n@@ -255,12 +266,14 @@ This can also be used with a general register class (e.g. `reg`) to obtain a scr\n // Multiply x by 6 using shifts and adds\n let mut x: u64 = 4;\n unsafe {\n-    asm!(\"\n-        mov {tmp}, {x}\n-        shl {tmp}, 1\n-        shl {x}, 2\n-        add {x}, {tmp}\n-    \", x = inout(reg) x, tmp = out(reg) _);\n+    asm!(\n+        \"mov {tmp}, {x}\",\n+        \"shl {tmp}, 1\",\n+        \"shl {x}, 2\",\n+        \"add {x}, {tmp}\",\n+        x = inout(reg) x,\n+        tmp = out(reg) _,\n+    );\n }\n assert_eq!(x, 4 * 6);\n ```\n@@ -338,7 +351,7 @@ unsafe {\n     asm!(\n         \"add {0}, {1}\",\n         inlateout(reg) a, in(reg) b,\n-        options(pure, nomem, nostack)\n+        options(pure, nomem, nostack),\n     );\n }\n assert_eq!(a, 8);\n@@ -371,17 +384,19 @@ reg_operand := dir_spec \"(\" reg_spec \")\" operand_expr\n operand := reg_operand / \"const\" const_expr / \"sym\" path\n option := \"pure\" / \"nomem\" / \"readonly\" / \"preserves_flags\" / \"noreturn\" / \"att_syntax\"\n options := \"options(\" option *[\",\" option] [\",\"] \")\"\n-asm := \"asm!(\" format_string *(\",\" [ident \"=\"] operand) [\",\" options] [\",\"] \")\"\n+asm := \"asm!(\" format_string *(\",\" format_string) *(\",\" [ident \"=\"] operand) [\",\" options] [\",\"] \")\"\n ```\n \n The macro will initially be supported only on ARM, AArch64, Hexagon, x86, x86-64 and RISC-V targets. Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n \n [format-syntax]: https://doc.rust-lang.org/std/fmt/#syntax\n \n-## Template string\n+## Template string arguments\n \n The assembler template uses the same syntax as [format strings][format-syntax] (i.e. placeholders are specified by curly braces). The corresponding arguments are accessed in order, by index, or by name. However, implicit named arguments (introduced by [RFC #2795][rfc-2795]) are not supported.\n \n+An `asm!` invocation may have one or more template string arguments; an `asm!` with multiple template string arguments is treated as if all the strings were concatenated with a `\\n` between them. The expected usage is for each template string argument to correspond to a line of assembly code. All template string arguments must appear before any other arguments.\n+\n As with format strings, named arguments must appear after positional arguments. Explicit register operands must appear at the end of the operand list, after named arguments if any.\n \n Explicit register operands cannot be used by placeholders in the template string. All other named and positional operands must appear at least once in the template string, otherwise a compiler error is generated."}, {"sha": "e98d709539d79b6ef910d2db072a8a824dbe21c1", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=687f929c9b320fcd11097aee2778e2fc81fa8536", "patch": "@@ -1905,7 +1905,7 @@ impl fmt::Display for InlineAsmTemplatePiece {\n                     match c {\n                         '{' => f.write_str(\"{{\")?,\n                         '}' => f.write_str(\"}}\")?,\n-                        _ => write!(f, \"{}\", c.escape_debug())?,\n+                        _ => c.fmt(f)?,\n                     }\n                 }\n                 Ok(())"}, {"sha": "29885679604647db049912609842e20d07d7de52", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 185, "deletions": 147, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=687f929c9b320fcd11097aee2778e2fc81fa8536", "patch": "@@ -11,7 +11,7 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{InnerSpan, Span};\n \n struct AsmArgs {\n-    template: P<ast::Expr>,\n+    templates: Vec<P<ast::Expr>>,\n     operands: Vec<(ast::InlineAsmOperand, Span)>,\n     named_args: FxHashMap<Symbol, usize>,\n     reg_args: FxHashSet<usize>,\n@@ -52,21 +52,21 @@ fn parse_args<'a>(\n         return Err(err);\n     }\n \n-    let template = p.parse_expr()?;\n+    let first_template = p.parse_expr()?;\n     let mut args = AsmArgs {\n-        template,\n+        templates: vec![first_template],\n         operands: vec![],\n         named_args: FxHashMap::default(),\n         reg_args: FxHashSet::default(),\n         options: ast::InlineAsmOptions::empty(),\n         options_span: None,\n     };\n \n-    let mut first = true;\n+    let mut allow_templates = true;\n     while p.token != token::Eof {\n         if !p.eat(&token::Comma) {\n-            if first {\n-                // After `asm!(\"\"` we always expect *only* a comma...\n+            if allow_templates {\n+                // After a template string, we always expect *only* a comma...\n                 let mut err = ecx.struct_span_err(p.token.span, \"expected token: `,`\");\n                 err.span_label(p.token.span, \"expected `,`\");\n                 p.maybe_annotate_with_ascription(&mut err, false);\n@@ -76,14 +76,14 @@ fn parse_args<'a>(\n                 return Err(p.expect(&token::Comma).err().unwrap());\n             }\n         }\n-        first = false;\n         if p.token == token::Eof {\n             break;\n         } // accept trailing commas\n \n         // Parse options\n         if p.eat(&token::Ident(sym::options, false)) {\n             parse_options(&mut p, &mut args)?;\n+            allow_templates = false;\n             continue;\n         }\n \n@@ -94,6 +94,7 @@ fn parse_args<'a>(\n             let (ident, _) = p.token.ident().unwrap();\n             p.bump();\n             p.expect(&token::Eq)?;\n+            allow_templates = false;\n             Some(ident.name)\n         } else {\n             None\n@@ -135,8 +136,7 @@ fn parse_args<'a>(\n         } else if p.eat(&token::Ident(kw::Const, false)) {\n             let expr = p.parse_expr()?;\n             ast::InlineAsmOperand::Const { expr }\n-        } else {\n-            p.expect(&token::Ident(sym::sym, false))?;\n+        } else if p.eat(&token::Ident(sym::sym, false)) {\n             let expr = p.parse_expr()?;\n             match expr.kind {\n                 ast::ExprKind::Path(..) => {}\n@@ -147,8 +147,27 @@ fn parse_args<'a>(\n                 }\n             }\n             ast::InlineAsmOperand::Sym { expr }\n+        } else if allow_templates {\n+            let template = p.parse_expr()?;\n+            // If it can't possibly expand to a string, provide diagnostics here to include other\n+            // things it could have been.\n+            match template.kind {\n+                ast::ExprKind::Lit(ast::Lit { kind: ast::LitKind::Str(..), .. }) => {}\n+                ast::ExprKind::MacCall(..) => {}\n+                _ => {\n+                    let errstr = \"expected operand, options, or additional template string\";\n+                    let mut err = ecx.struct_span_err(template.span, errstr);\n+                    err.span_label(template.span, errstr);\n+                    return Err(err);\n+                }\n+            }\n+            args.templates.push(template);\n+            continue;\n+        } else {\n+            return Err(p.expect_one_of(&[], &[]).unwrap_err());\n         };\n \n+        allow_templates = false;\n         let span = span_start.to(p.prev_token.span);\n         let slot = args.operands.len();\n         args.operands.push((op, span));\n@@ -330,155 +349,180 @@ fn parse_reg<'a>(\n }\n \n fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast::Expr> {\n-    let msg = \"asm template must be a string literal\";\n-    let template_sp = args.template.span;\n-    let (template_str, template_style, template_span) =\n-        match expr_to_spanned_string(ecx, args.template, msg) {\n-            Ok(template) => template,\n-            Err(err) => {\n-                if let Some(mut err) = err {\n-                    err.emit();\n-                }\n-                return DummyResult::raw_expr(sp, true);\n-            }\n-        };\n-\n-    let str_style = match template_style {\n-        ast::StrStyle::Cooked => None,\n-        ast::StrStyle::Raw(raw) => Some(raw as usize),\n-    };\n-\n-    let template_str = &template_str.as_str();\n-    let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n-    let mut parser = parse::Parser::new(\n-        template_str,\n-        str_style,\n-        template_snippet,\n-        false,\n-        parse::ParseMode::InlineAsm,\n-    );\n-\n-    let mut unverified_pieces = Vec::new();\n-    while let Some(piece) = parser.next() {\n-        if !parser.errors.is_empty() {\n-            break;\n-        } else {\n-            unverified_pieces.push(piece);\n-        }\n-    }\n-\n-    if !parser.errors.is_empty() {\n-        let err = parser.errors.remove(0);\n-        let err_sp = template_span.from_inner(err.span);\n-        let mut e = ecx\n-            .struct_span_err(err_sp, &format!(\"invalid asm template string: {}\", err.description));\n-        e.span_label(err_sp, err.label + \" in asm template string\");\n-        if let Some(note) = err.note {\n-            e.note(&note);\n-        }\n-        if let Some((label, span)) = err.secondary_label {\n-            let err_sp = template_span.from_inner(span);\n-            e.span_label(err_sp, label);\n-        }\n-        e.emit();\n-        return DummyResult::raw_expr(sp, true);\n-    }\n-\n+    let mut template = vec![];\n     // Register operands are implicitly used since they are not allowed to be\n     // referenced in the template string.\n     let mut used = vec![false; args.operands.len()];\n     for pos in &args.reg_args {\n         used[*pos] = true;\n     }\n-\n     let named_pos: FxHashMap<usize, Symbol> =\n         args.named_args.iter().map(|(&sym, &idx)| (idx, sym)).collect();\n-    let mut arg_spans = parser.arg_places.iter().map(|span| template_span.from_inner(*span));\n-    let mut template = vec![];\n-    for piece in unverified_pieces {\n-        match piece {\n-            parse::Piece::String(s) => {\n-                template.push(ast::InlineAsmTemplatePiece::String(s.to_string()))\n+    let mut line_spans = Vec::with_capacity(args.templates.len());\n+    let mut curarg = 0;\n+\n+    for template_expr in args.templates.into_iter() {\n+        if !template.is_empty() {\n+            template.push(ast::InlineAsmTemplatePiece::String(\"\\n\".to_string()));\n+        }\n+\n+        let msg = \"asm template must be a string literal\";\n+        let template_sp = template_expr.span;\n+        let (template_str, template_style, template_span) =\n+            match expr_to_spanned_string(ecx, template_expr, msg) {\n+                Ok(template_part) => template_part,\n+                Err(err) => {\n+                    if let Some(mut err) = err {\n+                        err.emit();\n+                    }\n+                    return DummyResult::raw_expr(sp, true);\n+                }\n+            };\n+\n+        let str_style = match template_style {\n+            ast::StrStyle::Cooked => None,\n+            ast::StrStyle::Raw(raw) => Some(raw as usize),\n+        };\n+\n+        let template_str = &template_str.as_str();\n+        let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n+        let mut parser = parse::Parser::new(\n+            template_str,\n+            str_style,\n+            template_snippet,\n+            false,\n+            parse::ParseMode::InlineAsm,\n+        );\n+        parser.curarg = curarg;\n+\n+        let mut unverified_pieces = Vec::new();\n+        while let Some(piece) = parser.next() {\n+            if !parser.errors.is_empty() {\n+                break;\n+            } else {\n+                unverified_pieces.push(piece);\n             }\n-            parse::Piece::NextArgument(arg) => {\n-                let span = arg_spans.next().unwrap_or(template_sp);\n-\n-                let operand_idx = match arg.position {\n-                    parse::ArgumentIs(idx) | parse::ArgumentImplicitlyIs(idx) => {\n-                        if idx >= args.operands.len()\n-                            || named_pos.contains_key(&idx)\n-                            || args.reg_args.contains(&idx)\n-                        {\n-                            let msg = format!(\"invalid reference to argument at index {}\", idx);\n-                            let mut err = ecx.struct_span_err(span, &msg);\n-                            err.span_label(span, \"from here\");\n-\n-                            let positional_args =\n-                                args.operands.len() - args.named_args.len() - args.reg_args.len();\n-                            let positional = if positional_args != args.operands.len() {\n-                                \"positional \"\n+        }\n+\n+        if !parser.errors.is_empty() {\n+            let err = parser.errors.remove(0);\n+            let err_sp = template_span.from_inner(err.span);\n+            let msg = &format!(\"invalid asm template string: {}\", err.description);\n+            let mut e = ecx.struct_span_err(err_sp, msg);\n+            e.span_label(err_sp, err.label + \" in asm template string\");\n+            if let Some(note) = err.note {\n+                e.note(&note);\n+            }\n+            if let Some((label, span)) = err.secondary_label {\n+                let err_sp = template_span.from_inner(span);\n+                e.span_label(err_sp, label);\n+            }\n+            e.emit();\n+            return DummyResult::raw_expr(sp, true);\n+        }\n+\n+        curarg = parser.curarg;\n+\n+        let mut arg_spans = parser.arg_places.iter().map(|span| template_span.from_inner(*span));\n+        for piece in unverified_pieces {\n+            match piece {\n+                parse::Piece::String(s) => {\n+                    template.push(ast::InlineAsmTemplatePiece::String(s.to_string()))\n+                }\n+                parse::Piece::NextArgument(arg) => {\n+                    let span = arg_spans.next().unwrap_or(template_sp);\n+\n+                    let operand_idx = match arg.position {\n+                        parse::ArgumentIs(idx) | parse::ArgumentImplicitlyIs(idx) => {\n+                            if idx >= args.operands.len()\n+                                || named_pos.contains_key(&idx)\n+                                || args.reg_args.contains(&idx)\n+                            {\n+                                let msg = format!(\"invalid reference to argument at index {}\", idx);\n+                                let mut err = ecx.struct_span_err(span, &msg);\n+                                err.span_label(span, \"from here\");\n+\n+                                let positional_args = args.operands.len()\n+                                    - args.named_args.len()\n+                                    - args.reg_args.len();\n+                                let positional = if positional_args != args.operands.len() {\n+                                    \"positional \"\n+                                } else {\n+                                    \"\"\n+                                };\n+                                let msg = match positional_args {\n+                                    0 => format!(\"no {}arguments were given\", positional),\n+                                    1 => format!(\"there is 1 {}argument\", positional),\n+                                    x => format!(\"there are {} {}arguments\", x, positional),\n+                                };\n+                                err.note(&msg);\n+\n+                                if named_pos.contains_key(&idx) {\n+                                    err.span_label(args.operands[idx].1, \"named argument\");\n+                                    err.span_note(\n+                                        args.operands[idx].1,\n+                                        \"named arguments cannot be referenced by position\",\n+                                    );\n+                                } else if args.reg_args.contains(&idx) {\n+                                    err.span_label(\n+                                        args.operands[idx].1,\n+                                        \"explicit register argument\",\n+                                    );\n+                                    err.span_note(\n+                                        args.operands[idx].1,\n+                                        \"explicit register arguments cannot be used in the asm template\",\n+                                    );\n+                                }\n+                                err.emit();\n+                                None\n                             } else {\n-                                \"\"\n-                            };\n-                            let msg = match positional_args {\n-                                0 => format!(\"no {}arguments were given\", positional),\n-                                1 => format!(\"there is 1 {}argument\", positional),\n-                                x => format!(\"there are {} {}arguments\", x, positional),\n-                            };\n-                            err.note(&msg);\n-\n-                            if named_pos.contains_key(&idx) {\n-                                err.span_label(args.operands[idx].1, \"named argument\");\n-                                err.span_note(\n-                                    args.operands[idx].1,\n-                                    \"named arguments cannot be referenced by position\",\n-                                );\n-                            } else if args.reg_args.contains(&idx) {\n-                                err.span_label(args.operands[idx].1, \"explicit register argument\");\n-                                err.span_note(\n-                                    args.operands[idx].1,\n-                                    \"explicit register arguments cannot be used in the asm template\",\n-                                );\n+                                Some(idx)\n                             }\n-                            err.emit();\n-                            None\n-                        } else {\n-                            Some(idx)\n-                        }\n-                    }\n-                    parse::ArgumentNamed(name) => match args.named_args.get(&name) {\n-                        Some(&idx) => Some(idx),\n-                        None => {\n-                            let msg = format!(\"there is no argument named `{}`\", name);\n-                            ecx.struct_span_err(span, &msg[..]).emit();\n-                            None\n                         }\n-                    },\n-                };\n-\n-                let mut chars = arg.format.ty.chars();\n-                let mut modifier = chars.next();\n-                if chars.next().is_some() {\n-                    let span = arg\n-                        .format\n-                        .ty_span\n-                        .map(|sp| template_sp.from_inner(sp))\n-                        .unwrap_or(template_sp);\n-                    ecx.struct_span_err(span, \"asm template modifier must be a single character\")\n+                        parse::ArgumentNamed(name) => match args.named_args.get(&name) {\n+                            Some(&idx) => Some(idx),\n+                            None => {\n+                                let msg = format!(\"there is no argument named `{}`\", name);\n+                                ecx.struct_span_err(span, &msg[..]).emit();\n+                                None\n+                            }\n+                        },\n+                    };\n+\n+                    let mut chars = arg.format.ty.chars();\n+                    let mut modifier = chars.next();\n+                    if chars.next().is_some() {\n+                        let span = arg\n+                            .format\n+                            .ty_span\n+                            .map(|sp| template_sp.from_inner(sp))\n+                            .unwrap_or(template_sp);\n+                        ecx.struct_span_err(\n+                            span,\n+                            \"asm template modifier must be a single character\",\n+                        )\n                         .emit();\n-                    modifier = None;\n-                }\n+                        modifier = None;\n+                    }\n \n-                if let Some(operand_idx) = operand_idx {\n-                    used[operand_idx] = true;\n-                    template.push(ast::InlineAsmTemplatePiece::Placeholder {\n-                        operand_idx,\n-                        modifier,\n-                        span,\n-                    });\n+                    if let Some(operand_idx) = operand_idx {\n+                        used[operand_idx] = true;\n+                        template.push(ast::InlineAsmTemplatePiece::Placeholder {\n+                            operand_idx,\n+                            modifier,\n+                            span,\n+                        });\n+                    }\n                 }\n             }\n         }\n+\n+        if parser.line_spans.is_empty() {\n+            let template_num_lines = 1 + template_str.matches('\\n').count();\n+            line_spans.extend(std::iter::repeat(template_sp).take(template_num_lines));\n+        } else {\n+            line_spans.extend(parser.line_spans.iter().map(|span| template_span.from_inner(*span)));\n+        };\n     }\n \n     let mut unused_operands = vec![];\n@@ -525,12 +569,6 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n         }\n     }\n \n-    let line_spans = if parser.line_spans.is_empty() {\n-        vec![template_sp]\n-    } else {\n-        parser.line_spans.iter().map(|span| template_span.from_inner(*span)).collect()\n-    };\n-\n     let inline_asm =\n         ast::InlineAsm { template, operands: args.operands, options: args.options, line_spans };\n     P(ast::Expr {"}, {"sha": "a5b5a1090cbfd5052e0d6beb64b0b79581a87698", "filename": "src/librustc_parse_format/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Flibrustc_parse_format%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Flibrustc_parse_format%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse_format%2Flib.rs?ref=687f929c9b320fcd11097aee2778e2fc81fa8536", "patch": "@@ -178,7 +178,7 @@ pub struct Parser<'a> {\n     /// Error messages accumulated during parsing\n     pub errors: Vec<ParseError>,\n     /// Current position of implicit positional argument pointer\n-    curarg: usize,\n+    pub curarg: usize,\n     /// `Some(raw count)` when the string is \"raw\", used to position spans correctly\n     style: Option<usize>,\n     /// Start and end byte offset of every successfully parsed argument\n@@ -243,11 +243,13 @@ impl<'a> Iterator for Parser<'a> {\n                 _ => Some(String(self.string(pos))),\n             }\n         } else {\n-            if self.is_literal && self.cur_line_start != self.input.len() {\n+            if self.is_literal {\n                 let start = self.to_span_index(self.cur_line_start);\n                 let end = self.to_span_index(self.input.len());\n-                self.line_spans.push(start.to(end));\n-                self.cur_line_start = self.input.len();\n+                let span = start.to(end);\n+                if self.line_spans.last() != Some(&span) {\n+                    self.line_spans.push(span);\n+                }\n             }\n             None\n         }"}, {"sha": "b3d188dd708814cf50c3937d59eb7334ef73cb09", "filename": "src/test/pretty/asm.pp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fpretty%2Fasm.pp", "raw_url": "https://github.com/rust-lang/rust/raw/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fpretty%2Fasm.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fasm.pp?ref=687f929c9b320fcd11097aee2778e2fc81fa8536", "patch": "@@ -22,5 +22,13 @@\n         asm!(\"{0}\", inout(reg) b);\n         asm!(\"{0} {1}\", out(reg) _, inlateout(reg) b => _);\n         asm!(\"\", out(\"al\") _, lateout(\"rbx\") _);\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1 {0}, 42\\ninst2 {1}, 24\", in(reg) a, out(reg) b);\n+        asm!(\"inst2 {1}, 24\\ninst1 {0}, 42\", in(reg) a, out(reg) b);\n+        asm!(\"inst1 {0}, 42\\ninst2 {1}, 24\", in(reg) a, out(reg) b);\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1\\n\\tinst2\");\n+        asm!(\"inst1\\ninst2\\ninst3\\ninst4\");\n     }\n }"}, {"sha": "33f25e5216b4eafab08089c2f779fd22ba736544", "filename": "src/test/pretty/asm.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fpretty%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fpretty%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fasm.rs?ref=687f929c9b320fcd11097aee2778e2fc81fa8536", "patch": "@@ -16,5 +16,14 @@ pub fn main() {\n         asm!(\"{name}\", name = inout(reg) b);\n         asm!(\"{} {}\", out(reg) _, inlateout(reg) b => _);\n         asm!(\"\", out(\"al\") _, lateout(\"rbx\") _);\n+        asm!(\"inst1\", \"inst2\");\n+        asm!(\"inst1 {}, 42\", \"inst2 {}, 24\", in(reg) a, out(reg) b);\n+        asm!(\"inst2 {1}, 24\", \"inst1 {0}, 42\", in(reg) a, out(reg) b);\n+        asm!(\"inst1 {}, 42\", \"inst2 {name}, 24\", in(reg) a, name = out(reg) b);\n+        asm!(\"inst1\n+inst2\");\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1\\n\\tinst2\");\n+        asm!(\"inst1\\ninst2\", \"inst3\\ninst4\");\n     }\n }"}, {"sha": "fbf399d8b075c311b51cb36e3760789f7d604344", "filename": "src/test/ui/asm/parse-error.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs?ref=687f929c9b320fcd11097aee2778e2fc81fa8536", "patch": "@@ -13,7 +13,7 @@ fn main() {\n         asm!(\"{}\" foo);\n         //~^ ERROR expected token: `,`\n         asm!(\"{}\", foo);\n-        //~^ ERROR expected one of\n+        //~^ ERROR expected operand, options, or additional template string\n         asm!(\"{}\", in foo);\n         //~^ ERROR expected `(`, found `foo`\n         asm!(\"{}\", in(reg foo));\n@@ -52,5 +52,13 @@ fn main() {\n         //~^ ERROR named arguments cannot follow explicit register arguments\n         asm!(\"{1}\", in(\"eax\") foo, const bar);\n         //~^ ERROR positional arguments cannot follow named arguments or explicit register arguments\n+        asm!(\"\", options(), \"\");\n+        //~^ ERROR expected one of\n+        asm!(\"{}\", in(reg) foo, \"{}\", out(reg) foo);\n+        //~^ ERROR expected one of\n+        asm!(format!(\"{{{}}}\", 0), in(reg) foo);\n+        //~^ ERROR asm template must be a string literal\n+        asm!(\"{1}\", format!(\"{{{}}}\", 0), in(reg) foo, out(reg) bar);\n+        //~^ ERROR asm template must be a string literal\n     }\n }"}, {"sha": "ba7e8f7a03ccad682165367ca555d91352895908", "filename": "src/test/ui/asm/parse-error.stderr", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr?ref=687f929c9b320fcd11097aee2778e2fc81fa8536", "patch": "@@ -16,11 +16,11 @@ error: expected token: `,`\n LL |         asm!(\"{}\" foo);\n    |                   ^^^ expected `,`\n \n-error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `foo`\n+error: expected operand, options, or additional template string\n   --> $DIR/parse-error.rs:15:20\n    |\n LL |         asm!(\"{}\", foo);\n-   |                    ^^^ expected one of 8 possible tokens\n+   |                    ^^^ expected operand, options, or additional template string\n \n error: expected `(`, found `foo`\n   --> $DIR/parse-error.rs:17:23\n@@ -160,5 +160,33 @@ LL |         asm!(\"{1}\", in(\"eax\") foo, const bar);\n    |                     |\n    |                     explicit register argument\n \n-error: aborting due to 24 previous errors\n+error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"\"`\n+  --> $DIR/parse-error.rs:55:29\n+   |\n+LL |         asm!(\"\", options(), \"\");\n+   |                             ^^ expected one of 8 possible tokens\n+\n+error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"{}\"`\n+  --> $DIR/parse-error.rs:57:33\n+   |\n+LL |         asm!(\"{}\", in(reg) foo, \"{}\", out(reg) foo);\n+   |                                 ^^^^ expected one of 8 possible tokens\n+\n+error: asm template must be a string literal\n+  --> $DIR/parse-error.rs:59:14\n+   |\n+LL |         asm!(format!(\"{{{}}}\", 0), in(reg) foo);\n+   |              ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: asm template must be a string literal\n+  --> $DIR/parse-error.rs:61:21\n+   |\n+LL |         asm!(\"{1}\", format!(\"{{{}}}\", 0), in(reg) foo, out(reg) bar);\n+   |                     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 28 previous errors\n "}, {"sha": "1477e3dd5665ce6230819888ed21c50c8c4824da", "filename": "src/test/ui/asm/srcloc.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs?ref=687f929c9b320fcd11097aee2778e2fc81fa8536", "patch": "@@ -40,5 +40,85 @@ fn main() {\n \n         asm!(\"movaps %xmm3, (%esi, 2)\", options(att_syntax));\n         //~^ WARN: scale factor without index register is ignored\n+\n+        asm!(\n+            \"invalid_instruction\",\n+        );\n+        //~^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            \"mov eax, eax\",\n+            \"invalid_instruction\",\n+            \"mov eax, eax\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            \"mov eax, eax\\n\",\n+            \"invalid_instruction\",\n+            \"mov eax, eax\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            \"mov eax, eax\",\n+            concat!(\"invalid\", \"_\", \"instruction\"),\n+            \"mov eax, eax\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            concat!(\"mov eax\", \", \", \"eax\"),\n+            concat!(\"invalid\", \"_\", \"instruction\"),\n+            concat!(\"mov eax\", \", \", \"eax\"),\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        // Make sure template strings get separated\n+        asm!(\n+            \"invalid_instruction1\",\n+            \"invalid_instruction2\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+\n+        asm!(\n+            concat!(\n+                \"invalid\", \"_\", \"instruction1\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction2\",\n+            ),\n+        );\n+        //~^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+\n+        asm!(\n+            concat!(\n+                \"invalid\", \"_\", \"instruction1\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction2\",\n+            ),\n+            concat!(\n+                \"invalid\", \"_\", \"instruction3\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction4\",\n+            ),\n+        );\n+        //~^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+        //~^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction3'\n+        //~^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction4'\n+\n+        asm!(\n+            concat!(\n+                \"invalid\", \"_\", \"instruction1\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction2\", \"\\n\",\n+            ),\n+            concat!(\n+                \"invalid\", \"_\", \"instruction3\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction4\", \"\\n\",\n+            ),\n+        );\n+        //~^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+        //~^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction3'\n+        //~^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction4'\n     }\n }"}, {"sha": "b62c8948289ddf1bf55575457bdc2e178c99d50c", "filename": "src/test/ui/asm/srcloc.stderr", "status": "modified", "additions": 205, "deletions": 1, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/687f929c9b320fcd11097aee2778e2fc81fa8536/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr?ref=687f929c9b320fcd11097aee2778e2fc81fa8536", "patch": "@@ -82,5 +82,209 @@ note: instantiated into assembly here\n LL |     movaps %xmm3, (%esi, 2)\n    |                          ^\n \n-error: aborting due to 6 previous errors; 1 warning emitted\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:45:14\n+   |\n+LL |             \"invalid_instruction\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:51:14\n+   |\n+LL |             \"invalid_instruction\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:58:14\n+   |\n+LL |             \"invalid_instruction\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:4:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:65:13\n+   |\n+LL |             concat!(\"invalid\", \"_\", \"instruction\"),\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:72:13\n+   |\n+LL |             concat!(\"invalid\", \"_\", \"instruction\"),\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:79:14\n+   |\n+LL |             \"invalid_instruction1\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:80:14\n+   |\n+LL |             \"invalid_instruction2\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:86:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:86:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:95:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:95:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction3'\n+  --> $DIR/srcloc.rs:99:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:4:1\n+   |\n+LL | invalid_instruction3\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction4'\n+  --> $DIR/srcloc.rs:99:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:5:1\n+   |\n+LL | invalid_instruction4\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:110:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:110:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction3'\n+  --> $DIR/srcloc.rs:114:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:5:1\n+   |\n+LL | invalid_instruction3\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction4'\n+  --> $DIR/srcloc.rs:114:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:6:1\n+   |\n+LL | invalid_instruction4\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 23 previous errors; 1 warning emitted\n "}]}