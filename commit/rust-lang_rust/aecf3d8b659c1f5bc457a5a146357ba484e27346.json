{"sha": "aecf3d8b659c1f5bc457a5a146357ba484e27346", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlY2YzZDhiNjU5YzFmNWJjNDU3YTVhMTQ2MzU3YmE0ODRlMjczNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-01T08:33:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-01T08:33:08Z"}, "message": "Auto merge of #24965 - arielb1:instant-reject, r=nikomatsakis\n\nThis uses a (per-trait) hash-table to separate impls from different TraitDefs, and makes coherence go so much quicker. I will post performance numbers tomorrow.\r\n\r\nThis is still WIP, as when there's an overlap error, impls can get printed in the wrong order, which causes a few issues. Should I pick the local impl with the smallest NodeId to print?\r\n\r\nCould you take a look at this @nikomatsakis?", "tree": {"sha": "a5c08584ff06cb89da61a95635a54b539948ae07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5c08584ff06cb89da61a95635a54b539948ae07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aecf3d8b659c1f5bc457a5a146357ba484e27346", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aecf3d8b659c1f5bc457a5a146357ba484e27346", "html_url": "https://github.com/rust-lang/rust/commit/aecf3d8b659c1f5bc457a5a146357ba484e27346", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aecf3d8b659c1f5bc457a5a146357ba484e27346/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c710b593b429d39ea01375172a9ce968f43ab26", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c710b593b429d39ea01375172a9ce968f43ab26", "html_url": "https://github.com/rust-lang/rust/commit/5c710b593b429d39ea01375172a9ce968f43ab26"}, {"sha": "30a5448d256b17e1924401f705d22f5313cb59ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/30a5448d256b17e1924401f705d22f5313cb59ed", "html_url": "https://github.com/rust-lang/rust/commit/30a5448d256b17e1924401f705d22f5313cb59ed"}], "stats": {"total": 766, "additions": 431, "deletions": 335}, "files": [{"sha": "7132ac4895aa1d60055871301ba4c5cc8c94041e", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -283,7 +283,7 @@ pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n // if there is one.\n pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             def: ast::DefId)\n-                            -> Option<Rc<ty::TraitRef<'tcx>>> {\n+                            -> Option<ty::TraitRef<'tcx>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_trait(&*cdata, def.node, tcx)"}, {"sha": "00fc42341c38996225823b22e1df9d67bc5ccb2d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -30,7 +30,9 @@ use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty::{self, Ty};\n use middle::astencode::vtable_decoder_helpers;\n+use util::nodemap::FnvHashMap;\n \n+use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::hash::{self, Hash, SipHasher};\n use std::io::prelude::*;\n@@ -247,13 +249,13 @@ pub fn item_type<'tcx>(_item_id: ast::DefId, item: rbml::Doc,\n }\n \n fn doc_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n-                       -> Rc<ty::TraitRef<'tcx>> {\n+                       -> ty::TraitRef<'tcx> {\n     parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n-                        -> Rc<ty::TraitRef<'tcx>> {\n+                        -> ty::TraitRef<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n@@ -420,6 +422,9 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n         generics: generics,\n         trait_ref: item_trait_ref(item_doc, tcx, cdata),\n         associated_type_names: associated_type_names,\n+        nonblanket_impls: RefCell::new(FnvHashMap()),\n+        blanket_impls: RefCell::new(vec![]),\n+        flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n     }\n }\n \n@@ -490,7 +495,7 @@ pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n pub fn get_impl_trait<'tcx>(cdata: Cmd,\n                             id: ast::NodeId,\n                             tcx: &ty::ctxt<'tcx>)\n-                            -> Option<Rc<ty::TraitRef<'tcx>>>\n+                            -> Option<ty::TraitRef<'tcx>>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     let fam = item_family(item_doc);"}, {"sha": "90dd452e06b5bf7cc3f5c8504dbe63981c7c5ccc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -103,7 +103,7 @@ struct entry<T> {\n \n fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a, 'tcx>,\n-                              trait_ref: &ty::TraitRef<'tcx>,\n+                              trait_ref: ty::TraitRef<'tcx>,\n                               tag: usize) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n@@ -191,7 +191,7 @@ pub fn write_trait_ref<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_trait_ref(rbml_w, ty_str_ctxt, trait_ref);\n+    tyencode::enc_trait_ref(rbml_w, ty_str_ctxt, *trait_ref);\n }\n \n pub fn write_region(ecx: &EncodeContext,\n@@ -974,16 +974,14 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n fn encode_extension_implementations(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n-    match ecx.tcx.trait_impls.borrow().get(&trait_def_id) {\n-        None => {}\n-        Some(implementations) => {\n-            for &impl_def_id in &*implementations.borrow() {\n-                rbml_w.start_tag(tag_items_data_item_extension_impl);\n-                encode_def_id(rbml_w, impl_def_id);\n-                rbml_w.end_tag();\n-            }\n-        }\n-    }\n+    assert!(ast_util::is_local(trait_def_id));\n+    let def = ty::lookup_trait_def(ecx.tcx, trait_def_id);\n+\n+    def.for_each_impl(ecx.tcx, |impl_def_id| {\n+        rbml_w.start_tag(tag_items_data_item_extension_impl);\n+        encode_def_id(rbml_w, impl_def_id);\n+        rbml_w.end_tag();\n+    });\n }\n \n fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<attr::Stability>) {\n@@ -1201,7 +1199,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           encode_unsafety(rbml_w, unsafety);\n \n           let trait_ref = ty::impl_id_to_trait_ref(tcx, item.id);\n-          encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n+          encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n       ast::ItemImpl(unsafety, polarity, _, ref opt_trait, ref ty, ref ast_items) => {\n@@ -1246,7 +1244,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         if opt_trait.is_some() {\n             let trait_ref = ty::impl_id_to_trait_ref(tcx, item.id);\n-            encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n+            encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n@@ -1314,7 +1312,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         tag_item_generics);\n         encode_predicates(rbml_w, ecx, &ty::lookup_super_predicates(tcx, def_id),\n                           tag_item_super_predicates);\n-        encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n+        encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_visibility(rbml_w, vis);"}, {"sha": "223a5eef614c1acc4aacf62e4369be359f7e36cc", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -23,7 +23,6 @@ use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, AsPredicate, Ty};\n \n-use std::rc::Rc;\n use std::str;\n use syntax::abi;\n use syntax::ast;\n@@ -182,7 +181,7 @@ pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos\n \n pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                                      tcx: &ty::ctxt<'tcx>, conv: F)\n-                                     -> Rc<ty::TraitRef<'tcx>> where\n+                                     -> ty::TraitRef<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_trait_ref_data {}\", data_log_string(data, pos));\n@@ -434,19 +433,19 @@ fn parse_str(st: &mut PState, term: char) -> String {\n }\n \n fn parse_trait_ref<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F)\n-                                -> Rc<ty::TraitRef<'tcx>> where\n+                                -> ty::TraitRef<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     parse_trait_ref_(st, &mut conv)\n }\n \n fn parse_trait_ref_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n-                              -> Rc<ty::TraitRef<'tcx>> where\n+                              -> ty::TraitRef<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     let def = parse_def_(st, NominalType, conv);\n     let substs = st.tcx.mk_substs(parse_substs_(st, conv));\n-    Rc::new(ty::TraitRef {def_id: def, substs: substs})\n+    ty::TraitRef {def_id: def, substs: substs}\n }\n \n fn parse_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F) -> Ty<'tcx> where"}, {"sha": "f5f520720c62bc1ca5d421bbd91b9fed2cfac57b", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -94,7 +94,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n         ty::ty_trait(box ty::TyTrait { ref principal,\n                                        ref bounds }) => {\n             mywrite!(w, \"x[\");\n-            enc_trait_ref(w, cx, &*principal.0);\n+            enc_trait_ref(w, cx, principal.0);\n             enc_existential_bounds(w, cx, bounds);\n             mywrite!(w, \"]\");\n         }\n@@ -149,7 +149,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n         }\n         ty::ty_projection(ref data) => {\n             mywrite!(w, \"P[\");\n-            enc_trait_ref(w, cx, &*data.trait_ref);\n+            enc_trait_ref(w, cx, data.trait_ref);\n             mywrite!(w, \"{}]\", token::get_name(data.item_name));\n         }\n         ty::ty_err => {\n@@ -309,7 +309,7 @@ fn enc_bound_region(w: &mut Encoder, cx: &ctxt, br: ty::BoundRegion) {\n }\n \n pub fn enc_trait_ref<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n-                               s: &ty::TraitRef<'tcx>) {\n+                               s: ty::TraitRef<'tcx>) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, s.substs);\n }\n@@ -394,7 +394,7 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n \n     for tp in &bs.trait_bounds {\n         mywrite!(w, \"I\");\n-        enc_trait_ref(w, cx, &*tp.0);\n+        enc_trait_ref(w, cx, tp.0);\n     }\n \n     for tp in &bs.projection_bounds {\n@@ -446,7 +446,7 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut Encoder,\n     match *p {\n         ty::Predicate::Trait(ref trait_ref) => {\n             mywrite!(w, \"t\");\n-            enc_trait_ref(w, cx, &*trait_ref.0.trait_ref);\n+            enc_trait_ref(w, cx, trait_ref.0.trait_ref);\n         }\n         ty::Predicate::Equate(ty::Binder(ty::EquatePredicate(a, b))) => {\n             mywrite!(w, \"e\");\n@@ -473,7 +473,7 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut Encoder,\n fn enc_projection_predicate<'a, 'tcx>(w: &mut Encoder,\n                                       cx: &ctxt<'a, 'tcx>,\n                                       data: &ty::ProjectionPredicate<'tcx>) {\n-    enc_trait_ref(w, cx, &*data.projection_ty.trait_ref);\n+    enc_trait_ref(w, cx, data.projection_ty.trait_ref);\n     mywrite!(w, \"{}|\", token::get_name(data.projection_ty.item_name));\n     enc_ty(w, cx, data.ty);\n }"}, {"sha": "4bfc4c5b850fd43f8dfe3ffe834cad4aa66662c6", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -41,7 +41,6 @@ use syntax;\n use std::cell::Cell;\n use std::io::SeekFrom;\n use std::io::prelude::*;\n-use std::rc::Rc;\n use std::fmt::Debug;\n \n use rbml::reader;\n@@ -890,7 +889,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"MethodTypeParam\", 2, 1, |this| {\n                         this.emit_struct(\"MethodParam\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &*p.trait_ref))\n+                                Ok(this.emit_trait_ref(ecx, &p.trait_ref))\n                             }));\n                             try!(this.emit_struct_field(\"method_num\", 0, |this| {\n                                 this.emit_uint(p.method_num)\n@@ -914,7 +913,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"MethodTraitObject\", 3, 1, |this| {\n                         this.emit_struct(\"MethodObject\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &*o.trait_ref))\n+                                Ok(this.emit_trait_ref(ecx, &o.trait_ref))\n                             }));\n                             try!(this.emit_struct_field(\"object_trait_id\", 0, |this| {\n                                 Ok(this.emit_def_id(o.object_trait_id))\n@@ -1208,7 +1207,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     if let Some(trait_ref) = tcx.object_cast_map.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.emit_trait_ref(ecx, &*trait_ref.0);\n+            rbml_w.emit_trait_ref(ecx, &trait_ref.0);\n         })\n     }\n \n@@ -1275,7 +1274,7 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                              -> Rc<ty::TraitRef<'tcx>>;\n+                              -> ty::TraitRef<'tcx>;\n     fn read_poly_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::PolyTraitRef<'tcx>;\n     fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1469,7 +1468,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n     fn read_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                              -> Rc<ty::TraitRef<'tcx>> {\n+                              -> ty::TraitRef<'tcx> {\n         self.read_opaque(|this, doc| {\n             let ty = tydecode::parse_trait_ref_data(\n                 doc.data,"}, {"sha": "091092e3b607992adc637a8fd0ffc0ac80e8c484", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -942,8 +942,8 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n     let trait_substs = tcx.mk_substs(trait_substs);\n     debug!(\"resolve_trait_associated_const: trait_substs={}\",\n            trait_substs.repr(tcx));\n-    let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: trait_id,\n-                                                      substs: trait_substs }));\n+    let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n+                                              substs: trait_substs });\n \n     ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);"}, {"sha": "86deca0c1449d5eac1773c7fa62979bcf3ab4aa4", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -16,7 +16,6 @@ use middle::traits;\n use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty_fold::{TypeFoldable, TypeFolder};\n \n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -324,7 +323,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n \n     fn accumulate_from_assoc_types(&mut self,\n-                                   trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                                   trait_ref: ty::TraitRef<'tcx>)\n     {\n         debug!(\"accumulate_from_assoc_types({})\",\n                trait_ref.repr(self.tcx()));\n@@ -442,7 +441,7 @@ pub fn object_region_bounds<'tcx>(\n     // Note that we preserve the overall binding levels here.\n     assert!(!open_ty.has_escaping_regions());\n     let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n-    let trait_refs = vec!(ty::Binder(Rc::new(ty::TraitRef::new(principal.0.def_id, substs))));\n+    let trait_refs = vec!(ty::Binder(ty::TraitRef::new(principal.0.def_id, substs)));\n \n     let param_bounds = ty::ParamBounds {\n         region_bounds: Vec::new(),"}, {"sha": "8aca64484bf4506d43b9d4bbcff305477fbe7edf", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -79,7 +79,6 @@ use middle::ty::{self, Ty};\n use middle::ty::{Region, ReFree};\n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n-use std::rc::Rc;\n use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n@@ -1680,13 +1679,13 @@ impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> Resolvable<'tcx> for Rc<ty::TraitRef<'tcx>> {\n+impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n-                   -> Rc<ty::TraitRef<'tcx>> {\n-        Rc::new(infcx.resolve_type_vars_if_possible(&**self))\n+                   -> ty::TraitRef<'tcx> {\n+        infcx.resolve_type_vars_if_possible(self)\n     }\n     fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(&**self)\n+        ty::trait_ref_contains_error(self)\n     }\n }\n \n@@ -1699,7 +1698,7 @@ impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n     }\n \n     fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(&*self.0)\n+        ty::trait_ref_contains_error(&self.0)\n     }\n }\n "}, {"sha": "b802f46e28594184eeb8c51853e5d880902dead1", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -33,7 +33,6 @@ use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell};\n use std::fmt;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n@@ -155,7 +154,7 @@ impl fmt::Display for TypeOrigin {\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n     Types(ty::expected_found<Ty<'tcx>>),\n-    TraitRefs(ty::expected_found<Rc<ty::TraitRef<'tcx>>>),\n+    TraitRefs(ty::expected_found<ty::TraitRef<'tcx>>),\n     PolyTraitRefs(ty::expected_found<ty::PolyTraitRef<'tcx>>),\n }\n \n@@ -663,8 +662,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn sub_trait_refs(&self,\n                           a_is_expected: bool,\n                           origin: TypeOrigin,\n-                          a: Rc<ty::TraitRef<'tcx>>,\n-                          b: Rc<ty::TraitRef<'tcx>>)\n+                          a: ty::TraitRef<'tcx>,\n+                          b: ty::TraitRef<'tcx>)\n                           -> UnitResult<'tcx>\n     {\n         debug!(\"sub_trait_refs({} <: {})\",\n@@ -675,7 +674,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).relate(&*a, &*b).map(|_| ())\n+            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n         })\n     }\n \n@@ -873,8 +872,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_string(&self, t: &Rc<ty::TraitRef<'tcx>>) -> String {\n-        let t = self.resolve_type_vars_if_possible(&**t);\n+    pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n+        let t = self.resolve_type_vars_if_possible(t);\n         t.user_string(self.tcx)\n     }\n "}, {"sha": "d9f8a88fddca3694b28d94d6159f1f7745447a37", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -20,7 +20,6 @@ use super::util;\n use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use middle::infer::{self, InferCtxt};\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n use util::ppaux::Repr;\n@@ -139,7 +138,7 @@ type SubstsFn = for<'a,'tcx> fn(infcx: &InferCtxt<'a, 'tcx>,\n fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                      impl_def_id: ast::DefId,\n                                      substs_fn: SubstsFn)\n-                                     -> (Rc<ty::TraitRef<'tcx>>,\n+                                     -> (ty::TraitRef<'tcx>,\n                                          Vec<PredicateObligation<'tcx>>)\n {\n     let impl_substs =\n@@ -341,5 +340,3 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n     }\n }\n-\n-"}, {"sha": "1b5719d3d42e5d84756ed8acdd5cc59869f2745c", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -191,7 +191,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         trait_ref.self_ty().user_string(infcx.tcx));\n                                 // Check if it has a custom \"#[rustc_on_unimplemented]\"\n                                 // error message, report with that message if it does\n-                                let custom_note = report_on_unimplemented(infcx, &*trait_ref.0,\n+                                let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n                                                                           obligation.cause.span);\n                                 if let Some(s) = custom_note {\n                                     infcx.tcx.sess.span_note(obligation.cause.span,"}, {"sha": "ac3c9dfbb463b3a1d0fba2d88e6aaed6431d8cbc", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -57,20 +57,18 @@ pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             -> bool\n {\n     // Because we query yes/no results frequently, we keep a cache:\n-    let cached_result =\n-        tcx.object_safety_cache.borrow().get(&trait_def_id).cloned();\n+    let def = ty::lookup_trait_def(tcx, trait_def_id);\n \n-    let result =\n-        cached_result.unwrap_or_else(|| {\n-            let result = object_safety_violations(tcx, trait_def_id).is_empty();\n+    let result = def.object_safety().unwrap_or_else(|| {\n+        let result = object_safety_violations(tcx, trait_def_id).is_empty();\n \n-            // Record just a yes/no result in the cache; this is what is\n-            // queried most frequently. Note that this may overwrite a\n-            // previous result, but always with the same thing.\n-            tcx.object_safety_cache.borrow_mut().insert(trait_def_id, result);\n+        // Record just a yes/no result in the cache; this is what is\n+        // queried most frequently. Note that this may overwrite a\n+        // previous result, but always with the same thing.\n+        def.set_object_safety(result);\n \n-            result\n-        });\n+        result\n+    });\n \n     debug!(\"is_object_safe({}) = {}\", trait_def_id.repr(tcx), result);\n "}, {"sha": "8ae7ad029ac3feac3d61b8832f692510b1d30e6f", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -25,7 +25,6 @@ use middle::subst::{Subst, Substs};\n use middle::ty::{self, AsPredicate, ReferencesError, RegionEscape,\n                  HasProjectionTypes, ToPolyTraitRef, Ty};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::parse::token;\n use util::common::FN_OUTPUT_NAME;\n@@ -525,7 +524,7 @@ fn project_type<'cx,'tcx>(\n fn assemble_candidates_from_param_env<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n     let env_predicates = selcx.param_env().caller_bounds.clone();\n@@ -546,7 +545,7 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n     // Check whether the self-type is itself a projection.\n@@ -571,7 +570,7 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n fn assemble_candidates_from_predicates<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     env_predicates: Vec<ty::Predicate<'tcx>>)\n {\n@@ -614,7 +613,7 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n fn assemble_candidates_from_object_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     object_ty: Ty<'tcx>)\n {\n@@ -641,7 +640,7 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n fn assemble_candidates_from_impls<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n     -> Result<(), SelectionError<'tcx>>\n {"}, {"sha": "49371eae2652d78c00c0860daa73f53b3d56109a", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -89,7 +89,7 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n \n #[derive(Clone)]\n pub struct SelectionCache<'tcx> {\n-    hashmap: RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+    hashmap: RefCell<FnvHashMap<ty::TraitRef<'tcx>,\n                                 SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n }\n \n@@ -988,7 +988,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn match_projection(&mut self,\n                         obligation: &TraitObligation<'tcx>,\n                         trait_bound: ty::PolyTraitRef<'tcx>,\n-                        skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                        skol_trait_ref: ty::TraitRef<'tcx>,\n                         skol_map: &infer::SkolemizationMap,\n                         snapshot: &infer::CombinedSnapshot)\n                         -> bool\n@@ -1153,18 +1153,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         debug!(\"assemble_candidates_from_impls(obligation={})\", obligation.repr(self.tcx()));\n \n-        let def_id = obligation.predicate.def_id();\n-        let all_impls = self.all_impls(def_id);\n-        for &impl_def_id in &all_impls {\n-            self.infcx.probe(|snapshot| {\n-                match self.match_impl(impl_def_id, obligation, snapshot) {\n-                    Ok(_) => {\n+        let def = ty::lookup_trait_def(self.tcx(), obligation.predicate.def_id());\n+\n+        def.for_each_relevant_impl(\n+            self.tcx(),\n+            obligation.predicate.0.trait_ref.self_ty(),\n+            |impl_def_id| {\n+                self.infcx.probe(|snapshot| {\n+                    if let Ok(_) = self.match_impl(impl_def_id, obligation, snapshot) {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n                     }\n-                    Err(()) => { }\n-                }\n-            });\n-        }\n+                });\n+            }\n+        );\n \n         Ok(())\n     }\n@@ -2324,7 +2325,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Before we create the substitutions and everything, first\n         // consider a \"quick reject\". This avoids creating more types\n         // and so forth that we need to.\n-        if self.fast_reject_trait_refs(obligation, &*impl_trait_ref) {\n+        if self.fast_reject_trait_refs(obligation, &impl_trait_ref) {\n             return Err(());\n         }\n \n@@ -2529,16 +2530,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    /// Returns set of all impls for a given trait.\n-    fn all_impls(&self, trait_def_id: ast::DefId) -> Vec<ast::DefId> {\n-        ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_def_id);\n-\n-        match self.tcx().trait_impls.borrow().get(&trait_def_id) {\n-            None => Vec::new(),\n-            Some(impls) => impls.borrow().clone(),\n-        }\n-    }\n-\n     fn closure_trait_ref(&self,\n                          obligation: &TraitObligation<'tcx>,\n                          closure_def_id: ast::DefId,"}, {"sha": "a6b2359c2b877b88625661f5ee4a3eaad612af3b", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -12,7 +12,6 @@ use middle::subst::{Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, AsPredicate, ToPolyTraitRef};\n use std::fmt;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n use util::common::ErrorReported;\n@@ -336,14 +335,14 @@ pub fn trait_ref_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     param_ty: Ty<'tcx>)\n-    -> Result<Rc<ty::TraitRef<'tcx>>, ErrorReported>\n+    -> Result<ty::TraitRef<'tcx>, ErrorReported>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n-            Ok(Rc::new(ty::TraitRef {\n+            Ok(ty::TraitRef {\n                 def_id: def_id,\n                 substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n-            }))\n+            })\n         }\n         Err(e) => {\n             tcx.sess.err(&e);\n@@ -355,7 +354,7 @@ pub fn trait_ref_for_builtin_bound<'tcx>(\n \n pub fn predicate_for_trait_ref<'tcx>(\n     cause: ObligationCause<'tcx>,\n-    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    trait_ref: ty::TraitRef<'tcx>,\n     recursion_depth: usize)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n@@ -374,10 +373,10 @@ pub fn predicate_for_trait_def<'tcx>(\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n-    let trait_ref = Rc::new(ty::TraitRef {\n+    let trait_ref = ty::TraitRef {\n         def_id: trait_def_id,\n         substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n-    });\n+    };\n     predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n }\n \n@@ -466,17 +465,17 @@ pub fn closure_trait_ref_and_return_type<'tcx>(\n     self_ty: Ty<'tcx>,\n     sig: &ty::PolyFnSig<'tcx>,\n     tuple_arguments: TupleArgumentsFlag)\n-    -> ty::Binder<(Rc<ty::TraitRef<'tcx>>, Ty<'tcx>)>\n+    -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)>\n {\n     let arguments_tuple = match tuple_arguments {\n         TupleArgumentsFlag::No => sig.0.inputs[0],\n         TupleArgumentsFlag::Yes => ty::mk_tup(tcx, sig.0.inputs.to_vec()),\n     };\n     let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n-    let trait_ref = Rc::new(ty::TraitRef {\n+    let trait_ref = ty::TraitRef {\n         def_id: fn_trait_def_id,\n         substs: tcx.mk_substs(trait_substs),\n-    });\n+    };\n     ty::Binder((trait_ref, sig.0.output.unwrap_or(ty::mk_nil(tcx))))\n }\n "}, {"sha": "41bd52dc25c21a09d1569ecd77d5ada59866f80f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 182, "deletions": 84, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -45,6 +45,7 @@ use middle::check_const;\n use middle::const_eval;\n use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n+use middle::fast_reject;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::mem_categorization as mc;\n@@ -433,7 +434,7 @@ pub struct MethodParam<'tcx> {\n     // be a supertrait of what the user actually typed. Note that it\n     // never contains bound regions; those regions should have been\n     // instantiated with fresh variables at this point.\n-    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub trait_ref: ty::TraitRef<'tcx>,\n \n     // index of usize in the list of trait items. Note that this is NOT\n     // the index into the vtable, because the list of trait items\n@@ -451,7 +452,7 @@ pub struct MethodParam<'tcx> {\n #[derive(Clone, Debug)]\n pub struct MethodObject<'tcx> {\n     // the (super)trait containing the method to be invoked\n-    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub trait_ref: TraitRef<'tcx>,\n \n     // the actual base trait id of the object\n     pub object_trait_id: ast::DefId,\n@@ -588,10 +589,14 @@ pub struct TransmuteRestriction<'tcx> {\n \n /// Internal storage\n pub struct CtxtArenas<'tcx> {\n+    // internings\n     type_: TypedArena<TyS<'tcx>>,\n     substs: TypedArena<Substs<'tcx>>,\n     bare_fn: TypedArena<BareFnTy<'tcx>>,\n     region: TypedArena<Region>,\n+\n+    // references\n+    trait_defs: TypedArena<TraitDef<'tcx>>\n }\n \n impl<'tcx> CtxtArenas<'tcx> {\n@@ -601,6 +606,8 @@ impl<'tcx> CtxtArenas<'tcx> {\n             substs: TypedArena::new(),\n             bare_fn: TypedArena::new(),\n             region: TypedArena::new(),\n+\n+            trait_defs: TypedArena::new()\n         }\n     }\n }\n@@ -678,10 +685,10 @@ pub struct ctxt<'tcx> {\n     /// A cache for the trait_items() routine\n     pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ImplOrTraitItem<'tcx>>>>>,\n \n-    pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef<'tcx>>>>>,\n+    pub impl_trait_cache: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n \n-    pub impl_trait_refs: RefCell<NodeMap<Rc<TraitRef<'tcx>>>>,\n-    pub trait_defs: RefCell<DefIdMap<Rc<TraitDef<'tcx>>>>,\n+    pub impl_trait_refs: RefCell<NodeMap<TraitRef<'tcx>>>,\n+    pub trait_defs: RefCell<DefIdMap<&'tcx TraitDef<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated predicates.\n@@ -731,12 +738,6 @@ pub struct ctxt<'tcx> {\n     /// A method will be in this list if and only if it is a destructor.\n     pub destructors: RefCell<DefIdSet>,\n \n-    /// Maps a trait onto a list of impls of that trait.\n-    pub trait_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n-\n-    /// A set of traits that have a default impl\n-    traits_with_default_impls: RefCell<DefIdMap<()>>,\n-\n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n@@ -760,12 +761,8 @@ pub struct ctxt<'tcx> {\n     /// The set of external nominal types whose implementations have been read.\n     /// This is used for lazy resolution of methods.\n     pub populated_external_types: RefCell<DefIdSet>,\n-\n-    /// The set of external traits whose implementations have been read. This\n-    /// is used for lazy resolution of traits.\n-    pub populated_external_traits: RefCell<DefIdSet>,\n-\n-    /// The set of external primitive inherent implementations that have been read.\n+    /// The set of external primitive types whose implementations have been read.\n+    /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n     /// Borrows\n@@ -819,9 +816,6 @@ pub struct ctxt<'tcx> {\n     /// results are dependent on the parameter environment.\n     pub type_impls_sized_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n \n-    /// Caches whether traits are object safe\n-    pub object_safety_cache: RefCell<DefIdMap<bool>>,\n-\n     /// Maps Expr NodeId's to their constant qualification.\n     pub const_qualif_map: RefCell<NodeMap<check_const::ConstQualif>>,\n }\n@@ -832,6 +826,13 @@ impl<'tcx> ctxt<'tcx> {\n         self.node_types.borrow_mut().insert(id, ty);\n     }\n \n+    pub fn intern_trait_def(&self, def: TraitDef<'tcx>) -> &'tcx TraitDef<'tcx> {\n+        let did = def.trait_ref.def_id;\n+        let interned = self.arenas.trait_defs.alloc(def);\n+        self.trait_defs.borrow_mut().insert(did, interned);\n+        interned\n+    }\n+\n     pub fn store_free_region_map(&self, id: NodeId, map: FreeRegionMap) {\n         self.free_region_maps.borrow_mut()\n                              .insert(id, map);\n@@ -953,6 +954,7 @@ impl fmt::Debug for TypeFlags {\n }\n \n impl<'tcx> PartialEq for TyS<'tcx> {\n+    #[inline]\n     fn eq(&self, other: &TyS<'tcx>) -> bool {\n         // (self as *const _) == (other as *const _)\n         (self as *const TyS<'tcx>) == (other as *const TyS<'tcx>)\n@@ -1414,10 +1416,10 @@ impl<'tcx> TyTrait<'tcx> {\n         // otherwise the escaping regions would be captured by the binder\n         assert!(!self_ty.has_escaping_regions());\n \n-        ty::Binder(Rc::new(ty::TraitRef {\n+        ty::Binder(TraitRef {\n             def_id: self.principal.0.def_id,\n             substs: tcx.mk_substs(self.principal.0.substs.with_self_ty(self_ty)),\n-        }))\n+        })\n     }\n \n     pub fn projection_bounds_with_self_ty(&self,\n@@ -1432,9 +1434,8 @@ impl<'tcx> TyTrait<'tcx> {\n             .map(|in_poly_projection_predicate| {\n                 let in_projection_ty = &in_poly_projection_predicate.0.projection_ty;\n                 let substs = tcx.mk_substs(in_projection_ty.trait_ref.substs.with_self_ty(self_ty));\n-                let trait_ref =\n-                    Rc::new(ty::TraitRef::new(in_projection_ty.trait_ref.def_id,\n-                                              substs));\n+                let trait_ref = ty::TraitRef::new(in_projection_ty.trait_ref.def_id,\n+                                              substs);\n                 let projection_ty = ty::ProjectionTy {\n                     trait_ref: trait_ref,\n                     item_name: in_projection_ty.item_name\n@@ -1463,13 +1464,13 @@ impl<'tcx> TyTrait<'tcx> {\n /// Note that a `TraitRef` introduces a level of region binding, to\n /// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n /// U>` or higher-ranked object types.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n-pub type PolyTraitRef<'tcx> = Binder<Rc<TraitRef<'tcx>>>;\n+pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n \n impl<'tcx> PolyTraitRef<'tcx> {\n     pub fn self_ty(&self) -> Ty<'tcx> {\n@@ -1995,7 +1996,7 @@ impl<'tcx> Predicate<'tcx> {\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TraitPredicate<'tcx> {\n-    pub trait_ref: Rc<TraitRef<'tcx>>\n+    pub trait_ref: TraitRef<'tcx>\n }\n pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n \n@@ -2064,7 +2065,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ProjectionTy<'tcx> {\n     /// The trait reference `T as Trait<..>`.\n-    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub trait_ref: ty::TraitRef<'tcx>,\n \n     /// The name `N` of the associated type.\n     pub item_name: ast::Name,\n@@ -2080,7 +2081,7 @@ pub trait ToPolyTraitRef<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx>;\n }\n \n-impl<'tcx> ToPolyTraitRef<'tcx> for Rc<TraitRef<'tcx>> {\n+impl<'tcx> ToPolyTraitRef<'tcx> for TraitRef<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n         assert!(!self.has_escaping_regions());\n         ty::Binder(self.clone())\n@@ -2108,7 +2109,7 @@ pub trait AsPredicate<'tcx> {\n     fn as_predicate(&self) -> Predicate<'tcx>;\n }\n \n-impl<'tcx> AsPredicate<'tcx> for Rc<TraitRef<'tcx>> {\n+impl<'tcx> AsPredicate<'tcx> for TraitRef<'tcx> {\n     fn as_predicate(&self) -> Predicate<'tcx> {\n         // we're about to add a binder, so let's check that we don't\n         // accidentally capture anything, or else that might be some\n@@ -2488,6 +2489,16 @@ pub struct TypeScheme<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n+bitflags! {\n+    flags TraitFlags: u32 {\n+        const NO_TRAIT_FLAGS        = 0,\n+        const HAS_DEFAULT_IMPL      = 1 << 0,\n+        const IS_OBJECT_SAFE        = 1 << 1,\n+        const OBJECT_SAFETY_VALID   = 1 << 2,\n+        const IMPLS_VALID           = 1 << 3,\n+    }\n+}\n+\n /// As `TypeScheme` but for a trait ref.\n pub struct TraitDef<'tcx> {\n     pub unsafety: ast::Unsafety,\n@@ -2505,11 +2516,117 @@ pub struct TraitDef<'tcx> {\n     /// implements the trait.\n     pub generics: Generics<'tcx>,\n \n-    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub trait_ref: TraitRef<'tcx>,\n \n     /// A list of the associated types defined in this trait. Useful\n     /// for resolving `X::Foo` type markers.\n     pub associated_type_names: Vec<ast::Name>,\n+\n+    // Impls of this trait. To allow for quicker lookup, the impls are indexed\n+    // by a simplified version of their Self type: impls with a simplifiable\n+    // Self are stored in nonblanket_impls keyed by it, while all other impls\n+    // are stored in blanket_impls.\n+\n+    /// Impls of the trait.\n+    pub nonblanket_impls: RefCell<\n+        FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n+    >,\n+\n+    /// Blanket impls associated with the trait.\n+    pub blanket_impls: RefCell<Vec<DefId>>,\n+\n+    /// Various flags\n+    pub flags: Cell<TraitFlags>\n+}\n+\n+impl<'tcx> TraitDef<'tcx> {\n+    // returns None if not yet calculated\n+    pub fn object_safety(&self) -> Option<bool> {\n+        if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n+            Some(self.flags.get().intersects(TraitFlags::IS_OBJECT_SAFE))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn set_object_safety(&self, is_safe: bool) {\n+        assert!(self.object_safety().map(|cs| cs == is_safe).unwrap_or(true));\n+        self.flags.set(\n+            self.flags.get() | if is_safe {\n+                TraitFlags::OBJECT_SAFETY_VALID | TraitFlags::IS_OBJECT_SAFE\n+            } else {\n+                TraitFlags::OBJECT_SAFETY_VALID\n+            }\n+        );\n+    }\n+\n+    /// Records a trait-to-implementation mapping.\n+    pub fn record_impl(&self,\n+                       tcx: &ctxt<'tcx>,\n+                       impl_def_id: DefId,\n+                       impl_trait_ref: TraitRef<'tcx>) {\n+        // We don't want to borrow_mut after we already populated all impls,\n+        // so check if an impl is present with an immutable borrow first.\n+\n+        if let Some(sty) = fast_reject::simplify_type(tcx,\n+                                                      impl_trait_ref.self_ty(), false) {\n+            if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n+                if is.contains(&impl_def_id) {\n+                    return // duplicate - skip\n+                }\n+            }\n+\n+            self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n+        } else {\n+            if self.blanket_impls.borrow().contains(&impl_def_id) {\n+                return // duplicate - skip\n+            }\n+            self.blanket_impls.borrow_mut().push(impl_def_id)\n+        }\n+    }\n+\n+\n+    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &ctxt<'tcx>, mut f: F)  {\n+        ty::populate_implementations_for_trait_if_necessary(tcx, self.trait_ref.def_id);\n+\n+        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+            f(impl_def_id);\n+        }\n+\n+        for v in self.nonblanket_impls.borrow().values() {\n+            for &impl_def_id in v {\n+                f(impl_def_id);\n+            }\n+        }\n+    }\n+\n+    pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n+                                                   tcx: &ctxt<'tcx>,\n+                                                   self_ty: Ty<'tcx>,\n+                                                   mut f: F)\n+    {\n+        ty::populate_implementations_for_trait_if_necessary(tcx, self.trait_ref.def_id);\n+\n+        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+            f(impl_def_id);\n+        }\n+\n+        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, false) {\n+            if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n+                for &impl_def_id in impls {\n+                    f(impl_def_id);\n+                }\n+                return; // we don't need to process the other non-blanket impls\n+            }\n+        }\n+\n+        for v in self.nonblanket_impls.borrow().values() {\n+            for &impl_def_id in v {\n+                f(impl_def_id);\n+            }\n+        }\n+    }\n+\n }\n \n /// Records the substitutions used to translate the polytype for an\n@@ -2669,14 +2786,11 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         struct_fields: RefCell::new(DefIdMap()),\n         destructor_for_type: RefCell::new(DefIdMap()),\n         destructors: RefCell::new(DefIdSet()),\n-        trait_impls: RefCell::new(DefIdMap()),\n-        traits_with_default_impls: RefCell::new(DefIdMap()),\n         inherent_impls: RefCell::new(DefIdMap()),\n         impl_items: RefCell::new(DefIdMap()),\n         used_unsafe: RefCell::new(NodeSet()),\n         used_mut_nodes: RefCell::new(NodeSet()),\n         populated_external_types: RefCell::new(DefIdSet()),\n-        populated_external_traits: RefCell::new(DefIdSet()),\n         populated_external_primitive_impls: RefCell::new(DefIdSet()),\n         upvar_capture_map: RefCell::new(FnvHashMap()),\n         extern_const_statics: RefCell::new(DefIdMap()),\n@@ -2693,7 +2807,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         repr_hint_cache: RefCell::new(DefIdMap()),\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n-        object_safety_cache: RefCell::new(DefIdMap()),\n         const_qualif_map: RefCell::new(NodeMap()),\n    }\n }\n@@ -3132,7 +3245,7 @@ pub fn sort_bounds_list(bounds: &mut [ty::PolyProjectionPredicate]) {\n }\n \n pub fn mk_projection<'tcx>(cx: &ctxt<'tcx>,\n-                           trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                           trait_ref: TraitRef<'tcx>,\n                            item_name: ast::Name)\n                            -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n@@ -4398,9 +4511,9 @@ pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n }\n \n pub fn impl_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n-                                  -> Rc<ty::TraitRef<'tcx>> {\n+                                  -> ty::TraitRef<'tcx> {\n     match cx.impl_trait_refs.borrow().get(&id) {\n-        Some(ty) => ty.clone(),\n+        Some(ty) => *ty,\n         None => cx.sess.bug(\n             &format!(\"impl_id_to_trait_ref: no trait ref for impl `{}`\",\n                     cx.map.node_to_string(id)))\n@@ -5313,7 +5426,7 @@ pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n }\n \n pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n-                            -> Option<Rc<TraitRef<'tcx>>> {\n+                            -> Option<TraitRef<'tcx>> {\n     memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n             debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n@@ -5821,10 +5934,10 @@ pub fn lookup_item_type<'tcx>(cx: &ctxt<'tcx>,\n \n /// Given the did of a trait, returns its canonical trait ref.\n pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n-                              -> Rc<TraitDef<'tcx>> {\n+                              -> &'tcx TraitDef<'tcx> {\n     memoized(&cx.trait_defs, did, |did: DefId| {\n         assert!(did.krate != ast::LOCAL_CRATE);\n-        Rc::new(csearch::get_trait_def(cx, did))\n+        cx.arenas.trait_defs.alloc(csearch::get_trait_def(cx, did))\n     })\n }\n \n@@ -6213,50 +6326,36 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n \n pub fn trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) -> bool {\n     populate_implementations_for_trait_if_necessary(tcx, trait_def_id);\n-    tcx.traits_with_default_impls.borrow().contains_key(&trait_def_id)\n-}\n \n-/// Records a trait-to-implementation mapping.\n-pub fn record_trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) {\n-    // We're using the latest implementation found as the reference one.\n-    // Duplicated implementations are caught and reported in the coherence\n-    // step.\n-    tcx.traits_with_default_impls.borrow_mut().insert(trait_def_id, ());\n+    let def = lookup_trait_def(tcx, trait_def_id);\n+    def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n }\n \n /// Records a trait-to-implementation mapping.\n-pub fn record_trait_implementation(tcx: &ctxt,\n-                                   trait_def_id: DefId,\n-                                   impl_def_id: DefId) {\n-\n-    match tcx.trait_impls.borrow().get(&trait_def_id) {\n-        Some(impls_for_trait) => {\n-            impls_for_trait.borrow_mut().push(impl_def_id);\n-            return;\n-        }\n-        None => {}\n-    }\n-\n-    tcx.trait_impls.borrow_mut().insert(trait_def_id, Rc::new(RefCell::new(vec!(impl_def_id))));\n+pub fn record_trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) {\n+    let def = lookup_trait_def(tcx, trait_def_id);\n+    def.flags.set(def.flags.get() | TraitFlags::HAS_DEFAULT_IMPL)\n }\n \n /// Load primitive inherent implementations if necessary\n-pub fn populate_implementations_for_primitive_if_necessary(tcx: &ctxt, lang_def_id: ast::DefId) {\n-    if lang_def_id.krate == LOCAL_CRATE {\n+pub fn populate_implementations_for_primitive_if_necessary(tcx: &ctxt,\n+                                                           primitive_def_id: ast::DefId) {\n+    if primitive_def_id.krate == LOCAL_CRATE {\n         return\n     }\n-    if tcx.populated_external_primitive_impls.borrow().contains(&lang_def_id) {\n+\n+    if tcx.populated_external_primitive_impls.borrow().contains(&primitive_def_id) {\n         return\n     }\n \n-    debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\", lang_def_id);\n+    debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\",\n+           primitive_def_id);\n \n-    let impl_items = csearch::get_impl_items(&tcx.sess.cstore, lang_def_id);\n+    let impl_items = csearch::get_impl_items(&tcx.sess.cstore, primitive_def_id);\n \n     // Store the implementation info.\n-    tcx.impl_items.borrow_mut().insert(lang_def_id, impl_items);\n-\n-    tcx.populated_external_primitive_impls.borrow_mut().insert(lang_def_id);\n+    tcx.impl_items.borrow_mut().insert(primitive_def_id, impl_items);\n+    tcx.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n }\n \n /// Populates the type context with all the implementations for the given type\n@@ -6266,6 +6365,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n     if type_id.krate == LOCAL_CRATE {\n         return\n     }\n+\n     if tcx.populated_external_types.borrow().contains(&type_id) {\n         return\n     }\n@@ -6276,10 +6376,12 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id, |impl_def_id| {\n         let impl_items = csearch::get_impl_items(&tcx.sess.cstore, impl_def_id);\n \n-        // Record the trait->implementation mappings, if applicable.\n-        let associated_traits = csearch::get_impl_trait(tcx, impl_def_id);\n-        if let Some(ref trait_ref) = associated_traits {\n-            record_trait_implementation(tcx, trait_ref.def_id, impl_def_id);\n+        // Record the implementation, if needed\n+        if let Some(trait_ref) = csearch::get_impl_trait(tcx, impl_def_id) {\n+            let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n+            trait_def.record_impl(tcx, impl_def_id, trait_ref);\n+        } else {\n+            inherent_impls.push(impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n@@ -6300,11 +6402,6 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n \n         // Store the implementation info.\n         tcx.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n-\n-        // If this is an inherent implementation, record it.\n-        if associated_traits.is_none() {\n-            inherent_impls.push(impl_def_id);\n-        }\n     });\n \n     tcx.inherent_impls.borrow_mut().insert(type_id, Rc::new(inherent_impls));\n@@ -6320,7 +6417,8 @@ pub fn populate_implementations_for_trait_if_necessary(\n         return\n     }\n \n-    if tcx.populated_external_traits.borrow().contains(&trait_id) {\n+    let def = lookup_trait_def(tcx, trait_id);\n+    if def.flags.get().intersects(TraitFlags::IMPLS_VALID) {\n         return\n     }\n \n@@ -6330,9 +6428,9 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n     csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id, |implementation_def_id| {\n         let impl_items = csearch::get_impl_items(&tcx.sess.cstore, implementation_def_id);\n-\n+        let trait_ref = impl_trait_ref(tcx, implementation_def_id).unwrap();\n         // Record the trait->implementation mapping.\n-        record_trait_implementation(tcx, trait_id, implementation_def_id);\n+        def.record_impl(tcx, implementation_def_id, trait_ref);\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n@@ -6354,7 +6452,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n         tcx.impl_items.borrow_mut().insert(implementation_def_id, impl_items);\n     });\n \n-    tcx.populated_external_traits.borrow_mut().insert(trait_id);\n+    def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n }\n \n /// Given the def_id of an impl, return the def_id of the trait it implements."}, {"sha": "0ef7b5be1fbd805377471a6ed68d90be58bff8d0", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -321,8 +321,8 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionTy<'tcx> {\n             Err(ty::terr_projection_name_mismatched(\n                 expected_found(relation, &a.item_name, &b.item_name)))\n         } else {\n-            let trait_ref = try!(relation.relate(&*a.trait_ref, &*b.trait_ref));\n-            Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n+            let trait_ref = try!(relation.relate(&a.trait_ref, &b.trait_ref));\n+            Ok(ty::ProjectionTy { trait_ref: trait_ref, item_name: a.item_name })\n         }\n     }\n }\n@@ -652,4 +652,3 @@ pub fn expected_found_bool<T>(a_is_expected: bool,\n         ty::expected_found {expected: b, found: a}\n     }\n }\n-"}, {"sha": "aa89c1943a2e3855feb1f772995bf35ca77665f4", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -671,7 +671,7 @@ impl<'tcx> Repr<'tcx> for def::Def {\n /// projection bounds, so we just stuff them altogether. But in\n /// reality we should eventually sort things out better.\n type TraitAndProjections<'tcx> =\n-    (Rc<ty::TraitRef<'tcx>>, Vec<ty::ProjectionPredicate<'tcx>>);\n+    (ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n \n impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {"}, {"sha": "19e71d6e40d5aecc755863a9042837d4d5fd5549", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -1745,17 +1745,16 @@ impl LintPass for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let impls = cx.tcx.trait_impls.borrow();\n-            let impls = match impls.get(&debug) {\n-                Some(impls) => {\n-                    impls.borrow().iter()\n-                         .filter(|d| d.krate == ast::LOCAL_CRATE)\n-                         .filter_map(|d| ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)))\n-                         .map(|d| d.node)\n-                         .collect()\n+            let debug_def = ty::lookup_trait_def(cx.tcx, debug);\n+            let mut impls = NodeSet();\n+            debug_def.for_each_impl(cx.tcx, |d| {\n+                if d.krate == ast::LOCAL_CRATE {\n+                    if let Some(ty_def) = ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)) {\n+                        impls.insert(ty_def.node);\n+                    }\n                 }\n-                None => NodeSet(),\n-            };\n+            });\n+\n             self.impling_types = Some(impls);\n             debug!(\"{:?}\", self.impling_types);\n         }"}, {"sha": "e87c058faf9c19b3626b5a77b3673e9a8ff56b74", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -452,7 +452,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n                     // Compute the first substitution\n                     let first_subst =\n-                        ty::make_substs_for_receiver_types(tcx, &*trait_ref, &*method)\n+                        ty::make_substs_for_receiver_types(tcx, &trait_ref, &*method)\n                         .erase_regions();\n \n                     // And compose them"}, {"sha": "7be1f3813d72fc6a75cd21a16311c7e71da48609", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -86,7 +86,6 @@ use syntax::ptr::P;\n use syntax::parse::token;\n use std::iter::repeat;\n use std::mem;\n-use std::rc::Rc;\n \n // Destinations\n \n@@ -320,8 +319,8 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             // Note that we preserve binding levels here:\n             let substs = principal.0.substs.with_self_ty(source).erase_regions();\n             let substs = ccx.tcx().mk_substs(substs);\n-            let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: principal.def_id(),\n-                                                               substs: substs }));\n+            let trait_ref = ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n+                                                      substs: substs });\n             consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n                             Type::vtable_ptr(ccx))\n         }"}, {"sha": "7039968b029ac776284dfcc55ec7449f0c5c884e", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -40,7 +40,6 @@ use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use util::ppaux::Repr;\n \n-use std::rc::Rc;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n use syntax::{ast, ast_map, attr, visit};\n@@ -232,8 +231,8 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                              Vec::new()));\n     let trait_substs = tcx.mk_substs(trait_substs);\n     debug!(\"trait_substs={}\", trait_substs.repr(tcx));\n-    let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: trait_id,\n-                                                      substs: trait_substs }));\n+    let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n+                                              substs: trait_substs });\n     let vtbl = fulfill_obligation(ccx,\n                                   DUMMY_SP,\n                                   trait_ref);"}, {"sha": "694993cdc0aae29526a4f161472c215fda0568d1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -64,7 +64,6 @@ use util::nodemap::FnvHashSet;\n use util::ppaux::{self, Repr, UserString};\n \n use std::iter::repeat;\n-use std::rc::Rc;\n use std::slice;\n use syntax::{abi, ast, ast_util};\n use syntax::codemap::{Span, Pos};\n@@ -83,7 +82,7 @@ pub trait AstConv<'tcx> {\n     /// Returns the `TraitDef` for a given trait. This allows you to\n     /// figure out the set of type parameters defined on the trait.\n     fn get_trait_def(&self, span: Span, id: ast::DefId)\n-                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>;\n+                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>;\n \n     /// Ensure that the super-predicates for the trait with the given\n     /// id are available and also for the transitive set of\n@@ -140,7 +139,7 @@ pub trait AstConv<'tcx> {\n     /// This is fairly straightforward and can be accommodated in any context.\n     fn projected_ty(&self,\n                     span: Span,\n-                    _trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    _trait_ref: ty::TraitRef<'tcx>,\n                     _item_name: ast::Name)\n                     -> Ty<'tcx>;\n }\n@@ -633,7 +632,7 @@ pub fn instantiate_mono_trait_ref<'tcx>(\n     rscope: &RegionScope,\n     trait_ref: &ast::TraitRef,\n     self_ty: Option<Ty<'tcx>>)\n-    -> Rc<ty::TraitRef<'tcx>>\n+    -> ty::TraitRef<'tcx>\n {\n     let trait_def_id = trait_def_id(this, trait_ref);\n     ast_path_to_mono_trait_ref(this,\n@@ -702,7 +701,7 @@ fn ast_path_to_poly_trait_ref<'a,'tcx>(\n                                         trait_def_id,\n                                         self_ty,\n                                         trait_segment);\n-    let poly_trait_ref = ty::Binder(Rc::new(ty::TraitRef::new(trait_def_id, substs)));\n+    let poly_trait_ref = ty::Binder(ty::TraitRef::new(trait_def_id, substs));\n \n     {\n         let converted_bindings =\n@@ -730,7 +729,7 @@ fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n                                        trait_def_id: ast::DefId,\n                                        self_ty: Option<Ty<'tcx>>,\n                                        trait_segment: &ast::PathSegment)\n-                                       -> Rc<ty::TraitRef<'tcx>>\n+                                       -> ty::TraitRef<'tcx>\n {\n     let (substs, assoc_bindings) =\n         create_substs_for_ast_trait_ref(this,\n@@ -741,7 +740,7 @@ fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n                                         self_ty,\n                                         trait_segment);\n     prohibit_projections(this.tcx(), &assoc_bindings);\n-    Rc::new(ty::TraitRef::new(trait_def_id, substs))\n+    ty::TraitRef::new(trait_def_id, substs)\n }\n \n fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n@@ -856,8 +855,8 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n         let mut dummy_substs = trait_ref.skip_binder().substs.clone(); // binder moved here -+\n         assert!(dummy_substs.self_ty().is_none());                     //                    |\n         dummy_substs.types.push(SelfSpace, dummy_self_ty);             //                    |\n-        trait_ref = ty::Binder(Rc::new(ty::TraitRef::new(trait_ref.def_id(), // <------------+\n-                                                         tcx.mk_substs(dummy_substs))));\n+        trait_ref = ty::Binder(ty::TraitRef::new(trait_ref.def_id(),   // <------------+\n+                                                 tcx.mk_substs(dummy_substs)));\n     }\n \n     try!(this.ensure_super_predicates(binding.span, trait_ref.def_id()));\n@@ -874,8 +873,8 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n             let mut dummy_substs = candidate.0.substs.clone();\n             assert!(dummy_substs.self_ty() == Some(dummy_self_ty));\n             dummy_substs.types.pop(SelfSpace);\n-            *candidate = ty::Binder(Rc::new(ty::TraitRef::new(candidate.def_id(),\n-                                                              tcx.mk_substs(dummy_substs))));\n+            *candidate = ty::Binder(ty::TraitRef::new(candidate.def_id(),\n+                                                      tcx.mk_substs(dummy_substs)));\n         }\n     }\n "}, {"sha": "c068bfaa82eb74b23ab3f4c9027d625c0c8dbadf", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -23,7 +23,6 @@ use middle::infer;\n use middle::infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::Span;\n-use std::rc::Rc;\n use std::iter::repeat;\n use util::ppaux::Repr;\n \n@@ -276,7 +275,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                                                  self.infcx().next_ty_var());\n \n                 let trait_ref =\n-                    Rc::new(ty::TraitRef::new(trait_def_id, self.tcx().mk_substs(substs.clone())));\n+                    ty::TraitRef::new(trait_def_id, self.tcx().mk_substs(substs.clone()));\n                 let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n                                                            method_num: method_num,\n                                                            impl_def_id: None });"}, {"sha": "c070df6b5939df96a99f307e989ec348b2824f00", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -170,7 +170,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Construct a trait-reference `self_ty : Trait<input_tys>`\n     let substs = subst::Substs::new_trait(input_types, Vec::new(), self_ty);\n-    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, fcx.tcx().mk_substs(substs)));\n+    let trait_ref = ty::TraitRef::new(trait_def_id, fcx.tcx().mk_substs(substs));\n \n     // Construct an obligation\n     let poly_trait_ref = trait_ref.to_poly_trait_ref();"}, {"sha": "c94fa03702681bcb5fdd52131ab98cf7b8489c08", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -61,7 +61,7 @@ struct Candidate<'tcx> {\n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n     ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ usize, /* vtable index */ usize),\n-    ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n+    ExtensionImplCandidate(/* Impl */ ast::DefId, ty::TraitRef<'tcx>,\n                            subst::Substs<'tcx>, ItemIndex),\n     ClosureCandidate(/* Trait */ ast::DefId, ItemIndex),\n     WhereClauseCandidate(ty::PolyTraitRef<'tcx>, ItemIndex),\n@@ -624,23 +624,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                      item: ty::ImplOrTraitItem<'tcx>,\n                                                      item_index: usize)\n     {\n-        ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n-                                                            trait_def_id);\n-\n-        let trait_impls = self.tcx().trait_impls.borrow();\n-        let impl_def_ids = trait_impls.get(&trait_def_id);\n-        let impl_def_ids = match impl_def_ids {\n-            None => { return; }\n-            Some(impls) => impls,\n-        };\n+        let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n \n-        for &impl_def_id in &*impl_def_ids.borrow() {\n+        // FIXME(arielb1): can we use for_each_relevant_impl here?\n+        trait_def.for_each_impl(self.tcx(), |impl_def_id| {\n             debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={} impl_def_id={}\",\n                    trait_def_id.repr(self.tcx()),\n                    impl_def_id.repr(self.tcx()));\n \n             if !self.impl_can_possibly_match(impl_def_id) {\n-                continue;\n+                return;\n             }\n \n             let (_, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n@@ -667,7 +660,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 item: item.clone(),\n                 kind: ExtensionImplCandidate(impl_def_id, impl_trait_ref, impl_substs, item_index)\n             });\n-        }\n+        });\n     }\n \n     fn impl_can_possibly_match(&self, impl_def_id: ast::DefId) -> bool {"}, {"sha": "ad1042c068abc64ed8eacdd128942478e0b99d0a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -112,7 +112,6 @@ use util::lev_distance::lev_distance;\n \n use std::cell::{Cell, Ref, RefCell};\n use std::mem::replace;\n-use std::rc::Rc;\n use std::iter::repeat;\n use std::slice;\n use syntax::{self, abi, attr};\n@@ -747,7 +746,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n-                                               &*impl_trait_ref,\n+                                               &impl_trait_ref,\n                                                impl_items);\n               }\n               None => { }\n@@ -1174,7 +1173,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n \n     fn get_trait_def(&self, _: Span, id: ast::DefId)\n-                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>\n+                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n     {\n         Ok(ty::lookup_trait_def(self.tcx(), id))\n     }\n@@ -1244,7 +1243,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n \n     fn projected_ty(&self,\n                     span: Span,\n-                    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    trait_ref: ty::TraitRef<'tcx>,\n                     item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n@@ -1457,7 +1456,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn normalize_associated_type(&self,\n                                  span: Span,\n-                                 trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                                 trait_ref: ty::TraitRef<'tcx>,\n                                  item_name: ast::Name)\n                                  -> Ty<'tcx>\n     {"}, {"sha": "c2209ba2dc64754a16c2d0fa4846b9a94819627d", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -252,7 +252,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // trait reference. Instead, this is done at the impl site.\n             // Arguably this is wrong and we should treat the trait-reference\n             // the same way as we treat the self-type.\n-            bounds_checker.check_trait_ref(&*trait_ref);\n+            bounds_checker.check_trait_ref(&trait_ref);\n \n             let cause =\n                 traits::ObligationCause::new("}, {"sha": "05b74a5cc226bd7393d1830518c03358f12535d2", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             enforce_trait_manually_implementable(self.crate_context.tcx,\n                                                  item.span,\n                                                  trait_ref.def_id);\n-            self.add_trait_impl(trait_ref.def_id, impl_did);\n+            self.add_trait_impl(trait_ref, impl_did);\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -259,12 +259,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             Rc::new(RefCell::new(vec!(impl_def_id))));\n     }\n \n-    fn add_trait_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        debug!(\"add_trait_impl: base_def_id={:?} impl_def_id={:?}\",\n-               base_def_id, impl_def_id);\n-        ty::record_trait_implementation(self.crate_context.tcx,\n-                                        base_def_id,\n-                                        impl_def_id);\n+    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n+        debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n+               impl_trait_ref, impl_def_id);\n+        let trait_def = ty::lookup_trait_def(self.crate_context.tcx,\n+                                             impl_trait_ref.def_id);\n+        trait_def.record_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                                              item.id);\n \n                     self.instantiate_default_methods(local_def(item.id),\n-                                                     &*trait_ref,\n+                                                     &trait_ref,\n                                                      &mut items);\n                 }\n \n@@ -337,7 +337,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         // Record all the trait items.\n         if let Some(trait_ref) = associated_traits {\n-            self.add_trait_impl(trait_ref.def_id, impl_def_id);\n+            self.add_trait_impl(trait_ref, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n@@ -382,18 +382,16 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let drop_trait = match tcx.lang_items.drop_trait() {\n             Some(id) => id, None => { return }\n         };\n+        ty::populate_implementations_for_trait_if_necessary(tcx, drop_trait);\n+        let drop_trait = ty::lookup_trait_def(tcx, drop_trait);\n \n         let impl_items = tcx.impl_items.borrow();\n-        let trait_impls = match tcx.trait_impls.borrow().get(&drop_trait).cloned() {\n-            None => return, // No types with (new-style) dtors present.\n-            Some(found_impls) => found_impls\n-        };\n \n-        for &impl_did in &*trait_impls.borrow() {\n+        drop_trait.for_each_impl(tcx, |impl_did| {\n             let items = impl_items.get(&impl_did).unwrap();\n             if items.is_empty() {\n                 // We'll error out later. For now, just don't ICE.\n-                continue;\n+                return;\n             }\n             let method_def_id = items[0];\n \n@@ -430,7 +428,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-        }\n+        });\n     }\n \n     /// Ensures that implementations of the built-in trait `Copy` are legal.\n@@ -440,30 +438,17 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             Some(id) => id,\n             None => return,\n         };\n+        ty::populate_implementations_for_trait_if_necessary(tcx, copy_trait);\n+        let copy_trait = ty::lookup_trait_def(tcx, copy_trait);\n \n-        let trait_impls = match tcx.trait_impls\n-                                   .borrow()\n-                                   .get(&copy_trait)\n-                                   .cloned() {\n-            None => {\n-                debug!(\"check_implementations_of_copy(): no types with \\\n-                        implementations of `Copy` found\");\n-                return\n-            }\n-            Some(found_impls) => found_impls\n-        };\n-\n-        // Clone first to avoid a double borrow error.\n-        let trait_impls = trait_impls.borrow().clone();\n-\n-        for &impl_did in &trait_impls {\n+        copy_trait.for_each_impl(tcx, |impl_did| {\n             debug!(\"check_implementations_of_copy: impl_did={}\",\n                    impl_did.repr(tcx));\n \n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n                         crate\");\n-                continue\n+                return\n             }\n \n             let self_type = self.get_self_type_for_implementation(impl_did);\n@@ -506,7 +491,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                the type has a destructor\");\n                 }\n             }\n-        }\n+        });\n     }\n }\n "}, {"sha": "46cce54301168b0cc256a297e656e510e6b42a99", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 78, "deletions": 33, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -48,59 +48,104 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         // check_for_overlapping_impls_of_trait() check, since that\n         // check can populate this table further with impls from other\n         // crates.\n-        let trait_def_ids: Vec<(ast::DefId, Vec<ast::DefId>)> =\n-            self.tcx.trait_impls.borrow().iter().map(|(&k, v)| {\n-                // FIXME -- it seems like this method actually pushes\n-                // duplicate impls onto the list\n-                ty::populate_implementations_for_trait_if_necessary(self.tcx, k);\n-                (k, v.borrow().clone())\n-            }).collect();\n-\n-        for &(trait_def_id, ref impls) in &trait_def_ids {\n-            self.check_for_overlapping_impls_of_trait(trait_def_id, impls);\n+        let trait_defs : Vec<&ty::TraitDef> = {\n+            let d = self.tcx.trait_defs.borrow();\n+            d.values().map(|&v|v).collect()\n+        };\n+\n+        for trait_def in trait_defs {\n+            // FIXME -- it seems like this method actually pushes\n+            // duplicate impls onto the list\n+            ty::populate_implementations_for_trait_if_necessary(\n+                self.tcx,\n+                trait_def.trait_ref.def_id);\n+            self.check_for_overlapping_impls_of_trait(trait_def);\n         }\n     }\n \n     fn check_for_overlapping_impls_of_trait(&self,\n-                                            trait_def_id: ast::DefId,\n-                                            trait_impls: &Vec<ast::DefId>)\n+                                            trait_def: &'tcx ty::TraitDef<'tcx>)\n     {\n-        debug!(\"check_for_overlapping_impls_of_trait(trait_def_id={})\",\n-               trait_def_id.repr(self.tcx));\n+        debug!(\"check_for_overlapping_impls_of_trait(trait_def={})\",\n+               trait_def.repr(self.tcx));\n \n-        for (i, &impl1_def_id) in trait_impls.iter().enumerate() {\n-            if impl1_def_id.krate != ast::LOCAL_CRATE {\n-                // we don't need to check impls if both are external;\n-                // that's the other crate's job.\n-                continue;\n-            }\n+        // We should already know all impls of this trait, so these\n+        // borrows are safe.\n+        let blanket_impls = trait_def.blanket_impls.borrow();\n+        let nonblanket_impls = trait_def.nonblanket_impls.borrow();\n+        let trait_def_id = trait_def.trait_ref.def_id;\n \n-            for &impl2_def_id in &trait_impls[(i+1)..] {\n+        // Conflicts can only occur between a blanket impl and another impl,\n+        // or between 2 non-blanket impls of the same kind.\n+\n+        for (i, &impl1_def_id) in blanket_impls.iter().enumerate() {\n+            for &impl2_def_id in &blanket_impls[(i+1)..] {\n                 self.check_if_impls_overlap(trait_def_id,\n                                             impl1_def_id,\n                                             impl2_def_id);\n             }\n+\n+            for v in nonblanket_impls.values() {\n+                for &impl2_def_id in v {\n+                    self.check_if_impls_overlap(trait_def_id,\n+                                                impl1_def_id,\n+                                                impl2_def_id);\n+                }\n+            }\n+        }\n+\n+        for impl_group in nonblanket_impls.values() {\n+            for (i, &impl1_def_id) in impl_group.iter().enumerate() {\n+                for &impl2_def_id in &impl_group[(i+1)..] {\n+                    self.check_if_impls_overlap(trait_def_id,\n+                                                impl1_def_id,\n+                                                impl2_def_id);\n+                }\n+            }\n         }\n     }\n \n+    // We need to coherently pick which impl will be displayed\n+    // as causing the error message, and it must be the in the current\n+    // crate. Just pick the smaller impl in the file.\n+    fn order_impls(&self, impl1_def_id: ast::DefId, impl2_def_id: ast::DefId)\n+            -> Option<(ast::DefId, ast::DefId)> {\n+        if impl1_def_id.krate != ast::LOCAL_CRATE {\n+            if impl2_def_id.krate != ast::LOCAL_CRATE {\n+                // we don't need to check impls if both are external;\n+                // that's the other crate's job.\n+                None\n+            } else {\n+                Some((impl2_def_id, impl1_def_id))\n+            }\n+        } else if impl2_def_id.krate != ast::LOCAL_CRATE {\n+            Some((impl1_def_id, impl2_def_id))\n+        } else if impl1_def_id.node < impl2_def_id.node {\n+            Some((impl1_def_id, impl2_def_id))\n+        } else {\n+            Some((impl2_def_id, impl1_def_id))\n+        }\n+    }\n+\n+\n     fn check_if_impls_overlap(&self,\n                               trait_def_id: ast::DefId,\n                               impl1_def_id: ast::DefId,\n                               impl2_def_id: ast::DefId)\n     {\n-        assert_eq!(impl1_def_id.krate, ast::LOCAL_CRATE);\n-\n-        debug!(\"check_if_impls_overlap({}, {}, {})\",\n-               trait_def_id.repr(self.tcx),\n-               impl1_def_id.repr(self.tcx),\n-               impl2_def_id.repr(self.tcx));\n-\n-        let infcx = infer::new_infer_ctxt(self.tcx);\n-        if !traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n-            return;\n+        if let Some((impl1_def_id, impl2_def_id)) = self.order_impls(\n+            impl1_def_id, impl2_def_id)\n+        {\n+            debug!(\"check_if_impls_overlap({}, {}, {})\",\n+                   trait_def_id.repr(self.tcx),\n+                   impl1_def_id.repr(self.tcx),\n+                   impl2_def_id.repr(self.tcx));\n+\n+            let infcx = infer::new_infer_ctxt(self.tcx);\n+            if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n+                self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n+            }\n         }\n-\n-        self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n     }\n \n     fn report_overlap_error(&self, trait_def_id: ast::DefId,"}, {"sha": "6f78e853ebe84ecd592c091e8624d40a86ee9cf4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -83,7 +83,7 @@ use util::ppaux;\n use util::ppaux::{Repr,UserString};\n use write_ty_to_tcx;\n \n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n use std::rc::Rc;\n \n@@ -309,7 +309,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n     /// Loads the trait def for a given trait, returning ErrorReported if a cycle arises.\n     fn get_trait_def(&self, trait_id: ast::DefId)\n-                     -> Rc<ty::TraitDef<'tcx>>\n+                     -> &'tcx ty::TraitDef<'tcx>\n     {\n         let tcx = self.tcx;\n \n@@ -361,7 +361,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n \n     fn get_trait_def(&self, span: Span, id: ast::DefId)\n-                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>\n+                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetTraitDef(id), || {\n             Ok(self.ccx.get_trait_def(id))\n@@ -415,7 +415,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n \n     fn projected_ty(&self,\n                     _span: Span,\n-                    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    trait_ref: ty::TraitRef<'tcx>,\n                     item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n@@ -1210,7 +1210,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n \n fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                it: &ast::Item)\n-                               -> Rc<ty::TraitDef<'tcx>>\n+                               -> &'tcx ty::TraitDef<'tcx>\n {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n@@ -1246,22 +1246,23 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }).collect();\n \n-    let trait_ref = Rc::new(ty::TraitRef {\n+    let trait_ref = ty::TraitRef {\n         def_id: def_id,\n         substs: substs,\n-    });\n+    };\n \n-    let trait_def = Rc::new(ty::TraitDef {\n+    let trait_def = ty::TraitDef {\n         paren_sugar: paren_sugar,\n         unsafety: unsafety,\n         generics: ty_generics,\n         trait_ref: trait_ref,\n         associated_type_names: associated_type_names,\n-    });\n-\n-    tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n+        nonblanket_impls: RefCell::new(FnvHashMap()),\n+        blanket_impls: RefCell::new(vec![]),\n+        flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n+    };\n \n-    return trait_def;\n+    return tcx.intern_trait_def(trait_def);\n \n     fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  generics: &ast::Generics)\n@@ -1357,7 +1358,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n     let assoc_predicates = predicates_for_associated_types(ccx,\n                                                            generics,\n                                                            &trait_predicates,\n-                                                           &trait_def.trait_ref,\n+                                                           trait_def.trait_ref,\n                                                            items);\n     trait_predicates.predicates.extend(TypeSpace, assoc_predicates.into_iter());\n \n@@ -1369,7 +1370,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n     fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  ast_generics: &ast::Generics,\n                                                  trait_predicates: &ty::GenericPredicates<'tcx>,\n-                                                 self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+                                                 self_trait_ref: ty::TraitRef<'tcx>,\n                                                  trait_items: &[P<ast::TraitItem>])\n                                                  -> Vec<ty::Predicate<'tcx>>\n     {\n@@ -1382,7 +1383,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n             };\n \n             let assoc_ty = ty::mk_projection(ccx.tcx,\n-                                             self_trait_ref.clone(),\n+                                             self_trait_ref,\n                                              trait_item.ident.name);\n \n             let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),"}, {"sha": "3c8aab8447a2f14e9d670360e4ae82809db3824f", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -12,7 +12,6 @@ use middle::subst;\n use middle::ty::{self, Ty};\n \n use std::collections::HashSet;\n-use std::rc::Rc;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Parameter {\n@@ -26,7 +25,7 @@ pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n       .collect()\n }\n \n-pub fn parameters_for_trait_ref<'tcx>(trait_ref: &Rc<ty::TraitRef<'tcx>>) -> Vec<Parameter> {\n+pub fn parameters_for_trait_ref<'tcx>(trait_ref: &ty::TraitRef<'tcx>) -> Vec<Parameter> {\n     let mut region_parameters =\n         parameters_for_regions_in_substs(&trait_ref.substs);\n \n@@ -71,7 +70,7 @@ fn parameters_for_region(region: &ty::Region) -> Option<Parameter> {\n \n pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,\n                                               predicates: &[ty::Predicate<'tcx>],\n-                                              impl_trait_ref: Option<Rc<ty::TraitRef<'tcx>>>,\n+                                              impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                               input_parameters: &mut HashSet<Parameter>)\n {\n     loop {"}, {"sha": "9e8c23734e3c8c0d6854f52d8acb1a3895973113", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecf3d8b659c1f5bc457a5a146357ba484e27346/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=aecf3d8b659c1f5bc457a5a146357ba484e27346", "patch": "@@ -654,7 +654,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             ast::ItemTrait(..) => {\n                 let trait_def = ty::lookup_trait_def(tcx, did);\n                 self.add_constraints_from_trait_ref(&trait_def.generics,\n-                                                    &trait_def.trait_ref,\n+                                                    trait_def.trait_ref,\n                                                     self.invariant);\n             }\n \n@@ -844,7 +844,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n     fn add_constraints_from_trait_ref(&mut self,\n                                       generics: &ty::Generics<'tcx>,\n-                                      trait_ref: &ty::TraitRef<'tcx>,\n+                                      trait_ref: ty::TraitRef<'tcx>,\n                                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_trait_ref: trait_ref={} variance={:?}\",\n                trait_ref.repr(self.tcx()),\n@@ -946,7 +946,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_region(generics, data.bounds.region_bound, contra);\n \n                 // Ignore the SelfSpace, it is erased.\n-                self.add_constraints_from_trait_ref(generics, &*poly_trait_ref.0, variance);\n+                self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n \n                 let projections = data.projection_bounds_with_self_ty(self.tcx(),\n                                                                       self.tcx().types.err);"}]}