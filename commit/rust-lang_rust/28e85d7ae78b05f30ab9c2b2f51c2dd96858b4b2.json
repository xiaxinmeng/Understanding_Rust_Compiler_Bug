{"sha": "28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZTg1ZDdhZTc4YjA1ZjMwYWI5YzJiMmY1MWMyZGQ5Njg1OGI0YjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-12T08:29:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-12T08:29:55Z"}, "message": "Auto merge of #64328 - Mark-Simulacrum:rustdoc-find-rustc, r=GuillaumeGomez\n\nrustdoc: change doctests locating rustc binary\n\nWe previously used the \"naive\" approach of replacing the `current_exe()`'s file name with rustc, but now load from the sysroot by default (`$sysroot/bin/rustc`). The functionality of locating the sysroot overlaps/is the same as the functionality used by codegen backend loading; this ensures that any failure cases we've introduced are not exceeding those, and that improvements to finding the sysroot for loading codegen backends likewise enhance rustdoc.\n\nThe second commit adds an unstable `--test-builder` flag to rustdoc, and is largely separate (I can split into separate PR, but it's a simple and related change). This is largely intended for \"advanced\" users at this point (I'm not sure if we'll ever stabilize it); it permits use of a different rustc binary for rustdoc compilation of doctests than the rustdoc binary used when loading. Note, that this may not be what you want as the parsers and such differ (and rustdoc uses its own libsyntax, etc.). However, I've been told that running doctests in miri may be assisted by this change, so I've implemented it; I'll file a tracking issue for it if there's interest in it (and we land this PR).", "tree": {"sha": "b7667d1f3b9add300041d38988949697b8cff2e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7667d1f3b9add300041d38988949697b8cff2e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "html_url": "https://github.com/rust-lang/rust/commit/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f71826e8f26fd4fa331574caa462960db8ed961a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f71826e8f26fd4fa331574caa462960db8ed961a", "html_url": "https://github.com/rust-lang/rust/commit/f71826e8f26fd4fa331574caa462960db8ed961a"}, {"sha": "093cbd60fc331e9aab63fc4cdd8b8c9a043eaa3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/093cbd60fc331e9aab63fc4cdd8b8c9a043eaa3e", "html_url": "https://github.com/rust-lang/rust/commit/093cbd60fc331e9aab63fc4cdd8b8c9a043eaa3e"}], "stats": {"total": 222, "additions": 143, "deletions": 79}, "files": [{"sha": "f2eaf470658b3e8ed1dc453755729965d43c27eb", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "patch": "@@ -2137,6 +2137,12 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"once_cell\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d6a04cb71e910d0034815600180f62a95bf6e67942d7ab52a166a68c7d7e9cd0\"\n+\n [[package]]\n name = \"open\"\n version = \"1.2.1\"\n@@ -3425,6 +3431,7 @@ name = \"rustc_interface\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n+ \"once_cell\",\n  \"rustc\",\n  \"rustc-rayon\",\n  \"rustc_ast_borrowck\","}, {"sha": "b7873fd1d35814b68811472fe5dea76e2faeca82", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "patch": "@@ -1167,6 +1167,8 @@ impl<'a> Builder<'a> {\n             cargo.arg(\"--frozen\");\n         }\n \n+        cargo.env(\"RUSTC_INSTALL_BINDIR\", &self.config.bindir);\n+\n         self.ci_env.force_coloring_in_ci(&mut cargo);\n \n         cargo"}, {"sha": "52b5cd888df9c20222db09aaf1b7a1920be57b90", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "patch": "@@ -137,7 +137,7 @@ pub struct Config {\n     pub sysconfdir: Option<PathBuf>,\n     pub datadir: Option<PathBuf>,\n     pub docdir: Option<PathBuf>,\n-    pub bindir: Option<PathBuf>,\n+    pub bindir: PathBuf,\n     pub libdir: Option<PathBuf>,\n     pub mandir: Option<PathBuf>,\n     pub codegen_tests: bool,\n@@ -400,6 +400,7 @@ impl Config {\n         config.incremental = flags.incremental;\n         config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n+        config.bindir = \"bin\".into(); // default\n         if let Some(value) = flags.deny_warnings {\n             config.deny_warnings = value;\n         }\n@@ -482,7 +483,7 @@ impl Config {\n             config.sysconfdir = install.sysconfdir.clone().map(PathBuf::from);\n             config.datadir = install.datadir.clone().map(PathBuf::from);\n             config.docdir = install.docdir.clone().map(PathBuf::from);\n-            config.bindir = install.bindir.clone().map(PathBuf::from);\n+            set(&mut config.bindir, install.bindir.clone().map(PathBuf::from));\n             config.libdir = install.libdir.clone().map(PathBuf::from);\n             config.mandir = install.mandir.clone().map(PathBuf::from);\n         }"}, {"sha": "384219c38fd0483f821754a19dc9029a5434173b", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "patch": "@@ -67,7 +67,6 @@ fn install_sh(\n     let sysconfdir_default = PathBuf::from(\"/etc\");\n     let datadir_default = PathBuf::from(\"share\");\n     let docdir_default = datadir_default.join(\"doc/rust\");\n-    let bindir_default = PathBuf::from(\"bin\");\n     let libdir_default = PathBuf::from(\"lib\");\n     let mandir_default = datadir_default.join(\"man\");\n     let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n@@ -76,7 +75,7 @@ fn install_sh(\n     let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n     let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);\n     let docdir = builder.config.docdir.as_ref().unwrap_or(&docdir_default);\n-    let bindir = builder.config.bindir.as_ref().unwrap_or(&bindir_default);\n+    let bindir = &builder.config.bindir;\n     let libdir = builder.config.libdir.as_ref().unwrap_or(&libdir_default);\n     let mandir = builder.config.mandir.as_ref().unwrap_or(&mandir_default);\n "}, {"sha": "f6293107a940eeee46d717d8a9c7d34eee375e20", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "patch": "@@ -34,3 +34,4 @@ rustc_plugin = { path = \"../librustc_plugin\", package = \"rustc_plugin_impl\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n tempfile = \"3.0.5\"\n+once_cell = \"1\""}, {"sha": "79a343e0fee0bfcc2ce20a53e36fc92f822b0ec0", "filename": "src/librustc_interface/build.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustc_interface%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustc_interface%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fbuild.rs?ref=28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    println!(\"cargo:rerun-if-env-changed=RUSTC_INSTALL_BINDIR\");\n+}"}, {"sha": "b81f814de0f4a81b8c301a259ca06a0c4e905234", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 110, "deletions": 74, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "patch": "@@ -289,20 +289,39 @@ pub fn get_codegen_backend(sess: &Session) -> Box<dyn CodegenBackend> {\n     backend\n }\n \n-pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n-    // For now we only allow this function to be called once as it'll dlopen a\n-    // few things, which seems to work best if we only do that once. In\n-    // general this assertion never trips due to the once guard in `get_codegen_backend`,\n-    // but there's a few manual calls to this function in this file we protect\n-    // against.\n-    static LOADED: AtomicBool = AtomicBool::new(false);\n-    assert!(!LOADED.fetch_or(true, Ordering::SeqCst),\n-            \"cannot load the default codegen backend twice\");\n+// This is used for rustdoc, but it uses similar machinery to codegen backend\n+// loading, so we leave the code here. It is potentially useful for other tools\n+// that want to invoke the rustc binary while linking to rustc as well.\n+pub fn rustc_path<'a>() -> Option<&'a Path> {\n+    static RUSTC_PATH: once_cell::sync::OnceCell<Option<PathBuf>> =\n+        once_cell::sync::OnceCell::new();\n \n+    const BIN_PATH: &str = env!(\"RUSTC_INSTALL_BINDIR\");\n+\n+    RUSTC_PATH.get_or_init(|| get_rustc_path_inner(BIN_PATH)).as_ref().map(|v| &**v)\n+}\n+\n+fn get_rustc_path_inner(bin_path: &str) -> Option<PathBuf> {\n+    sysroot_candidates().iter()\n+        .filter_map(|sysroot| {\n+            let candidate = sysroot.join(bin_path).join(if cfg!(target_os = \"windows\") {\n+                \"rustc.exe\"\n+            } else {\n+                \"rustc\"\n+            });\n+            if candidate.exists() {\n+                Some(candidate)\n+            } else {\n+                None\n+            }\n+        })\n+        .next()\n+}\n+\n+fn sysroot_candidates() -> Vec<PathBuf> {\n     let target = session::config::host_triple();\n     let mut sysroot_candidates = vec![filesearch::get_or_default_sysroot()];\n-    let path = current_dll_path()\n-        .and_then(|s| s.canonicalize().ok());\n+    let path = current_dll_path().and_then(|s| s.canonicalize().ok());\n     if let Some(dll) = path {\n         // use `parent` twice to chop off the file name and then also the\n         // directory containing the dll which should be either `lib` or `bin`.\n@@ -327,69 +346,7 @@ pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend\n         }\n     }\n \n-    let sysroot = sysroot_candidates.iter()\n-        .map(|sysroot| {\n-            let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n-            sysroot.join(libdir).with_file_name(\n-                option_env!(\"CFG_CODEGEN_BACKENDS_DIR\").unwrap_or(\"codegen-backends\"))\n-        })\n-        .filter(|f| {\n-            info!(\"codegen backend candidate: {}\", f.display());\n-            f.exists()\n-        })\n-        .next();\n-    let sysroot = sysroot.unwrap_or_else(|| {\n-        let candidates = sysroot_candidates.iter()\n-            .map(|p| p.display().to_string())\n-            .collect::<Vec<_>>()\n-            .join(\"\\n* \");\n-        let err = format!(\"failed to find a `codegen-backends` folder \\\n-                           in the sysroot candidates:\\n* {}\", candidates);\n-        early_error(ErrorOutputType::default(), &err);\n-    });\n-    info!(\"probing {} for a codegen backend\", sysroot.display());\n-\n-    let d = sysroot.read_dir().unwrap_or_else(|e| {\n-        let err = format!(\"failed to load default codegen backend, couldn't \\\n-                           read `{}`: {}\", sysroot.display(), e);\n-        early_error(ErrorOutputType::default(), &err);\n-    });\n-\n-    let mut file: Option<PathBuf> = None;\n-\n-    let expected_name = format!(\"rustc_codegen_llvm-{}\", backend_name);\n-    for entry in d.filter_map(|e| e.ok()) {\n-        let path = entry.path();\n-        let filename = match path.file_name().and_then(|s| s.to_str()) {\n-            Some(s) => s,\n-            None => continue,\n-        };\n-        if !(filename.starts_with(DLL_PREFIX) && filename.ends_with(DLL_SUFFIX)) {\n-            continue\n-        }\n-        let name = &filename[DLL_PREFIX.len() .. filename.len() - DLL_SUFFIX.len()];\n-        if name != expected_name {\n-            continue\n-        }\n-        if let Some(ref prev) = file {\n-            let err = format!(\"duplicate codegen backends found\\n\\\n-                               first:  {}\\n\\\n-                               second: {}\\n\\\n-            \", prev.display(), path.display());\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-        file = Some(path.clone());\n-    }\n-\n-    match file {\n-        Some(ref s) => return load_backend_from_dylib(s),\n-        None => {\n-            let err = format!(\"failed to load default codegen backend for `{}`, \\\n-                               no appropriate codegen dylib found in `{}`\",\n-                              backend_name, sysroot.display());\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-    }\n+    return sysroot_candidates;\n \n     #[cfg(unix)]\n     fn current_dll_path() -> Option<PathBuf> {\n@@ -459,6 +416,85 @@ pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend\n     }\n }\n \n+pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n+    // For now we only allow this function to be called once as it'll dlopen a\n+    // few things, which seems to work best if we only do that once. In\n+    // general this assertion never trips due to the once guard in `get_codegen_backend`,\n+    // but there's a few manual calls to this function in this file we protect\n+    // against.\n+    static LOADED: AtomicBool = AtomicBool::new(false);\n+    assert!(!LOADED.fetch_or(true, Ordering::SeqCst),\n+            \"cannot load the default codegen backend twice\");\n+\n+    let target = session::config::host_triple();\n+    let sysroot_candidates = sysroot_candidates();\n+\n+    let sysroot = sysroot_candidates.iter()\n+        .map(|sysroot| {\n+            let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n+            sysroot.join(libdir).with_file_name(\n+                option_env!(\"CFG_CODEGEN_BACKENDS_DIR\").unwrap_or(\"codegen-backends\"))\n+        })\n+        .filter(|f| {\n+            info!(\"codegen backend candidate: {}\", f.display());\n+            f.exists()\n+        })\n+        .next();\n+    let sysroot = sysroot.unwrap_or_else(|| {\n+        let candidates = sysroot_candidates.iter()\n+            .map(|p| p.display().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n* \");\n+        let err = format!(\"failed to find a `codegen-backends` folder \\\n+                           in the sysroot candidates:\\n* {}\", candidates);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n+    info!(\"probing {} for a codegen backend\", sysroot.display());\n+\n+    let d = sysroot.read_dir().unwrap_or_else(|e| {\n+        let err = format!(\"failed to load default codegen backend, couldn't \\\n+                           read `{}`: {}\", sysroot.display(), e);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n+\n+    let mut file: Option<PathBuf> = None;\n+\n+    let expected_name = format!(\"rustc_codegen_llvm-{}\", backend_name);\n+    for entry in d.filter_map(|e| e.ok()) {\n+        let path = entry.path();\n+        let filename = match path.file_name().and_then(|s| s.to_str()) {\n+            Some(s) => s,\n+            None => continue,\n+        };\n+        if !(filename.starts_with(DLL_PREFIX) && filename.ends_with(DLL_SUFFIX)) {\n+            continue\n+        }\n+        let name = &filename[DLL_PREFIX.len() .. filename.len() - DLL_SUFFIX.len()];\n+        if name != expected_name {\n+            continue\n+        }\n+        if let Some(ref prev) = file {\n+            let err = format!(\"duplicate codegen backends found\\n\\\n+                               first:  {}\\n\\\n+                               second: {}\\n\\\n+            \", prev.display(), path.display());\n+            early_error(ErrorOutputType::default(), &err);\n+        }\n+        file = Some(path.clone());\n+    }\n+\n+    match file {\n+        Some(ref s) => return load_backend_from_dylib(s),\n+        None => {\n+            let err = format!(\"failed to load default codegen backend for `{}`, \\\n+                               no appropriate codegen dylib found in `{}`\",\n+                              backend_name, sysroot.display());\n+            early_error(ErrorOutputType::default(), &err);\n+        }\n+    }\n+\n+}\n+\n pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguator {\n     use std::hash::Hasher;\n "}, {"sha": "19ea7814300418913c295bf09a1201e89a6c5b5c", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "patch": "@@ -86,6 +86,10 @@ pub struct Options {\n     /// contains \"foo\" as a substring\n     pub enable_per_target_ignores: bool,\n \n+    /// The path to a rustc-like binary to build tests with. If not set, we\n+    /// default to loading from $sysroot/bin/rustc.\n+    pub test_builder: Option<PathBuf>,\n+\n     // Options that affect the documentation process\n \n     /// The selected default set of passes to use.\n@@ -476,6 +480,7 @@ impl Options {\n         let generate_search_filter = !matches.opt_present(\"disable-per-crate-search\");\n         let persist_doctests = matches.opt_str(\"persist-doctests\").map(PathBuf::from);\n         let generate_redirect_pages = matches.opt_present(\"generate-redirect-pages\");\n+        let test_builder = matches.opt_str(\"test-builder\").map(PathBuf::from);\n         let codegen_options_strs = matches.opt_strs(\"C\");\n         let lib_strs = matches.opt_strs(\"L\");\n         let extern_strs = matches.opt_strs(\"extern\");\n@@ -515,6 +520,7 @@ impl Options {\n             runtool,\n             runtool_args,\n             enable_per_target_ignores,\n+            test_builder,\n             render_options: RenderOptions {\n                 output,\n                 external_html,"}, {"sha": "d77e790d4a481a460f67705e6a3db50dcbb2a503", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "patch": "@@ -373,6 +373,11 @@ fn opts() -> Vec<RustcOptGroup> {\n                        \"\",\n                        \"One (of possibly many) arguments to pass to the runtool\")\n         }),\n+        unstable(\"test-builder\", |o| {\n+            o.optflag(\"\",\n+                      \"test-builder\",\n+                      \"specified the rustc-like binary to use as the test builder\")\n+        }),\n     ]\n }\n "}, {"sha": "482c69c1ab5b522fd158122bbcffbfd137a3adeb", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=28e85d7ae78b05f30ab9c2b2f51c2dd96858b4b2", "patch": "@@ -248,7 +248,10 @@ fn run_test(\n     };\n     let output_file = outdir.path().join(\"rust_out\");\n \n-    let mut compiler = Command::new(std::env::current_exe().unwrap().with_file_name(\"rustc\"));\n+    let rustc_binary = options.test_builder.as_ref().map(|v| &**v).unwrap_or_else(|| {\n+        rustc_interface::util::rustc_path().expect(\"found rustc\")\n+    });\n+    let mut compiler = Command::new(&rustc_binary);\n     compiler.arg(\"--crate-type\").arg(\"bin\");\n     for cfg in &options.cfgs {\n         compiler.arg(\"--cfg\").arg(&cfg);"}]}