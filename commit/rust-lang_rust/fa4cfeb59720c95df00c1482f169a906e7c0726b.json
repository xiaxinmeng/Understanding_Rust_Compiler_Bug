{"sha": "fa4cfeb59720c95df00c1482f169a906e7c0726b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNGNmZWI1OTcyMGM5NWRmMDBjMTQ4MmYxNjlhOTA2ZTdjMDcyNmI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-09-15T23:30:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-15T23:30:32Z"}, "message": "Rollup merge of #75304 - Aaron1011:feature/diag-deref-move-out, r=estebank\n\nNote when a a move/borrow error is caused by a deref coercion\n\nFixes #73268\n\nWhen a deref coercion occurs, we may end up with a move error if the\nbase value has been partially moved out of. However, we do not indicate\nanywhere that a deref coercion is occuring, resulting in an error\nmessage with a confusing span.\n\nThis PR adds an explicit note to move errors when a deref coercion is\ninvolved. We mention the name of the type that the deref-coercion\nresolved to, as well as the `Deref::Target` associated type being used.", "tree": {"sha": "c145f720f963dee195f18d6717de94b22c8276f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c145f720f963dee195f18d6717de94b22c8276f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa4cfeb59720c95df00c1482f169a906e7c0726b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfYU6ZCRBK7hj4Ov3rIwAAdHIIAFdsyuvNU7eSmvi6FYvTg00R\nO1mlhLKF/lWi0lEWwqmuNI71PkbVuq9tvAPYftJoxERI6ynUF79CovRaUFHkoc6q\nC7p6na0zX8aaWxRItxPCggMz6ywVnncYhf08M+OjJZV56WMRoFP6pF5mB1OamBMK\nF9r0KnVXeK5o5iBVxB/EjEKcKwmbX6itqI9//aVwY7xrXXgcpC1WcWSebLBS/foW\nOjqTITeN7wWDTnB8IRW4IV5ewNjnp4CVnnmw3oivu/K6h8t3iFhgxW07/3KTbQlN\n9j19A1oQapjYU7aR239p4Ix76iNOsVFbQWJrazlmu+3AzceYKUsJN0hFa9NlZpo=\n=E4UX\n-----END PGP SIGNATURE-----\n", "payload": "tree c145f720f963dee195f18d6717de94b22c8276f7\nparent fb9bb2b5ca517d85e1041ea9f80d06f48054624c\nparent d18b4bb7a735add53cad717fd96ec5f4b89d752d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1600212632 +0200\ncommitter GitHub <noreply@github.com> 1600212632 +0200\n\nRollup merge of #75304 - Aaron1011:feature/diag-deref-move-out, r=estebank\n\nNote when a a move/borrow error is caused by a deref coercion\n\nFixes #73268\n\nWhen a deref coercion occurs, we may end up with a move error if the\nbase value has been partially moved out of. However, we do not indicate\nanywhere that a deref coercion is occuring, resulting in an error\nmessage with a confusing span.\n\nThis PR adds an explicit note to move errors when a deref coercion is\ninvolved. We mention the name of the type that the deref-coercion\nresolved to, as well as the `Deref::Target` associated type being used.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa4cfeb59720c95df00c1482f169a906e7c0726b", "html_url": "https://github.com/rust-lang/rust/commit/fa4cfeb59720c95df00c1482f169a906e7c0726b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa4cfeb59720c95df00c1482f169a906e7c0726b/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb9bb2b5ca517d85e1041ea9f80d06f48054624c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9bb2b5ca517d85e1041ea9f80d06f48054624c", "html_url": "https://github.com/rust-lang/rust/commit/fb9bb2b5ca517d85e1041ea9f80d06f48054624c"}, {"sha": "d18b4bb7a735add53cad717fd96ec5f4b89d752d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d18b4bb7a735add53cad717fd96ec5f4b89d752d", "html_url": "https://github.com/rust-lang/rust/commit/d18b4bb7a735add53cad717fd96ec5f4b89d752d"}], "stats": {"total": 304, "additions": 250, "deletions": 54}, "files": [{"sha": "46ef5ff7dd8c5c97e71278b3df39e44040ef2716", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -4,6 +4,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_macros::HashStable;\n+use rustc_span::Span;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum PointerCast {\n@@ -113,6 +114,9 @@ pub enum Adjust<'tcx> {\n pub struct OverloadedDeref<'tcx> {\n     pub region: ty::Region<'tcx>,\n     pub mutbl: hir::Mutability,\n+    /// The `Span` associated with the field access or method call\n+    /// that triggered this overloaded deref.\n+    pub span: Span,\n }\n \n impl<'tcx> OverloadedDeref<'tcx> {"}, {"sha": "6d9d23836fc69d920284317bde8689d07d6f887f", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -612,8 +612,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n     type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.region)\n-            .map(|region| ty::adjustment::OverloadedDeref { region, mutbl: self.mutbl })\n+        tcx.lift(&self.region).map(|region| ty::adjustment::OverloadedDeref {\n+            region,\n+            mutbl: self.mutbl,\n+            span: self.span,\n+        })\n     }\n }\n "}, {"sha": "11122b195c0c4bf2c7fe4173688afe12753fd3b5", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -66,7 +66,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let span = use_spans.args_or_use();\n \n         let move_site_vec = self.get_moved_indexes(location, mpi);\n-        debug!(\"report_use_of_moved_or_uninitialized: move_site_vec={:?}\", move_site_vec);\n+        debug!(\n+            \"report_use_of_moved_or_uninitialized: move_site_vec={:?} use_spans={:?}\",\n+            move_site_vec, use_spans\n+        );\n         let move_out_indices: Vec<_> =\n             move_site_vec.iter().map(|move_site| move_site.moi).collect();\n \n@@ -229,6 +232,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     );\n                                 }\n                             }\n+                            // Deref::deref takes &self, which cannot cause a move\n+                            FnSelfUseKind::DerefCoercion { .. } => unreachable!(),\n                         }\n                     } else {\n                         err.span_label(\n@@ -355,6 +360,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.note_type_does_not_implement_copy(&mut err, &note_msg, ty, span, partial_str);\n             }\n \n+            if let UseSpans::FnSelfUse {\n+                kind: FnSelfUseKind::DerefCoercion { deref_target, deref_target_ty },\n+                ..\n+            } = use_spans\n+            {\n+                err.note(&format!(\n+                    \"{} occurs due to deref coercion to `{}`\",\n+                    desired_action.as_noun(),\n+                    deref_target_ty\n+                ));\n+\n+                err.span_note(deref_target, \"deref defined here\");\n+            }\n+\n             if let Some((_, mut old_err)) =\n                 self.move_error_reported.insert(move_out_indices, (used_place, err))\n             {\n@@ -945,7 +964,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         name: &str,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrow_spans: UseSpans,\n+        borrow_spans: UseSpans<'tcx>,\n         explanation: BorrowExplanation,\n     ) -> DiagnosticBuilder<'cx> {\n         debug!(\n@@ -1146,7 +1165,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrow_spans: UseSpans,\n+        borrow_spans: UseSpans<'tcx>,\n         proper_span: Span,\n         explanation: BorrowExplanation,\n     ) -> DiagnosticBuilder<'cx> {\n@@ -1274,7 +1293,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn report_escaping_closure_capture(\n         &mut self,\n-        use_span: UseSpans,\n+        use_span: UseSpans<'tcx>,\n         var_span: Span,\n         fr_name: &RegionName,\n         category: ConstraintCategory,"}, {"sha": "eccb6168229c29f5949ef6f468ff03bd6cfb1175", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -501,7 +501,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn later_use_kind(\n         &self,\n         borrow: &BorrowData<'tcx>,\n-        use_spans: UseSpans,\n+        use_spans: UseSpans<'tcx>,\n         location: Location,\n     ) -> (LaterUseKind, Span) {\n         match use_spans {"}, {"sha": "4256f6e39d5e863234dcefda647b0994c5fc4bc2", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 57, "deletions": 16, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::{\n     PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n use rustc_span::{\n     hygiene::{DesugaringKind, ForLoopLoc},\n     symbol::sym,\n@@ -538,7 +538,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n /// The span(s) associated to a use of a place.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub(super) enum UseSpans {\n+pub(super) enum UseSpans<'tcx> {\n     /// The access is caused by capturing a variable for a closure.\n     ClosureUse {\n         /// This is true if the captured variable was from a generator.\n@@ -558,7 +558,7 @@ pub(super) enum UseSpans {\n         fn_call_span: Span,\n         /// The definition span of the method being called\n         fn_span: Span,\n-        kind: FnSelfUseKind,\n+        kind: FnSelfUseKind<'tcx>,\n     },\n     /// This access is caused by a `match` or `if let` pattern.\n     PatUse(Span),\n@@ -567,31 +567,44 @@ pub(super) enum UseSpans {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub(super) enum FnSelfUseKind {\n+pub(super) enum FnSelfUseKind<'tcx> {\n     /// A normal method call of the form `receiver.foo(a, b, c)`\n     Normal { self_arg: Ident, implicit_into_iter: bool },\n     /// A call to `FnOnce::call_once`, desugared from `my_closure(a, b, c)`\n     FnOnceCall,\n     /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n     Operator { self_arg: Ident },\n+    DerefCoercion {\n+        /// The `Span` of the `Target` associated type\n+        /// in the `Deref` impl we are using.\n+        deref_target: Span,\n+        /// The type `T::Deref` we are dereferencing to\n+        deref_target_ty: Ty<'tcx>,\n+    },\n }\n \n-impl UseSpans {\n+impl UseSpans<'_> {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n             UseSpans::ClosureUse { args_span: span, .. }\n             | UseSpans::PatUse(span)\n-            | UseSpans::FnSelfUse { var_span: span, .. }\n             | UseSpans::OtherUse(span) => span,\n+            UseSpans::FnSelfUse {\n+                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n+            } => fn_call_span,\n+            UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n \n     pub(super) fn var_or_use(self) -> Span {\n         match self {\n             UseSpans::ClosureUse { var_span: span, .. }\n             | UseSpans::PatUse(span)\n-            | UseSpans::FnSelfUse { var_span: span, .. }\n             | UseSpans::OtherUse(span) => span,\n+            UseSpans::FnSelfUse {\n+                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n+            } => fn_call_span,\n+            UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n \n@@ -754,7 +767,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         moved_place: PlaceRef<'tcx>, // Could also be an upvar.\n         location: Location,\n-    ) -> UseSpans {\n+    ) -> UseSpans<'tcx> {\n         use self::UseSpans::*;\n \n         let stmt = match self.body[location.block].statements.get(location.statement_index) {\n@@ -809,36 +822,64 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             kind: TerminatorKind::Call { fn_span, from_hir_call, .. }, ..\n         }) = &self.body[location.block].terminator\n         {\n-            let method_did = if let Some(method_did) =\n+            let (method_did, method_substs) = if let Some(info) =\n                 crate::util::find_self_call(self.infcx.tcx, &self.body, target_temp, location.block)\n             {\n-                method_did\n+                info\n             } else {\n                 return normal_ret;\n             };\n \n             let tcx = self.infcx.tcx;\n-\n             let parent = tcx.parent(method_did);\n             let is_fn_once = parent == tcx.lang_items().fn_once_trait();\n             let is_operator = !from_hir_call\n                 && parent.map_or(false, |p| tcx.lang_items().group(LangItemGroup::Op).contains(&p));\n+            let is_deref = !from_hir_call && tcx.is_diagnostic_item(sym::deref_method, method_did);\n             let fn_call_span = *fn_span;\n \n             let self_arg = tcx.fn_arg_names(method_did)[0];\n \n+            debug!(\n+                \"terminator = {:?} from_hir_call={:?}\",\n+                self.body[location.block].terminator, from_hir_call\n+            );\n+\n+            // Check for a 'special' use of 'self' -\n+            // an FnOnce call, an operator (e.g. `<<`), or a\n+            // deref coercion.\n             let kind = if is_fn_once {\n-                FnSelfUseKind::FnOnceCall\n+                Some(FnSelfUseKind::FnOnceCall)\n             } else if is_operator {\n-                FnSelfUseKind::Operator { self_arg }\n+                Some(FnSelfUseKind::Operator { self_arg })\n+            } else if is_deref {\n+                let deref_target =\n+                    tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {\n+                        Instance::resolve(tcx, self.param_env, deref_target, method_substs)\n+                            .transpose()\n+                    });\n+                if let Some(Ok(instance)) = deref_target {\n+                    let deref_target_ty = instance.ty(tcx, self.param_env);\n+                    Some(FnSelfUseKind::DerefCoercion {\n+                        deref_target: tcx.def_span(instance.def_id()),\n+                        deref_target_ty,\n+                    })\n+                } else {\n+                    None\n+                }\n             } else {\n+                None\n+            };\n+\n+            let kind = kind.unwrap_or_else(|| {\n+                // This isn't a 'special' use of `self`\n                 debug!(\"move_spans: method_did={:?}, fn_call_span={:?}\", method_did, fn_call_span);\n                 let implicit_into_iter = matches!(\n                     fn_call_span.desugaring_kind(),\n                     Some(DesugaringKind::ForLoop(ForLoopLoc::IntoIter))\n                 );\n                 FnSelfUseKind::Normal { self_arg, implicit_into_iter }\n-            };\n+            });\n \n             return FnSelfUse {\n                 var_span: stmt.source_info.span,\n@@ -859,7 +900,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// and its usage of the local assigned at `location`.\n     /// This is done by searching in statements succeeding `location`\n     /// and originating from `maybe_closure_span`.\n-    pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans {\n+    pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans<'tcx> {\n         use self::UseSpans::*;\n         debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n@@ -963,7 +1004,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Helper to retrieve span(s) of given borrow from the current MIR\n     /// representation\n-    pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData<'_>) -> UseSpans {\n+    pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData<'_>) -> UseSpans<'tcx> {\n         let span = self.body.source_info(borrow.reserve_location).span;\n         self.borrow_spans(span, borrow.reserve_location)\n     }"}, {"sha": "e256fb55b124b70a2d3eec66140982b394056a05", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -47,7 +47,7 @@ enum GroupedMoveError<'tcx> {\n     // Everything that isn't from pattern matching.\n     OtherIllegalMove {\n         original_path: Place<'tcx>,\n-        use_spans: UseSpans,\n+        use_spans: UseSpans<'tcx>,\n         kind: IllegalMoveOriginKind<'tcx>,\n     },\n }\n@@ -222,7 +222,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let (mut err, err_span) = {\n             let (span, use_spans, original_path, kind): (\n                 Span,\n-                Option<UseSpans>,\n+                Option<UseSpans<'tcx>>,\n                 Place<'tcx>,\n                 &IllegalMoveOriginKind<'_>,\n             ) = match error {\n@@ -291,7 +291,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         move_place: Place<'tcx>,\n         deref_target_place: Place<'tcx>,\n         span: Span,\n-        use_spans: Option<UseSpans>,\n+        use_spans: Option<UseSpans<'tcx>>,\n     ) -> DiagnosticBuilder<'a> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this"}, {"sha": "64ad0627720aa0286b26af7ab2a6bccfb4269ba4", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind\n use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, InstanceDef, RegionVid, TyCtxt};\n+use rustc_middle::ty::{self, InstanceDef, ParamEnv, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT, UNUSED_MUT};\n use rustc_span::{Span, Symbol, DUMMY_SP};\n \n@@ -287,6 +287,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         if let Err((move_data, move_errors)) = move_data_results {\n             let mut promoted_mbcx = MirBorrowckCtxt {\n                 infcx,\n+                param_env,\n                 body: promoted_body,\n                 mir_def_id: def.did,\n                 move_data: &move_data,\n@@ -320,6 +321,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n+        param_env,\n         body,\n         mir_def_id: def.did,\n         move_data: &mdpe.move_data,\n@@ -473,6 +475,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     body: &'cx Body<'tcx>,\n     mir_def_id: LocalDefId,\n     move_data: &'cx MoveData<'tcx>,"}, {"sha": "70c1aed0957f8554279a33ca93924c8c1f7c800f", "filename": "compiler/rustc_mir/src/transform/check_const_item_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ConstMutationChecker<'a, 'tcx> {\n                         .note(\"each usage of a `const` item creates a new temporary\")\n                         .note(\"the mutable reference will refer to this temporary, not the original `const` item\");\n \n-                    if let Some(method_did) = method_did {\n+                    if let Some((method_did, _substs)) = method_did {\n                         lint.span_note(self.tcx.def_span(method_did), \"mutable reference created due to call to this method\");\n                     }\n "}, {"sha": "5b146eeb87c044956846f6f5c4a33e7e9ad1a5cc", "filename": "compiler/rustc_mir/src/util/find_self_call.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,30 +1,31 @@\n use rustc_middle::mir::*;\n+use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::def_id::DefId;\n \n /// Checks if the specified `local` is used as the `self` prameter of a method call\n /// in the provided `BasicBlock`. If it is, then the `DefId` of the called method is\n /// returned.\n-pub fn find_self_call(\n-    tcx: TyCtxt<'_>,\n-    body: &Body<'_>,\n+pub fn find_self_call<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n     local: Local,\n     block: BasicBlock,\n-) -> Option<DefId> {\n+) -> Option<(DefId, SubstsRef<'tcx>)> {\n     debug!(\"find_self_call(local={:?}): terminator={:?}\", local, &body[block].terminator);\n     if let Some(Terminator { kind: TerminatorKind::Call { func, args, .. }, .. }) =\n         &body[block].terminator\n     {\n         debug!(\"find_self_call: func={:?}\", func);\n         if let Operand::Constant(box Constant { literal: ty::Const { ty, .. }, .. }) = func {\n-            if let ty::FnDef(def_id, _) = *ty.kind() {\n+            if let ty::FnDef(def_id, substs) = *ty.kind() {\n                 if let Some(ty::AssocItem { fn_has_self_parameter: true, .. }) =\n                     tcx.opt_associated_item(def_id)\n                 {\n                     debug!(\"find_self_call: args={:?}\", args);\n                     if let [Operand::Move(self_place) | Operand::Copy(self_place), ..] = **args {\n                         if self_place.as_local() == Some(local) {\n-                            return Some(def_id);\n+                            return Some((def_id, substs));\n                         }\n                     }\n                 }"}, {"sha": "13e69474cfb965b706f45ff1d4ce092803a8b2f1", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -117,7 +117,14 @@ fn apply_adjustment<'a, 'tcx>(\n                 },\n             };\n \n-            overloaded_place(cx, hir_expr, adjustment.target, Some(call), vec![expr.to_ref()])\n+            overloaded_place(\n+                cx,\n+                hir_expr,\n+                adjustment.target,\n+                Some(call),\n+                vec![expr.to_ref()],\n+                deref.span,\n+            )\n         }\n         Adjust::Borrow(AutoBorrow::Ref(_, m)) => {\n             ExprKind::Borrow { borrow_kind: m.to_borrow_kind(), arg: expr.to_ref() }\n@@ -277,15 +284,22 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n         hir::ExprKind::Index(ref lhs, ref index) => {\n             if cx.typeck_results().is_method_call(expr) {\n-                overloaded_place(cx, expr, expr_ty, None, vec![lhs.to_ref(), index.to_ref()])\n+                overloaded_place(\n+                    cx,\n+                    expr,\n+                    expr_ty,\n+                    None,\n+                    vec![lhs.to_ref(), index.to_ref()],\n+                    expr.span,\n+                )\n             } else {\n                 ExprKind::Index { lhs: lhs.to_ref(), index: index.to_ref() }\n             }\n         }\n \n         hir::ExprKind::Unary(hir::UnOp::UnDeref, ref arg) => {\n             if cx.typeck_results().is_method_call(expr) {\n-                overloaded_place(cx, expr, expr_ty, None, vec![arg.to_ref()])\n+                overloaded_place(cx, expr, expr_ty, None, vec![arg.to_ref()], expr.span)\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n@@ -1025,6 +1039,7 @@ fn overloaded_place<'a, 'tcx>(\n     place_ty: Ty<'tcx>,\n     overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n     args: Vec<ExprRef<'tcx>>,\n+    span: Span,\n ) -> ExprKind<'tcx> {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n@@ -1040,24 +1055,24 @@ fn overloaded_place<'a, 'tcx>(\n     // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n     let (region, mutbl) = match *recv_ty.kind() {\n         ty::Ref(region, _, mutbl) => (region, mutbl),\n-        _ => span_bug!(expr.span, \"overloaded_place: receiver is not a reference\"),\n+        _ => span_bug!(span, \"overloaded_place: receiver is not a reference\"),\n     };\n     let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut { ty: place_ty, mutbl });\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-    let fun = method_callee(cx, expr, expr.span, overloaded_callee);\n+    let fun = method_callee(cx, expr, span, overloaded_callee);\n     let ref_expr = Expr {\n         temp_lifetime,\n         ty: ref_ty,\n-        span: expr.span,\n+        span,\n         kind: ExprKind::Call {\n             ty: fun.ty,\n             fun: fun.to_ref(),\n             args,\n             from_hir_call: false,\n-            fn_span: expr.span,\n+            fn_span: span,\n         },\n     };\n "}, {"sha": "94f795b11ea4d3047b72efdb3d93c8eec1c8a46f", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -416,7 +416,9 @@ symbols! {\n         deny,\n         deprecated,\n         deref,\n+        deref_method,\n         deref_mut,\n+        deref_target,\n         derive,\n         diagnostic,\n         direct,"}, {"sha": "b9c5123e49a0ea3b35f3aa7c18e260647cce8f96", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -27,6 +27,7 @@ pub struct Autoderef<'a, 'tcx> {\n     // Meta infos:\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     span: Span,\n+    overloaded_span: Span,\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n \n@@ -98,10 +99,12 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         body_id: hir::HirId,\n         span: Span,\n         base_ty: Ty<'tcx>,\n+        overloaded_span: Span,\n     ) -> Autoderef<'a, 'tcx> {\n         Autoderef {\n             infcx,\n             span,\n+            overloaded_span,\n             body_id,\n             param_env,\n             state: AutoderefSnapshot {\n@@ -190,6 +193,10 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         self.span\n     }\n \n+    pub fn overloaded_span(&self) -> Span {\n+        self.overloaded_span\n+    }\n+\n     pub fn reached_recursion_limit(&self) -> bool {\n         self.state.reached_recursion_limit\n     }"}, {"sha": "90a8d9634ae1e183907226e7831c6bf12ec9a3ba", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -483,7 +483,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         if let ty::Ref(region, base_ty, mutbl) = *real_ty.kind() {\n-            let mut autoderef = Autoderef::new(self, param_env, body_id, span, base_ty);\n+            let mut autoderef = Autoderef::new(self, param_env, body_id, span, base_ty, span);\n             if let Some(steps) = autoderef.find_map(|(ty, steps)| {\n                 // Re-add the `&`\n                 let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });"}, {"sha": "59c366ad7d776cb41868bc18140e042f70ccab60", "filename": "compiler/rustc_typeck/src/check/autoderef.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fautoderef.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -12,7 +12,18 @@ use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'tcx> {\n-        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n+        Autoderef::new(self, self.param_env, self.body_id, span, base_ty, span)\n+    }\n+\n+    /// Like `autoderef`, but provides a custom `Span` to use for calls to\n+    /// an overloaded `Deref` operator\n+    pub fn autoderef_overloaded_span(\n+        &'a self,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+        overloaded_span: Span,\n+    ) -> Autoderef<'a, 'tcx> {\n+        Autoderef::new(self, self.param_env, self.body_id, span, base_ty, overloaded_span)\n     }\n \n     pub fn try_overloaded_deref(\n@@ -44,7 +55,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n                             if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n-                                Some(OverloadedDeref { region, mutbl })\n+                                Some(OverloadedDeref {\n+                                    region,\n+                                    mutbl,\n+                                    span: autoderef.overloaded_span(),\n+                                })\n                             } else {\n                                 None\n                             }"}, {"sha": "fd2700b85e2790a7721e523f4e0a272880babb21", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -137,7 +137,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         // Commit the autoderefs by calling `autoderef` again, but this\n         // time writing the results into the various typeck results.\n-        let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n+        let mut autoderef =\n+            self.autoderef_overloaded_span(self.span, unadjusted_self_ty, self.call_expr.span);\n         let (_, n) = match autoderef.nth(pick.autoderefs) {\n             Some(n) => n,\n             None => {"}, {"sha": "8a62031ec887caed2885f04f843ec053dfcc8701", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -446,9 +446,10 @@ fn method_autoderef_steps<'tcx>(\n     tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {\n         let ParamEnvAnd { param_env, value: self_ty } = goal;\n \n-        let mut autoderef = Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty)\n-            .include_raw_pointers()\n-            .silence_errors();\n+        let mut autoderef =\n+            Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty, DUMMY_SP)\n+                .include_raw_pointers()\n+                .silence_errors();\n         let mut reached_raw_pointer = false;\n         let mut steps: Vec<_> = autoderef\n             .by_ref()"}, {"sha": "502cb562385e0de9432f10d4ab88b95ff4e51955", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -242,7 +242,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ) {\n                             let method = self.register_infer_ok_obligations(ok);\n                             if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n-                                *deref = OverloadedDeref { region, mutbl };\n+                                *deref = OverloadedDeref { region, mutbl, span: deref.span };\n                             }\n                             // If this is a union field, also throw an error for `DerefMut` of `ManuallyDrop` (see RFC 2514).\n                             // This helps avoid accidental drops."}, {"sha": "245152e5490d8c5e87c35f1479463985d428cce4", "filename": "library/core/src/ops/deref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fderef.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -63,11 +63,13 @@\n pub trait Deref {\n     /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_diagnostic_item = \"deref_target\"]\n     type Target: ?Sized;\n \n     /// Dereferences the value.\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_diagnostic_item = \"deref_method\"]\n     fn deref(&self) -> &Self::Target;\n }\n "}, {"sha": "fb884e3129999c3246f085522ebc6e553705c25a", "filename": "src/test/ui/lint/lint-unconditional-recursion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.stderr?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -149,7 +149,7 @@ error: function cannot return without recursing\n LL |     fn deref(&self) -> &Baz {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n LL |         self.as_ref()\n-   |         ---- recursive call site\n+   |         ------------- recursive call site\n    |\n    = help: a `loop` may express intention better if this is on purpose\n "}, {"sha": "41154388f56a835b8b8fa767a916c6907f6510ab", "filename": "src/test/ui/moves/move-deref-coercion.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -0,0 +1,33 @@\n+use std::ops::Deref;\n+\n+struct NotCopy {\n+    inner: bool\n+}\n+\n+impl NotCopy {\n+    fn inner_method(&self) {}\n+}\n+\n+struct Foo {\n+    first: NotCopy,\n+    second: NotCopy\n+}\n+\n+impl Deref for Foo {\n+    type Target = NotCopy;\n+    fn deref(&self) -> &NotCopy {\n+        &self.second\n+    }\n+}\n+\n+fn use_field(val: Foo) {\n+    let _val = val.first;\n+    val.inner; //~ ERROR borrow of\n+}\n+\n+fn use_method(val: Foo) {\n+    let _val = val.first;\n+    val.inner_method(); //~ ERROR borrow of\n+}\n+\n+fn main() {}"}, {"sha": "e3bdf6d78320734e4cf7e06e0081061037ceb017", "filename": "src/test/ui/moves/move-deref-coercion.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.stderr?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -0,0 +1,35 @@\n+error[E0382]: borrow of partially moved value: `val`\n+  --> $DIR/move-deref-coercion.rs:25:5\n+   |\n+LL |     let _val = val.first;\n+   |                --------- value partially moved here\n+LL |     val.inner;\n+   |     ^^^^^^^^^ value borrowed here after partial move\n+   |\n+   = note: partial move occurs because `val.first` has type `NotCopy`, which does not implement the `Copy` trait\n+   = note: borrow occurs due to deref coercion to `NotCopy`\n+note: deref defined here\n+  --> $DIR/move-deref-coercion.rs:17:5\n+   |\n+LL |     type Target = NotCopy;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0382]: borrow of partially moved value: `val`\n+  --> $DIR/move-deref-coercion.rs:30:5\n+   |\n+LL |     let _val = val.first;\n+   |                --------- value partially moved here\n+LL |     val.inner_method();\n+   |     ^^^^^^^^^^^^^^^^^^ value borrowed here after partial move\n+   |\n+   = note: partial move occurs because `val.first` has type `NotCopy`, which does not implement the `Copy` trait\n+   = note: borrow occurs due to deref coercion to `NotCopy`\n+note: deref defined here\n+  --> $DIR/move-deref-coercion.rs:17:5\n+   |\n+LL |     type Target = NotCopy;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "37032e73f1900c2a21bdfc55821ea77ed476fb52", "filename": "src/test/ui/no-capture-arc.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/src%2Ftest%2Fui%2Fno-capture-arc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/src%2Ftest%2Fui%2Fno-capture-arc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-capture-arc.stderr?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: borrow of moved value: `arc_v`\n-  --> $DIR/no-capture-arc.rs:14:18\n+  --> $DIR/no-capture-arc.rs:14:16\n    |\n LL |     let arc_v = Arc::new(v);\n    |         ----- move occurs because `arc_v` has type `Arc<Vec<i32>>`, which does not implement the `Copy` trait\n@@ -10,7 +10,14 @@ LL |         assert_eq!((*arc_v)[3], 4);\n    |                      ----- variable moved due to use in closure\n ...\n LL |     assert_eq!((*arc_v)[2], 3);\n-   |                  ^^^^^ value borrowed here after move\n+   |                ^^^^^^^^ value borrowed here after move\n+   |\n+   = note: borrow occurs due to deref coercion to `Vec<i32>`\n+note: deref defined here\n+  --> $SRC_DIR/alloc/src/sync.rs:LL:COL\n+   |\n+LL |     type Target = T;\n+   |     ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "6f37d4c9d869125a8ea59a314edebf5f1577efae", "filename": "src/test/ui/no-reuse-move-arc.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/src%2Ftest%2Fui%2Fno-reuse-move-arc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/src%2Ftest%2Fui%2Fno-reuse-move-arc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-reuse-move-arc.stderr?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: borrow of moved value: `arc_v`\n-  --> $DIR/no-reuse-move-arc.rs:12:18\n+  --> $DIR/no-reuse-move-arc.rs:12:16\n    |\n LL |     let arc_v = Arc::new(v);\n    |         ----- move occurs because `arc_v` has type `Arc<Vec<i32>>`, which does not implement the `Copy` trait\n@@ -10,7 +10,14 @@ LL |         assert_eq!((*arc_v)[3], 4);\n    |                      ----- variable moved due to use in closure\n ...\n LL |     assert_eq!((*arc_v)[2], 3);\n-   |                  ^^^^^ value borrowed here after move\n+   |                ^^^^^^^^ value borrowed here after move\n+   |\n+   = note: borrow occurs due to deref coercion to `Vec<i32>`\n+note: deref defined here\n+  --> $SRC_DIR/alloc/src/sync.rs:LL:COL\n+   |\n+LL |     type Target = T;\n+   |     ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}]}