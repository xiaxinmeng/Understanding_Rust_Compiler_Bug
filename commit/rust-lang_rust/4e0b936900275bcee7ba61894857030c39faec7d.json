{"sha": "4e0b936900275bcee7ba61894857030c39faec7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMGI5MzY5MDAyNzViY2VlN2JhNjE4OTQ4NTcwMzBjMzlmYWVjN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-01T06:16:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-01T06:16:42Z"}, "message": "auto merge of #14513 : alexcrichton/rust/rustdoc-primitives, r=huonw\n\nThis is currently rebased on top of #14478, but that's just to preemptively avoid rebase conflicts and to provide a better preview. This can land independently of that PR.\r\n\r\nThis change crates a dedicated page in rustdoc for primitive types to outline everything you can do with them (at least in a basic way).\r\n\r\n* Preview - http://people.mozilla.org/~acrichton/doc/\r\n* Exhibit A - http://people.mozilla.org/~acrichton/doc/std/#primitives\r\n* Exhibit B - http://people.mozilla.org/~acrichton/doc/std/primitive.str.html\r\n* Exhibit C - http://people.mozilla.org/~acrichton/doc/std/primitive.slice.html\r\n\r\nPlease don't hesitate to be nitpickity, it's easy to overlook a thing here or there!", "tree": {"sha": "c4e94d6937cc90c8a07a81d05427aa9722a16934", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4e94d6937cc90c8a07a81d05427aa9722a16934"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e0b936900275bcee7ba61894857030c39faec7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e0b936900275bcee7ba61894857030c39faec7d", "html_url": "https://github.com/rust-lang/rust/commit/4e0b936900275bcee7ba61894857030c39faec7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e0b936900275bcee7ba61894857030c39faec7d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5527c5dc060754d7ca17c19886bc357ef29ec8fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5527c5dc060754d7ca17c19886bc357ef29ec8fc", "html_url": "https://github.com/rust-lang/rust/commit/5527c5dc060754d7ca17c19886bc357ef29ec8fc"}, {"sha": "d58f27a82f34bfbfec1fc2dfdfcbed26e4f09f58", "url": "https://api.github.com/repos/rust-lang/rust/commits/d58f27a82f34bfbfec1fc2dfdfcbed26e4f09f58", "html_url": "https://github.com/rust-lang/rust/commit/d58f27a82f34bfbfec1fc2dfdfcbed26e4f09f58"}], "stats": {"total": 1249, "additions": 865, "deletions": 384}, "files": [{"sha": "e2dae8c8b52a2ead59b1c8f1051c6ce62ca90d0e", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -4,7 +4,7 @@\n \n **Int to string**\n \n-Use [`ToStr`](../std/to_str/trait.ToStr.html).\n+Use [`ToStr`](std/to_str/trait.ToStr.html).\n \n ~~~\n let x: int = 42;\n@@ -13,8 +13,8 @@ let y: String = x.to_str().to_string();\n \n **String to int**\n \n-Use [`FromStr`](../std/from_str/trait.FromStr.html), and its helper function,\n-[`from_str`](../std/from_str/fn.from_str.html).\n+Use [`FromStr`](std/from_str/trait.FromStr.html), and its helper function,\n+[`from_str`](std/from_str/fn.from_str.html).\n \n ~~~\n let x: Option<int> = from_str(\"42\");\n@@ -35,8 +35,8 @@ let y: String = format!(\"{:X}\", x);   // uppercase hexadecimal\n \n **String to int, in non-base-10**\n \n-Use [`FromStrRadix`](../std/num/trait.FromStrRadix.html), and its helper\n-function, [`from_str_radix`](../std/num/fn.from_str_radix.html).\n+Use [`FromStrRadix`](std/num/trait.FromStrRadix.html), and its helper\n+function, [`from_str_radix`](std/num/fn.from_str_radix.html).\n \n ~~~\n use std::num;\n@@ -48,7 +48,7 @@ let y: i64 = x.unwrap();\n **Vector of Bytes to String**\n \n To return a Borrowed String Slice (&str) use the str helper function\n-[`from_utf8`](../std/str/fn.from_utf8.html).\n+[`from_utf8`](std/str/fn.from_utf8.html).\n \n ~~~\n use std::str;\n@@ -58,7 +58,7 @@ let x: &str = str::from_utf8(bytes).unwrap();\n ~~~\n \n To return an Owned String use the str helper function\n-[`from_utf8_owned`](../std/str/fn.from_utf8_owned.html).\n+[`from_utf8_owned`](std/str/fn.from_utf8_owned.html).\n \n ~~~\n use std::str;\n@@ -68,8 +68,8 @@ let x: Option<String> =\n let y: String = x.unwrap();\n ~~~\n \n-To return a [`MaybeOwned`](../std/str/enum.MaybeOwned.html) use the str helper\n-function [`from_utf8_lossy`](../std/str/fn.from_utf8_owned.html).\n+To return a [`MaybeOwned`](std/str/type.MaybeOwned.html) use the str helper\n+function [`from_utf8_lossy`](std/str/fn.from_utf8_owned.html).\n This function also replaces non-valid utf-8 sequences with U+FFFD replacement\n character.\n \n@@ -85,11 +85,11 @@ let y = str::from_utf8_lossy(x);\n ## How do I read from a file?\n \n Use\n-[`File::open`](../std/io/fs/struct.File.html#method.open)\n+[`File::open`](std/io/fs/struct.File.html#method.open)\n to create a\n-[`File`](../std/io/fs/struct.File.html)\n+[`File`](std/io/fs/struct.File.html)\n struct, which implements the\n-[`Reader`](../std/io/trait.Reader.html)\n+[`Reader`](std/io/trait.Reader.html)\n trait.\n \n ~~~ {.ignore}\n@@ -103,7 +103,8 @@ let reader : File = File::open(&path).unwrap_or_else(on_error);\n \n ## How do I iterate over the lines in a file?\n \n-Use the [`lines`](../std/io/trait.Buffer.html#method.lines) method on a [`BufferedReader`](../std/io/buffered/struct.BufferedReader.html).\n+Use the [`lines`](std/io/trait.Buffer.html#method.lines) method on a\n+[`BufferedReader`](std/io/struct.BufferedReader.html).\n \n ~~~\n use std::io::BufferedReader;\n@@ -121,7 +122,7 @@ for line in reader.lines() {\n \n ## How do I search for a substring?\n \n-Use the [`find_str`](../std/str/trait.StrSlice.html#tymethod.find_str) method.\n+Use the [`find_str`](std/str/trait.StrSlice.html#tymethod.find_str) method.\n \n ~~~\n let str = \"Hello, this is some random string\";\n@@ -132,7 +133,7 @@ let index: Option<uint> = str.find_str(\"rand\");\n \n ## How do I get the length of a vector?\n \n-The [`Container`](../std/container/trait.Container.html) trait provides the `len` method.\n+The [`Container`](std/container/trait.Container.html) trait provides the `len` method.\n \n ~~~\n let u: Vec<u32> = vec![0, 1, 2];\n@@ -144,7 +145,7 @@ println!(\"u: {}, v: {}, w: {}\", u.len(), v.len(), w.len()); // 3, 4, 5\n \n ## How do I iterate over a vector?\n \n-Use the [`iter`](../std/vec/trait.ImmutableVector.html#tymethod.iter) method.\n+Use the [`iter`](std/slice/trait.ImmutableVector.html#tymethod.iter) method.\n \n ~~~\n let values: Vec<int> = vec![1, 2, 3, 4, 5];\n@@ -153,9 +154,9 @@ for value in values.iter() {  // value: &int\n }\n ~~~\n \n-(See also [`mut_iter`](../std/vec/trait.MutableVector.html#tymethod.mut_iter)\n+(See also [`mut_iter`](std/slice/trait.MutableVector.html#tymethod.mut_iter)\n which yields `&mut int` and\n-[`move_iter`](../std/vec/trait.OwnedVector.html#tymethod.move_iter) which yields\n+[`move_iter`](std/slice/trait.OwnedVector.html#tymethod.move_iter) which yields\n `int` while consuming the `values` vector.)\n \n # Type system"}, {"sha": "c03c72ca35fd12e84fa5aec59cddd36774c6537b", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -21,7 +21,7 @@ Some examples that demonstrate different aspects of the language:\n * The extra library's [json] module. Enums and pattern matching\n \n [sprocketnes]: https://github.com/pcwalton/sprocketnes\n-[hash]: https://github.com/mozilla/rust/blob/master/src/libstd/hash.rs\n+[hash]: https://github.com/mozilla/rust/blob/master/src/libstd/hash/mod.rs\n [HashMap]: https://github.com/mozilla/rust/blob/master/src/libcollections/hashmap.rs\n [json]: https://github.com/mozilla/rust/blob/master/src/libserialize/json.rs\n \n@@ -149,6 +149,6 @@ example we were setting RUST_LOG to the name of the hello crate. Multiple paths\n can be combined to control the exact logging you want to see. For example, when\n debugging linking in the compiler you might set\n `RUST_LOG=rustc::metadata::creader,rustc::util::filesearch,rustc::back::rpath`\n-For a full description see [the language reference][1].\n+For a full description see [the logging crate][1].\n \n-[1]:http://doc.rust-lang.org/doc/master/rust.html#logging-system\n+[1]:log/index.html"}, {"sha": "4e1a96710be84b044834a51305331e9f199975f5", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -499,9 +499,9 @@ shouldn't get triggered.\n \n The second of these two functions, `eh_personality`, is used by the failure\n mechanisms of the compiler. This is often mapped to GCC's personality function\n-(see the [libstd implementation](../std/rt/unwind/) for more information), but\n-crates which do not trigger failure can be assured that this function is never\n-called.\n+(see the [libstd implementation](std/rt/unwind/index.html) for more\n+information), but crates which do not trigger failure can be assured that this\n+function is never called.\n \n ## Using libcore\n \n@@ -511,7 +511,8 @@ called.\n With the above techniques, we've got a bare-metal executable running some Rust\n code. There is a good deal of functionality provided by the standard library,\n however, that is necessary to be productive in Rust. If the standard library is\n-not sufficient, then [libcore](../core/) is designed to be used instead.\n+not sufficient, then [libcore](core/index.html) is designed to be used\n+instead.\n \n The core library has very few dependencies and is much more portable than the\n standard library itself. Additionally, the core library has most of the"}, {"sha": "511983da4f7f24a8bb07c6ad7d5da220acb2eb65", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -97,6 +97,7 @@ pub mod arc;\n pub mod rc;\n \n #[cfg(not(test))]\n+#[doc(hidden)]\n mod std {\n     pub use core::fmt;\n     pub use core::option;"}, {"sha": "146f29dd9f1da64716a765223002069ce0dfd2e2", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -12,6 +12,8 @@\n //!\n //! A `to_bit` conversion function.\n \n+#![doc(primitive = \"bool\")]\n+\n use num::{Int, one, zero};\n \n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "76ff56a77a48d67a4bee6b92d23b149da8601158", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -24,6 +24,7 @@\n //! and, as such, should be performed via the `from_u32` function..\n \n #![allow(non_snake_case_functions)]\n+#![doc(primitive = \"char\")]\n \n use mem::transmute;\n use option::{None, Option, Some};"}, {"sha": "6aa07415e9cc71edb19a7666edf54414c53b434d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -134,10 +134,12 @@ pub mod fmt;\n //        crate.\n mod should_not_exist;\n \n+#[doc(hidden)]\n mod core {\n     pub use failure;\n }\n \n+#[doc(hidden)]\n mod std {\n     pub use clone;\n     pub use cmp;"}, {"sha": "cadc874891d2042109c0316e3db1a65439a1941f", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for 32-bits floats (`f32` type)\n \n+#![doc(primitive = \"f32\")]\n+\n use intrinsics;\n use mem;\n use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};"}, {"sha": "5e19015dd02819209f3d69f1f932dc6cc932e582", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for 64-bits floats (`f64` type)\n \n+#![doc(primitive = \"f64\")]\n+\n use intrinsics;\n use mem;\n use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};"}, {"sha": "b821ff60a730e13b98b1e617c79547ad10cd2330", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,5 +10,7 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n+#![doc(primitive = \"i16\")]\n+\n int_module!(i16, 16)\n "}, {"sha": "a8cab1f95b0afc47d941947fbe604023ce50e240", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,5 +10,7 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n+#![doc(primitive = \"i32\")]\n+\n int_module!(i32, 32)\n "}, {"sha": "6009b953bb4dbb3de25dc6676ff42a57aaf8b982", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,5 +10,7 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n+#![doc(primitive = \"i64\")]\n+\n int_module!(i64, 64)\n "}, {"sha": "b3a5557b20c7fd42a0a553e83bcdaee29087011a", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,5 +10,7 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n+#![doc(primitive = \"i8\")]\n+\n int_module!(i8, 8)\n "}, {"sha": "06d64e73abd49ec76b8c8b2b22c09cc48024c8f6", "filename": "src/libcore/num/int.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for architecture-sized signed integers (`int` type)\n \n+#![doc(primitive = \"int\")]\n+\n #[cfg(target_word_size = \"32\")] int_module!(int, 32)\n #[cfg(target_word_size = \"64\")] int_module!(int, 64)\n "}, {"sha": "eb4bd427d51666507183b8cb2201af809d940c1d", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,4 +10,6 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n+#![doc(primitive = \"u16\")]\n+\n uint_module!(u16, i16, 16)"}, {"sha": "9522b2e86ac639db8e24c40c0fe926bb54f6d99e", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,5 +10,7 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n+#![doc(primitive = \"u32\")]\n+\n uint_module!(u32, i32, 32)\n "}, {"sha": "7a654f4bffa0d76cd13161684a7bd2e0719e03df", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,5 +10,7 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n+#![doc(primitive = \"u64\")]\n+\n uint_module!(u64, i64, 64)\n "}, {"sha": "6a42ce07e5d18c7ca8586c93891f9e25cf7fb628", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,5 +10,7 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n+#![doc(primitive = \"u8\")]\n+\n uint_module!(u8, i8, 8)\n "}, {"sha": "2f539fff61ae6417a8d0a8e26b083f152ed5fe42", "filename": "src/libcore/num/uint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,5 +10,7 @@\n \n //! Operations and constants for architecture-sized unsigned integers (`uint` type)\n \n+#![doc(primitive = \"uint\")]\n+\n uint_module!(uint, int, ::int::BITS)\n "}, {"sha": "0762c7458d906c450c20da748fc673b6d284ef7f", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -234,8 +234,8 @@\n //! similar and complementary: they are often employed to indicate a\n //! lack of a return value; and they are trivially converted between\n //! each other, so `Result`s are often handled by first converting to\n-//! `Option` with the [`ok`](enum.Result.html#method.ok) and\n-//! [`err`](enum.Result.html#method.ok) methods.\n+//! `Option` with the [`ok`](type.Result.html#method.ok) and\n+//! [`err`](type.Result.html#method.ok) methods.\n //!\n //! Whereas `Option` only indicates the lack of a value, `Result` is\n //! specifically for error reporting, and carries with it an error"}, {"sha": "8f885dafffa46f09fa89f619976f129d723e59ae", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -12,6 +12,8 @@\n //!\n //! For more details `std::slice`.\n \n+#![doc(primitive = \"slice\")]\n+\n use mem::transmute;\n use clone::Clone;\n use container::Container;"}, {"sha": "21dbaf705973f2006a1b83f7224f8e0878e3b55e", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -12,6 +12,8 @@\n //!\n //! For more details, see std::str\n \n+#![doc(primitive = \"str\")]\n+\n use mem;\n use char;\n use clone::Clone;"}, {"sha": "f9a14b1de506fe2ab2ea6f3ee0b6c25851c38e09", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -59,6 +59,8 @@\n //! assert_eq!(d, (0u32, 0.0f32));\n //! ```\n \n+#![doc(primitive = \"tuple\")]\n+\n use clone::Clone;\n #[cfg(not(test))] use cmp::*;\n #[cfg(not(test))] use default::Default;"}, {"sha": "65c60f2d3606de00a8dbb655004ea0b846f5a5c1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -62,17 +62,22 @@ fn try_inline_def(cx: &core::DocContext,\n             clean::TraitItem(build_external_trait(tcx, did))\n         }\n         ast::DefFn(did, style) => {\n+            // If this function is a tuple struct constructor, we just skip it\n+            if csearch::get_tuple_struct_definition_if_ctor(&tcx.sess.cstore,\n+                                                            did).is_some() {\n+                return None\n+            }\n             record_extern_fqn(cx, did, clean::TypeFunction);\n             clean::FunctionItem(build_external_function(tcx, did, style))\n         }\n         ast::DefStruct(did) => {\n             record_extern_fqn(cx, did, clean::TypeStruct);\n-            ret.extend(build_impls(tcx, did).move_iter());\n+            ret.extend(build_impls(cx, tcx, did).move_iter());\n             clean::StructItem(build_struct(tcx, did))\n         }\n         ast::DefTy(did) => {\n             record_extern_fqn(cx, did, clean::TypeEnum);\n-            ret.extend(build_impls(tcx, did).move_iter());\n+            ret.extend(build_impls(cx, tcx, did).move_iter());\n             build_type(tcx, did)\n         }\n         // Assume that the enum type is reexported next to the variant, and\n@@ -193,7 +198,8 @@ fn build_type(tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n     })\n }\n \n-fn build_impls(tcx: &ty::ctxt,\n+fn build_impls(cx: &core::DocContext,\n+               tcx: &ty::ctxt,\n                did: ast::DefId) -> Vec<clean::Item> {\n     ty::populate_implementations_for_type_if_necessary(tcx, did);\n     let mut impls = Vec::new();\n@@ -205,6 +211,38 @@ fn build_impls(tcx: &ty::ctxt,\n         }\n     }\n \n+    // If this is the first time we've inlined something from this crate, then\n+    // we inline *all* impls from the crate into this crate. Note that there's\n+    // currently no way for us to filter this based on type, and we likely need\n+    // many impls for a variety of reasons.\n+    //\n+    // Primarily, the impls will be used to populate the documentation for this\n+    // type being inlined, but impls can also be used when generating\n+    // documentation for primitives (no way to find those specifically).\n+    if cx.populated_crate_impls.borrow_mut().insert(did.krate) {\n+        csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n+                                              did.krate,\n+                                              |def, _, _| {\n+            populate_impls(tcx, def, &mut impls)\n+        });\n+\n+        fn populate_impls(tcx: &ty::ctxt,\n+                          def: decoder::DefLike,\n+                          impls: &mut Vec<clean::Item>) {\n+            match def {\n+                decoder::DlImpl(did) => impls.push(build_impl(tcx, did)),\n+                decoder::DlDef(ast::DefMod(did)) => {\n+                    csearch::each_child_of_item(&tcx.sess.cstore,\n+                                                did,\n+                                                |def, _, _| {\n+                        populate_impls(tcx, def, impls)\n+                    })\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n     impls\n }\n \n@@ -259,15 +297,17 @@ fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n \n     // FIXME: this doesn't handle reexports inside the module itself.\n     //        Should they be handled?\n-    csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, _| {\n+    csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, vis| {\n+        if vis != ast::Public { return }\n         match def {\n             decoder::DlDef(def) => {\n                 match try_inline_def(cx, tcx, def) {\n                     Some(i) => items.extend(i.move_iter()),\n                     None => {}\n                 }\n             }\n-            decoder::DlImpl(did) => items.push(build_impl(tcx, did)),\n+            // All impls were inlined above\n+            decoder::DlImpl(..) => {}\n             decoder::DlField => fail!(\"unimplemented field\"),\n         }\n     });"}, {"sha": "856619882c574b18753448b26909c2c04e600e9f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 238, "deletions": 42, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -28,6 +28,7 @@ use rustc::metadata::decoder;\n use rustc::middle::ty;\n \n use std::rc::Rc;\n+use std::u32;\n \n use core;\n use doctree;\n@@ -81,6 +82,7 @@ pub struct Crate {\n     pub name: String,\n     pub module: Option<Item>,\n     pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n+    pub primitives: Vec<Primitive>,\n }\n \n impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n@@ -92,6 +94,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n             externs.push((n, meta.clean()));\n         });\n \n+        // Figure out the name of this crate\n         let input = driver::FileInput(cx.src.clone());\n         let t_outputs = driver::build_output_filenames(&input,\n                                                        &None,\n@@ -100,10 +103,62 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n                                                        cx.sess());\n         let id = link::find_crate_id(self.attrs.as_slice(),\n                                      t_outputs.out_filestem.as_slice());\n+\n+        // Clean the crate, translating the entire libsyntax AST to one that is\n+        // understood by rustdoc.\n+        let mut module = self.module.clean();\n+\n+        // Collect all inner modules which are tagged as implementations of\n+        // primitives.\n+        //\n+        // Note that this loop only searches the top-level items of the crate,\n+        // and this is intentional. If we were to search the entire crate for an\n+        // item tagged with `#[doc(primitive)]` then we we would also have to\n+        // search the entirety of external modules for items tagged\n+        // `#[doc(primitive)]`, which is a pretty inefficient process (decoding\n+        // all that metadata unconditionally).\n+        //\n+        // In order to keep the metadata load under control, the\n+        // `#[doc(primitive)]` feature is explicitly designed to only allow the\n+        // primitive tags to show up as the top level items in a crate.\n+        //\n+        // Also note that this does not attempt to deal with modules tagged\n+        // duplicately for the same primitive. This is handled later on when\n+        // rendering by delegating everything to a hash map.\n+        let mut primitives = Vec::new();\n+        {\n+            let m = match module.inner {\n+                ModuleItem(ref mut m) => m,\n+                _ => unreachable!(),\n+            };\n+            let mut tmp = Vec::new();\n+            for child in m.items.iter() {\n+                match child.inner {\n+                    ModuleItem(..) => {},\n+                    _ => continue,\n+                }\n+                let prim = match Primitive::find(child.attrs.as_slice()) {\n+                    Some(prim) => prim,\n+                    None => continue,\n+                };\n+                primitives.push(prim);\n+                tmp.push(Item {\n+                    source: Span::empty(),\n+                    name: Some(prim.to_url_str().to_string()),\n+                    attrs: child.attrs.clone(),\n+                    visibility: Some(ast::Public),\n+                    def_id: ast_util::local_def(prim.to_node_id()),\n+                    inner: PrimitiveItem(prim),\n+                });\n+            }\n+            m.items.extend(tmp.move_iter());\n+        }\n+\n         Crate {\n             name: id.name.to_string(),\n-            module: Some(self.module.clean()),\n+            module: Some(module),\n             externs: externs,\n+            primitives: primitives,\n         }\n     }\n }\n@@ -112,15 +167,35 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n pub struct ExternalCrate {\n     pub name: String,\n     pub attrs: Vec<Attribute>,\n+    pub primitives: Vec<Primitive>,\n }\n \n impl Clean<ExternalCrate> for cstore::crate_metadata {\n     fn clean(&self) -> ExternalCrate {\n+        let mut primitives = Vec::new();\n+        let cx = super::ctxtkey.get().unwrap();\n+        match cx.maybe_typed {\n+            core::Typed(ref tcx) => {\n+                csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n+                                                      self.cnum,\n+                                                      |def, _, _| {\n+                    let did = match def {\n+                        decoder::DlDef(ast::DefMod(did)) => did,\n+                        _ => return\n+                    };\n+                    let attrs = inline::load_attrs(tcx, did);\n+                    match Primitive::find(attrs.as_slice()) {\n+                        Some(prim) => primitives.push(prim),\n+                        None => {}\n+                    }\n+                });\n+            }\n+            core::NotTyped(..) => {}\n+        }\n         ExternalCrate {\n             name: self.name.to_string(),\n-            attrs: decoder::get_crate_attributes(self.data()).clean()\n-                                                             .move_iter()\n-                                                             .collect(),\n+            attrs: decoder::get_crate_attributes(self.data()).clean(),\n+            primitives: primitives,\n         }\n     }\n }\n@@ -227,6 +302,7 @@ pub enum ItemEnum {\n     /// `static`s from an extern block\n     ForeignStaticItem(Static),\n     MacroItem(Macro),\n+    PrimitiveItem(Primitive),\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -400,14 +476,19 @@ impl Clean<TyParamBound> for ast::TyParamBound {\n     }\n }\n \n-fn external_path(name: &str) -> Path {\n+fn external_path(name: &str, substs: &ty::substs) -> Path {\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n-            lifetimes: Vec::new(),\n-            types: Vec::new(),\n-        }]\n+            lifetimes: match substs.regions {\n+                ty::ErasedRegions => Vec::new(),\n+                ty::NonerasedRegions(ref v) => {\n+                    v.iter().filter_map(|v| v.clean()).collect()\n+                }\n+            },\n+            types: substs.tps.clean(),\n+        }],\n     }\n }\n \n@@ -418,16 +499,21 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n             core::Typed(ref tcx) => tcx,\n             core::NotTyped(_) => return RegionBound,\n         };\n+        let empty = ty::substs::empty();\n         let (did, path) = match *self {\n             ty::BoundStatic => return RegionBound,\n             ty::BoundSend =>\n-                (tcx.lang_items.send_trait().unwrap(), external_path(\"Send\")),\n+                (tcx.lang_items.send_trait().unwrap(),\n+                 external_path(\"Send\", &empty)),\n             ty::BoundSized =>\n-                (tcx.lang_items.sized_trait().unwrap(), external_path(\"Sized\")),\n+                (tcx.lang_items.sized_trait().unwrap(),\n+                 external_path(\"Sized\", &empty)),\n             ty::BoundCopy =>\n-                (tcx.lang_items.copy_trait().unwrap(), external_path(\"Copy\")),\n+                (tcx.lang_items.copy_trait().unwrap(),\n+                 external_path(\"Copy\", &empty)),\n             ty::BoundShare =>\n-                (tcx.lang_items.share_trait().unwrap(), external_path(\"Share\")),\n+                (tcx.lang_items.share_trait().unwrap(),\n+                 external_path(\"Share\", &empty)),\n         };\n         let fqn = csearch::get_item_path(tcx, did);\n         let fqn = fqn.move_iter().map(|i| i.to_str().to_string()).collect();\n@@ -451,7 +537,8 @@ impl Clean<TyParamBound> for ty::TraitRef {\n         let fqn = csearch::get_item_path(tcx, self.def_id);\n         let fqn = fqn.move_iter().map(|i| i.to_str().to_string())\n                      .collect::<Vec<String>>();\n-        let path = external_path(fqn.last().unwrap().as_slice());\n+        let path = external_path(fqn.last().unwrap().as_slice(),\n+                                 &self.substs);\n         cx.external_paths.borrow_mut().get_mut_ref().insert(self.def_id,\n                                                             (fqn, TypeTrait));\n         TraitBound(ResolvedPath {\n@@ -519,9 +606,9 @@ impl Clean<Option<Lifetime>> for ty::Region {\n             ty::ReStatic => Some(Lifetime(\"static\".to_string())),\n             ty::ReLateBound(_, ty::BrNamed(_, name)) =>\n                 Some(Lifetime(token::get_name(name).get().to_string())),\n+            ty::ReEarlyBound(_, _, name) => Some(Lifetime(name.clean())),\n \n             ty::ReLateBound(..) |\n-            ty::ReEarlyBound(..) |\n             ty::ReFree(..) |\n             ty::ReScope(..) |\n             ty::ReInfer(..) |\n@@ -920,18 +1007,14 @@ pub enum Type {\n     /// For references to self\n     Self(ast::DefId),\n     /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n-    Primitive(ast::PrimTy),\n+    Primitive(Primitive),\n     Closure(Box<ClosureDecl>, Option<Lifetime>),\n     Proc(Box<ClosureDecl>),\n     /// extern \"ABI\" fn\n     BareFunction(Box<BareFunctionDecl>),\n     Tuple(Vec<Type>),\n     Vector(Box<Type>),\n     FixedVector(Box<Type>, String),\n-    String,\n-    Bool,\n-    /// aka TyNil\n-    Unit,\n     /// aka TyBot\n     Bottom,\n     Unique(Box<Type>),\n@@ -945,6 +1028,19 @@ pub enum Type {\n     // region, raw, other boxes, mutable\n }\n \n+#[deriving(Clone, Encodable, Decodable, PartialEq, TotalEq, Hash)]\n+pub enum Primitive {\n+    Int, I8, I16, I32, I64,\n+    Uint, U8, U16, U32, U64,\n+    F32, F64, F128,\n+    Char,\n+    Bool,\n+    Nil,\n+    Str,\n+    Slice,\n+    PrimitiveTuple,\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub enum TypeKind {\n     TypeEnum,\n@@ -956,11 +1052,97 @@ pub enum TypeKind {\n     TypeVariant,\n }\n \n+impl Primitive {\n+    fn from_str(s: &str) -> Option<Primitive> {\n+        match s.as_slice() {\n+            \"int\" => Some(Int),\n+            \"i8\" => Some(I8),\n+            \"i16\" => Some(I16),\n+            \"i32\" => Some(I32),\n+            \"i64\" => Some(I64),\n+            \"uint\" => Some(Uint),\n+            \"u8\" => Some(U8),\n+            \"u16\" => Some(U16),\n+            \"u32\" => Some(U32),\n+            \"u64\" => Some(U64),\n+            \"bool\" => Some(Bool),\n+            \"nil\" => Some(Nil),\n+            \"char\" => Some(Char),\n+            \"str\" => Some(Str),\n+            \"f32\" => Some(F32),\n+            \"f64\" => Some(F64),\n+            \"f128\" => Some(F128),\n+            \"slice\" => Some(Slice),\n+            \"tuple\" => Some(PrimitiveTuple),\n+            _ => None,\n+        }\n+    }\n+\n+    fn find(attrs: &[Attribute]) -> Option<Primitive> {\n+        for attr in attrs.iter() {\n+            let list = match *attr {\n+                List(ref k, ref l) if k.as_slice() == \"doc\" => l,\n+                _ => continue,\n+            };\n+            for sub_attr in list.iter() {\n+                let value = match *sub_attr {\n+                    NameValue(ref k, ref v)\n+                        if k.as_slice() == \"primitive\" => v.as_slice(),\n+                    _ => continue,\n+                };\n+                match Primitive::from_str(value) {\n+                    Some(p) => return Some(p),\n+                    None => {}\n+                }\n+            }\n+        }\n+        return None\n+    }\n+\n+    pub fn to_str(&self) -> &'static str {\n+        match *self {\n+            Int => \"int\",\n+            I8 => \"i8\",\n+            I16 => \"i16\",\n+            I32 => \"i32\",\n+            I64 => \"i64\",\n+            Uint => \"uint\",\n+            U8 => \"u8\",\n+            U16 => \"u16\",\n+            U32 => \"u32\",\n+            U64 => \"u64\",\n+            F32 => \"f32\",\n+            F64 => \"f64\",\n+            F128 => \"f128\",\n+            Str => \"str\",\n+            Bool => \"bool\",\n+            Char => \"char\",\n+            Nil => \"()\",\n+            Slice => \"slice\",\n+            PrimitiveTuple => \"tuple\",\n+        }\n+    }\n+\n+    pub fn to_url_str(&self) -> &'static str {\n+        match *self {\n+            Nil => \"nil\",\n+            other => other.to_str(),\n+        }\n+    }\n+\n+    /// Creates a rustdoc-specific node id for primitive types.\n+    ///\n+    /// These node ids are generally never used by the AST itself.\n+    pub fn to_node_id(&self) -> ast::NodeId {\n+        u32::MAX - 1 - (*self as u32)\n+    }\n+}\n+\n impl Clean<Type> for ast::Ty {\n     fn clean(&self) -> Type {\n         use syntax::ast::*;\n         match self.node {\n-            TyNil => Unit,\n+            TyNil => Primitive(Nil),\n             TyPtr(ref m) => RawPointer(m.mutbl.clean(), box m.ty.clean()),\n             TyRptr(ref l, ref m) =>\n                 BorrowedRef {lifetime: l.clean(), mutability: m.mutbl.clean(),\n@@ -988,16 +1170,26 @@ impl Clean<Type> for ast::Ty {\n impl Clean<Type> for ty::t {\n     fn clean(&self) -> Type {\n         match ty::get(*self).sty {\n-            ty::ty_nil => Unit,\n             ty::ty_bot => Bottom,\n-            ty::ty_bool => Bool,\n-            ty::ty_char => Primitive(ast::TyChar),\n-            ty::ty_int(t) => Primitive(ast::TyInt(t)),\n-            ty::ty_uint(u) => Primitive(ast::TyUint(u)),\n-            ty::ty_float(f) => Primitive(ast::TyFloat(f)),\n+            ty::ty_nil => Primitive(Nil),\n+            ty::ty_bool => Primitive(Bool),\n+            ty::ty_char => Primitive(Char),\n+            ty::ty_int(ast::TyI) => Primitive(Int),\n+            ty::ty_int(ast::TyI8) => Primitive(I8),\n+            ty::ty_int(ast::TyI16) => Primitive(I16),\n+            ty::ty_int(ast::TyI32) => Primitive(I32),\n+            ty::ty_int(ast::TyI64) => Primitive(I64),\n+            ty::ty_uint(ast::TyU) => Primitive(Uint),\n+            ty::ty_uint(ast::TyU8) => Primitive(U8),\n+            ty::ty_uint(ast::TyU16) => Primitive(U16),\n+            ty::ty_uint(ast::TyU32) => Primitive(U32),\n+            ty::ty_uint(ast::TyU64) => Primitive(U64),\n+            ty::ty_float(ast::TyF32) => Primitive(F32),\n+            ty::ty_float(ast::TyF64) => Primitive(F64),\n+            ty::ty_float(ast::TyF128) => Primitive(F128),\n+            ty::ty_str => Primitive(Str),\n             ty::ty_box(t) => Managed(box t.clean()),\n             ty::ty_uniq(t) => Unique(box t.clean()),\n-            ty::ty_str => String,\n             ty::ty_vec(mt, None) => Vector(box mt.ty.clean()),\n             ty::ty_vec(mt, Some(i)) => FixedVector(box mt.ty.clean(),\n                                                    format!(\"{}\", i)),\n@@ -1040,22 +1232,13 @@ impl Clean<Type> for ty::t {\n                 let fqn: Vec<String> = fqn.move_iter().map(|i| {\n                     i.to_str().to_string()\n                 }).collect();\n-                let mut path = external_path(fqn.last()\n-                                                .unwrap()\n-                                                .to_str()\n-                                                .as_slice());\n                 let kind = match ty::get(*self).sty {\n                     ty::ty_struct(..) => TypeStruct,\n                     ty::ty_trait(..) => TypeTrait,\n                     _ => TypeEnum,\n                 };\n-                path.segments.get_mut(0).lifetimes = match substs.regions {\n-                    ty::ErasedRegions => Vec::new(),\n-                    ty::NonerasedRegions(ref v) => {\n-                        v.iter().filter_map(|v| v.clean()).collect()\n-                    }\n-                };\n-                path.segments.get_mut(0).types = substs.tps.clean();\n+                let path = external_path(fqn.last().unwrap().to_str().as_slice(),\n+                                         substs);\n                 cx.external_paths.borrow_mut().get_mut_ref().insert(did,\n                                                                     (fqn, kind));\n                 ResolvedPath {\n@@ -1747,7 +1930,7 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n     let tycx = match cx.maybe_typed {\n         core::Typed(ref tycx) => tycx,\n         // If we're extracting tests, this return value doesn't matter.\n-        core::NotTyped(_) => return Bool\n+        core::NotTyped(_) => return Primitive(Bool),\n     };\n     debug!(\"searching for {:?} in defmap\", id);\n     let def = match tycx.def_map.borrow().find(&id) {\n@@ -1758,9 +1941,22 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n     match def {\n         ast::DefSelfTy(i) => return Self(ast_util::local_def(i)),\n         ast::DefPrimTy(p) => match p {\n-            ast::TyStr => return String,\n-            ast::TyBool => return Bool,\n-            _ => return Primitive(p)\n+            ast::TyStr => return Primitive(Str),\n+            ast::TyBool => return Primitive(Bool),\n+            ast::TyChar => return Primitive(Char),\n+            ast::TyInt(ast::TyI) => return Primitive(Int),\n+            ast::TyInt(ast::TyI8) => return Primitive(I8),\n+            ast::TyInt(ast::TyI16) => return Primitive(I16),\n+            ast::TyInt(ast::TyI32) => return Primitive(I32),\n+            ast::TyInt(ast::TyI64) => return Primitive(I64),\n+            ast::TyUint(ast::TyU) => return Primitive(Uint),\n+            ast::TyUint(ast::TyU8) => return Primitive(U8),\n+            ast::TyUint(ast::TyU16) => return Primitive(U16),\n+            ast::TyUint(ast::TyU32) => return Primitive(U32),\n+            ast::TyUint(ast::TyU64) => return Primitive(U64),\n+            ast::TyFloat(ast::TyF32) => return Primitive(F32),\n+            ast::TyFloat(ast::TyF64) => return Primitive(F64),\n+            ast::TyFloat(ast::TyF128) => return Primitive(F128),\n         },\n         ast::DefTyParam(i, _) => return Generic(i),\n         ast::DefTyParamBinder(i) => return TyParamBinder(i),"}, {"sha": "87b19fecb1f2025bf97747982767b7c5ef944e92", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -42,6 +42,7 @@ pub struct DocContext {\n     pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n     pub external_typarams: RefCell<Option<HashMap<ast::DefId, String>>>,\n     pub inlined: RefCell<Option<HashSet<ast::DefId>>>,\n+    pub populated_crate_impls: RefCell<HashSet<ast::CrateNum>>,\n }\n \n impl DocContext {\n@@ -114,6 +115,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n         external_typarams: RefCell::new(Some(HashMap::new())),\n         external_paths: RefCell::new(Some(HashMap::new())),\n         inlined: RefCell::new(Some(HashSet::new())),\n+        populated_crate_impls: RefCell::new(HashSet::new()),\n     }, CrateAnalysis {\n         exported_items: exported_items,\n         public_items: public_items,"}, {"sha": "41d84deea6f4105661c96cdf66cfb742ef8064a7", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 68, "deletions": 38, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -263,6 +263,53 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n     Ok(())\n }\n \n+fn primitive_link(f: &mut fmt::Formatter,\n+                  prim: clean::Primitive,\n+                  name: &str) -> fmt::Result {\n+    let m = cache_key.get().unwrap();\n+    let mut needs_termination = false;\n+    match m.primitive_locations.find(&prim) {\n+        Some(&ast::LOCAL_CRATE) => {\n+            let loc = current_location_key.get().unwrap();\n+            let len = if loc.len() == 0 {0} else {loc.len() - 1};\n+            try!(write!(f, \"<a href='{}primitive.{}.html'>\",\n+                        \"../\".repeat(len),\n+                        prim.to_url_str()));\n+            needs_termination = true;\n+        }\n+        Some(&cnum) => {\n+            let path = m.paths.get(&ast::DefId {\n+                krate: cnum,\n+                node: ast::CRATE_NODE_ID,\n+            });\n+            let loc = match *m.extern_locations.get(&cnum) {\n+                render::Remote(ref s) => Some(s.to_string()),\n+                render::Local => {\n+                    let loc = current_location_key.get().unwrap();\n+                    Some(\"../\".repeat(loc.len()))\n+                }\n+                render::Unknown => None,\n+            };\n+            match loc {\n+                Some(root) => {\n+                    try!(write!(f, \"<a href='{}{}/primitive.{}.html'>\",\n+                                root,\n+                                path.ref0().as_slice().head().unwrap(),\n+                                prim.to_url_str()));\n+                    needs_termination = true;\n+                }\n+                None => {}\n+            }\n+        }\n+        None => {}\n+    }\n+    try!(write!(f, \"{}\", name));\n+    if needs_termination {\n+        try!(write!(f, \"</a>\"));\n+    }\n+    Ok(())\n+}\n+\n /// Helper to render type parameters\n fn tybounds(w: &mut fmt::Formatter,\n             typarams: &Option<Vec<clean::TyParamBound> >) -> fmt::Result {\n@@ -297,27 +344,7 @@ impl fmt::Show for clean::Type {\n                 tybounds(f, typarams)\n             }\n             clean::Self(..) => f.write(\"Self\".as_bytes()),\n-            clean::Primitive(prim) => {\n-                let s = match prim {\n-                    ast::TyInt(ast::TyI) => \"int\",\n-                    ast::TyInt(ast::TyI8) => \"i8\",\n-                    ast::TyInt(ast::TyI16) => \"i16\",\n-                    ast::TyInt(ast::TyI32) => \"i32\",\n-                    ast::TyInt(ast::TyI64) => \"i64\",\n-                    ast::TyUint(ast::TyU) => \"uint\",\n-                    ast::TyUint(ast::TyU8) => \"u8\",\n-                    ast::TyUint(ast::TyU16) => \"u16\",\n-                    ast::TyUint(ast::TyU32) => \"u32\",\n-                    ast::TyUint(ast::TyU64) => \"u64\",\n-                    ast::TyFloat(ast::TyF32) => \"f32\",\n-                    ast::TyFloat(ast::TyF64) => \"f64\",\n-                    ast::TyFloat(ast::TyF128) => \"f128\",\n-                    ast::TyStr => \"str\",\n-                    ast::TyBool => \"bool\",\n-                    ast::TyChar => \"char\",\n-                };\n-                f.write(s.as_bytes())\n-            }\n+            clean::Primitive(prim) => primitive_link(f, prim, prim.to_str()),\n             clean::Closure(ref decl, ref region) => {\n                 write!(f, \"{style}{lifetimes}|{args}|{bounds}\\\n                            {arrow, select, yes{ -&gt; {ret}} other{}}\",\n@@ -329,7 +356,7 @@ impl fmt::Show for clean::Type {\n                        },\n                        args = decl.decl.inputs,\n                        arrow = match decl.decl.output {\n-                           clean::Unit => \"no\",\n+                           clean::Primitive(clean::Nil) => \"no\",\n                            _ => \"yes\",\n                        },\n                        ret = decl.decl.output,\n@@ -379,7 +406,10 @@ impl fmt::Show for clean::Type {\n                                \": {}\",\n                                m.collect::<Vec<String>>().connect(\" + \"))\n                        },\n-                       arrow = match decl.decl.output { clean::Unit => \"no\", _ => \"yes\" },\n+                       arrow = match decl.decl.output {\n+                           clean::Primitive(clean::Nil) => \"no\",\n+                           _ => \"yes\",\n+                       },\n                        ret = decl.decl.output)\n             }\n             clean::BareFunction(ref decl) => {\n@@ -394,22 +424,16 @@ impl fmt::Show for clean::Type {\n                        decl.decl)\n             }\n             clean::Tuple(ref typs) => {\n-                try!(f.write(\"(\".as_bytes()));\n-                for (i, typ) in typs.iter().enumerate() {\n-                    if i > 0 {\n-                        try!(f.write(\", \".as_bytes()))\n-                    }\n-                    try!(write!(f, \"{}\", *typ));\n-                }\n-                f.write(\")\".as_bytes())\n+                primitive_link(f, clean::PrimitiveTuple,\n+                               format!(\"({:#})\", typs).as_slice())\n+            }\n+            clean::Vector(ref t) => {\n+                primitive_link(f, clean::Slice, format!(\"[{}]\", **t).as_slice())\n             }\n-            clean::Vector(ref t) => write!(f, \"[{}]\", **t),\n             clean::FixedVector(ref t, ref s) => {\n-                write!(f, \"[{}, ..{}]\", **t, *s)\n+                primitive_link(f, clean::Slice,\n+                               format!(\"[{}, ..{}]\", **t, *s).as_slice())\n             }\n-            clean::String => f.write(\"str\".as_bytes()),\n-            clean::Bool => f.write(\"bool\".as_bytes()),\n-            clean::Unit => f.write(\"()\".as_bytes()),\n             clean::Bottom => f.write(\"!\".as_bytes()),\n             clean::Unique(ref t) => write!(f, \"~{}\", **t),\n             clean::Managed(ref t) => write!(f, \"@{}\", **t),\n@@ -454,7 +478,10 @@ impl fmt::Show for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n                args = self.inputs,\n-               arrow = match self.output { clean::Unit => \"no\", _ => \"yes\" },\n+               arrow = match self.output {\n+                   clean::Primitive(clean::Nil) => \"no\",\n+                   _ => \"yes\"\n+               },\n                ret = self.output)\n     }\n }\n@@ -490,7 +517,10 @@ impl<'a> fmt::Show for Method<'a> {\n         write!(f,\n                \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n                args = args,\n-               arrow = match d.output { clean::Unit => \"no\", _ => \"yes\" },\n+               arrow = match d.output {\n+                   clean::Primitive(clean::Nil) => \"no\",\n+                   _ => \"yes\"\n+               },\n                ret = d.output)\n     }\n }"}, {"sha": "f36c81f8f8d8d507923794e9db6c9a55a5131b94", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -37,6 +37,7 @@ pub enum ItemType {\n     ForeignFunction = 13,\n     ForeignStatic   = 14,\n     Macro           = 15,\n+    Primitive       = 16,\n }\n \n impl ItemType {\n@@ -58,6 +59,7 @@ impl ItemType {\n             ForeignFunction => \"ffi\",\n             ForeignStatic   => \"ffs\",\n             Macro           => \"macro\",\n+            Primitive       => \"primitive\",\n         }\n     }\n }\n@@ -92,6 +94,7 @@ pub fn shortty(item: &clean::Item) -> ItemType {\n         clean::ForeignFunctionItem(..) => ForeignFunction,\n         clean::ForeignStaticItem(..)   => ForeignStatic,\n         clean::MacroItem(..)           => Macro,\n+        clean::PrimitiveItem(..)       => Primitive,\n     }\n }\n "}, {"sha": "80653878247fad444f20c419a7db4d955731c736", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -130,3 +130,17 @@ r##\"<!DOCTYPE html>\n fn nonestr<'a>(s: &'a str) -> &'a str {\n     if s == \"\" { \"none\" } else { s }\n }\n+\n+pub fn redirect(dst: &mut io::Writer, url: &str) -> io::IoResult<()> {\n+    write!(dst,\n+r##\"<!DOCTYPE html>\n+<html lang=\"en\">\n+<head>\n+    <meta http-equiv=\"refresh\" content=\"0;URL={url}\">\n+</head>\n+<body>\n+</body>\n+</html>\"##,\n+    url = url,\n+    )\n+}"}, {"sha": "16becde164ff3e2a3dd27fd16517fbdc83e1c596", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 378, "deletions": 261, "changes": 639, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -70,7 +70,7 @@ use html::markdown;\n pub struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n-    pub current: Vec<String> ,\n+    pub current: Vec<String>,\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     pub root_path: String,\n@@ -90,6 +90,10 @@ pub struct Context {\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n     pub include_sources: bool,\n+    /// A flag, which when turned off, will render pages which redirect to the\n+    /// real location of an item. This is used to allow external links to\n+    /// publicly reused items to redirect to the right location.\n+    pub render_redirect_pages: bool,\n }\n \n /// Indicates where an external crate can be found.\n@@ -102,13 +106,11 @@ pub enum ExternalLocation {\n     Unknown,\n }\n \n-/// Different ways an implementor of a trait can be rendered.\n-pub enum Implementor {\n-    /// Paths are displayed specially by omitting the `impl XX for` cruft\n-    PathType(clean::Type),\n-    /// This is the generic representation of a trait implementor, used for\n-    /// primitive types and otherwise non-path types.\n-    OtherType(clean::Generics, /* trait */ clean::Type, /* for */ clean::Type),\n+/// Metadata about an implementor of a trait.\n+pub struct Implementor {\n+    generics: clean::Generics,\n+    trait_: clean::Type,\n+    for_: clean::Type,\n }\n \n /// This cache is used to store information about the `clean::Crate` being\n@@ -159,6 +161,9 @@ pub struct Cache {\n     /// Cache of where external crate documentation can be found.\n     pub extern_locations: HashMap<ast::CrateNum, ExternalLocation>,\n \n+    /// Cache of where documentation for primitives can be found.\n+    pub primitive_locations: HashMap<clean::Primitive, ast::CrateNum>,\n+\n     /// Set of definitions which have been inlined from external crates.\n     pub inlined: HashSet<ast::DefId>,\n \n@@ -226,9 +231,12 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n             krate: krate.name.clone(),\n         },\n         include_sources: true,\n+        render_redirect_pages: false,\n     };\n     try!(mkdir(&cx.dst));\n \n+    // Crawl the crate attributes looking for attributes which control how we're\n+    // going to emit HTML\n     match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(&[])) {\n         Some(attrs) => {\n             for attr in attrs.iter() {\n@@ -281,6 +289,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         parent_stack: Vec::new(),\n         search_index: Vec::new(),\n         extern_locations: HashMap::new(),\n+        primitive_locations: HashMap::new(),\n         privmod: false,\n         public_items: public_items,\n         orphan_methods: Vec::new(),\n@@ -297,19 +306,58 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     cache.stack.push(krate.name.clone());\n     krate = cache.fold_crate(krate);\n \n+    // Cache where all our extern crates are located\n+    for &(n, ref e) in krate.externs.iter() {\n+        cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n+        let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n+        cache.paths.insert(did, (vec![e.name.to_string()], item_type::Module));\n+    }\n+\n+    // Cache where all known primitives have their documentation located.\n+    //\n+    // Favor linking to as local extern as possible, so iterate all crates in\n+    // reverse topological order.\n+    for &(n, ref e) in krate.externs.iter().rev() {\n+        for &prim in e.primitives.iter() {\n+            cache.primitive_locations.insert(prim, n);\n+        }\n+    }\n+    for &prim in krate.primitives.iter() {\n+        cache.primitive_locations.insert(prim, ast::LOCAL_CRATE);\n+    }\n+\n+    // Build our search index\n+    let index = try!(build_index(&krate, &mut cache));\n+\n+    // Freeze the cache now that the index has been built. Put an Arc into TLS\n+    // for future parallelization opportunities\n+    let cache = Arc::new(cache);\n+    cache_key.replace(Some(cache.clone()));\n+    current_location_key.replace(Some(Vec::new()));\n+\n+    try!(write_shared(&cx, &krate, &*cache, index));\n+    let krate = try!(render_sources(&mut cx, krate));\n+\n+    // And finally render the whole crate's documentation\n+    cx.krate(krate)\n+}\n+\n+fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String> {\n+    // Build the search index from the collected metadata\n     let mut nodeid_to_pathid = HashMap::new();\n     let mut pathid_to_nodeid = Vec::new();\n     {\n-        let Cache { search_index: ref mut index,\n-                    orphan_methods: ref meths, paths: ref mut paths, ..} = cache;\n+        let Cache { ref mut search_index,\n+                    ref orphan_methods,\n+                    ref mut paths, .. } = *cache;\n \n         // Attach all orphan methods to the type's definition if the type\n         // has since been learned.\n-        for &(pid, ref item) in meths.iter() {\n+        for &(pid, ref item) in orphan_methods.iter() {\n             let did = ast_util::local_def(pid);\n             match paths.find(&did) {\n                 Some(&(ref fqp, _)) => {\n-                    index.push(IndexItem {\n+                    search_index.push(IndexItem {\n                         ty: shortty(item),\n                         name: item.name.clone().unwrap(),\n                         path: fqp.slice_to(fqp.len() - 1).connect(\"::\")\n@@ -324,7 +372,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n \n         // Reduce `NodeId` in paths into smaller sequential numbers,\n         // and prune the paths that do not appear in the index.\n-        for item in index.iter() {\n+        for item in search_index.iter() {\n             match item.parent {\n                 Some(nodeid) => {\n                     if !nodeid_to_pathid.contains_key(&nodeid) {\n@@ -339,189 +387,181 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         assert_eq!(nodeid_to_pathid.len(), pathid_to_nodeid.len());\n     }\n \n-    // Publish the search index\n-    let index = {\n-        let mut w = MemWriter::new();\n-        try!(write!(&mut w, r#\"searchIndex['{}'] = \\{\"items\":[\"#, krate.name));\n-\n-        let mut lastpath = \"\".to_string();\n-        for (i, item) in cache.search_index.iter().enumerate() {\n-            // Omit the path if it is same to that of the prior item.\n-            let path;\n-            if lastpath.as_slice() == item.path.as_slice() {\n-                path = \"\";\n-            } else {\n-                lastpath = item.path.to_string();\n-                path = item.path.as_slice();\n-            };\n+    // Collect the index into a string\n+    let mut w = MemWriter::new();\n+    try!(write!(&mut w, r#\"searchIndex['{}'] = \\{\"items\":[\"#, krate.name));\n \n-            if i > 0 {\n-                try!(write!(&mut w, \",\"));\n-            }\n-            try!(write!(&mut w, r#\"[{:u},\"{}\",\"{}\",{}\"#,\n-                        item.ty, item.name, path,\n-                        item.desc.to_json().to_str()));\n-            match item.parent {\n-                Some(nodeid) => {\n-                    let pathid = *nodeid_to_pathid.find(&nodeid).unwrap();\n-                    try!(write!(&mut w, \",{}\", pathid));\n-                }\n-                None => {}\n+    let mut lastpath = \"\".to_string();\n+    for (i, item) in cache.search_index.iter().enumerate() {\n+        // Omit the path if it is same to that of the prior item.\n+        let path;\n+        if lastpath.as_slice() == item.path.as_slice() {\n+            path = \"\";\n+        } else {\n+            lastpath = item.path.to_string();\n+            path = item.path.as_slice();\n+        };\n+\n+        if i > 0 {\n+            try!(write!(&mut w, \",\"));\n+        }\n+        try!(write!(&mut w, r#\"[{:u},\"{}\",\"{}\",{}\"#,\n+                    item.ty, item.name, path,\n+                    item.desc.to_json().to_str()));\n+        match item.parent {\n+            Some(nodeid) => {\n+                let pathid = *nodeid_to_pathid.find(&nodeid).unwrap();\n+                try!(write!(&mut w, \",{}\", pathid));\n             }\n-            try!(write!(&mut w, \"]\"));\n+            None => {}\n         }\n+        try!(write!(&mut w, \"]\"));\n+    }\n \n-        try!(write!(&mut w, r#\"],\"paths\":[\"#));\n+    try!(write!(&mut w, r#\"],\"paths\":[\"#));\n \n-        for (i, &did) in pathid_to_nodeid.iter().enumerate() {\n-            let &(ref fqp, short) = cache.paths.find(&did).unwrap();\n-            if i > 0 {\n-                try!(write!(&mut w, \",\"));\n-            }\n-            try!(write!(&mut w, r#\"[{:u},\"{}\"]\"#,\n-                        short, *fqp.last().unwrap()));\n+    for (i, &did) in pathid_to_nodeid.iter().enumerate() {\n+        let &(ref fqp, short) = cache.paths.find(&did).unwrap();\n+        if i > 0 {\n+            try!(write!(&mut w, \",\"));\n         }\n+        try!(write!(&mut w, r#\"[{:u},\"{}\"]\"#,\n+                    short, *fqp.last().unwrap()));\n+    }\n \n-        try!(write!(&mut w, r\"]\\};\"));\n+    try!(write!(&mut w, r\"]\\};\"));\n \n-        str::from_utf8(w.unwrap().as_slice()).unwrap().to_string()\n-    };\n+    Ok(str::from_utf8(w.unwrap().as_slice()).unwrap().to_string())\n+}\n \n+fn write_shared(cx: &Context,\n+                krate: &clean::Crate,\n+                cache: &Cache,\n+                search_index: String) -> io::IoResult<()> {\n     // Write out the shared files. Note that these are shared among all rustdoc\n     // docs placed in the output directory, so this needs to be a synchronized\n     // operation with respect to all other rustdocs running around.\n-    {\n-        try!(mkdir(&cx.dst));\n-        let _lock = ::flock::Lock::new(&cx.dst.join(\".lock\"));\n-\n-        // Add all the static files. These may already exist, but we just\n-        // overwrite them anyway to make sure that they're fresh and up-to-date.\n-        try!(write(cx.dst.join(\"jquery.js\"),\n-                   include_bin!(\"static/jquery-2.1.0.min.js\")));\n-        try!(write(cx.dst.join(\"main.js\"), include_bin!(\"static/main.js\")));\n-        try!(write(cx.dst.join(\"main.css\"), include_bin!(\"static/main.css\")));\n-        try!(write(cx.dst.join(\"normalize.css\"),\n-                   include_bin!(\"static/normalize.css\")));\n-        try!(write(cx.dst.join(\"FiraSans-Regular.woff\"),\n-                   include_bin!(\"static/FiraSans-Regular.woff\")));\n-        try!(write(cx.dst.join(\"FiraSans-Medium.woff\"),\n-                   include_bin!(\"static/FiraSans-Medium.woff\")));\n-        try!(write(cx.dst.join(\"Heuristica-Regular.woff\"),\n-                   include_bin!(\"static/Heuristica-Regular.woff\")));\n-        try!(write(cx.dst.join(\"Heuristica-Italic.woff\"),\n-                   include_bin!(\"static/Heuristica-Italic.woff\")));\n-        try!(write(cx.dst.join(\"Heuristica-Bold.woff\"),\n-                   include_bin!(\"static/Heuristica-Bold.woff\")));\n-\n-        fn collect(path: &Path, krate: &str,\n-                   key: &str) -> io::IoResult<Vec<String>> {\n-            let mut ret = Vec::new();\n-            if path.exists() {\n-                for line in BufferedReader::new(File::open(path)).lines() {\n-                    let line = try!(line);\n-                    if !line.as_slice().starts_with(key) {\n-                        continue\n-                    }\n-                    if line.as_slice().starts_with(\n-                            format!(\"{}['{}']\", key, krate).as_slice()) {\n-                        continue\n-                    }\n-                    ret.push(line.to_string());\n+    try!(mkdir(&cx.dst));\n+    let _lock = ::flock::Lock::new(&cx.dst.join(\".lock\"));\n+\n+    // Add all the static files. These may already exist, but we just\n+    // overwrite them anyway to make sure that they're fresh and up-to-date.\n+    try!(write(cx.dst.join(\"jquery.js\"),\n+               include_bin!(\"static/jquery-2.1.0.min.js\")));\n+    try!(write(cx.dst.join(\"main.js\"), include_bin!(\"static/main.js\")));\n+    try!(write(cx.dst.join(\"main.css\"), include_bin!(\"static/main.css\")));\n+    try!(write(cx.dst.join(\"normalize.css\"),\n+               include_bin!(\"static/normalize.css\")));\n+    try!(write(cx.dst.join(\"FiraSans-Regular.woff\"),\n+               include_bin!(\"static/FiraSans-Regular.woff\")));\n+    try!(write(cx.dst.join(\"FiraSans-Medium.woff\"),\n+               include_bin!(\"static/FiraSans-Medium.woff\")));\n+    try!(write(cx.dst.join(\"Heuristica-Regular.woff\"),\n+               include_bin!(\"static/Heuristica-Regular.woff\")));\n+    try!(write(cx.dst.join(\"Heuristica-Italic.woff\"),\n+               include_bin!(\"static/Heuristica-Italic.woff\")));\n+    try!(write(cx.dst.join(\"Heuristica-Bold.woff\"),\n+               include_bin!(\"static/Heuristica-Bold.woff\")));\n+\n+    fn collect(path: &Path, krate: &str,\n+               key: &str) -> io::IoResult<Vec<String>> {\n+        let mut ret = Vec::new();\n+        if path.exists() {\n+            for line in BufferedReader::new(File::open(path)).lines() {\n+                let line = try!(line);\n+                if !line.as_slice().starts_with(key) {\n+                    continue\n                 }\n-            }\n-            return Ok(ret);\n-        }\n-\n-        // Update the search index\n-        let dst = cx.dst.join(\"search-index.js\");\n-        let all_indexes = try!(collect(&dst, krate.name.as_slice(),\n-                                       \"searchIndex\"));\n-        let mut w = try!(File::create(&dst));\n-        try!(writeln!(&mut w, r\"var searchIndex = \\{\\};\"));\n-        try!(writeln!(&mut w, \"{}\", index));\n-        for index in all_indexes.iter() {\n-            try!(writeln!(&mut w, \"{}\", *index));\n-        }\n-        try!(writeln!(&mut w, \"initSearch(searchIndex);\"));\n-\n-        // Update the list of all implementors for traits\n-        let dst = cx.dst.join(\"implementors\");\n-        try!(mkdir(&dst));\n-        for (&did, imps) in cache.implementors.iter() {\n-            if ast_util::is_local(did) { continue }\n-            let &(ref remote_path, remote_item_type) = cache.paths.get(&did);\n-\n-            let mut mydst = dst.clone();\n-            for part in remote_path.slice_to(remote_path.len() - 1).iter() {\n-                mydst.push(part.as_slice());\n-                try!(mkdir(&mydst));\n-            }\n-            mydst.push(format!(\"{}.{}.js\",\n-                               remote_item_type.to_static_str(),\n-                               *remote_path.get(remote_path.len() - 1)));\n-            let all_implementors = try!(collect(&mydst, krate.name.as_slice(),\n-                                                \"implementors\"));\n-\n-            try!(mkdir(&mydst.dir_path()));\n-            let mut f = BufferedWriter::new(try!(File::create(&mydst)));\n-            try!(writeln!(&mut f, r\"(function() \\{var implementors = \\{\\};\"));\n-\n-            for implementor in all_implementors.iter() {\n-                try!(writeln!(&mut f, \"{}\", *implementor));\n-            }\n-\n-            try!(write!(&mut f, r\"implementors['{}'] = \\{\", krate.name));\n-            for imp in imps.iter() {\n-                let &(ref path, item_type) = match *imp {\n-                    PathType(clean::ResolvedPath { did, .. }) => {\n-                        cache.paths.get(&did)\n-                    }\n-                    PathType(..) | OtherType(..) => continue,\n-                };\n-                try!(write!(&mut f, r#\"{}:\"#, *path.get(path.len() - 1)));\n-                try!(write!(&mut f, r#\"\"{}\"#,\n-                            path.slice_to(path.len() - 1).connect(\"/\")));\n-                try!(write!(&mut f, r#\"/{}.{}.html\",\"#,\n-                            item_type.to_static_str(),\n-                            *path.get(path.len() - 1)));\n-            }\n-            try!(writeln!(&mut f, r\"\\};\"));\n-            try!(writeln!(&mut f, \"{}\", r\"\n-                if (window.register_implementors) {\n-                    window.register_implementors(implementors);\n-                } else {\n-                    window.pending_implementors = implementors;\n+                if line.as_slice().starts_with(\n+                        format!(\"{}['{}']\", key, krate).as_slice()) {\n+                    continue\n                 }\n-            \"));\n-            try!(writeln!(&mut f, r\"\\})()\"));\n+                ret.push(line.to_string());\n+            }\n         }\n+        return Ok(ret);\n     }\n \n-    // Render all source files (this may turn into a giant no-op)\n-    {\n-        info!(\"emitting source files\");\n-        let dst = cx.dst.join(\"src\");\n-        try!(mkdir(&dst));\n-        let dst = dst.join(krate.name.as_slice());\n-        try!(mkdir(&dst));\n-        let mut folder = SourceCollector {\n-            dst: dst,\n-            seen: HashSet::new(),\n-            cx: &mut cx,\n-        };\n-        // skip all invalid spans\n-        folder.seen.insert(\"\".to_string());\n-        krate = folder.fold_crate(krate);\n+    // Update the search index\n+    let dst = cx.dst.join(\"search-index.js\");\n+    let all_indexes = try!(collect(&dst, krate.name.as_slice(),\n+                                   \"searchIndex\"));\n+    let mut w = try!(File::create(&dst));\n+    try!(writeln!(&mut w, r\"var searchIndex = \\{\\};\"));\n+    try!(writeln!(&mut w, \"{}\", search_index));\n+    for index in all_indexes.iter() {\n+        try!(writeln!(&mut w, \"{}\", *index));\n     }\n+    try!(writeln!(&mut w, \"initSearch(searchIndex);\"));\n+\n+    // Update the list of all implementors for traits\n+    let dst = cx.dst.join(\"implementors\");\n+    try!(mkdir(&dst));\n+    for (&did, imps) in cache.implementors.iter() {\n+        // Private modules can leak through to this phase of rustdoc, which\n+        // could contain implementations for otherwise private types. In some\n+        // rare cases we could find an implementation for an item which wasn't\n+        // indexed, so we just skip this step in that case.\n+        //\n+        // FIXME: this is a vague explanation for why this can't be a `get`, in\n+        //        theory it should be...\n+        let &(ref remote_path, remote_item_type) = match cache.paths.find(&did) {\n+            Some(p) => p,\n+            None => continue,\n+        };\n \n-    for &(n, ref e) in krate.externs.iter() {\n-        cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n-        let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n-        cache.paths.insert(did, (vec![e.name.to_string()], item_type::Module));\n+        let mut mydst = dst.clone();\n+        for part in remote_path.slice_to(remote_path.len() - 1).iter() {\n+            mydst.push(part.as_slice());\n+            try!(mkdir(&mydst));\n+        }\n+        mydst.push(format!(\"{}.{}.js\",\n+                           remote_item_type.to_static_str(),\n+                           *remote_path.get(remote_path.len() - 1)));\n+        let all_implementors = try!(collect(&mydst, krate.name.as_slice(),\n+                                            \"implementors\"));\n+\n+        try!(mkdir(&mydst.dir_path()));\n+        let mut f = BufferedWriter::new(try!(File::create(&mydst)));\n+        try!(writeln!(&mut f, r\"(function() \\{var implementors = \\{\\};\"));\n+\n+        for implementor in all_implementors.iter() {\n+            try!(write!(&mut f, \"{}\", *implementor));\n+        }\n+\n+        try!(write!(&mut f, r\"implementors['{}'] = [\", krate.name));\n+        for imp in imps.iter() {\n+            try!(write!(&mut f, r#\"\"impl{} {} for {}\",\"#,\n+                        imp.generics, imp.trait_, imp.for_));\n+        }\n+        try!(writeln!(&mut f, r\"];\"));\n+        try!(writeln!(&mut f, \"{}\", r\"\n+            if (window.register_implementors) {\n+                window.register_implementors(implementors);\n+            } else {\n+                window.pending_implementors = implementors;\n+            }\n+        \"));\n+        try!(writeln!(&mut f, r\"\\})()\"));\n     }\n+    Ok(())\n+}\n \n-    // And finally render the whole crate's documentation\n-    cx.krate(krate, cache)\n+fn render_sources(cx: &mut Context,\n+                  krate: clean::Crate) -> io::IoResult<clean::Crate> {\n+    info!(\"emitting source files\");\n+    let dst = cx.dst.join(\"src\");\n+    try!(mkdir(&dst));\n+    let dst = dst.join(krate.name.as_slice());\n+    try!(mkdir(&dst));\n+    let mut folder = SourceCollector {\n+        dst: dst,\n+        seen: HashSet::new(),\n+        cx: cx,\n+    };\n+    // skip all invalid spans\n+    folder.seen.insert(\"\".to_string());\n+    Ok(folder.fold_crate(krate))\n }\n \n /// Writes the entire contents of a string to a destination, not attempting to\n@@ -718,16 +758,11 @@ impl DocFolder for Cache {\n                         let v = self.implementors.find_or_insert_with(did, |_| {\n                             Vec::new()\n                         });\n-                        match i.for_ {\n-                            clean::ResolvedPath{..} => {\n-                                v.unshift(PathType(i.for_.clone()));\n-                            }\n-                            _ => {\n-                                v.push(OtherType(i.generics.clone(),\n-                                                 i.trait_.get_ref().clone(),\n-                                                 i.for_.clone()));\n-                            }\n-                        }\n+                        v.push(Implementor {\n+                            generics: i.generics.clone(),\n+                            trait_: i.trait_.get_ref().clone(),\n+                            for_: i.for_.clone(),\n+                        });\n                     }\n                     Some(..) | None => {}\n                 }\n@@ -803,7 +838,7 @@ impl DocFolder for Cache {\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n-            clean::ForeignFunctionItem(..) => {\n+            clean::ForeignFunctionItem(..) if !self.privmod => {\n                 // Reexported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n                 // however, that a reexported item doesn't show up in the\n@@ -820,7 +855,7 @@ impl DocFolder for Cache {\n             }\n             // link variants to their parent enum because pages aren't emitted\n             // for each variant\n-            clean::VariantItem(..) => {\n+            clean::VariantItem(..) if !self.privmod => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n                 self.paths.insert(item.def_id, (stack, item_type::Enum));\n@@ -852,41 +887,66 @@ impl DocFolder for Cache {\n             Some(item) => {\n                 match item {\n                     clean::Item{ attrs, inner: clean::ImplItem(i), .. } => {\n-                        match i.for_ {\n-                            clean::ResolvedPath { did, .. } => {\n+                        use clean::{Primitive, Vector, ResolvedPath, BorrowedRef};\n+                        use clean::{FixedVector, Slice, Tuple, PrimitiveTuple};\n+\n+                        // extract relevant documentation for this impl\n+                        let dox = match attrs.move_iter().find(|a| {\n+                            match *a {\n+                                clean::NameValue(ref x, _)\n+                                        if \"doc\" == x.as_slice() => {\n+                                    true\n+                                }\n+                                _ => false\n+                            }\n+                        }) {\n+                            Some(clean::NameValue(_, dox)) => Some(dox),\n+                            Some(..) | None => None,\n+                        };\n+\n+                        // Figure out the id of this impl. This may map to a\n+                        // primitive rather than always to a struct/enum.\n+                        let did = match i.for_ {\n+                            ResolvedPath { did, .. } => Some(did),\n+\n+                            // References to primitives are picked up as well to\n+                            // recognize implementations for &str, this may not\n+                            // be necessary in a DST world.\n+                            Primitive(p) |\n+                                BorrowedRef { type_: box Primitive(p), ..} =>\n+                            {\n+                                Some(ast_util::local_def(p.to_node_id()))\n+                            }\n+\n+                            // In a DST world, we may only need\n+                            // Vector/FixedVector, but for now we also pick up\n+                            // borrowed references\n+                            Vector(..) | FixedVector(..) |\n+                                BorrowedRef{ type_: box Vector(..), ..  } |\n+                                BorrowedRef{ type_: box FixedVector(..), .. } =>\n+                            {\n+                                Some(ast_util::local_def(Slice.to_node_id()))\n+                            }\n+\n+                            Tuple(..) => {\n+                                let id = PrimitiveTuple.to_node_id();\n+                                Some(ast_util::local_def(id))\n+                            }\n+\n+                            _ => None,\n+                        };\n+\n+                        match did {\n+                            Some(did) => {\n                                 let v = self.impls.find_or_insert_with(did, |_| {\n                                     Vec::new()\n                                 });\n-                                // extract relevant documentation for this impl\n-                                match attrs.move_iter().find(|a| {\n-                                    match *a {\n-                                        clean::NameValue(ref x, _)\n-                                                if \"doc\" == x.as_slice() => {\n-                                            true\n-                                        }\n-                                        _ => false\n-                                    }\n-                                }) {\n-                                    Some(clean::NameValue(_, dox)) => {\n-                                        v.push((i, Some(dox)));\n-                                    }\n-                                    Some(..) | None => {\n-                                        v.push((i, None));\n-                                    }\n-                                }\n+                                v.push((i, dox));\n                             }\n-                            _ => {}\n+                            None => {}\n                         }\n                         None\n                     }\n-                    // Private modules may survive the strip-private pass if\n-                    // they contain impls for public types, but those will get\n-                    // stripped here\n-                    clean::Item { inner: clean::ModuleItem(ref m),\n-                                  visibility, .. }\n-                            if (m.items.len() == 0 &&\n-                                item.doc_value().is_none()) ||\n-                               visibility != Some(ast::Public) => None,\n \n                     i => Some(i),\n                 }\n@@ -941,16 +1001,13 @@ impl Context {\n     ///\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n     /// parallelization to this function.\n-    fn krate(self, mut krate: clean::Crate, cache: Cache) -> io::IoResult<()> {\n+    fn krate(self, mut krate: clean::Crate) -> io::IoResult<()> {\n         let mut item = match krate.module.take() {\n             Some(i) => i,\n             None => return Ok(())\n         };\n         item.name = Some(krate.name);\n \n-        // using a rwarc makes this parallelizable in the future\n-        cache_key.replace(Some(Arc::new(cache)));\n-\n         let mut work = vec!((self, item));\n         loop {\n             match work.pop() {\n@@ -970,7 +1027,7 @@ impl Context {\n     /// The rendering driver uses this closure to queue up more work.\n     fn item(&mut self, item: clean::Item,\n             f: |&mut Context, clean::Item|) -> io::IoResult<()> {\n-        fn render(w: io::File, cx: &mut Context, it: &clean::Item,\n+        fn render(w: io::File, cx: &Context, it: &clean::Item,\n                   pushname: bool) -> io::IoResult<()> {\n             info!(\"Rendering an item to {}\", w.path().display());\n             // A little unfortunate that this is done like this, but it sure\n@@ -997,16 +1054,42 @@ impl Context {\n             // of the pain by using a buffered writer instead of invoking the\n             // write sycall all the time.\n             let mut writer = BufferedWriter::new(w);\n-            try!(layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n-                                &Sidebar{ cx: cx, item: it },\n-                                &Item{ cx: cx, item: it }));\n+            if !cx.render_redirect_pages {\n+                try!(layout::render(&mut writer, &cx.layout, &page,\n+                                    &Sidebar{ cx: cx, item: it },\n+                                    &Item{ cx: cx, item: it }));\n+            } else {\n+                let mut url = \"../\".repeat(cx.current.len());\n+                match cache_key.get().unwrap().paths.find(&it.def_id) {\n+                    Some(&(ref names, _)) => {\n+                        for name in names.slice_to(names.len() - 1).iter() {\n+                            url.push_str(name.as_slice());\n+                            url.push_str(\"/\");\n+                        }\n+                        url.push_str(item_path(it).as_slice());\n+                        try!(layout::redirect(&mut writer, url.as_slice()));\n+                    }\n+                    None => {}\n+                }\n+            }\n             writer.flush()\n         }\n \n         match item.inner {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n             clean::ModuleItem(..) => {\n+                // Private modules may survive the strip-private pass if they\n+                // contain impls for public types. These modules can also\n+                // contain items such as publicly reexported structures.\n+                //\n+                // External crates will provide links to these structures, so\n+                // these modules are recursed into, but not rendered normally (a\n+                // flag on the context).\n+                if !self.render_redirect_pages {\n+                    self.render_redirect_pages = ignore_private_module(&item);\n+                }\n+\n                 let name = item.name.get_ref().to_string();\n                 let mut item = Some(item);\n                 self.recurse(name, |this| {\n@@ -1120,17 +1203,21 @@ impl<'a> fmt::Show for Item<'a> {\n             clean::TraitItem(..) => try!(write!(fmt, \"Trait \")),\n             clean::StructItem(..) => try!(write!(fmt, \"Struct \")),\n             clean::EnumItem(..) => try!(write!(fmt, \"Enum \")),\n+            clean::PrimitiveItem(..) => try!(write!(fmt, \"Primitive Type \")),\n             _ => {}\n         }\n-        let cur = self.cx.current.as_slice();\n-        let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n-        for (i, component) in cur.iter().enumerate().take(amt) {\n-            let mut trail = String::new();\n-            for _ in range(0, cur.len() - i - 1) {\n-                trail.push_str(\"../\");\n+        let is_primitive = match self.item.inner {\n+            clean::PrimitiveItem(..) => true,\n+            _ => false,\n+        };\n+        if !is_primitive {\n+            let cur = self.cx.current.as_slice();\n+            let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n+            for (i, component) in cur.iter().enumerate().take(amt) {\n+                try!(write!(fmt, \"<a href='{}index.html'>{}</a>::\",\n+                            \"../\".repeat(cur.len() - i - 1),\n+                            component.as_slice()));\n             }\n-            try!(write!(fmt, \"<a href='{}index.html'>{}</a>::\",\n-                        trail, component.as_slice()));\n         }\n         try!(write!(fmt, \"<a class='{}' href=''>{}</a>\",\n                     shortty(self.item), self.item.name.get_ref().as_slice()));\n@@ -1155,7 +1242,7 @@ impl<'a> fmt::Show for Item<'a> {\n         // [src] link in the downstream documentation will actually come back to\n         // this page, and this link will be auto-clicked. The `id` attribute is\n         // used to find the link to auto-click.\n-        if self.cx.include_sources {\n+        if self.cx.include_sources && !is_primitive {\n             match self.href() {\n                 Some(l) => {\n                     try!(write!(fmt,\n@@ -1179,6 +1266,7 @@ impl<'a> fmt::Show for Item<'a> {\n             clean::EnumItem(ref e) => item_enum(fmt, self.item, e),\n             clean::TypedefItem(ref t) => item_typedef(fmt, self.item, t),\n             clean::MacroItem(ref m) => item_macro(fmt, self.item, m),\n+            clean::PrimitiveItem(ref p) => item_primitive(fmt, self.item, p),\n             _ => Ok(())\n         }\n     }\n@@ -1234,8 +1322,9 @@ fn document(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     try!(document(w, item));\n-    debug!(\"{:?}\", items);\n-    let mut indices = Vec::from_fn(items.len(), |i| i);\n+    let mut indices = range(0, items.len()).filter(|i| {\n+        !ignore_private_module(&items[*i])\n+    }).collect::<Vec<uint>>();\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n         if shortty(i1) == shortty(i2) {\n@@ -1251,6 +1340,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             }\n             (&clean::ViewItemItem(..), _) => Less,\n             (_, &clean::ViewItemItem(..)) => Greater,\n+            (&clean::PrimitiveItem(..), _) => Less,\n+            (_, &clean::PrimitiveItem(..)) => Greater,\n             (&clean::ModuleItem(..), _) => Less,\n             (_, &clean::ModuleItem(..)) => Greater,\n             (&clean::MacroItem(..), _) => Less,\n@@ -1275,7 +1366,6 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         }\n     }\n \n-    debug!(\"{:?}\", indices);\n     indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n \n     debug!(\"{:?}\", indices);\n@@ -1306,6 +1396,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 clean::ForeignFunctionItem(..) => (\"ffi-fns\", \"Foreign Functions\"),\n                 clean::ForeignStaticItem(..)   => (\"ffi-statics\", \"Foreign Statics\"),\n                 clean::MacroItem(..)           => (\"macros\", \"Macros\"),\n+                clean::PrimitiveItem(..)       => (\"primitives\", \"Primitive Types\"),\n             };\n             try!(write!(w,\n                         \"<h2 id='{id}' class='section-header'>\\\n@@ -1322,8 +1413,13 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                         if s.len() == 0 { return Ok(()); }\n                         try!(write!(f, \"<code> = </code>\"));\n                         if s.contains(\"\\n\") {\n-                            write!(f, \"<a href='{}'>[definition]</a>\",\n-                                   item.href())\n+                            match item.href() {\n+                                Some(url) => {\n+                                    write!(f, \"<a href='{}'>[definition]</a>\",\n+                                           url)\n+                                }\n+                                None => Ok(()),\n+                            }\n                         } else {\n                             write!(f, \"<code>{}</code>\", s.as_slice())\n                         }\n@@ -1473,34 +1569,33 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"</div>\"));\n     }\n \n-    match cache_key.get().unwrap().implementors.find(&it.def_id) {\n+    let cache = cache_key.get().unwrap();\n+    try!(write!(w, \"\n+        <h2 id='implementors'>Implementors</h2>\n+        <ul class='item-list' id='implementors-list'>\n+    \"));\n+    match cache.implementors.find(&it.def_id) {\n         Some(implementors) => {\n-            try!(write!(w, \"\n-                <h2 id='implementors'>Implementors</h2>\n-                <ul class='item-list' id='implementors-list'>\n-            \"));\n             for i in implementors.iter() {\n-                match *i {\n-                    PathType(ref ty) => {\n-                        try!(write!(w, \"<li><code>{}</code></li>\", *ty));\n-                    }\n-                    OtherType(ref generics, ref trait_, ref for_) => {\n-                        try!(write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n-                                      *generics, *trait_, *for_));\n-                    }\n-                }\n+                try!(writeln!(w, \"<li><code>impl{} {} for {}</code></li>\",\n+                              i.generics, i.trait_, i.for_));\n             }\n-            try!(write!(w, \"</ul>\"));\n-            try!(write!(w, r#\"<script type=\"text/javascript\" async\n-                                      src=\"{}/implementors/{}/{}.{}.js\"></script>\"#,\n-                        cx.current.iter().map(|_| \"..\")\n-                                  .collect::<Vec<&str>>().connect(\"/\"),\n-                        cx.current.connect(\"/\"),\n-                        shortty(it).to_static_str(),\n-                        *it.name.get_ref()));\n         }\n         None => {}\n     }\n+    try!(write!(w, \"</ul>\"));\n+    try!(write!(w, r#\"<script type=\"text/javascript\" async\n+                              src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n+                      </script>\"#,\n+                root_path = Vec::from_elem(cx.current.len(), \"..\").connect(\"/\"),\n+                path = if ast_util::is_local(it.def_id) {\n+                    cx.current.connect(\"/\")\n+                } else {\n+                    let path = cache.external_paths.get(&it.def_id);\n+                    path.slice_to(path.len() - 1).connect(\"/\")\n+                },\n+                ty = shortty(it).to_static_str(),\n+                name = *it.name.get_ref()));\n     Ok(())\n }\n \n@@ -1879,8 +1974,11 @@ impl<'a> fmt::Show for Sidebar<'a> {\n             try!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n             for item in items.iter() {\n                 let curty = shortty(cur).to_static_str();\n-                let class = if cur.name.get_ref() == item &&\n-                               short == curty { \"current\" } else { \"\" };\n+                let class = if cur.name.get_ref() == item && short == curty {\n+                    \"current\"\n+                } else {\n+                    \"\"\n+                };\n                 try!(write!(w, \"<a class='{ty} {class}' href='{curty, select,\n                                 mod{../}\n                                 other{}\n@@ -1911,6 +2009,8 @@ impl<'a> fmt::Show for Sidebar<'a> {\n fn build_sidebar(m: &clean::Module) -> HashMap<String, Vec<String>> {\n     let mut map = HashMap::new();\n     for item in m.items.iter() {\n+        if ignore_private_module(item) { continue }\n+\n         let short = shortty(item).to_static_str();\n         let myname = match item.name {\n             None => continue,\n@@ -1951,3 +2051,20 @@ fn item_macro(w: &mut fmt::Formatter, it: &clean::Item,\n     try!(w.write(highlight::highlight(t.source.as_slice(), Some(\"macro\")).as_bytes()));\n     document(w, it)\n }\n+\n+fn item_primitive(w: &mut fmt::Formatter,\n+                  it: &clean::Item,\n+                  _p: &clean::Primitive) -> fmt::Result {\n+    try!(document(w, it));\n+    render_methods(w, it)\n+}\n+\n+fn ignore_private_module(it: &clean::Item) -> bool {\n+    match it.inner {\n+        clean::ModuleItem(ref m) => {\n+            (m.items.len() == 0 && it.doc_value().is_none()) ||\n+               it.visibility != Some(ast::Public)\n+        }\n+        _ => false,\n+    }\n+}"}, {"sha": "6c9bc793582b66cb23921dc5e7738a60625fcd47", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -527,7 +527,8 @@\n                          \"variant\",\n                          \"ffi\",\n                          \"ffs\",\n-                         \"macro\"];\n+                         \"macro\",\n+                         \"primitive\"];\n \n         function itemTypeFromName(typename) {\n             for (var i = 0; i < itemTypes.length; ++i) {\n@@ -658,15 +659,13 @@\n         var list = $('#implementors-list');\n         var libs = Object.getOwnPropertyNames(imp);\n         for (var i = 0; i < libs.length; i++) {\n-            var structs = Object.getOwnPropertyNames(imp[libs[i]]);\n+            if (libs[i] == currentCrate) continue;\n+            var structs = imp[libs[i]];\n             for (var j = 0; j < structs.length; j++) {\n-                console.log(i, structs[j]);\n-                var path = rootPath + imp[libs[i]][structs[j]];\n-                var klass = path.contains(\"type.\") ? \"type\" : \"struct\";\n-                var link = $('<a>').text(structs[j])\n-                                   .attr('href', path)\n-                                   .attr('class', klass);\n-                var code = $('<code>').append(link);\n+                var code = $('<code>').append(structs[j]);\n+                $.each(code.find('a'), function(idx, a) {\n+                    $(a).attr('href', rootPath + $(a).attr('href'));\n+                });\n                 var li = $('<li>').append(code);\n                 list.append(li);\n             }"}, {"sha": "7176ad1a6c151020c975da1ca637187c1f68ad17", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -67,11 +67,22 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n                 match i.inner {\n                     clean::ImplItem(clean::Impl{\n-                        for_: clean::ResolvedPath{ did, .. }, ..\n+                        for_: clean::ResolvedPath{ did, .. },\n+                        ref trait_, ..\n                     }) => {\n+                        // Impls for stripped types don't need to exist\n                         if self.stripped.contains(&did.node) {\n                             return None;\n                         }\n+                        // Impls of stripped traits also don't need to exist\n+                        match *trait_ {\n+                            Some(clean::ResolvedPath { did, .. }) => {\n+                                if self.stripped.contains(&did.node) {\n+                                    return None\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n                     }\n                     _ => {}\n                 }\n@@ -161,6 +172,9 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n \n             // tymethods/macros have no control over privacy\n             clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n+\n+            // Primitives are never stripped\n+            clean::PrimitiveItem(..) => {}\n         }\n \n         let fastreturn = match i.inner {"}, {"sha": "c1f61de9be2f72c09d7b3335a6e3450dc86c3629", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -79,6 +79,7 @@ pub fn run(input: &str,\n         external_traits: RefCell::new(None),\n         external_typarams: RefCell::new(None),\n         inlined: RefCell::new(None),\n+        populated_crate_impls: RefCell::new(HashSet::new()),\n     };\n     super::ctxtkey.replace(Some(ctx));\n "}, {"sha": "4f565de6791d4f4aa5638c27516eca98444499de", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -82,6 +82,7 @@ pub fn local_id() -> uint {\n     }\n }\n \n+#[doc(hidden)]\n pub trait HomingIO {\n     fn home<'r>(&'r mut self) -> &'r mut HomeHandle;\n "}, {"sha": "bbf1458da216e0852d5c7d11b8f3d3182265ddcd", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -12,6 +12,7 @@\n \n #![allow(missing_doc)]\n #![allow(unsigned_negate)]\n+#![doc(primitive = \"f32\")]\n \n use prelude::*;\n "}, {"sha": "cfa8534160bae9fd6d2c52c1d7a5061a009d6856", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -11,6 +11,7 @@\n //! Operations and constants for 64-bits floats (`f64` type)\n \n #![allow(missing_doc)]\n+#![doc(primitive = \"f64\")]\n \n use prelude::*;\n "}, {"sha": "cfa0662e2256d44421f5933c715b4c2ee1b8b572", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n+#![doc(primitive = \"i16\")]\n+\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;"}, {"sha": "3c656b20ee524c9b6082bed645656ba2e09a4a43", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n+#![doc(primitive = \"i32\")]\n+\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;"}, {"sha": "857f78efc9cfdb648c0ceced28412ac8017b3965", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n+#![doc(primitive = \"i64\")]\n+\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;"}, {"sha": "a939c1d6b76294dc8d8f8c17e7631d21383a0564", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n+#![doc(primitive = \"i8\")]\n+\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;"}, {"sha": "415d11b3145b3bdbae713bbb4a0b9c706d535c76", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for architecture-sized signed integers (`int` type)\n \n+#![doc(primitive = \"int\")]\n+\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;"}, {"sha": "3b018414be2d415ff10b0d2aa6416c43c971d77d", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n+#![doc(primitive = \"u16\")]\n+\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;"}, {"sha": "980129431095d626ef6681e26eb12e81004f4475", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n+#![doc(primitive = \"u32\")]\n+\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;"}, {"sha": "b3a8bfc20df15f5b762ecf7f8831fbbaf89a8fe6", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n+#![doc(primitive = \"u64\")]\n+\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;"}, {"sha": "d72049d253302cc39dcaa14e4001196ed489cf73", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n+#![doc(primitive = \"u8\")]\n+\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;"}, {"sha": "1f43ad8af3398d7bc7a92951156362d3d14f0584", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for architecture-sized unsigned integers (`uint` type)\n \n+#![doc(primitive = \"uint\")]\n+\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;"}, {"sha": "430629a1f88f1709ebbfa3c87f05772e30f8e397", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -97,6 +97,8 @@ There are a number of free functions that create or take vectors, for example:\n \n */\n \n+#![doc(primitive = \"slice\")]\n+\n use mem::transmute;\n use clone::Clone;\n use cmp::{TotalOrd, Ordering, Less, Greater};"}, {"sha": "11b9d0e85ff255ee5966fe9f2fe8812737d7fceb", "filename": "src/libstd/str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -65,6 +65,8 @@ is the same as `&[u8]`.\n \n */\n \n+#![doc(primitive = \"str\")]\n+\n use char::Char;\n use char;\n use clone::Clone;"}, {"sha": "aecfe935d30fba7080e101c4a273ad09403dd4d5", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e0b936900275bcee7ba61894857030c39faec7d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=4e0b936900275bcee7ba61894857030c39faec7d", "patch": "@@ -288,7 +288,7 @@ pub enum SubstructureFields<'a> {\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::Variant,\n-    [field span, field ident, fields])] (i.e. all fields for self are in the\n+    [field span, field ident, fields])] \\(i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n     EnumNonMatching(&'a [(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, @Expr)> )]),"}]}