{"sha": "c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZWQ0ZDdkNDFhOWFjYWFiYWVhYmMwNzk5ZTA0MDMzZmI5NjFhMzA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-02-28T23:25:15Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-03-02T06:40:53Z"}, "message": "librustc: Fix errors arising from the automated `~[T]` conversion", "tree": {"sha": "bf9c97614f4c01edda9ff64f67a18f3037e4487c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf9c97614f4c01edda9ff64f67a18f3037e4487c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "html_url": "https://github.com/rust-lang/rust/commit/c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "198cc3d850136582651489328fec221a2b98bfef", "url": "https://api.github.com/repos/rust-lang/rust/commits/198cc3d850136582651489328fec221a2b98bfef", "html_url": "https://github.com/rust-lang/rust/commit/198cc3d850136582651489328fec221a2b98bfef"}], "stats": {"total": 827, "additions": 528, "deletions": 299}, "files": [{"sha": "4d86848482e8d0f18d55d849d4b5828d1dce4ad7", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -519,7 +519,7 @@ pub fn crate_id_hash(crate_id: &CrateId) -> ~str {\n pub fn build_link_meta(krate: &ast::Crate,\n                        output: &OutputFilenames) -> LinkMeta {\n     let r = LinkMeta {\n-        crateid: find_crate_id(krate.attrs, output),\n+        crateid: find_crate_id(krate.attrs.as_slice(), output),\n         crate_hash: Svh::calculate(krate),\n     };\n     info!(\"{}\", r);"}, {"sha": "88526dd15a9138737b0f56e68cc603cf198c1f3c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -35,6 +35,8 @@ use std::io::fs;\n use std::io::MemReader;\n use std::os;\n use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use collections::{HashMap, HashSet};\n use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n@@ -101,15 +103,15 @@ pub fn default_configuration(sess: Session) ->\n     };\n \n     let mk = attr::mk_name_value_item_str;\n-    return ~[ // Target bindings.\n+    return vec!(// Target bindings.\n          attr::mk_word_item(fam.clone()),\n          mk(InternedString::new(\"target_os\"), tos),\n          mk(InternedString::new(\"target_family\"), fam),\n          mk(InternedString::new(\"target_arch\"), InternedString::new(arch)),\n          mk(InternedString::new(\"target_endian\"), InternedString::new(end)),\n          mk(InternedString::new(\"target_word_size\"),\n-            InternedString::new(wordsz)),\n-    ];\n+            InternedString::new(wordsz))\n+    );\n }\n \n pub fn append_configuration(cfg: &mut ast::CrateConfig,\n@@ -119,8 +121,7 @@ pub fn append_configuration(cfg: &mut ast::CrateConfig,\n     }\n }\n \n-pub fn build_configuration(sess: Session) ->\n-   ast::CrateConfig {\n+pub fn build_configuration(sess: Session) -> ast::CrateConfig {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess);\n@@ -135,15 +136,19 @@ pub fn build_configuration(sess: Session) ->\n     } else {\n         InternedString::new(\"nogc\")\n     });\n-    return vec::append(user_cfg, default_cfg);\n+    return vec_ng::append(user_cfg.move_iter().collect(),\n+                          default_cfg.as_slice());\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n fn parse_cfgspecs(cfgspecs: ~[~str])\n                   -> ast::CrateConfig {\n     cfgspecs.move_iter().map(|s| {\n         let sess = parse::new_parse_sess();\n-        parse::parse_meta_from_source_str(\"cfgspec\".to_str(), s, ~[], sess)\n+        parse::parse_meta_from_source_str(\"cfgspec\".to_str(),\n+                                          s,\n+                                          Vec::new(),\n+                                          sess)\n     }).collect::<ast::CrateConfig>()\n }\n \n@@ -193,7 +198,9 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     let time_passes = sess.time_passes();\n \n     sess.building_library.set(session::building_library(sess.opts, &krate));\n-    sess.crate_types.set(session::collect_crate_types(&sess, krate.attrs));\n+    sess.crate_types.set(session::collect_crate_types(&sess,\n+                                                      krate.attrs\n+                                                           .as_slice()));\n \n     time(time_passes, \"gated feature checking\", (), |_|\n          front::feature_gate::check_crate(sess, &krate));\n@@ -472,7 +479,7 @@ fn write_out_deps(sess: Session,\n                   input: &Input,\n                   outputs: &OutputFilenames,\n                   krate: &ast::Crate) -> io::IoResult<()> {\n-    let id = link::find_crate_id(krate.attrs, outputs);\n+    let id = link::find_crate_id(krate.attrs.as_slice(), outputs);\n \n     let mut out_filenames = ~[];\n     for output_type in sess.opts.output_types.iter() {\n@@ -546,8 +553,11 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n             let loader = &mut Loader::new(sess);\n             phase_2_configure_and_expand(sess, loader, krate)\n         };\n-        let outputs = build_output_filenames(input, outdir, output,\n-                                             expanded_crate.attrs, sess);\n+        let outputs = build_output_filenames(input,\n+                                             outdir,\n+                                             output,\n+                                             expanded_crate.attrs.as_slice(),\n+                                             sess);\n \n         write_out_deps(sess, input, &outputs, &expanded_crate).unwrap();\n \n@@ -1180,7 +1190,7 @@ mod test {\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None);\n         let cfg = build_configuration(sess);\n-        assert!((attr::contains_name(cfg, \"test\")));\n+        assert!((attr::contains_name(cfg.as_slice(), \"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add"}, {"sha": "d404360bf1499445c4b2b48b644c878df377acbc", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -27,6 +27,7 @@ use syntax::{abi, ast, codemap};\n use syntax;\n \n use std::cell::{Cell, RefCell};\n+use std::vec_ng::Vec;\n use collections::{HashMap,HashSet};\n \n pub struct Config {\n@@ -319,7 +320,7 @@ pub fn basic_options() -> @Options {\n         addl_lib_search_paths: @RefCell::new(HashSet::new()),\n         maybe_sysroot: None,\n         target_triple: host_triple(),\n-        cfg: ~[],\n+        cfg: Vec::new(),\n         test: false,\n         parse_only: false,\n         no_trans: false,\n@@ -451,7 +452,8 @@ pub fn building_library(options: &Options, krate: &ast::Crate) -> bool {\n             CrateTypeStaticlib | CrateTypeDylib | CrateTypeRlib => return true\n         }\n     }\n-    match syntax::attr::first_attr_value_str_by_name(krate.attrs, \"crate_type\") {\n+    match syntax::attr::first_attr_value_str_by_name(krate.attrs.as_slice(),\n+                                                     \"crate_type\") {\n         Some(s) => {\n             s.equiv(&(\"lib\")) ||\n             s.equiv(&(\"rlib\")) ||"}, {"sha": "26d72f843515e76e192110936a99b064e5033d8c", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -21,7 +21,7 @@ struct Context<'a> {\n // any items that do not belong in the current configuration\n pub fn strip_unconfigured_items(krate: ast::Crate) -> ast::Crate {\n     let config = krate.config.clone();\n-    strip_items(krate, |attrs| in_cfg(config, attrs))\n+    strip_items(krate, |attrs| in_cfg(config.as_slice(), attrs))\n }\n \n impl<'a> fold::Folder for Context<'a> {\n@@ -117,7 +117,7 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n         ast::ItemEnum(ref def, ref generics) => {\n             let mut variants = def.variants.iter().map(|c| c.clone()).\n             filter_map(|v| {\n-                if !(cx.in_cfg)(v.node.attrs) {\n+                if !(cx.in_cfg)(v.node.attrs.as_slice()) {\n                     None\n                 } else {\n                     Some(match v.node.kind {\n@@ -147,7 +147,7 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n \n fn fold_struct(cx: &Context, def: &ast::StructDef) -> @ast::StructDef {\n     let mut fields = def.fields.iter().map(|c| c.clone()).filter(|m| {\n-        (cx.in_cfg)(m.node.attrs)\n+        (cx.in_cfg)(m.node.attrs.as_slice())\n     });\n     @ast::StructDef {\n         fields: fields.collect(),\n@@ -189,25 +189,25 @@ fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n }\n \n fn item_in_cfg(cx: &Context, item: &ast::Item) -> bool {\n-    return (cx.in_cfg)(item.attrs);\n+    return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n fn foreign_item_in_cfg(cx: &Context, item: &ast::ForeignItem) -> bool {\n-    return (cx.in_cfg)(item.attrs);\n+    return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n fn view_item_in_cfg(cx: &Context, item: &ast::ViewItem) -> bool {\n-    return (cx.in_cfg)(item.attrs);\n+    return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n fn method_in_cfg(cx: &Context, meth: &ast::Method) -> bool {\n-    return (cx.in_cfg)(meth.attrs);\n+    return (cx.in_cfg)(meth.attrs.as_slice());\n }\n \n fn trait_method_in_cfg(cx: &Context, meth: &ast::TraitMethod) -> bool {\n     match *meth {\n-        ast::Required(ref meth) => (cx.in_cfg)(meth.attrs),\n-        ast::Provided(meth) => (cx.in_cfg)(meth.attrs)\n+        ast::Required(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n+        ast::Provided(meth) => (cx.in_cfg)(meth.attrs.as_slice())\n     }\n }\n "}, {"sha": "b0a901f30be650907b42d9de0711ece35b26cd43", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -171,7 +171,7 @@ impl Visitor<()> for Context {\n             }\n \n             ast::ItemForeignMod(..) => {\n-                if attr::contains_name(i.attrs, \"link_args\") {\n+                if attr::contains_name(i.attrs.as_slice(), \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,\n                                       \"the `link_args` attribute is not portable \\\n                                        across platforms, it is recommended to \\\n@@ -180,15 +180,15 @@ impl Visitor<()> for Context {\n             }\n \n             ast::ItemFn(..) => {\n-                if attr::contains_name(i.attrs, \"macro_registrar\") {\n+                if attr::contains_name(i.attrs.as_slice(), \"macro_registrar\") {\n                     self.gate_feature(\"macro_registrar\", i.span,\n                                       \"cross-crate macro exports are \\\n                                        experimental and possibly buggy\");\n                 }\n             }\n \n             ast::ItemStruct(..) => {\n-                if attr::contains_name(i.attrs, \"simd\") {\n+                if attr::contains_name(i.attrs.as_slice(), \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n                 }"}, {"sha": "eec44cc31b1a3fbff25b33af0953d2cfcfd756e4", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -11,7 +11,8 @@\n \n use driver::session::Session;\n \n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n@@ -43,11 +44,11 @@ pub fn maybe_inject_prelude(sess: Session, krate: ast::Crate) -> ast::Crate {\n }\n \n fn use_std(krate: &ast::Crate) -> bool {\n-    !attr::contains_name(krate.attrs, \"no_std\")\n+    !attr::contains_name(krate.attrs.as_slice(), \"no_std\")\n }\n \n fn use_uv(krate: &ast::Crate) -> bool {\n-    !attr::contains_name(krate.attrs, \"no_uv\")\n+    !attr::contains_name(krate.attrs.as_slice(), \"no_uv\")\n }\n \n fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n@@ -72,42 +73,41 @@ pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n \n impl fold::Folder for StandardLibraryInjector {\n     fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n-        let mut vis = ~[ast::ViewItem {\n+        let mut vis = vec!(ast::ViewItem {\n             node: ast::ViewItemExternMod(token::str_to_ident(\"std\"),\n                                          with_version(\"std\"),\n                                          ast::DUMMY_NODE_ID),\n-            attrs: ~[\n+            attrs: vec!(\n                 attr::mk_attr(attr::mk_list_item(\n                         InternedString::new(\"phase\"),\n-                        ~[\n+                        vec!(\n                             attr::mk_word_item(InternedString::new(\"syntax\")),\n                             attr::mk_word_item(InternedString::new(\"link\")\n-                        )]))\n-            ],\n+                        ))))),\n             vis: ast::Inherited,\n             span: DUMMY_SP\n-        }];\n+        });\n \n         if use_uv(&krate) && !self.sess.building_library.get() {\n             vis.push(ast::ViewItem {\n                 node: ast::ViewItemExternMod(token::str_to_ident(\"green\"),\n                                              with_version(\"green\"),\n                                              ast::DUMMY_NODE_ID),\n-                attrs: ~[],\n+                attrs: Vec::new(),\n                 vis: ast::Inherited,\n                 span: DUMMY_SP\n             });\n             vis.push(ast::ViewItem {\n                 node: ast::ViewItemExternMod(token::str_to_ident(\"rustuv\"),\n                                              with_version(\"rustuv\"),\n                                              ast::DUMMY_NODE_ID),\n-                attrs: ~[],\n+                attrs: Vec::new(),\n                 vis: ast::Inherited,\n                 span: DUMMY_SP\n             });\n         }\n \n-        vis.push_all(krate.module.view_items);\n+        vis.push_all_move(krate.module.view_items.clone());\n         let new_module = ast::Mod {\n             view_items: vis,\n             ..krate.module.clone()\n@@ -134,7 +134,7 @@ struct PreludeInjector {\n \n impl fold::Folder for PreludeInjector {\n     fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n-        if !no_prelude(krate.attrs) {\n+        if !no_prelude(krate.attrs.as_slice()) {\n             // only add `use std::prelude::*;` if there wasn't a\n             // `#[no_implicit_prelude];` at the crate level.\n             ast::Crate {\n@@ -147,7 +147,7 @@ impl fold::Folder for PreludeInjector {\n     }\n \n     fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n-        if !no_prelude(item.attrs) {\n+        if !no_prelude(item.attrs.as_slice()) {\n             // only recur if there wasn't `#[no_implicit_prelude];`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree\n@@ -161,7 +161,7 @@ impl fold::Folder for PreludeInjector {\n         let prelude_path = ast::Path {\n             span: DUMMY_SP,\n             global: false,\n-            segments: ~[\n+            segments: vec!(\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"std\"),\n                     lifetimes: opt_vec::Empty,\n@@ -171,19 +171,18 @@ impl fold::Folder for PreludeInjector {\n                     identifier: token::str_to_ident(\"prelude\"),\n                     lifetimes: opt_vec::Empty,\n                     types: opt_vec::Empty,\n-                },\n-            ],\n+                }),\n         };\n \n         let vp = @codemap::dummy_spanned(ast::ViewPathGlob(prelude_path, ast::DUMMY_NODE_ID));\n         let vi2 = ast::ViewItem {\n-            node: ast::ViewItemUse(~[vp]),\n-            attrs: ~[],\n+            node: ast::ViewItemUse(vec!(vp)),\n+            attrs: Vec::new(),\n             vis: ast::Inherited,\n             span: DUMMY_SP,\n         };\n \n-        let vis = vec::append(~[vi2], module.view_items);\n+        let vis = vec_ng::append(vec!(vi2), module.view_items.as_slice());\n \n         // FIXME #2543: Bad copy.\n         let new_module = ast::Mod {"}, {"sha": "333504b7e8247314a2eb8beb853581f5a8e56f4e", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -10,6 +10,8 @@\n \n // Code that generates a test runner to run all the tests in a crate\n \n+#[allow(dead_code)];\n+#[allow(unused_imports)];\n \n use driver::session;\n use front::config;\n@@ -18,6 +20,8 @@ use metadata::creader::Loader;\n \n use std::cell::RefCell;\n use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -57,7 +61,7 @@ pub fn modify_for_testing(sess: session::Session,\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n-    let should_test = attr::contains_name(krate.config, \"test\");\n+    let should_test = attr::contains_name(krate.config.as_slice(), \"test\");\n \n     if should_test {\n         generate_test_harness(sess, krate)\n@@ -189,13 +193,13 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     config::strip_items(krate, |attrs| {\n-        !attr::contains_name(attrs, \"test\") &&\n-        !attr::contains_name(attrs, \"bench\")\n+        !attr::contains_name(attrs.as_slice(), \"test\") &&\n+        !attr::contains_name(attrs.as_slice(), \"bench\")\n     })\n }\n \n fn is_test_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n-    let has_test_attr = attr::contains_name(i.attrs, \"test\");\n+    let has_test_attr = attr::contains_name(i.attrs.as_slice(), \"test\");\n \n     fn has_test_signature(i: @ast::Item) -> bool {\n         match &i.node {\n@@ -224,7 +228,7 @@ fn is_test_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n }\n \n fn is_bench_fn(i: @ast::Item) -> bool {\n-    let has_bench_attr = attr::contains_name(i.attrs, \"bench\");\n+    let has_bench_attr = attr::contains_name(i.attrs.as_slice(), \"bench\");\n \n     fn has_test_signature(i: @ast::Item) -> bool {\n         match i.node {\n@@ -251,20 +255,22 @@ fn is_ignored(cx: &TestCtxt, i: @ast::Item) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         attr.name().equiv(&(\"ignore\")) && match attr.meta_item_list() {\n-            Some(ref cfgs) => attr::test_cfg(cx.config, cfgs.iter().map(|x| *x)),\n+            Some(ref cfgs) => {\n+                attr::test_cfg(cx.config.as_slice(), cfgs.iter().map(|x| *x))\n+            }\n             None => true\n         }\n     })\n }\n \n fn should_fail(i: @ast::Item) -> bool {\n-    attr::contains_name(i.attrs, \"should_fail\")\n+    attr::contains_name(i.attrs.as_slice(), \"should_fail\")\n }\n \n fn add_test_module(cx: &TestCtxt, m: &ast::Mod) -> ast::Mod {\n     let testmod = mk_test_module(cx);\n     ast::Mod {\n-        items: vec::append_one(m.items.clone(), testmod),\n+        items: vec_ng::append_one(m.items.clone(), testmod),\n         ..(*m).clone()\n     }\n }\n@@ -291,26 +297,31 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     let id_test = token::str_to_ident(\"test\");\n     let vi = if cx.is_test_crate {\n         ast::ViewItemUse(\n-            ~[@nospan(ast::ViewPathSimple(id_test,\n-                                          path_node(~[id_test]),\n-                                          ast::DUMMY_NODE_ID))])\n+            vec!(@nospan(ast::ViewPathSimple(id_test,\n+                                             path_node(~[id_test]),\n+                                             ast::DUMMY_NODE_ID))))\n     } else {\n         ast::ViewItemExternMod(id_test,\n                                with_version(\"test\"),\n                                ast::DUMMY_NODE_ID)\n     };\n     ast::ViewItem {\n         node: vi,\n-        attrs: ~[],\n+        attrs: Vec::new(),\n         vis: ast::Inherited,\n         span: DUMMY_SP\n     }\n }\n \n-fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n+#[cfg(stage0)]\n+fn mk_test_module(_: &TestCtxt) -> @ast::Item {\n+    fail!(\"test disabled in this stage due to quasiquoter\")\n+}\n \n+#[cfg(not(stage0))]\n+fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n     // Link to test crate\n-    let view_items = ~[mk_std(cx)];\n+    let view_items = vec!(mk_std(cx));\n \n     // A constant vector of test descriptors.\n     let tests = mk_tests(cx);\n@@ -326,7 +337,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n \n     let testmod = ast::Mod {\n         view_items: view_items,\n-        items: ~[mainfn, tests],\n+        items: vec!(mainfn, tests),\n     };\n     let item_ = ast::ItemMod(testmod);\n \n@@ -337,7 +348,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n \n     let item = ast::Item {\n         ident: token::str_to_ident(\"__test\"),\n-        attrs: ~[resolve_unexported_attr],\n+        attrs: vec!(resolve_unexported_attr),\n         id: ast::DUMMY_NODE_ID,\n         node: item_,\n         vis: ast::Public,\n@@ -377,6 +388,12 @@ fn path_node_global(ids: ~[ast::Ident]) -> ast::Path {\n     }\n }\n \n+#[cfg(stage0)]\n+fn mk_tests(_: &TestCtxt) -> @ast::Item {\n+    fail!(\"tests disabled in this stage due to quasiquoter\")\n+}\n+\n+#[cfg(not(stage0))]\n fn mk_tests(cx: &TestCtxt) -> @ast::Item {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n@@ -389,14 +406,14 @@ fn mk_tests(cx: &TestCtxt) -> @ast::Item {\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n-    match attr::find_crateid(krate.attrs) {\n+    match attr::find_crateid(krate.attrs.as_slice()) {\n         Some(ref s) if \"test\" == s.name => true,\n         _ => false\n     }\n }\n \n fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n-    let mut descs = ~[];\n+    let mut descs = Vec::new();\n     {\n         let testfns = cx.testfns.borrow();\n         debug!(\"building test vector from {} tests\", testfns.get().len());\n@@ -418,6 +435,12 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n     }\n }\n \n+#[cfg(stage0)]\n+fn mk_test_desc_and_fn_rec(_: &TestCtxt, _: &Test) -> @ast::Expr {\n+    fail!(\"tests disabled in this stage due to quasiquoter\")\n+}\n+\n+#[cfg(not(stage0))]\n fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     let span = test.span;\n     let path = test.path.clone();"}, {"sha": "235e1c72455c2693552bfde44000b858821d4108", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -54,6 +54,7 @@ use std::os;\n use std::str;\n use std::task;\n use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::diagnostic::Emitter;\n use syntax::diagnostic;\n@@ -334,19 +335,22 @@ pub fn run_compiler(args: &[~str]) {\n     d::compile_input(sess, cfg, &input, &odir, &ofile);\n }\n \n-fn parse_crate_attrs(sess: session::Session,\n-                     input: &d::Input) -> ~[ast::Attribute] {\n-    match *input {\n+fn parse_crate_attrs(sess: session::Session, input: &d::Input) ->\n+                     ~[ast::Attribute] {\n+    let result = match *input {\n         d::FileInput(ref ifile) => {\n-            parse::parse_crate_attrs_from_file(ifile, ~[], sess.parse_sess)\n+            parse::parse_crate_attrs_from_file(ifile,\n+                                               Vec::new(),\n+                                               sess.parse_sess)\n         }\n         d::StrInput(ref src) => {\n             parse::parse_crate_attrs_from_source_str(d::anon_src(),\n                                                      (*src).clone(),\n-                                                     ~[],\n+                                                     Vec::new(),\n                                                      sess.parse_sess)\n         }\n-    }\n+    };\n+    result.move_iter().collect()\n }\n \n /// Run a procedure which will detect failures in the compiler and print nicer"}, {"sha": "58268d1169b2ffae7ed6533de3e3d9672af1471f", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -23,6 +23,7 @@ use metadata::loader;\n use metadata::loader::Os;\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use collections::HashMap;\n use syntax::ast;\n use syntax::abi;\n@@ -140,7 +141,7 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n     let should_load = i.attrs.iter().all(|attr| {\n         attr.name().get() != \"phase\" ||\n             attr.meta_item_list().map_or(false, |phases| {\n-                attr::contains_name(phases, \"link\")\n+                attr::contains_name(phases.as_slice(), \"link\")\n             })\n     });\n \n@@ -420,8 +421,9 @@ impl CrateLoader for Loader {\n         }\n     }\n \n-    fn get_exported_macros(&mut self, cnum: ast::CrateNum) -> ~[~str] {\n-        csearch::get_exported_macros(self.env.sess.cstore, cnum)\n+    fn get_exported_macros(&mut self, cnum: ast::CrateNum) -> Vec<~str> {\n+        csearch::get_exported_macros(self.env.sess.cstore, cnum).move_iter()\n+                                                                .collect()\n     }\n \n     fn get_registrar_symbol(&mut self, cnum: ast::CrateNum) -> Option<~str> {"}, {"sha": "7e5c20fae65ebe02607e0b0bd5da98928988bdcb", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -1057,7 +1057,7 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n         let subitems = get_meta_items(meta_item_doc);\n-        items.push(attr::mk_list_item(n, subitems));\n+        items.push(attr::mk_list_item(n, subitems.move_iter().collect()));\n         true\n     });\n     return items;"}, {"sha": "3a490845c60989bc32170262d7bdf3aa6f963cc7", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -349,15 +349,18 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_name(ebml_w, variant.node.name.name);\n         encode_parent_item(ebml_w, local_def(id));\n         encode_visibility(ebml_w, variant.node.vis);\n-        encode_attributes(ebml_w, variant.node.attrs);\n+        encode_attributes(ebml_w, variant.node.attrs.as_slice());\n         match variant.node.kind {\n             ast::TupleVariantKind(ref args)\n                     if args.len() > 0 && generics.ty_params.len() == 0 => {\n                 encode_symbol(ecx, ebml_w, variant.node.id);\n             }\n             ast::TupleVariantKind(_) => {},\n             ast::StructVariantKind(def) => {\n-                let idx = encode_info_for_struct(ecx, ebml_w, def.fields, index);\n+                let idx = encode_info_for_struct(ecx,\n+                                                 ebml_w,\n+                                                 def.fields.as_slice(),\n+                                                 index);\n                 encode_struct_fields(ebml_w, def);\n                 let bkts = create_index(idx);\n                 encode_index(ebml_w, bkts, write_i64);\n@@ -516,7 +519,7 @@ fn each_auxiliary_node_id(item: @Item, callback: |NodeId| -> bool) -> bool {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n                 Some(ctor_id) if struct_def.fields.len() > 0 &&\n-                        struct_def.fields[0].node.kind ==\n+                        struct_def.fields.get(0).node.kind ==\n                         ast::UnnamedField => {\n                     continue_ = callback(ctor_id);\n                 }\n@@ -799,13 +802,17 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     let elem = ast_map::PathName(m.ident.name);\n     encode_path(ebml_w, impl_path.chain(Some(elem).move_iter()));\n     match ast_method_opt {\n-        Some(ast_method) => encode_attributes(ebml_w, ast_method.attrs),\n+        Some(ast_method) => {\n+            encode_attributes(ebml_w, ast_method.attrs.as_slice())\n+        }\n         None => ()\n     }\n \n     for &ast_method in ast_method_opt.iter() {\n         let num_params = tpt.generics.type_param_defs().len();\n-        if num_params > 0u || is_default_impl || should_inline(ast_method.attrs) {\n+        if num_params > 0u ||\n+                is_default_impl ||\n+                should_inline(ast_method.attrs.as_slice()) {\n             (ecx.encode_inlined_item)(\n                 ecx, ebml_w, IIMethodRef(local_def(parent_id), false, ast_method));\n         } else {\n@@ -930,8 +937,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ebml_w, item.ident.name);\n         encode_path(ebml_w, path);\n-        encode_attributes(ebml_w, item.attrs);\n-        if tps_len > 0u || should_inline(item.attrs) {\n+        encode_attributes(ebml_w, item.attrs.as_slice());\n+        if tps_len > 0u || should_inline(item.attrs.as_slice()) {\n             (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n         } else {\n             encode_symbol(ecx, ebml_w, item.id);\n@@ -986,7 +993,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(ebml_w, ecx, item.id);\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs);\n+        encode_attributes(ebml_w, item.attrs.as_slice());\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n@@ -1002,7 +1009,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  ebml_w,\n                                  item.id,\n-                                 (*enum_definition).variants,\n+                                 (*enum_definition).variants.as_slice(),\n                                  index,\n                                  generics);\n       }\n@@ -1012,7 +1019,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            the index, and the index needs to be in the item for the\n            class itself */\n         let idx = encode_info_for_struct(ecx, ebml_w,\n-                                         struct_def.fields, index);\n+                                         struct_def.fields.as_slice(), index);\n \n         /* Index the class*/\n         add_to_index(item, ebml_w, index);\n@@ -1025,7 +1032,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         encode_item_variances(ebml_w, ecx, item.id);\n         encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs);\n+        encode_attributes(ebml_w, item.attrs.as_slice());\n         encode_path(ebml_w, path.clone());\n         encode_visibility(ebml_w, vis);\n \n@@ -1065,7 +1072,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(ebml_w, 'i');\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs);\n+        encode_attributes(ebml_w, item.attrs.as_slice());\n         match ty.node {\n             ast::TyPath(ref path, ref bounds, _) if path.segments\n                                                         .len() == 1 => {\n@@ -1097,7 +1104,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let num_implemented_methods = ast_methods.len();\n         for (i, m) in imp.methods.iter().enumerate() {\n             let ast_method = if i < num_implemented_methods {\n-                Some(ast_methods[i])\n+                Some(*ast_methods.get(i))\n             } else { None };\n \n             {\n@@ -1129,7 +1136,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_region_param_defs(ebml_w, trait_def.generics.region_param_defs());\n         encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs);\n+        encode_attributes(ebml_w, item.attrs.as_slice());\n         encode_visibility(ebml_w, vis);\n         for &method_def_id in ty::trait_method_def_ids(tcx, def_id).iter() {\n             ebml_w.start_tag(tag_item_trait_method);\n@@ -1195,14 +1202,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 }\n             }\n \n-            match ms[i] {\n-                Required(ref tm) => {\n-                    encode_attributes(ebml_w, tm.attrs);\n+            match ms.get(i) {\n+                &Required(ref tm) => {\n+                    encode_attributes(ebml_w, tm.attrs.as_slice());\n                     encode_method_sort(ebml_w, 'r');\n                 }\n \n-                Provided(m) => {\n-                    encode_attributes(ebml_w, m.attrs);\n+                &Provided(m) => {\n+                    encode_attributes(ebml_w, m.attrs.as_slice());\n                     // If this is a static method, we've already encoded\n                     // this.\n                     if method_ty.explicit_self != SelfStatic {"}, {"sha": "3fb127f470e972785ba5499395fc53b5cb74c6e5", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -36,6 +36,7 @@ use std::libc;\n use std::cast;\n use std::io::Seek;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n \n use serialize::ebml::reader;\n use serialize::ebml;\n@@ -334,8 +335,8 @@ impl Folder for NestedItemsDropper {\n             }\n         }).collect();\n         let blk_sans_items = ast::P(ast::Block {\n-            view_items: ~[], // I don't know if we need the view_items here,\n-                             // but it doesn't break tests!\n+            view_items: Vec::new(), // I don't know if we need the view_items\n+                                    // here, but it doesn't break tests!\n             stmts: stmts_sans_items,\n             expr: blk.expr,\n             id: blk.id,\n@@ -396,7 +397,10 @@ fn renumber_and_map_ast(xcx: @ExtendedDecodeContext,\n                         map: &ast_map::Map,\n                         path: ~[ast_map::PathElem],\n                         ii: ast::InlinedItem) -> ast::InlinedItem {\n-    ast_map::map_decoded_item(map, path, AstRenumberer { xcx: xcx }, |fld| {\n+    ast_map::map_decoded_item(map,\n+                              path.move_iter().collect(),\n+                              AstRenumberer { xcx: xcx },\n+                              |fld| {\n         match ii {\n             ast::IIItem(i) => {\n                 ast::IIItem(fld.fold_item(i).expect_one(\"expected one item\"))\n@@ -1436,7 +1440,9 @@ trait fake_ext_ctxt {\n \n #[cfg(test)]\n impl fake_ext_ctxt for @parse::ParseSess {\n-    fn cfg(&self) -> ast::CrateConfig { ~[] }\n+    fn cfg(&self) -> ast::CrateConfig {\n+        Vec::new()\n+    }\n     fn parse_sess(&self) -> @parse::ParseSess { *self }\n     fn call_site(&self) -> Span {\n         codemap::Span {"}, {"sha": "3a500a82664dd83df6630e2a786c9b4ed39fa72b", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -831,10 +831,10 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n         this.check_assignment(dest);\n       }\n       ast::ExprCall(f, ref args) => {\n-        this.check_call(expr, Some(f), f.span, *args);\n+        this.check_call(expr, Some(f), f.span, args.as_slice());\n       }\n       ast::ExprMethodCall(_, _, ref args) => {\n-        this.check_call(expr, None, expr.span, *args);\n+        this.check_call(expr, None, expr.span, args.as_slice());\n       }\n       ast::ExprIndex(_, rval) | ast::ExprBinary(_, _, rval)\n       if method_map.get().contains_key(&expr.id) => {"}, {"sha": "b76d4cb85890356b1f0b058368c1e37551f7353b", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -298,7 +298,8 @@ impl CFGBuilder {\n                 let mut guard_exit = discr_exit;\n                 for arm in arms.iter() {\n                     guard_exit = self.opt_expr(arm.guard, guard_exit); // 2\n-                    let pats_exit = self.pats_any(arm.pats, guard_exit); // 3\n+                    let pats_exit = self.pats_any(arm.pats.as_slice(),\n+                                                  guard_exit); // 3\n                     let body_exit = self.block(arm.body, pats_exit);    // 4\n                     self.add_contained_edge(body_exit, expr_exit);       // 5\n                 }\n@@ -348,15 +349,15 @@ impl CFGBuilder {\n             }\n \n             ast::ExprVec(ref elems, _) => {\n-                self.straightline(expr, pred, *elems)\n+                self.straightline(expr, pred, elems.as_slice())\n             }\n \n             ast::ExprCall(func, ref args) => {\n-                self.call(expr, pred, func, *args)\n+                self.call(expr, pred, func, args.as_slice())\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                self.call(expr, pred, args[0], args.slice_from(1))\n+                self.call(expr, pred, *args.get(0), args.slice_from(1))\n             }\n \n             ast::ExprIndex(l, r) |\n@@ -369,7 +370,7 @@ impl CFGBuilder {\n             }\n \n             ast::ExprTup(ref exprs) => {\n-                self.straightline(expr, pred, *exprs)\n+                self.straightline(expr, pred, exprs.as_slice())\n             }\n \n             ast::ExprStruct(_, ref fields, base) => {"}, {"sha": "0ca5ad8b44c5ab0d5979db40b6e65765075ad41c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -76,10 +76,10 @@ fn check_expr(v: &mut CheckMatchVisitor,\n         for arm in arms.iter() {\n             check_legality_of_move_bindings(cx,\n                                             arm.guard.is_some(),\n-                                            arm.pats);\n+                                            arm.pats.as_slice());\n         }\n \n-        check_arms(cx, *arms);\n+        check_arms(cx, arms.as_slice());\n         /* Check for exhaustiveness */\n          // Check for empty enum, because is_useful only works on inhabited\n          // types.\n@@ -104,11 +104,15 @@ fn check_expr(v: &mut CheckMatchVisitor,\n           }\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n-       let arms = arms.iter().filter_map(unguarded_pat).collect::<~[~[@Pat]]>().concat_vec();\n-       if arms.is_empty() {\n+\n+       let pats: ~[@Pat] = arms.iter()\n+                               .filter_map(unguarded_pat)\n+                               .flat_map(|pats| pats.move_iter())\n+                               .collect();\n+       if pats.is_empty() {\n            cx.tcx.sess.span_err(ex.span, \"non-exhaustive patterns\");\n        } else {\n-           check_exhaustive(cx, ex.span, arms);\n+           check_exhaustive(cx, ex.span, pats);\n        }\n      }\n      _ => ()\n@@ -671,7 +675,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                     }\n                     DefVariant(_, id, _) if variant(id) == *ctor_id => {\n                         let args = match args {\n-                            Some(args) => args,\n+                            Some(args) => args.iter().map(|x| *x).collect(),\n                             None => vec::from_elem(arity, wild())\n                         };\n                         Some(vec::append(args, r.tail()))\n@@ -682,7 +686,9 @@ fn specialize(cx: &MatchCheckCtxt,\n                     DefStruct(..) => {\n                         let new_args;\n                         match args {\n-                            Some(args) => new_args = args,\n+                            Some(args) => {\n+                                new_args = args.iter().map(|x| *x).collect()\n+                            }\n                             None => new_args = vec::from_elem(arity, wild())\n                         }\n                         Some(vec::append(new_args, r.tail()))\n@@ -741,7 +747,9 @@ fn specialize(cx: &MatchCheckCtxt,\n                     }\n                 }\n             }\n-            PatTup(args) => Some(vec::append(args, r.tail())),\n+            PatTup(args) => {\n+                Some(vec::append(args.iter().map(|x| *x).collect(), r.tail()))\n+            }\n             PatUniq(a) | PatRegion(a) => {\n                 Some(vec::append(~[a], r.tail()))\n             }\n@@ -804,20 +812,32 @@ fn specialize(cx: &MatchCheckCtxt,\n                     vec(_) => {\n                         let num_elements = before.len() + after.len();\n                         if num_elements < arity && slice.is_some() {\n-                            Some(vec::append(\n-                                [\n-                                    before,\n-                                    vec::from_elem(\n-                                        arity - num_elements, wild()),\n-                                    after\n-                                ].concat_vec(),\n-                                r.tail()\n-                            ))\n+                            let mut result = ~[];\n+                            for pat in before.iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            for _ in iter::range(0, arity - num_elements) {\n+                                result.push(wild())\n+                            }\n+                            for pat in after.iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            for pat in r.tail().iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            Some(result)\n                         } else if num_elements == arity {\n-                            Some(vec::append(\n-                                vec::append(before, after),\n-                                r.tail()\n-                            ))\n+                            let mut result = ~[];\n+                            for pat in before.iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            for pat in after.iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            for pat in r.tail().iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            Some(result)\n                         } else {\n                             None\n                         }"}, {"sha": "cd52f24b8eaeeacfb0b5fa0e46dec0fa280be94b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -117,7 +117,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n                 None => None,\n                 Some(ast_map::NodeItem(it)) => match it.node {\n                     ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n-                        variant_expr(*variants, variant_def.node)\n+                        variant_expr(variants.as_slice(), variant_def.node)\n                     }\n                     _ => None\n                 },\n@@ -144,7 +144,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n                                                         c, d)) {\n             csearch::found(ast::IIItem(item)) => match item.node {\n                 ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n-                    variant_expr(*variants, variant_def.node)\n+                    variant_expr(variants.as_slice(), variant_def.node)\n                 }\n                 _ => None\n             },\n@@ -509,7 +509,9 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n pub fn lit_to_const(lit: &Lit) -> const_val {\n     match lit.node {\n         LitStr(ref s, _) => const_str((*s).clone()),\n-        LitBinary(ref data) => const_binary(data.clone()),\n+        LitBinary(ref data) => {\n+            const_binary(Rc::new(data.borrow().iter().map(|x| *x).collect()))\n+        }\n         LitChar(n) => const_uint(n as u64),\n         LitInt(n, _) => const_int(n),\n         LitUint(n, _) => const_uint(n),"}, {"sha": "1e38f5d9bd7f5861c09a36c5411ca3a15203f767", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -531,7 +531,9 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                     // determine the bits for the body and then union\n                     // them into `in_out`, which reflects all bodies to date\n                     let mut body = guards.to_owned();\n-                    self.walk_pat_alternatives(arm.pats, body, loop_scopes);\n+                    self.walk_pat_alternatives(arm.pats.as_slice(),\n+                                               body,\n+                                               loop_scopes);\n                     self.walk_block(arm.body, body, loop_scopes);\n                     join_bits(&self.dfcx.oper, body, in_out);\n                 }\n@@ -562,7 +564,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             }\n \n             ast::ExprVec(ref exprs, _) => {\n-                self.walk_exprs(*exprs, in_out, loop_scopes)\n+                self.walk_exprs(exprs.as_slice(), in_out, loop_scopes)\n             }\n \n             ast::ExprRepeat(l, r, _) => {\n@@ -579,11 +581,11 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n             ast::ExprCall(f, ref args) => {\n                 self.walk_expr(f, in_out, loop_scopes);\n-                self.walk_call(expr.id, *args, in_out, loop_scopes);\n+                self.walk_call(expr.id, args.as_slice(), in_out, loop_scopes);\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                self.walk_call(expr.id, *args, in_out, loop_scopes);\n+                self.walk_call(expr.id, args.as_slice(), in_out, loop_scopes);\n             }\n \n             ast::ExprIndex(l, r) |\n@@ -596,7 +598,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             }\n \n             ast::ExprTup(ref exprs) => {\n-                self.walk_exprs(*exprs, in_out, loop_scopes);\n+                self.walk_exprs(exprs.as_slice(), in_out, loop_scopes);\n             }\n \n             ast::ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {"}, {"sha": "a0a34ff4f32b53ce0203e0ebb5d3dcde9d9c44b9", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -198,7 +198,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n \n fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     contains_lint(attrs, allow, DEAD_CODE_LINT_STR)\n-    || attr::contains_name(attrs, \"lang\")\n+    || attr::contains_name(attrs.as_slice(), \"lang\")\n }\n \n // This visitor seeds items that\n@@ -220,7 +220,7 @@ struct LifeSeeder {\n \n impl Visitor<()> for LifeSeeder {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n-        if has_allow_dead_code_or_lang_attr(item.attrs) {\n+        if has_allow_dead_code_or_lang_attr(item.attrs.as_slice()) {\n             self.worklist.push(item.id);\n         }\n         match item.node {\n@@ -240,7 +240,7 @@ impl Visitor<()> for LifeSeeder {\n         // Check for method here because methods are not ast::Item\n         match *fk {\n             visit::FkMethod(_, _, method) => {\n-                if has_allow_dead_code_or_lang_attr(method.attrs) {\n+                if has_allow_dead_code_or_lang_attr(method.attrs.as_slice()) {\n                     self.worklist.push(id);\n                 }\n             }"}, {"sha": "2623ddb15297e0672514acc372150dd1ffacbfec", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -54,7 +54,7 @@ pub fn find_entry_point(session: Session, krate: &Crate, ast_map: &ast_map::Map)\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(krate.attrs, \"no_main\") {\n+    if attr::contains_name(krate.attrs.as_slice(), \"no_main\") {\n         session.entry_type.set(Some(session::EntryNone));\n         return\n     }\n@@ -95,7 +95,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n                 });\n             }\n \n-            if attr::contains_name(item.attrs, \"main\") {\n+            if attr::contains_name(item.attrs.as_slice(), \"main\") {\n                 if ctxt.attr_main_fn.is_none() {\n                     ctxt.attr_main_fn = Some((item.id, item.span));\n                 } else {\n@@ -105,7 +105,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n                 }\n             }\n \n-            if attr::contains_name(item.attrs, \"start\") {\n+            if attr::contains_name(item.attrs.as_slice(), \"start\") {\n                 if ctxt.start_fn.is_none() {\n                     ctxt.start_fn = Some((item.id, item.span));\n                 } else {"}, {"sha": "5b7ac704e2a228cec546a39a7eb242197de7426c", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -160,7 +160,7 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n }\n \n fn check_item(cx: &mut Context, item: &Item) {\n-    if !attr::contains_name(item.attrs, \"unsafe_destructor\") {\n+    if !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\") {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), self_type, _) => {\n                 check_impl_of_trait(cx, item, trait_ref, self_type);"}, {"sha": "bedf8ed05290b35f93ddebf9b84505c58f84b16c", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -114,7 +114,7 @@ struct LanguageItemVisitor<'a> {\n \n impl<'a> Visitor<()> for LanguageItemVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n-        match extract(item.attrs) {\n+        match extract(item.attrs.as_slice()) {\n             Some(value) => {\n                 let item_index = self.this.item_refs.find_equiv(&value).map(|x| *x);\n "}, {"sha": "cef32797ca268dca6483bceea88600aa73a43e3c", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 54, "deletions": 27, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -548,7 +548,9 @@ impl<'a> Context<'a> {\n                      attr.name().equiv(&(\"doc\")) &&\n                      match attr.meta_item_list() {\n                          None => false,\n-                         Some(l) => attr::contains_name(l, \"hidden\")\n+                         Some(l) => {\n+                             attr::contains_name(l.as_slice(), \"hidden\")\n+                         }\n                      }\n                  });\n \n@@ -1070,7 +1072,8 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n             if ast_util::is_local(did) {\n                 match cx.tcx.map.get(did.node) {\n                     ast_map::NodeItem(it) => {\n-                        if attr::contains_name(it.attrs, \"must_use\") {\n+                        if attr::contains_name(it.attrs.as_slice(),\n+                                               \"must_use\") {\n                             cx.span_lint(UnusedMustUse, s.span,\n                                          \"unused result which must be used\");\n                             warned = true;\n@@ -1234,8 +1237,9 @@ fn check_unused_mut_pat(cx: &Context, p: &ast::Pat) {\n                       ref path, _) if pat_util::pat_is_binding(cx.tcx.def_map, p)=> {\n             // `let mut _a = 1;` doesn't need a warning.\n             let initial_underscore = if path.segments.len() == 1 {\n-                token::get_ident(path.segments[0].identifier).get()\n-                                                             .starts_with(\"_\")\n+                token::get_ident(path.segments\n+                                     .get(0)\n+                                     .identifier).get().starts_with(\"_\")\n             } else {\n                 cx.tcx.sess.span_bug(p.span,\n                                      \"mutable binding that doesn't consist \\\n@@ -1353,7 +1357,11 @@ fn check_missing_doc_item(cx: &Context, it: &ast::Item) {\n         ast::ItemTrait(..) => \"a trait\",\n         _ => return\n     };\n-    check_missing_doc_attrs(cx, Some(it.id), it.attrs, it.span, desc);\n+    check_missing_doc_attrs(cx,\n+                            Some(it.id),\n+                            it.attrs.as_slice(),\n+                            it.span,\n+                            desc);\n }\n \n fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n@@ -1386,24 +1394,39 @@ fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n             }\n         }\n     }\n-    check_missing_doc_attrs(cx, Some(m.id), m.attrs, m.span, \"a method\");\n+    check_missing_doc_attrs(cx,\n+                            Some(m.id),\n+                            m.attrs.as_slice(),\n+                            m.span,\n+                            \"a method\");\n }\n \n fn check_missing_doc_ty_method(cx: &Context, tm: &ast::TypeMethod) {\n-    check_missing_doc_attrs(cx, Some(tm.id), tm.attrs, tm.span, \"a type method\");\n+    check_missing_doc_attrs(cx,\n+                            Some(tm.id),\n+                            tm.attrs.as_slice(),\n+                            tm.span,\n+                            \"a type method\");\n }\n \n fn check_missing_doc_struct_field(cx: &Context, sf: &ast::StructField) {\n     match sf.node.kind {\n         ast::NamedField(_, vis) if vis != ast::Private =>\n-            check_missing_doc_attrs(cx, Some(cx.cur_struct_def_id), sf.node.attrs,\n-                                    sf.span, \"a struct field\"),\n+            check_missing_doc_attrs(cx,\n+                                    Some(cx.cur_struct_def_id),\n+                                    sf.node.attrs.as_slice(),\n+                                    sf.span,\n+                                    \"a struct field\"),\n         _ => {}\n     }\n }\n \n fn check_missing_doc_variant(cx: &Context, v: &ast::Variant) {\n-    check_missing_doc_attrs(cx, Some(v.node.id), v.node.attrs, v.span, \"a variant\");\n+    check_missing_doc_attrs(cx,\n+                            Some(v.node.id),\n+                            v.node.attrs.as_slice(),\n+                            v.span,\n+                            \"a variant\");\n }\n \n /// Checks for use of items with #[deprecated], #[experimental] and\n@@ -1500,13 +1523,13 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n \n impl<'a> Visitor<()> for Context<'a> {\n     fn visit_item(&mut self, it: &ast::Item, _: ()) {\n-        self.with_lint_attrs(it.attrs, |cx| {\n+        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n             check_item_ctypes(cx, it);\n             check_item_non_camel_case_types(cx, it);\n             check_item_non_uppercase_statics(cx, it);\n             check_heap_item(cx, it);\n             check_missing_doc_item(cx, it);\n-            check_attrs_usage(cx, it.attrs);\n+            check_attrs_usage(cx, it.attrs.as_slice());\n \n             cx.visit_ids(|v| v.visit_item(it, ()));\n \n@@ -1515,15 +1538,15 @@ impl<'a> Visitor<()> for Context<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, it: &ast::ForeignItem, _: ()) {\n-        self.with_lint_attrs(it.attrs, |cx| {\n-            check_attrs_usage(cx, it.attrs);\n+        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+            check_attrs_usage(cx, it.attrs.as_slice());\n             visit::walk_foreign_item(cx, it, ());\n         })\n     }\n \n     fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n-        self.with_lint_attrs(i.attrs, |cx| {\n-            check_attrs_usage(cx, i.attrs);\n+        self.with_lint_attrs(i.attrs.as_slice(), |cx| {\n+            check_attrs_usage(cx, i.attrs.as_slice());\n             visit::walk_view_item(cx, i, ());\n         })\n     }\n@@ -1579,9 +1602,9 @@ impl<'a> Visitor<()> for Context<'a> {\n \n         match *fk {\n             visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(m.attrs, |cx| {\n+                self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n                     check_missing_doc_method(cx, m);\n-                    check_attrs_usage(cx, m.attrs);\n+                    check_attrs_usage(cx, m.attrs.as_slice());\n \n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id, ());\n@@ -1595,9 +1618,9 @@ impl<'a> Visitor<()> for Context<'a> {\n \n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n-        self.with_lint_attrs(t.attrs, |cx| {\n+        self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n             check_missing_doc_ty_method(cx, t);\n-            check_attrs_usage(cx, t.attrs);\n+            check_attrs_usage(cx, t.attrs.as_slice());\n \n             visit::walk_ty_method(cx, t, ());\n         })\n@@ -1616,18 +1639,18 @@ impl<'a> Visitor<()> for Context<'a> {\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n-        self.with_lint_attrs(s.node.attrs, |cx| {\n+        self.with_lint_attrs(s.node.attrs.as_slice(), |cx| {\n             check_missing_doc_struct_field(cx, s);\n-            check_attrs_usage(cx, s.node.attrs);\n+            check_attrs_usage(cx, s.node.attrs.as_slice());\n \n             visit::walk_struct_field(cx, s, ());\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n-        self.with_lint_attrs(v.node.attrs, |cx| {\n+        self.with_lint_attrs(v.node.attrs.as_slice(), |cx| {\n             check_missing_doc_variant(cx, v);\n-            check_attrs_usage(cx, v.node.attrs);\n+            check_attrs_usage(cx, v.node.attrs.as_slice());\n \n             visit::walk_variant(cx, v, g, ());\n         })\n@@ -1675,17 +1698,21 @@ pub fn check_crate(tcx: ty::ctxt,\n     for &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n         cx.set_level(lint, level, CommandLine);\n     }\n-    cx.with_lint_attrs(krate.attrs, |cx| {\n+    cx.with_lint_attrs(krate.attrs.as_slice(), |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;\n             visit::walk_crate(v, krate, ());\n         });\n \n-        check_crate_attrs_usage(cx, krate.attrs);\n+        check_crate_attrs_usage(cx, krate.attrs.as_slice());\n         // since the root module isn't visited as an item (because it isn't an item), warn for it\n         // here.\n-        check_missing_doc_attrs(cx, None, krate.attrs, krate.span, \"crate\");\n+        check_missing_doc_attrs(cx,\n+                                None,\n+                                krate.attrs.as_slice(),\n+                                krate.span,\n+                                \"crate\");\n \n         visit::walk_crate(cx, krate, ());\n     });"}, {"sha": "ab4de1ed71d7977721d1ed7bb18f04e089621a46", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -1129,7 +1129,8 @@ impl Liveness {\n                 let guard_succ =\n                     self.propagate_through_opt_expr(arm.guard, body_succ);\n                 let arm_succ =\n-                    self.define_bindings_in_arm_pats(arm.pats, guard_succ);\n+                    self.define_bindings_in_arm_pats(arm.pats.as_slice(),\n+                                                     guard_succ);\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n             };\n@@ -1194,7 +1195,7 @@ impl Liveness {\n           }\n \n           ExprVec(ref exprs, _) => {\n-            self.propagate_through_exprs(*exprs, succ)\n+            self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n           ExprRepeat(element, count, _) => {\n@@ -1215,7 +1216,7 @@ impl Liveness {\n             let t_ret = ty::ty_fn_ret(ty::expr_ty(self.tcx, f));\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n-            let succ = self.propagate_through_exprs(*args, succ);\n+            let succ = self.propagate_through_exprs(args.as_slice(), succ);\n             self.propagate_through_expr(f, succ)\n           }\n \n@@ -1225,11 +1226,11 @@ impl Liveness {\n             let t_ret = ty::node_id_to_type(self.tcx, expr.id);\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n-            self.propagate_through_exprs(*args, succ)\n+            self.propagate_through_exprs(args.as_slice(), succ)\n           }\n \n           ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(*exprs, succ)\n+            self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n           ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {\n@@ -1493,7 +1494,7 @@ fn check_local(this: &mut Liveness, local: &Local) {\n }\n \n fn check_arm(this: &mut Liveness, arm: &Arm) {\n-    this.arm_pats_bindings(arm.pats, |ln, var, sp, id| {\n+    this.arm_pats_bindings(arm.pats.as_slice(), |ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n     visit::walk_arm(this, arm, ());"}, {"sha": "b96a4e4c1606497df4d2dabc6a20426c896d45c5", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -409,11 +409,11 @@ impl VisitContext {\n                     }\n                 }\n                 self.use_expr(callee, mode);\n-                self.use_fn_args(*args);\n+                self.use_fn_args(args.as_slice());\n             }\n \n             ExprMethodCall(_, _, ref args) => { // callee.m(args)\n-                self.use_fn_args(*args);\n+                self.use_fn_args(args.as_slice());\n             }\n \n             ExprStruct(_, ref fields, opt_with) => {\n@@ -468,7 +468,7 @@ impl VisitContext {\n             }\n \n             ExprTup(ref exprs) => {\n-                self.consume_exprs(*exprs);\n+                self.consume_exprs(exprs.as_slice());\n             }\n \n             ExprIf(cond_expr, then_blk, opt_else_expr) => {\n@@ -497,7 +497,7 @@ impl VisitContext {\n             }\n \n             ExprVec(ref exprs, _) => {\n-                self.consume_exprs(*exprs);\n+                self.consume_exprs(exprs.as_slice());\n             }\n \n             ExprAddrOf(_, base) => {   // &base"}, {"sha": "3d90566ee7931f08c73827f26dad211abe02b355", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -759,7 +759,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         // Do not check privacy inside items with the resolve_unexported\n         // attribute. This is used for the test runner.\n-        if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n+        if attr::contains_name(item.attrs.as_slice(), \"!resolve_unexported\") {\n             return;\n         }\n \n@@ -788,7 +788,8 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n             }\n             ast::ExprMethodCall(ident, _, ref args) => {\n                 // see above\n-                let t = ty::type_autoderef(ty::expr_ty(self.tcx, args[0]));\n+                let t = ty::type_autoderef(ty::expr_ty(self.tcx,\n+                                                       *args.get(0)));\n                 match ty::get(t).sty {\n                     ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n                         match self.method_map.borrow().get().find(&expr.id) {\n@@ -857,7 +858,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                                     lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 };\n-                                let segs = ~[seg];\n+                                let segs = vec!(seg);\n                                 let path = ast::Path {\n                                     global: false,\n                                     span: pid.span,"}, {"sha": "305c60d8215c9f5cfa35e2305f5b9331da44db28", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -44,7 +44,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n fn item_might_be_inlined(item: &ast::Item) -> bool {\n-    if attributes_specify_inlining(item.attrs) {\n+    if attributes_specify_inlining(item.attrs.as_slice()) {\n         return true\n     }\n \n@@ -59,7 +59,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n-    if attributes_specify_inlining(method.attrs) ||\n+    if attributes_specify_inlining(method.attrs.as_slice()) ||\n         generics_require_inlining(&method.generics) {\n         return true\n     }\n@@ -217,7 +217,7 @@ impl ReachableContext {\n             }\n             Some(ast_map::NodeMethod(method)) => {\n                 if generics_require_inlining(&method.generics) ||\n-                        attributes_specify_inlining(method.attrs) {\n+                        attributes_specify_inlining(method.attrs.as_slice()) {\n                     true\n                 } else {\n                     let impl_did = tcx.map.get_parent_did(node_id);\n@@ -324,7 +324,7 @@ impl ReachableContext {\n                     // Statics with insignificant addresses are not reachable\n                     // because they're inlined specially into all other crates.\n                     ast::ItemStatic(..) => {\n-                        if attr::contains_name(item.attrs,\n+                        if attr::contains_name(item.attrs.as_slice(),\n                                                \"address_insignificant\") {\n                             let mut reachable_symbols =\n                                 self.reachable_symbols.borrow_mut();"}, {"sha": "58de36a796825f0bc361526327b8a22c0074bd8d", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -3690,7 +3690,7 @@ impl Resolver {\n                                             generics,\n                                             implemented_traits,\n                                             self_type,\n-                                            *methods);\n+                                            methods.as_slice());\n             }\n \n             ItemTrait(ref generics, ref traits, ref methods) => {\n@@ -3764,7 +3764,7 @@ impl Resolver {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    struct_def.fields);\n+                                    struct_def.fields.as_slice());\n             }\n \n             ItemMod(ref module_) => {\n@@ -4187,8 +4187,10 @@ impl Resolver {\n     // check that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n     fn check_consistent_bindings(&mut self, arm: &Arm) {\n-        if arm.pats.len() == 0 { return; }\n-        let map_0 = self.binding_mode_map(arm.pats[0]);\n+        if arm.pats.len() == 0 {\n+            return\n+        }\n+        let map_0 = self.binding_mode_map(*arm.pats.get(0));\n         for (i, p) in arm.pats.iter().enumerate() {\n             let map_i = self.binding_mode_map(*p);\n \n@@ -4408,7 +4410,7 @@ impl Resolver {\n                     // such a value is simply disallowed (since it's rarely\n                     // what you want).\n \n-                    let ident = path.segments[0].identifier;\n+                    let ident = path.segments.get(0).identifier;\n                     let renamed = mtwt_resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident) {"}, {"sha": "d57557c5f1be36a5c3a35cca214fd3c254cd4a57", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -652,7 +652,9 @@ fn enter_opt<'r,'b>(\n                     // FIXME: Must we clone?\n                     match *subpats {\n                         None => Some(vec::from_elem(variant_size, dummy)),\n-                        _ => (*subpats).clone(),\n+                        Some(ref subpats) => {\n+                            Some((*subpats).iter().map(|x| *x).collect())\n+                        }\n                     }\n                 } else {\n                     None\n@@ -719,16 +721,27 @@ fn enter_opt<'r,'b>(\n                         let this_opt = vec_len(n, vec_len_ge(before.len()),\n                                                (lo, hi));\n                         if opt_eq(tcx, &this_opt, opt) {\n-                            Some(vec::append_one((*before).clone(), slice) +\n-                                    *after)\n+                            let mut new_before = ~[];\n+                            for pat in before.iter() {\n+                                new_before.push(*pat);\n+                            }\n+                            new_before.push(slice);\n+                            for pat in after.iter() {\n+                                new_before.push(*pat);\n+                            }\n+                            Some(new_before)\n                         } else {\n                             None\n                         }\n                     }\n                     None if i >= lo && i <= hi => {\n                         let n = before.len();\n                         if opt_eq(tcx, &vec_len(n, vec_len_eq, (lo,hi)), opt) {\n-                            Some((*before).clone())\n+                            let mut new_before = ~[];\n+                            for pat in before.iter() {\n+                                new_before.push(*pat);\n+                            }\n+                            Some(new_before)\n                         } else {\n                             None\n                         }\n@@ -811,7 +824,13 @@ fn enter_tup<'r,'b>(\n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n-            ast::PatTup(ref elts) => Some((*elts).clone()),\n+            ast::PatTup(ref elts) => {\n+                let mut new_elts = ~[];\n+                for elt in elts.iter() {\n+                    new_elts.push((*elt).clone())\n+                }\n+                Some(new_elts)\n+            }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n@@ -838,7 +857,9 @@ fn enter_tuple_struct<'r,'b>(\n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n-            ast::PatEnum(_, Some(ref elts)) => Some((*elts).clone()),\n+            ast::PatEnum(_, Some(ref elts)) => {\n+                Some(elts.iter().map(|x| (*x)).collect())\n+            }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n@@ -1094,7 +1115,7 @@ fn collect_record_or_struct_fields<'a>(\n           ast::PatStruct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n               ty::ty_struct(..) => {\n-                   extend(&mut fields, *fs);\n+                   extend(&mut fields, fs.as_slice());\n                    found = true;\n               }\n               _ => ()\n@@ -1866,7 +1887,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n     let mut matches = ~[];\n     for arm in arms.iter() {\n         let body = fcx.new_id_block(\"case_body\", arm.body.id);\n-        let bindings_map = create_bindings_map(bcx, arm.pats[0]);\n+        let bindings_map = create_bindings_map(bcx, *arm.pats.get(0));\n         let arm_data = ArmData {\n             bodycx: body,\n             arm: arm,\n@@ -2172,7 +2193,7 @@ fn bind_irrefutable_pat<'a>(\n                                                     val);\n                     for sub_pat in sub_pats.iter() {\n                         for (i, argval) in args.vals.iter().enumerate() {\n-                            bcx = bind_irrefutable_pat(bcx, sub_pat[i],\n+                            bcx = bind_irrefutable_pat(bcx, *sub_pat.get(i),\n                                                        *argval, binding_mode,\n                                                        cleanup_scope);\n                         }"}, {"sha": "130bcb419022478a6e1eb8078c8606929f5a30ac", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -100,13 +100,20 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n \n     let r = ia.asm.get().with_c_str(|a| {\n         constraints.with_c_str(|c| {\n-            InlineAsmCall(bcx, a, c, inputs, output_type, ia.volatile, ia.alignstack, dialect)\n+            InlineAsmCall(bcx,\n+                          a,\n+                          c,\n+                          inputs.as_slice(),\n+                          output_type,\n+                          ia.volatile,\n+                          ia.alignstack,\n+                          dialect)\n         })\n     });\n \n     // Again, based on how many outputs we have\n     if numOutputs == 1 {\n-        Store(bcx, r, outputs[0]);\n+        Store(bcx, r, *outputs.get(0));\n     } else {\n         for (i, o) in outputs.iter().enumerate() {\n             let v = ExtractValue(bcx, r, i);"}, {"sha": "b8301cbc33abfeb5453206686d1dbf4bbae61cdb", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -1473,7 +1473,11 @@ pub fn trans_closure<'a>(ccx: @CrateContext,\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n     let arg_datums = create_datums_for_fn_args(&fcx, arg_tys);\n \n-    bcx = copy_args_to_allocas(&fcx, arg_scope, bcx, decl.inputs, arg_datums);\n+    bcx = copy_args_to_allocas(&fcx,\n+                               arg_scope,\n+                               bcx,\n+                               decl.inputs.as_slice(),\n+                               arg_datums);\n \n     bcx = maybe_load_env(bcx);\n \n@@ -1637,7 +1641,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::EnumDef,\n         match variant.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n-                trans_enum_variant(ccx, id, variant, *args,\n+                trans_enum_variant(ccx, id, variant, args.as_slice(),\n                                    disr_val, None, llfn);\n             }\n             ast::TupleVariantKind(_) => {\n@@ -1667,10 +1671,16 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n         if purity == ast::ExternFn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_rust_fn_with_foreign_abi(\n-                ccx, decl, body, item.attrs, llfndecl, item.id);\n+                ccx, decl, body, item.attrs.as_slice(), llfndecl, item.id);\n         } else if !generics.is_type_parameterized() {\n             let llfn = get_item_val(ccx, item.id);\n-            trans_fn(ccx, decl, body, llfn, None, item.id, item.attrs);\n+            trans_fn(ccx,\n+                     decl,\n+                     body,\n+                     llfn,\n+                     None,\n+                     item.id,\n+                     item.attrs.as_slice());\n         } else {\n             // Be sure to travel more than just one layer deep to catch nested\n             // items in blocks and such.\n@@ -1679,7 +1689,7 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n         }\n       }\n       ast::ItemImpl(ref generics, _, _, ref ms) => {\n-        meth::trans_impl(ccx, item.ident, *ms, generics, item.id);\n+        meth::trans_impl(ccx, item.ident, ms.as_slice(), generics, item.id);\n       }\n       ast::ItemMod(ref m) => {\n         trans_mod(ccx, m);\n@@ -1695,7 +1705,7 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n           consts::trans_const(ccx, m, item.id);\n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n-          if attr::contains_name(item.attrs, \"static_assert\") {\n+          if attr::contains_name(item.attrs.as_slice(), \"static_assert\") {\n               if m == ast::MutMutable {\n                   ccx.sess.span_fatal(expr.span,\n                                       \"cannot have static_assert on a mutable \\\n@@ -1738,7 +1748,7 @@ pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::StructDef) {\n         // otherwise this is a unit-like struct.\n         Some(ctor_id) if struct_def.fields.len() > 0 => {\n             let llfndecl = get_item_val(ccx, ctor_id);\n-            trans_tuple_struct(ccx, struct_def.fields,\n+            trans_tuple_struct(ccx, struct_def.fields.as_slice(),\n                                ctor_id, None, llfndecl);\n         }\n         Some(_) | None => {}\n@@ -1925,7 +1935,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n             let val = match item {\n                 ast_map::NodeItem(i) => {\n                     let ty = ty::node_id_to_type(ccx.tcx, i.id);\n-                    let sym = exported_name(ccx, id, ty, i.attrs);\n+                    let sym = exported_name(ccx, id, ty, i.attrs.as_slice());\n \n                     let v = match i.node {\n                         ast::ItemStatic(_, _, expr) => {\n@@ -1974,7 +1984,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n \n                                 // Apply the `unnamed_addr` attribute if\n                                 // requested\n-                                if attr::contains_name(i.attrs,\n+                                if attr::contains_name(i.attrs.as_slice(),\n                                                        \"address_insignificant\"){\n                                     {\n                                         let reachable =\n@@ -2006,7 +2016,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                                     inlineable = true;\n                                 }\n \n-                                if attr::contains_name(i.attrs, \"thread_local\") {\n+                                if attr::contains_name(i.attrs.as_slice(),\n+                                                       \"thread_local\") {\n                                     lib::llvm::set_thread_local(g, true);\n                                 }\n \n@@ -2034,14 +2045,16 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                            sym,\n                                                                            i.id)\n                             };\n-                            set_llvm_fn_attrs(i.attrs, llfn);\n+                            set_llvm_fn_attrs(i.attrs.as_slice(), llfn);\n                             llfn\n                         }\n \n                         _ => fail!(\"get_item_val: weird result in table\")\n                     };\n \n-                    match attr::first_attr_value_str_by_name(i.attrs, \"link_section\") {\n+                    match attr::first_attr_value_str_by_name(i.attrs\n+                                                              .as_slice(),\n+                                                             \"link_section\") {\n                         Some(sect) => unsafe {\n                             sect.get().with_c_str(|buf| {\n                                 llvm::LLVMSetSection(v, buf);\n@@ -2087,7 +2100,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             // with weak linkage, but if we're building a\n                             // library then we've already declared the crate map\n                             // so use that instead.\n-                            if attr::contains_name(ni.attrs, \"crate_map\") {\n+                            if attr::contains_name(ni.attrs.as_slice(),\n+                                                   \"crate_map\") {\n                                 if ccx.sess.building_library.get() {\n                                     let s = \"_rust_crate_map_toplevel\";\n                                     let g = unsafe {\n@@ -2126,7 +2140,10 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             let ty = ty::node_id_to_type(ccx.tcx, id);\n                             let parent = ccx.tcx.map.get_parent(id);\n                             let enm = ccx.tcx.map.expect_item(parent);\n-                            let sym = exported_name(ccx, id, ty, enm.attrs);\n+                            let sym = exported_name(ccx,\n+                                                    id,\n+                                                    ty,\n+                                                    enm.attrs.as_slice());\n \n                             llfn = match enm.node {\n                                 ast::ItemEnum(_, _) => {\n@@ -2154,7 +2171,11 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             let parent = ccx.tcx.map.get_parent(id);\n                             let struct_item = ccx.tcx.map.expect_item(parent);\n                             let ty = ty::node_id_to_type(ccx.tcx, ctor_id);\n-                            let sym = exported_name(ccx, id, ty, struct_item.attrs);\n+                            let sym = exported_name(ccx,\n+                                                    id,\n+                                                    ty,\n+                                                    struct_item.attrs\n+                                                               .as_slice());\n                             let llfn = register_fn(ccx, struct_item.span,\n                                                    sym, ctor_id, ty);\n                             set_inline_hint(llfn);\n@@ -2190,10 +2211,10 @@ fn register_method(ccx: @CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n \n-    let sym = exported_name(ccx, id, mty, m.attrs);\n+    let sym = exported_name(ccx, id, mty, m.attrs.as_slice());\n \n     let llfn = register_fn(ccx, m.span, sym, id, mty);\n-    set_llvm_fn_attrs(m.attrs, llfn);\n+    set_llvm_fn_attrs(m.attrs.as_slice(), llfn);\n     llfn\n }\n "}, {"sha": "793c70770a932207f32667b2945c5de6a69e8310", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -75,7 +75,9 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n         ast::LitBool(b) => C_bool(b),\n         ast::LitNil => C_nil(),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        ast::LitBinary(ref data) => C_binary_slice(cx, *data.borrow()),\n+        ast::LitBinary(ref data) => {\n+            C_binary_slice(cx, data.borrow().as_slice())\n+        }\n     }\n }\n \n@@ -529,7 +531,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n-              let (vals, inlineable) = map_list(*es);\n+              let (vals, inlineable) = map_list(es.as_slice());\n               (adt::trans_const(cx, repr, 0, vals), inlineable)\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n@@ -564,7 +566,10 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               })\n           }\n           ast::ExprVec(ref es, ast::MutImmutable) => {\n-            let (v, _, inlineable) = const_vec(cx, e, *es, is_local);\n+            let (v, _, inlineable) = const_vec(cx,\n+                                               e,\n+                                               es.as_slice(),\n+                                               is_local);\n             (v, inlineable)\n           }\n           ast::ExprVstore(sub, ast::ExprVstoreSlice) => {\n@@ -576,7 +581,10 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                 }\n               }\n               ast::ExprVec(ref es, ast::MutImmutable) => {\n-                let (cv, llunitty, _) = const_vec(cx, e, *es, is_local);\n+                let (cv, llunitty, _) = const_vec(cx,\n+                                                  e,\n+                                                  es.as_slice(),\n+                                                  is_local);\n                 let llty = val_ty(cv);\n                 let gv = \"const\".with_c_str(|name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n@@ -657,7 +665,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                   Some(ast::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let (arg_vals, inlineable) = map_list(*args);\n+                      let (arg_vals, inlineable) = map_list(args.as_slice());\n                       (adt::trans_const(cx, repr, 0, arg_vals), inlineable)\n                   }\n                   Some(ast::DefVariant(enum_did, variant_did, _)) => {\n@@ -666,7 +674,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                       let vinfo = ty::enum_variant_with_id(cx.tcx,\n                                                            enum_did,\n                                                            variant_did);\n-                      let (arg_vals, inlineable) = map_list(*args);\n+                      let (arg_vals, inlineable) = map_list(args.as_slice());\n                       (adt::trans_const(cx, repr, vinfo.disr_val, arg_vals),\n                        inlineable)\n                   }"}, {"sha": "44e6bbf91cf7c975acfc423024f653d04aa69d44", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -690,7 +690,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     {\n         let mut scope_map = fn_debug_context.scope_map.borrow_mut();\n         populate_scope_map(cx,\n-                           arg_pats,\n+                           arg_pats.as_slice(),\n                            top_level_block,\n                            fn_metadata,\n                            scope_map.get());\n@@ -2650,7 +2650,7 @@ fn populate_scope_map(cx: &CrateContext,\n                 // they all must contain the same binding names\n \n                 for arm_ref in arms.iter() {\n-                    let arm_span = arm_ref.pats[0].span;\n+                    let arm_span = arm_ref.pats.get(0).span;\n \n                     with_new_scope(cx,\n                                    arm_span,"}, {"sha": "b033086125deca3325e29089d894bd98ff3b72a0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -731,13 +731,18 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             controlflow::trans_if(bcx, expr.id, cond, thn, els, dest)\n         }\n         ast::ExprMatch(discr, ref arms) => {\n-            _match::trans_match(bcx, expr, discr, *arms, dest)\n+            _match::trans_match(bcx, expr, discr, arms.as_slice(), dest)\n         }\n         ast::ExprBlock(blk) => {\n             controlflow::trans_block(bcx, blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, base) => {\n-            trans_rec_or_struct(bcx, (*fields), base, expr.span, expr.id, dest)\n+            trans_rec_or_struct(bcx,\n+                                fields.as_slice(),\n+                                base,\n+                                expr.span,\n+                                expr.id,\n+                                dest)\n         }\n         ast::ExprTup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n@@ -777,10 +782,19 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             closure::trans_expr_fn(bcx, sigil, decl, body, expr.id, dest)\n         }\n         ast::ExprCall(f, ref args) => {\n-            callee::trans_call(bcx, expr, f, callee::ArgExprs(*args), expr.id, dest)\n+            callee::trans_call(bcx,\n+                               expr,\n+                               f,\n+                               callee::ArgExprs(args.as_slice()),\n+                               expr.id,\n+                               dest)\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n-            callee::trans_method_call(bcx, expr, args[0], callee::ArgExprs(*args), dest)\n+            callee::trans_method_call(bcx,\n+                                      expr,\n+                                      *args.get(0),\n+                                      callee::ArgExprs(args.as_slice()),\n+                                      dest)\n         }\n         ast::ExprBinary(_, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr"}, {"sha": "7f90810bae48eb66b2bcf2a1adc0f589d18f540c", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -713,7 +713,8 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n // the massive simplifications that have occurred.\n \n pub fn link_name(i: @ast::ForeignItem) -> InternedString {\n-     match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n+     match attr::first_attr_value_str_by_name(i.attrs.as_slice(),\n+                                              \"link_name\") {\n         None => token::get_ident(i.ident),\n         Some(ln) => ln.clone(),\n     }"}, {"sha": "896d97f037405525b63813f7a5a51eec216f0b85", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -74,7 +74,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n                     let g = get_item_val(ccx, item.id);\n                     // see the comment in get_item_val() as to why this check is\n                     // performed here.\n-                    if !attr::contains_name(item.attrs,\n+                    if !attr::contains_name(item.attrs.as_slice(),\n                                             \"address_insignificant\") {\n                         SetLinkage(g, AvailableExternallyLinkage);\n                     }"}, {"sha": "c76d1cbcd20a4a9c97752862420eae64c99fcc52", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -201,7 +201,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                   ..\n               } => {\n                   let d = mk_lldecl();\n-                  set_llvm_fn_attrs(i.attrs, d);\n+                  set_llvm_fn_attrs(i.attrs.as_slice(), d);\n                   trans_fn(ccx, decl, body, d, Some(psubsts), fn_id.node, []);\n                   d\n               }\n@@ -232,7 +232,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                     trans_enum_variant(ccx,\n                                        parent,\n                                        v,\n-                                       (*args).clone(),\n+                                       args.as_slice(),\n                                        this_tv.disr_val,\n                                        Some(psubsts),\n                                        d);\n@@ -244,15 +244,15 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         }\n         ast_map::NodeMethod(mth) => {\n             let d = mk_lldecl();\n-            set_llvm_fn_attrs(mth.attrs, d);\n+            set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n             trans_fn(ccx, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n             d\n         }\n         ast_map::NodeTraitMethod(method) => {\n             match *method {\n                 ast::Provided(mth) => {\n                     let d = mk_lldecl();\n-                    set_llvm_fn_attrs(mth.attrs, d);\n+                    set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n                     trans_fn(ccx, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n                     d\n                 }\n@@ -266,7 +266,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n             let d = mk_lldecl();\n             set_inline_hint(d);\n             base::trans_tuple_struct(ccx,\n-                                     struct_def.fields,\n+                                     struct_def.fields.as_slice(),\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n                                      Some(psubsts),"}, {"sha": "210adc1d0a5ec60c9f67773a7ba06b19baa3da09", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -3730,8 +3730,11 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n                 Some(ast_map::NodeItem(item)) => {\n                     match item.node {\n                         ItemTrait(_, _, ref ms) => {\n-                            let (_, p) = ast_util::split_trait_methods(*ms);\n-                            p.map(|m| method(cx, ast_util::local_def(m.id)))\n+                            let (_, p) =\n+                                ast_util::split_trait_methods(ms.as_slice());\n+                            p.iter()\n+                             .map(|m| method(cx, ast_util::local_def(m.id)))\n+                             .collect()\n                         }\n                         _ => {\n                             cx.sess.bug(format!(\"provided_trait_methods: \\\n@@ -3947,7 +3950,7 @@ impl VariantInfo {\n             },\n             ast::StructVariantKind(ref struct_def) => {\n \n-                let fields: &[StructField] = struct_def.fields;\n+                let fields: &[StructField] = struct_def.fields.as_slice();\n \n                 assert!(fields.len() > 0);\n \n@@ -4280,15 +4283,15 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n            Some(ast_map::NodeItem(i)) => {\n              match i.node {\n                 ast::ItemStruct(struct_def, _) => {\n-                   struct_field_tys(struct_def.fields)\n+                   struct_field_tys(struct_def.fields.as_slice())\n                 }\n                 _ => cx.sess.bug(\"struct ID bound to non-struct\")\n              }\n            }\n            Some(ast_map::NodeVariant(ref variant)) => {\n               match (*variant).node.kind {\n                 ast::StructVariantKind(struct_def) => {\n-                  struct_field_tys(struct_def.fields)\n+                  struct_field_tys(struct_def.fields.as_slice())\n                 }\n                 _ => {\n                   cx.sess.bug(\"struct ID bound to enum variant that isn't \\"}, {"sha": "e1157d29d9d82d1e7f0d052862aef9bf87bbf640", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -60,7 +60,7 @@ use middle::typeck::rscope::{RegionScope};\n use middle::typeck::lookup_def_tcx;\n use util::ppaux::Repr;\n \n-use std::vec;\n+use std::vec_ng::Vec;\n use syntax::abi::AbiSet;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n@@ -186,8 +186,8 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n         }\n \n         match anon_regions {\n-            Ok(v) => opt_vec::from(v),\n-            Err(()) => opt_vec::from(vec::from_fn(expected_num_region_params,\n+            Ok(v) => opt_vec::from(v.move_iter().collect()),\n+            Err(()) => opt_vec::from(Vec::from_fn(expected_num_region_params,\n                                                   |_| ty::ReStatic)) // hokey\n         }\n     };\n@@ -519,7 +519,9 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                            |tmt| ty::mk_rptr(tcx, r, tmt))\n             }\n             ast::TyTup(ref fields) => {\n-                let flds = fields.map(|&t| ast_ty_to_ty(this, rscope, t));\n+                let flds = fields.iter()\n+                                 .map(|&t| ast_ty_to_ty(this, rscope, t))\n+                                 .collect();\n                 ty::mk_tup(tcx, flds)\n             }\n             ast::TyBareFn(ref bf) => {"}, {"sha": "def80e39821ee7bcfb41c425764ee429e74a2306", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -20,6 +20,7 @@ use middle::typeck::infer;\n use middle::typeck::require_same_types;\n \n use collections::{HashMap, HashSet};\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n@@ -40,7 +41,7 @@ pub fn check_match(fcx: @FnCtxt,\n     for arm in arms.iter() {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n-            map: pat_id_map(tcx.def_map, arm.pats[0]),\n+            map: pat_id_map(tcx.def_map, *arm.pats.get(0)),\n         };\n \n         for p in arm.pats.iter() { check_pat(&mut pcx, *p, discrim_ty);}\n@@ -108,13 +109,13 @@ pub struct pat_ctxt {\n }\n \n pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n-                         subpats: &Option<~[@ast::Pat]>, expected: ty::t) {\n+                         subpats: &Option<Vec<@ast::Pat>>, expected: ty::t) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let arg_types;\n+    let arg_types: ~[ty::t];\n     let kind_name;\n \n     // structure_of requires type variables to be resolved.\n@@ -174,8 +175,10 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n                     arg_types = subpats.clone()\n-                                          .unwrap_or_default()\n-                                          .map(|_| ty::mk_err());\n+                                       .unwrap_or_default()\n+                                       .move_iter()\n+                                       .map(|_| ty::mk_err())\n+                                       .collect();\n                 }\n             }\n         }\n@@ -223,8 +226,10 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n             arg_types = subpats.clone()\n-                                  .unwrap_or_default()\n-                                  .map(|_| ty::mk_err());\n+                               .unwrap_or_default()\n+                               .iter()\n+                               .map(|_| ty::mk_err())\n+                               .collect();\n         }\n     }\n \n@@ -509,7 +514,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         }\n       }\n       ast::PatIdent(_, ref path, _) => {\n-        check_pat_variant(pcx, pat, path, &Some(~[]), expected);\n+        check_pat_variant(pcx, pat, path, &Some(Vec::new()), expected);\n       }\n       ast::PatEnum(ref path, ref subpats) => {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n@@ -521,12 +526,18 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         match *structure {\n             ty::ty_struct(cid, ref substs) => {\n                 check_struct_pat(pcx, pat.id, pat.span, expected, path,\n-                                 *fields, etc, cid, substs);\n+                                 fields.as_slice(), etc, cid, substs);\n             }\n             ty::ty_enum(eid, ref substs) => {\n-                check_struct_like_enum_variant_pat(\n-                    pcx, pat.id, pat.span, expected, path, *fields, etc, eid,\n-                    substs);\n+                check_struct_like_enum_variant_pat(pcx,\n+                                                   pat.id,\n+                                                   pat.span,\n+                                                   expected,\n+                                                   path,\n+                                                   fields.as_slice(),\n+                                                   etc,\n+                                                   eid,\n+                                                   substs);\n             }\n             _ => {\n                // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n@@ -540,9 +551,19 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                 let def_map = tcx.def_map.borrow();\n                 match def_map.get().find(&pat.id) {\n                     Some(&ast::DefStruct(supplied_def_id)) => {\n-                         check_struct_pat(pcx, pat.id, pat.span, ty::mk_err(), path, *fields, etc,\n-                         supplied_def_id,\n-                         &ty::substs { self_ty: None, tps: ~[], regions: ty::ErasedRegions} );\n+                         check_struct_pat(pcx,\n+                                          pat.id,\n+                                          pat.span,\n+                                          ty::mk_err(),\n+                                          path,\n+                                          fields.as_slice(),\n+                                          etc,\n+                                          supplied_def_id,\n+                                          &ty::substs {\n+                                              self_ty: None,\n+                                              tps: ~[],\n+                                              regions: ty::ErasedRegions,\n+                                          });\n                     }\n                     _ => () // Error, but we're already in an error case\n                 }"}, {"sha": "6e9cfc9d0d2b0f3b51f58ac1c0c7ff5d02b267cb", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -387,7 +387,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n                 {\n                     let locals = self.fcx.inh.locals.borrow();\n                     debug!(\"Pattern binding {} is assigned to {}\",\n-                           token::get_ident(path.segments[0].identifier),\n+                           token::get_ident(path.segments.get(0).identifier),\n                            self.fcx.infcx().ty_to_str(\n                                locals.get().get_copy(&p.id)));\n                 }\n@@ -554,7 +554,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n-                            enum_definition.variants,\n+                            enum_definition.variants.as_slice(),\n                             it.id);\n       }\n       ast::ItemFn(decl, _, _, _, body) => {\n@@ -588,7 +588,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n                                              &impl_tpt.generics,\n                                              ast_trait_ref,\n                                              impl_trait_ref,\n-                                             *ms);\n+                                             ms.as_slice());\n                 vtable::resolve_impl(ccx.tcx, it, &impl_tpt.generics, impl_trait_ref);\n             }\n             None => { }\n@@ -1397,9 +1397,12 @@ pub fn impl_self_ty(vcx: &VtableContext,\n             n_rps);\n     let tps = vcx.infcx.next_ty_vars(n_tps);\n \n-    let substs = substs {regions: ty::NonerasedRegions(opt_vec::from(rps)),\n-                         self_ty: None,\n-                         tps: tps};\n+    let substs = substs {\n+        regions: ty::NonerasedRegions(opt_vec::from(rps.move_iter()\n+                                                       .collect())),\n+        self_ty: None,\n+        tps: tps,\n+    };\n     let substd_ty = ty::subst(tcx, &substs, raw_ty);\n \n     ty_param_substs_and_ty { substs: substs, ty: substd_ty }\n@@ -1453,7 +1456,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n     // Verify that no lifetimes or type parameters are present anywhere\n     // except the final two elements of the path.\n     for i in range(0, path.segments.len() - 2) {\n-        for lifetime in path.segments[i].lifetimes.iter() {\n+        for lifetime in path.segments.get(i).lifetimes.iter() {\n             function_context.tcx()\n                 .sess\n                 .span_err(lifetime.span,\n@@ -1462,7 +1465,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n             break;\n         }\n \n-        for typ in path.segments[i].types.iter() {\n+        for typ in path.segments.get(i).types.iter() {\n             function_context.tcx()\n                             .sess\n                             .span_err(typ.span,\n@@ -1493,7 +1496,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n                 ast::FromImpl(_) => \"impl\",\n             };\n \n-            let trait_segment = &path.segments[path.segments.len() - 2];\n+            let trait_segment = &path.segments.get(path.segments.len() - 2);\n \n             // Make sure lifetime parameterization agrees with the trait or\n             // implementation type.\n@@ -1567,7 +1570,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n         _ => {\n             // Verify that no lifetimes or type parameters are present on\n             // the penultimate segment of the path.\n-            let segment = &path.segments[path.segments.len() - 2];\n+            let segment = &path.segments.get(path.segments.len() - 2);\n             for lifetime in segment.lifetimes.iter() {\n                 function_context.tcx()\n                     .sess\n@@ -2415,7 +2418,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         // Generate the struct type.\n         let regions = fcx.infcx().next_region_vars(\n             infer::BoundRegionInTypeOrImpl(span),\n-            region_parameter_count);\n+            region_parameter_count).move_iter().collect();\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n             regions: ty::NonerasedRegions(opt_vec::from(regions)),\n@@ -2473,7 +2476,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         // Generate the enum type.\n         let regions = fcx.infcx().next_region_vars(\n             infer::BoundRegionInTypeOrImpl(span),\n-            region_parameter_count);\n+            region_parameter_count).move_iter().collect();\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n             regions: ty::NonerasedRegions(opt_vec::from(regions)),\n@@ -2866,7 +2869,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n       }\n       ast::ExprMatch(discrim, ref arms) => {\n-        _match::check_match(fcx, expr, discrim, *arms);\n+        _match::check_match(fcx, expr, discrim, arms.as_slice());\n       }\n       ast::ExprFnBlock(decl, body) => {\n         check_expr_fn(fcx,\n@@ -2891,7 +2894,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n       ast::ExprCall(f, ref args) => {\n-          check_call(fcx, expr, f, *args);\n+          check_call(fcx, expr, f, args.as_slice());\n           let f_ty = fcx.expr_ty(f);\n           let (args_bot, args_err) = args.iter().fold((false, false),\n              |(rest_bot, rest_err), a| {\n@@ -2907,7 +2910,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n           }\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, *args, *tps);\n+        check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice());\n         let arg_tys = args.map(|a| fcx.expr_ty(*a));\n         let (args_bot, args_err) = arg_tys.iter().fold((false, false),\n              |(rest_bot, rest_err), a| {\n@@ -3093,11 +3096,11 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         match def_map.get().find(&id) {\n             Some(&ast::DefStruct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n-                                         *fields, base_expr);\n+                                         fields.as_slice(), base_expr);\n             }\n             Some(&ast::DefVariant(enum_id, variant_id, _)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, *fields);\n+                                          variant_id, fields.as_slice());\n             }\n             _ => {\n                 tcx.sess.span_bug(path.span,\n@@ -3106,7 +3109,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n       }\n       ast::ExprField(base, field, ref tys) => {\n-        check_field(fcx, expr, base, field.name, *tys);\n+        check_field(fcx, expr, base, field.name, tys.as_slice());\n       }\n       ast::ExprIndex(base, idx) => {\n           check_expr(fcx, base);\n@@ -3670,7 +3673,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n \n         opt_vec::from(fcx.infcx().next_region_vars(\n                 infer::BoundRegionInTypeOrImpl(span),\n-                num_expected_regions))\n+                num_expected_regions).move_iter().collect())\n     };\n     let regions = ty::NonerasedRegions(regions);\n "}, {"sha": "ed03ced5ca066635fdadbfe074246ef0ed365ba1", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -437,13 +437,18 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     match expr.node {\n         ast::ExprCall(callee, ref args) => {\n             constrain_callee(rcx, callee.id, expr, callee);\n-            constrain_call(rcx, Some(callee.id), expr, None, *args, false);\n+            constrain_call(rcx,\n+                           Some(callee.id),\n+                           expr,\n+                           None,\n+                           args.as_slice(),\n+                           false);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprMethodCall(_, _, ref args) => {\n-            constrain_call(rcx, None, expr, Some(args[0]),\n+            constrain_call(rcx, None, expr, Some(*args.get(0)),\n                            args.slice_from(1), false);\n \n             visit::walk_expr(rcx, expr, ());\n@@ -545,7 +550,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMatch(discr, ref arms) => {\n-            link_match(rcx, discr, *arms);\n+            link_match(rcx, discr, arms.as_slice());\n \n             visit::walk_expr(rcx, expr, ());\n         }"}, {"sha": "e47b6e722f386ecd17844cdc2f67777389798fe8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -524,7 +524,8 @@ impl CoherenceChecker {\n         let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n \n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(opt_vec::from(region_parameters)),\n+            regions: ty::NonerasedRegions(opt_vec::from(\n+                             region_parameters.move_iter().collect())),\n             self_ty: None,\n             tps: type_parameters\n         };"}, {"sha": "f7733335c91773c050848dc6a59d982663f8c350", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -149,7 +149,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys = args.map(|va| ccx.to_ty(&rs, va.ty));\n-                ty::mk_ctor_fn(tcx, scope, input_tys, enum_ty)\n+                ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -166,7 +166,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n                 let input_tys = struct_def.fields.map(\n                     |f| ty::node_id_to_type(ccx.tcx, f.node.id));\n-                ty::mk_ctor_fn(tcx, scope, input_tys, enum_ty)\n+                ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n             }\n         };\n \n@@ -235,8 +235,11 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                     let trait_def_id = local_def(trait_id);\n                     let mut trait_method_def_ids = tcx.trait_method_def_ids\n                                                       .borrow_mut();\n-                    trait_method_def_ids.get().insert(trait_def_id,\n-                                                      method_def_ids);\n+                    trait_method_def_ids.get()\n+                                        .insert(trait_def_id,\n+                                                @method_def_ids.iter()\n+                                                               .map(|x| *x)\n+                                                               .collect());\n                 }\n                 _ => {} // Ignore things that aren't traits.\n             }\n@@ -575,7 +578,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n             get_enum_variant_types(ccx,\n                                    tpt.ty,\n-                                   enum_definition.variants,\n+                                   enum_definition.variants.as_slice(),\n                                    generics);\n         },\n         ast::ItemImpl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n@@ -604,7 +607,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             convert_methods(ccx,\n                             ImplContainer(local_def(it.id)),\n-                            *ms,\n+                            ms.as_slice(),\n                             selfty,\n                             &i_ty_generics,\n                             generics,\n@@ -626,11 +629,11 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             // Run convert_methods on the provided methods.\n             let (_, provided_methods) =\n-                split_trait_methods(*trait_methods);\n+                split_trait_methods(trait_methods.as_slice());\n             let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n             convert_methods(ccx,\n                             TraitContainer(local_def(it.id)),\n-                            provided_methods,\n+                            provided_methods.as_slice(),\n                             untransformed_rcvr_ty,\n                             &trait_def.generics,\n                             generics,\n@@ -701,15 +704,19 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                     let mut tcache = tcx.tcache.borrow_mut();\n                     tcache.get().insert(local_def(ctor_id), tpt);\n                 }\n-            } else if struct_def.fields[0].node.kind == ast::UnnamedField {\n+            } else if struct_def.fields.get(0).node.kind ==\n+                    ast::UnnamedField {\n                 // Tuple-like.\n                 let inputs = {\n                     let tcache = tcx.tcache.borrow();\n                     struct_def.fields.map(\n                         |field| tcache.get().get(\n                             &local_def(field.node.id)).ty)\n                 };\n-                let ctor_fn_ty = ty::mk_ctor_fn(tcx, ctor_id, inputs, selfty);\n+                let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n+                                                ctor_id,\n+                                                inputs.as_slice(),\n+                                                selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 {\n                     let mut tcache = tcx.tcache.borrow_mut();\n@@ -802,7 +809,10 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> @ty::TraitDef {\n             let self_ty = ty::mk_self(tcx, def_id);\n             let ty_generics = ty_generics(ccx, generics, 0);\n             let substs = mk_item_substs(ccx, &ty_generics, Some(self_ty));\n-            let bounds = ensure_supertraits(ccx, it.id, it.span, *supertraits);\n+            let bounds = ensure_supertraits(ccx,\n+                                            it.id,\n+                                            it.span,\n+                                            supertraits.as_slice());\n             let trait_ref = @ty::TraitRef {def_id: def_id,\n                                            substs: substs};\n             let trait_def = @ty::TraitDef {generics: ty_generics,\n@@ -980,7 +990,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                     def\n                 }\n             }\n-        }))\n+        }).move_iter().collect())\n     };\n \n     fn compute_bounds(\n@@ -1032,7 +1042,10 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                           -> ty::ty_param_bounds_and_ty {\n     let ty_generics = ty_generics(ccx, ast_generics, 0);\n     let rb = BindingRscope::new(def_id.node);\n-    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, a, None) );\n+    let input_tys = decl.inputs\n+                        .iter()\n+                        .map(|a| ty_of_arg(ccx, &rb, a, None))\n+                        .collect();\n     let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n \n     let t_fn = ty::mk_bare_fn("}, {"sha": "1384bf182a76229dec1d27176272756cfb6cd9d5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ed4d7d41a9acaabaeabc0799e04033fb961a30/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c1ed4d7d41a9acaabaeabc0799e04033fb961a30", "patch": "@@ -603,7 +603,7 @@ impl<T:Repr> Repr for OptVec<T> {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match *self {\n             opt_vec::Empty => ~\"[]\",\n-            opt_vec::Vec(ref v) => repr_vec(tcx, *v)\n+            opt_vec::Vec(ref v) => repr_vec(tcx, v.as_slice())\n         }\n     }\n }"}]}