{"sha": "02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZjUxMjExZWRkYmJhZjZjNmUwMmNlY2M3ODk1N2NlMWQ1YjQ2MDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-08T15:16:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-08T15:16:52Z"}, "message": "auto merge of #13397 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "d7c5f1dbc4a37e473577b39abd56e2f1df433069", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7c5f1dbc4a37e473577b39abd56e2f1df433069"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "html_url": "https://github.com/rust-lang/rust/commit/02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e415c25bcd81dc1f9a5a3d25d9b48ed2d545336b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e415c25bcd81dc1f9a5a3d25d9b48ed2d545336b", "html_url": "https://github.com/rust-lang/rust/commit/e415c25bcd81dc1f9a5a3d25d9b48ed2d545336b"}, {"sha": "da8d4fddc6445c19ad434a1f104c1c310c6c3c34", "url": "https://api.github.com/repos/rust-lang/rust/commits/da8d4fddc6445c19ad434a1f104c1c310c6c3c34", "html_url": "https://github.com/rust-lang/rust/commit/da8d4fddc6445c19ad434a1f104c1c310c6c3c34"}], "stats": {"total": 1251, "additions": 805, "deletions": 446}, "files": [{"sha": "b96d5bee3af9160fae0817e65f5d994f675ddd2a", "filename": "mk/dist.mk", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -203,19 +203,17 @@ distcheck-osx: dist-osx\n # Unix binary installer tarballs\n ######################################################################\n \n-define DEF_INSTALLER\n-\n-$$(eval $$(call DEF_PREPARE,dir-$(1)))\n-\n-dist-install-dir-$(1): PREPARE_HOST=$(1)\n-dist-install-dir-$(1): PREPARE_TARGETS=$(1)\n-dist-install-dir-$(1): PREPARE_DEST_DIR=tmp/dist/$$(PKG_NAME)-$(1)\n-dist-install-dir-$(1): PREPARE_DIR_CMD=$(DEFAULT_PREPARE_DIR_CMD)\n-dist-install-dir-$(1): PREPARE_BIN_CMD=$(DEFAULT_PREPARE_BIN_CMD)\n-dist-install-dir-$(1): PREPARE_LIB_CMD=$(DEFAULT_PREPARE_LIB_CMD)\n-dist-install-dir-$(1): PREPARE_MAN_CMD=$(DEFAULT_PREPARE_MAN_CMD)\n-dist-install-dir-$(1): PREPARE_CLEAN=true\n-dist-install-dir-$(1): prepare-base-dir-$(1) docs compiler-docs\n+define DEF_PREPARE_DIST_DIR\n+\n+dist-install-dir-$(1)$(3): PREPARE_HOST=$(1)\n+dist-install-dir-$(1)$(3): PREPARE_TARGETS=$(2)\n+dist-install-dir-$(1)$(3): PREPARE_DEST_DIR=tmp/dist/$$(PKG_NAME)-$(1)\n+dist-install-dir-$(1)$(3): PREPARE_DIR_CMD=$(DEFAULT_PREPARE_DIR_CMD)\n+dist-install-dir-$(1)$(3): PREPARE_BIN_CMD=$(DEFAULT_PREPARE_BIN_CMD)\n+dist-install-dir-$(1)$(3): PREPARE_LIB_CMD=$(DEFAULT_PREPARE_LIB_CMD)\n+dist-install-dir-$(1)$(3): PREPARE_MAN_CMD=$(DEFAULT_PREPARE_MAN_CMD)\n+dist-install-dir-$(1)$(3): PREPARE_CLEAN=true\n+dist-install-dir-$(1)$(3): prepare-base-dir-$(1) docs compiler-docs\n \t$$(Q)(cd $$(PREPARE_DEST_DIR)/ && find . -type f | sed 's/^\\.\\///') \\\n       > tmp/dist/manifest-$(1).in\n \t$$(Q)mv tmp/dist/manifest-$(1).in $$(PREPARE_DEST_DIR)/$$(CFG_LIBDIR_RELATIVE)/rustlib/manifest.in\n@@ -227,6 +225,16 @@ dist-install-dir-$(1): prepare-base-dir-$(1) docs compiler-docs\n \t$$(Q)cp -r doc $$(PREPARE_DEST_DIR)\n \t$$(Q)$$(PREPARE_BIN_CMD) $$(S)src/etc/install.sh $$(PREPARE_DEST_DIR)\n \n+endef\n+\n+define DEF_INSTALLER\n+\n+$$(eval $$(call DEF_PREPARE,dir-$(1)))\n+\n+$$(eval $$(call DEF_PREPARE_DIST_DIR,$(1),$(1),))\n+\n+$$(eval $$(call DEF_PREPARE_DIST_DIR,$(1),$(CFG_TARGET),-with-target-libs))\n+\n dist/$$(PKG_NAME)-$(1).tar.gz: dist-install-dir-$(1)\n \t@$(call E, build: $$@)\n \t$$(Q)tar -czf dist/$$(PKG_NAME)-$(1).tar.gz -C tmp/dist $$(PKG_NAME)-$(1)"}, {"sha": "206046faeb6ef34e52c9715e4c9ed2d42bd380ef", "filename": "mk/install.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -14,12 +14,12 @@ else\n MAYBE_DISABLE_VERIFY=\n endif\n \n-install: dist-install-dir-$(CFG_BUILD)\n+install: dist-install-dir-$(CFG_BUILD)-with-target-libs\n \t$(Q)sh tmp/dist/$(PKG_NAME)-$(CFG_BUILD)/install.sh --prefix=\"$(DESTDIR)$(CFG_PREFIX)\" --libdir=\"$(DESTDIR)$(CFG_LIBDIR)\" --mandir=\"$(DESTDIR)$(CFG_MANDIR)\" \"$(MAYBE_DISABLE_VERIFY)\"\n # Remove tmp files while we can because they may have been created under sudo\n \t$(Q)rm -R tmp/dist\n \n-uninstall: dist-install-dir-$(CFG_BUILD)\n+uninstall: dist-install-dir-$(CFG_BUILD)-with-target-libs\n \t$(Q)sh tmp/dist/$(PKG_NAME)-$(CFG_BUILD)/install.sh --uninstall --prefix=\"$(DESTDIR)$(CFG_PREFIX)\" --libdir=\"$(DESTDIR)$(CFG_LIBDIR)\" --mandir=\"$(DESTDIR)$(CFG_MANDIR)\"\n # Remove tmp files while we can because they may have been created under sudo\n \t$(Q)rm -R tmp/dist"}, {"sha": "328998ba9fa1c1404e638818c275149266412a50", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -152,7 +152,7 @@ struct Foo {\n }\n \n struct FooClosure<'a> {\n-    myfunc: 'a |int, uint| -> i32\n+    myfunc: |int, uint|: 'a -> i32\n }\n \n fn a(a: int, b: uint) -> i32 {"}, {"sha": "5d505e55d2c91a367f9e2c08b7315ae5ba83f71c", "filename": "src/doc/rust.md", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -432,7 +432,7 @@ operators](#binary-operator-expressions), or [keywords](#keywords).\n ## Paths\n \n ~~~~ {.notrust .ebnf .gram}\n-expr_path : ident [ \"::\" expr_path_tail ] + ;\n+expr_path : [ \"::\" ] ident [ \"::\" expr_path_tail ] + ;\n expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n                | expr_path ;\n \n@@ -475,6 +475,51 @@ let x = id::<int>(10);         // Type arguments used in a call expression\n # }\n ~~~~\n \n+Paths can be denoted with various leading qualifiers to change the meaning of\n+how it is resolved:\n+\n+* Paths starting with `::` are considered to be global paths where the\n+  components of the path start being resolved from the crate root. Each\n+  identifier in the path must resolve to an item.\n+\n+  ```rust\n+  mod a {\n+      pub fn foo() {}\n+  }\n+  mod b {\n+      pub fn foo() {\n+          ::a::foo(); // call a's foo function\n+      }\n+  }\n+  # fn main() {}\n+  ```\n+\n+* Paths starting with the keyword `super` begin resolution relative to the\n+  parent module. Each further identifier must resolve to an item\n+\n+  ```rust\n+  mod a {\n+      pub fn foo() {}\n+  }\n+  mod b {\n+      pub fn foo() {\n+          super::a::foo(); // call a's foo function\n+      }\n+  }\n+  # fn main() {}\n+  ```\n+\n+* Paths starting with the keyword `self` begin resolution relative to the\n+  current module. Each further identifier must resolve to an item.\n+\n+  ```rust\n+  fn foo() {}\n+  fn bar() {\n+      self::foo();\n+  }\n+  # fn main() {}\n+  ```\n+\n # Syntax extensions\n \n A number of minor features of Rust are not central enough to have their own\n@@ -3415,7 +3460,7 @@ fn add(x: int, y: int) -> int {\n \n let mut x = add(5,7);\n \n-type Binop<'a> = 'a |int,int| -> int;\n+type Binop<'a> = |int,int|: 'a -> int;\n let bo: Binop = add;\n x = bo(5,7);\n ~~~~"}, {"sha": "3d44c27a16e6f1e6cdbbb33bf0f705804a2b76d2", "filename": "src/etc/tidy.py", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -65,10 +65,11 @@ def do_license_check(name, contents):\n                 check_tab = False\n             if line.find(linelength_flag) != -1:\n                 check_linelength = False\n-            if line.find(\"// XXX\") != -1:\n-                report_err(\"XXX is no longer necessary, use FIXME\")\n             if line.find(\"TODO\") != -1:\n                 report_err(\"TODO is deprecated; use FIXME\")\n+            match = re.match(r'^.*/(\\*|/!?)\\s*XXX', line)\n+            if match:\n+                report_err(\"XXX is no longer necessary, use FIXME\")\n             match = re.match(r'^.*//\\s*(NOTE.*)$', line)\n             if match:\n                 m = match.group(1)"}, {"sha": "def8f4f35611309c5ed4aadf4365c85ac2af112e", "filename": "src/libcollections/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibcollections%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibcollections%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdeque.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -96,7 +96,7 @@ pub mod bench {\n             map.insert(*k, 1);\n         }\n \n-        rng.shuffle_mut(keys);\n+        rng.shuffle(keys);\n \n         // measure\n         let mut i = 0;"}, {"sha": "753a3120c21575ac2773b47c4c18cb463c913925", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -54,43 +54,49 @@ static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adler32 checksum\n static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n-fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> CVec<u8> {\n+fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     unsafe {\n         let mut outsz : size_t = 0;\n         let res = rustrt::tdefl_compress_mem_to_heap(bytes.as_ptr() as *c_void,\n                                                      bytes.len() as size_t,\n                                                      &mut outsz,\n                                                      flags);\n-        assert!(!res.is_null());\n-        CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res))\n+        if !res.is_null() {\n+            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res)))\n+        } else {\n+            None\n+        }\n     }\n }\n \n-pub fn deflate_bytes(bytes: &[u8]) -> CVec<u8> {\n+pub fn deflate_bytes(bytes: &[u8]) -> Option<CVec<u8>> {\n     deflate_bytes_internal(bytes, LZ_NORM)\n }\n \n-pub fn deflate_bytes_zlib(bytes: &[u8]) -> CVec<u8> {\n+pub fn deflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n     deflate_bytes_internal(bytes, LZ_NORM | TDEFL_WRITE_ZLIB_HEADER)\n }\n \n-fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> CVec<u8> {\n+fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     unsafe {\n         let mut outsz : size_t = 0;\n         let res = rustrt::tinfl_decompress_mem_to_heap(bytes.as_ptr() as *c_void,\n                                                        bytes.len() as size_t,\n                                                        &mut outsz,\n                                                        flags);\n-        assert!(!res.is_null());\n-        CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res))\n+        if !res.is_null() {\n+            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res)))\n+        } else {\n+            None\n+        }\n     }\n }\n \n-pub fn inflate_bytes(bytes: &[u8]) -> CVec<u8> {\n+pub fn inflate_bytes(bytes: &[u8]) -> Option<CVec<u8>> {\n     inflate_bytes_internal(bytes, 0)\n }\n \n-pub fn inflate_bytes_zlib(bytes: &[u8]) -> CVec<u8> {\n+pub fn inflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n     inflate_bytes_internal(bytes, TINFL_FLAG_PARSE_ZLIB_HEADER)\n }\n \n@@ -117,8 +123,8 @@ mod tests {\n             }\n             debug!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());\n-            let cmp = deflate_bytes(input);\n-            let out = inflate_bytes(cmp.as_slice());\n+            let cmp = deflate_bytes(input).expect(\"deflation failed\");\n+            let out = inflate_bytes(cmp.as_slice()).expect(\"inflation failed\");\n             debug!(\"{} bytes deflated to {} ({:.1f}% size)\",\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as f64) / (input.len() as f64)));\n@@ -129,8 +135,8 @@ mod tests {\n     #[test]\n     fn test_zlib_flate() {\n         let bytes = vec!(1, 2, 3, 4, 5);\n-        let deflated = deflate_bytes(bytes.as_slice());\n-        let inflated = inflate_bytes(deflated.as_slice());\n+        let deflated = deflate_bytes(bytes.as_slice()).expect(\"deflation failed\");\n+        let inflated = inflate_bytes(deflated.as_slice()).expect(\"inflation failed\");\n         assert_eq!(inflated.as_slice(), bytes.as_slice());\n     }\n }"}, {"sha": "62b6f71ae9c6b94e0a79305a5b619639cb4b42cb", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -27,7 +27,7 @@ pub fn event_loop() -> ~EventLoop:Send {\n }\n \n struct BasicLoop {\n-    work: ~[proc:Send()],             // pending work\n+    work: ~[proc():Send],             // pending work\n     idle: Option<*mut BasicPausable>, // only one is allowed\n     remotes: ~[(uint, ~Callback:Send)],\n     next_remote: uint,\n@@ -135,7 +135,7 @@ impl EventLoop for BasicLoop {\n         }\n     }\n \n-    fn callback(&mut self, f: proc:Send()) {\n+    fn callback(&mut self, f: proc():Send) {\n         self.work.push(f);\n     }\n "}, {"sha": "6b519fa7b83b7bf674f0a24581455fd126f27d7e", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![feature(globs)]\n-#![crate_id = \"libc#0.10-pre\"]\n+#![crate_id = \"libc#0.11-pre\"]\n #![experimental]\n #![no_std] // we don't need std, and we can't have std, since it doesn't exist\n            // yet. std depends on us.\n@@ -75,8 +75,6 @@\n #![allow(missing_doc)]\n #![allow(uppercase_variables)]\n \n-#![feature(link_args)] // NOTE: remove after stage0\n-\n #[cfg(test)] extern crate std;\n #[cfg(test)] extern crate test;\n #[cfg(test)] extern crate native;\n@@ -199,11 +197,6 @@ pub use funcs::posix88::unistd::{rmdir, unlink, write};\n #[link(name = \"m\")]\n extern {}\n \n-// NOTE: remove this after a stage0 snap\n-#[cfg(stage0, windows)]\n-#[link_args = \"-Wl,--enable-long-section-names\"]\n-extern {}\n-\n /// A wrapper for a nullable pointer. Don't use this except for interacting\n /// with libc. Basically Option, but without the dependance on libstd.\n // If/when libprim happens, this can be removed in favor of that"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/libnative/io/p", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibnative%2Fio%2Fp", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibnative%2Fio%2Fp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fp?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600"}, {"sha": "fcf59cb05485915d22d625131f66a87691818f8d", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -639,7 +639,7 @@ fn spawn_process_os(config: p::ProcessConfig,\n }\n \n #[cfg(unix)]\n-fn with_argv<T>(prog: &str, args: &[~str], cb: proc:(**libc::c_char) -> T) -> T {\n+fn with_argv<T>(prog: &str, args: &[~str], cb: proc(**libc::c_char) -> T) -> T {\n     use std::slice;\n \n     // We can't directly convert `str`s into `*char`s, as someone needs to hold\n@@ -665,7 +665,7 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: proc:(**libc::c_char) -> T) -> T\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: proc:(*c_void) -> T) -> T {\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: proc(*c_void) -> T) -> T {\n     use std::slice;\n \n     // On posixy systems we can pass a char** for envp, which is a"}, {"sha": "871fc94bde46a73641ebf4306ebe81c6ba2372fe", "filename": "src/libnative/task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -50,13 +50,13 @@ fn ops() -> ~Ops {\n }\n \n /// Spawns a function with the default configuration\n-pub fn spawn(f: proc:Send()) {\n+pub fn spawn(f: proc():Send) {\n     spawn_opts(TaskOpts::new(), f)\n }\n \n /// Spawns a new task given the configuration options and a procedure to run\n /// inside the task.\n-pub fn spawn_opts(opts: TaskOpts, f: proc:Send()) {\n+pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n     let TaskOpts {\n         notify_chan, name, stack_size,\n         stderr, stdout,\n@@ -238,7 +238,7 @@ impl rt::Runtime for Ops {\n         }\n     }\n \n-    fn spawn_sibling(~self, mut cur_task: ~Task, opts: TaskOpts, f: proc:Send()) {\n+    fn spawn_sibling(~self, mut cur_task: ~Task, opts: TaskOpts, f: proc():Send) {\n         cur_task.put_runtime(self);\n         Local::put(cur_task);\n "}, {"sha": "b3535a695eaf310e331350dd44c38a2a3e711dce", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -209,8 +209,8 @@ fn ziggurat<R:Rng>(\n             symmetric: bool,\n             x_tab: ziggurat_tables::ZigTable,\n             f_tab: ziggurat_tables::ZigTable,\n-            pdf: 'static |f64| -> f64,\n-            zero_case: 'static |&mut R, f64| -> f64)\n+            pdf: |f64|: 'static -> f64,\n+            zero_case: |&mut R, f64|: 'static -> f64)\n             -> f64 {\n     static SCALE: f64 = (1u64 << 53) as f64;\n     loop {"}, {"sha": "c9e4c81901e7e4721433b0fd9c3ed4625e229b56", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -801,7 +801,7 @@ mod test {\n     #[test]\n     fn test_shuffle() {\n         let mut r = task_rng();\n-        let mut empty: &mut [int] = &mut [];\n+        let empty: &mut [int] = &mut [];\n         r.shuffle(empty);\n         let mut one = [1];\n         r.shuffle(one);"}, {"sha": "0946e375e4f7fc527232b1385b2469f5023e015a", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -945,11 +945,14 @@ fn link_rlib<'a>(sess: &'a Session,\n             let bc_deflated = obj_filename.with_extension(\"bc.deflate\");\n             match fs::File::open(&bc).read_to_end().and_then(|data| {\n                 fs::File::create(&bc_deflated)\n-                    .write(flate::deflate_bytes(data.as_slice()).as_slice())\n+                    .write(match flate::deflate_bytes(data.as_slice()) {\n+                        Some(compressed) => compressed,\n+                        None => sess.fatal(\"failed to compress bytecode\")\n+                     }.as_slice())\n             }) {\n                 Ok(()) => {}\n                 Err(e) => {\n-                    sess.err(format!(\"failed to compress bytecode: {}\", e));\n+                    sess.err(format!(\"failed to write compressed bytecode: {}\", e));\n                     sess.abort_if_errors()\n                 }\n             }"}, {"sha": "8319be02bdbc301705f2ea27564861e38be78715", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -56,7 +56,10 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                       archive.read(format!(\"{}.bc.deflate\", name)));\n         let bc = bc.expect(\"missing compressed bytecode in archive!\");\n         let bc = time(sess.time_passes(), format!(\"inflate {}.bc\", name), (), |_|\n-                      flate::inflate_bytes(bc));\n+                      match flate::inflate_bytes(bc) {\n+                          Some(bc) => bc,\n+                          None => sess.fatal(format!(\"failed to decompress bc of `{}`\", name))\n+                      });\n         let ptr = bc.as_slice().as_ptr();\n         debug!(\"linking {}\", name);\n         time(sess.time_passes(), format!(\"ll link {}\", name), (), |()| unsafe {"}, {"sha": "8a593d5f92a2add5a7ba6a3bae490598f8b76be6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -241,8 +241,6 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                           cfg,\n                                           krate)\n     });\n-    // dump the syntax-time crates\n-    sess.cstore.reset();\n \n     // strip again, in case expansion added anything with a #[cfg].\n     krate = time(time_passes, \"configuration 2\", krate, |krate|"}, {"sha": "703ff51b3b0e206532019cd34e910f195eed35ee", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -13,7 +13,7 @@ use syntax::{ast, fold, attr};\n use syntax::codemap;\n \n struct Context<'a> {\n-    in_cfg: 'a |attrs: &[ast::Attribute]| -> bool,\n+    in_cfg: |attrs: &[ast::Attribute]|: 'a -> bool,\n }\n \n // Support conditional compilation by transforming the AST, stripping out"}, {"sha": "3f72be673e0a00aae4c3f9f1f134dbe52cd97a33", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -364,7 +364,7 @@ fn parse_crate_attrs(sess: &session::Session, input: &d::Input) ->\n ///\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n-pub fn monitor(f: proc:Send()) {\n+pub fn monitor(f: proc():Send) {\n     // FIXME: This is a hack for newsched since it doesn't support split stacks.\n     // rustc needs a lot of stack! When optimizations are disabled, it needs\n     // even *more* stack than usual as well."}, {"sha": "50c22f6bf1bba6985bb1ec82e0f7ecff32bd08c8", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 91, "deletions": 101, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -18,6 +18,7 @@ use driver::{driver, session};\n use driver::session::Session;\n use metadata::csearch;\n use metadata::cstore;\n+use metadata::cstore::CStore;\n use metadata::decoder;\n use metadata::loader;\n use metadata::loader::Os;\n@@ -38,6 +39,13 @@ use syntax::parse::token;\n use syntax::crateid::CrateId;\n use syntax::visit;\n \n+struct Env<'a> {\n+    sess: &'a Session,\n+    os: loader::Os,\n+    next_crate_num: ast::CrateNum,\n+    intr: Rc<IdentInterner>\n+}\n+\n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n pub fn read_crates(sess: &Session,\n@@ -47,16 +55,13 @@ pub fn read_crates(sess: &Session,\n     let mut e = Env {\n         sess: sess,\n         os: os,\n-        crate_cache: @RefCell::new(Vec::new()),\n-        next_crate_num: 1,\n+        next_crate_num: sess.cstore.next_crate_num(),\n         intr: intr\n     };\n     visit_crate(&e, krate);\n     visit::walk_crate(&mut e, krate, ());\n-    dump_crates(e.crate_cache.borrow().as_slice());\n-    warn_if_multiple_versions(&mut e,\n-                              sess.diagnostic(),\n-                              e.crate_cache.borrow().as_slice());\n+    dump_crates(&sess.cstore);\n+    warn_if_multiple_versions(sess.diagnostic(), &sess.cstore)\n }\n \n impl<'a> visit::Visitor<()> for Env<'a> {\n@@ -70,55 +75,36 @@ impl<'a> visit::Visitor<()> for Env<'a> {\n     }\n }\n \n-#[deriving(Clone)]\n-struct cache_entry {\n-    cnum: ast::CrateNum,\n-    span: Span,\n-    hash: Svh,\n-    crate_id: CrateId,\n-}\n-\n-fn dump_crates(crate_cache: &[cache_entry]) {\n+fn dump_crates(cstore: &CStore) {\n     debug!(\"resolved crates:\");\n-    for entry in crate_cache.iter() {\n-        debug!(\"cnum: {:?}\", entry.cnum);\n-        debug!(\"span: {:?}\", entry.span);\n-        debug!(\"hash: {:?}\", entry.hash);\n-    }\n+    cstore.iter_crate_data(|_, data| {\n+        debug!(\"crate_id: {}\", data.crate_id());\n+        debug!(\"  cnum: {}\", data.cnum);\n+        debug!(\"  hash: {}\", data.hash());\n+    })\n }\n \n-fn warn_if_multiple_versions(e: &mut Env,\n-                             diag: &SpanHandler,\n-                             crate_cache: &[cache_entry]) {\n-    if crate_cache.len() != 0u {\n-        let name = crate_cache[crate_cache.len() - 1].crate_id.name.clone();\n-\n-        let (matches, non_matches) = crate_cache.partitioned(|entry|\n-            name == entry.crate_id.name);\n+fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n+    let mut map = HashMap::new();\n \n-        assert!(!matches.is_empty());\n+    cstore.iter_crate_data(|cnum, data| {\n+        let crateid = data.crate_id();\n+        let key = (crateid.name.clone(), crateid.path.clone());\n+        map.find_or_insert_with(key, |_| Vec::new()).push(cnum);\n+    });\n \n-        if matches.len() != 1u {\n-            diag.handler().warn(\n-                format!(\"using multiple versions of crate `{}`\", name));\n-            for match_ in matches.iter() {\n-                diag.span_note(match_.span, \"used here\");\n-                loader::note_crateid_attr(diag, &match_.crate_id);\n-            }\n+    for ((name, _), dupes) in map.move_iter() {\n+        if dupes.len() == 1 { continue }\n+        diag.handler().warn(\n+            format!(\"using multiple versions of crate `{}`\", name));\n+        for dupe in dupes.move_iter() {\n+            let data = cstore.get_crate_data(dupe);\n+            diag.span_note(data.span, \"used here\");\n+            loader::note_crateid_attr(diag, &data.crate_id());\n         }\n-\n-        warn_if_multiple_versions(e, diag, non_matches);\n     }\n }\n \n-struct Env<'a> {\n-    sess: &'a Session,\n-    os: loader::Os,\n-    crate_cache: @RefCell<Vec<cache_entry>>,\n-    next_crate_num: ast::CrateNum,\n-    intr: Rc<IdentInterner>\n-}\n-\n fn visit_crate(e: &Env, c: &ast::Crate) {\n     for a in c.attrs.iter().filter(|m| m.name().equiv(&(\"link_args\"))) {\n         match a.value_str() {\n@@ -128,22 +114,25 @@ fn visit_crate(e: &Env, c: &ast::Crate) {\n     }\n }\n \n-fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n-    let should_load = i.attrs.iter().all(|attr| {\n+fn should_link(i: &ast::ViewItem) -> bool {\n+    i.attrs.iter().all(|attr| {\n         attr.name().get() != \"phase\" ||\n             attr.meta_item_list().map_or(false, |phases| {\n                 attr::contains_name(phases.as_slice(), \"link\")\n             })\n-    });\n+    })\n+}\n \n-    if !should_load {\n+fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n+    if !should_link(i) {\n         return;\n     }\n \n     match extract_crate_info(e, i) {\n         Some(info) => {\n-            let cnum = resolve_crate(e, &None, info.ident, &info.crate_id, None,\n-                                     i.span);\n+            let (cnum, _, _) = resolve_crate(e, &None, info.ident,\n+                                             &info.crate_id, None, true,\n+                                             i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n         }\n         None => ()\n@@ -154,6 +143,7 @@ struct CrateInfo {\n     ident: ~str,\n     crate_id: CrateId,\n     id: ast::NodeId,\n+    should_link: bool,\n }\n \n fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n@@ -179,6 +169,7 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n                 ident: ident.get().to_str(),\n                 crate_id: crate_id,\n                 id: id,\n+                should_link: should_link(i),\n             })\n         }\n         _ => None\n@@ -269,23 +260,29 @@ fn visit_item(e: &Env, i: &ast::Item) {\n \n fn existing_match(e: &Env, crate_id: &CrateId,\n                   hash: Option<&Svh>) -> Option<ast::CrateNum> {\n-    for c in e.crate_cache.borrow().iter() {\n-        if !crate_id.matches(&c.crate_id) { continue }\n-        match hash {\n-            Some(hash) if *hash != c.hash => {}\n-            Some(..) | None => return Some(c.cnum)\n+    let mut ret = None;\n+    e.sess.cstore.iter_crate_data(|cnum, data| {\n+        let other_id = data.crate_id();\n+        if crate_id.matches(&other_id) {\n+            let other_hash = data.hash();\n+            match hash {\n+                Some(hash) if *hash != other_hash => {}\n+                Some(..) | None => { ret = Some(cnum); }\n+            }\n         }\n-    }\n-    None\n+    });\n+    return ret;\n }\n \n fn resolve_crate<'a>(e: &mut Env,\n                      root: &Option<CratePaths>,\n                      ident: &str,\n                      crate_id: &CrateId,\n                      hash: Option<&Svh>,\n+                     should_link: bool,\n                      span: Span)\n-                     -> ast::CrateNum {\n+                     -> (ast::CrateNum, @cstore::crate_metadata,\n+                         cstore::CrateSource) {\n     match existing_match(e, crate_id, hash) {\n         None => {\n             let id_hash = link::crate_id_hash(crate_id);\n@@ -304,17 +301,8 @@ fn resolve_crate<'a>(e: &mut Env,\n                 dylib, rlib, metadata\n             } = load_ctxt.load_library_crate(root);\n \n-            let crate_id = decoder::get_crate_id(metadata.as_slice());\n-            let hash = decoder::get_crate_hash(metadata.as_slice());\n-\n             // Claim this crate number and cache it\n             let cnum = e.next_crate_num;\n-            e.crate_cache.borrow_mut().push(cache_entry {\n-                cnum: cnum,\n-                span: span,\n-                hash: hash,\n-                crate_id: crate_id,\n-            });\n             e.next_crate_num += 1;\n \n             // Stash paths for top-most crate locally if necessary.\n@@ -331,27 +319,35 @@ fn resolve_crate<'a>(e: &mut Env,\n             let root = if root.is_some() { root } else { &crate_paths };\n \n             // Now resolve the crates referenced by this crate\n-            let cnum_map = resolve_crate_deps(e,\n-            root,\n-            metadata.as_slice(),\n-            span);\n+            let cnum_map = if should_link {\n+                resolve_crate_deps(e, root, metadata.as_slice(), span)\n+            } else {\n+                @RefCell::new(HashMap::new())\n+            };\n \n             let cmeta = @cstore::crate_metadata {\n                 name: load_ctxt.crate_id.name.to_owned(),\n                 data: metadata,\n                 cnum_map: cnum_map,\n-                cnum: cnum\n+                cnum: cnum,\n+                span: span,\n             };\n \n-            e.sess.cstore.set_crate_data(cnum, cmeta);\n-            e.sess.cstore.add_used_crate_source(cstore::CrateSource {\n+            let source = cstore::CrateSource {\n                 dylib: dylib,\n                 rlib: rlib,\n                 cnum: cnum,\n-            });\n-            cnum\n+            };\n+\n+            if should_link {\n+                e.sess.cstore.set_crate_data(cnum, cmeta);\n+                e.sess.cstore.add_used_crate_source(source.clone());\n+            }\n+            (cnum, cmeta, source)\n         }\n-        Some(cnum) => cnum\n+        Some(cnum) => (cnum,\n+                       e.sess.cstore.get_crate_data(cnum),\n+                       e.sess.cstore.get_used_crate_source(cnum).unwrap())\n     }\n }\n \n@@ -368,11 +364,12 @@ fn resolve_crate_deps(e: &mut Env,\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n         debug!(\"resolving dep crate {} hash: `{}`\", dep.crate_id, dep.hash);\n-        let local_cnum = resolve_crate(e, root,\n-                                       dep.crate_id.name.as_slice(),\n-                                       &dep.crate_id,\n-                                       Some(&dep.hash),\n-                                       span);\n+        let (local_cnum, _, _) = resolve_crate(e, root,\n+                                               dep.crate_id.name.as_slice(),\n+                                               &dep.crate_id,\n+                                               Some(&dep.hash),\n+                                               true,\n+                                               span);\n         cnum_map.insert(extrn_cnum, local_cnum);\n     }\n     return @RefCell::new(cnum_map);\n@@ -390,8 +387,7 @@ impl<'a> Loader<'a> {\n             env: Env {\n                 sess: sess,\n                 os: os,\n-                crate_cache: @RefCell::new(Vec::new()),\n-                next_crate_num: 1,\n+                next_crate_num: sess.cstore.next_crate_num(),\n                 intr: token::get_ident_interner(),\n             }\n         }\n@@ -401,23 +397,17 @@ impl<'a> Loader<'a> {\n impl<'a> CrateLoader for Loader<'a> {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate {\n         let info = extract_crate_info(&self.env, krate).unwrap();\n-        let cnum = resolve_crate(&mut self.env, &None, info.ident,\n-                                 &info.crate_id, None, krate.span);\n-        let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n+        let (cnum, data, library) = resolve_crate(&mut self.env, &None,\n+                                                  info.ident, &info.crate_id,\n+                                                  None, true, krate.span);\n+        let macros = decoder::get_exported_macros(data);\n+        let cstore = &self.env.sess.cstore;\n+        let registrar = csearch::get_macro_registrar_fn(cstore, cnum)\n+                            .map(|did| csearch::get_symbol(cstore, did));\n         MacroCrate {\n             lib: library.dylib,\n-            cnum: cnum\n+            macros: macros.move_iter().collect(),\n+            registrar_symbol: registrar,\n         }\n     }\n-\n-    fn get_exported_macros(&mut self, cnum: ast::CrateNum) -> Vec<~str> {\n-        csearch::get_exported_macros(&self.env.sess.cstore, cnum).move_iter()\n-                                                                 .collect()\n-    }\n-\n-    fn get_registrar_symbol(&mut self, cnum: ast::CrateNum) -> Option<~str> {\n-        let cstore = &self.env.sess.cstore;\n-        csearch::get_macro_registrar_fn(cstore, cnum)\n-            .map(|did| csearch::get_symbol(cstore, did))\n-    }\n }"}, {"sha": "2d46f92e88fa47939859c746c4aba9214effef25", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -22,6 +22,8 @@ use std::c_vec::CVec;\n use std::rc::Rc;\n use collections::HashMap;\n use syntax::ast;\n+use syntax::crateid::CrateId;\n+use syntax::codemap::Span;\n use syntax::parse::token::IdentInterner;\n \n // A map from external crate numbers (as decoded from some crate file) to\n@@ -40,6 +42,7 @@ pub struct crate_metadata {\n     pub data: MetadataBlob,\n     pub cnum_map: cnum_map,\n     pub cnum: ast::CrateNum,\n+    pub span: Span,\n }\n \n #[deriving(Eq)]\n@@ -88,6 +91,10 @@ impl CStore {\n         }\n     }\n \n+    pub fn next_crate_num(&self) -> ast::CrateNum {\n+        self.metas.borrow().len() as ast::CrateNum + 1\n+    }\n+\n     pub fn get_crate_data(&self, cnum: ast::CrateNum) -> @crate_metadata {\n         *self.metas.borrow().get(&cnum)\n     }\n@@ -121,6 +128,9 @@ impl CStore {\n             .map(|source| source.clone())\n     }\n \n+    pub fn dump_phase_syntax_crates(&self) {\n+    }\n+\n     pub fn reset(&self) {\n         self.metas.borrow_mut().clear();\n         self.extern_mod_crate_map.borrow_mut().clear();\n@@ -202,6 +212,8 @@ impl CStore {\n \n impl crate_metadata {\n     pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n+    pub fn crate_id(&self) -> CrateId { decoder::get_crate_id(self.data()) }\n+    pub fn hash(&self) -> Svh { decoder::get_crate_hash(self.data()) }\n }\n \n impl MetadataBlob {"}, {"sha": "40f0b719f2dcb3374c65ffb43d585b0d8a811053", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -76,7 +76,7 @@ fn lookup_hash<'a>(d: ebml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n     ret\n }\n \n-pub type GetCrateDataCb<'a> = 'a |ast::CrateNum| -> Cmd;\n+pub type GetCrateDataCb<'a> = |ast::CrateNum|: 'a -> Cmd;\n \n pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: ebml::Doc<'a>) -> Option<ebml::Doc<'a>> {\n@@ -637,11 +637,11 @@ pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n     item_path(lookup_item(id, cdata.data()))\n }\n \n-pub type DecodeInlinedItem<'a> = 'a |cdata: @cstore::crate_metadata,\n-                                     tcx: &ty::ctxt,\n-                                     path: Vec<ast_map::PathElem>,\n-                                     par_doc: ebml::Doc|\n-                                     -> Result<ast::InlinedItem, Vec<ast_map::PathElem> >;\n+pub type DecodeInlinedItem<'a> = |cdata: @cstore::crate_metadata,\n+                                  tcx: &ty::ctxt,\n+                                  path: Vec<ast_map::PathElem>,\n+                                  par_doc: ebml::Doc|: 'a\n+                                  -> Result<ast::InlinedItem, Vec<ast_map::PathElem> >;\n \n pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n                           decode_inlined_item: DecodeInlinedItem)"}, {"sha": "fcb0e3136a76e010b3874f25db136cfb09d9bde1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -64,9 +64,9 @@ pub enum InlinedItemRef<'a> {\n \n pub type Encoder<'a> = writer::Encoder<'a, MemWriter>;\n \n-pub type EncodeInlinedItem<'a> = 'a |ecx: &EncodeContext,\n-                                     ebml_w: &mut Encoder,\n-                                     ii: InlinedItemRef|;\n+pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n+                                  ebml_w: &mut Encoder,\n+                                  ii: InlinedItemRef|: 'a;\n \n pub struct EncodeParams<'a> {\n     pub diag: &'a SpanHandler,"}, {"sha": "7a531c5c128bfbe49abb9745bcb8d3a11e51f928", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -23,7 +23,7 @@ pub enum FileMatch { FileMatches, FileDoesntMatch }\n \n /// Functions with type `pick` take a parent directory as well as\n /// a file found in that directory.\n-pub type pick<'a> = 'a |path: &Path| -> FileMatch;\n+pub type pick<'a> = |path: &Path|: 'a -> FileMatch;\n \n pub struct FileSearch<'a> {\n     pub sysroot: &'a Path,"}, {"sha": "5a342e39d701a8a02df13dfb719f51451a0a1110", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -317,15 +317,23 @@ impl<'a> Context<'a> {\n     // read the metadata from it if `*slot` is `None`. If the metadata couldn't\n     // be read, it is assumed that the file isn't a valid rust library (no\n     // errors are emitted).\n-    //\n-    // FIXME(#10786): for an optimization, we only read one of the library's\n-    //                metadata sections. In theory we should read both, but\n-    //                reading dylib metadata is quite slow.\n     fn extract_one(&mut self, m: HashSet<Path>, flavor: &str,\n                    slot: &mut Option<MetadataBlob>) -> Option<Path> {\n         let mut ret = None::<Path>;\n         let mut error = 0;\n \n+        if slot.is_some() {\n+            // FIXME(#10786): for an optimization, we only read one of the\n+            //                library's metadata sections. In theory we should\n+            //                read both, but reading dylib metadata is quite\n+            //                slow.\n+            if m.len() == 0 {\n+                return None\n+            } else if m.len() == 1 {\n+                return Some(m.move_iter().next().unwrap())\n+            }\n+        }\n+\n         for lib in m.move_iter() {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let metadata = match get_metadata_section(self.os, &lib) {\n@@ -494,14 +502,17 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~st\n                 let version_ok = slice::raw::buf_as_slice(cvbuf, minsz,\n                     |buf0| buf0 == encoder::metadata_encoding_version);\n                 if !version_ok { return Err(format!(\"incompatible metadata version found: '{}'\",\n-                                                    filename.display()));}\n+                                                    filename.display())); }\n \n                 let cvbuf1 = cvbuf.offset(vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 slice::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {\n-                    let inflated = flate::inflate_bytes(bytes);\n-                    found = Ok(MetadataVec(inflated));\n+                    match flate::inflate_bytes(bytes) {\n+                        Some(inflated) => found = Ok(MetadataVec(inflated)),\n+                        None => found = Err(format!(\"failed to decompress metadata for: '{}'\",\n+                                                    filename.display()))\n+                    }\n                 });\n                 if found.is_ok() {\n                     return found;"}, {"sha": "599a1dad33d22a56124abeb920f890598e0d769e", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -54,7 +54,7 @@ pub enum DefIdSource {\n     RegionParameter,\n }\n pub type conv_did<'a> =\n-    'a |source: DefIdSource, ast::DefId| -> ast::DefId;\n+    |source: DefIdSource, ast::DefId|: 'a -> ast::DefId;\n \n pub struct PState<'a> {\n     data: &'a [u8],"}, {"sha": "49163ce96996728ac6b5bfdef8094a32727843de", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -503,7 +503,7 @@ fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n     }\n }\n \n-type enter_pat<'a> = 'a |@ast::Pat| -> Option<Vec<@ast::Pat>>;\n+type enter_pat<'a> = |@ast::Pat|: 'a -> Option<Vec<@ast::Pat>>;\n \n fn enter_match<'r,'b>(\n                bcx: &'b Block<'b>,"}, {"sha": "d5646c611a0410201f5df98e01bfa28e723ed78d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -613,7 +613,7 @@ pub fn compare_scalar_values<'a>(\n }\n \n pub type val_and_ty_fn<'r,'b> =\n-    'r |&'b Block<'b>, ValueRef, ty::t| -> &'b Block<'b>;\n+    |&'b Block<'b>, ValueRef, ty::t|: 'r -> &'b Block<'b>;\n \n // Iterates through the elements of a structural type.\n pub fn iter_structural_ty<'r,\n@@ -2236,7 +2236,10 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let compressed = encoder::metadata_encoding_version +\n-                        flate::deflate_bytes(metadata.as_slice()).as_slice();\n+                        match flate::deflate_bytes(metadata.as_slice()) {\n+                            Some(compressed) => compressed,\n+                            None => cx.sess().fatal(format!(\"failed to compress metadata\", ))\n+                        }.as_slice();\n     let llmeta = C_bytes(cx, compressed);\n     let llconst = C_struct(cx, [llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.crateid.name,"}, {"sha": "e47362e8d9ecebf28111facc212e642fef7be106", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -1802,11 +1802,15 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n             RvalueExpr(Rvalue { mode: ByRef }) => {\n                 let scope = cleanup::temporary_scope(bcx.tcx(), expr.id);\n                 let ptr = Load(bcx, datum.val);\n-                bcx.fcx.schedule_free_value(scope, ptr, cleanup::HeapExchange);\n+                if !type_is_zero_size(bcx.ccx(), content_ty) {\n+                    bcx.fcx.schedule_free_value(scope, ptr, cleanup::HeapExchange);\n+                }\n             }\n             RvalueExpr(Rvalue { mode: ByValue }) => {\n                 let scope = cleanup::temporary_scope(bcx.tcx(), expr.id);\n-                bcx.fcx.schedule_free_value(scope, datum.val, cleanup::HeapExchange);\n+                if !type_is_zero_size(bcx.ccx(), content_ty) {\n+                    bcx.fcx.schedule_free_value(scope, datum.val, cleanup::HeapExchange);\n+                }\n             }\n             LvalueExpr => { }\n         }"}, {"sha": "73370357a92b118563969326c471e006be1795e5", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -525,7 +525,7 @@ pub fn get_base_and_len(bcx: &Block,\n }\n \n pub type iter_vec_block<'r,'b> =\n-    'r |&'b Block<'b>, ValueRef, ty::t| -> &'b Block<'b>;\n+    |&'b Block<'b>, ValueRef, ty::t|: 'r -> &'b Block<'b>;\n \n pub fn iter_vec_loop<'r,\n                      'b>("}, {"sha": "8b14741f88145e50247dc631f56032889696ff3a", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -217,7 +217,7 @@ pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n \n pub struct BottomUpFolder<'a> {\n     pub tcx: &'a ty::ctxt,\n-    pub fldop: 'a |ty::t| -> ty::t,\n+    pub fldop: |ty::t|: 'a -> ty::t,\n }\n \n impl<'a> TypeFolder for BottomUpFolder<'a> {\n@@ -234,14 +234,14 @@ impl<'a> TypeFolder for BottomUpFolder<'a> {\n \n pub struct RegionFolder<'a> {\n     tcx: &'a ty::ctxt,\n-    fld_t: 'a |ty::t| -> ty::t,\n-    fld_r: 'a |ty::Region| -> ty::Region,\n+    fld_t: |ty::t|: 'a -> ty::t,\n+    fld_r: |ty::Region|: 'a -> ty::Region,\n }\n \n impl<'a> RegionFolder<'a> {\n     pub fn general(tcx: &'a ty::ctxt,\n-                   fld_r: 'a |ty::Region| -> ty::Region,\n-                   fld_t: 'a |ty::t| -> ty::t)\n+                   fld_r: |ty::Region|: 'a -> ty::Region,\n+                   fld_t: |ty::t|: 'a -> ty::t)\n                    -> RegionFolder<'a> {\n         RegionFolder {\n             tcx: tcx,\n@@ -250,7 +250,7 @@ impl<'a> RegionFolder<'a> {\n         }\n     }\n \n-    pub fn regions(tcx: &'a ty::ctxt, fld_r: 'a |ty::Region| -> ty::Region)\n+    pub fn regions(tcx: &'a ty::ctxt, fld_r: |ty::Region|: 'a -> ty::Region)\n                    -> RegionFolder<'a> {\n         fn noop(t: ty::t) -> ty::t { t }\n "}, {"sha": "febf47add4339b545557bf784a23f205b7e8b8d3", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -86,7 +86,7 @@ pub fn relate_nested_regions(tcx: &ty::ctxt,\n     struct RegionRelator<'a> {\n         tcx: &'a ty::ctxt,\n         stack: Vec<ty::Region>,\n-        relate_op: 'a |ty::Region, ty::Region|,\n+        relate_op: |ty::Region, ty::Region|: 'a,\n     }\n \n     // FIXME(#10151) -- Define more precisely when a region is"}, {"sha": "83cc929424448b1e3822b4ee1f3a6949223da02e", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -54,7 +54,7 @@ pub trait LatticeValue {\n }\n \n pub type LatticeOp<'a, T> =\n-    'a |cf: &CombineFields, a: &T, b: &T| -> cres<T>;\n+    |cf: &CombineFields, a: &T, b: &T|: 'a -> cres<T>;\n \n impl LatticeValue for ty::t {\n     fn sub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n@@ -407,7 +407,7 @@ pub fn super_lattice_tys<L:LatticeDir+TyLatticeDir+Combine>(this: &L,\n     }\n }\n \n-pub type LatticeDirOp<'a, T> = 'a |a: &T, b: &T| -> cres<T>;\n+pub type LatticeDirOp<'a, T> = |a: &T, b: &T|: 'a -> cres<T>;\n \n #[deriving(Clone)]\n pub enum LatticeVarResult<V,T> {"}, {"sha": "0d14c036ba7f1cb2cc414829ca9b602cf110b11a", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -64,7 +64,7 @@ pub fn indenter() -> _indenter {\n }\n \n struct LoopQueryVisitor<'a> {\n-    p: 'a |&ast::Expr_| -> bool,\n+    p: |&ast::Expr_|: 'a -> bool,\n     flag: bool,\n }\n \n@@ -92,7 +92,7 @@ pub fn loop_query(b: &ast::Block, p: |&ast::Expr_| -> bool) -> bool {\n }\n \n struct BlockQueryVisitor<'a> {\n-    p: 'a |&ast::Expr| -> bool,\n+    p: |&ast::Expr|: 'a -> bool,\n     flag: bool,\n }\n "}, {"sha": "1621435de55ab60fefc2f55bf1ba15321169a95d", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -120,7 +120,7 @@ impl Drop for Addrinfo {\n }\n \n fn each_ai_flag(_f: |c_int, ai::Flag|) {\n-    /* XXX: do we really want to support these?\n+    /* FIXME: do we really want to support these?\n     unsafe {\n         f(uvll::rust_AI_ADDRCONFIG(), ai::AddrConfig);\n         f(uvll::rust_AI_ALL(), ai::All);\n@@ -150,7 +150,7 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n                 }\n             });\n \n-            /* XXX: do we really want to support these\n+            /* FIXME: do we really want to support these\n             let protocol = match (*addr).ai_protocol {\n                 p if p == uvll::rust_IPPROTO_UDP() => Some(ai::UDP),\n                 p if p == uvll::rust_IPPROTO_TCP() => Some(ai::TCP),"}, {"sha": "4ef5af9275c875140c9e408189da13bc54ec3913", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -46,7 +46,7 @@ use raw;\n pub struct CVec<T> {\n     base: *mut T,\n     len: uint,\n-    dtor: Option<proc:Send()>,\n+    dtor: Option<proc():Send>,\n }\n \n #[unsafe_destructor]\n@@ -90,7 +90,7 @@ impl<T> CVec<T> {\n     /// * dtor - A proc to run when the value is destructed, useful\n     ///          for freeing the buffer, etc.\n     pub unsafe fn new_with_dtor(base: *mut T, len: uint,\n-                                dtor: proc:Send()) -> CVec<T> {\n+                                dtor: proc():Send) -> CVec<T> {\n         assert!(base != ptr::mut_null());\n         CVec {\n             base: base,"}, {"sha": "f384000896cfe708ce12f7f8a588a99342adb853", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -632,28 +632,28 @@ pub trait Reader {\n \n     /// Reads a little-endian unsigned integer.\n     ///\n-    /// The number of bytes returned is system-dependant.\n+    /// The number of bytes returned is system-dependent.\n     fn read_le_uint(&mut self) -> IoResult<uint> {\n         self.read_le_uint_n(uint::BYTES).map(|i| i as uint)\n     }\n \n     /// Reads a little-endian integer.\n     ///\n-    /// The number of bytes returned is system-dependant.\n+    /// The number of bytes returned is system-dependent.\n     fn read_le_int(&mut self) -> IoResult<int> {\n         self.read_le_int_n(int::BYTES).map(|i| i as int)\n     }\n \n     /// Reads a big-endian unsigned integer.\n     ///\n-    /// The number of bytes returned is system-dependant.\n+    /// The number of bytes returned is system-dependent.\n     fn read_be_uint(&mut self) -> IoResult<uint> {\n         self.read_be_uint_n(uint::BYTES).map(|i| i as uint)\n     }\n \n     /// Reads a big-endian integer.\n     ///\n-    /// The number of bytes returned is system-dependant.\n+    /// The number of bytes returned is system-dependent.\n     fn read_be_int(&mut self) -> IoResult<int> {\n         self.read_be_int_n(int::BYTES).map(|i| i as int)\n     }"}, {"sha": "a58cdbdba446f7e483c1c229123c8d6fc2af60f3", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -141,7 +141,7 @@ mod tests {\n     use io::*;\n     use io::test::*;\n \n-    pub fn smalltest(server: proc:Send(UnixStream), client: proc:Send(UnixStream)) {\n+    pub fn smalltest(server: proc(UnixStream):Send, client: proc(UnixStream):Send) {\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n "}, {"sha": "33306dba8defec7747f813489c9a68a4dbc86015", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -99,7 +99,15 @@ fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n ///\n /// See `stdout()` for more notes about this function.\n pub fn stdin() -> BufferedReader<StdReader> {\n-    BufferedReader::new(stdin_raw())\n+    // The default buffer capacity is 64k, but apparently windows doesn't like\n+    // 64k reads on stdin. See #13304 for details, but the idea is that on\n+    // windows we use a slighly smaller buffer that's been seen to be\n+    // acceptable.\n+    if cfg!(windows) {\n+        BufferedReader::with_capacity(8 * 1024, stdin_raw())\n+    } else {\n+        BufferedReader::new(stdin_raw())\n+    }\n }\n \n /// Creates a new non-blocking handle to the stdin of the current process."}, {"sha": "1c7579e6b8e75c129f6b57fe45914e0fdc5e9c34", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -156,7 +156,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn map<'r, B>(self, f: 'r |A| -> B) -> Map<'r, A, B, Self> {\n+    fn map<'r, B>(self, f: |A|: 'r -> B) -> Map<'r, A, B, Self> {\n         Map{iter: self, f: f}\n     }\n \n@@ -173,7 +173,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn filter<'r>(self, predicate: 'r |&A| -> bool) -> Filter<'r, A, Self> {\n+    fn filter<'r>(self, predicate: |&A|: 'r -> bool) -> Filter<'r, A, Self> {\n         Filter{iter: self, predicate: predicate}\n     }\n \n@@ -190,7 +190,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn filter_map<'r, B>(self, f: 'r |A| -> Option<B>) -> FilterMap<'r, A, B, Self> {\n+    fn filter_map<'r, B>(self, f: |A|: 'r -> Option<B>) -> FilterMap<'r, A, B, Self> {\n         FilterMap { iter: self, f: f }\n     }\n \n@@ -249,7 +249,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn skip_while<'r>(self, predicate: 'r |&A| -> bool) -> SkipWhile<'r, A, Self> {\n+    fn skip_while<'r>(self, predicate: |&A|: 'r -> bool) -> SkipWhile<'r, A, Self> {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n@@ -267,7 +267,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn take_while<'r>(self, predicate: 'r |&A| -> bool) -> TakeWhile<'r, A, Self> {\n+    fn take_while<'r>(self, predicate: |&A|: 'r -> bool) -> TakeWhile<'r, A, Self> {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n@@ -327,7 +327,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn scan<'r, St, B>(self, initial_state: St, f: 'r |&mut St, A| -> Option<B>)\n+    fn scan<'r, St, B>(self, initial_state: St, f: |&mut St, A|: 'r -> Option<B>)\n         -> Scan<'r, A, B, Self, St> {\n         Scan{iter: self, f: f, state: initial_state}\n     }\n@@ -351,7 +351,7 @@ pub trait Iterator<A> {\n     /// }\n     /// ```\n     #[inline]\n-    fn flat_map<'r, B, U: Iterator<B>>(self, f: 'r |A| -> U)\n+    fn flat_map<'r, B, U: Iterator<B>>(self, f: |A|: 'r -> U)\n         -> FlatMap<'r, A, Self, U> {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n@@ -405,7 +405,7 @@ pub trait Iterator<A> {\n     /// println!(\"{}\", sum);\n     /// ```\n     #[inline]\n-    fn inspect<'r>(self, f: 'r |&A|) -> Inspect<'r, A, Self> {\n+    fn inspect<'r>(self, f: |&A|: 'r) -> Inspect<'r, A, Self> {\n         Inspect{iter: self, f: f}\n     }\n \n@@ -1235,7 +1235,7 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n /// An iterator which maps the values of `iter` with `f`\n pub struct Map<'a, A, B, T> {\n     iter: T,\n-    f: 'a |A| -> B\n+    f: |A|: 'a -> B\n }\n \n impl<'a, A, B, T> Map<'a, A, B, T> {\n@@ -1284,7 +1284,7 @@ impl<'a, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'a, A\n /// An iterator which filters the elements of `iter` with `predicate`\n pub struct Filter<'a, A, T> {\n     iter: T,\n-    predicate: 'a |&A| -> bool\n+    predicate: |&A|: 'a -> bool\n }\n \n impl<'a, A, T: Iterator<A>> Iterator<A> for Filter<'a, A, T> {\n@@ -1328,7 +1328,7 @@ impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Filter<'a, A,\n /// An iterator which uses `f` to both filter and map elements from `iter`\n pub struct FilterMap<'a, A, B, T> {\n     iter: T,\n-    f: 'a |A| -> Option<B>\n+    f: |A|: 'a -> Option<B>\n }\n \n impl<'a, A, B, T: Iterator<A>> Iterator<B> for FilterMap<'a, A, B, T> {\n@@ -1477,7 +1477,7 @@ impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n pub struct SkipWhile<'a, A, T> {\n     iter: T,\n     flag: bool,\n-    predicate: 'a |&A| -> bool\n+    predicate: |&A|: 'a -> bool\n }\n \n impl<'a, A, T: Iterator<A>> Iterator<A> for SkipWhile<'a, A, T> {\n@@ -1515,7 +1515,7 @@ impl<'a, A, T: Iterator<A>> Iterator<A> for SkipWhile<'a, A, T> {\n pub struct TakeWhile<'a, A, T> {\n     iter: T,\n     flag: bool,\n-    predicate: 'a |&A| -> bool\n+    predicate: |&A|: 'a -> bool\n }\n \n impl<'a, A, T: Iterator<A>> Iterator<A> for TakeWhile<'a, A, T> {\n@@ -1662,7 +1662,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n /// An iterator to maintain state while iterating another iterator\n pub struct Scan<'a, A, B, T, St> {\n     iter: T,\n-    f: 'a |&mut St, A| -> Option<B>,\n+    f: |&mut St, A|: 'a -> Option<B>,\n \n     /// The current internal state to be passed to the closure next.\n     pub state: St,\n@@ -1686,7 +1686,7 @@ impl<'a, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'a, A, B, T, St> {\n ///\n pub struct FlatMap<'a, A, T, U> {\n     iter: T,\n-    f: 'a |A| -> U,\n+    f: |A|: 'a -> U,\n     frontiter: Option<U>,\n     backiter: Option<U>,\n }\n@@ -1817,7 +1817,7 @@ impl<T> Fuse<T> {\n /// element before yielding it.\n pub struct Inspect<'a, A, T> {\n     iter: T,\n-    f: 'a |&A|\n+    f: |&A|: 'a\n }\n \n impl<'a, A, T> Inspect<'a, A, T> {\n@@ -1869,7 +1869,7 @@ for Inspect<'a, A, T> {\n \n /// An iterator which just modifies the contained state throughout iteration.\n pub struct Unfold<'a, A, St> {\n-    f: 'a |&mut St| -> Option<A>,\n+    f: |&mut St|: 'a -> Option<A>,\n     /// Internal state that will be yielded on the next iteration\n     pub state: St,\n }\n@@ -1878,7 +1878,7 @@ impl<'a, A, St> Unfold<'a, A, St> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the iterator\n     #[inline]\n-    pub fn new<'a>(initial_state: St, f: 'a |&mut St| -> Option<A>)\n+    pub fn new<'a>(initial_state: St, f: |&mut St|: 'a -> Option<A>)\n                -> Unfold<'a, A, St> {\n         Unfold {\n             f: f,"}, {"sha": "985f8a8eb0a1e1685764bf2374cc1cb227ce8250", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -58,7 +58,6 @@\n #![no_std]\n \n #![deny(missing_doc)]\n-#![allow(unknown_features)] // NOTE: remove after a stage0 snap\n \n // When testing libstd, bring in libuv as the I/O backend so tests can print\n // things and all of the std::io tests have an I/O interface to run on top"}, {"sha": "fbb48f2ebcb2641bcc3d02ad16893c8f3c18a634", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -273,7 +273,8 @@ macro_rules! vec(\n         let mut _temp = ::std::vec::Vec::new();\n         $(_temp.push($e);)*\n         _temp\n-    })\n+    });\n+    ($($e:expr),+,) => (vec!($($e),+))\n )\n \n "}, {"sha": "19eee8755a0cc185c7ed2be7478e82fa744a401c", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 182, "deletions": 53, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -8,7 +8,87 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Unsafe pointer utility functions\n+//! Conveniences for working with unsafe pointers, the `*T`, and `*mut T` types.\n+//!\n+//! Working with unsafe pointers in Rust is fairly uncommon,\n+//! and often limited to some narrow use cases: holding\n+//! an unsafe pointer when safe pointers are unsuitable;\n+//! checking for null; and converting back to safe pointers.\n+//! As a result, there is not yet an abundance of library code\n+//! for working with unsafe poniters, and in particular,\n+//! since pointer math is fairly uncommon in Rust, it is not\n+//! all that convenient.\n+//!\n+//! Use the [`null` function](fn.null.html) to create null pointers,\n+//! the [`is_null`](trait.RawPtr.html#tymethod.is_null)\n+//! and [`is_not_null`](trait.RawPtr.html#method.is_not_null)\n+//! methods of the [`RawPtr` trait](trait.RawPtr.html) to check for null.\n+//! The `RawPtr` trait is imported by the prelude, so `is_null` etc.\n+//! work everywhere.\n+//!\n+//! # Common ways to create unsafe pointers\n+//!\n+//! ## 1. Coerce a reference (`&T`) or mutable reference (`&mut T`).\n+//!\n+//! ```\n+//! let my_num: int = 10;\n+//! let my_num_ptr: *int = &my_num;\n+//! let mut my_speed: int = 88;\n+//! let my_speed_ptr: *mut int = &mut my_speed;\n+//! ```\n+//!\n+//! This does not take ownership of the original allocation\n+//! and requires no resource management later,\n+//! but you must not use the pointer after its lifetime.\n+//!\n+//! ## 2. Transmute an owned box (`~T`).\n+//!\n+//! The `transmute` function takes, by value, whatever it's given\n+//! and returns it as whatever type is requested, as long as the\n+//! types are the same size. Because `~T` and `*T` have the same\n+//! representation they can be trivially,\n+//! though unsafely, transformed from one type to the other.\n+//!\n+//! ```\n+//! use std::cast;\n+//!\n+//! unsafe {\n+//!     let my_num: ~int = ~10;\n+//!     let my_num: *int = cast::transmute(my_num);\n+//!     let my_speed: ~int = ~88;\n+//!     let my_speed: *mut int = cast::transmute(my_speed);\n+//!\n+//!     // By taking ownership of the original `~T` though\n+//!     // we are obligated to transmute it back later to be destroyed.\n+//!     drop(cast::transmute::<_, ~int>(my_speed));\n+//!     drop(cast::transmute::<_, ~int>(my_num));\n+//! }\n+//! ```\n+//!\n+//! Note that here the call to `drop` is for clarity - it indicates\n+//! that we are done with the given value and it should be destroyed.\n+//!\n+//! ## 3. Get it from C.\n+//!\n+//! ```\n+//! extern crate libc;\n+//!\n+//! use std::mem;\n+//!\n+//! fn main() {\n+//!     unsafe {\n+//!         let my_num: *mut int = libc::malloc(mem::size_of::<int>() as libc::size_t) as *mut int;\n+//!         if my_num.is_null() {\n+//!             fail!(\"failed to allocate memory\");\n+//!         }\n+//!         libc::free(my_num as *mut libc::c_void);\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! Usually you wouldn't literally use `malloc` and `free` from Rust,\n+//! but C APIs hand out a lot of pointers generally, so are a common source\n+//! of unsafe pointers in Rust.\n \n use cast;\n use clone::Clone;\n@@ -51,59 +131,119 @@ pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {\n     }\n }\n \n-/// Create an unsafe null pointer\n+/// Create an null pointer.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let p: *int = ptr::null();\n+/// assert!(p.is_null());\n+/// ```\n #[inline]\n pub fn null<T>() -> *T { 0 as *T }\n \n-/// Create an unsafe mutable null pointer\n+/// Create an unsafe mutable null pointer.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let p: *mut int = ptr::mut_null();\n+/// assert!(p.is_null());\n+/// ```\n #[inline]\n pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n \n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may overlap.\n- */\n+/// Copies data from one location to another.\n+///\n+/// Copies `count` elements (not bytes) from `src` to `dst`. The source\n+/// and destination may overlap.\n+///\n+/// `copy_memory` is semantically equivalent to C's `memmove`.\n+///\n+/// # Example\n+///\n+/// Efficiently create a Rust vector from an unsafe buffer:\n+///\n+/// ```\n+/// use std::ptr;\n+/// use std::slice;\n+///\n+/// unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n+///     let mut dst = slice::with_capacity(elts);\n+///     dst.set_len(elts);\n+///     ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n+///     dst\n+/// }\n+/// ```\n+///\n #[inline]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n     intrinsics::copy_memory(dst, src, count)\n }\n \n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may *not* overlap.\n- */\n+/// Copies data from one location to another.\n+///\n+/// Copies `count` elements (not bytes) from `src` to `dst`. The source\n+/// and destination may *not* overlap.\n+///\n+/// `copy_nonoverlapping_memory` is semantically equivalent to C's `memcpy`.\n+///\n+/// # Example\n+///\n+/// A safe swap function:\n+///\n+/// ```\n+/// use std::cast;\n+/// use std::mem;\n+/// use std::ptr;\n+///\n+/// fn swap<T>(x: &mut T, y: &mut T) {\n+///     unsafe {\n+///         // Give ourselves some scratch space to work with\n+///         let mut t: T = mem::uninit();\n+///\n+///         // Perform the swap, `&mut` pointers never alias\n+///         ptr::copy_nonoverlapping_memory(&mut t, &*x, 1);\n+///         ptr::copy_nonoverlapping_memory(x, &*y, 1);\n+///         ptr::copy_nonoverlapping_memory(y, &t, 1);\n+///\n+///         // y and t now point to the same thing, but we need to completely forget `tmp`\n+///         // because it's no longer relevant.\n+///         cast::forget(t);\n+///     }\n+/// }\n+/// ```\n+///\n+/// # Safety Note\n+///\n+/// If the source and destination overlap then the behavior of this\n+/// function is undefined.\n #[inline]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,\n                                             src: *T,\n                                             count: uint) {\n     intrinsics::copy_nonoverlapping_memory(dst, src, count)\n }\n \n-/**\n- * Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n- * bytes of memory starting at `dst` to `c`.\n- */\n+/// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n+/// bytes of memory starting at `dst` to `c`.\n #[inline]\n pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     intrinsics::set_memory(dst, c, count)\n }\n \n-/**\n- * Zeroes out `count * size_of::<T>` bytes of memory at `dst`\n- */\n+/// Zeroes out `count * size_of::<T>` bytes of memory at `dst`\n #[inline]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n     set_memory(dst, 0, count);\n }\n \n-/**\n- * Swap the values at two mutable locations of the same type, without\n- * deinitialising either. They may overlap.\n- */\n+/// Swap the values at two mutable locations of the same type, without\n+/// deinitialising either. They may overlap.\n #[inline]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n@@ -120,30 +260,24 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     cast::forget(tmp);\n }\n \n-/**\n- * Replace the value at a mutable location with a new one, returning the old\n- * value, without deinitialising either.\n- */\n+/// Replace the value at a mutable location with a new one, returning the old\n+/// value, without deinitialising either.\n #[inline]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     mem::swap(cast::transmute(dest), &mut src); // cannot overlap\n     src\n }\n \n-/**\n- * Reads the value from `*src` and returns it.\n- */\n+/// Reads the value from `*src` and returns it.\n #[inline(always)]\n pub unsafe fn read<T>(src: *T) -> T {\n     let mut tmp: T = mem::uninit();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n     tmp\n }\n \n-/**\n- * Reads the value from `*src` and nulls it out.\n- * This currently prevents destructors from executing.\n- */\n+/// Reads the value from `*src` and nulls it out.\n+/// This currently prevents destructors from executing.\n #[inline(always)]\n pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n@@ -155,13 +289,9 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     tmp\n }\n \n-/**\n-  Given a **T (pointer to an array of pointers),\n-  iterate through each *T, up to the provided `len`,\n-  passing to the provided callback function\n-\n-  SAFETY NOTE: Pointer-arithmetic. Dragons be here.\n-*/\n+/// Given a **T (pointer to an array of pointers),\n+/// iterate through each *T, up to the provided `len`,\n+/// passing to the provided callback function\n pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     if arr.is_null() {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n@@ -173,15 +303,14 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     }\n }\n \n-/**\n-  Given a null-pointer-terminated **T (pointer to\n-  an array of pointers), iterate through each *T,\n-  passing to the provided callback function\n-\n-  SAFETY NOTE: This will only work with a null-terminated\n-  pointer array. Barely less-dodgy Pointer Arithmetic.\n-  Dragons be here.\n-*/\n+/// Given a null-pointer-terminated **T (pointer to\n+/// an array of pointers), iterate through each *T,\n+/// passing to the provided callback function\n+///\n+/// # Safety Note\n+///\n+/// This will only work with a null-terminated\n+/// pointer array.\n pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {\n     if arr.is_null()  {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");"}, {"sha": "4be9c8a84acd38659f4ecb09a8ba26f8a856b355", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -21,7 +21,7 @@ use ptr::RawPtr;\n use unstable::sync::Exclusive;\n use slice::OwnedVector;\n \n-type Queue = Exclusive<~[proc:Send()]>;\n+type Queue = Exclusive<~[proc():Send]>;\n \n // You'll note that these variables are *not* atomic, and this is done on\n // purpose. This module is designed to have init() called *once* in a\n@@ -40,7 +40,7 @@ pub fn init() {\n     }\n }\n \n-pub fn push(f: proc:Send()) {\n+pub fn push(f: proc():Send) {\n     unsafe {\n         rtassert!(!RUNNING);\n         rtassert!(!QUEUE.is_null());"}, {"sha": "e3f64f40c0d40103fed1bfb7dc8c4e598f9a569f", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -12,7 +12,7 @@\n //!\n //! The runtime will use this for storing ~Task.\n //!\n-//! XXX: Add runtime checks for usage of inconsistent pointer types.\n+//! FIXME: Add runtime checks for usage of inconsistent pointer types.\n //! and for overwriting an existing pointer.\n \n #![allow(dead_code)]"}, {"sha": "f4a4fd9ab2e9b34072e814b66b16a4da15f6b3b0", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -157,7 +157,7 @@ pub trait Runtime {\n \n     // Miscellaneous calls which are very different depending on what context\n     // you're in.\n-    fn spawn_sibling(~self, cur_task: ~Task, opts: TaskOpts, f: proc:Send());\n+    fn spawn_sibling(~self, cur_task: ~Task, opts: TaskOpts, f: proc():Send);\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n     /// The (low, high) edges of the current stack.\n     fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n@@ -196,7 +196,7 @@ pub fn init(argc: int, argv: **u8) {\n ///\n /// It is forbidden for procedures to register more `at_exit` handlers when they\n /// are running, and doing so will lead to a process abort.\n-pub fn at_exit(f: proc:Send()) {\n+pub fn at_exit(f: proc():Send) {\n     at_exit_imp::push(f);\n }\n "}, {"sha": "1750e685627d8a1deebb093d23bc1d6a4187ad51", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -36,7 +36,7 @@ pub trait Callback {\n \n pub trait EventLoop {\n     fn run(&mut self);\n-    fn callback(&mut self, arg: proc:Send());\n+    fn callback(&mut self, arg: proc():Send);\n     fn pausable_idle_callback(&mut self,\n                               ~Callback:Send) -> ~PausableIdleCallback:Send;\n     fn remote_callback(&mut self, ~Callback:Send) -> ~RemoteCallback:Send;"}, {"sha": "bae20d3bb9b9072c90f6712519eb50d03451f273", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -70,7 +70,7 @@ pub enum BlockedTask {\n pub enum DeathAction {\n     /// Action to be done with the exit code. If set, also makes the task wait\n     /// until all its watched children exit before collecting the status.\n-    Execute(proc:Send(TaskResult)),\n+    Execute(proc(TaskResult):Send),\n     /// A channel to send the result of the task on when the task exits\n     SendMessage(Sender<TaskResult>),\n }\n@@ -236,7 +236,7 @@ impl Task {\n \n     /// Spawns a sibling to this task. The newly spawned task is configured with\n     /// the `opts` structure and will run `f` as the body of its code.\n-    pub fn spawn_sibling(mut ~self, opts: TaskOpts, f: proc:Send()) {\n+    pub fn spawn_sibling(mut ~self, opts: TaskOpts, f: proc():Send) {\n         let ops = self.imp.take_unwrap();\n         ops.spawn_sibling(self, opts, f)\n     }"}, {"sha": "b1c7c5aab020f0cb2135d2adedb7bd8b6d213569", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -68,13 +68,13 @@ impl Thread<()> {\n     /// to finish executing. This means that even if `join` is not explicitly\n     /// called, when the `Thread` falls out of scope its destructor will block\n     /// waiting for the OS thread.\n-    pub fn start<T: Send>(main: proc:Send() -> T) -> Thread<T> {\n+    pub fn start<T: Send>(main: proc():Send -> T) -> Thread<T> {\n         Thread::start_stack(DEFAULT_STACK_SIZE, main)\n     }\n \n     /// Performs the same functionality as `start`, but specifies an explicit\n     /// stack size for the new thread.\n-    pub fn start_stack<T: Send>(stack: uint, main: proc:Send() -> T) -> Thread<T> {\n+    pub fn start_stack<T: Send>(stack: uint, main: proc():Send -> T) -> Thread<T> {\n \n         // We need the address of the packet to fill in to be stable so when\n         // `main` fills it in it's still valid, so allocate an extra ~ box to do\n@@ -99,13 +99,13 @@ impl Thread<()> {\n     /// This corresponds to creating threads in the 'detached' state on unix\n     /// systems. Note that platforms may not keep the main program alive even if\n     /// there are detached thread still running around.\n-    pub fn spawn(main: proc:Send()) {\n+    pub fn spawn(main: proc():Send) {\n         Thread::spawn_stack(DEFAULT_STACK_SIZE, main)\n     }\n \n     /// Performs the same functionality as `spawn`, but explicitly specifies a\n     /// stack size for the new thread.\n-    pub fn spawn_stack(stack: uint, main: proc:Send()) {\n+    pub fn spawn_stack(stack: uint, main: proc():Send) {\n         unsafe {\n             let handle = imp::create(stack, ~main);\n             imp::detach(handle);\n@@ -156,7 +156,7 @@ mod imp {\n     pub type rust_thread = HANDLE;\n     pub type rust_thread_return = DWORD;\n \n-    pub unsafe fn create(stack: uint, p: ~proc:Send()) -> rust_thread {\n+    pub unsafe fn create(stack: uint, p: ~proc():Send) -> rust_thread {\n         let arg: *mut libc::c_void = cast::transmute(p);\n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n@@ -215,7 +215,7 @@ mod imp {\n     pub type rust_thread = libc::pthread_t;\n     pub type rust_thread_return = *u8;\n \n-    pub unsafe fn create(stack: uint, p: ~proc:Send()) -> rust_thread {\n+    pub unsafe fn create(stack: uint, p: ~proc():Send) -> rust_thread {\n         let mut native: libc::pthread_t = mem::uninit();\n         let mut attr: libc::pthread_attr_t = mem::uninit();\n         assert_eq!(pthread_attr_init(&mut attr), 0);"}, {"sha": "fced9b5dd5b9448858c3ed21b0d12d72a14e7a3f", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -235,7 +235,7 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n pub struct Splits<'a, T> {\n     v: &'a [T],\n     n: uint,\n-    pred: 'a |t: &T| -> bool,\n+    pred: |t: &T|: 'a -> bool,\n     finished: bool\n }\n \n@@ -284,7 +284,7 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n pub struct RevSplits<'a, T> {\n     v: &'a [T],\n     n: uint,\n-    pred: 'a |t: &T| -> bool,\n+    pred: |t: &T|: 'a -> bool,\n     finished: bool\n }\n \n@@ -810,23 +810,23 @@ pub trait ImmutableVector<'a, T> {\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`.  The matched element\n     /// is not contained in the subslices.\n-    fn split(self, pred: 'a |&T| -> bool) -> Splits<'a, T>;\n+    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`, limited to splitting\n     /// at most `n` times.  The matched element is not contained in\n     /// the subslices.\n-    fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> Splits<'a, T>;\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`. This starts at the\n     /// end of the vector and works backwards.  The matched element is\n     /// not contained in the subslices.\n-    fn rsplit(self, pred: 'a |&T| -> bool) -> RevSplits<'a, T>;\n+    fn rsplit(self, pred: |&T|: 'a -> bool) -> RevSplits<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred` limited to splitting\n     /// at most `n` times. This starts at the end of the vector and\n     /// works backwards.  The matched element is not contained in the\n     /// subslices.\n-    fn rsplitn(self,  n: uint, pred: 'a |&T| -> bool) -> RevSplits<'a, T>;\n+    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> RevSplits<'a, T>;\n \n     /**\n      * Returns an iterator over all contiguous windows of length\n@@ -1003,12 +1003,12 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn split(self, pred: 'a |&T| -> bool) -> Splits<'a, T> {\n+    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n         self.splitn(uint::MAX, pred)\n     }\n \n     #[inline]\n-    fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> Splits<'a, T> {\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n         Splits {\n             v: self,\n             n: n,\n@@ -1018,12 +1018,12 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn rsplit(self, pred: 'a |&T| -> bool) -> RevSplits<'a, T> {\n+    fn rsplit(self, pred: |&T|: 'a -> bool) -> RevSplits<'a, T> {\n         self.rsplitn(uint::MAX, pred)\n     }\n \n     #[inline]\n-    fn rsplitn(self, n: uint, pred: 'a |&T| -> bool) -> RevSplits<'a, T> {\n+    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> RevSplits<'a, T> {\n         RevSplits {\n             v: self,\n             n: n,\n@@ -2027,7 +2027,7 @@ pub trait MutableVector<'a, T> {\n     /// Returns an iterator over the mutable subslices of the vector\n     /// which are separated by elements that match `pred`.  The\n     /// matched element is not contained in the subslices.\n-    fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplits<'a, T>;\n+    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n \n     /**\n      * Returns an iterator over `size` elements of the vector at a time.\n@@ -2299,7 +2299,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-    fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplits<'a, T> {\n+    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n         MutSplits { v: self, pred: pred, finished: false }\n     }\n \n@@ -2736,7 +2736,7 @@ pub type RevMutItems<'a, T> = Rev<MutItems<'a, T>>;\n /// by elements that match `pred`.\n pub struct MutSplits<'a, T> {\n     v: &'a mut [T],\n-    pred: 'a |t: &T| -> bool,\n+    pred: |t: &T|: 'a -> bool,\n     finished: bool\n }\n "}, {"sha": "e24011ca021d0ee3e66fd9be886b639de73fbba8", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -241,7 +241,7 @@ impl CharEq for char {\n     fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n }\n \n-impl<'a> CharEq for 'a |char| -> bool {\n+impl<'a> CharEq for |char|: 'a -> bool {\n     #[inline]\n     fn matches(&self, c: char) -> bool { (*self)(c) }\n "}, {"sha": "ed10f6d15cd662c822e99d691df84b1eafb77888", "filename": "src/libstd/task.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -86,7 +86,7 @@ pub struct TaskOpts {\n pub struct TaskBuilder {\n     /// Options to spawn the new task with\n     pub opts: TaskOpts,\n-    gen_body: Option<proc:Send(v: proc:Send()) -> proc:Send()>,\n+    gen_body: Option<proc(v: proc():Send):Send -> proc():Send>,\n     nocopy: Option<marker::NoCopy>,\n }\n \n@@ -151,7 +151,7 @@ impl TaskBuilder {\n      * existing body generator to the new body generator.\n      */\n     pub fn with_wrapper(mut self,\n-                        wrapper: proc:Send(v: proc:Send()) -> proc:Send())\n+                        wrapper: proc(v: proc():Send):Send -> proc():Send)\n         -> TaskBuilder\n     {\n         self.gen_body = match self.gen_body.take() {\n@@ -168,7 +168,7 @@ impl TaskBuilder {\n      * the provided unique closure. The task has the properties and behavior\n      * specified by the task_builder.\n      */\n-    pub fn spawn(mut self, f: proc:Send()) {\n+    pub fn spawn(mut self, f: proc():Send) {\n         let gen_body = self.gen_body.take();\n         let f = match gen_body {\n             Some(gen) => gen(f),\n@@ -191,7 +191,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    pub fn try<T:Send>(mut self, f: proc:Send() -> T) -> Result<T, ~Any:Send> {\n+    pub fn try<T:Send>(mut self, f: proc():Send -> T) -> Result<T, ~Any:Send> {\n         let (tx, rx) = channel();\n \n         let result = self.future_result();\n@@ -233,12 +233,12 @@ impl TaskOpts {\n /// the provided unique closure.\n ///\n /// This function is equivalent to `task().spawn(f)`.\n-pub fn spawn(f: proc:Send()) {\n+pub fn spawn(f: proc():Send) {\n     let task = task();\n     task.spawn(f)\n }\n \n-pub fn try<T:Send>(f: proc:Send() -> T) -> Result<T, ~Any:Send> {\n+pub fn try<T:Send>(f: proc():Send -> T) -> Result<T, ~Any:Send> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -338,7 +338,7 @@ fn test_run_basic() {\n fn test_with_wrapper() {\n     let (tx, rx) = channel();\n     task().with_wrapper(proc(body) {\n-        let result: proc:Send() = proc() {\n+        let result: proc():Send = proc() {\n             body();\n             tx.send(());\n         };\n@@ -424,7 +424,7 @@ fn test_spawn_sched_childs_on_default_sched() {\n }\n \n #[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: |v: proc:Send()|) {\n+fn avoid_copying_the_body(spawnfn: |v: proc():Send|) {\n     let (tx, rx) = channel::<uint>();\n \n     let x = ~1;\n@@ -470,7 +470,7 @@ fn test_child_doesnt_ref_parent() {\n     // (well, it would if the constant were 8000+ - I lowered it to be more\n     // valgrind-friendly. try this at home, instead..!)\n     static generations: uint = 16;\n-    fn child_no(x: uint) -> proc:Send() {\n+    fn child_no(x: uint) -> proc():Send {\n         return proc() {\n             if x < generations {\n                 task().spawn(child_no(x+1));"}, {"sha": "82119ad21b990b1708397b27cd09711aee639dd0", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -39,7 +39,7 @@ pub trait Finally<T> {\n     fn finally(&self, dtor: ||) -> T;\n }\n \n-impl<'a,T> Finally<T> for 'a || -> T {\n+impl<'a,T> Finally<T> for ||: 'a -> T {\n     fn finally(&self, dtor: ||) -> T {\n         try_finally(&mut (), (),\n                     |_, _| (*self)(),\n@@ -101,7 +101,7 @@ pub fn try_finally<T,U,R>(mutate: &mut T,\n \n struct Finallyalizer<'a,A> {\n     mutate: &'a mut A,\n-    dtor: 'a |&mut A|\n+    dtor: |&mut A|: 'a\n }\n \n #[unsafe_destructor]"}, {"sha": "f660d7ae97a99d38859b913e2367f05d38f72660", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -28,7 +28,7 @@ for it to terminate.\n The executing thread has no access to a task pointer and will be using\n a normal large stack.\n */\n-pub fn run_in_bare_thread(f: proc:Send()) {\n+pub fn run_in_bare_thread(f: proc():Send) {\n     use rt::thread::Thread;\n     Thread::start(f).join()\n }"}, {"sha": "3c5cdfcf94ec43762e97bf6990158b34ca060e98", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -1574,6 +1574,7 @@ mod tests {\n         assert_eq!(v, three)\n     }\n \n+    #[test]\n     fn test_grow_fn() {\n         let mut v = Vec::from_slice([0u, 1]);\n         v.grow_fn(3, |i| i);"}, {"sha": "ecfeade2fb43767a03f515717937e380bd12a036", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -124,12 +124,10 @@ impl<T: Share + Send> Clone for Arc<T> {\n     }\n }\n \n-// FIXME(#13042): this should have T: Send, and use self.inner()\n-impl<T> Deref<T> for Arc<T> {\n+impl<T: Send + Share> Deref<T> for Arc<T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        let inner = unsafe { &*self.x };\n-        &inner.data\n+        &self.inner().data\n     }\n }\n "}, {"sha": "ac4150a67e0ee037f16ed1913887a0e8808a790e", "filename": "src/libsync/future.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ffuture.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -34,7 +34,7 @@ pub struct Future<A> {\n }\n \n enum FutureState<A> {\n-    Pending(proc:Send() -> A),\n+    Pending(proc():Send -> A),\n     Evaluating,\n     Forced(A)\n }\n@@ -90,7 +90,7 @@ impl<A> Future<A> {\n         Future {state: Forced(val)}\n     }\n \n-    pub fn from_fn(f: proc:Send() -> A) -> Future<A> {\n+    pub fn from_fn(f: proc():Send -> A) -> Future<A> {\n         /*!\n          * Create a future from a function.\n          *\n@@ -117,7 +117,7 @@ impl<A:Send> Future<A> {\n         })\n     }\n \n-    pub fn spawn(blk: proc:Send() -> A) -> Future<A> {\n+    pub fn spawn(blk: proc():Send -> A) -> Future<A> {\n         /*!\n          * Create a future from a unique closure.\n          *"}, {"sha": "b83bdf9df299e0152b010bc552f23365d3e7c8bf", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -231,11 +231,10 @@ impl<T: Send> Mutex<T> {\n     }\n }\n \n-// FIXME(#13042): these should both have T: Send\n-impl<'a, T> Deref<T> for MutexGuard<'a, T> {\n+impl<'a, T: Send> Deref<T> for MutexGuard<'a, T> {\n     fn deref<'a>(&'a self) -> &'a T { &*self.data }\n }\n-impl<'a, T> DerefMut<T> for MutexGuard<'a, T> {\n+impl<'a, T: Send> DerefMut<T> for MutexGuard<'a, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self.data }\n }\n \n@@ -363,14 +362,13 @@ impl<'a, T: Send + Share> RWLockWriteGuard<'a, T> {\n     }\n }\n \n-// FIXME(#13042): these should all have T: Send + Share\n-impl<'a, T> Deref<T> for RWLockReadGuard<'a, T> {\n+impl<'a, T: Send + Share> Deref<T> for RWLockReadGuard<'a, T> {\n     fn deref<'a>(&'a self) -> &'a T { self.data }\n }\n-impl<'a, T> Deref<T> for RWLockWriteGuard<'a, T> {\n+impl<'a, T: Send + Share> Deref<T> for RWLockWriteGuard<'a, T> {\n     fn deref<'a>(&'a self) -> &'a T { &*self.data }\n }\n-impl<'a, T> DerefMut<T> for RWLockWriteGuard<'a, T> {\n+impl<'a, T: Send + Share> DerefMut<T> for RWLockWriteGuard<'a, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self.data }\n }\n "}, {"sha": "75e5d19b2e22d072eecbe312b488a6244fd83c53", "filename": "src/libsync/task_pool.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ftask_pool.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -16,7 +16,7 @@\n use std::task;\n \n enum Msg<T> {\n-    Execute(proc:Send(&T)),\n+    Execute(proc(&T):Send),\n     Quit\n }\n \n@@ -41,7 +41,7 @@ impl<T> TaskPool<T> {\n     /// returns a function which, given the index of the task, should return\n     /// local data to be kept around in that task.\n     pub fn new(n_tasks: uint,\n-               init_fn_factory: || -> proc:Send(uint) -> T)\n+               init_fn_factory: || -> proc(uint):Send -> T)\n                -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n@@ -73,7 +73,7 @@ impl<T> TaskPool<T> {\n \n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n-    pub fn execute(&mut self, f: proc:Send(&T)) {\n+    pub fn execute(&mut self, f: proc(&T):Send) {\n         self.channels.get(self.next_index).send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }\n@@ -82,8 +82,8 @@ impl<T> TaskPool<T> {\n \n #[test]\n fn test_task_pool() {\n-    let f: || -> proc:Send(uint) -> uint = || {\n-        let g: proc:Send(uint) -> uint = proc(i) i;\n+    let f: || -> proc(uint):Send -> uint = || {\n+        let g: proc(uint):Send -> uint = proc(i) i;\n         g\n     };\n     let mut pool = TaskPool::new(4, f);"}, {"sha": "ec9c02ac82a7317de602bebee26b8caea7353f89", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -613,7 +613,7 @@ pub trait EachViewItem {\n }\n \n struct EachViewItemData<'a> {\n-    callback: 'a |&ast::ViewItem| -> bool,\n+    callback: |&ast::ViewItem|: 'a -> bool,\n }\n \n impl<'a> Visitor<()> for EachViewItemData<'a> {"}, {"sha": "3bf1ed95f380ef1f95df75bca0b9b55c77c8b4aa", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -293,13 +293,12 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n \n pub struct MacroCrate {\n     pub lib: Option<Path>,\n-    pub cnum: ast::CrateNum,\n+    pub macros: Vec<~str>,\n+    pub registrar_symbol: Option<~str>,\n }\n \n pub trait CrateLoader {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate;\n-    fn get_exported_macros(&mut self, crate_num: ast::CrateNum) -> Vec<~str> ;\n-    fn get_registrar_symbol(&mut self, crate_num: ast::CrateNum) -> Option<~str>;\n }\n \n // One of these is made during expansion and incrementally updated as we go;"}, {"sha": "1dcb753624d83a63d28bada06e69d3faf8dbf0ac", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -303,18 +303,18 @@ Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n pub type CombineSubstructureFunc<'a> =\n-    'a |&mut ExtCtxt, Span, &Substructure| -> @Expr;\n+    |&mut ExtCtxt, Span, &Substructure|: 'a -> @Expr;\n \n /**\n Deal with non-matching enum variants, the arguments are a list\n representing each variant: (variant index, ast::Variant instance,\n [variant fields]), and a list of the nonself args of the type\n */\n pub type EnumNonMatchFunc<'a> =\n-    'a |&mut ExtCtxt,\n+    |&mut ExtCtxt,\n            Span,\n            &[(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, @Expr)> )],\n-           &[@Expr]|\n+           &[@Expr]|: 'a\n            -> @Expr;\n \n "}, {"sha": "1cff1d0f295e80f9ef60d0c6137bed7d47b0936b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -487,16 +487,16 @@ pub fn expand_view_item(vi: &ast::ViewItem,\n }\n \n fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n-    let MacroCrate { lib, cnum } = fld.cx.ecfg.loader.load_crate(krate);\n+    let MacroCrate { lib, macros, registrar_symbol } =\n+        fld.cx.ecfg.loader.load_crate(krate);\n \n     let crate_name = match krate.node {\n         ast::ViewItemExternCrate(name, _, _) => name,\n         _ => unreachable!()\n     };\n     let name = format!(\"<{} macros>\", token::get_ident(crate_name));\n \n-    let exported_macros = fld.cx.ecfg.loader.get_exported_macros(cnum);\n-    for source in exported_macros.iter() {\n+    for source in macros.iter() {\n         let item = parse::parse_item_from_source_str(name.clone(),\n                                                      (*source).clone(),\n                                                      fld.cx.cfg(),\n@@ -512,7 +512,7 @@ fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n     // Make sure the path contains a / or the linker will search for it.\n     let path = os::make_absolute(&path);\n \n-    let registrar = match fld.cx.ecfg.loader.get_registrar_symbol(cnum) {\n+    let registrar = match registrar_symbol {\n         Some(registrar) => registrar,\n         None => return\n     };\n@@ -1019,14 +1019,6 @@ mod test {\n         fn load_crate(&mut self, _: &ast::ViewItem) -> MacroCrate {\n             fail!(\"lolwut\")\n         }\n-\n-        fn get_exported_macros(&mut self, _: ast::CrateNum) -> Vec<~str> {\n-            fail!(\"lolwut\")\n-        }\n-\n-        fn get_registrar_symbol(&mut self, _: ast::CrateNum) -> Option<~str> {\n-            fail!(\"lolwut\")\n-        }\n     }\n \n     // these following tests are quite fragile, in that they don't test what"}, {"sha": "c8ea0b6aac283208ec3f6a0f475a4cfeecc4a279", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -905,31 +905,23 @@ impl<'a> Parser<'a> {\n \n         */\n \n-        // NOTE: remove after the next stage0 snap\n-        let (decl, lifetimes, bounds) = if self.token == token::COLON {\n-            let (_, bounds) = self.parse_optional_ty_param_bounds(false);\n-            let (decl, lifetimes) = self.parse_ty_fn_decl(false);\n-            (decl, lifetimes, bounds)\n+        let lifetimes = if self.eat(&token::LT) {\n+            let lifetimes = self.parse_lifetimes();\n+            self.expect_gt();\n+            lifetimes\n         } else {\n-            let lifetimes = if self.eat(&token::LT) {\n-                let lifetimes = self.parse_lifetimes();\n-                self.expect_gt();\n-                lifetimes\n-            } else {\n-                Vec::new()\n-            };\n-\n-            let (inputs, variadic) = self.parse_fn_args(false, false);\n-            let (_, bounds) = self.parse_optional_ty_param_bounds(false);\n-            let (ret_style, ret_ty) = self.parse_ret_ty();\n-            let decl = P(FnDecl {\n-                inputs: inputs,\n-                output: ret_ty,\n-                cf: ret_style,\n-                variadic: variadic\n-            });\n-            (decl, lifetimes, bounds)\n+            Vec::new()\n         };\n+\n+        let (inputs, variadic) = self.parse_fn_args(false, false);\n+        let (_, bounds) = self.parse_optional_ty_param_bounds(false);\n+        let (ret_style, ret_ty) = self.parse_ret_ty();\n+        let decl = P(FnDecl {\n+            inputs: inputs,\n+            output: ret_ty,\n+            cf: ret_style,\n+            variadic: variadic\n+        });\n         TyClosure(@ClosureTy {\n             sigil: OwnedSigil,\n             region: None,\n@@ -957,8 +949,6 @@ impl<'a> Parser<'a> {\n \n         */\n \n-        // NOTE: remove 'let region' after a stage0 snap\n-        let region = self.parse_opt_lifetime();\n         let purity = self.parse_unsafety();\n         let onceness = if self.eat_keyword(keywords::Once) {Once} else {Many};\n \n@@ -982,10 +972,7 @@ impl<'a> Parser<'a> {\n             inputs\n         };\n \n-        let (new_region, bounds) = self.parse_optional_ty_param_bounds(true);\n-\n-        // NOTE: this should be removed after a stage0 snap\n-        let region = new_region.or(region);\n+        let (region, bounds) = self.parse_optional_ty_param_bounds(true);\n \n         let (return_style, output) = self.parse_ret_ty();\n         let decl = P(FnDecl {\n@@ -1246,9 +1233,7 @@ impl<'a> Parser<'a> {\n         } else if self.token_is_closure_keyword() ||\n                 self.token == token::BINOP(token::OR) ||\n                 self.token == token::OROR ||\n-                self.token == token::LT ||\n-                // NOTE: remove this clause after a stage0 snap\n-                Parser::token_is_lifetime(&self.token) {\n+                self.token == token::LT {\n             // CLOSURE\n             //\n             // FIXME(pcwalton): Eventually `token::LT` will not unambiguously"}, {"sha": "5c74715fd2969df00348a384800ef577942bc5ce", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -123,7 +123,7 @@ pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut BenchHarness)),\n     StaticMetricFn(proc(&mut MetricMap)),\n-    DynTestFn(proc:Send()),\n+    DynTestFn(proc():Send),\n     DynMetricFn(proc(&mut MetricMap)),\n     DynBenchFn(~TDynBenchFn)\n }\n@@ -948,7 +948,7 @@ pub fn run_test(force_ignore: bool,\n     #[allow(deprecated_owned_vector)]\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: Sender<MonitorMsg>,\n-                      testfn: proc:Send()) {\n+                      testfn: proc():Send) {\n         spawn(proc() {\n             let (tx, rx) = channel();\n             let mut reader = ChanReader::new(rx);"}, {"sha": "748ca378e4d53ca0f5517b05b134d847bf98c926", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -394,14 +394,14 @@ impl<'a> Prep<'a> {\n     pub fn exec<'a, T:Send +\n         Encodable<json::Encoder<'a>, io::IoError> +\n         Decodable<json::Decoder, json::Error>>(\n-            &'a self, blk: proc:Send(&mut Exec) -> T) -> T {\n+            &'a self, blk: proc(&mut Exec):Send -> T) -> T {\n         self.exec_work(blk).unwrap()\n     }\n \n     fn exec_work<'a, T:Send +\n         Encodable<json::Encoder<'a>, io::IoError> +\n         Decodable<json::Decoder, json::Error>>( // FIXME(#5121)\n-            &'a self, blk: proc:Send(&mut Exec) -> T) -> Work<'a, T> {\n+            &'a self, blk: proc(&mut Exec):Send -> T) -> Work<'a, T> {\n         let mut bo = Some(blk);\n \n         debug!(\"exec_work: looking up {} and {:?}\", self.fn_name,"}, {"sha": "b8b198cb992109d09f82d7f36d74a854019e603b", "filename": "src/rt/sundown/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Frt%2Fsundown%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Frt%2Fsundown%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2FMakefile?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -16,7 +16,7 @@\n \n DEPDIR=depends\n \n-# \"Machine-dependant\" options\n+# \"Machine-dependent\" options\n #MFLAGS=-fPIC\n \n CFLAGS=-c -g -O3 -fPIC -Wall -Werror -Wsign-compare -Isrc -Ihtml"}, {"sha": "0e9f6d80369da4a60e54531de21b1358918493fd", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -1,3 +1,11 @@\n+S 2014-04-07 c7fac44\n+  freebsd-x86_64 3c01e2a52a1487c360a8e075df0d4fd412d84fe9\n+  linux-i386 145f83ec557db77160a207aa2a17e2db8e254b84\n+  linux-x86_64 647d2922311a497280d49e91e4946a271d44a232\n+  macos-i386 fa19ebca45f83e224911bad13475e40d531e6515\n+  macos-x86_64 c0b4df5eed015c527a2a23ca3f2755a44782f61d\n+  winnt-i386 e93af6e5ce88e1220f8b4b4cce14436af0b4279a\n+\n S 2014-04-03 e7fe207\n   freebsd-x86_64 6d40f547d13896ab9d9dd4a4fdf2e72be553b01b\n   linux-i386 875a8f6956f7d703f7206db91ca2a9b67c244cf8"}, {"sha": "96cb6c3273aaff84f966dfd369a833d6d081c79b", "filename": "src/test/auxiliary/iss.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fauxiliary%2Fiss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fauxiliary%2Fiss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fiss.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -13,7 +13,7 @@\n // part of issue-6919.rs\n \n struct C<'a> {\n-    pub k: 'a ||,\n+    pub k: ||: 'a,\n }\n \n fn no_op() { }"}, {"sha": "72d91ac645e2a5d2de8a2e6eef56ea49af1d4911", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -15,7 +15,7 @@ use std::os;\n fn start(n_tasks: int, token: int) {\n     let (tx, mut rx) = channel();\n     tx.send(token);\n-    //  XXX could not get this to work with a range closure\n+    //  FIXME could not get this to work with a range closure\n     let mut i = 2;\n     while i <= n_tasks {\n         let (tx, next_rx) = channel();"}, {"sha": "951354d964d9f43cfea1963dbd1baf5e00fb0145", "filename": "src/test/compile-fail/closure-bounds-cant-promote-superkind-in-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n struct X {\n-    field: 'static ||:Send,\n+    field: ||:'static + Send,\n }\n \n-fn foo(blk: 'static ||:) -> X {\n-    return X { field: blk }; //~ ERROR expected bounds `Send` but found no bounds\n+fn foo(blk: ||:'static) -> X {\n+    return X { field: blk }; //~ ERROR expected bounds `'static+Send`\n }\n \n fn main() {"}, {"sha": "08ff575f63bfbfd2a862325e6a9bc8f2ffb3a095", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -10,7 +10,7 @@\n \n fn id<T>(t: T) -> T { t }\n \n-fn f<'r, T>(v: &'r T) -> 'r || -> T {\n+fn f<'r, T>(v: &'r T) -> ||: 'r -> T {\n     id(|| *v) //~ ERROR cannot infer\n }\n "}, {"sha": "026327a358a46c90843eee929a9249b9d17f4289", "filename": "src/test/compile-fail/issue-4523.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -10,7 +10,7 @@\n \n fn foopy() {}\n \n-static f: 'static || = foopy; //~ ERROR found extern fn\n+static f: ||: 'static = foopy; //~ ERROR found extern fn\n \n fn main () {\n     f();"}, {"sha": "8fe9694b0cb46b57b2c195401bf0e08b2135b22c", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -14,8 +14,8 @@ fn foo(_x: @uint) {}\n \n fn main() {\n     let x = @3u;\n-    let _: proc:Send() = proc() foo(x); //~ ERROR does not fulfill `Send`\n-    let _: proc:Send() = proc() foo(x); //~ ERROR does not fulfill `Send`\n-    let _: proc:Send() = proc() foo(x); //~ ERROR does not fulfill `Send`\n+    let _: proc():Send = proc() foo(x); //~ ERROR does not fulfill `Send`\n+    let _: proc():Send = proc() foo(x); //~ ERROR does not fulfill `Send`\n+    let _: proc():Send = proc() foo(x); //~ ERROR does not fulfill `Send`\n     let _: proc() = proc() foo(x);\n }"}, {"sha": "e9053b46bbbf17ce3a32ff0c361719e5c6ebe80a", "filename": "src/test/compile-fail/moves-based-on-type-no-recursive-stack-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -16,7 +16,7 @@ struct R<'a> {\n     // This struct is needed to create the\n     // otherwise infinite type of a fn that\n     // accepts itself as argument:\n-    c: 'a |&R, bool|\n+    c: |&R, bool|: 'a\n }\n \n fn innocent_looking_victim() {"}, {"sha": "0875212b7dee35b296368a01e300c33d623ef85b", "filename": "src/test/compile-fail/proc-bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fproc-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fproc-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fproc-bounds.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -13,13 +13,13 @@ fn is_freeze<T: Share>() {}\n fn is_static<T: 'static>() {}\n \n fn main() {\n-    is_send::<proc:()>();\n+    is_send::<proc()>();\n     //~^ ERROR: instantiating a type parameter with an incompatible type\n \n-    is_freeze::<proc:()>();\n+    is_freeze::<proc()>();\n     //~^ ERROR: instantiating a type parameter with an incompatible type\n \n-    is_static::<proc:()>();\n+    is_static::<proc()>();\n     //~^ ERROR: instantiating a type parameter with an incompatible type\n }\n "}, {"sha": "e9ef23ebe09e839186857c98f0725b87e95fa677", "filename": "src/test/compile-fail/regionck-closure-lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn env<'a>(_: &'a uint, blk: |p: 'a |||) {\n+fn env<'a>(_: &'a uint, blk: |p: ||: 'a|) {\n     // Test that the closure here cannot be assigned\n     // the lifetime `'a`, which outlives the current\n     // block.\n@@ -21,7 +21,7 @@ fn env<'a>(_: &'a uint, blk: |p: 'a |||) {\n     blk(|| *statep = 1); //~ ERROR cannot infer\n }\n \n-fn no_env_no_for<'a>(_: &'a uint, blk: |p: 'a |||) {\n+fn no_env_no_for<'a>(_: &'a uint, blk: |p: |||: 'a) {\n     // Test that a closure with no free variables CAN\n     // outlive the block in which it is created.\n     //"}, {"sha": "285e11fa9a2e1ee40e4b425ca0f41c33b095b240", "filename": "src/test/compile-fail/regions-freevar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn wants_static_fn(_x: 'static ||) {}\n+fn wants_static_fn(_x: ||: 'static) {}\n \n fn main() {\n     let i = 3;"}, {"sha": "4c883656d61a5d4e8b7b70e39c25632360c325b8", "filename": "src/test/compile-fail/regions-infer-at-fn-not-param.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n struct parameterized1<'a> {\n-    g: 'a ||\n+    g: ||: 'a\n }\n \n struct not_parameterized1 {\n-    g: 'static ||\n+    g: ||: 'static\n }\n \n struct not_parameterized2 {\n-    g: 'static ||\n+    g: ||: 'static\n }\n \n fn take1(p: parameterized1) -> parameterized1 { p }"}, {"sha": "53d013c0e6b8cc7f3924f4a2cc711419a26621b6", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -11,7 +11,7 @@\n #![feature(managed_boxes)]\n \n struct invariant<'a> {\n-    f: 'static |x: &mut &'a int|\n+    f: |x: &mut &'a int|: 'static\n }\n \n fn to_same_lifetime<'r>(bi: invariant<'r>) {"}, {"sha": "edab5b219911e82fd1713ae385792318188339a5", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -11,7 +11,7 @@\n #![feature(managed_boxes)]\n \n struct invariant<'a> {\n-    f: 'static || -> &mut &'a int\n+    f: ||: 'static -> &mut &'a int\n }\n \n fn to_same_lifetime<'r>(bi: invariant<'r>) {"}, {"sha": "86f98d5cc3515b4de3cd7ebf8b04b2c13ee62865", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -14,12 +14,12 @@ struct direct<'a> {\n \n struct indirect1 {\n     // Here the lifetime parameter of direct is bound by the fn()\n-    g: 'static |direct|\n+    g: |direct|: 'static\n }\n \n struct indirect2<'a> {\n     // But here it is set to 'a\n-    g: 'static |direct<'a>|\n+    g: |direct<'a>|: 'static\n }\n \n fn take_direct(p: direct) -> direct { p } //~ ERROR mismatched types"}, {"sha": "7ffc6a75cff8ca9ac9d5a8b48a3d5fecf355f45b", "filename": "src/test/compile-fail/regions-steal-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n struct closure_box<'a> {\n-    cl: 'a ||\n+    cl: ||: 'a\n }\n \n-fn box_it<'r>(x: 'r ||) -> closure_box<'r> {\n+fn box_it<'r>(x: ||: 'r) -> closure_box<'r> {\n     closure_box {cl: x}\n }\n "}, {"sha": "8c8e789cd9640058bfb45cc1f4584ece0c9963e1", "filename": "src/test/compile-fail/vec-macro-with-comma-only.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    vec!(,); //~ ERROR unexpected token\n+}"}, {"sha": "c02d3f0e07630edd64ef550b7b4d9ccb0f187837", "filename": "src/test/debug-info/recursive-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fdebug-info%2Frecursive-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Fdebug-info%2Frecursive-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Frecursive-enum.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -26,7 +26,7 @@ struct WindowCallbacks<'a> {\n     pos_callback: Option<WindowPosCallback<'a>>,\n }\n \n-pub type WindowPosCallback<'a> = 'a |&Window, i32, i32|;\n+pub type WindowPosCallback<'a> = |&Window, i32, i32|: 'a;\n \n fn main() {\n     let x = WindowCallbacks { pos_callback: None };"}, {"sha": "da4210b9fa8ccbc94b8609ccb3d4f6c921274627", "filename": "src/test/run-fail/unwind-box-fn-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -18,7 +18,7 @@ fn failfn() {\n \n fn main() {\n     let y = ~0;\n-    let x: @proc:Send() = @(proc() {\n+    let x: @proc():Send = @(proc() {\n         println!(\"{:?}\", y.clone());\n     });\n     failfn();"}, {"sha": "f544d474c4fe783dbe2059692e9d642e2fabc3f7", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -16,7 +16,7 @@ fn main() {\n     let cheese = ~\"roquefort\";\n     let carrots = @~\"crunchy\";\n \n-    let result: 'static |@~str, |~str|| = (|tasties, macerate| {\n+    let result: |@~str, |~str||: 'static = (|tasties, macerate| {\n         macerate((*tasties).clone());\n     });\n     result(carrots, |food| {"}, {"sha": "038c0418ecb4cf660cbfb40f7b8dce13c921b760", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -18,7 +18,7 @@ struct Pair {\n pub fn main() {\n     let z = ~Pair { a : 10, b : 12};\n \n-    let f: proc:Send() = proc() {\n+    let f: proc():Send = proc() {\n         assert_eq!(z.a, 10);\n         assert_eq!(z.b, 12);\n     };"}, {"sha": "983cd00f39cb8f1339d7e152528e93542966283a", "filename": "src/test/run-pass/closure-syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -61,15 +61,15 @@ fn bar<'b>() {\n     foo::<proc<'a>(int, f32, &'a int):'static + Share -> &'a int>();\n \n     // issue #11209\n-    let _: 'b ||; // for comparison\n+    let _: ||: 'b; // for comparison\n     let _: <'a> ||;\n \n     let _: Option<||:'b>;\n     // let _: Option<<'a>||>;\n     let _: Option< <'a>||>;\n \n     // issue #11210\n-    let _: 'static ||;\n+    let _: ||: 'static;\n }\n \n pub fn main() {"}, {"sha": "a5fc8425cf6b0da8a287ad2e28674e6bfad9d452", "filename": "src/test/run-pass/empty-allocation-rvalue-non-null.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fempty-allocation-rvalue-non-null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fempty-allocation-rvalue-non-null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-allocation-rvalue-non-null.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    let x = *~();\n+}"}, {"sha": "2bf846fe3419ca59e0d586e3124c31fe07ac1b8f", "filename": "src/test/run-pass/issue-11881.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate ser = \"serialize\";\n+\n+use serialize = self::ser;\n+ //necessary for deriving(Encodable)\n+use ser::{Encodable, Encoder};\n+use ser::json;\n+use ser::ebml::writer;\n+use std::io::MemWriter;\n+use std::str::from_utf8_owned;\n+\n+#[deriving(Encodable)]\n+struct Foo {\n+    baz: bool,\n+}\n+\n+#[deriving(Encodable)]\n+struct Bar {\n+    froboz: uint,\n+}\n+\n+enum WireProtocol {\n+    JSON,\n+    EBML,\n+    // ...\n+}\n+\n+fn encode_json<'a,\n+               T: Encodable<json::Encoder<'a>,\n+                            std::io::IoError>>(val: &T,\n+                                               wr: &'a mut MemWriter) {\n+    let mut encoder = json::Encoder::new(wr);\n+    val.encode(&mut encoder);\n+}\n+fn encode_ebml<'a,\n+               T: Encodable<writer::Encoder<'a, MemWriter>,\n+                            std::io::IoError>>(val: &T,\n+                                               wr: &'a mut MemWriter) {\n+    let mut encoder = writer::Encoder(wr);\n+    val.encode(&mut encoder);\n+}\n+\n+pub fn main() {\n+    let target = Foo{baz: false,};\n+    let mut wr = MemWriter::new();\n+    let proto = JSON;\n+    match proto {\n+        JSON => encode_json(&target, &mut wr),\n+        EBML => encode_ebml(&target, &mut wr)\n+    }\n+}"}, {"sha": "20bd8e51a48ca7ab42f28fae5f9a0fc413079230", "filename": "src/test/run-pass/issue-13304.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast\n+\n+extern crate green;\n+extern crate rustuv;\n+extern crate native;\n+\n+use std::os;\n+use std::io;\n+use std::str;\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    green::start(argc, argv, rustuv::event_loop, main)\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    if args.len() > 1 && args[1].as_slice() == \"child\" {\n+        if args[2].as_slice() == \"green\" {\n+            child();\n+        } else {\n+            let (tx, rx) = channel();\n+            native::task::spawn(proc() { tx.send(child()); });\n+            rx.recv();\n+        }\n+    } else {\n+        parent(~\"green\");\n+        parent(~\"native\");\n+        let (tx, rx) = channel();\n+        native::task::spawn(proc() {\n+            parent(~\"green\");\n+            parent(~\"native\");\n+            tx.send(());\n+        });\n+        rx.recv();\n+    }\n+}\n+\n+fn parent(flavor: ~str) {\n+    let args = os::args();\n+    let mut p = io::Process::new(args[0].as_slice(), [~\"child\", flavor]).unwrap();\n+    p.stdin.get_mut_ref().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n+    let out = p.wait_with_output();\n+    assert!(out.status.success());\n+    let s = str::from_utf8(out.output.as_slice()).unwrap();\n+    assert_eq!(s, \"test1\\n\\ntest2\\n\\ntest3\\n\");\n+}\n+\n+fn child() {\n+    for line in io::stdin().lines() {\n+        println!(\"{}\", line.unwrap());\n+    }\n+}"}, {"sha": "3aaa480d776c23845ab8b86a26c5630ff0e56d30", "filename": "src/test/run-pass/issue-1516.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fissue-1516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fissue-1516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1516.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub fn main() {\n-    let early_error: 'static |&str| -> ! = |_msg| { fail!() };\n+    let early_error: |&str|: 'static -> ! = |_msg| { fail!() };\n }"}, {"sha": "c8735e79e502c296429ddf5290ec692f556f0cc9", "filename": "src/test/run-pass/issue-2190-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -12,13 +12,13 @@ use std::task;\n \n static generations: uint = 1024+256+128+49;\n \n-fn spawn(f: proc:Send()) {\n+fn spawn(f: proc():Send) {\n     let mut t = task::task();\n     t.opts.stack_size = Some(32 * 1024);\n     t.spawn(f);\n }\n \n-fn child_no(x: uint) -> proc:Send() {\n+fn child_no(x: uint) -> proc():Send {\n     proc() {\n         if x < generations {\n             spawn(child_no(x+1));"}, {"sha": "95bbf77024c8fa178d21ac1aaa834956595044f2", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -11,7 +11,7 @@\n use std::task;\n \n type RingBuffer = Vec<f64> ;\n-type SamplesFn = proc:Send(samples: &RingBuffer);\n+type SamplesFn = proc(samples: &RingBuffer):Send;\n \n enum Msg\n {"}, {"sha": "ec26dc0b3ed360d1c482b768308abebc50eef92b", "filename": "src/test/run-pass/last-use-in-cap-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -12,10 +12,10 @@\n \n struct A { a: ~int }\n \n-fn foo() -> 'static || -> int {\n+fn foo() -> ||: 'static -> int {\n     let k = ~22;\n     let _u = A {a: k.clone()};\n-    let result: 'static || -> int = || 22;\n+    let result: ||: 'static -> int = || 22;\n     result\n }\n "}, {"sha": "c103e087363967585a2743666f833e652864236c", "filename": "src/test/run-pass/proc-bounds.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fproc-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fproc-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fproc-bounds.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -17,18 +17,18 @@ fn is_static<T: 'static>() {}\n \n pub fn main() {\n     foo::<proc()>();\n-    foo::<proc:()>();\n-    foo::<proc:Send()>();\n-    foo::<proc:Send + Share()>();\n-    foo::<proc:'static + Send + Share()>();\n+    foo::<proc()>();\n+    foo::<proc():Send>();\n+    foo::<proc():Send + Share>();\n+    foo::<proc():'static + Send + Share>();\n \n-    is_send::<proc:Send()>();\n-    is_freeze::<proc:Share()>();\n-    is_static::<proc:'static()>();\n+    is_send::<proc():Send>();\n+    is_freeze::<proc():Share>();\n+    is_static::<proc():'static>();\n \n \n     let a = 3;\n-    bar::<proc:()>(proc() {\n+    bar::<proc():>(proc() {\n         let b = &a;\n         println!(\"{}\", *b);\n     });"}, {"sha": "a62c1ec33146bfa0a56910e3db0f41074c9e1b86", "filename": "src/test/run-pass/sendfn-spawn-with-fn-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -18,7 +18,7 @@ fn test05_start(f: proc(int)) {\n \n fn test05() {\n     let three = ~3;\n-    let fn_to_send: proc:Send(int) = proc(n) {\n+    let fn_to_send: proc(int):Send = proc(n) {\n         println!(\"{}\", *three + n); // will copy x into the closure\n         assert_eq!(*three, 3);\n     };"}, {"sha": "437d6faea3854cea53a480763648168522fc7eee", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -35,7 +35,7 @@ fn test_tempdir() {\n \n fn test_rm_tempdir() {\n     let (tx, rx) = channel();\n-    let f: proc:Send() = proc() {\n+    let f: proc():Send = proc() {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n         tx.send(tmp.path().clone());\n         fail!(\"fail to unwind past `tmp`\");\n@@ -46,7 +46,7 @@ fn test_rm_tempdir() {\n \n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n     let path = tmp.path().clone();\n-    let f: proc:Send() = proc() {\n+    let f: proc():Send = proc() {\n         let _tmp = tmp;\n         fail!(\"fail to unwind past `tmp`\");\n     };"}, {"sha": "3c164d3e2dab599ff3fcd707007ded864aea223e", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -19,10 +19,10 @@ enum maybe_pointy {\n \n struct Pointy {\n     a : maybe_pointy,\n-    d : proc:Send() -> uint,\n+    d : proc():Send -> uint,\n }\n \n-fn make_uniq_closure<A:Send>(a: A) -> proc:Send() -> uint {\n+fn make_uniq_closure<A:Send>(a: A) -> proc():Send -> uint {\n     proc() { &a as *A as uint }\n }\n "}, {"sha": "6c273199c6f7c71e359e5e0193a9341c587d8f32", "filename": "src/test/run-pass/uniq-cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -20,7 +20,7 @@ enum maybe_pointy {\n struct Pointy {\n     a : maybe_pointy,\n     c : ~int,\n-    d : proc:Send()->(),\n+    d : proc():Send->(),\n }\n \n fn empty_pointy() -> @RefCell<Pointy> {"}, {"sha": "07033d60497477c51630ba9f1ca231ae991cae53", "filename": "src/test/run-pass/vec-macro-with-trailing-comma.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fvec-macro-with-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f51211eddbbaf6c6e02cecc78957ce1d5b4600/src%2Ftest%2Frun-pass%2Fvec-macro-with-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-macro-with-trailing-comma.rs?ref=02f51211eddbbaf6c6e02cecc78957ce1d5b4600", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub fn main() {\n+    assert_eq!(vec!(1), vec!(1,));\n+    assert_eq!(vec!(1, 2, 3), vec!(1, 2, 3,));\n+}"}]}