{"sha": "2cca2567d9a39f159e392c47c8be6d94087242c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjY2EyNTY3ZDlhMzlmMTU5ZTM5MmM0N2M4YmU2ZDk0MDg3MjQyYzk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-18T15:50:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-28T09:49:52Z"}, "message": "make `ty` and `impl_trait_ref` private\n\nThis requires copying out the cycle error to avoid a cyclic borrow.  Is\nthis a problem? Are there paths where we expect cycles to arise and not\nresult in errors? (In such cases, we could add a faster way to test for\ncycle.)", "tree": {"sha": "84c6643505b8547118278a24ef4446c2bc00b806", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84c6643505b8547118278a24ef4446c2bc00b806"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cca2567d9a39f159e392c47c8be6d94087242c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cca2567d9a39f159e392c47c8be6d94087242c9", "html_url": "https://github.com/rust-lang/rust/commit/2cca2567d9a39f159e392c47c8be6d94087242c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cca2567d9a39f159e392c47c8be6d94087242c9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ac7eb8649a499177a2931221d77677e905100d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac7eb8649a499177a2931221d77677e905100d0", "html_url": "https://github.com/rust-lang/rust/commit/1ac7eb8649a499177a2931221d77677e905100d0"}], "stats": {"total": 98, "additions": 68, "deletions": 30}, "files": [{"sha": "16d5d1187fc8bf5de52ee2b6cd934f5e709f8896", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2cca2567d9a39f159e392c47c8be6d94087242c9/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cca2567d9a39f159e392c47c8be6d94087242c9/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=2cca2567d9a39f159e392c47c8be6d94087242c9", "patch": "@@ -13,16 +13,19 @@ use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::symbol::Symbol;\n+use syntax_pos::DUMMY_SP;\n \n use std::cell::Cell;\n \n thread_local! {\n-    static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false)\n+    static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false);\n+    static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n }\n \n-/// Enforces that item_path_str always returns an absolute path.\n-/// This is useful when building symbols that contain types,\n-/// where we want the crate name to be part of the symbol.\n+/// Enforces that item_path_str always returns an absolute path and\n+/// also enables \"type-based\" impl paths. This is used when building\n+/// symbols that contain types, where we want the crate name to be\n+/// part of the symbol.\n pub fn with_forced_absolute_paths<F: FnOnce() -> R, R>(f: F) -> R {\n     FORCE_ABSOLUTE.with(|force| {\n         let old = force.get();\n@@ -33,6 +36,20 @@ pub fn with_forced_absolute_paths<F: FnOnce() -> R, R>(f: F) -> R {\n     })\n }\n \n+/// Force us to name impls with just the filename/line number. We\n+/// normally try to use types. But at some points, notably while printing\n+/// cycle errors, this can result in extra or suboptimal error output,\n+/// so this variable disables that check.\n+pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n+    FORCE_IMPL_FILENAME_LINE.with(|force| {\n+        let old = force.get();\n+        force.set(true);\n+        let result = f();\n+        force.set(old);\n+        result\n+    })\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It is relative to the current crate\n@@ -199,14 +216,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n \n-        let use_types = if !impl_def_id.is_local() {\n-            // always have full types available for extern crates\n-            true\n-        } else {\n-            // for local crates, check whether type info is\n-            // available; typeck might not have completed yet\n-            self.maps.impl_trait_ref.borrow().contains_key(&impl_def_id) &&\n-                self.maps.type_of.borrow().contains_key(&impl_def_id)\n+        // Always use types for non-local impls, where types are always\n+        // available, and filename/line-number is mostly uninteresting.\n+        let use_types = !impl_def_id.is_local() || {\n+            // Otherwise, use filename/line-number if forced.\n+            let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n+            !force_no_types && {\n+                // Otherwise, use types if we can query them without inducing a cycle.\n+                ty::queries::impl_trait_ref::try_get(self, DUMMY_SP, impl_def_id).is_ok() &&\n+                    ty::queries::type_of::try_get(self, DUMMY_SP, impl_def_id).is_ok()\n+            }\n         };\n \n         if !use_types {"}, {"sha": "93f3916d1b5011a57fd62ff32f316ddcb51e5280", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2cca2567d9a39f159e392c47c8be6d94087242c9/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cca2567d9a39f159e392c47c8be6d94087242c9/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=2cca2567d9a39f159e392c47c8be6d94087242c9", "patch": "@@ -17,11 +17,13 @@ use middle::privacy::AccessLevels;\n use mir;\n use session::CompileResult;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use ty::item_path;\n use ty::subst::Substs;\n use util::nodemap::NodeSet;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n+use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -139,24 +141,36 @@ pub struct CycleError<'a, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_cycle(self, CycleError { span, cycle }: CycleError) {\n-        assert!(!cycle.is_empty());\n-\n-        let mut err = struct_span_err!(self.sess, span, E0391,\n-            \"unsupported cyclic reference between types/traits detected\");\n-        err.span_label(span, &format!(\"cyclic reference\"));\n-\n-        err.span_note(cycle[0].0, &format!(\"the cycle begins when {}...\",\n-                                           cycle[0].1.describe(self)));\n-\n-        for &(span, ref query) in &cycle[1..] {\n-            err.span_note(span, &format!(\"...which then requires {}...\",\n-                                         query.describe(self)));\n-        }\n+        // Subtle: release the refcell lock before invoking `describe()`\n+        // below by dropping `cycle`.\n+        let stack = cycle.to_vec();\n+        mem::drop(cycle);\n+\n+        assert!(!stack.is_empty());\n+\n+        // Disable naming impls with types in this path, since that\n+        // sometimes cycles itself, leading to extra cycle errors.\n+        // (And cycle errors around impls tend to occur during the\n+        // collect/coherence phases anyhow.)\n+        item_path::with_forced_impl_filename_line(|| {\n+            let mut err =\n+                struct_span_err!(self.sess, span, E0391,\n+                                 \"unsupported cyclic reference between types/traits detected\");\n+            err.span_label(span, &format!(\"cyclic reference\"));\n+\n+            err.span_note(stack[0].0, &format!(\"the cycle begins when {}...\",\n+                                               stack[0].1.describe(self)));\n+\n+            for &(span, ref query) in &stack[1..] {\n+                err.span_note(span, &format!(\"...which then requires {}...\",\n+                                             query.describe(self)));\n+            }\n \n-        err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n-                          cycle[0].1.describe(self)));\n+            err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n+                              stack[0].1.describe(self)));\n \n-        err.emit();\n+            err.emit();\n+        });\n     }\n \n     fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n@@ -335,6 +349,11 @@ macro_rules! define_maps {\n                                   -> Result<R, CycleError<'a, $tcx>>\n                 where F: FnOnce(&$V) -> R\n             {\n+                debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n+                       stringify!($name),\n+                       key,\n+                       span);\n+\n                 if let Some(result) = tcx.maps.$name.borrow().get(&key) {\n                     return Ok(f(result));\n                 }\n@@ -441,7 +460,7 @@ macro_rules! define_maps {\n // the driver creates (using several `rustc_*` crates).\n define_maps! { <'tcx>\n     /// Records the type of every item.\n-    [pub] type_of: ItemSignature(DefId) -> Ty<'tcx>,\n+    [] type_of: ItemSignature(DefId) -> Ty<'tcx>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n@@ -480,7 +499,7 @@ define_maps! { <'tcx>\n     /// Maps from a trait item to the trait item \"descriptor\"\n     [] associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n \n-    [pub] impl_trait_ref: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n+    [] impl_trait_ref: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n     [] impl_polarity: ItemSignature(DefId) -> hir::ImplPolarity,\n \n     /// Maps a DefId of a type to a list of its inherent impls."}]}