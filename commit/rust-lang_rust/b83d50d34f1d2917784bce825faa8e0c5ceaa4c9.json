{"sha": "b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4M2Q1MGQzNGYxZDI5MTc3ODRiY2U4MjVmYWE4ZTBjNWNlYWE0Yzk=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2019-11-17T04:36:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-17T04:36:12Z"}, "message": "Rollup merge of #66271 - petrochenkov:abism, r=Centril\n\nsyntax: Keep string literals in ABIs and `asm!` more precisely\n\nAs a result we don't lose spans when `extern` functions or blocks are passed to proc macros, and also escape all string literals consistently.\nContinuation of https://github.com/rust-lang/rust/pull/60679, which did a similar thing with all literals besides those in ABIs and `asm!`.\n\nTODO: Add tests.\n\nFixes https://github.com/rust-lang/rust/issues/60493\nFixes https://github.com/rust-lang/rust/issues/64561\nr? @Centril", "tree": {"sha": "e24f56e7a2716e3236f16a52cbe9f84338c18557", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e24f56e7a2716e3236f16a52cbe9f84338c18557"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd0M48CRBK7hj4Ov3rIwAAdHIIABgeN+4qInO6IM43TXPt6KCJ\nJ5M5Mejo66QI9NMS7J8+DUgXuxgBP1lo76YWydfouoKoJtgY59kYejmqRAk4gcam\nOunI43YKfe2O3usO3bkZN/eFrVcu/nc09pzYBK0XXDB6dy0dhm1uuhjZMqVDujKk\nhDCAa9sEmUsJIXhV3V6fKHyBXB/ZY9LqXofwtyznHLXooSdGOFeLAOm1NhJYLTsW\nNsV8i3uaJjowFH9f29eH++ZATuMFNrxaAMz5nVshRsbIa5pKYm9luei7dJ7hzNa4\nj0skvJ87Hsq7297u3IMR2Rv20mDMLlHBW2hRwUMPEesqu5i8vu8DViBxbbqWmJ0=\n=bp3U\n-----END PGP SIGNATURE-----\n", "payload": "tree e24f56e7a2716e3236f16a52cbe9f84338c18557\nparent d8f252670322466af43ba9eb8c81c1151671e070\nparent 28aec1beaa5e16b17143f993cab408debe1dcda5\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1573965372 +0900\ncommitter GitHub <noreply@github.com> 1573965372 +0900\n\nRollup merge of #66271 - petrochenkov:abism, r=Centril\n\nsyntax: Keep string literals in ABIs and `asm!` more precisely\n\nAs a result we don't lose spans when `extern` functions or blocks are passed to proc macros, and also escape all string literals consistently.\nContinuation of https://github.com/rust-lang/rust/pull/60679, which did a similar thing with all literals besides those in ABIs and `asm!`.\n\nTODO: Add tests.\n\nFixes https://github.com/rust-lang/rust/issues/60493\nFixes https://github.com/rust-lang/rust/issues/64561\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "html_url": "https://github.com/rust-lang/rust/commit/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8f252670322466af43ba9eb8c81c1151671e070", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8f252670322466af43ba9eb8c81c1151671e070", "html_url": "https://github.com/rust-lang/rust/commit/d8f252670322466af43ba9eb8c81c1151671e070"}, {"sha": "28aec1beaa5e16b17143f993cab408debe1dcda5", "url": "https://api.github.com/repos/rust-lang/rust/commits/28aec1beaa5e16b17143f993cab408debe1dcda5", "html_url": "https://github.com/rust-lang/rust/commit/28aec1beaa5e16b17143f993cab408debe1dcda5"}], "stats": {"total": 448, "additions": 271, "deletions": 177}, "files": [{"sha": "12f6f66e96b50cc038d380c4ee5791bf6cf8267d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -1219,7 +1219,7 @@ impl<'a> LoweringContext<'a> {\n                                     ImplTraitContext::disallowed(),\n                                 ),\n                                 unsafety: f.unsafety,\n-                                abi: this.lower_abi(f.abi),\n+                                abi: this.lower_extern(f.ext),\n                                 decl: this.lower_fn_decl(&f.decl, None, false, None),\n                                 param_names: this.lower_fn_params_to_names(&f.decl),\n                             }))"}, {"sha": "f689e7f96222f18242fdaa6f57baf1732da8ed56", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -735,7 +735,7 @@ impl LoweringContext<'_> {\n \n     fn lower_foreign_mod(&mut self, fm: &ForeignMod) -> hir::ForeignMod {\n         hir::ForeignMod {\n-            abi: self.lower_abi(fm.abi),\n+            abi: fm.abi.map_or(abi::Abi::C, |abi| self.lower_abi(abi)),\n             items: fm.items\n                 .iter()\n                 .map(|x| self.lower_foreign_item(x))\n@@ -1283,18 +1283,26 @@ impl LoweringContext<'_> {\n             unsafety: h.unsafety,\n             asyncness: self.lower_asyncness(h.asyncness.node),\n             constness: h.constness.node,\n-            abi: self.lower_abi(h.abi),\n+            abi: self.lower_extern(h.ext),\n         }\n     }\n \n-    pub(super) fn lower_abi(&mut self, abi: Abi) -> abi::Abi {\n-        abi::lookup(&abi.symbol.as_str()).unwrap_or_else(|| {\n+    pub(super) fn lower_abi(&mut self, abi: StrLit) -> abi::Abi {\n+        abi::lookup(&abi.symbol_unescaped.as_str()).unwrap_or_else(|| {\n             self.error_on_invalid_abi(abi);\n             abi::Abi::Rust\n         })\n     }\n \n-    fn error_on_invalid_abi(&self, abi: Abi) {\n+    pub(super) fn lower_extern(&mut self, ext: Extern) -> abi::Abi {\n+        match ext {\n+            Extern::None => abi::Abi::Rust,\n+            Extern::Implicit => abi::Abi::C,\n+            Extern::Explicit(abi) => self.lower_abi(abi),\n+        }\n+    }\n+\n+    fn error_on_invalid_abi(&self, abi: StrLit) {\n         struct_span_err!(\n             self.sess,\n             abi.span,"}, {"sha": "a56a7bf1802c77b8b70f5b1d30324b9b7f335e06", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -778,13 +778,12 @@ impl<'a> Parser<'a> {\n \n         macro_rules! parse_lit {\n             () => {\n-                match self.parse_lit() {\n-                    Ok(literal) => {\n+                match self.parse_opt_lit() {\n+                    Some(literal) => {\n                         hi = self.prev_span;\n                         ex = ExprKind::Lit(literal);\n                     }\n-                    Err(mut err) => {\n-                        err.cancel();\n+                    None => {\n                         return Err(self.expected_expression_found());\n                     }\n                 }\n@@ -1074,11 +1073,39 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n-    /// Matches `lit = true | false | token_lit`.\n+    /// Returns a string literal if the next token is a string literal.\n+    /// In case of error returns `Some(lit)` if the next token is a literal with a wrong kind,\n+    /// and returns `None` if the next token is not literal at all.\n+    pub fn parse_str_lit(&mut self) -> Result<ast::StrLit, Option<Lit>> {\n+        match self.parse_opt_lit() {\n+            Some(lit) => match lit.kind {\n+                ast::LitKind::Str(symbol_unescaped, style) => Ok(ast::StrLit {\n+                    style,\n+                    symbol: lit.token.symbol,\n+                    suffix: lit.token.suffix,\n+                    span: lit.span,\n+                    symbol_unescaped,\n+                }),\n+                _ => Err(Some(lit)),\n+            }\n+            None => Err(None),\n+        }\n+    }\n+\n     pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n+        self.parse_opt_lit().ok_or_else(|| {\n+            let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n+            self.span_fatal(self.token.span, &msg)\n+        })\n+    }\n+\n+    /// Matches `lit = true | false | token_lit`.\n+    /// Returns `None` if the next token is not a literal.\n+    pub(super) fn parse_opt_lit(&mut self) -> Option<Lit> {\n         let mut recovered = None;\n         if self.token == token::Dot {\n-            // Attempt to recover `.4` as `0.4`.\n+            // Attempt to recover `.4` as `0.4`. We don't currently have any syntax where\n+            // dot would follow an optional literal, so we do this unconditionally.\n             recovered = self.look_ahead(1, |next_token| {\n                 if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix })\n                         = next_token.kind {\n@@ -1107,11 +1134,10 @@ impl<'a> Parser<'a> {\n         match Lit::from_token(token) {\n             Ok(lit) => {\n                 self.bump();\n-                Ok(lit)\n+                Some(lit)\n             }\n             Err(LitError::NotLiteral) => {\n-                let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n-                Err(self.span_fatal(token.span, &msg))\n+                None\n             }\n             Err(err) => {\n                 let span = token.span;\n@@ -1120,18 +1146,18 @@ impl<'a> Parser<'a> {\n                     _ => unreachable!(),\n                 };\n                 self.bump();\n-                self.error_literal_from_token(err, lit, span);\n+                self.report_lit_error(err, lit, span);\n                 // Pack possible quotes and prefixes from the original literal into\n                 // the error literal's symbol so they can be pretty-printed faithfully.\n                 let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n                 let symbol = Symbol::intern(&suffixless_lit.to_string());\n                 let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n-                Lit::from_lit_token(lit, span).map_err(|_| unreachable!())\n+                Some(Lit::from_lit_token(lit, span).unwrap_or_else(|_| unreachable!()))\n             }\n         }\n     }\n \n-    fn error_literal_from_token(&self, err: LitError, lit: token::Lit, span: Span) {\n+    fn report_lit_error(&self, err: LitError, lit: token::Lit, span: Span) {\n         // Checks if `s` looks like i32 or u1234 etc.\n         fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n             s.len() > 1"}, {"sha": "20b96d5cd62f6a6060fd7303526afe1d8ff1c31b", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -3,9 +3,9 @@ use super::diagnostics::{Error, dummy_arg, ConsumeClosingDelim};\n \n use crate::maybe_whole;\n \n-use syntax::ast::{self, Abi, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n+use syntax::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n use syntax::ast::{ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n-use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness};\n+use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness, Extern, StrLit};\n use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n use syntax::ast::{Ty, TyKind, Generics, TraitRef, EnumDef, VariantData, StructField};\n use syntax::ast::{Mac, MacDelimiter, Block, BindingMode, FnDecl, FnSig, SelfKind, Param};\n@@ -105,7 +105,7 @@ impl<'a> Parser<'a> {\n                 return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n             }\n \n-            let abi = self.parse_opt_abi()?;\n+            let abi = self.parse_abi();\n \n             if self.eat_keyword(kw::Fn) {\n                 // EXTERN FUNCTION ITEM\n@@ -114,7 +114,7 @@ impl<'a> Parser<'a> {\n                     unsafety: Unsafety::Normal,\n                     asyncness: respan(fn_span, IsAsync::NotAsync),\n                     constness: respan(fn_span, Constness::NotConst),\n-                    abi,\n+                    ext: Extern::from_abi(abi),\n                 };\n                 return self.parse_item_fn(lo, vis, attrs, header);\n             } else if self.check(&token::OpenDelim(token::Brace)) {\n@@ -143,14 +143,14 @@ impl<'a> Parser<'a> {\n                 if self.check_keyword(kw::Extern) {\n                     self.sess.gated_spans.gate(sym::const_extern_fn, lo.to(self.token.span));\n                 }\n-                let abi = self.parse_extern_abi()?;\n+                let ext = self.parse_extern()?;\n                 self.bump(); // `fn`\n \n                 let header = FnHeader {\n                     unsafety,\n                     asyncness: respan(const_span, IsAsync::NotAsync),\n                     constness: respan(const_span, Constness::Const),\n-                    abi,\n+                    ext,\n                 };\n                 return self.parse_item_fn(lo, vis, attrs, header);\n             }\n@@ -193,7 +193,7 @@ impl<'a> Parser<'a> {\n                     unsafety,\n                     asyncness,\n                     constness: respan(fn_span, Constness::NotConst),\n-                    abi: Abi::new(sym::Rust, fn_span),\n+                    ext: Extern::None,\n                 };\n                 return self.parse_item_fn(lo, vis, attrs, header);\n             }\n@@ -230,7 +230,7 @@ impl<'a> Parser<'a> {\n                 unsafety: Unsafety::Normal,\n                 asyncness: respan(fn_span, IsAsync::NotAsync),\n                 constness: respan(fn_span, Constness::NotConst),\n-                abi: Abi::new(sym::Rust, fn_span),\n+                ext: Extern::None,\n             };\n             return self.parse_item_fn(lo, vis, attrs, header);\n         }\n@@ -242,14 +242,14 @@ impl<'a> Parser<'a> {\n             self.bump(); // `unsafe`\n             // `{` is also expected after `unsafe`; in case of error, include it in the diagnostic.\n             self.check(&token::OpenDelim(token::Brace));\n-            let abi = self.parse_extern_abi()?;\n+            let ext = self.parse_extern()?;\n             self.expect_keyword(kw::Fn)?;\n             let fn_span = self.prev_span;\n             let header = FnHeader {\n                 unsafety: Unsafety::Unsafe,\n                 asyncness: respan(fn_span, IsAsync::NotAsync),\n                 constness: respan(fn_span, Constness::NotConst),\n-                abi,\n+                ext,\n             };\n             return self.parse_item_fn(lo, vis, attrs, header);\n         }\n@@ -1100,7 +1100,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_foreign_mod(\n         &mut self,\n         lo: Span,\n-        abi: Abi,\n+        abi: Option<StrLit>,\n         visibility: Visibility,\n         mut attrs: Vec<Attribute>,\n         extern_sp: Span,\n@@ -1775,9 +1775,16 @@ impl<'a> Parser<'a> {\n         attrs: Vec<Attribute>,\n         header: FnHeader,\n     ) -> PResult<'a, Option<P<Item>>> {\n+        let is_c_abi = match header.ext {\n+            ast::Extern::None => false,\n+            ast::Extern::Implicit => true,\n+            ast::Extern::Explicit(abi) => abi.symbol_unescaped == sym::C,\n+        };\n         let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n             is_self_allowed: false,\n-            allow_c_variadic: header.abi.symbol == sym::C && header.unsafety == Unsafety::Unsafe,\n+            // FIXME: Parsing should not depend on ABI or unsafety and\n+            // the variadic parameter should always be parsed.\n+            allow_c_variadic: is_c_abi && header.unsafety == Unsafety::Unsafe,\n             is_name_required: |_| true,\n         })?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n@@ -1905,19 +1912,19 @@ impl<'a> Parser<'a> {\n         }\n         let asyncness = respan(self.prev_span, asyncness);\n         let unsafety = self.parse_unsafety();\n-        let (constness, unsafety, abi) = if is_const_fn {\n-            (respan(const_span, Constness::Const), unsafety, Abi::default())\n+        let (constness, unsafety, ext) = if is_const_fn {\n+            (respan(const_span, Constness::Const), unsafety, Extern::None)\n         } else {\n-            let abi = self.parse_extern_abi()?;\n-            (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n+            let ext = self.parse_extern()?;\n+            (respan(self.prev_span, Constness::NotConst), unsafety, ext)\n         };\n         if !self.eat_keyword(kw::Fn) {\n             // It is possible for `expect_one_of` to recover given the contents of\n             // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n             // account for this.\n             if !self.expect_one_of(&[], &[])? { unreachable!() }\n         }\n-        Ok(FnHeader { constness, unsafety, asyncness, abi })\n+        Ok(FnHeader { constness, unsafety, asyncness, ext })\n     }\n \n     /// Parse the \"signature\", including the identifier, parameters, and generics of a function."}, {"sha": "d5ec46114980659ad45b76ce1ae95ec76b08b710", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 15, "deletions": 49, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -15,8 +15,8 @@ use crate::{Directory, DirectoryOwnership};\n use crate::lexer::UnmatchedBrace;\n \n use syntax::ast::{\n-    self, Abi, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Ident,\n-    IsAsync, MacDelimiter, Mutability, StrStyle, Visibility, VisibilityKind, Unsafety,\n+    self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Extern, Ident, StrLit,\n+    IsAsync, MacDelimiter, Mutability, Visibility, VisibilityKind, Unsafety,\n };\n \n use syntax::print::pprust;\n@@ -1212,40 +1212,34 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `extern string_literal?`.\n-    /// If `extern` is not found, the Rust ABI is used.\n-    /// If `extern` is found and a `string_literal` does not follow, the C ABI is used.\n-    fn parse_extern_abi(&mut self) -> PResult<'a, Abi> {\n+    fn parse_extern(&mut self) -> PResult<'a, Extern> {\n         Ok(if self.eat_keyword(kw::Extern) {\n-            self.parse_opt_abi()?\n+            Extern::from_abi(self.parse_abi())\n         } else {\n-            Abi::default()\n+            Extern::None\n         })\n     }\n \n     /// Parses a string literal as an ABI spec.\n-    /// If one is not found, the \"C\" ABI is used.\n-    fn parse_opt_abi(&mut self) -> PResult<'a, Abi> {\n-        let span = if self.token.can_begin_literal_or_bool() {\n-            let ast::Lit { span, kind, .. } = self.parse_lit()?;\n-            match kind {\n-                ast::LitKind::Str(symbol, _) => return Ok(Abi::new(symbol, span)),\n-                ast::LitKind::Err(_) => {}\n+    fn parse_abi(&mut self) -> Option<StrLit> {\n+        match self.parse_str_lit() {\n+            Ok(str_lit) => Some(str_lit),\n+            Err(Some(lit)) => match lit.kind {\n+                ast::LitKind::Err(_) => None,\n                 _ => {\n-                    self.struct_span_err(span, \"non-string ABI literal\")\n+                    self.struct_span_err(lit.span, \"non-string ABI literal\")\n                         .span_suggestion(\n-                            span,\n+                            lit.span,\n                             \"specify the ABI with a string literal\",\n                             \"\\\"C\\\"\".to_string(),\n                             Applicability::MaybeIncorrect,\n                         )\n                         .emit();\n+                    None\n                 }\n             }\n-            span\n-        } else {\n-            self.prev_span\n-        };\n-        Ok(Abi::new(sym::C, span))\n+            Err(None) => None,\n+        }\n     }\n \n     /// We are parsing `async fn`. If we are on Rust 2015, emit an error.\n@@ -1337,34 +1331,6 @@ impl<'a> Parser<'a> {\n             self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace) ||\n                                    *t == token::BinOp(token::Star))\n     }\n-\n-    fn parse_optional_str(&mut self) -> Option<(Symbol, ast::StrStyle, Option<ast::Name>)> {\n-        let ret = match self.token.kind {\n-            token::Literal(token::Lit { kind: token::Str, symbol, suffix }) =>\n-                (symbol, ast::StrStyle::Cooked, suffix),\n-            token::Literal(token::Lit { kind: token::StrRaw(n), symbol, suffix }) =>\n-                (symbol, ast::StrStyle::Raw(n), suffix),\n-            _ => return None\n-        };\n-        self.bump();\n-        Some(ret)\n-    }\n-\n-    pub fn parse_str(&mut self) -> PResult<'a, (Symbol, StrStyle)> {\n-        match self.parse_optional_str() {\n-            Some((s, style, suf)) => {\n-                let sp = self.prev_span;\n-                self.expect_no_suffix(sp, \"a string literal\", suf);\n-                Ok((s, style))\n-            }\n-            _ => {\n-                let msg = \"expected string literal\";\n-                let mut err = self.fatal(msg);\n-                err.span_label(self.token.span, msg);\n-                Err(err)\n-            }\n-        }\n-    }\n }\n \n crate fn make_unclosed_delims_error("}, {"sha": "8e6bc29be521803e02472068d1eb97148690df80", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -287,7 +287,7 @@ impl<'a> Parser<'a> {\n         */\n \n         let unsafety = self.parse_unsafety();\n-        let abi = self.parse_extern_abi()?;\n+        let ext = self.parse_extern()?;\n         self.expect_keyword(kw::Fn)?;\n         let cfg = ParamCfg {\n             is_self_allowed: false,\n@@ -296,7 +296,7 @@ impl<'a> Parser<'a> {\n         };\n         let decl = self.parse_fn_decl(cfg, false)?;\n         Ok(TyKind::BareFn(P(BareFnTy {\n-            abi,\n+            ext,\n             unsafety,\n             generic_params,\n             decl,"}, {"sha": "255938a193c9763fafc7a7b5d3997c0dba507d14", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -30,9 +30,8 @@ use crate::{id_from_def_id, id_from_node_id, SaveContext};\n use rls_data::{SigElement, Signature};\n \n use rustc::hir::def::{Res, DefKind};\n-use syntax::ast::{self, NodeId};\n+use syntax::ast::{self, Extern, NodeId};\n use syntax::print::pprust;\n-use syntax_pos::sym;\n \n pub fn item_signature(item: &ast::Item, scx: &SaveContext<'_, '_>) -> Option<Signature> {\n     if !scx.config.signatures {\n@@ -157,9 +156,11 @@ fn text_sig(text: String) -> Signature {\n     }\n }\n \n-fn push_abi(text: &mut String, abi: ast::Abi) {\n-    if abi.symbol != sym::Rust {\n-        text.push_str(&format!(\"extern \\\"{}\\\" \", abi.symbol));\n+fn push_extern(text: &mut String, ext: Extern) {\n+    match ext {\n+        Extern::None => {}\n+        Extern::Implicit => text.push_str(\"extern \"),\n+        Extern::Explicit(abi) => text.push_str(&format!(\"extern \\\"{}\\\" \", abi.symbol)),\n     }\n }\n \n@@ -237,7 +238,7 @@ impl Sig for ast::Ty {\n                 if f.unsafety == ast::Unsafety::Unsafe {\n                     text.push_str(\"unsafe \");\n                 }\n-                push_abi(&mut text, f.abi);\n+                push_extern(&mut text, f.ext);\n                 text.push_str(\"fn(\");\n \n                 let mut defs = vec![];\n@@ -387,7 +388,7 @@ impl Sig for ast::Item {\n                 if header.unsafety == ast::Unsafety::Unsafe {\n                     text.push_str(\"unsafe \");\n                 }\n-                push_abi(&mut text, header.abi);\n+                push_extern(&mut text, header.ext);\n                 text.push_str(\"fn \");\n \n                 let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n@@ -936,7 +937,7 @@ fn make_method_signature(\n     if m.header.unsafety == ast::Unsafety::Unsafe {\n         text.push_str(\"unsafe \");\n     }\n-    push_abi(&mut text, m.header.abi);\n+    push_extern(&mut text, m.header.ext);\n     text.push_str(\"fn \");\n \n     let mut sig = name_and_generics(text, 0, generics, id, ident, scx)?;"}, {"sha": "bbf00825acb3376874e809690c022a4edb79e796", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -1422,6 +1422,33 @@ pub struct Lit {\n     pub span: Span,\n }\n \n+/// Same as `Lit`, but restricted to string literals.\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub struct StrLit {\n+    /// The original literal token as written in source code.\n+    pub style: StrStyle,\n+    pub symbol: Symbol,\n+    pub suffix: Option<Symbol>,\n+    pub span: Span,\n+    /// The unescaped \"semantic\" representation of the literal lowered from the original token.\n+    /// FIXME: Remove this and only create the semantic representation during lowering to HIR.\n+    pub symbol_unescaped: Symbol,\n+}\n+\n+impl StrLit {\n+    crate fn as_lit(&self) -> Lit {\n+        let token_kind = match self.style {\n+            StrStyle::Cooked => token::Str,\n+            StrStyle::Raw(n) => token::StrRaw(n),\n+        };\n+        Lit {\n+            token: token::Lit::new(token_kind, self.symbol, self.suffix),\n+            span: self.span,\n+            kind: LitKind::Str(self.symbol_unescaped, self.style),\n+        }\n+    }\n+}\n+\n // Clippy uses Hash and PartialEq\n /// Type of the integer literal based on provided suffix.\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, Hash, PartialEq)]\n@@ -1745,7 +1772,7 @@ pub struct Ty {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n-    pub abi: Abi,\n+    pub ext: Extern,\n     pub generic_params: Vec<GenericParam>,\n     pub decl: P<FnDecl>,\n }\n@@ -2128,7 +2155,7 @@ pub struct Mod {\n /// E.g., `extern { .. }` or `extern C { .. }`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ForeignMod {\n-    pub abi: Abi,\n+    pub abi: Option<StrLit>,\n     pub items: Vec<ForeignItem>,\n }\n \n@@ -2411,24 +2438,17 @@ impl Item {\n     }\n }\n \n-/// A reference to an ABI.\n-///\n-/// In AST our notion of an ABI is still syntactic unlike in `rustc_target::spec::abi::Abi`.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, PartialEq)]\n-pub struct Abi {\n-    pub symbol: Symbol,\n-    pub span: Span,\n-}\n-\n-impl Abi {\n-    pub fn new(symbol: Symbol, span: Span) -> Self {\n-        Self { symbol, span }\n-    }\n+/// `extern` qualifier on a function item or function type.\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub enum Extern {\n+    None,\n+    Implicit,\n+    Explicit(StrLit),\n }\n \n-impl Default for Abi {\n-    fn default() -> Self {\n-        Self::new(sym::Rust, DUMMY_SP)\n+impl Extern {\n+    pub fn from_abi(abi: Option<StrLit>) -> Extern {\n+        abi.map_or(Extern::Implicit, Extern::Explicit)\n     }\n }\n \n@@ -2441,7 +2461,7 @@ pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub asyncness: Spanned<IsAsync>,\n     pub constness: Spanned<Constness>,\n-    pub abi: Abi,\n+    pub ext: Extern,\n }\n \n impl Default for FnHeader {\n@@ -2450,7 +2470,7 @@ impl Default for FnHeader {\n             unsafety: Unsafety::Normal,\n             asyncness: dummy_spanned(IsAsync::NotAsync),\n             constness: dummy_spanned(Constness::NotConst),\n-            abi: Abi::default(),\n+            ext: Extern::None,\n         }\n     }\n }"}, {"sha": "abf9adefd3c44328d1c0bc2e957fde7478089a90", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -191,10 +191,10 @@ macro_rules! gate_feature_post {\n }\n \n impl<'a> PostExpansionVisitor<'a> {\n-    fn check_abi(&self, abi: ast::Abi) {\n-        let ast::Abi { symbol, span } = abi;\n+    fn check_abi(&self, abi: ast::StrLit) {\n+        let ast::StrLit { symbol_unescaped, span, .. } = abi;\n \n-        match &*symbol.as_str() {\n+        match &*symbol_unescaped.as_str() {\n             // Stable\n             \"Rust\" |\n             \"C\" |\n@@ -258,6 +258,12 @@ impl<'a> PostExpansionVisitor<'a> {\n         }\n     }\n \n+    fn check_extern(&self, ext: ast::Extern) {\n+        if let ast::Extern::Explicit(abi) = ext {\n+            self.check_abi(abi);\n+        }\n+    }\n+\n     fn maybe_report_invalid_custom_discriminants(&self, variants: &[ast::Variant]) {\n         let has_fields = variants.iter().any(|variant| match variant.data {\n             VariantData::Tuple(..) | VariantData::Struct(..) => true,\n@@ -388,7 +394,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_item(&mut self, i: &'a ast::Item) {\n         match i.kind {\n             ast::ItemKind::ForeignMod(ref foreign_module) => {\n-                self.check_abi(foreign_module.abi);\n+                if let Some(abi) = foreign_module.abi {\n+                    self.check_abi(abi);\n+                }\n             }\n \n             ast::ItemKind::Fn(..) => {\n@@ -511,7 +519,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_ty(&mut self, ty: &'a ast::Ty) {\n         match ty.kind {\n             ast::TyKind::BareFn(ref bare_fn_ty) => {\n-                self.check_abi(bare_fn_ty.abi);\n+                self.check_extern(bare_fn_ty.ext);\n             }\n             ast::TyKind::Never => {\n                 gate_feature_post!(&self, never_type, ty.span,\n@@ -605,7 +613,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             // Stability of const fn methods are covered in\n             // `visit_trait_item` and `visit_impl_item` below; this is\n             // because default methods don't pass through this point.\n-            self.check_abi(header.abi);\n+            self.check_extern(header.ext);\n         }\n \n         if fn_decl.c_variadic() {\n@@ -639,7 +647,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match ti.kind {\n             ast::TraitItemKind::Method(ref sig, ref block) => {\n                 if block.is_none() {\n-                    self.check_abi(sig.header.abi);\n+                    self.check_extern(sig.header.ext);\n                 }\n                 if sig.decl.c_variadic() {\n                     gate_feature_post!(&self, c_variadic, ti.span,"}, {"sha": "da3c885b8609dc9e389ca0c24b8014276bb5793a", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -441,7 +441,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n             vis.visit_mt(mt);\n         }\n         TyKind::BareFn(bft) => {\n-            let BareFnTy { unsafety: _, abi: _, generic_params, decl } = bft.deref_mut();\n+            let BareFnTy { unsafety: _, ext: _, generic_params, decl } = bft.deref_mut();\n             generic_params.flat_map_in_place(|param| vis.flat_map_generic_param(param));\n             vis.visit_fn_decl(decl);\n         }\n@@ -974,7 +974,7 @@ pub fn noop_flat_map_impl_item<T: MutVisitor>(mut item: ImplItem, visitor: &mut\n }\n \n pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n-    let FnHeader { unsafety: _, asyncness, constness: _, abi: _ } = header;\n+    let FnHeader { unsafety: _, asyncness, constness: _, ext: _ } = header;\n     vis.visit_asyncness(&mut asyncness.node);\n }\n "}, {"sha": "17a7cbddff9cc3e420eb87c68b577e745f0766ab", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -1013,7 +1013,7 @@ impl<'a> State<'a> {\n                 self.pclose();\n             }\n             ast::TyKind::BareFn(ref f) => {\n-                self.print_ty_fn(f.abi,\n+                self.print_ty_fn(f.ext,\n                                  f.unsafety,\n                                  &f.decl,\n                                  None,\n@@ -1232,7 +1232,10 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n                 self.head(\"extern\");\n-                self.print_abi(nmod.abi);\n+                if let Some(abi) = nmod.abi {\n+                    self.print_literal(&abi.as_lit());\n+                    self.nbsp();\n+                }\n                 self.bopen();\n                 self.print_foreign_mod(nmod, &item.attrs);\n                 self.bclose(item.span);\n@@ -2805,7 +2808,7 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_ty_fn(&mut self,\n-                       abi: ast::Abi,\n+                       ext: ast::Extern,\n                        unsafety: ast::Unsafety,\n                        decl: &ast::FnDecl,\n                        name: Option<ast::Ident>,\n@@ -2825,7 +2828,7 @@ impl<'a> State<'a> {\n             span: syntax_pos::DUMMY_SP,\n         };\n         self.print_fn(decl,\n-                      ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n+                      ast::FnHeader { unsafety, ext, ..ast::FnHeader::default() },\n                       name,\n                       &generics,\n                       &source_map::dummy_spanned(ast::VisibilityKind::Inherited));\n@@ -2866,18 +2869,21 @@ impl<'a> State<'a> {\n         self.print_asyncness(header.asyncness.node);\n         self.print_unsafety(header.unsafety);\n \n-        if header.abi.symbol != sym::Rust {\n-            self.word_nbsp(\"extern\");\n-            self.print_abi(header.abi);\n+        match header.ext {\n+            ast::Extern::None => {}\n+            ast::Extern::Implicit => {\n+                self.word_nbsp(\"extern\");\n+            }\n+            ast::Extern::Explicit(abi) => {\n+                self.word_nbsp(\"extern\");\n+                self.print_literal(&abi.as_lit());\n+                self.nbsp();\n+            }\n         }\n \n         self.s.word(\"fn\")\n     }\n \n-    fn print_abi(&mut self, abi: ast::Abi) {\n-        self.word_nbsp(format!(\"\\\"{}\\\"\", abi.symbol));\n-    }\n-\n     crate fn print_unsafety(&mut self, s: ast::Unsafety) {\n         match s {\n             ast::Unsafety::Normal => {},"}, {"sha": "bd345a9a7dada11c83573e30517fcf0d5e3a412e", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -2,19 +2,17 @@\n //\n use State::*;\n \n+use errors::{DiagnosticBuilder, PResult};\n use rustc_data_structures::thin_vec::ThinVec;\n-\n-use errors::DiagnosticBuilder;\n-\n-use syntax::ast;\n-use syntax_expand::base::{self, *};\n-use syntax::token::{self, Token};\n+use rustc_parse::parser::Parser;\n+use syntax_expand::base::*;\n+use syntax_pos::Span;\n+use syntax::{span_err, struct_span_err};\n+use syntax::ast::{self, AsmDialect};\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym, Symbol};\n-use syntax::ast::AsmDialect;\n-use syntax_pos::Span;\n+use syntax::token::{self, Token};\n use syntax::tokenstream::{self, TokenStream};\n-use syntax::{span_err, struct_span_err};\n \n use rustc_error_codes::*;\n \n@@ -45,7 +43,7 @@ const OPTIONS: &[Symbol] = &[sym::volatile, sym::alignstack, sym::intel];\n pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                        sp: Span,\n                        tts: TokenStream)\n-                       -> Box<dyn base::MacResult + 'cx> {\n+                       -> Box<dyn MacResult + 'cx> {\n     let mut inline_asm = match parse_inline_asm(cx, sp, tts) {\n         Ok(Some(inline_asm)) => inline_asm,\n         Ok(None) => return DummyResult::any(sp),\n@@ -69,6 +67,18 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n     }))\n }\n \n+fn parse_asm_str<'a>(p: &mut Parser<'a>) -> PResult<'a, Symbol> {\n+    match p.parse_str_lit() {\n+        Ok(str_lit) => Ok(str_lit.symbol_unescaped),\n+        Err(opt_lit) => {\n+            let span = opt_lit.map_or(p.token.span, |lit| lit.span);\n+            let mut err = p.sess.span_diagnostic.struct_span_err(span, \"expected string literal\");\n+            err.span_label(span, \"not a string literal\");\n+            Err(err)\n+        }\n+    }\n+}\n+\n fn parse_inline_asm<'a>(\n     cx: &mut ExtCtxt<'a>,\n     sp: Span,\n@@ -144,7 +154,7 @@ fn parse_inline_asm<'a>(\n                         p.eat(&token::Comma);\n                     }\n \n-                    let (constraint, _) = p.parse_str()?;\n+                    let constraint = parse_asm_str(&mut p)?;\n \n                     let span = p.prev_span;\n \n@@ -189,7 +199,7 @@ fn parse_inline_asm<'a>(\n                         p.eat(&token::Comma);\n                     }\n \n-                    let (constraint, _) = p.parse_str()?;\n+                    let constraint = parse_asm_str(&mut p)?;\n \n                     if constraint.as_str().starts_with(\"=\") {\n                         span_err!(cx, p.prev_span, E0662,\n@@ -212,7 +222,7 @@ fn parse_inline_asm<'a>(\n                         p.eat(&token::Comma);\n                     }\n \n-                    let (s, _) = p.parse_str()?;\n+                    let s = parse_asm_str(&mut p)?;\n \n                     if OPTIONS.iter().any(|&opt| s == opt) {\n                         cx.span_warn(p.prev_span, \"expected a clobber, found an option\");\n@@ -225,7 +235,7 @@ fn parse_inline_asm<'a>(\n                 }\n             }\n             Options => {\n-                let (option, _) = p.parse_str()?;\n+                let option = parse_asm_str(&mut p)?;\n \n                 if option == sym::volatile {\n                     // Indicates that the inline assembly has side effects"}, {"sha": "b6bf2f881616f1163d508c932d729eb44f23e49d", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -182,7 +182,7 @@ use std::iter;\n use std::vec;\n \n use rustc_data_structures::thin_vec::ThinVec;\n-use syntax::ast::{self, Abi, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n+use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n use syntax::ast::{VariantData, GenericParamKind, GenericArg};\n use syntax::attr;\n use syntax::source_map::respan;\n@@ -737,7 +737,6 @@ impl<'a> TraitDef<'a> {\n                                          self,\n                                          type_ident,\n                                          generics,\n-                                         sym::Rust,\n                                          explicit_self,\n                                          tys,\n                                          body)\n@@ -792,7 +791,6 @@ impl<'a> TraitDef<'a> {\n                                          self,\n                                          type_ident,\n                                          generics,\n-                                         sym::Rust,\n                                          explicit_self,\n                                          tys,\n                                          body)\n@@ -918,7 +916,6 @@ impl<'a> MethodDef<'a> {\n                      trait_: &TraitDef<'_>,\n                      type_ident: Ident,\n                      generics: &Generics,\n-                     abi: Symbol,\n                      explicit_self: Option<ast::ExplicitSelf>,\n                      arg_types: Vec<(Ident, P<ast::Ty>)>,\n                      body: P<Expr>)\n@@ -953,7 +950,7 @@ impl<'a> MethodDef<'a> {\n         let sig = ast::FnSig {\n             header: ast::FnHeader {\n                 unsafety,\n-                abi: Abi::new(abi, trait_lo_sp),\n+                ext: ast::Extern::None,\n                 ..ast::FnHeader::default()\n             },\n             decl: fn_decl,"}, {"sha": "86eaeeab5a426ec4b27199860928c336a5268f54", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -570,7 +570,6 @@ symbols! {\n         rust_2018_preview,\n         rust_begin_unwind,\n         rustc,\n-        Rust,\n         RustcDecodable,\n         RustcEncodable,\n         rustc_allocator,"}, {"sha": "8d464e752e637172c42230300e1b61e0872f7389", "filename": "src/test/ui/asm/asm-literal-escaping.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Ftest%2Fui%2Fasm%2Fasm-literal-escaping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Ftest%2Fui%2Fasm%2Fasm-literal-escaping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fasm-literal-escaping.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -0,0 +1,12 @@\n+// build-pass\n+// only-x86_64\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    unsafe {\n+        // \"nop\" :: \"r\"(x) : \"eax\" : \"volatile\"\n+        let x = 10;\n+        asm!(\"\\x6Eop\" :: \"\\x72\"(x) : \"\\x65ax\" : \"\\x76olatile\");\n+    }\n+}"}, {"sha": "2b29332fef5e524adcec3bc4ecf2c0b19faa5ba6", "filename": "src/test/ui/asm/asm-parse-errors.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Ftest%2Fui%2Fasm%2Fasm-parse-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Ftest%2Fui%2Fasm%2Fasm-parse-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fasm-parse-errors.stderr?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -8,13 +8,13 @@ error: expected string literal\n   --> $DIR/asm-parse-errors.rs:5:18\n    |\n LL |     asm!(\"nop\" : struct);\n-   |                  ^^^^^^ expected string literal\n+   |                  ^^^^^^ not a string literal\n \n error: expected string literal\n   --> $DIR/asm-parse-errors.rs:6:30\n    |\n LL |     asm!(\"mov %eax, $$0x2\" : struct);\n-   |                              ^^^^^^ expected string literal\n+   |                              ^^^^^^ not a string literal\n \n error: expected `(`, found keyword `struct`\n   --> $DIR/asm-parse-errors.rs:7:39\n@@ -32,7 +32,7 @@ error: expected string literal\n   --> $DIR/asm-parse-errors.rs:9:44\n    |\n LL |     asm!(\"in %dx, %al\" : \"={al}\"(result) : struct);\n-   |                                            ^^^^^^ expected string literal\n+   |                                            ^^^^^^ not a string literal\n \n error: expected `(`, found keyword `struct`\n   --> $DIR/asm-parse-errors.rs:10:51\n@@ -50,13 +50,13 @@ error: expected string literal\n   --> $DIR/asm-parse-errors.rs:12:36\n    |\n LL |     asm!(\"mov $$0x200, %eax\" : : : struct);\n-   |                                    ^^^^^^ expected string literal\n+   |                                    ^^^^^^ not a string literal\n \n error: expected string literal\n   --> $DIR/asm-parse-errors.rs:13:45\n    |\n LL |     asm!(\"mov eax, 2\" : \"={eax}\"(foo) : : : struct);\n-   |                                             ^^^^^^ expected string literal\n+   |                                             ^^^^^^ not a string literal\n \n error: inline assembly must be a string literal\n   --> $DIR/asm-parse-errors.rs:14:10"}, {"sha": "b22e50c4c1715d785de19052c1593d884219b40b", "filename": "src/test/ui/proc-macro/span-preservation.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.rs?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -1,9 +1,8 @@\n-//~ ERROR mismatched types\n-// aux-build:test-macros.rs\n-\n // For each of these, we should get the appropriate type mismatch error message,\n // and the function should be echoed.\n \n+// aux-build:test-macros.rs\n+\n #[macro_use]\n extern crate test_macros;\n \n@@ -35,17 +34,24 @@ fn c() {\n     let y = Foo { a: 10, b: 10isize }; //~ ERROR has no field named `b`\n }\n \n-// FIXME: This doesn't work at the moment. See the one below. The pretty-printer\n-// injects a \"C\" between `extern` and `fn` which causes a \"probably_eq\"\n-// `TokenStream` mismatch. The lack of `\"C\"` should be preserved in the AST.\n #[recollect_attr]\n extern fn bar() {\n-    0\n+    0 //~ ERROR mismatched types\n }\n \n #[recollect_attr]\n extern \"C\" fn baz() {\n     0 //~ ERROR mismatched types\n }\n \n+#[recollect_attr]\n+extern \"Rust\" fn rust_abi() {\n+    0 //~ ERROR mismatched types\n+}\n+\n+#[recollect_attr]\n+extern \"\\x43\" fn c_abi_escaped() {\n+    0 //~ ERROR mismatched types\n+}\n+\n fn main() {}"}, {"sha": "545c2fa5f40e4ab193ef031e1dde6a49f40655b9", "filename": "src/test/ui/proc-macro/span-preservation.stderr", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b83d50d34f1d2917784bce825faa8e0c5ceaa4c9/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr?ref=b83d50d34f1d2917784bce825faa8e0c5ceaa4c9", "patch": "@@ -1,10 +1,5 @@\n error[E0308]: mismatched types\n-   |\n-   = note: expected type `()`\n-              found type `{integer}`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/span-preservation.rs:12:20\n+  --> $DIR/span-preservation.rs:11:20\n    |\n LL |     let x: usize = \"hello\";\n    |                    ^^^^^^^ expected usize, found reference\n@@ -13,7 +8,7 @@ LL |     let x: usize = \"hello\";\n               found type `&'static str`\n \n error[E0308]: mismatched types\n-  --> $DIR/span-preservation.rs:18:29\n+  --> $DIR/span-preservation.rs:17:29\n    |\n LL | fn b(x: Option<isize>) -> usize {\n    |                           ----- expected `usize` because of return type\n@@ -22,21 +17,32 @@ LL |         Some(x) => { return x },\n    |                             ^ expected usize, found isize\n \n error[E0308]: mismatched types\n-  --> $DIR/span-preservation.rs:34:22\n+  --> $DIR/span-preservation.rs:33:22\n    |\n LL |     let x = Foo { a: 10isize };\n    |                      ^^^^^^^ expected usize, found isize\n \n error[E0560]: struct `c::Foo` has no field named `b`\n-  --> $DIR/span-preservation.rs:35:26\n+  --> $DIR/span-preservation.rs:34:26\n    |\n LL |     let y = Foo { a: 10, b: 10isize };\n    |                          ^ `c::Foo` does not have this field\n    |\n    = note: available fields are: `a`\n \n error[E0308]: mismatched types\n-  --> $DIR/span-preservation.rs:48:5\n+  --> $DIR/span-preservation.rs:39:5\n+   |\n+LL | extern fn bar() {\n+   |                 - possibly return type missing here?\n+LL |     0\n+   |     ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/span-preservation.rs:44:5\n    |\n LL | extern \"C\" fn baz() {\n    |                     - possibly return type missing here?\n@@ -46,7 +52,29 @@ LL |     0\n    = note: expected type `()`\n               found type `{integer}`\n \n-error: aborting due to 6 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/span-preservation.rs:49:5\n+   |\n+LL | extern \"Rust\" fn rust_abi() {\n+   |                             - possibly return type missing here?\n+LL |     0\n+   |     ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/span-preservation.rs:54:5\n+   |\n+LL | extern \"\\x43\" fn c_abi_escaped() {\n+   |                                  - possibly return type missing here?\n+LL |     0\n+   |     ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error: aborting due to 8 previous errors\n \n Some errors have detailed explanations: E0308, E0560.\n For more information about an error, try `rustc --explain E0308`."}]}