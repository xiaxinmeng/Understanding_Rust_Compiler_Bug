{"sha": "4d66b65850cba7302c79c031f9fa61e7162aca43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNjZiNjU4NTBjYmE3MzAyYzc5YzAzMWY5ZmE2MWU3MTYyYWNhNDM=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-07-01T22:40:03Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-07-02T18:44:27Z"}, "message": "Fix issue-50585 test", "tree": {"sha": "378244ae4325c54356d78a6e5716295f1626a38f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/378244ae4325c54356d78a6e5716295f1626a38f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d66b65850cba7302c79c031f9fa61e7162aca43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d66b65850cba7302c79c031f9fa61e7162aca43", "html_url": "https://github.com/rust-lang/rust/commit/4d66b65850cba7302c79c031f9fa61e7162aca43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d66b65850cba7302c79c031f9fa61e7162aca43/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90eee7dff21e6fa7be553cc3863aaeb8a73db442", "url": "https://api.github.com/repos/rust-lang/rust/commits/90eee7dff21e6fa7be553cc3863aaeb8a73db442", "html_url": "https://github.com/rust-lang/rust/commit/90eee7dff21e6fa7be553cc3863aaeb8a73db442"}], "stats": {"total": 14, "additions": 10, "deletions": 4}, "files": [{"sha": "eff0dbe1235ff85d75cd7cb43b7c585ca12efc13", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d66b65850cba7302c79c031f9fa61e7162aca43/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d66b65850cba7302c79c031f9fa61e7162aca43/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=4d66b65850cba7302c79c031f9fa61e7162aca43", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::{self, Destination};\n use syntax::ast;\n use syntax_pos::Span;\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n enum LoopKind {\n     Loop(hir::LoopSource),\n     WhileLoop,\n@@ -34,7 +34,7 @@ impl LoopKind {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n enum Context {\n     Normal,\n     Loop(LoopKind),"}, {"sha": "646c4f17568f05c3aab5e20b309d7ff14c58b7ff", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d66b65850cba7302c79c031f9fa61e7162aca43/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d66b65850cba7302c79c031f9fa61e7162aca43/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4d66b65850cba7302c79c031f9fa61e7162aca43", "patch": "@@ -3827,7 +3827,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // this can only happen if the `break` was not\n                     // inside a loop at all, which is caught by the\n                     // loop-checking pass.\n-                    assert!(self.tcx.sess.err_count() > 0);\n+                    if self.tcx.sess.err_count() == 0 {\n+                        self.tcx.sess.delay_span_bug(expr.span,\n+                            \"break was outside loop, but no error was emitted\");\n+                    }\n \n                     // We still need to assign a type to the inner expression to\n                     // prevent the ICE in #43162.\n@@ -3960,7 +3963,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // is nil. This makes sense because infinite loops\n                 // (which would have type !) are only possible iff we\n                 // permit break with a value [1].\n-                assert!(ctxt.coerce.is_some() || ctxt.may_break); // [1]\n+                if ctxt.coerce.is_none() && !ctxt.may_break {\n+                    // [1]\n+                    self.tcx.sess.delay_span_bug(body.span, \"no coercion, but loop may not break\");\n+                }\n                 ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_nil())\n             }\n             hir::ExprMatch(ref discrim, ref arms, match_src) => {"}]}