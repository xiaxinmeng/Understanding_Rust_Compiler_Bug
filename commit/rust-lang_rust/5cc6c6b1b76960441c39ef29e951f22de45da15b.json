{"sha": "5cc6c6b1b76960441c39ef29e951f22de45da15b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYzZjNmIxYjc2OTYwNDQxYzM5ZWYyOWU5NTFmMjJkZTQ1ZGExNWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-21T08:33:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-21T08:33:37Z"}, "message": "Auto merge of #36524 - michaelwoerister:trans-inline-only-on-demand, r=nikomatsakis\n\ntrans: Only instantiate #[inline] functions in codegen units referencing them\n\nThis PR changes how `#[inline]` functions are translated. Before, there was one \"master instance\" of the function with `external` linkage and a number of on-demand instances with `available_externally` linkage in each codegen unit that referenced the function. This had two downsides:\n\n* Public functions marked with `#[inline]` would be present in machine code of libraries unnecessarily (see #36280 for an example)\n* LLVM would crash on `i686-pc-windows-msvc` due to what I suspect to be a bug in LLVM's Win32 exception handling code, because it doesn't like `available_externally` there (#36309).\n\nThis PR changes the behavior, so that there is no master instance and only on-demand instances with `internal` linkage. The downside of this is potential code-bloat if LLVM does not completely inline away the `internal` instances because then there'd be N instances of the function instead of 1. However, this can only become a problem when using more than one codegen unit per crate.\n\ncc @rust-lang/compiler", "tree": {"sha": "13940d8d1b688ff8e4e8d6958eb47d4b152ea999", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13940d8d1b688ff8e4e8d6958eb47d4b152ea999"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cc6c6b1b76960441c39ef29e951f22de45da15b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc6c6b1b76960441c39ef29e951f22de45da15b", "html_url": "https://github.com/rust-lang/rust/commit/5cc6c6b1b76960441c39ef29e951f22de45da15b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cc6c6b1b76960441c39ef29e951f22de45da15b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c772948b687488a087356cb91432425662e034b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c772948b687488a087356cb91432425662e034b9", "html_url": "https://github.com/rust-lang/rust/commit/c772948b687488a087356cb91432425662e034b9"}, {"sha": "cf976fe2cd92a7a4923e6a0934c8f15333b6589d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf976fe2cd92a7a4923e6a0934c8f15333b6589d", "html_url": "https://github.com/rust-lang/rust/commit/cf976fe2cd92a7a4923e6a0934c8f15333b6589d"}], "stats": {"total": 169, "additions": 49, "deletions": 120}, "files": [{"sha": "2c3880d21ad1ad3c90a2043e632d6b94665c1c3a", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5cc6c6b1b76960441c39ef29e951f22de45da15b", "patch": "@@ -1421,21 +1421,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n             .iter()\n             .cloned()\n             .filter(|trans_item|{\n-                let def_id = match *trans_item {\n-                    TransItem::DropGlue(..) => {\n-                        return false\n-                    },\n-                    TransItem::Fn(ref instance) => {\n-                        instance.def\n-                    }\n-                    TransItem::Static(node_id) => {\n-                        tcx.map.local_def_id(node_id)\n-                    }\n-                };\n-\n-                trans_item.explicit_linkage(tcx).is_some() ||\n-                attr::contains_extern_indicator(tcx.sess.diagnostic(),\n-                                                &tcx.get_attrs(def_id))\n+                trans_item.explicit_linkage(tcx).is_some()\n             })\n             .map(|trans_item| symbol_map.get_or_compute(scx, trans_item))\n             .collect();\n@@ -1591,7 +1577,11 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n                 node: hir::ImplItemKind::Method(..), .. }) => {\n                 let def_id = tcx.map.local_def_id(id);\n                 let generics = tcx.lookup_generics(def_id);\n-                generics.parent_types == 0 && generics.types.is_empty()\n+                let attributes = tcx.get_attrs(def_id);\n+                (generics.parent_types == 0 && generics.types.is_empty()) &&\n+                // Functions marked with #[inline] are only ever translated\n+                // with \"internal\" linkage and are never exported.\n+                !attr::requests_inline(&attributes[..])\n             }\n \n             _ => false\n@@ -1896,8 +1886,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         partitioning::partition(scx,\n                                 items.iter().cloned(),\n                                 strategy,\n-                                &inlining_map,\n-                                scx.reachable())\n+                                &inlining_map)\n     });\n \n     assert!(scx.tcx().sess.opts.cg.codegen_units == codegen_units.len() ||"}, {"sha": "91ffe5044ce0cc79490a4df2f5f5617d86a3b9d2", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=5cc6c6b1b76960441c39ef29e951f22de45da15b", "patch": "@@ -401,7 +401,7 @@ fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         callees: &[TransItem<'tcx>],\n                                         inlining_map: &mut InliningMap<'tcx>) {\n     let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n-        trans_item.is_from_extern_crate() || trans_item.requests_inline(tcx)\n+        trans_item.needs_local_copy(tcx)\n     };\n \n     let inlining_candidates = callees.into_iter()"}, {"sha": "65615e6b6440cb45513120e86bd9a453f7e4b3f6", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 9, "deletions": 77, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=5cc6c6b1b76960441c39ef29e951f22de45da15b", "patch": "@@ -133,7 +133,7 @@ use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n use syntax::parse::token::{self, InternedString};\n use trans_item::TransItem;\n-use util::nodemap::{FnvHashMap, FnvHashSet, NodeSet};\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n \n pub enum PartitioningStrategy {\n     /// Generate one codegen unit per source-level module.\n@@ -254,25 +254,17 @@ const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                               trans_items: I,\n                               strategy: PartitioningStrategy,\n-                              inlining_map: &InliningMap<'tcx>,\n-                              reachable: &NodeSet)\n+                              inlining_map: &InliningMap<'tcx>)\n                               -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     let tcx = scx.tcx();\n \n-    if let PartitioningStrategy::FixedUnitCount(1) = strategy {\n-        // If there is only a single codegen-unit, we can use a very simple\n-        // scheme and don't have to bother with doing much analysis.\n-        return vec![single_codegen_unit(tcx, trans_items, reachable)];\n-    }\n-\n     // In the first step, we place all regular translation items into their\n     // respective 'home' codegen unit. Regular translation items are all\n     // functions and statics defined in the local crate.\n     let mut initial_partitioning = place_root_translation_items(scx,\n-                                                                trans_items,\n-                                                                reachable);\n+                                                                trans_items);\n \n     debug_dump(tcx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n \n@@ -310,8 +302,7 @@ struct PreInliningPartitioning<'tcx> {\n struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n \n fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                             trans_items: I,\n-                                             _reachable: &NodeSet)\n+                                             trans_items: I)\n                                              -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n@@ -320,7 +311,7 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let mut codegen_units = FnvHashMap();\n \n     for trans_item in trans_items {\n-        let is_root = !trans_item.is_instantiated_only_on_demand();\n+        let is_root = !trans_item.is_instantiated_only_on_demand(tcx);\n \n         if is_root {\n             let characteristic_def_id = characteristic_def_id_of_trans_item(scx, trans_item);\n@@ -350,6 +341,10 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 // This is a non-generic functions, we always\n                                 // make it visible externally on the chance that\n                                 // it might be used in another codegen unit.\n+                                // Later on base::internalize_symbols() will\n+                                // assign \"internal\" linkage to those symbols\n+                                // that are not referenced from other codegen\n+                                // units (and are not publicly visible).\n                                 llvm::ExternalLinkage\n                             } else {\n                                 // In the current setup, generic functions cannot\n@@ -454,7 +449,6 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n                 // reliably in that case.\n                 new_codegen_unit.items.insert(trans_item, llvm::InternalLinkage);\n             } else {\n-                assert!(trans_item.is_instantiated_only_on_demand());\n                 // We can't be sure if this will also be instantiated\n                 // somewhere else, so we add an instance here with\n                 // InternalLinkage so we don't get any conflicts.\n@@ -550,68 +544,6 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return token::intern_and_get_ident(&mod_path[..]);\n }\n \n-fn single_codegen_unit<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    trans_items: I,\n-                                    reachable: &NodeSet)\n-                                    -> CodegenUnit<'tcx>\n-    where I: Iterator<Item = TransItem<'tcx>>\n-{\n-    let mut items = FnvHashMap();\n-\n-    for trans_item in trans_items {\n-        let linkage = trans_item.explicit_linkage(tcx).unwrap_or_else(|| {\n-            match trans_item {\n-                TransItem::Static(node_id) => {\n-                    if reachable.contains(&node_id) {\n-                        llvm::ExternalLinkage\n-                    } else {\n-                        llvm::PrivateLinkage\n-                    }\n-                }\n-                TransItem::DropGlue(_) => {\n-                    llvm::InternalLinkage\n-                }\n-                TransItem::Fn(instance) => {\n-                    if trans_item.is_generic_fn() {\n-                        // FIXME(mw): Assigning internal linkage to all\n-                        // monomorphizations is potentially a waste of space\n-                        // since monomorphizations could be shared between\n-                        // crates. The main reason for making them internal is\n-                        // a limitation in MingW's binutils that cannot deal\n-                        // with COFF object that have more than 2^15 sections,\n-                        // which is something that can happen for large programs\n-                        // when every function gets put into its own COMDAT\n-                        // section.\n-                        llvm::InternalLinkage\n-                    } else if trans_item.is_from_extern_crate() {\n-                        // FIXME(mw): It would be nice if we could mark these as\n-                        // `AvailableExternallyLinkage`, since they should have\n-                        // been instantiated in the extern crate. But this\n-                        // sometimes leads to crashes on Windows because LLVM\n-                        // does not handle exception handling table instantiation\n-                        // reliably in that case.\n-                        llvm::InternalLinkage\n-                    } else if reachable.contains(&tcx.map\n-                                                     .as_local_node_id(instance.def)\n-                                                     .unwrap()) {\n-                        llvm::ExternalLinkage\n-                    } else {\n-                        // Functions that are not visible outside this crate can\n-                        // be marked as internal.\n-                        llvm::InternalLinkage\n-                    }\n-                }\n-            }\n-        });\n-\n-        items.insert(trans_item, linkage);\n-    }\n-\n-    CodegenUnit::new(\n-        numbered_codegen_unit_name(&tcx.crate_name[..], 0),\n-        items)\n-}\n-\n fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n     token::intern_and_get_ident(&format!(\"{}{}{}\",\n         crate_name,"}, {"sha": "5c7cbbbd88d46ced274471bd4a333b4f05e1da81", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=5cc6c6b1b76960441c39ef29e951f22de45da15b", "patch": "@@ -241,19 +241,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => {\n-                instance.substs.types().next().is_some() || {\n-                    let attributes = tcx.get_attrs(instance.def);\n-                    attr::requests_inline(&attributes[..])\n-                }\n-            }\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n     pub fn is_from_extern_crate(&self) -> bool {\n         match *self {\n             TransItem::Fn(ref instance) => !instance.def.is_local(),\n@@ -262,10 +249,18 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn is_instantiated_only_on_demand(&self) -> bool {\n+    /// True if the translation item should only be translated to LLVM IR if\n+    /// it is referenced somewhere (like inline functions, for example).\n+    pub fn is_instantiated_only_on_demand(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        if self.explicit_linkage(tcx).is_some() {\n+            return false;\n+        }\n+\n         match *self {\n             TransItem::Fn(ref instance) => {\n-                !instance.def.is_local() || instance.substs.types().next().is_some()\n+                !instance.def.is_local() ||\n+                instance.substs.types().next().is_some() ||\n+                attr::requests_inline(&tcx.get_attrs(instance.def)[..])\n             }\n             TransItem::DropGlue(..) => true,\n             TransItem::Static(..)   => false,\n@@ -282,6 +277,18 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n+    /// Returns true if there has to be a local copy of this TransItem in every\n+    /// codegen unit that references it (as with inlined functions, for example)\n+    pub fn needs_local_copy(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        // Currently everything that is instantiated only on demand is done so\n+        // with \"internal\" linkage, so we need a copy to be present in every\n+        // codegen unit.\n+        // This is coincidental: We could also instantiate something only if it\n+        // is referenced (e.g. a regular, private function) but place it in its\n+        // own codegen unit with \"external\" linkage.\n+        self.is_instantiated_only_on_demand(tcx)\n+    }\n+\n     pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n         let def_id = match *self {\n             TransItem::Fn(ref instance) => instance.def,"}, {"sha": "84ca8b1b0f641e271cc2f67fc6457b7182ace6f1", "filename": "src/test/codegen-units/partitioning/local-inlining.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs?ref=5cc6c6b1b76960441c39ef29e951f22de45da15b", "patch": "@@ -19,7 +19,7 @@\n mod inline {\n \n     // Important: This function should show up in all codegen units where it is inlined\n-    //~ TRANS_ITEM fn local_inlining::inline[0]::inlined_function[0] @@ local_inlining-inline[External] local_inlining-user1[Available] local_inlining-user2[Available]\n+    //~ TRANS_ITEM fn local_inlining::inline[0]::inlined_function[0] @@ local_inlining-user1[Internal] local_inlining-user2[Internal]\n     #[inline(always)]\n     pub fn inlined_function()\n     {"}, {"sha": "7e37f9ccaa5a911c2557a55684637abdaaa80b65", "filename": "src/test/codegen-units/partitioning/local-transitive-inlining.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs?ref=5cc6c6b1b76960441c39ef29e951f22de45da15b", "patch": "@@ -18,7 +18,7 @@\n \n mod inline {\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::inline[0]::inlined_function[0] @@ local_transitive_inlining-inline[External] local_transitive_inlining-direct_user[Available] local_transitive_inlining-indirect_user[Available]\n+    //~ TRANS_ITEM fn local_transitive_inlining::inline[0]::inlined_function[0] @@ local_transitive_inlining-indirect_user[Internal]\n     #[inline(always)]\n     pub fn inlined_function()\n     {\n@@ -29,7 +29,7 @@ mod inline {\n mod direct_user {\n     use super::inline;\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::direct_user[0]::foo[0] @@ local_transitive_inlining-direct_user[External] local_transitive_inlining-indirect_user[Available]\n+    //~ TRANS_ITEM fn local_transitive_inlining::direct_user[0]::foo[0] @@ local_transitive_inlining-indirect_user[Internal]\n     #[inline(always)]\n     pub fn foo() {\n         inline::inlined_function();"}, {"sha": "ef43b0d97e4170fd98b174b8e18c797e47febbdc", "filename": "src/test/run-make/sepcomp-inlining/Makefile", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5cc6c6b1b76960441c39ef29e951f22de45da15b/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile?ref=5cc6c6b1b76960441c39ef29e951f22de45da15b", "patch": "@@ -1,13 +1,14 @@\n -include ../tools.mk\n \n-# Test that #[inline(always)] functions still get inlined across compilation\n-# unit boundaries.  Compilation should produce three IR files, with each one\n-# containing a definition of the inlined function.  Also, the non-#[inline]\n-# function should be defined in only one compilation unit.\n+# Test that #[inline] functions still get inlined across compilation unit\n+# boundaries. Compilation should produce three IR files, but only the two\n+# compilation units that have a usage of the #[inline] function should\n+# contain a definition. Also, the non-#[inline] function should be defined\n+# in only one compilation unit.\n \n all:\n \t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=3\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ i32\\ .*inlined)\" -eq \"1\" ]\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ available_externally\\ i32\\ .*inlined)\" -eq \"2\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ i32\\ .*inlined)\" -eq \"0\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ internal\\ i32\\ .*inlined)\" -eq \"2\" ]\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ i32\\ .*normal)\" -eq \"1\" ]\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c declare\\ i32\\ .*normal)\" -eq \"2\" ]"}]}