{"sha": "eeb98237d1cf5134ca3e41b85e1e9e07cab83c75", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYjk4MjM3ZDFjZjUxMzRjYTNlNDFiODVlMWU5ZTA3Y2FiODNjNzU=", "commit": {"author": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-05-16T08:16:32Z"}, "committer": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-05-16T08:16:32Z"}, "message": "parse fixture meta in test_utils crate", "tree": {"sha": "d530284aa0bf78e4355ce2bddc6be2b614812dba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d530284aa0bf78e4355ce2bddc6be2b614812dba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeb98237d1cf5134ca3e41b85e1e9e07cab83c75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb98237d1cf5134ca3e41b85e1e9e07cab83c75", "html_url": "https://github.com/rust-lang/rust/commit/eeb98237d1cf5134ca3e41b85e1e9e07cab83c75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeb98237d1cf5134ca3e41b85e1e9e07cab83c75/comments", "author": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4ecaa70969067c1149711dbf1f40a8a95cb5b72", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4ecaa70969067c1149711dbf1f40a8a95cb5b72", "html_url": "https://github.com/rust-lang/rust/commit/a4ecaa70969067c1149711dbf1f40a8a95cb5b72"}], "stats": {"total": 102, "additions": 101, "deletions": 1}, "files": [{"sha": "4d185b01c752d26e41c9fa7437e189719a20c73b", "filename": "crates/test_utils/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb98237d1cf5134ca3e41b85e1e9e07cab83c75/crates%2Ftest_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eeb98237d1cf5134ca3e41b85e1e9e07cab83c75/crates%2Ftest_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2FCargo.toml?ref=eeb98237d1cf5134ca3e41b85e1e9e07cab83c75", "patch": "@@ -11,3 +11,7 @@ doctest = false\n difference = \"2.0.0\"\n text-size = \"1.0.0\"\n serde_json = \"1.0.48\"\n+relative-path = \"1.0.0\"\n+rustc-hash = \"1.1.0\"\n+\n+ra_cfg = { path = \"../ra_cfg\" }\n\\ No newline at end of file"}, {"sha": "12ae5f451377831b82bb27c04d83afdbabc78044", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 97, "deletions": 1, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/eeb98237d1cf5134ca3e41b85e1e9e07cab83c75/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb98237d1cf5134ca3e41b85e1e9e07cab83c75/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=eeb98237d1cf5134ca3e41b85e1e9e07cab83c75", "patch": "@@ -14,8 +14,12 @@ use std::{\n     path::{Path, PathBuf},\n };\n \n+pub use ra_cfg::CfgOptions;\n+\n use serde_json::Value;\n use text_size::{TextRange, TextSize};\n+pub use relative_path::{RelativePath, RelativePathBuf};\n+pub use rustc_hash::FxHashMap;\n \n pub use difference::Changeset as __Changeset;\n \n@@ -159,6 +163,33 @@ pub fn add_cursor(text: &str, offset: TextSize) -> String {\n pub struct FixtureEntry {\n     pub meta: String,\n     pub text: String,\n+\n+    pub parsed_meta: FixtureMeta,\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub enum FixtureMeta {\n+    Root { path: RelativePathBuf },\n+    File(FileMeta),\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct FileMeta {\n+    pub path: RelativePathBuf,\n+    pub krate: Option<String>,\n+    pub deps: Vec<String>,\n+    pub cfg: ra_cfg::CfgOptions,\n+    pub edition: Option<String>,\n+    pub env: FxHashMap<String, String>,\n+}\n+\n+impl FixtureMeta {\n+    pub fn path(&self) -> &RelativePath {\n+        match self {\n+            FixtureMeta::Root { path } => &path,\n+            FixtureMeta::File(f) => &f.path,\n+        }\n+    }\n }\n \n /// Parses text which looks like this:\n@@ -200,7 +231,8 @@ The offending line: {:?}\"#,\n     for line in lines.by_ref() {\n         if line.starts_with(\"//-\") {\n             let meta = line[\"//-\".len()..].trim().to_string();\n-            res.push(FixtureEntry { meta, text: String::new() })\n+            let parsed_meta = parse_meta(&meta);\n+            res.push(FixtureEntry { meta, parsed_meta, text: String::new() })\n         } else if let Some(entry) = res.last_mut() {\n             entry.text.push_str(line);\n             entry.text.push('\\n');\n@@ -209,6 +241,58 @@ The offending line: {:?}\"#,\n     res\n }\n \n+//- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo\n+fn parse_meta(meta: &str) -> FixtureMeta {\n+    let components = meta.split_ascii_whitespace().collect::<Vec<_>>();\n+\n+    if components[0] == \"root\" {\n+        let path: RelativePathBuf = components[1].into();\n+        assert!(path.starts_with(\"/\") && path.ends_with(\"/\"));\n+        return FixtureMeta::Root { path };\n+    }\n+\n+    let path: RelativePathBuf = components[0].into();\n+    assert!(path.starts_with(\"/\"));\n+\n+    let mut krate = None;\n+    let mut deps = Vec::new();\n+    let mut edition = None;\n+    let mut cfg = CfgOptions::default();\n+    let mut env = FxHashMap::default();\n+    for component in components[1..].iter() {\n+        let (key, value) = split1(component, ':').unwrap();\n+        match key {\n+            \"crate\" => krate = Some(value.to_string()),\n+            \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n+            \"edition\" => edition = Some(value.to_string()),\n+            \"cfg\" => {\n+                for key in value.split(',') {\n+                    match split1(key, '=') {\n+                        None => cfg.insert_atom(key.into()),\n+                        Some((k, v)) => cfg.insert_key_value(k.into(), v.into()),\n+                    }\n+                }\n+            }\n+            \"env\" => {\n+                for key in value.split(',') {\n+                    if let Some((k, v)) = split1(key, '=') {\n+                        env.insert(k.into(), v.into());\n+                    }\n+                }\n+            }\n+            _ => panic!(\"bad component: {:?}\", component),\n+        }\n+    }\n+\n+    FixtureMeta::File(FileMeta { path, krate, deps, edition, cfg, env })\n+}\n+\n+fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n+    let idx = haystack.find(delim)?;\n+    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n+}\n+\n+\n /// Adjusts the indentation of the first line to the minimum indentation of the rest of the lines.\n /// This allows fixtures to start off in a different indentation, e.g. to align the first line with\n /// the other lines visually:\n@@ -288,6 +372,18 @@ struct Bar;\n     )\n }\n \n+#[test]\n+fn parse_fixture_gets_full_meta() {\n+    let fixture = r\"\n+    //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b,atom env:OUTDIR=path/to,OTHER=foo\n+    \";\n+    let parsed = parse_fixture(fixture);\n+    assert_eq!(1, parsed.len());\n+\n+    let parsed = &parsed[0];\n+    assert_eq!(\"\\n\", parsed.text);\n+}\n+\n /// Same as `parse_fixture`, except it allow empty fixture\n pub fn parse_single_fixture(fixture: &str) -> Option<FixtureEntry> {\n     if !fixture.lines().any(|it| it.trim_start().starts_with(\"//-\")) {"}]}