{"sha": "e87082293e11a2f9c6d38bcd9896e8742e110ef8", "node_id": "C_kwDOAAsO6NoAKGU4NzA4MjI5M2UxMWEyZjljNmQzOGJjZDk4OTZlODc0MmUxMTBlZjg", "commit": {"author": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2022-03-19T14:30:34Z"}, "committer": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2022-04-17T05:23:46Z"}, "message": "Improve Windows path prefix parsing", "tree": {"sha": "f0c2a82bf1bffaabc8b3798208b1417669f1800a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0c2a82bf1bffaabc8b3798208b1417669f1800a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e87082293e11a2f9c6d38bcd9896e8742e110ef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e87082293e11a2f9c6d38bcd9896e8742e110ef8", "html_url": "https://github.com/rust-lang/rust/commit/e87082293e11a2f9c6d38bcd9896e8742e110ef8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e87082293e11a2f9c6d38bcd9896e8742e110ef8/comments", "author": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c28b0eaf9843ec0f493fca2dba506fe4d9174fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c28b0eaf9843ec0f493fca2dba506fe4d9174fb", "html_url": "https://github.com/rust-lang/rust/commit/2c28b0eaf9843ec0f493fca2dba506fe4d9174fb"}], "stats": {"total": 161, "additions": 124, "deletions": 37}, "files": [{"sha": "f60b604f1b167a832b6d4185dc980e74ee861fc0", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=e87082293e11a2f9c6d38bcd9896e8742e110ef8", "patch": "@@ -240,6 +240,7 @@\n #![feature(exhaustive_patterns)]\n #![feature(intra_doc_pointers)]\n #![feature(lang_items)]\n+#![feature(let_chains)]\n #![feature(linkage)]\n #![feature(min_specialization)]\n #![feature(must_not_suspend)]"}, {"sha": "f0358c871cb07a11589e7c34159a9c2c18a1c82d", "filename": "library/std/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=e87082293e11a2f9c6d38bcd9896e8742e110ef8", "patch": "@@ -168,8 +168,8 @@ pub enum Prefix<'a> {\n \n     /// Device namespace prefix, e.g., `\\\\.\\COM42`.\n     ///\n-    /// Device namespace prefixes consist of `\\\\.\\` immediately followed by the\n-    /// device name.\n+    /// Device namespace prefixes consist of `\\\\.\\` (possibly using `/`\n+    /// instead of `\\`), immediately followed by the device name.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     DeviceNS(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n "}, {"sha": "0d8ea29c2be759b1580f2b36f20560d5d2b6ecb7", "filename": "library/std/src/path/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs?ref=e87082293e11a2f9c6d38bcd9896e8742e110ef8", "patch": "@@ -971,15 +971,15 @@ pub fn test_decompositions_windows() {\n     file_prefix: None\n     );\n \n-    t!(\"\\\\\\\\?\\\\C:/foo\",\n-    iter: [\"\\\\\\\\?\\\\C:/foo\"],\n+    t!(\"\\\\\\\\?\\\\C:/foo/bar\",\n+    iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"foo/bar\"],\n     has_root: true,\n     is_absolute: true,\n-    parent: None,\n-    file_name: None,\n-    file_stem: None,\n+    parent: Some(\"\\\\\\\\?\\\\C:/\"),\n+    file_name: Some(\"foo/bar\"),\n+    file_stem: Some(\"foo/bar\"),\n     extension: None,\n-    file_prefix: None\n+    file_prefix: Some(\"foo/bar\")\n     );\n \n     t!(\"\\\\\\\\.\\\\foo\\\\bar\","}, {"sha": "2c832aa75fd187b62e41f5ca5622c0232ba13f04", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=e87082293e11a2f9c6d38bcd9896e8742e110ef8", "patch": "@@ -190,6 +190,10 @@ where\n {\n     // Start off with a stack buf but then spill over to the heap if we end up\n     // needing more space.\n+    //\n+    // This initial size also works around `GetFullPathNameW` returning\n+    // incorrect size hints for some short paths:\n+    // https://github.com/dylni/normpath/issues/5\n     let mut stack_buf = [0u16; 512];\n     let mut heap_buf = Vec::new();\n     unsafe {"}, {"sha": "a0f822070992f5032e6f54a5c16b77d19c0eaa85", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 91, "deletions": 29, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=e87082293e11a2f9c6d38bcd9896e8742e110ef8", "patch": "@@ -50,37 +50,101 @@ pub(crate) fn append_suffix(path: PathBuf, suffix: &OsStr) -> PathBuf {\n     path.into()\n }\n \n+struct PrefixParser<'a, const LEN: usize> {\n+    path: &'a OsStr,\n+    prefix: [u8; LEN],\n+}\n+\n+impl<'a, const LEN: usize> PrefixParser<'a, LEN> {\n+    #[inline]\n+    fn get_prefix(path: &OsStr) -> [u8; LEN] {\n+        let mut prefix = [0; LEN];\n+        // SAFETY: Only ASCII characters are modified.\n+        for (i, &ch) in path.bytes().iter().take(LEN).enumerate() {\n+            prefix[i] = if ch == b'/' { b'\\\\' } else { ch };\n+        }\n+        prefix\n+    }\n+\n+    fn new(path: &'a OsStr) -> Self {\n+        Self { path, prefix: Self::get_prefix(path) }\n+    }\n+\n+    fn as_slice(&self) -> PrefixParserSlice<'a, '_> {\n+        PrefixParserSlice {\n+            path: self.path,\n+            prefix: &self.prefix[..LEN.min(self.path.len())],\n+            index: 0,\n+        }\n+    }\n+}\n+\n+struct PrefixParserSlice<'a, 'b> {\n+    path: &'a OsStr,\n+    prefix: &'b [u8],\n+    index: usize,\n+}\n+\n+impl<'a> PrefixParserSlice<'a, '_> {\n+    fn strip_prefix(&self, prefix: &str) -> Option<Self> {\n+        self.prefix[self.index..]\n+            .starts_with(prefix.as_bytes())\n+            .then(|| Self { index: self.index + prefix.len(), ..*self })\n+    }\n+\n+    fn prefix_bytes(&self) -> &'a [u8] {\n+        &self.path.bytes()[..self.index]\n+    }\n+\n+    fn finish(self) -> &'a OsStr {\n+        // SAFETY: The unsafety here stems from converting between &OsStr and\n+        // &[u8] and back. This is safe to do because (1) we only look at ASCII\n+        // contents of the encoding and (2) new &OsStr values are produced only\n+        // from ASCII-bounded slices of existing &OsStr values.\n+        unsafe { bytes_as_os_str(&self.path.bytes()[self.index..]) }\n+    }\n+}\n+\n pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n     use Prefix::{DeviceNS, Disk, Verbatim, VerbatimDisk, VerbatimUNC, UNC};\n \n-    if let Some(path) = strip_prefix(path, r\"\\\\\") {\n+    let parser = PrefixParser::<8>::new(path);\n+    let parser = parser.as_slice();\n+    if let Some(parser) = parser.strip_prefix(r\"\\\\\") {\n         // \\\\\n-        if let Some(path) = strip_prefix(path, r\"?\\\") {\n+\n+        // The meaning of verbatim paths can change when they use a different\n+        // separator.\n+        if let Some(parser) = parser.strip_prefix(r\"?\\\") && !parser.prefix_bytes().iter().any(|&x| x == b'/') {\n             // \\\\?\\\n-            if let Some(path) = strip_prefix(path, r\"UNC\\\") {\n+            if let Some(parser) = parser.strip_prefix(r\"UNC\\\") {\n                 // \\\\?\\UNC\\server\\share\n \n+                let path = parser.finish();\n                 let (server, path) = parse_next_component(path, true);\n                 let (share, _) = parse_next_component(path, true);\n \n                 Some(VerbatimUNC(server, share))\n             } else {\n-                let (prefix, _) = parse_next_component(path, true);\n+                let path = parser.finish();\n \n                 // in verbatim paths only recognize an exact drive prefix\n-                if let Some(drive) = parse_drive_exact(prefix) {\n+                if let Some(drive) = parse_drive_exact(path) {\n                     // \\\\?\\C:\n                     Some(VerbatimDisk(drive))\n                 } else {\n                     // \\\\?\\prefix\n+                    let (prefix, _) = parse_next_component(path, true);\n                     Some(Verbatim(prefix))\n                 }\n             }\n-        } else if let Some(path) = strip_prefix(path, r\".\\\") {\n+        } else if let Some(parser) = parser.strip_prefix(r\".\\\") {\n             // \\\\.\\COM42\n+            let path = parser.finish();\n             let (prefix, _) = parse_next_component(path, false);\n             Some(DeviceNS(prefix))\n         } else {\n+            let path = parser.finish();\n             let (server, path) = parse_next_component(path, false);\n             let (share, _) = parse_next_component(path, false);\n \n@@ -102,31 +166,26 @@ pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n }\n \n // Parses a drive prefix, e.g. \"C:\" and \"C:\\whatever\"\n-fn parse_drive(prefix: &OsStr) -> Option<u8> {\n+fn parse_drive(path: &OsStr) -> Option<u8> {\n     // In most DOS systems, it is not possible to have more than 26 drive letters.\n     // See <https://en.wikipedia.org/wiki/Drive_letter_assignment#Common_assignments>.\n     fn is_valid_drive_letter(drive: &u8) -> bool {\n         drive.is_ascii_alphabetic()\n     }\n \n-    match prefix.bytes() {\n+    match path.bytes() {\n         [drive, b':', ..] if is_valid_drive_letter(drive) => Some(drive.to_ascii_uppercase()),\n         _ => None,\n     }\n }\n \n // Parses a drive prefix exactly, e.g. \"C:\"\n-fn parse_drive_exact(prefix: &OsStr) -> Option<u8> {\n+fn parse_drive_exact(path: &OsStr) -> Option<u8> {\n     // only parse two bytes: the drive letter and the drive separator\n-    if prefix.len() == 2 { parse_drive(prefix) } else { None }\n-}\n-\n-fn strip_prefix<'a>(path: &'a OsStr, prefix: &str) -> Option<&'a OsStr> {\n-    // `path` and `prefix` are valid wtf8 and utf8 encoded slices respectively, `path[prefix.len()]`\n-    // is thus a code point boundary and `path[prefix.len()..]` is a valid wtf8 encoded slice.\n-    match path.bytes().strip_prefix(prefix.as_bytes()) {\n-        Some(path) => unsafe { Some(bytes_as_os_str(path)) },\n-        None => None,\n+    if path.bytes().get(2).map(|&x| is_sep_byte(x)).unwrap_or(true) {\n+        parse_drive(path)\n+    } else {\n+        None\n     }\n }\n \n@@ -219,15 +278,7 @@ pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n         // SAFETY: `fill_utf16_buf` ensures the `buffer` and `size` are valid.\n         // `lpfilename` is a pointer to a null terminated string that is not\n         // invalidated until after `GetFullPathNameW` returns successfully.\n-        |buffer, size| unsafe {\n-            // While the docs for `GetFullPathNameW` have the standard note\n-            // about needing a `\\\\?\\` path for a long lpfilename, this does not\n-            // appear to be true in practice.\n-            // See:\n-            // https://stackoverflow.com/questions/38036943/getfullpathnamew-and-long-windows-file-paths\n-            // https://googleprojectzero.blogspot.com/2016/02/the-definitive-guide-on-win32-to-nt.html\n-            c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut())\n-        },\n+        |buffer, size| unsafe { c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut()) },\n         |mut absolute| {\n             path.clear();\n \n@@ -263,9 +314,20 @@ pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n \n /// Make a Windows path absolute.\n pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n-    if path.as_os_str().bytes().starts_with(br\"\\\\?\\\") {\n-        return Ok(path.into());\n+    let path = path.as_os_str();\n+    let prefix = parse_prefix(path);\n+    // Verbatim paths should not be modified.\n+    if prefix.map(|x| x.is_verbatim()).unwrap_or(false) {\n+        // NULs in verbatim paths are rejected for consistency.\n+        if path.bytes().contains(&0) {\n+            return Err(io::const_io_error!(\n+                io::ErrorKind::InvalidInput,\n+                \"strings passed to WinAPI cannot contain NULs\",\n+            ));\n+        }\n+        return Ok(path.to_owned().into());\n     }\n+\n     let path = to_u16s(path)?;\n     let lpfilename = path.as_ptr();\n     fill_utf16_buf("}, {"sha": "8656b04e4f410320befd75d198bd9c9a1690d254", "filename": "library/std/src/sys/windows/path/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87082293e11a2f9c6d38bcd9896e8742e110ef8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs?ref=e87082293e11a2f9c6d38bcd9896e8742e110ef8", "patch": "@@ -94,3 +94,23 @@ fn verbatim() {\n     // A path that contains null is not a valid path.\n     assert!(maybe_verbatim(Path::new(\"\\0\")).is_err());\n }\n+\n+fn parse_prefix(path: &str) -> Option<Prefix<'_>> {\n+    super::parse_prefix(OsStr::new(path))\n+}\n+\n+#[test]\n+fn test_parse_prefix_verbatim() {\n+    let prefix = Some(Prefix::VerbatimDisk(b'C'));\n+    assert_eq!(prefix, parse_prefix(r\"\\\\?\\C:/windows/system32/notepad.exe\"));\n+    assert_eq!(prefix, parse_prefix(r\"\\\\?\\C:\\windows\\system32\\notepad.exe\"));\n+}\n+\n+#[test]\n+fn test_parse_prefix_verbatim_device() {\n+    let prefix = Some(Prefix::UNC(OsStr::new(\"?\"), OsStr::new(\"C:\")));\n+    assert_eq!(prefix, parse_prefix(r\"//?/C:/windows/system32/notepad.exe\"));\n+    assert_eq!(prefix, parse_prefix(r\"//?/C:\\windows\\system32\\notepad.exe\"));\n+    assert_eq!(prefix, parse_prefix(r\"/\\?\\C:\\windows\\system32\\notepad.exe\"));\n+    assert_eq!(prefix, parse_prefix(r\"\\\\?/C:\\windows\\system32\\notepad.exe\"));\n+}"}]}