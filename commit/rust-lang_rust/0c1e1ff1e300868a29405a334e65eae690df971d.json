{"sha": "0c1e1ff1e300868a29405a334e65eae690df971d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMWUxZmYxZTMwMDg2OGEyOTQwNWEzMzRlNjVlYWU2OTBkZjk3MWQ=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-01T00:34:14Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-09T04:40:38Z"}, "message": "Runtime removal: refactor fs\n\nThis moves the filesystem implementation from libnative into the new\n`sys` modules, refactoring along the way and hooking into `std::io::fs`.\n\nBecause this eliminates APIs in `libnative` and `librustrt`, it is a:\n\n[breaking-change]\n\nThis functionality is likely to be available publicly, in some form,\nfrom `std` in the future.", "tree": {"sha": "d863379e4827ece4d4f6905bc091d60be86d7c1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d863379e4827ece4d4f6905bc091d60be86d7c1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c1e1ff1e300868a29405a334e65eae690df971d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c1e1ff1e300868a29405a334e65eae690df971d", "html_url": "https://github.com/rust-lang/rust/commit/0c1e1ff1e300868a29405a334e65eae690df971d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c1e1ff1e300868a29405a334e65eae690df971d/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16470cf01b688c576f47b93bdb4af88db33cf1e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/16470cf01b688c576f47b93bdb4af88db33cf1e1", "html_url": "https://github.com/rust-lang/rust/commit/16470cf01b688c576f47b93bdb4af88db33cf1e1"}], "stats": {"total": 1828, "additions": 662, "deletions": 1166}, "files": [{"sha": "f616295c73d1b1aafbcf7e6b61b684ea97d6e4ef", "filename": "src/libnative/io/file_unix.rs", "status": "removed", "additions": 0, "deletions": 554, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/16470cf01b688c576f47b93bdb4af88db33cf1e1/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16470cf01b688c576f47b93bdb4af88db33cf1e1/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=16470cf01b688c576f47b93bdb4af88db33cf1e1", "patch": "@@ -1,554 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Blocking posix-based file I/O\n-\n-use alloc::arc::Arc;\n-use libc::{mod, c_int, c_void};\n-use std::c_str::CString;\n-use std::mem;\n-use std::rt::rtio::{mod, IoResult};\n-\n-use io::{retry, keep_going};\n-use io::util;\n-\n-pub type fd_t = libc::c_int;\n-\n-struct Inner {\n-    fd: fd_t,\n-    close_on_drop: bool,\n-}\n-\n-pub struct FileDesc {\n-    inner: Arc<Inner>\n-}\n-\n-impl FileDesc {\n-    /// Create a `FileDesc` from an open C file descriptor.\n-    ///\n-    /// The `FileDesc` will take ownership of the specified file descriptor and\n-    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n-    /// it will not close the file descriptor when this `FileDesc` is dropped.\n-    ///\n-    /// Note that all I/O operations done on this object will be *blocking*, but\n-    /// they do not require the runtime to be active.\n-    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n-        FileDesc { inner: Arc::new(Inner {\n-            fd: fd,\n-            close_on_drop: close_on_drop\n-        }) }\n-    }\n-\n-    // FIXME(#10465) these functions should not be public, but anything in\n-    //               native::io wanting to use them is forced to have all the\n-    //               rtio traits in scope\n-    pub fn inner_read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let ret = retry(|| unsafe {\n-            libc::read(self.fd(),\n-                       buf.as_mut_ptr() as *mut libc::c_void,\n-                       buf.len() as libc::size_t)\n-        });\n-        if ret == 0 {\n-            Err(util::eof())\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n-    }\n-    pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::write(self.fd(), buf as *const libc::c_void,\n-                            len as libc::size_t) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    pub fn fd(&self) -> fd_t { self.inner.fd }\n-}\n-\n-impl rtio::RtioFileStream for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n-        self.inner_read(buf).map(|i| i as int)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n-        match retry(|| unsafe {\n-            libc::pread(self.fd(), buf.as_ptr() as *mut _,\n-                        buf.len() as libc::size_t,\n-                        offset as libc::off_t)\n-        }) {\n-            -1 => Err(super::last_error()),\n-            n => Ok(n as int)\n-        }\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::pwrite(self.fd(), buf.as_ptr() as *const _,\n-                         buf.len() as libc::size_t, offset as libc::off_t)\n-        }))\n-    }\n-    fn seek(&mut self, pos: i64, whence: rtio::SeekStyle) -> IoResult<u64> {\n-        let whence = match whence {\n-            rtio::SeekSet => libc::SEEK_SET,\n-            rtio::SeekEnd => libc::SEEK_END,\n-            rtio::SeekCur => libc::SEEK_CUR,\n-        };\n-        let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn tell(&self) -> IoResult<u64> {\n-        let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn fsync(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe { libc::fsync(self.fd()) }))\n-    }\n-    fn datasync(&mut self) -> IoResult<()> {\n-        return super::mkerr_libc(os_datasync(self.fd()));\n-\n-        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n-        }\n-        #[cfg(target_os = \"linux\")]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            retry(|| unsafe { libc::fdatasync(fd) })\n-        }\n-        #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"linux\")))]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            retry(|| unsafe { libc::fsync(fd) })\n-        }\n-    }\n-    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::ftruncate(self.fd(), offset as libc::off_t)\n-        }))\n-    }\n-\n-    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n-        let mut stat: libc::stat = unsafe { mem::zeroed() };\n-        match unsafe { libc::fstat(self.fd(), &mut stat) } {\n-            0 => Ok(mkstat(&stat)),\n-            _ => Err(super::last_error()),\n-        }\n-    }\n-}\n-\n-impl rtio::RtioPipe for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-    fn clone(&self) -> Box<rtio::RtioPipe + Send> {\n-        box FileDesc { inner: self.inner.clone() } as Box<rtio::RtioPipe + Send>\n-    }\n-\n-    // Only supported on named pipes currently. Note that this doesn't have an\n-    // impact on the std::io primitives, this is never called via\n-    // std::io::PipeStream. If the functionality is exposed in the future, then\n-    // these methods will need to be implemented.\n-    fn close_read(&mut self) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn close_write(&mut self) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn set_timeout(&mut self, _t: Option<u64>) {}\n-    fn set_read_timeout(&mut self, _t: Option<u64>) {}\n-    fn set_write_timeout(&mut self, _t: Option<u64>) {}\n-}\n-\n-impl rtio::RtioTTY for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-    fn set_raw(&mut self, _raw: bool) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n-        Err(super::unimpl())\n-    }\n-    fn isatty(&self) -> bool { false }\n-}\n-\n-impl Drop for Inner {\n-    fn drop(&mut self) {\n-        // closing stdio file handles makes no sense, so never do it. Also, note\n-        // that errors are ignored when closing a file descriptor. The reason\n-        // for this is that if an error occurs we don't actually know if the\n-        // file descriptor was closed or not, and if we retried (for something\n-        // like EINTR), we might close another valid file descriptor (opened\n-        // after we closed ours.\n-        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n-            let n = unsafe { libc::close(self.fd) };\n-            if n != 0 {\n-                println!(\"error {} when closing file descriptor {}\", n,\n-                         self.fd);\n-            }\n-        }\n-    }\n-}\n-\n-pub struct CFile {\n-    file: *mut libc::FILE,\n-    fd: FileDesc,\n-}\n-\n-impl CFile {\n-    /// Create a `CFile` from an open `FILE` pointer.\n-    ///\n-    /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n-    /// destruction.\n-    pub fn new(file: *mut libc::FILE) -> CFile {\n-        CFile {\n-            file: file,\n-            fd: FileDesc::new(unsafe { libc::fileno(file) }, false)\n-        }\n-    }\n-\n-    pub fn flush(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe { libc::fflush(self.file) }))\n-    }\n-}\n-\n-impl rtio::RtioFileStream for CFile {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n-                            self.file) as i64\n-            }\n-        });\n-        if ret == 0 {\n-            Err(util::eof())\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as int)\n-        }\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::fwrite(buf as *const libc::c_void, 1, len as libc::size_t,\n-                            self.file) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n-        self.flush().and_then(|()| self.fd.pread(buf, offset))\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n-        self.flush().and_then(|()| self.fd.pwrite(buf, offset))\n-    }\n-    fn seek(&mut self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n-        let whence = match style {\n-            rtio::SeekSet => libc::SEEK_SET,\n-            rtio::SeekEnd => libc::SEEK_END,\n-            rtio::SeekCur => libc::SEEK_CUR,\n-        };\n-        let n = unsafe { libc::fseek(self.file, pos as libc::c_long, whence) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn tell(&self) -> IoResult<u64> {\n-        let ret = unsafe { libc::ftell(self.file) };\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as u64)\n-        }\n-    }\n-    fn fsync(&mut self) -> IoResult<()> {\n-        self.flush().and_then(|()| self.fd.fsync())\n-    }\n-    fn datasync(&mut self) -> IoResult<()> {\n-        self.flush().and_then(|()| self.fd.datasync())\n-    }\n-    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n-        self.flush().and_then(|()| self.fd.truncate(offset))\n-    }\n-\n-    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n-        self.flush().and_then(|()| self.fd.fstat())\n-    }\n-}\n-\n-impl Drop for CFile {\n-    fn drop(&mut self) {\n-        unsafe { let _ = libc::fclose(self.file); }\n-    }\n-}\n-\n-pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n-    -> IoResult<FileDesc>\n-{\n-    let flags = match fm {\n-        rtio::Open => 0,\n-        rtio::Append => libc::O_APPEND,\n-        rtio::Truncate => libc::O_TRUNC,\n-    };\n-    // Opening with a write permission must silently create the file.\n-    let (flags, mode) = match fa {\n-        rtio::Read => (flags | libc::O_RDONLY, 0),\n-        rtio::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n-                        libc::S_IRUSR | libc::S_IWUSR),\n-        rtio::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n-                            libc::S_IRUSR | libc::S_IWUSR),\n-    };\n-\n-    match retry(|| unsafe { libc::open(path.as_ptr(), flags, mode) }) {\n-        -1 => Err(super::last_error()),\n-        fd => Ok(FileDesc::new(fd, true)),\n-    }\n-}\n-\n-pub fn mkdir(p: &CString, mode: uint) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::mkdir(p.as_ptr(), mode as libc::mode_t) })\n-}\n-\n-pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n-    use libc::{dirent_t};\n-    use libc::{opendir, readdir_r, closedir};\n-\n-    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> {\n-        let root = unsafe { CString::new(root.as_ptr(), false) };\n-        let root = Path::new(root);\n-\n-        dirs.into_iter().filter(|path| {\n-            path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n-        }).map(|path| root.join(path).to_c_str()).collect()\n-    }\n-\n-    extern {\n-        fn rust_dirent_t_size() -> libc::c_int;\n-        fn rust_list_dir_val(ptr: *mut dirent_t) -> *const libc::c_char;\n-    }\n-\n-    let size = unsafe { rust_dirent_t_size() };\n-    let mut buf = Vec::<u8>::with_capacity(size as uint);\n-    let ptr = buf.as_mut_slice().as_mut_ptr() as *mut dirent_t;\n-\n-    let dir_ptr = unsafe {opendir(p.as_ptr())};\n-\n-    if dir_ptr as uint != 0 {\n-        let mut paths = vec!();\n-        let mut entry_ptr = 0 as *mut dirent_t;\n-        while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n-            if entry_ptr.is_null() { break }\n-            let cstr = unsafe {\n-                CString::new(rust_list_dir_val(entry_ptr), false)\n-            };\n-            paths.push(Path::new(cstr));\n-        }\n-        assert_eq!(unsafe { closedir(dir_ptr) }, 0);\n-        Ok(prune(p, paths))\n-    } else {\n-        Err(super::last_error())\n-    }\n-}\n-\n-pub fn unlink(p: &CString) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::unlink(p.as_ptr()) })\n-}\n-\n-pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) })\n-}\n-\n-pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n-    super::mkerr_libc(retry(|| unsafe {\n-        libc::chmod(p.as_ptr(), mode as libc::mode_t)\n-    }))\n-}\n-\n-pub fn rmdir(p: &CString) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::rmdir(p.as_ptr()) })\n-}\n-\n-pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n-    super::mkerr_libc(retry(|| unsafe {\n-        libc::chown(p.as_ptr(), uid as libc::uid_t,\n-                    gid as libc::gid_t)\n-    }))\n-}\n-\n-pub fn readlink(p: &CString) -> IoResult<CString> {\n-    let p = p.as_ptr();\n-    let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n-    if len == -1 {\n-        len = 1024; // FIXME: read PATH_MAX from C ffi?\n-    }\n-    let mut buf: Vec<u8> = Vec::with_capacity(len as uint);\n-    match unsafe {\n-        libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n-                       len as libc::size_t) as libc::c_int\n-    } {\n-        -1 => Err(super::last_error()),\n-        n => {\n-            assert!(n > 0);\n-            unsafe { buf.set_len(n as uint); }\n-            Ok(buf.as_slice().to_c_str())\n-        }\n-    }\n-}\n-\n-pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })\n-}\n-\n-pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })\n-}\n-\n-fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n-    // FileStat times are in milliseconds\n-    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn flags(_stat: &libc::stat) -> u64 { 0 }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn gen(_stat: &libc::stat) -> u64 { 0 }\n-\n-    rtio::FileStat {\n-        size: stat.st_size as u64,\n-        kind: stat.st_mode as u64,\n-        perm: stat.st_mode as u64,\n-        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n-        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n-        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n-        device: stat.st_dev as u64,\n-        inode: stat.st_ino as u64,\n-        rdev: stat.st_rdev as u64,\n-        nlink: stat.st_nlink as u64,\n-        uid: stat.st_uid as u64,\n-        gid: stat.st_gid as u64,\n-        blksize: stat.st_blksize as u64,\n-        blocks: stat.st_blocks as u64,\n-        flags: flags(stat),\n-        gen: gen(stat),\n-    }\n-}\n-\n-pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n-    let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    match unsafe { libc::stat(p.as_ptr(), &mut stat) } {\n-        0 => Ok(mkstat(&stat)),\n-        _ => Err(super::last_error()),\n-    }\n-}\n-\n-pub fn lstat(p: &CString) -> IoResult<rtio::FileStat> {\n-    let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    match unsafe { libc::lstat(p.as_ptr(), &mut stat) } {\n-        0 => Ok(mkstat(&stat)),\n-        _ => Err(super::last_error()),\n-    }\n-}\n-\n-pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n-    let buf = libc::utimbuf {\n-        actime: (atime / 1000) as libc::time_t,\n-        modtime: (mtime / 1000) as libc::time_t,\n-    };\n-    super::mkerr_libc(unsafe { libc::utime(p.as_ptr(), &buf) })\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{CFile, FileDesc};\n-    use libc;\n-    use std::os;\n-    use std::rt::rtio::{RtioFileStream, SeekSet};\n-\n-    #[cfg_attr(target_os = \"freebsd\", ignore)] // hmm, maybe pipes have a tiny buffer\n-    #[test]\n-    fn test_file_desc() {\n-        // Run this test with some pipes so we don't have to mess around with\n-        // opening or closing files.\n-        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n-        let mut reader = FileDesc::new(reader, true);\n-        let mut writer = FileDesc::new(writer, true);\n-\n-        writer.inner_write(b\"test\").ok().unwrap();\n-        let mut buf = [0u8, ..4];\n-        match reader.inner_read(buf) {\n-            Ok(4) => {\n-                assert_eq!(buf[0], 't' as u8);\n-                assert_eq!(buf[1], 'e' as u8);\n-                assert_eq!(buf[2], 's' as u8);\n-                assert_eq!(buf[3], 't' as u8);\n-            }\n-            r => panic!(\"invalid read: {}\", r),\n-        }\n-\n-        assert!(writer.inner_read(buf).is_err());\n-        assert!(reader.inner_write(buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_cfile() {\n-        unsafe {\n-            let f = libc::tmpfile();\n-            assert!(!f.is_null());\n-            let mut file = CFile::new(f);\n-\n-            file.write(b\"test\").ok().unwrap();\n-            let mut buf = [0u8, ..4];\n-            let _ = file.seek(0, SeekSet).ok().unwrap();\n-            match file.read(buf) {\n-                Ok(4) => {\n-                    assert_eq!(buf[0], 't' as u8);\n-                    assert_eq!(buf[1], 'e' as u8);\n-                    assert_eq!(buf[2], 's' as u8);\n-                    assert_eq!(buf[3], 't' as u8);\n-                }\n-                r => panic!(\"invalid read: {}\", r)\n-            }\n-        }\n-    }\n-}"}, {"sha": "baf58b83dcd25eb2bb64f495c7a1c141a3a424fb", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=0c1e1ff1e300868a29405a334e65eae690df971d", "patch": "@@ -30,7 +30,6 @@ use std::rt::rtio::{mod, IoResult, IoError};\n use std::num;\n \n // Local re-exports\n-pub use self::file::FileDesc;\n pub use self::process::Process;\n \n mod helper_thread;\n@@ -41,13 +40,6 @@ pub mod net;\n pub mod process;\n mod util;\n \n-#[cfg(unix)]\n-#[path = \"file_unix.rs\"]\n-pub mod file;\n-#[cfg(windows)]\n-#[path = \"file_windows.rs\"]\n-pub mod file;\n-\n #[cfg(any(target_os = \"macos\",\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n@@ -92,25 +84,6 @@ fn last_error() -> IoError {\n     }\n }\n \n-// unix has nonzero values as errors\n-fn mkerr_libc <Int: num::Zero>(ret: Int) -> IoResult<()> {\n-    if !ret.is_zero() {\n-        Err(last_error())\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n-// windows has zero values as errors\n-#[cfg(windows)]\n-fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n-    if ret == 0 {\n-        Err(last_error())\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n #[cfg(windows)]\n #[inline]\n fn retry<I> (f: || -> I) -> I { f() } // PR rust-lang/rust/#17020\n@@ -199,62 +172,6 @@ impl rtio::IoFactory for IoFactory {\n         addrinfo::GetAddrInfoRequest::run(host, servname, hint)\n     }\n \n-    // filesystem operations\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close: rtio::CloseBehavior)\n-                      -> Box<rtio::RtioFileStream + Send> {\n-        let close = match close {\n-            rtio::CloseSynchronously | rtio::CloseAsynchronously => true,\n-            rtio::DontClose => false\n-        };\n-        box file::FileDesc::new(fd, close) as Box<rtio::RtioFileStream + Send>\n-    }\n-    fn fs_open(&mut self, path: &CString, fm: rtio::FileMode,\n-               fa: rtio::FileAccess)\n-        -> IoResult<Box<rtio::RtioFileStream + Send>>\n-    {\n-        file::open(path, fm, fa).map(|fd| box fd as Box<rtio::RtioFileStream + Send>)\n-    }\n-    fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n-        file::unlink(path)\n-    }\n-    fn fs_stat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n-        file::stat(path)\n-    }\n-    fn fs_mkdir(&mut self, path: &CString, mode: uint) -> IoResult<()> {\n-        file::mkdir(path, mode)\n-    }\n-    fn fs_chmod(&mut self, path: &CString, mode: uint) -> IoResult<()> {\n-        file::chmod(path, mode)\n-    }\n-    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> {\n-        file::rmdir(path)\n-    }\n-    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> {\n-        file::rename(path, to)\n-    }\n-    fn fs_readdir(&mut self, path: &CString, _flags: c_int) -> IoResult<Vec<CString>> {\n-        file::readdir(path)\n-    }\n-    fn fs_lstat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n-        file::lstat(path)\n-    }\n-    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> {\n-        file::chown(path, uid, gid)\n-    }\n-    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString> {\n-        file::readlink(path)\n-    }\n-    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n-        file::symlink(src, dst)\n-    }\n-    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n-        file::link(src, dst)\n-    }\n-    fn fs_utime(&mut self, src: &CString, atime: u64,\n-                mtime: u64) -> IoResult<()> {\n-        file::utime(src, atime, mtime)\n-    }\n-\n     // misc\n     fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer + Send>> {\n         timer::Timer::new().map(|t| box t as Box<rtio::RtioTimer + Send>)"}, {"sha": "c26e2e76cee635f7fc88c622da9c99229c183f48", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=0c1e1ff1e300868a29405a334e65eae690df971d", "patch": "@@ -56,7 +56,7 @@ use std::sync::atomic;\n use std::comm;\n \n use io::c;\n-use io::file::FileDesc;\n+use platform_imp::fs::FileDesc;\n use io::helper_thread::Helper;\n \n helper_init!(static HELPER: Helper<Req>)"}, {"sha": "1f3ef60e6fb2b80316f5acb872f9c2191f4191ca", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=0c1e1ff1e300868a29405a334e65eae690df971d", "patch": "@@ -50,20 +50,6 @@ pub trait RemoteCallback {\n     fn fire(&mut self);\n }\n \n-/// Description of what to do when a file handle is closed\n-pub enum CloseBehavior {\n-    /// Do not close this handle when the object is destroyed\n-    DontClose,\n-    /// Synchronously close the handle, meaning that the task will block when\n-    /// the handle is destroyed until it has been fully closed.\n-    CloseSynchronously,\n-    /// Asynchronously closes a handle, meaning that the task will *not* block\n-    /// when the handle is destroyed, but the handle will still get deallocated\n-    /// and cleaned up (but this will happen asynchronously on the local event\n-    /// loop).\n-    CloseAsynchronously,\n-}\n-\n /// Data needed to spawn a process. Serializes the `std::io::process::Command`\n /// builder.\n pub struct ProcessConfig<'a> {\n@@ -202,28 +188,6 @@ pub trait IoFactory {\n                           hint: Option<AddrinfoHint>)\n                           -> IoResult<Vec<AddrinfoInfo>>;\n \n-    // filesystem operations\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)\n-                      -> Box<RtioFileStream + Send>;\n-    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n-               -> IoResult<Box<RtioFileStream + Send>>;\n-    fn fs_unlink(&mut self, path: &CString) -> IoResult<()>;\n-    fn fs_stat(&mut self, path: &CString) -> IoResult<FileStat>;\n-    fn fs_mkdir(&mut self, path: &CString, mode: uint) -> IoResult<()>;\n-    fn fs_chmod(&mut self, path: &CString, mode: uint) -> IoResult<()>;\n-    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()>;\n-    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()>;\n-    fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n-        IoResult<Vec<CString>>;\n-    fn fs_lstat(&mut self, path: &CString) -> IoResult<FileStat>;\n-    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) ->\n-        IoResult<()>;\n-    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString>;\n-    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()>;\n-    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()>;\n-    fn fs_utime(&mut self, src: &CString, atime: u64, mtime: u64) ->\n-        IoResult<()>;\n-\n     // misc\n     fn timer_init(&mut self) -> IoResult<Box<RtioTimer + Send>>;\n     fn spawn(&mut self, cfg: ProcessConfig)\n@@ -296,19 +260,6 @@ pub trait RtioTimer {\n     fn period(&mut self, msecs: u64, cb: Box<Callback + Send>);\n }\n \n-pub trait RtioFileStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<int>;\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int>;\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()>;\n-    fn seek(&mut self, pos: i64, whence: SeekStyle) -> IoResult<u64>;\n-    fn tell(&self) -> IoResult<u64>;\n-    fn fsync(&mut self) -> IoResult<()>;\n-    fn datasync(&mut self) -> IoResult<()>;\n-    fn truncate(&mut self, offset: i64) -> IoResult<()>;\n-    fn fstat(&mut self) -> IoResult<FileStat>;\n-}\n-\n pub trait RtioProcess {\n     fn id(&self) -> libc::pid_t;\n     fn kill(&mut self, signal: int) -> IoResult<()>;\n@@ -399,43 +350,6 @@ pub enum ProcessExit {\n     ExitSignal(int),\n }\n \n-pub enum FileMode {\n-    Open,\n-    Append,\n-    Truncate,\n-}\n-\n-pub enum FileAccess {\n-    Read,\n-    Write,\n-    ReadWrite,\n-}\n-\n-pub struct FileStat {\n-    pub size: u64,\n-    pub kind: u64,\n-    pub perm: u64,\n-    pub created: u64,\n-    pub modified: u64,\n-    pub accessed: u64,\n-    pub device: u64,\n-    pub inode: u64,\n-    pub rdev: u64,\n-    pub nlink: u64,\n-    pub uid: u64,\n-    pub gid: u64,\n-    pub blksize: u64,\n-    pub blocks: u64,\n-    pub flags: u64,\n-    pub gen: u64,\n-}\n-\n-pub enum SeekStyle {\n-    SeekSet,\n-    SeekEnd,\n-    SeekCur,\n-}\n-\n pub struct AddrinfoHint {\n     pub family: uint,\n     pub socktype: uint,"}, {"sha": "5c2a5c3512d3212f9fe9fb24b336f6adc4615e96", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 87, "deletions": 217, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=0c1e1ff1e300868a29405a334e65eae690df971d", "patch": "@@ -52,28 +52,25 @@ fs::unlink(&path);\n \n */\n \n-use c_str::ToCStr;\n use clone::Clone;\n use io::standard_error;\n-use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n+use io::{FilePermission, Write, Open, FileAccess, FileMode};\n use io::{IoResult, IoError, FileStat, SeekStyle, Seek, Writer, Reader};\n-use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n+use io::{Read, Truncate, ReadWrite, Append};\n use io::UpdateIoError;\n use io;\n use iter::{Iterator, Extend};\n-use kinds::Send;\n-use libc;\n use option::{Some, None, Option};\n-use boxed::Box;\n use path::{Path, GenericPath};\n use path;\n use result::{Err, Ok};\n-use rt::rtio::LocalIo;\n-use rt::rtio;\n use slice::SlicePrelude;\n use string::String;\n use vec::Vec;\n \n+use sys::fs as fs_imp;\n+use sys_common;\n+\n /// Unconstrained file access type that exposes read and write operations\n ///\n /// Can be constructed via `File::open()`, `File::create()`, and\n@@ -86,11 +83,17 @@ use vec::Vec;\n /// configured at creation time, via the `FileAccess` parameter to\n /// `File::open_mode()`.\n pub struct File {\n-    fd: Box<rtio::RtioFileStream + Send>,\n+    fd: fs_imp::FileDesc,\n     path: Path,\n     last_nread: int,\n }\n \n+impl sys_common::AsFileDesc for File {\n+    fn as_fd(&self) -> &fs_imp::FileDesc {\n+        &self.fd\n+    }\n+}\n+\n impl File {\n     /// Open a file at `path` in the mode specified by the `mode` and `access`\n     /// arguments\n@@ -133,26 +136,13 @@ impl File {\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n                      access: FileAccess) -> IoResult<File> {\n-        let rtio_mode = match mode {\n-            Open => rtio::Open,\n-            Append => rtio::Append,\n-            Truncate => rtio::Truncate,\n-        };\n-        let rtio_access = match access {\n-            Read => rtio::Read,\n-            Write => rtio::Write,\n-            ReadWrite => rtio::ReadWrite,\n-        };\n-        let err = LocalIo::maybe_raise(|io| {\n-            io.fs_open(&path.to_c_str(), rtio_mode, rtio_access).map(|fd| {\n-                File {\n-                    path: path.clone(),\n-                    fd: fd,\n-                    last_nread: -1\n-                }\n-            })\n-        }).map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't open file\", |e| {\n+        fs_imp::open(path, mode, access).map(|fd| {\n+            File {\n+                path: path.clone(),\n+                fd: fd,\n+                last_nread: -1\n+            }\n+        }).update_err(\"couldn't open file\", |e| {\n             format!(\"{}; path={}; mode={}; access={}\", e, path.display(),\n                 mode_string(mode), access_string(access))\n         })\n@@ -194,7 +184,7 @@ impl File {\n     /// ```\n     pub fn create(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Truncate, Write)\n-            .update_desc(\"couldn't create file\")\n+             .update_desc(\"couldn't create file\")\n     }\n \n     /// Returns the original path which was used to open this file.\n@@ -206,19 +196,19 @@ impl File {\n     /// device. This will flush any internal buffers necessary to perform this\n     /// operation.\n     pub fn fsync(&mut self) -> IoResult<()> {\n-        let err = self.fd.fsync().map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't fsync file\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n+        self.fd.fsync()\n+            .update_err(\"couldn't fsync file\",\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n     /// file metadata to the filesystem. This is intended for use case which\n     /// must synchronize content, but don't need the metadata on disk. The goal\n     /// of this method is to reduce disk operations.\n     pub fn datasync(&mut self) -> IoResult<()> {\n-        let err = self.fd.datasync().map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't datasync file\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n+        self.fd.datasync()\n+            .update_err(\"couldn't datasync file\",\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     /// Either truncates or extends the underlying file, updating the size of\n@@ -230,10 +220,9 @@ impl File {\n     /// will be extended to `size` and have all of the intermediate data filled\n     /// in with 0s.\n     pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n-        let err = self.fd.truncate(size).map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't truncate file\", |e| {\n-            format!(\"{}; path={}; size={}\", e, self.path.display(), size)\n-        })\n+        self.fd.truncate(size)\n+            .update_err(\"couldn't truncate file\", |e|\n+                format!(\"{}; path={}; size={}\", e, self.path.display(), size))\n     }\n \n     /// Returns true if the stream has reached the end of the file.\n@@ -251,12 +240,9 @@ impl File {\n \n     /// Queries information about the underlying file.\n     pub fn stat(&mut self) -> IoResult<FileStat> {\n-        let err = match self.fd.fstat() {\n-            Ok(s) => Ok(from_rtio(s)),\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        };\n-        err.update_err(\"couldn't fstat file\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n+        self.fd.fstat()\n+            .update_err(\"couldn't fstat file\", |e|\n+                format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n@@ -282,41 +268,9 @@ impl File {\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n pub fn unlink(path: &Path) -> IoResult<()> {\n-    return match do_unlink(path) {\n-        Ok(()) => Ok(()),\n-        Err(e) => {\n-            // On unix, a readonly file can be successfully removed. On windows,\n-            // however, it cannot. To keep the two platforms in line with\n-            // respect to their behavior, catch this case on windows, attempt to\n-            // change it to read-write, and then remove the file.\n-            if cfg!(windows) && e.kind == io::PermissionDenied {\n-                let stat = match stat(path) {\n-                    Ok(stat) => stat,\n-                    Err(..) => return Err(e),\n-                };\n-                if stat.perm.intersects(io::USER_WRITE) { return Err(e) }\n-\n-                match chmod(path, stat.perm | io::USER_WRITE) {\n-                    Ok(()) => do_unlink(path),\n-                    Err(..) => {\n-                        // Try to put it back as we found it\n-                        let _ = chmod(path, stat.perm);\n-                        Err(e)\n-                    }\n-                }\n-            } else {\n-                Err(e)\n-            }\n-        }\n-    };\n-\n-    fn do_unlink(path: &Path) -> IoResult<()> {\n-        let err = LocalIo::maybe_raise(|io| {\n-            io.fs_unlink(&path.to_c_str())\n-        }).map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't unlink path\",\n-                       |e| format!(\"{}; path={}\", e, path.display()))\n-    }\n+    fs_imp::unlink(path)\n+           .update_err(\"couldn't unlink path\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -341,12 +295,9 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// to perform a `stat` call on the given `path` or if there is no entry in the\n /// filesystem at the provided path.\n pub fn stat(path: &Path) -> IoResult<FileStat> {\n-    let err = match LocalIo::maybe_raise(|io| io.fs_stat(&path.to_c_str())) {\n-        Ok(s) => Ok(from_rtio(s)),\n-        Err(e) => Err(IoError::from_rtio_error(e)),\n-    };\n-    err.update_err(\"couldn't stat path\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n+    fs_imp::stat(path)\n+           .update_err(\"couldn't stat path\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Perform the same operation as the `stat` function, except that this\n@@ -358,53 +309,9 @@ pub fn stat(path: &Path) -> IoResult<FileStat> {\n ///\n /// See `stat`\n pub fn lstat(path: &Path) -> IoResult<FileStat> {\n-    let err = match LocalIo::maybe_raise(|io| io.fs_lstat(&path.to_c_str())) {\n-        Ok(s) => Ok(from_rtio(s)),\n-        Err(e) => Err(IoError::from_rtio_error(e)),\n-    };\n-    err.update_err(\"couldn't lstat path\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-fn from_rtio(s: rtio::FileStat) -> FileStat {\n-    #[cfg(windows)]\n-    type Mode = libc::c_int;\n-    #[cfg(unix)]\n-    type Mode = libc::mode_t;\n-\n-    let rtio::FileStat {\n-        size, kind, perm, created, modified,\n-        accessed, device, inode, rdev,\n-        nlink, uid, gid, blksize, blocks, flags, gen\n-    } = s;\n-\n-    FileStat {\n-        size: size,\n-        kind: match (kind as Mode) & libc::S_IFMT {\n-            libc::S_IFREG => io::TypeFile,\n-            libc::S_IFDIR => io::TypeDirectory,\n-            libc::S_IFIFO => io::TypeNamedPipe,\n-            libc::S_IFBLK => io::TypeBlockSpecial,\n-            libc::S_IFLNK => io::TypeSymlink,\n-            _ => io::TypeUnknown,\n-        },\n-        perm: FilePermission::from_bits_truncate(perm as u32),\n-        created: created,\n-        modified: modified,\n-        accessed: accessed,\n-        unstable: UnstableFileStat {\n-            device: device,\n-            inode: inode,\n-            rdev: rdev,\n-            nlink: nlink,\n-            uid: uid,\n-            gid: gid,\n-            blksize: blksize,\n-            blocks: blocks,\n-            flags: flags,\n-            gen: gen,\n-        },\n-    }\n+    fs_imp::lstat(path)\n+           .update_err(\"couldn't lstat path\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Rename a file or directory to a new name.\n@@ -424,12 +331,9 @@ fn from_rtio(s: rtio::FileStat) -> FileStat {\n /// the process lacks permissions to view the contents, or if some other\n /// intermittent I/O error occurs.\n pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_rename(&from.to_c_str(), &to.to_c_str())\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't rename path\", |e| {\n-        format!(\"{}; from={}; to={}\", e, from.display(), to.display())\n-    })\n+    fs_imp::rename(from, to)\n+           .update_err(\"couldn't rename path\", |e|\n+               format!(\"{}; from={}; to={}\", e, from.display(), to.display()))\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -462,8 +366,9 @@ pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n /// being created and then destroyed by this operation.\n pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n     fn update_err<T>(result: IoResult<T>, from: &Path, to: &Path) -> IoResult<T> {\n-        result.update_err(\"couldn't copy path\",\n-            |e| format!(\"{}; from={}; to={}\", e, from.display(), to.display()))\n+        result.update_err(\"couldn't copy path\", |e| {\n+            format!(\"{}; from={}; to={}\", e, from.display(), to.display())\n+        })\n     }\n \n     if !from.is_file() {\n@@ -512,45 +417,33 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// the process lacks permissions to change the attributes of the file, or if\n /// some other I/O error is encountered.\n pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_chmod(&path.to_c_str(), mode.bits() as uint)\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't chmod path\", |e| {\n-        format!(\"{}; path={}; mode={}\", e, path.display(), mode)\n-    })\n+    fs_imp::chmod(path, mode.bits() as uint)\n+           .update_err(\"couldn't chmod path\", |e|\n+               format!(\"{}; path={}; mode={}\", e, path.display(), mode))\n }\n \n /// Change the user and group owners of a file at the specified path.\n pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_chown(&path.to_c_str(), uid, gid)\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't chown path\", |e| {\n-        format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid)\n-    })\n+    fs_imp::chown(path, uid, gid)\n+           .update_err(\"couldn't chown path\", |e|\n+               format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid))\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n /// link pointing to the `src` path. Note that systems often require these\n /// two paths to both be located on the same filesystem.\n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_link(&src.to_c_str(), &dst.to_c_str())\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't link path\", |e| {\n-        format!(\"{}; src={}; dest={}\", e, src.display(), dst.display())\n-    })\n+    fs_imp::link(src, dst)\n+           .update_err(\"couldn't link path\", |e|\n+               format!(\"{}; src={}; dest={}\", e, src.display(), dst.display()))\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n /// symlink pointing to the `src` path.\n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_symlink(&src.to_c_str(), &dst.to_c_str())\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't symlink path\", |e| {\n-        format!(\"{}; src={}; dest={}\", e, src.display(), dst.display())\n-    })\n+    fs_imp::symlink(src, dst)\n+           .update_err(\"couldn't symlink path\", |e|\n+               format!(\"{}; src={}; dest={}\", e, src.display(), dst.display()))\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -560,11 +453,9 @@ pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n /// This function will return an error on failure. Failure conditions include\n /// reading a file that does not exist or reading a file which is not a symlink.\n pub fn readlink(path: &Path) -> IoResult<Path> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        Ok(Path::new(try!(io.fs_readlink(&path.to_c_str()))))\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't resolve symlink for path\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n+    fs_imp::readlink(path)\n+           .update_err(\"couldn't resolve symlink for path\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Create a new, empty directory at the provided path\n@@ -585,12 +476,9 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// This function will return an error if the user lacks permissions to make a\n /// new directory at the provided `path`, or if the directory already exists.\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_mkdir(&path.to_c_str(), mode.bits() as uint)\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't create directory\", |e| {\n-        format!(\"{}; path={}; mode={}\", e, path.display(), mode)\n-    })\n+    fs_imp::mkdir(path, mode.bits() as uint)\n+           .update_err(\"couldn't create directory\", |e|\n+               format!(\"{}; path={}; mode={}\", e, path.display(), mode))\n }\n \n /// Remove an existing, empty directory\n@@ -610,11 +498,9 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// This function will return an error if the user lacks permissions to remove\n /// the directory at the provided `path`, or if the directory isn't empty.\n pub fn rmdir(path: &Path) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_rmdir(&path.to_c_str())\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't remove directory\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n+    fs_imp::rmdir(path)\n+           .update_err(\"couldn't remove directory\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -650,13 +536,9 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        Ok(try!(io.fs_readdir(&path.to_c_str(), 0)).into_iter().map(|a| {\n-            Path::new(a)\n-        }).collect())\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't read directory\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n+    fs_imp::readdir(path)\n+           .update_err(\"couldn't read directory\",\n+                       |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n@@ -666,8 +548,7 @@ pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n     Ok(Directories {\n         stack: try!(readdir(path).update_err(\"couldn't walk directory\",\n-                                             |e| format!(\"{}; path={}\",\n-                                                         e, path.display())))\n+                                             |e| format!(\"{}; path={}\", e, path.display())))\n     })\n }\n \n@@ -681,12 +562,7 @@ impl Iterator<Path> for Directories {\n         match self.stack.pop() {\n             Some(path) => {\n                 if path.is_dir() {\n-                    let result = readdir(&path)\n-                        .update_err(\"couldn't advance Directories iterator\",\n-                                    |e| format!(\"{}; path={}\",\n-                                                e, path.display()));\n-\n-                    match result {\n+                    match readdir(&path) {\n                         Ok(dirs) => { self.stack.extend(dirs.into_iter()); }\n                         Err(..) => {}\n                     }\n@@ -804,11 +680,9 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n /// be in milliseconds.\n // FIXME(#10301) these arguments should not be u64\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_utime(&path.to_c_str(), atime, mtime)\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't change_file_times\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n+    fs_imp::utime(path, atime, mtime)\n+           .update_err(\"couldn't change_file_times\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n impl Reader for File {\n@@ -819,12 +693,11 @@ impl Reader for File {\n                                           e, file.path.display()))\n         }\n \n-        let result = update_err(self.fd.read(buf)\n-                                    .map_err(IoError::from_rtio_error), self);\n+        let result = update_err(self.fd.read(buf), self);\n \n         match result {\n             Ok(read) => {\n-                self.last_nread = read;\n+                self.last_nread = read as int;\n                 match read {\n                     0 => update_err(Err(standard_error(io::EndOfFile)), self),\n                     _ => Ok(read as uint)\n@@ -837,32 +710,27 @@ impl Reader for File {\n \n impl Writer for File {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let err = self.fd.write(buf).map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't write to file\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n+        self.fd.write(buf)\n+            .update_err(\"couldn't write to file\",\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n impl Seek for File {\n     fn tell(&self) -> IoResult<u64> {\n-        let err = self.fd.tell().map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't retrieve file cursor (`tell`)\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n+        self.fd.tell()\n+            .update_err(\"couldn't retrieve file cursor (`tell`)\",\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let style = match style {\n-            SeekSet => rtio::SeekSet,\n-            SeekCur => rtio::SeekCur,\n-            SeekEnd => rtio::SeekEnd,\n-        };\n         let err = match self.fd.seek(pos, style) {\n             Ok(_) => {\n                 // successful seek resets EOF indicator\n                 self.last_nread = -1;\n                 Ok(())\n             }\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n+            Err(e) => Err(e),\n         };\n         err.update_err(\"couldn't seek in file\",\n                        |e| format!(\"{}; path={}\", e, self.path.display()))\n@@ -942,6 +810,8 @@ fn access_string(access: FileAccess) -> &'static str {\n \n #[cfg(test)]\n #[allow(unused_imports)]\n+#[allow(unused_variables)]\n+#[allow(unused_mut)]\n mod test {\n     use prelude::*;\n     use io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite};"}, {"sha": "03c073c1477d5c5f91d0c6e74dd4491a7bfdcaa1", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=0c1e1ff1e300868a29405a334e65eae690df971d", "patch": "@@ -316,6 +316,7 @@ impl IoError {\n             err.detail = Some(os::error_string(errno).as_slice().chars()\n                                  .map(|c| c.to_lowercase()).collect())\n         }\n+        err\n     }\n \n     /// Retrieve the last error to occur as a (detailed) IoError."}, {"sha": "98644cfc7e995df7a4d979d5280fcdbc39e92fe3", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=0c1e1ff1e300868a29405a334e65eae690df971d", "patch": "@@ -36,11 +36,11 @@ use kinds::Send;\n use libc;\n use option::{Option, Some, None};\n use boxed::Box;\n+use sys::fs::FileDesc;\n use result::{Ok, Err};\n use rt;\n use rt::local::Local;\n use rt::task::Task;\n-use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n use slice::SlicePrelude;\n use str::StrPrelude;\n use uint;\n@@ -75,14 +75,14 @@ use uint;\n //        case pipe also doesn't work, but magically file does!\n enum StdSource {\n     TTY(Box<RtioTTY + Send>),\n-    File(Box<RtioFileStream + Send>),\n+    File(FileDesc),\n }\n \n fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n     LocalIo::maybe_raise(|io| {\n         Ok(match io.tty_open(fd, readable) {\n             Ok(tty) => f(TTY(tty)),\n-            Err(_) => f(File(io.fs_from_raw_fd(fd, DontClose))),\n+            Err(_) => f(File(FileDesc::new(fd, false))),\n         })\n     }).map_err(IoError::from_rtio_error).unwrap()\n }\n@@ -278,10 +278,10 @@ impl Reader for StdReader {\n                 // print!'d prompt not being shown until after the user hits\n                 // enter.\n                 flush();\n-                tty.read(buf)\n+                tty.read(buf).map_err(IoError::from_rtio_error)\n             },\n             File(ref mut file) => file.read(buf).map(|i| i as uint),\n-        }.map_err(IoError::from_rtio_error);\n+        };\n         match ret {\n             // When reading a piped stdin, libuv will return 0-length reads when\n             // stdin reaches EOF. For pretty much all other streams it will\n@@ -372,9 +372,9 @@ impl Writer for StdWriter {\n         let max_size = if cfg!(windows) {8192} else {uint::MAX};\n         for chunk in buf.chunks(max_size) {\n             try!(match self.inner {\n-                TTY(ref mut tty) => tty.write(chunk),\n+                TTY(ref mut tty) => tty.write(chunk).map_err(IoError::from_rtio_error),\n                 File(ref mut file) => file.write(chunk),\n-            }.map_err(IoError::from_rtio_error))\n+            })\n         }\n         Ok(())\n     }"}, {"sha": "3dcd99859e8cf5cfe26801e88bc6313b64a48e14", "filename": "src/libstd/platform_imp/unix/fs.rs", "status": "added", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibstd%2Fplatform_imp%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibstd%2Fplatform_imp%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fplatform_imp%2Funix%2Ffs.rs?ref=0c1e1ff1e300868a29405a334e65eae690df971d", "patch": "@@ -0,0 +1,411 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Blocking posix-based file I/O\n+\n+use libc::{mod, c_int, c_void};\n+use c_str::CString;\n+use mem;\n+use io;\n+\n+use prelude::*;\n+\n+use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n+use io::{IoResult, FileStat, SeekStyle, Reader};\n+use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n+use result::{Ok, Err};\n+use sys::retry;\n+use sys_common::{keep_going, eof, mkerr_libc};\n+\n+pub use path::PosixPath as Path;\n+\n+pub type fd_t = libc::c_int;\n+\n+pub struct FileDesc {\n+    /// The underlying C file descriptor.\n+    fd: fd_t,\n+\n+    /// Whether to close the file descriptor on drop.\n+    close_on_drop: bool,\n+}\n+\n+impl FileDesc {\n+    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n+        FileDesc { fd: fd, close_on_drop: close_on_drop }\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> IoResult<uint> {\n+        let ret = retry(|| unsafe {\n+            libc::read(self.fd(),\n+                       buf.as_mut_ptr() as *mut libc::c_void,\n+                       buf.len() as libc::size_t)\n+        });\n+        if ret == 0 {\n+            Err(eof())\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as uint)\n+        }\n+    }\n+    pub fn write(&self, buf: &[u8]) -> IoResult<()> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::write(self.fd(), buf as *const libc::c_void,\n+                            len as libc::size_t) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    pub fn fd(&self) -> fd_t { self.fd }\n+\n+    pub fn seek(&self, pos: i64, whence: SeekStyle) -> IoResult<u64> {\n+        let whence = match whence {\n+            SeekSet => libc::SEEK_SET,\n+            SeekEnd => libc::SEEK_END,\n+            SeekCur => libc::SEEK_CUR,\n+        };\n+        let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n+    }\n+\n+    pub fn tell(&self) -> IoResult<u64> {\n+        let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n+    }\n+\n+    pub fn fsync(&self) -> IoResult<()> {\n+        mkerr_libc(retry(|| unsafe { libc::fsync(self.fd()) }))\n+    }\n+\n+    pub fn datasync(&self) -> IoResult<()> {\n+        return mkerr_libc(os_datasync(self.fd()));\n+\n+        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n+        }\n+        #[cfg(target_os = \"linux\")]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            retry(|| unsafe { libc::fdatasync(fd) })\n+        }\n+        #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"linux\")))]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            retry(|| unsafe { libc::fsync(fd) })\n+        }\n+    }\n+\n+    pub fn truncate(&self, offset: i64) -> IoResult<()> {\n+        mkerr_libc(retry(|| unsafe {\n+            libc::ftruncate(self.fd(), offset as libc::off_t)\n+        }))\n+    }\n+\n+    pub fn fstat(&self) -> IoResult<FileStat> {\n+        let mut stat: libc::stat = unsafe { mem::zeroed() };\n+        match unsafe { libc::fstat(self.fd(), &mut stat) } {\n+            0 => Ok(mkstat(&stat)),\n+            _ => Err(super::last_error()),\n+        }\n+    }\n+\n+    /// Extract the actual filedescriptor without closing it.\n+    pub fn unwrap(self) -> fd_t {\n+        let fd = self.fd;\n+        unsafe { mem::forget(self) };\n+        fd\n+    }\n+}\n+\n+/*\n+\n+impl RtioTTY for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.inner_read(buf)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.inner_write(buf)\n+    }\n+    fn set_raw(&mut self, _raw: bool) -> IoResult<()> {\n+        Err(super::unimpl())\n+    }\n+    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n+        Err(super::unimpl())\n+    }\n+    fn isatty(&self) -> bool { false }\n+}\n+*/\n+\n+impl Drop for FileDesc {\n+    fn drop(&mut self) {\n+        // closing stdio file handles makes no sense, so never do it. Also, note\n+        // that errors are ignored when closing a file descriptor. The reason\n+        // for this is that if an error occurs we don't actually know if the\n+        // file descriptor was closed or not, and if we retried (for something\n+        // like EINTR), we might close another valid file descriptor (opened\n+        // after we closed ours.\n+        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n+            let n = unsafe { libc::close(self.fd) };\n+            if n != 0 {\n+                println!(\"error {} when closing file descriptor {}\", n, self.fd);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n+    let flags = match fm {\n+        Open => 0,\n+        Append => libc::O_APPEND,\n+        Truncate => libc::O_TRUNC,\n+    };\n+    // Opening with a write permission must silently create the file.\n+    let (flags, mode) = match fa {\n+        Read => (flags | libc::O_RDONLY, 0),\n+        Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n+                        libc::S_IRUSR | libc::S_IWUSR),\n+        ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n+                            libc::S_IRUSR | libc::S_IWUSR),\n+    };\n+\n+    let path = path.to_c_str();\n+    match retry(|| unsafe { libc::open(path.as_ptr(), flags, mode) }) {\n+        -1 => Err(super::last_error()),\n+        fd => Ok(FileDesc::new(fd, true)),\n+    }\n+}\n+\n+pub fn mkdir(p: &Path, mode: uint) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    mkerr_libc(unsafe { libc::mkdir(p.as_ptr(), mode as libc::mode_t) })\n+}\n+\n+pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n+    use libc::{dirent_t};\n+    use libc::{opendir, readdir_r, closedir};\n+\n+    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> {\n+        let root = unsafe { CString::new(root.as_ptr(), false) };\n+        let root = Path::new(root);\n+\n+        dirs.into_iter().filter(|path| {\n+            path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n+        }).map(|path| root.join(path)).collect()\n+    }\n+\n+    extern {\n+        fn rust_dirent_t_size() -> libc::c_int;\n+        fn rust_list_dir_val(ptr: *mut dirent_t) -> *const libc::c_char;\n+    }\n+\n+    let size = unsafe { rust_dirent_t_size() };\n+    let mut buf = Vec::<u8>::with_capacity(size as uint);\n+    let ptr = buf.as_mut_slice().as_mut_ptr() as *mut dirent_t;\n+\n+    let p = p.to_c_str();\n+    let dir_ptr = unsafe {opendir(p.as_ptr())};\n+\n+    if dir_ptr as uint != 0 {\n+        let mut paths = vec!();\n+        let mut entry_ptr = 0 as *mut dirent_t;\n+        while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n+            if entry_ptr.is_null() { break }\n+            let cstr = unsafe {\n+                CString::new(rust_list_dir_val(entry_ptr), false)\n+            };\n+            paths.push(Path::new(cstr));\n+        }\n+        assert_eq!(unsafe { closedir(dir_ptr) }, 0);\n+        Ok(prune(&p, paths))\n+    } else {\n+        Err(super::last_error())\n+    }\n+}\n+\n+pub fn unlink(p: &Path) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    mkerr_libc(unsafe { libc::unlink(p.as_ptr()) })\n+}\n+\n+pub fn rename(old: &Path, new: &Path) -> IoResult<()> {\n+    let old = old.to_c_str();\n+    let new = new.to_c_str();\n+    mkerr_libc(unsafe {\n+        libc::rename(old.as_ptr(), new.as_ptr())\n+    })\n+}\n+\n+pub fn chmod(p: &Path, mode: uint) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    mkerr_libc(retry(|| unsafe {\n+        libc::chmod(p.as_ptr(), mode as libc::mode_t)\n+    }))\n+}\n+\n+pub fn rmdir(p: &Path) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    mkerr_libc(unsafe { libc::rmdir(p.as_ptr()) })\n+}\n+\n+pub fn chown(p: &Path, uid: int, gid: int) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    mkerr_libc(retry(|| unsafe {\n+        libc::chown(p.as_ptr(), uid as libc::uid_t, gid as libc::gid_t)\n+    }))\n+}\n+\n+pub fn readlink(p: &Path) -> IoResult<Path> {\n+    let c_path = p.to_c_str();\n+    let p = c_path.as_ptr();\n+    let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n+    if len == -1 {\n+        len = 1024; // FIXME: read PATH_MAX from C ffi?\n+    }\n+    let mut buf: Vec<u8> = Vec::with_capacity(len as uint);\n+    match unsafe {\n+        libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n+                       len as libc::size_t) as libc::c_int\n+    } {\n+        -1 => Err(super::last_error()),\n+        n => {\n+            assert!(n > 0);\n+            unsafe { buf.set_len(n as uint); }\n+            Ok(Path::new(buf))\n+        }\n+    }\n+}\n+\n+pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n+    let src = src.to_c_str();\n+    let dst = dst.to_c_str();\n+    mkerr_libc(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })\n+}\n+\n+pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n+    let src = src.to_c_str();\n+    let dst = dst.to_c_str();\n+    mkerr_libc(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })\n+}\n+\n+fn mkstat(stat: &libc::stat) -> FileStat {\n+    // FileStat times are in milliseconds\n+    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    fn flags(_stat: &libc::stat) -> u64 { 0 }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    fn gen(_stat: &libc::stat) -> u64 { 0 }\n+\n+    FileStat {\n+        size: stat.st_size as u64,\n+        kind: match (stat.st_mode as libc::mode_t) & libc::S_IFMT {\n+            libc::S_IFREG => io::TypeFile,\n+            libc::S_IFDIR => io::TypeDirectory,\n+            libc::S_IFIFO => io::TypeNamedPipe,\n+            libc::S_IFBLK => io::TypeBlockSpecial,\n+            libc::S_IFLNK => io::TypeSymlink,\n+            _ => io::TypeUnknown,\n+        },\n+        perm: FilePermission::from_bits_truncate(stat.st_mode as u32),\n+        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n+        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n+        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n+        unstable: UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: stat.st_blksize as u64,\n+            blocks: stat.st_blocks as u64,\n+            flags: flags(stat),\n+            gen: gen(stat),\n+        },\n+    }\n+}\n+\n+pub fn stat(p: &Path) -> IoResult<FileStat> {\n+    let p = p.to_c_str();\n+    let mut stat: libc::stat = unsafe { mem::zeroed() };\n+    match unsafe { libc::stat(p.as_ptr(), &mut stat) } {\n+        0 => Ok(mkstat(&stat)),\n+        _ => Err(super::last_error()),\n+    }\n+}\n+\n+pub fn lstat(p: &Path) -> IoResult<FileStat> {\n+    let p = p.to_c_str();\n+    let mut stat: libc::stat = unsafe { mem::zeroed() };\n+    match unsafe { libc::lstat(p.as_ptr(), &mut stat) } {\n+        0 => Ok(mkstat(&stat)),\n+        _ => Err(super::last_error()),\n+    }\n+}\n+\n+pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    let buf = libc::utimbuf {\n+        actime: (atime / 1000) as libc::time_t,\n+        modtime: (mtime / 1000) as libc::time_t,\n+    };\n+    mkerr_libc(unsafe { libc::utime(p.as_ptr(), &buf) })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::FileDesc;\n+    use libc;\n+    use os;\n+    use prelude::*;\n+\n+    #[cfg_attr(target_os = \"freebsd\", ignore)] // hmm, maybe pipes have a tiny buffer\n+    #[test]\n+    fn test_file_desc() {\n+        // Run this test with some pipes so we don't have to mess around with\n+        // opening or closing files.\n+        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n+        let mut reader = FileDesc::new(reader, true);\n+        let mut writer = FileDesc::new(writer, true);\n+\n+        writer.write(b\"test\").ok().unwrap();\n+        let mut buf = [0u8, ..4];\n+        match reader.read(buf) {\n+            Ok(4) => {\n+                assert_eq!(buf[0], 't' as u8);\n+                assert_eq!(buf[1], 'e' as u8);\n+                assert_eq!(buf[2], 's' as u8);\n+                assert_eq!(buf[3], 't' as u8);\n+            }\n+            r => panic!(\"invalid read: {}\", r),\n+        }\n+\n+        assert!(writer.read(buf).is_err());\n+        assert!(reader.write(buf).is_err());\n+    }\n+}"}, {"sha": "a07688b2fed03e0ece26ff4b01ab742620ec4368", "filename": "src/libstd/platform_imp/windows/fs.rs", "status": "renamed", "additions": 155, "deletions": 218, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibstd%2Fplatform_imp%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1e1ff1e300868a29405a334e65eae690df971d/src%2Flibstd%2Fplatform_imp%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fplatform_imp%2Fwindows%2Ffs.rs?ref=0c1e1ff1e300868a29405a334e65eae690df971d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,42 +12,40 @@\n \n use alloc::arc::Arc;\n use libc::{mod, c_int};\n-use std::c_str::CString;\n-use std::mem;\n-use std::os::windows::fill_utf16_buf_and_decode;\n-use std::ptr;\n-use std::rt::rtio;\n-use std::rt::rtio::{IoResult, IoError};\n-use std::str;\n \n-pub type fd_t = libc::c_int;\n+use c_str::CString;\n+use mem;\n+use os::windows::fill_utf16_buf_and_decode;\n+use path;\n+use ptr;\n+use str;\n+use io;\n \n-struct Inner {\n-    fd: fd_t,\n-    close_on_drop: bool,\n-}\n+use prelude::*;\n+use sys;\n+use sys_common::{keep_going, eof, mkerr_libc};\n+\n+use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n+use io::{IoResult, IoError, FileStat, SeekStyle, Seek, Writer, Reader};\n+use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n+\n+pub use path::WindowsPath as Path;\n+pub type fd_t = libc::c_int;\n \n pub struct FileDesc {\n-    inner: Arc<Inner>\n+    /// The underlying C file descriptor.\n+    pub fd: fd_t,\n+\n+    /// Whether to close the file descriptor on drop.\n+    close_on_drop: bool,\n }\n \n impl FileDesc {\n-    /// Create a `FileDesc` from an open C file descriptor.\n-    ///\n-    /// The `FileDesc` will take ownership of the specified file descriptor and\n-    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n-    /// it will not close the file descriptor when this `FileDesc` is dropped.\n-    ///\n-    /// Note that all I/O operations done on this object will be *blocking*, but\n-    /// they do not require the runtime to be active.\n     pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n-        FileDesc { inner: Arc::new(Inner {\n-            fd: fd,\n-            close_on_drop: close_on_drop\n-        }) }\n+        FileDesc { fd: fd, close_on_drop: close_on_drop }\n     }\n \n-    pub fn inner_read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&self, buf: &mut [u8]) -> IoResult<uint> {\n         let mut read = 0;\n         let ret = unsafe {\n             libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n@@ -60,7 +58,8 @@ impl FileDesc {\n             Err(super::last_error())\n         }\n     }\n-    pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> {\n+\n+    pub fn write(&self, buf: &[u8]) -> IoResult<()> {\n         let mut cur = buf.as_ptr();\n         let mut remaining = buf.len();\n         while remaining > 0 {\n@@ -80,161 +79,75 @@ impl FileDesc {\n         Ok(())\n     }\n \n-    pub fn fd(&self) -> fd_t { self.inner.fd }\n+    pub fn fd(&self) -> fd_t { self.fd }\n \n     pub fn handle(&self) -> libc::HANDLE {\n         unsafe { libc::get_osfhandle(self.fd()) as libc::HANDLE }\n     }\n \n     // A version of seek that takes &self so that tell can call it\n     //   - the private seek should of course take &mut self.\n-    fn seek_common(&self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n+    fn seek_common(&self, pos: i64, style: SeekStyle) -> IoResult<u64> {\n         let whence = match style {\n-            rtio::SeekSet => libc::FILE_BEGIN,\n-            rtio::SeekEnd => libc::FILE_END,\n-            rtio::SeekCur => libc::FILE_CURRENT,\n+            SeekSet => libc::FILE_BEGIN,\n+            SeekEnd => libc::FILE_END,\n+            SeekCur => libc::FILE_CURRENT,\n         };\n         unsafe {\n             let mut newpos = 0;\n-            match libc::SetFilePointerEx(self.handle(), pos, &mut newpos,\n-                                         whence) {\n+            match libc::SetFilePointerEx(self.handle(), pos, &mut newpos, whence) {\n                 0 => Err(super::last_error()),\n                 _ => Ok(newpos as u64),\n             }\n         }\n     }\n \n-}\n-\n-impl rtio::RtioFileStream for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n-        self.inner_read(buf).map(|i| i as int)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n-        let mut read = 0;\n-        let mut overlap: libc::OVERLAPPED = unsafe { mem::zeroed() };\n-        overlap.Offset = offset as libc::DWORD;\n-        overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n-        let ret = unsafe {\n-            libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n-                           buf.len() as libc::DWORD, &mut read,\n-                           &mut overlap)\n-        };\n-        if ret != 0 {\n-            Ok(read as int)\n-        } else {\n-            Err(super::last_error())\n-        }\n-    }\n-    fn pwrite(&mut self, buf: &[u8], mut offset: u64) -> IoResult<()> {\n-        let mut cur = buf.as_ptr();\n-        let mut remaining = buf.len();\n-        let mut overlap: libc::OVERLAPPED = unsafe { mem::zeroed() };\n-        while remaining > 0 {\n-            overlap.Offset = offset as libc::DWORD;\n-            overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n-            let mut amt = 0;\n-            let ret = unsafe {\n-                libc::WriteFile(self.handle(), cur as libc::LPVOID,\n-                                remaining as libc::DWORD, &mut amt,\n-                                &mut overlap)\n-            };\n-            if ret != 0 {\n-                remaining -= amt as uint;\n-                cur = unsafe { cur.offset(amt as int) };\n-                offset += amt as u64;\n-            } else {\n-                return Err(super::last_error())\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    fn seek(&mut self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n+    pub fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<u64> {\n         self.seek_common(pos, style)\n     }\n \n-    fn tell(&self) -> IoResult<u64> {\n-        self.seek_common(0, rtio::SeekCur)\n+    pub fn tell(&self) -> IoResult<u64> {\n+        self.seek_common(0, SeekCur)\n     }\n \n-    fn fsync(&mut self) -> IoResult<()> {\n+    pub fn fsync(&mut self) -> IoResult<()> {\n         super::mkerr_winbool(unsafe {\n             libc::FlushFileBuffers(self.handle())\n         })\n     }\n \n-    fn datasync(&mut self) -> IoResult<()> { return self.fsync(); }\n+    pub fn datasync(&mut self) -> IoResult<()> { return self.fsync(); }\n \n-    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n+    pub fn truncate(&mut self, offset: i64) -> IoResult<()> {\n         let orig_pos = try!(self.tell());\n-        let _ = try!(self.seek(offset, rtio::SeekSet));\n+        let _ = try!(self.seek(offset, SeekSet));\n         let ret = unsafe {\n             match libc::SetEndOfFile(self.handle()) {\n                 0 => Err(super::last_error()),\n                 _ => Ok(())\n             }\n         };\n-        let _ = self.seek(orig_pos as i64, rtio::SeekSet);\n+        let _ = self.seek(orig_pos as i64, SeekSet);\n         return ret;\n     }\n \n-    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n+    pub fn fstat(&mut self) -> IoResult<io::FileStat> {\n         let mut stat: libc::stat = unsafe { mem::zeroed() };\n         match unsafe { libc::fstat(self.fd(), &mut stat) } {\n             0 => Ok(mkstat(&stat)),\n             _ => Err(super::last_error()),\n         }\n     }\n-}\n \n-impl rtio::RtioPipe for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-    fn clone(&self) -> Box<rtio::RtioPipe + Send> {\n-        box FileDesc { inner: self.inner.clone() } as Box<rtio::RtioPipe + Send>\n-    }\n-\n-    // Only supported on named pipes currently. Note that this doesn't have an\n-    // impact on the std::io primitives, this is never called via\n-    // std::io::PipeStream. If the functionality is exposed in the future, then\n-    // these methods will need to be implemented.\n-    fn close_read(&mut self) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn close_write(&mut self) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn set_timeout(&mut self, _t: Option<u64>) {}\n-    fn set_read_timeout(&mut self, _t: Option<u64>) {}\n-    fn set_write_timeout(&mut self, _t: Option<u64>) {}\n-}\n-\n-impl rtio::RtioTTY for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n+    /// Extract the actual filedescriptor without closing it.\n+    pub fn unwrap(self) -> fd_t {\n+        let fd = self.fd;\n+        unsafe { mem::forget(self) };\n+        fd\n     }\n-    fn set_raw(&mut self, _raw: bool) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n-        Err(super::unimpl())\n-    }\n-    fn isatty(&self) -> bool { false }\n }\n \n-impl Drop for Inner {\n+impl Drop for FileDesc {\n     fn drop(&mut self) {\n         // closing stdio file handles makes no sense, so never do it. Also, note\n         // that errors are ignored when closing a file descriptor. The reason\n@@ -251,39 +164,26 @@ impl Drop for Inner {\n     }\n }\n \n-pub fn to_utf16(s: &CString) -> IoResult<Vec<u16>> {\n-    match s.as_str() {\n-        Some(s) => Ok({\n-            let mut s = s.utf16_units().collect::<Vec<u16>>();\n-            s.push(0);\n-            s\n-        }),\n-        None => Err(IoError {\n-            code: libc::ERROR_INVALID_NAME as uint,\n-            extra: 0,\n-            detail: Some(\"valid unicode input required\".to_string()),\n-        })\n-    }\n+pub fn to_utf16(s: &Path) -> IoResult<Vec<u16>> {\n+    sys::to_utf16(s.as_str())\n }\n \n-pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n-        -> IoResult<FileDesc> {\n+pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n     // Flags passed to open_osfhandle\n     let flags = match fm {\n-        rtio::Open => 0,\n-        rtio::Append => libc::O_APPEND,\n-        rtio::Truncate => libc::O_TRUNC,\n+        Open => 0,\n+        Append => libc::O_APPEND,\n+        Truncate => libc::O_TRUNC,\n     };\n     let flags = match fa {\n-        rtio::Read => flags | libc::O_RDONLY,\n-        rtio::Write => flags | libc::O_WRONLY | libc::O_CREAT,\n-        rtio::ReadWrite => flags | libc::O_RDWR | libc::O_CREAT,\n+        Read => flags | libc::O_RDONLY,\n+        Write => flags | libc::O_WRONLY | libc::O_CREAT,\n+        ReadWrite => flags | libc::O_RDWR | libc::O_CREAT,\n     };\n-\n     let mut dwDesiredAccess = match fa {\n-        rtio::Read => libc::FILE_GENERIC_READ,\n-        rtio::Write => libc::FILE_GENERIC_WRITE,\n-        rtio::ReadWrite => libc::FILE_GENERIC_READ | libc::FILE_GENERIC_WRITE\n+        Read => libc::FILE_GENERIC_READ,\n+        Write => libc::FILE_GENERIC_WRITE,\n+        ReadWrite => libc::FILE_GENERIC_READ | libc::FILE_GENERIC_WRITE\n     };\n \n     // libuv has a good comment about this, but the basic idea is what we try to\n@@ -293,15 +193,15 @@ pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n                       libc::FILE_SHARE_DELETE;\n \n     let dwCreationDisposition = match (fm, fa) {\n-        (rtio::Truncate, rtio::Read) => libc::TRUNCATE_EXISTING,\n-        (rtio::Truncate, _) => libc::CREATE_ALWAYS,\n-        (rtio::Open, rtio::Read) => libc::OPEN_EXISTING,\n-        (rtio::Open, _) => libc::OPEN_ALWAYS,\n-        (rtio::Append, rtio::Read) => {\n+        (Truncate, Read) => libc::TRUNCATE_EXISTING,\n+        (Truncate, _) => libc::CREATE_ALWAYS,\n+        (Open, Read) => libc::OPEN_EXISTING,\n+        (Open, _) => libc::OPEN_ALWAYS,\n+        (Append, Read) => {\n             dwDesiredAccess |= libc::FILE_APPEND_DATA;\n             libc::OPEN_EXISTING\n         }\n-        (rtio::Append, _) => {\n+        (Append, _) => {\n             dwDesiredAccess &= !libc::FILE_WRITE_DATA;\n             dwDesiredAccess |= libc::FILE_APPEND_DATA;\n             libc::OPEN_ALWAYS\n@@ -337,28 +237,23 @@ pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n     }\n }\n \n-pub fn mkdir(p: &CString, _mode: uint) -> IoResult<()> {\n+pub fn mkdir(p: &Path, _mode: uint) -> IoResult<()> {\n     let p = try!(to_utf16(p));\n     super::mkerr_winbool(unsafe {\n         // FIXME: turn mode into something useful? #2623\n         libc::CreateDirectoryW(p.as_ptr(), ptr::null_mut())\n     })\n }\n \n-pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n-    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> {\n-        let root = unsafe { CString::new(root.as_ptr(), false) };\n-        let root = Path::new(root);\n-\n+pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n+    fn prune(root: &Path, dirs: Vec<Path>) -> Vec<Path> {\n         dirs.into_iter().filter(|path| {\n             path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n-        }).map(|path| root.join(path).to_c_str()).collect()\n+        }).map(|path| root.join(path)).collect()\n     }\n \n-    let star = Path::new(unsafe {\n-        CString::new(p.as_ptr(), false)\n-    }).join(\"*\");\n-    let path = try!(to_utf16(&star.to_c_str()));\n+    let star = p.join(\"*\");\n+    let path = try!(to_utf16(&star));\n \n     unsafe {\n         let mut wfd = mem::zeroed();\n@@ -374,8 +269,8 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n                         None => {\n                             assert!(libc::FindClose(find_handle) != 0);\n                             return Err(IoError {\n-                                code: super::c::ERROR_ILLEGAL_CHARACTER as uint,\n-                                extra: 0,\n+                                kind: io::InvalidInput,\n+                                desc: \"path was not valid UTF-16\",\n                                 detail: Some(format!(\"path was not valid UTF-16: {}\", filename)),\n                             })\n                         }, // FIXME #12056: Convert the UCS-2 to invalid utf-8 instead of erroring\n@@ -391,42 +286,74 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n     }\n }\n \n-pub fn unlink(p: &CString) -> IoResult<()> {\n-    let p = try!(to_utf16(p));\n-    super::mkerr_winbool(unsafe {\n-        libc::DeleteFileW(p.as_ptr())\n-    })\n+pub fn unlink(p: &Path) -> IoResult<()> {\n+    fn do_unlink(p_utf16: &Vec<u16>) -> IoResult<()> {\n+        super::mkerr_winbool(unsafe { libc::DeleteFileW(p_utf16.as_ptr()) })\n+    }\n+\n+    let p_utf16 = try!(to_utf16(p));\n+    let res = do_unlink(&p_utf16);\n+    match res {\n+        Ok(()) => Ok(()),\n+        Err(e) => {\n+            // FIXME: change the code below to use more direct calls\n+            // than `stat` and `chmod`, to avoid re-conversion to\n+            // utf16 etc.\n+\n+            // On unix, a readonly file can be successfully removed. On windows,\n+            // however, it cannot. To keep the two platforms in line with\n+            // respect to their behavior, catch this case on windows, attempt to\n+            // change it to read-write, and then remove the file.\n+            if e.kind == io::PermissionDenied {\n+                let stat = match stat(p) {\n+                    Ok(stat) => stat,\n+                    Err(..) => return Err(e),\n+                };\n+                if stat.perm.intersects(io::USER_WRITE) { return Err(e) }\n+\n+                match chmod(p, (stat.perm | io::USER_WRITE).bits() as uint) {\n+                    Ok(()) => do_unlink(&p_utf16),\n+                    Err(..) => {\n+                        // Try to put it back as we found it\n+                        let _ = chmod(p, stat.perm.bits() as uint);\n+                        Err(e)\n+                    }\n+                }\n+            } else {\n+                Err(e)\n+            }\n+        }\n+    }\n }\n \n-pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n+pub fn rename(old: &Path, new: &Path) -> IoResult<()> {\n     let old = try!(to_utf16(old));\n     let new = try!(to_utf16(new));\n     super::mkerr_winbool(unsafe {\n-        libc::MoveFileExW(old.as_ptr(), new.as_ptr(),\n-                          libc::MOVEFILE_REPLACE_EXISTING)\n+        libc::MoveFileExW(old.as_ptr(), new.as_ptr(), libc::MOVEFILE_REPLACE_EXISTING)\n     })\n }\n \n-pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n+pub fn chmod(p: &Path, mode: uint) -> IoResult<()> {\n     let p = try!(to_utf16(p));\n-    super::mkerr_libc(unsafe {\n+    mkerr_libc(unsafe {\n         libc::wchmod(p.as_ptr(), mode as libc::c_int)\n     })\n }\n \n-pub fn rmdir(p: &CString) -> IoResult<()> {\n+pub fn rmdir(p: &Path) -> IoResult<()> {\n     let p = try!(to_utf16(p));\n-    super::mkerr_libc(unsafe { libc::wrmdir(p.as_ptr()) })\n+    mkerr_libc(unsafe { libc::wrmdir(p.as_ptr()) })\n }\n \n-pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n+pub fn chown(_p: &Path, _uid: int, _gid: int) -> IoResult<()> {\n     // libuv has this as a no-op, so seems like this should as well?\n     Ok(())\n }\n \n-pub fn readlink(p: &CString) -> IoResult<CString> {\n+pub fn readlink(p: &Path) -> IoResult<Path> {\n     // FIXME: I have a feeling that this reads intermediate symlinks as well.\n-    use io::c::compat::kernel32::GetFinalPathNameByHandleW;\n+    use sys::c::compat::kernel32::GetFinalPathNameByHandleW;\n     let p = try!(to_utf16(p));\n     let handle = unsafe {\n         libc::CreateFileW(p.as_ptr(),\n@@ -449,55 +376,64 @@ pub fn readlink(p: &CString) -> IoResult<CString> {\n                                   libc::VOLUME_NAME_DOS)\n     });\n     let ret = match ret {\n-        Some(ref s) if s.as_slice().starts_with(r\"\\\\?\\\") => {\n-            Ok(Path::new(s.as_slice().slice_from(4)).to_c_str())\n+        Some(ref s) if s.as_slice().starts_with(r\"\\\\?\\\") => { // \"\n+            Ok(Path::new(s.as_slice().slice_from(4)))\n         }\n-        Some(s) => Ok(Path::new(s).to_c_str()),\n+        Some(s) => Ok(Path::new(s)),\n         None => Err(super::last_error()),\n     };\n     assert!(unsafe { libc::CloseHandle(handle) } != 0);\n     return ret;\n }\n \n-pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-    use io::c::compat::kernel32::CreateSymbolicLinkW;\n+pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n+    use sys::c::compat::kernel32::CreateSymbolicLinkW;\n     let src = try!(to_utf16(src));\n     let dst = try!(to_utf16(dst));\n     super::mkerr_winbool(unsafe {\n         CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), 0) as libc::BOOL\n     })\n }\n \n-pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n+pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n     let src = try!(to_utf16(src));\n     let dst = try!(to_utf16(dst));\n     super::mkerr_winbool(unsafe {\n         libc::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::null_mut())\n     })\n }\n \n-fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n-    rtio::FileStat {\n+fn mkstat(stat: &libc::stat) -> FileStat {\n+    FileStat {\n         size: stat.st_size as u64,\n-        kind: stat.st_mode as u64,\n-        perm: stat.st_mode as u64,\n+        kind: match (stat.st_mode as libc::c_int) & libc::S_IFMT {\n+            libc::S_IFREG => io::TypeFile,\n+            libc::S_IFDIR => io::TypeDirectory,\n+            libc::S_IFIFO => io::TypeNamedPipe,\n+            libc::S_IFBLK => io::TypeBlockSpecial,\n+            libc::S_IFLNK => io::TypeSymlink,\n+            _ => io::TypeUnknown,\n+        },\n+        perm: FilePermission::from_bits_truncate(stat.st_mode as u32),\n         created: stat.st_ctime as u64,\n         modified: stat.st_mtime as u64,\n         accessed: stat.st_atime as u64,\n-        device: stat.st_dev as u64,\n-        inode: stat.st_ino as u64,\n-        rdev: stat.st_rdev as u64,\n-        nlink: stat.st_nlink as u64,\n-        uid: stat.st_uid as u64,\n-        gid: stat.st_gid as u64,\n-        blksize: 0,\n-        blocks: 0,\n-        flags: 0,\n-        gen: 0,\n+        unstable: UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize:0,\n+            blocks: 0,\n+            flags: 0,\n+            gen: 0,\n+        },\n     }\n }\n \n-pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n+pub fn stat(p: &Path) -> IoResult<FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     let p = try!(to_utf16(p));\n     match unsafe { libc::wstat(p.as_ptr(), &mut stat) } {\n@@ -506,18 +442,19 @@ pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n     }\n }\n \n-pub fn lstat(_p: &CString) -> IoResult<rtio::FileStat> {\n+// FIXME: move this to platform-specific modules (for now)?\n+pub fn lstat(_p: &Path) -> IoResult<FileStat> {\n     // FIXME: implementation is missing\n     Err(super::unimpl())\n }\n \n-pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n+pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n     let mut buf = libc::utimbuf {\n         actime: atime as libc::time64_t,\n         modtime: mtime as libc::time64_t,\n     };\n     let p = try!(to_utf16(p));\n-    super::mkerr_libc(unsafe {\n+    mkerr_libc(unsafe {\n         libc::wutime(p.as_ptr(), &mut buf)\n     })\n }", "previous_filename": "src/libnative/io/file_windows.rs"}]}