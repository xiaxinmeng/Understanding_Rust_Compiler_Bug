{"sha": "746331edf3a6d055859ed0ed70dde1aa883c517d", "node_id": "C_kwDOAAsO6NoAKDc0NjMzMWVkZjNhNmQwNTU4NTllZDBlZDcwZGRlMWFhODgzYzUxN2Q", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2023-02-17T14:47:58Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2023-02-17T14:47:58Z"}, "message": "std: drop all messages in bounded channel when destroying the last receiver", "tree": {"sha": "0224b61128be964729c3f816f33f69489ff487ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0224b61128be964729c3f816f33f69489ff487ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/746331edf3a6d055859ed0ed70dde1aa883c517d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/746331edf3a6d055859ed0ed70dde1aa883c517d", "html_url": "https://github.com/rust-lang/rust/commit/746331edf3a6d055859ed0ed70dde1aa883c517d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/746331edf3a6d055859ed0ed70dde1aa883c517d/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a64ef7d07d0411315be85a646586cb85eeb9c136", "url": "https://api.github.com/repos/rust-lang/rust/commits/a64ef7d07d0411315be85a646586cb85eeb9c136", "html_url": "https://github.com/rust-lang/rust/commit/a64ef7d07d0411315be85a646586cb85eeb9c136"}], "stats": {"total": 136, "additions": 109, "deletions": 27}, "files": [{"sha": "7038176000362cf83c6de419da2ed99b8c5860f7", "filename": "library/std/src/sync/mpmc/array.rs", "status": "modified", "additions": 107, "deletions": 25, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/746331edf3a6d055859ed0ed70dde1aa883c517d/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746331edf3a6d055859ed0ed70dde1aa883c517d/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=746331edf3a6d055859ed0ed70dde1aa883c517d", "patch": "@@ -15,7 +15,7 @@ use super::utils::{Backoff, CachePadded};\n use super::waker::SyncWaker;\n \n use crate::cell::UnsafeCell;\n-use crate::mem::MaybeUninit;\n+use crate::mem::{self, MaybeUninit};\n use crate::ptr;\n use crate::sync::atomic::{self, AtomicUsize, Ordering};\n use crate::time::Instant;\n@@ -25,7 +25,8 @@ struct Slot<T> {\n     /// The current stamp.\n     stamp: AtomicUsize,\n \n-    /// The message in this slot.\n+    /// The message in this slot. Either read out in `read` or dropped through\n+    /// `discard_all_messages`.\n     msg: UnsafeCell<MaybeUninit<T>>,\n }\n \n@@ -439,21 +440,122 @@ impl<T> Channel<T> {\n         Some(self.cap)\n     }\n \n-    /// Disconnects the channel and wakes up all blocked senders and receivers.\n+    /// Disconnects senders and wakes up all blocked receivers.\n     ///\n     /// Returns `true` if this call disconnected the channel.\n-    pub(crate) fn disconnect(&self) -> bool {\n+    pub(crate) fn disconnect_senders(&self) -> bool {\n         let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n \n         if tail & self.mark_bit == 0 {\n-            self.senders.disconnect();\n             self.receivers.disconnect();\n             true\n         } else {\n             false\n         }\n     }\n \n+    /// Disconnects receivers and wakes up all blocked senders.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    ///\n+    /// # Safety\n+    /// May only be called once upon dropping the last receiver. The\n+    /// destruction of all other receivers must have been observed with acquire\n+    /// ordering or stronger.\n+    pub(crate) unsafe fn disconnect_receivers(&self) -> bool {\n+        let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n+        self.discard_all_messages(tail);\n+\n+        if tail & self.mark_bit == 0 {\n+            self.senders.disconnect();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Discards all messages.\n+    ///\n+    /// `tail` should be the current (and therefore last) value of `tail`.\n+    ///\n+    /// # Safety\n+    /// This method must only be called when dropping the last receiver. The\n+    /// destruction of all other receivers must have been observed with acquire\n+    /// ordering or stronger.\n+    unsafe fn discard_all_messages(&self, tail: usize) {\n+        debug_assert!(self.is_disconnected());\n+\n+        /// Use a helper struct with a custom `Drop` to ensure all messages are\n+        /// dropped, even if a destructor panicks.\n+        struct DiscardState<'a, T> {\n+            channel: &'a Channel<T>,\n+            head: usize,\n+            tail: usize,\n+            backoff: Backoff,\n+        }\n+\n+        impl<'a, T> DiscardState<'a, T> {\n+            fn discard(&mut self) {\n+                loop {\n+                    // Deconstruct the head.\n+                    let index = self.head & (self.channel.mark_bit - 1);\n+                    let lap = self.head & !(self.channel.one_lap - 1);\n+\n+                    // Inspect the corresponding slot.\n+                    debug_assert!(index < self.channel.buffer.len());\n+                    let slot = unsafe { self.channel.buffer.get_unchecked(index) };\n+                    let stamp = slot.stamp.load(Ordering::Acquire);\n+\n+                    // If the stamp is ahead of the head by 1, we may drop the message.\n+                    if self.head + 1 == stamp {\n+                        self.head = if index + 1 < self.channel.cap {\n+                            // Same lap, incremented index.\n+                            // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n+                            self.head + 1\n+                        } else {\n+                            // One lap forward, index wraps around to zero.\n+                            // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n+                            lap.wrapping_add(self.channel.one_lap)\n+                        };\n+\n+                        // We updated the head, so even if this descrutor panics,\n+                        // we will not attempt to destroy the slot again.\n+                        unsafe {\n+                            (*slot.msg.get()).assume_init_drop();\n+                        }\n+                    // If the tail equals the head, that means the channel is empty.\n+                    } else if self.tail == self.head {\n+                        return;\n+                    // Otherwise, a sender is about to write into the slot, so we need\n+                    // to wait for it to update the stamp.\n+                    } else {\n+                        self.backoff.spin_heavy();\n+                    }\n+                }\n+            }\n+        }\n+\n+        impl<'a, T> Drop for DiscardState<'a, T> {\n+            fn drop(&mut self) {\n+                self.discard();\n+            }\n+        }\n+\n+        let mut state = DiscardState {\n+            channel: self,\n+            // Only receivers modify `head`, so since we are the last one,\n+            // this value will not change and will not be observed (since\n+            // no new messages can be sent after disconnection).\n+            head: self.head.load(Ordering::Relaxed),\n+            tail: tail & !self.mark_bit,\n+            backoff: Backoff::new(),\n+        };\n+        state.discard();\n+        // This point is only reached if no destructor panics, so all messages\n+        // have already been dropped.\n+        mem::forget(state);\n+    }\n+\n     /// Returns `true` if the channel is disconnected.\n     pub(crate) fn is_disconnected(&self) -> bool {\n         self.tail.load(Ordering::SeqCst) & self.mark_bit != 0\n@@ -483,23 +585,3 @@ impl<T> Channel<T> {\n         head.wrapping_add(self.one_lap) == tail & !self.mark_bit\n     }\n }\n-\n-impl<T> Drop for Channel<T> {\n-    fn drop(&mut self) {\n-        // Get the index of the head.\n-        let hix = self.head.load(Ordering::Relaxed) & (self.mark_bit - 1);\n-\n-        // Loop over all slots that hold a message and drop them.\n-        for i in 0..self.len() {\n-            // Compute the index of the next slot holding a message.\n-            let index = if hix + i < self.cap { hix + i } else { hix + i - self.cap };\n-\n-            unsafe {\n-                debug_assert!(index < self.buffer.len());\n-                let slot = self.buffer.get_unchecked_mut(index);\n-                let msg = &mut *slot.msg.get();\n-                msg.as_mut_ptr().drop_in_place();\n-            }\n-        }\n-    }\n-}"}, {"sha": "2068dda393a2b632952b26e10786c181721975c0", "filename": "library/std/src/sync/mpmc/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/746331edf3a6d055859ed0ed70dde1aa883c517d/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746331edf3a6d055859ed0ed70dde1aa883c517d/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs?ref=746331edf3a6d055859ed0ed70dde1aa883c517d", "patch": "@@ -227,7 +227,7 @@ impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n         unsafe {\n             match &self.flavor {\n-                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect_senders()),\n                 SenderFlavor::List(chan) => chan.release(|c| c.disconnect_senders()),\n                 SenderFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n             }\n@@ -403,7 +403,7 @@ impl<T> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         unsafe {\n             match &self.flavor {\n-                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect_receivers()),\n                 ReceiverFlavor::List(chan) => chan.release(|c| c.disconnect_receivers()),\n                 ReceiverFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n             }"}]}