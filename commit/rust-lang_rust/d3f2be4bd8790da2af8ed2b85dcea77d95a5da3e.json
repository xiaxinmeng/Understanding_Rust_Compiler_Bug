{"sha": "d3f2be4bd8790da2af8ed2b85dcea77d95a5da3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZjJiZTRiZDg3OTBkYTJhZjhlZDJiODVkY2VhNzdkOTVhNWRhM2U=", "commit": {"author": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2017-08-22T17:45:36Z"}, "committer": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2017-11-03T20:27:17Z"}, "message": "Add all methods of AsciiExt to u8 directly\n\nThis is the first step in order to deprecate AsciiExt. Since\nthis is a WIP commit, there is still some code duplication (notably\nthe static arrays) that will be removed later.", "tree": {"sha": "712043d09f8604d9f044dcc6ef11c2f634460383", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/712043d09f8604d9f044dcc6ef11c2f634460383"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3f2be4bd8790da2af8ed2b85dcea77d95a5da3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3f2be4bd8790da2af8ed2b85dcea77d95a5da3e", "html_url": "https://github.com/rust-lang/rust/commit/d3f2be4bd8790da2af8ed2b85dcea77d95a5da3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3f2be4bd8790da2af8ed2b85dcea77d95a5da3e/comments", "author": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "525b81d570b15df2ed5896f0215baea5c64c650c", "url": "https://api.github.com/repos/rust-lang/rust/commits/525b81d570b15df2ed5896f0215baea5c64c650c", "html_url": "https://github.com/rust-lang/rust/commit/525b81d570b15df2ed5896f0215baea5c64c650c"}], "stats": {"total": 657, "additions": 656, "deletions": 1}, "files": [{"sha": "b631691c731028d8c25fbd77b1283ac5bb602f68", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/d3f2be4bd8790da2af8ed2b85dcea77d95a5da3e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3f2be4bd8790da2af8ed2b85dcea77d95a5da3e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=d3f2be4bd8790da2af8ed2b85dcea77d95a5da3e", "patch": "@@ -2257,6 +2257,558 @@ impl u8 {\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n+\n+\n+    /// Checks if the value is within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let ascii = 97u8;\n+    /// let non_ascii = 150u8;\n+    ///\n+    /// assert!(ascii.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        *self & 128 == 0\n+    }\n+\n+    /// Makes a copy of the value in its ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let lowercase_a = 97u8;\n+    ///\n+    /// assert_eq!(65, lowercase_a.to_ascii_uppercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> u8 {\n+        ASCII_UPPERCASE_MAP[*self as usize]\n+    }\n+\n+    /// Makes a copy of the value in its ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let uppercase_a = 65u8;\n+    ///\n+    /// assert_eq!(97, uppercase_a.to_ascii_lowercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> u8 {\n+        ASCII_LOWERCASE_MAP[*self as usize]\n+    }\n+\n+    /// Checks that two values are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let lowercase_a = 97u8;\n+    /// let uppercase_a = 65u8;\n+    ///\n+    /// assert!(lowercase_a.eq_ignore_ascii_case(uppercase_a));\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: u8) -> bool {\n+        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n+    }\n+\n+    /// Converts this value to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let mut byte = b'a';\n+    ///\n+    /// byte.make_ascii_uppercase();\n+    ///\n+    /// assert_eq!(b'A', byte);\n+    /// ```\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        *self = self.to_ascii_uppercase();\n+    }\n+\n+    /// Converts this value to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let mut byte = b'A';\n+    ///\n+    /// byte.make_ascii_lowercase();\n+    ///\n+    /// assert_eq!(b'a', byte);\n+    /// ```\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        *self = self.to_ascii_lowercase();\n+    }\n+\n+    /// Checks if the value is an ASCII alphabetic character:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_alphabetic());\n+    /// assert!(uppercase_g.is_ascii_alphabetic());\n+    /// assert!(a.is_ascii_alphabetic());\n+    /// assert!(g.is_ascii_alphabetic());\n+    /// assert!(!zero.is_ascii_alphabetic());\n+    /// assert!(!percent.is_ascii_alphabetic());\n+    /// assert!(!space.is_ascii_alphabetic());\n+    /// assert!(!lf.is_ascii_alphabetic());\n+    /// assert!(!esc.is_ascii_alphabetic());\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn is_ascii_alphabetic(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            L | Lx | U | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII uppercase character:\n+    /// U+0041 'A' ... U+005A 'Z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_uppercase());\n+    /// assert!(uppercase_g.is_ascii_uppercase());\n+    /// assert!(!a.is_ascii_uppercase());\n+    /// assert!(!g.is_ascii_uppercase());\n+    /// assert!(!zero.is_ascii_uppercase());\n+    /// assert!(!percent.is_ascii_uppercase());\n+    /// assert!(!space.is_ascii_uppercase());\n+    /// assert!(!lf.is_ascii_uppercase());\n+    /// assert!(!esc.is_ascii_uppercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn is_ascii_uppercase(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            U | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII lowercase character:\n+    /// U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_lowercase());\n+    /// assert!(!uppercase_g.is_ascii_lowercase());\n+    /// assert!(a.is_ascii_lowercase());\n+    /// assert!(g.is_ascii_lowercase());\n+    /// assert!(!zero.is_ascii_lowercase());\n+    /// assert!(!percent.is_ascii_lowercase());\n+    /// assert!(!space.is_ascii_lowercase());\n+    /// assert!(!lf.is_ascii_lowercase());\n+    /// assert!(!esc.is_ascii_lowercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn is_ascii_lowercase(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            L | Lx => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII alphanumeric character:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', U+0061 'a' ... U+007A 'z', or\n+    /// - U+0030 '0' ... U+0039 '9'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_alphanumeric());\n+    /// assert!(uppercase_g.is_ascii_alphanumeric());\n+    /// assert!(a.is_ascii_alphanumeric());\n+    /// assert!(g.is_ascii_alphanumeric());\n+    /// assert!(zero.is_ascii_alphanumeric());\n+    /// assert!(!percent.is_ascii_alphanumeric());\n+    /// assert!(!space.is_ascii_alphanumeric());\n+    /// assert!(!lf.is_ascii_alphanumeric());\n+    /// assert!(!esc.is_ascii_alphanumeric());\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn is_ascii_alphanumeric(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D | L | Lx | U | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII decimal digit:\n+    /// U+0030 '0' ... U+0039 '9'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_digit());\n+    /// assert!(!uppercase_g.is_ascii_digit());\n+    /// assert!(!a.is_ascii_digit());\n+    /// assert!(!g.is_ascii_digit());\n+    /// assert!(zero.is_ascii_digit());\n+    /// assert!(!percent.is_ascii_digit());\n+    /// assert!(!space.is_ascii_digit());\n+    /// assert!(!lf.is_ascii_digit());\n+    /// assert!(!esc.is_ascii_digit());\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn is_ascii_digit(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII hexadecimal digit:\n+    ///\n+    /// - U+0030 '0' ... U+0039 '9', U+0041 'A' ... U+0046 'F', or\n+    /// - U+0061 'a' ... U+0066 'f'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_hexdigit());\n+    /// assert!(!uppercase_g.is_ascii_hexdigit());\n+    /// assert!(a.is_ascii_hexdigit());\n+    /// assert!(!g.is_ascii_hexdigit());\n+    /// assert!(zero.is_ascii_hexdigit());\n+    /// assert!(!percent.is_ascii_hexdigit());\n+    /// assert!(!space.is_ascii_hexdigit());\n+    /// assert!(!lf.is_ascii_hexdigit());\n+    /// assert!(!esc.is_ascii_hexdigit());\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn is_ascii_hexdigit(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D | Lx | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII punctuation character:\n+    ///\n+    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n+    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n+    /// - U+005B ... U+0060 `[ \\\\ ] ^ _ \\``, or\n+    /// - U+007B ... U+007E `{ | } ~`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_punctuation());\n+    /// assert!(!uppercase_g.is_ascii_punctuation());\n+    /// assert!(!a.is_ascii_punctuation());\n+    /// assert!(!g.is_ascii_punctuation());\n+    /// assert!(!zero.is_ascii_punctuation());\n+    /// assert!(percent.is_ascii_punctuation());\n+    /// assert!(!space.is_ascii_punctuation());\n+    /// assert!(!lf.is_ascii_punctuation());\n+    /// assert!(!esc.is_ascii_punctuation());\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn is_ascii_punctuation(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            P => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII graphic character:\n+    /// U+0021 '@' ... U+007E '~'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_graphic());\n+    /// assert!(uppercase_g.is_ascii_graphic());\n+    /// assert!(a.is_ascii_graphic());\n+    /// assert!(g.is_ascii_graphic());\n+    /// assert!(zero.is_ascii_graphic());\n+    /// assert!(percent.is_ascii_graphic());\n+    /// assert!(!space.is_ascii_graphic());\n+    /// assert!(!lf.is_ascii_graphic());\n+    /// assert!(!esc.is_ascii_graphic());\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn is_ascii_graphic(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            Ux | U | Lx | L | D | P => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII whitespace character:\n+    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n+    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n+    ///\n+    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n+    /// whitespace][infra-aw]. There are several other definitions in\n+    /// wide use. For instance, [the POSIX locale][pct] includes\n+    /// U+000B VERTICAL TAB as well as all the above characters,\n+    /// but\u2014from the very same specification\u2014[the default rule for\n+    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n+    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n+    ///\n+    /// If you are writing a program that will process an existing\n+    /// file format, check what that format's definition of whitespace is\n+    /// before using this function.\n+    ///\n+    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n+    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n+    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_whitespace());\n+    /// assert!(!uppercase_g.is_ascii_whitespace());\n+    /// assert!(!a.is_ascii_whitespace());\n+    /// assert!(!g.is_ascii_whitespace());\n+    /// assert!(!zero.is_ascii_whitespace());\n+    /// assert!(!percent.is_ascii_whitespace());\n+    /// assert!(space.is_ascii_whitespace());\n+    /// assert!(lf.is_ascii_whitespace());\n+    /// assert!(!esc.is_ascii_whitespace());\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn is_ascii_whitespace(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            Cw|W => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII control character:\n+    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n+    /// Note that most ASCII whitespace characters are control\n+    /// characters, but SPACE is not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_methods_on_intrinsics)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_control());\n+    /// assert!(!uppercase_g.is_ascii_control());\n+    /// assert!(!a.is_ascii_control());\n+    /// assert!(!g.is_ascii_control());\n+    /// assert!(!zero.is_ascii_control());\n+    /// assert!(!percent.is_ascii_control());\n+    /// assert!(!space.is_ascii_control());\n+    /// assert!(lf.is_ascii_control());\n+    /// assert!(esc.is_ascii_control());\n+    /// ```\n+    #[unstable(feature = \"ascii_methods_on_intrinsics\", issue = \"0\")]\n+    #[inline]\n+    pub fn is_ascii_control(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            C|Cw => true,\n+            _ => false\n+        }\n+    }\n }\n \n #[lang = \"u16\"]\n@@ -2926,3 +3478,106 @@ impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\"\n \n // Float -> Float\n impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+static ASCII_LOWERCASE_MAP: [u8; 256] = [\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n+    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n+    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n+    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n+    b'@',\n+\n+          b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n+    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n+    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n+    b'x', b'y', b'z',\n+\n+                      b'[', b'\\\\', b']', b'^', b'_',\n+    b'`', b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n+    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n+    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n+    b'x', b'y', b'z', b'{', b'|', b'}', b'~', 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+static ASCII_UPPERCASE_MAP: [u8; 256] = [\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n+    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n+    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n+    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n+    b'@', b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n+    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n+    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n+    b'X', b'Y', b'Z', b'[', b'\\\\', b']', b'^', b'_',\n+    b'`',\n+\n+          b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n+    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n+    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n+    b'X', b'Y', b'Z',\n+\n+                      b'{', b'|', b'}', b'~', 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+enum AsciiCharacterClass {\n+    C,  // control\n+    Cw, // control whitespace\n+    W,  // whitespace\n+    D,  // digit\n+    L,  // lowercase\n+    Lx, // lowercase hex digit\n+    U,  // uppercase\n+    Ux, // uppercase hex digit\n+    P,  // punctuation\n+}\n+use self::AsciiCharacterClass::*;\n+\n+static ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 128] = [\n+//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n+    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n+    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n+    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n+    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n+    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n+    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n+    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n+    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n+];"}, {"sha": "8ddc75868ac7700bf59acf416f545838402c9d88", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3f2be4bd8790da2af8ed2b85dcea77d95a5da3e/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3f2be4bd8790da2af8ed2b85dcea77d95a5da3e/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=d3f2be4bd8790da2af8ed2b85dcea77d95a5da3e", "patch": "@@ -685,7 +685,7 @@ impl AsciiExt for [u8] {\n     #[inline]\n     fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n         self.len() == other.len() &&\n-        self.iter().zip(other).all(|(a, b)| {\n+        self.iter().zip(other).all(|(a, &b)| {\n             a.eq_ignore_ascii_case(b)\n         })\n     }"}]}