{"sha": "8be66e212b37045b927138965a76abe3608325ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZTY2ZTIxMmIzNzA0NWI5MjcxMzg5NjVhNzZhYmUzNjA4MzI1Y2E=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-14T02:27:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-25T03:59:53Z"}, "message": "std: Implement yields on receives for channels\n\nThis will prevent a deadlock when a task spins in a try_recv when using channel\ncommunication routines is a clear location for a M:N scheduling to happen.", "tree": {"sha": "854c2b53b85412f0abbb7f8b04b564a5532ef392", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/854c2b53b85412f0abbb7f8b04b564a5532ef392"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8be66e212b37045b927138965a76abe3608325ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8be66e212b37045b927138965a76abe3608325ca", "html_url": "https://github.com/rust-lang/rust/commit/8be66e212b37045b927138965a76abe3608325ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8be66e212b37045b927138965a76abe3608325ca/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14caf00c92b40e3f62094db54f325196c8a05d5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/14caf00c92b40e3f62094db54f325196c8a05d5a", "html_url": "https://github.com/rust-lang/rust/commit/14caf00c92b40e3f62094db54f325196c8a05d5a"}], "stats": {"total": 25, "additions": 20, "deletions": 5}, "files": [{"sha": "7b464bc2f3296433bab489bff322f640985c7eb2", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8be66e212b37045b927138965a76abe3608325ca/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8be66e212b37045b927138965a76abe3608325ca/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=8be66e212b37045b927138965a76abe3608325ca", "patch": "@@ -238,7 +238,6 @@ use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n use sync::atomics::{AtomicInt, AtomicBool, SeqCst, Relaxed};\n-use task;\n use vec::{ImmutableVector, OwnedVector};\n \n use spsc = sync::spsc_queue;\n@@ -346,6 +345,7 @@ struct Packet {\n     selection_id: uint,\n     select_next: *mut Packet,\n     select_prev: *mut Packet,\n+    recv_cnt: int,\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -367,6 +367,7 @@ impl Packet {\n             selection_id: 0,\n             select_next: 0 as *mut Packet,\n             select_prev: 0 as *mut Packet,\n+            recv_cnt: 0,\n         }\n     }\n \n@@ -611,8 +612,9 @@ impl<T: Send> Chan<T> {\n                 // the TLS overhead can be a bit much.\n                 n => {\n                     assert!(n >= 0);\n-                    if can_resched && n > 0 && n % RESCHED_FREQ == 0 {\n-                        task::deschedule();\n+                    if n > 0 && n % RESCHED_FREQ == 0 {\n+                        let task: ~Task = Local::take();\n+                        task.maybe_yield();\n                     }\n                     true\n                 }\n@@ -704,8 +706,9 @@ impl<T: Send> SharedChan<T> {\n                 DISCONNECTED => {} // oh well, we tried\n                 -1 => { (*packet).wakeup(can_resched); }\n                 n => {\n-                    if can_resched && n > 0 && n % RESCHED_FREQ == 0 {\n-                        task::deschedule();\n+                    if n > 0 && n % RESCHED_FREQ == 0 {\n+                        let task: ~Task = Local::take();\n+                        task.maybe_yield();\n                     }\n                 }\n             }\n@@ -773,6 +776,18 @@ impl<T: Send> Port<T> {\n         // This is a \"best effort\" situation, so if a queue is inconsistent just\n         // don't worry about it.\n         let this = unsafe { cast::transmute_mut(self) };\n+\n+        // See the comment about yielding on sends, but the same applies here.\n+        // If a thread is spinning in try_recv we should try\n+        unsafe {\n+            let packet = this.queue.packet();\n+            (*packet).recv_cnt += 1;\n+            if (*packet).recv_cnt % RESCHED_FREQ == 0 {\n+                let task: ~Task = Local::take();\n+                task.maybe_yield();\n+            }\n+        }\n+\n         let ret = match this.queue {\n             SPSC(ref mut queue) => queue.pop(),\n             MPSC(ref mut queue) => match queue.pop() {"}]}