{"sha": "b78af4f7c4dad767aae7f6d96b1c9c2990a717ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3OGFmNGY3YzRkYWQ3NjdhYWU3ZjZkOTZiMWM5YzI5OTBhNzE3Y2E=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-21T21:00:37Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-22T02:10:31Z"}, "message": "rt: Inline a bunch of stack switching code", "tree": {"sha": "5bacdcd860caedc679a171bb6ff828f44d76653f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bacdcd860caedc679a171bb6ff828f44d76653f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b78af4f7c4dad767aae7f6d96b1c9c2990a717ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b78af4f7c4dad767aae7f6d96b1c9c2990a717ca", "html_url": "https://github.com/rust-lang/rust/commit/b78af4f7c4dad767aae7f6d96b1c9c2990a717ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b78af4f7c4dad767aae7f6d96b1c9c2990a717ca/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5968d9f388423d90186a6e1269cceaab12a6b55", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5968d9f388423d90186a6e1269cceaab12a6b55", "html_url": "https://github.com/rust-lang/rust/commit/d5968d9f388423d90186a6e1269cceaab12a6b55"}], "stats": {"total": 281, "additions": 143, "deletions": 138}, "files": [{"sha": "495900fe98c1ee81462ef6581e23fd7c3dd3bae9", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/b78af4f7c4dad767aae7f6d96b1c9c2990a717ca/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b78af4f7c4dad767aae7f6d96b1c9c2990a717ca/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=b78af4f7c4dad767aae7f6d96b1c9c2990a717ca", "patch": "@@ -13,53 +13,6 @@\n #include \"globals.h\"\n #include \"rust_upcall.h\"\n \n-// The amount of extra space at the end of each stack segment, available\n-// to the rt, compiler and dynamic linker for running small functions\n-// FIXME: We want this to be 128 but need to slim the red zone calls down\n-#define RZ_LINUX_32 (1024*2)\n-#define RZ_LINUX_64 (1024*2)\n-#define RZ_MAC_32   (1024*20)\n-#define RZ_MAC_64   (1024*20)\n-#define RZ_WIN_32   (1024*20)\n-#define RZ_BSD_32   (1024*20)\n-#define RZ_BSD_64   (1024*20)\n-\n-#ifdef __linux__\n-#ifdef __i386__\n-#define RED_ZONE_SIZE RZ_LINUX_32\n-#endif\n-#ifdef __x86_64__\n-#define RED_ZONE_SIZE RZ_LINUX_64\n-#endif\n-#endif\n-#ifdef __APPLE__\n-#ifdef __i386__\n-#define RED_ZONE_SIZE RZ_MAC_32\n-#endif\n-#ifdef __x86_64__\n-#define RED_ZONE_SIZE RZ_MAC_64\n-#endif\n-#endif\n-#ifdef __WIN32__\n-#ifdef __i386__\n-#define RED_ZONE_SIZE RZ_WIN_32\n-#endif\n-#ifdef __x86_64__\n-#define RED_ZONE_SIZE RZ_WIN_64\n-#endif\n-#endif\n-#ifdef __FreeBSD__\n-#ifdef __i386__\n-#define RED_ZONE_SIZE RZ_BSD_32\n-#endif\n-#ifdef __x86_64__\n-#define RED_ZONE_SIZE RZ_BSD_64\n-#endif\n-#endif\n-\n-extern \"C\" CDECL void\n-record_sp(void *limit);\n-\n // Tasks\n rust_task::rust_task(rust_task_thread *thread, rust_task_state state,\n                      rust_task *spawner, const char *name,\n@@ -494,52 +447,18 @@ rust_task::get_next_stack_size(size_t min, size_t current, size_t requested) {\n     return sz;\n }\n \n-// The amount of stack in a segment available to Rust code\n-static size_t\n-user_stack_size(stk_seg *stk) {\n-    return (size_t)(stk->end\n-                    - (uintptr_t)&stk->data[0]\n-                    - RED_ZONE_SIZE);\n-}\n-\n void\n rust_task::free_stack(stk_seg *stk) {\n     LOGPTR(thread, \"freeing stk segment\", (uintptr_t)stk);\n     total_stack_sz -= user_stack_size(stk);\n     destroy_stack(&local_region, stk);\n }\n \n-struct new_stack_args {\n-    rust_task *task;\n-    size_t requested_sz;\n-};\n-\n void\n new_stack_slow(new_stack_args *args) {\n     args->task->new_stack(args->requested_sz);\n }\n \n-// NB: This runs on the Rust stack\n-// This is the new stack fast path, in which we\n-// reuse the next cached stack segment\n-void\n-rust_task::new_stack_fast(size_t requested_sz) {\n-    // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n-    size_t min_sz = thread->min_stack_size;\n-\n-    // Try to reuse an existing stack segment\n-    if (stk != NULL && stk->next != NULL) {\n-        size_t next_sz = user_stack_size(stk->next);\n-        if (min_sz <= next_sz && requested_sz <= next_sz) {\n-            stk = stk->next;\n-            return;\n-        }\n-    }\n-\n-    new_stack_args args = {this, requested_sz};\n-    call_on_c_stack(&args, (void*)new_stack_slow);\n-}\n-\n void\n rust_task::new_stack(size_t requested_sz) {\n     LOG(this, mem, \"creating new stack for task %\" PRIxPTR, this);\n@@ -596,63 +515,6 @@ rust_task::new_stack(size_t requested_sz) {\n     total_stack_sz += user_stack_size(new_stk);\n }\n \n-void *\n-rust_task::next_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n-    stk_seg *maybe_next_stack = NULL;\n-    if (stk != NULL) {\n-        maybe_next_stack = stk->prev;\n-    }\n-\n-    new_stack_fast(stk_sz + args_sz);\n-    A(thread, stk->end - (uintptr_t)stk->data >= stk_sz + args_sz,\n-      \"Did not receive enough stack\");\n-    uint8_t *new_sp = (uint8_t*)stk->end;\n-    // Push the function arguments to the new stack\n-    new_sp = align_down(new_sp - args_sz);\n-\n-    // When reusing a stack segment we need to tell valgrind that this area of\n-    // memory is accessible before writing to it, because the act of popping\n-    // the stack previously made all of the stack inaccessible.\n-    if (maybe_next_stack == stk) {\n-        // I don't know exactly where the region ends that valgrind needs us\n-        // to mark accessible. On x86_64 these extra bytes aren't needed, but\n-        // on i386 we get errors without.\n-        int fudge_bytes = 16;\n-        reuse_valgrind_stack(stk, new_sp - fudge_bytes);\n-    }\n-\n-    memcpy(new_sp, args_addr, args_sz);\n-    record_stack_limit();\n-    return new_sp;\n-}\n-\n-// NB: This runs on the Rust stack\n-void\n-rust_task::prev_stack() {\n-    // We're not going to actually delete anything now because that would\n-    // require switching to the C stack and be costly. Instead we'll just move\n-    // up the link list and clean up later, either in new_stack or after our\n-    // turn ends on the scheduler.\n-    stk = stk->prev;\n-    record_stack_limit();\n-}\n-\n-void\n-rust_task::record_stack_limit() {\n-    I(thread, stk);\n-    // The function prolog compares the amount of stack needed to the end of\n-    // the stack. As an optimization, when the frame size is less than 256\n-    // bytes, it will simply compare %esp to to the stack limit instead of\n-    // subtracting the frame size. As a result we need our stack limit to\n-    // account for those 256 bytes.\n-    const unsigned LIMIT_OFFSET = 256;\n-    A(thread,\n-      (uintptr_t)stk->end - RED_ZONE_SIZE\n-      - (uintptr_t)stk->data >= LIMIT_OFFSET,\n-      \"Stack size must be greater than LIMIT_OFFSET\");\n-    record_sp(stk->data + LIMIT_OFFSET + RED_ZONE_SIZE);\n-}\n-\n void\n rust_task::cleanup_after_turn() {\n     // Delete any spare stack segments that were left"}, {"sha": "0d5a1987b747c86f6505c2adf3155802835dd387", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/b78af4f7c4dad767aae7f6d96b1c9c2990a717ca/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/b78af4f7c4dad767aae7f6d96b1c9c2990a717ca/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=b78af4f7c4dad767aae7f6d96b1c9c2990a717ca", "patch": "@@ -17,6 +17,50 @@\n #include \"rust_stack.h\"\n #include \"rust_port_selector.h\"\n \n+// The amount of extra space at the end of each stack segment, available\n+// to the rt, compiler and dynamic linker for running small functions\n+// FIXME: We want this to be 128 but need to slim the red zone calls down\n+#define RZ_LINUX_32 (1024*2)\n+#define RZ_LINUX_64 (1024*2)\n+#define RZ_MAC_32   (1024*20)\n+#define RZ_MAC_64   (1024*20)\n+#define RZ_WIN_32   (1024*20)\n+#define RZ_BSD_32   (1024*20)\n+#define RZ_BSD_64   (1024*20)\n+\n+#ifdef __linux__\n+#ifdef __i386__\n+#define RED_ZONE_SIZE RZ_LINUX_32\n+#endif\n+#ifdef __x86_64__\n+#define RED_ZONE_SIZE RZ_LINUX_64\n+#endif\n+#endif\n+#ifdef __APPLE__\n+#ifdef __i386__\n+#define RED_ZONE_SIZE RZ_MAC_32\n+#endif\n+#ifdef __x86_64__\n+#define RED_ZONE_SIZE RZ_MAC_64\n+#endif\n+#endif\n+#ifdef __WIN32__\n+#ifdef __i386__\n+#define RED_ZONE_SIZE RZ_WIN_32\n+#endif\n+#ifdef __x86_64__\n+#define RED_ZONE_SIZE RZ_WIN_64\n+#endif\n+#endif\n+#ifdef __FreeBSD__\n+#ifdef __i386__\n+#define RED_ZONE_SIZE RZ_BSD_32\n+#endif\n+#ifdef __x86_64__\n+#define RED_ZONE_SIZE RZ_BSD_64\n+#endif\n+#endif\n+\n struct rust_box;\n \n struct frame_glue_fns {\n@@ -303,6 +347,105 @@ rust_task::return_c_stack() {\n     next_c_sp = 0;\n }\n \n+// NB: This runs on the Rust stack\n+inline void *\n+rust_task::next_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n+    stk_seg *maybe_next_stack = NULL;\n+    if (stk != NULL) {\n+        maybe_next_stack = stk->prev;\n+    }\n+\n+    new_stack_fast(stk_sz + args_sz);\n+    A(thread, stk->end - (uintptr_t)stk->data >= stk_sz + args_sz,\n+      \"Did not receive enough stack\");\n+    uint8_t *new_sp = (uint8_t*)stk->end;\n+    // Push the function arguments to the new stack\n+    new_sp = align_down(new_sp - args_sz);\n+\n+    // When reusing a stack segment we need to tell valgrind that this area of\n+    // memory is accessible before writing to it, because the act of popping\n+    // the stack previously made all of the stack inaccessible.\n+    if (maybe_next_stack == stk) {\n+        // I don't know exactly where the region ends that valgrind needs us\n+        // to mark accessible. On x86_64 these extra bytes aren't needed, but\n+        // on i386 we get errors without.\n+        int fudge_bytes = 16;\n+        reuse_valgrind_stack(stk, new_sp - fudge_bytes);\n+    }\n+\n+    memcpy(new_sp, args_addr, args_sz);\n+    record_stack_limit();\n+    return new_sp;\n+}\n+\n+// The amount of stack in a segment available to Rust code\n+inline size_t\n+user_stack_size(stk_seg *stk) {\n+    return (size_t)(stk->end\n+                    - (uintptr_t)&stk->data[0]\n+                    - RED_ZONE_SIZE);\n+}\n+\n+struct new_stack_args {\n+    rust_task *task;\n+    size_t requested_sz;\n+};\n+\n+void\n+new_stack_slow(new_stack_args *args);\n+\n+// NB: This runs on the Rust stack\n+// This is the new stack fast path, in which we\n+// reuse the next cached stack segment\n+inline void\n+rust_task::new_stack_fast(size_t requested_sz) {\n+    // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n+    size_t min_sz = thread->min_stack_size;\n+\n+    // Try to reuse an existing stack segment\n+    if (stk != NULL && stk->next != NULL) {\n+        size_t next_sz = user_stack_size(stk->next);\n+        if (min_sz <= next_sz && requested_sz <= next_sz) {\n+            stk = stk->next;\n+            return;\n+        }\n+    }\n+\n+    new_stack_args args = {this, requested_sz};\n+    call_on_c_stack(&args, (void*)new_stack_slow);\n+}\n+\n+// NB: This runs on the Rust stack\n+inline void\n+rust_task::prev_stack() {\n+    // We're not going to actually delete anything now because that would\n+    // require switching to the C stack and be costly. Instead we'll just move\n+    // up the link list and clean up later, either in new_stack or after our\n+    // turn ends on the scheduler.\n+    stk = stk->prev;\n+    record_stack_limit();\n+}\n+\n+extern \"C\" CDECL void\n+record_sp(void *limit);\n+\n+inline void\n+rust_task::record_stack_limit() {\n+    I(thread, stk);\n+    // The function prolog compares the amount of stack needed to the end of\n+    // the stack. As an optimization, when the frame size is less than 256\n+    // bytes, it will simply compare %esp to to the stack limit instead of\n+    // subtracting the frame size. As a result we need our stack limit to\n+    // account for those 256 bytes.\n+    const unsigned LIMIT_OFFSET = 256;\n+    A(thread,\n+      (uintptr_t)stk->end - RED_ZONE_SIZE\n+      - (uintptr_t)stk->data >= LIMIT_OFFSET,\n+      \"Stack size must be greater than LIMIT_OFFSET\");\n+    record_sp(stk->data + LIMIT_OFFSET + RED_ZONE_SIZE);\n+}\n+\n+\n //\n // Local Variables:\n // mode: C++"}]}