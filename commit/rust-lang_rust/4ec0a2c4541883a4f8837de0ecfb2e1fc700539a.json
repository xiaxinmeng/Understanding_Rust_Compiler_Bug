{"sha": "4ec0a2c4541883a4f8837de0ecfb2e1fc700539a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYzBhMmM0NTQxODgzYTRmODgzN2RlMGVjZmIyZTFmYzcwMDUzOWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-25T11:48:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-25T11:48:53Z"}, "message": "Merge #5056\n\n5056: Canonicalize actor API r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "d3fa47c7c1b998a10c8655593b12551f14276c75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3fa47c7c1b998a10c8655593b12551f14276c75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ec0a2c4541883a4f8837de0ecfb2e1fc700539a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9I8lCRBK7hj4Ov3rIwAAdHIIAEQwT46GUKnEwWVIwuECjLWC\nr083WhJW9CU9gve/7KCa/42CIXwsp4l2t+MiGICOtEklSKHstuM3Lpbrxe+jUdip\n7fOcGk9oMY+UE0MYQOyhJt1HcUAVJExULiwiJA4AuXIW85ltlk6jSX+7mjLZaZFW\nLKGoUFQwk0/y9YGu6ugNDmYtSGhtSrLI2WDHFqD6Qbsjixi4UKWQaskSlY0RPh+Q\nkSNJihSJti9d+QhFqgY7eAQFlDHvaDGS4n61xIiYxpQJIMKlYUUMxgwTD7WFNVNq\njRNPhb/E9m45zj79l8dPpFY8c1OjbQI8Dc+K5C60EImvgOU8l8zjk8F9G1uqRaM=\n=6mry\n-----END PGP SIGNATURE-----\n", "payload": "tree d3fa47c7c1b998a10c8655593b12551f14276c75\nparent e2465ee2e949d81f98270c57afa17666dac6afa4\nparent 331addcf61f9e2e0d14541e066dacda453f8fb54\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593085733 +0000\ncommitter GitHub <noreply@github.com> 1593085733 +0000\n\nMerge #5056\n\n5056: Canonicalize actor API r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ec0a2c4541883a4f8837de0ecfb2e1fc700539a", "html_url": "https://github.com/rust-lang/rust/commit/4ec0a2c4541883a4f8837de0ecfb2e1fc700539a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ec0a2c4541883a4f8837de0ecfb2e1fc700539a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2465ee2e949d81f98270c57afa17666dac6afa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2465ee2e949d81f98270c57afa17666dac6afa4", "html_url": "https://github.com/rust-lang/rust/commit/e2465ee2e949d81f98270c57afa17666dac6afa4"}, {"sha": "331addcf61f9e2e0d14541e066dacda453f8fb54", "url": "https://api.github.com/repos/rust-lang/rust/commits/331addcf61f9e2e0d14541e066dacda453f8fb54", "html_url": "https://github.com/rust-lang/rust/commit/331addcf61f9e2e0d14541e066dacda453f8fb54"}], "stats": {"total": 128, "additions": 57, "deletions": 71}, "files": [{"sha": "9e8205ae790df5d625a9ebfcde9cf555ec77bbdd", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 55, "deletions": 69, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0a2c4541883a4f8837de0ecfb2e1fc700539a/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0a2c4541883a4f8837de0ecfb2e1fc700539a/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=4ec0a2c4541883a4f8837de0ecfb2e1fc700539a", "patch": "@@ -10,7 +10,7 @@ use std::{\n     time::Instant,\n };\n \n-use crossbeam_channel::{never, select, unbounded, Receiver, RecvError, Sender};\n+use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n \n pub use cargo_metadata::diagnostic::{\n     Applicability, Diagnostic, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion,\n@@ -61,7 +61,7 @@ impl FlycheckHandle {\n     ) -> FlycheckHandle {\n         let (cmd_send, cmd_recv) = unbounded::<Restart>();\n         let handle = jod_thread::spawn(move || {\n-            FlycheckActor::new(sender, config, workspace_root).run(&cmd_recv);\n+            FlycheckActor::new(sender, config, workspace_root).run(cmd_recv);\n         });\n         FlycheckHandle { cmd_send, handle }\n     }\n@@ -98,14 +98,18 @@ struct FlycheckActor {\n     config: FlycheckConfig,\n     workspace_root: PathBuf,\n     last_update_req: Option<Instant>,\n-    // XXX: drop order is significant\n-    message_recv: Receiver<CheckEvent>,\n     /// WatchThread exists to wrap around the communication needed to be able to\n     /// run `cargo check` without blocking. Currently the Rust standard library\n     /// doesn't provide a way to read sub-process output without blocking, so we\n     /// have to wrap sub-processes output handling in a thread and pass messages\n     /// back over a channel.\n-    check_process: Option<jod_thread::JoinHandle>,\n+    // XXX: drop order is significant\n+    check_process: Option<(Receiver<CheckEvent>, jod_thread::JoinHandle)>,\n+}\n+\n+enum Event {\n+    Restart(Restart),\n+    CheckEvent(Option<CheckEvent>),\n }\n \n impl FlycheckActor {\n@@ -114,40 +118,48 @@ impl FlycheckActor {\n         config: FlycheckConfig,\n         workspace_root: PathBuf,\n     ) -> FlycheckActor {\n-        FlycheckActor {\n-            sender,\n-            config,\n-            workspace_root,\n-            last_update_req: None,\n-            message_recv: never(),\n-            check_process: None,\n-        }\n+        FlycheckActor { sender, config, workspace_root, last_update_req: None, check_process: None }\n     }\n \n-    fn run(&mut self, cmd_recv: &Receiver<Restart>) {\n+    fn run(&mut self, inbox: Receiver<Restart>) {\n         // If we rerun the thread, we need to discard the previous check results first\n-        self.clean_previous_results();\n-\n-        loop {\n-            select! {\n-                recv(&cmd_recv) -> cmd => match cmd {\n-                    Ok(Restart) => self.last_update_req = Some(Instant::now()),\n-                    Err(RecvError) => {\n-                        // Command channel has closed, so shut down\n-                        break;\n-                    },\n-                },\n-                recv(self.message_recv) -> msg => match msg {\n-                    Ok(msg) => self.handle_message(msg),\n-                    Err(RecvError) => {\n-                        // Watcher finished, replace it with a never channel to\n-                        // avoid busy-waiting.\n-                        self.message_recv = never();\n-                        self.check_process = None;\n-                    },\n+        self.send(Message::ClearDiagnostics);\n+        self.send(Message::Progress(Progress::End));\n+\n+        while let Some(event) = self.next_event(&inbox) {\n+            match event {\n+                Event::Restart(Restart) => self.last_update_req = Some(Instant::now()),\n+                Event::CheckEvent(None) => {\n+                    // Watcher finished, replace it with a never channel to\n+                    // avoid busy-waiting.\n+                    self.check_process = None;\n                 }\n-            };\n+                Event::CheckEvent(Some(event)) => match event {\n+                    CheckEvent::Begin => {\n+                        self.send(Message::Progress(Progress::Being));\n+                    }\n+\n+                    CheckEvent::End => {\n+                        self.send(Message::Progress(Progress::End));\n+                    }\n+\n+                    CheckEvent::Msg(cargo_metadata::Message::CompilerArtifact(msg)) => {\n+                        self.send(Message::Progress(Progress::DidCheckCrate(msg.target.name)));\n+                    }\n+\n+                    CheckEvent::Msg(cargo_metadata::Message::CompilerMessage(msg)) => {\n+                        self.send(Message::AddDiagnostic {\n+                            workspace_root: self.workspace_root.clone(),\n+                            diagnostic: msg.message,\n+                        });\n+                    }\n \n+                    CheckEvent::Msg(cargo_metadata::Message::BuildScriptExecuted(_))\n+                    | CheckEvent::Msg(cargo_metadata::Message::BuildFinished(_))\n+                    | CheckEvent::Msg(cargo_metadata::Message::TextLine(_))\n+                    | CheckEvent::Msg(cargo_metadata::Message::Unknown) => {}\n+                },\n+            }\n             if self.should_recheck() {\n                 self.last_update_req = None;\n                 self.send(Message::ClearDiagnostics);\n@@ -156,9 +168,12 @@ impl FlycheckActor {\n         }\n     }\n \n-    fn clean_previous_results(&self) {\n-        self.send(Message::ClearDiagnostics);\n-        self.send(Message::Progress(Progress::End));\n+    fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n+        let check_chan = self.check_process.as_ref().map(|(chan, _thread)| chan);\n+        select! {\n+            recv(inbox) -> msg => msg.ok().map(Event::Restart),\n+            recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n+        }\n     }\n \n     fn should_recheck(&mut self) -> bool {\n@@ -171,37 +186,8 @@ impl FlycheckActor {\n         false\n     }\n \n-    fn handle_message(&self, msg: CheckEvent) {\n-        match msg {\n-            CheckEvent::Begin => {\n-                self.send(Message::Progress(Progress::Being));\n-            }\n-\n-            CheckEvent::End => {\n-                self.send(Message::Progress(Progress::End));\n-            }\n-\n-            CheckEvent::Msg(cargo_metadata::Message::CompilerArtifact(msg)) => {\n-                self.send(Message::Progress(Progress::DidCheckCrate(msg.target.name)));\n-            }\n-\n-            CheckEvent::Msg(cargo_metadata::Message::CompilerMessage(msg)) => {\n-                self.send(Message::AddDiagnostic {\n-                    workspace_root: self.workspace_root.clone(),\n-                    diagnostic: msg.message,\n-                });\n-            }\n-\n-            CheckEvent::Msg(cargo_metadata::Message::BuildScriptExecuted(_))\n-            | CheckEvent::Msg(cargo_metadata::Message::BuildFinished(_))\n-            | CheckEvent::Msg(cargo_metadata::Message::TextLine(_))\n-            | CheckEvent::Msg(cargo_metadata::Message::Unknown) => {}\n-        }\n-    }\n-\n     fn restart_check_process(&mut self) {\n         // First, clear and cancel the old thread\n-        self.message_recv = never();\n         self.check_process = None;\n \n         let mut cmd = match &self.config {\n@@ -237,8 +223,7 @@ impl FlycheckActor {\n         cmd.current_dir(&self.workspace_root);\n \n         let (message_send, message_recv) = unbounded();\n-        self.message_recv = message_recv;\n-        self.check_process = Some(jod_thread::spawn(move || {\n+        let thread = jod_thread::spawn(move || {\n             // If we trigger an error here, we will do so in the loop instead,\n             // which will break out of the loop, and continue the shutdown\n             let _ = message_send.send(CheckEvent::Begin);\n@@ -267,7 +252,8 @@ impl FlycheckActor {\n             // We can ignore any error here, as we are already in the progress\n             // of shutting down.\n             let _ = message_send.send(CheckEvent::End);\n-        }))\n+        });\n+        self.check_process = Some((message_recv, thread))\n     }\n \n     fn send(&self, check_task: Message) {"}, {"sha": "68fdb8cb09cbbd50a1b43fa8ff69d53570dadef5", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0a2c4541883a4f8837de0ecfb2e1fc700539a/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0a2c4541883a4f8837de0ecfb2e1fc700539a/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=4ec0a2c4541883a4f8837de0ecfb2e1fc700539a", "patch": "@@ -83,8 +83,8 @@ impl NotifyActor {\n         }\n     }\n \n-    fn run(mut self, receiver: Receiver<Message>) {\n-        while let Some(event) = self.next_event(&receiver) {\n+    fn run(mut self, inbox: Receiver<Message>) {\n+        while let Some(event) = self.next_event(&inbox) {\n             log::debug!(\"vfs-notify event: {:?}\", event);\n             match event {\n                 Event::Message(msg) => match msg {"}]}