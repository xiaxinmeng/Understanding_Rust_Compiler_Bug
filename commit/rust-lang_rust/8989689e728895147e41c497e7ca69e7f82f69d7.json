{"sha": "8989689e728895147e41c497e7ca69e7f82f69d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ODk2ODllNzI4ODk1MTQ3ZTQxYzQ5N2U3Y2E2OWU3ZjgyZjY5ZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-04T02:15:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-04T02:15:57Z"}, "message": "Auto merge of #80418 - oli-obk:this_could_have_been_so_simple, r=RalfJung\n\nAllow references to interior mutable data behind a feature gate\n\nsupercedes #80373 by simply not checking for interior mutability on borrows of locals that have `StorageDead` and thus can never be leaked to the final value of the constant\n\ntracking issue: https://github.com/rust-lang/rust/issues/80384\n\nr? `@RalfJung`", "tree": {"sha": "da32380e2bedfcf01e980eb67ecd7060d10313a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da32380e2bedfcf01e980eb67ecd7060d10313a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8989689e728895147e41c497e7ca69e7f82f69d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8989689e728895147e41c497e7ca69e7f82f69d7", "html_url": "https://github.com/rust-lang/rust/commit/8989689e728895147e41c497e7ca69e7f82f69d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8989689e728895147e41c497e7ca69e7f82f69d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80184183ba0a53aa4f491753de9502acd3d6920c", "url": "https://api.github.com/repos/rust-lang/rust/commits/80184183ba0a53aa4f491753de9502acd3d6920c", "html_url": "https://github.com/rust-lang/rust/commit/80184183ba0a53aa4f491753de9502acd3d6920c"}, {"sha": "90b56b94f6925003c1879660530f9e0ebdb94fa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/90b56b94f6925003c1879660530f9e0ebdb94fa9", "html_url": "https://github.com/rust-lang/rust/commit/90b56b94f6925003c1879660530f9e0ebdb94fa9"}], "stats": {"total": 292, "additions": 230, "deletions": 62}, "files": [{"sha": "79e7c069a91c42cdb62d62be42c245702a32798d", "filename": "compiler/rustc_error_codes/src/error_codes/E0492.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0492.md", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0492.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0492.md?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -6,7 +6,7 @@ Erroneous code example:\n use std::sync::atomic::AtomicUsize;\n \n const A: AtomicUsize = AtomicUsize::new(0);\n-static B: &'static AtomicUsize = &A;\n+const B: &'static AtomicUsize = &A;\n // error: cannot borrow a constant which may contain interior mutability,\n //        create a static instead\n ```\n@@ -18,7 +18,7 @@ can't be changed via a shared `&` pointer, but interior mutability would allow\n it. That is, a constant value could be mutated. On the other hand, a `static` is\n explicitly a single memory location, which can be mutated at will.\n \n-So, in order to solve this error, either use statics which are `Sync`:\n+So, in order to solve this error, use statics which are `Sync`:\n \n ```\n use std::sync::atomic::AtomicUsize;"}, {"sha": "3b54ffbc3f08d653e40c68cafd5d9581281e5b95", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -626,6 +626,9 @@ declare_features! (\n     /// Allows const generics to have default values (e.g. `struct Foo<const N: usize = 3>(...);`).\n     (active, const_generics_defaults, \"1.51.0\", Some(44580), None),\n \n+    /// Allows references to types with interior mutability within constants\n+    (active, const_refs_to_cell, \"1.51.0\", Some(80384), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "9e90a7519cf2c8a74e9f897adb43417a84b7abf6", "filename": "compiler/rustc_mir/src/transform/check_consts/ops.rs", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -209,16 +209,61 @@ impl NonConstOp for LiveDrop {\n }\n \n #[derive(Debug)]\n+/// A borrow of a type that contains an `UnsafeCell` somewhere. The borrow never escapes to\n+/// the final value of the constant.\n+pub struct TransientCellBorrow;\n+impl NonConstOp for TransientCellBorrow {\n+    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+        Status::Unstable(sym::const_refs_to_cell)\n+    }\n+    fn importance(&self) -> DiagnosticImportance {\n+        // The cases that cannot possibly work will already emit a `CellBorrow`, so we should\n+        // not additionally emit a feature gate error if activating the feature gate won't work.\n+        DiagnosticImportance::Secondary\n+    }\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        feature_err(\n+            &ccx.tcx.sess.parse_sess,\n+            sym::const_refs_to_cell,\n+            span,\n+            \"cannot borrow here, since the borrowed element may contain interior mutability\",\n+        )\n+    }\n+}\n+\n+#[derive(Debug)]\n+/// A borrow of a type that contains an `UnsafeCell` somewhere. The borrow might escape to\n+/// the final value of the constant, and thus we cannot allow this (for now). We may allow\n+/// it in the future for static items.\n pub struct CellBorrow;\n impl NonConstOp for CellBorrow {\n     fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n-        struct_span_err!(\n+        let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n             E0492,\n-            \"cannot borrow a constant which may contain \\\n-            interior mutability, create a static instead\"\n-        )\n+            \"{}s cannot refer to interior mutable data\",\n+            ccx.const_kind(),\n+        );\n+        err.span_label(\n+            span,\n+            format!(\"this borrow of an interior mutable value may end up in the final value\"),\n+        );\n+        if let hir::ConstContext::Static(_) = ccx.const_kind() {\n+            err.help(\n+                \"to fix this, the value can be extracted to a separate \\\n+                `static` item and then referenced\",\n+            );\n+        }\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\n+                \"A constant containing interior mutable data behind a reference can allow you\n+                 to modify that data. This would make multiple uses of a constant to be able to\n+                 see different values and allow circumventing the `Send` and `Sync` requirements\n+                 for shared mutable data, which is unsound.\",\n+            );\n+        }\n+        err\n     }\n }\n "}, {"sha": "d1c07d1051d2fa79ffc9d663b6e81149aee52939", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -3,6 +3,7 @@\n use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorReported};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{self as hir, HirId, LangItem};\n+use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::{ImplSource, Obligation, ObligationCause};\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n@@ -188,6 +189,9 @@ pub struct Validator<'mir, 'tcx> {\n     /// The span of the current statement.\n     span: Span,\n \n+    /// A set that stores for each local whether it has a `StorageDead` for it somewhere.\n+    local_has_storage_dead: Option<BitSet<Local>>,\n+\n     error_emitted: Option<ErrorReported>,\n     secondary_errors: Vec<Diagnostic>,\n }\n@@ -206,6 +210,7 @@ impl Validator<'mir, 'tcx> {\n             span: ccx.body.span,\n             ccx,\n             qualifs: Default::default(),\n+            local_has_storage_dead: None,\n             error_emitted: None,\n             secondary_errors: Vec::new(),\n         }\n@@ -282,6 +287,27 @@ impl Validator<'mir, 'tcx> {\n         }\n     }\n \n+    fn local_has_storage_dead(&mut self, local: Local) -> bool {\n+        let ccx = self.ccx;\n+        self.local_has_storage_dead\n+            .get_or_insert_with(|| {\n+                struct StorageDeads {\n+                    locals: BitSet<Local>,\n+                }\n+                impl Visitor<'tcx> for StorageDeads {\n+                    fn visit_statement(&mut self, stmt: &Statement<'tcx>, _: Location) {\n+                        if let StatementKind::StorageDead(l) = stmt.kind {\n+                            self.locals.insert(l);\n+                        }\n+                    }\n+                }\n+                let mut v = StorageDeads { locals: BitSet::new_empty(ccx.body.local_decls.len()) };\n+                v.visit_body(ccx.body);\n+                v.locals\n+            })\n+            .contains(local)\n+    }\n+\n     pub fn qualifs_in_return_place(&mut self) -> ConstQualifs {\n         self.qualifs.in_return_place(self.ccx, self.error_emitted)\n     }\n@@ -556,7 +582,29 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 );\n \n                 if borrowed_place_has_mut_interior {\n-                    self.check_op(ops::CellBorrow);\n+                    match self.const_kind() {\n+                        // In a const fn all borrows are transient or point to the places given via\n+                        // references in the arguments (so we already checked them with\n+                        // TransientCellBorrow/CellBorrow as appropriate).\n+                        // The borrow checker guarantees that no new non-transient borrows are created.\n+                        // NOTE: Once we have heap allocations during CTFE we need to figure out\n+                        // how to prevent `const fn` to create long-lived allocations that point\n+                        // to (interior) mutable memory.\n+                        hir::ConstContext::ConstFn => self.check_op(ops::TransientCellBorrow),\n+                        _ => {\n+                            // Locals with StorageDead are definitely not part of the final constant value, and\n+                            // it is thus inherently safe to permit such locals to have their\n+                            // address taken as we can't end up with a reference to them in the\n+                            // final value.\n+                            // Note: This is only sound if every local that has a `StorageDead` has a\n+                            // `StorageDead` in every control flow path leading to a `return` terminator.\n+                            if self.local_has_storage_dead(place.local) {\n+                                self.check_op(ops::TransientCellBorrow);\n+                            } else {\n+                                self.check_op(ops::CellBorrow);\n+                            }\n+                        }\n+                    }\n                 }\n             }\n "}, {"sha": "b6cf584d875f1aaaa76d3cdc9bf473298ef6859b", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -381,6 +381,7 @@ symbols! {\n         const_ptr,\n         const_raw_ptr_deref,\n         const_raw_ptr_to_usize_cast,\n+        const_refs_to_cell,\n         const_slice_ptr,\n         const_trait_bound_opt_out,\n         const_trait_impl,"}, {"sha": "93120753b1a08851b1af24ab0a5ae6db3e0b6663", "filename": "src/test/ui/consts/const-address-of-interior-mut.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-interior-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-interior-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-interior-mut.stderr?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -1,27 +1,39 @@\n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0658]: cannot borrow here, since the borrowed element may contain interior mutability\n   --> $DIR/const-address-of-interior-mut.rs:5:39\n    |\n LL | const A: () = { let x = Cell::new(2); &raw const x; };\n    |                                       ^^^^^^^^^^^^\n+   |\n+   = note: see issue #80384 <https://github.com/rust-lang/rust/issues/80384> for more information\n+   = help: add `#![feature(const_refs_to_cell)]` to the crate attributes to enable\n \n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0658]: cannot borrow here, since the borrowed element may contain interior mutability\n   --> $DIR/const-address-of-interior-mut.rs:7:40\n    |\n LL | static B: () = { let x = Cell::new(2); &raw const x; };\n    |                                        ^^^^^^^^^^^^\n+   |\n+   = note: see issue #80384 <https://github.com/rust-lang/rust/issues/80384> for more information\n+   = help: add `#![feature(const_refs_to_cell)]` to the crate attributes to enable\n \n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0658]: cannot borrow here, since the borrowed element may contain interior mutability\n   --> $DIR/const-address-of-interior-mut.rs:9:44\n    |\n LL | static mut C: () = { let x = Cell::new(2); &raw const x; };\n    |                                            ^^^^^^^^^^^^\n+   |\n+   = note: see issue #80384 <https://github.com/rust-lang/rust/issues/80384> for more information\n+   = help: add `#![feature(const_refs_to_cell)]` to the crate attributes to enable\n \n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0658]: cannot borrow here, since the borrowed element may contain interior mutability\n   --> $DIR/const-address-of-interior-mut.rs:13:13\n    |\n LL |     let y = &raw const x;\n    |             ^^^^^^^^^^^^\n+   |\n+   = note: see issue #80384 <https://github.com/rust-lang/rust/issues/80384> for more information\n+   = help: add `#![feature(const_refs_to_cell)]` to the crate attributes to enable\n \n error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0492`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "7e0f1a812fd9c09a84cce492389115e38265ad37", "filename": "src/test/ui/consts/const-multi-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -13,7 +13,7 @@ const _: i32 = {\n \n const _: std::cell::Cell<i32> = {\n     let mut a = std::cell::Cell::new(5);\n-    let p = &a; //~ ERROR cannot borrow a constant which may contain interior mutability\n+    let p = &a; //~ ERROR borrowed element may contain interior mutability\n \n     let reborrow = {p};\n     let pp = &reborrow;"}, {"sha": "c0a320d46cbf9aface1b47f2f210995c73093bf8", "filename": "src/test/ui/consts/const-multi-ref.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -4,13 +4,16 @@ error[E0764]: mutable references are not allowed in constants\n LL |     let p = &mut a;\n    |             ^^^^^^ `&mut` is only allowed in `const fn`\n \n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0658]: cannot borrow here, since the borrowed element may contain interior mutability\n   --> $DIR/const-multi-ref.rs:16:13\n    |\n LL |     let p = &a;\n    |             ^^\n+   |\n+   = note: see issue #80384 <https://github.com/rust-lang/rust/issues/80384> for more information\n+   = help: add `#![feature(const_refs_to_cell)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0492, E0764.\n-For more information about an error, try `rustc --explain E0492`.\n+Some errors have detailed explanations: E0658, E0764.\n+For more information about an error, try `rustc --explain E0658`."}, {"sha": "7c28b8b8a628edb8bfcf39f66cd66b89275f8c18", "filename": "src/test/ui/consts/partial_qualif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fpartial_qualif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fpartial_qualif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpartial_qualif.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -3,7 +3,7 @@ use std::cell::Cell;\n const FOO: &(Cell<usize>, bool) = {\n     let mut a = (Cell::new(0), false);\n     a.1 = true; // sets `qualif(a)` to `qualif(a) | qualif(true)`\n-    &{a} //~ ERROR cannot borrow a constant which may contain interior mutability\n+    &{a} //~ ERROR cannot refer to interior mutable\n };\n \n fn main() {}"}, {"sha": "32c25be21735bd760e5497b6ca86bb69464a24e4", "filename": "src/test/ui/consts/partial_qualif.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fpartial_qualif.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fpartial_qualif.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpartial_qualif.stderr?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -1,8 +1,8 @@\n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0492]: constants cannot refer to interior mutable data\n   --> $DIR/partial_qualif.rs:6:5\n    |\n LL |     &{a}\n-   |     ^^^^\n+   |     ^^^^ this borrow of an interior mutable value may end up in the final value\n \n error: aborting due to previous error\n "}, {"sha": "aae4e41ffd7eec5b78cd9d95d08eee4c5d317a88", "filename": "src/test/ui/consts/qualif_overwrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -7,7 +7,7 @@ use std::cell::Cell;\n const FOO: &Option<Cell<usize>> = {\n     let mut a = Some(Cell::new(0));\n     a = None; // sets `qualif(a)` to `qualif(a) | qualif(None)`\n-    &{a} //~ ERROR cannot borrow a constant which may contain interior mutability\n+    &{a} //~ ERROR cannot refer to interior mutable\n };\n \n fn main() {}"}, {"sha": "86a669c433df663bbbe98f7a2962b802ea448d65", "filename": "src/test/ui/consts/qualif_overwrite.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite.stderr?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -1,8 +1,8 @@\n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0492]: constants cannot refer to interior mutable data\n   --> $DIR/qualif_overwrite.rs:10:5\n    |\n LL |     &{a}\n-   |     ^^^^\n+   |     ^^^^ this borrow of an interior mutable value may end up in the final value\n \n error: aborting due to previous error\n "}, {"sha": "1819d9a6d203d301d826b8805220f4c3f72a6c4e", "filename": "src/test/ui/consts/qualif_overwrite_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite_2.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -5,7 +5,7 @@ use std::cell::Cell;\n const FOO: &Option<Cell<usize>> = {\n     let mut a = (Some(Cell::new(0)),);\n     a.0 = None; // sets `qualif(a)` to `qualif(a) | qualif(None)`\n-    &{a.0} //~ ERROR cannot borrow a constant which may contain interior mutability\n+    &{a.0} //~ ERROR cannot refer to interior mutable\n };\n \n fn main() {}"}, {"sha": "9eb123d0b01b1d3d26c817d7c1d854e05b3c0b72", "filename": "src/test/ui/consts/qualif_overwrite_2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fqualif_overwrite_2.stderr?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -1,8 +1,8 @@\n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0492]: constants cannot refer to interior mutable data\n   --> $DIR/qualif_overwrite_2.rs:8:5\n    |\n LL |     &{a.0}\n-   |     ^^^^^^\n+   |     ^^^^^^ this borrow of an interior mutable value may end up in the final value\n \n error: aborting due to previous error\n "}, {"sha": "f1ef541319a4bd277fa010e475c46f929c4639a8", "filename": "src/test/ui/consts/std/cell.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fcell.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -1,18 +1,31 @@\n+#![feature(const_refs_to_cell)]\n+\n use std::cell::*;\n \n-// not ok, because this would create a silent constant with interior mutability.\n-// the rules could be relaxed in the future\n+// not ok, because this creates a dangling pointer, just like `let x = Cell::new(42).as_ptr()` would\n static FOO: Wrap<*mut u32> = Wrap(Cell::new(42).as_ptr());\n-//~^ ERROR cannot borrow a constant which may contain interior mutability\n+//~^ ERROR encountered dangling pointer\n+const FOO_CONST: Wrap<*mut u32> = Wrap(Cell::new(42).as_ptr());\n+//~^ ERROR encountered dangling pointer\n \n+// Ok, these are just base values and it is the `Wrap` author's job to uphold `Send` and `Sync`\n+// invariants, since they used `unsafe impl`.\n static FOO3: Wrap<Cell<u32>> = Wrap(Cell::new(42));\n-// ok\n+const FOO3_CONST: Wrap<Cell<u32>> = Wrap(Cell::new(42));\n+\n+// ok, we are referring to the memory of another static item.\n static FOO4: Wrap<*mut u32> = Wrap(FOO3.0.as_ptr());\n \n-// not ok, because the `as_ptr` call takes a reference to a type with interior mutability\n-// which is not allowed in constants\n+// not ok, the use of a constant here is equivalent to an inline declaration of the value, so\n+// its memory will get freed before the constant is finished evaluating, thus creating a dangling\n+// pointer. This would happen exactly the same at runtime.\n+const FOO4_CONST: Wrap<*mut u32> = Wrap(FOO3_CONST.0.as_ptr());\n+//~^ ERROR encountered dangling pointer\n+\n+// not ok, because the `as_ptr` call takes a reference to a temporary that will get freed\n+// before the constant is finished evaluating.\n const FOO2: *mut u32 = Cell::new(42).as_ptr();\n-//~^ ERROR cannot borrow a constant which may contain interior mutability\n+//~^ ERROR encountered dangling pointer\n \n struct IMSafeTrustMe(UnsafeCell<u32>);\n unsafe impl Send for IMSafeTrustMe {}\n@@ -21,10 +34,13 @@ unsafe impl Sync for IMSafeTrustMe {}\n static BAR: IMSafeTrustMe = IMSafeTrustMe(UnsafeCell::new(5));\n \n \n+\n struct Wrap<T>(T);\n unsafe impl<T> Send for Wrap<T> {}\n unsafe impl<T> Sync for Wrap<T> {}\n \n static BAR_PTR: Wrap<*mut u32> = Wrap(BAR.0.get());\n \n+const fn fst_ref<T, U>(x: &(T, U)) -> &T { &x.0 }\n+\n fn main() {}"}, {"sha": "355c326f0b6f12d6038f33c929e3ddc6f75df195", "filename": "src/test/ui/consts/std/cell.stderr", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fcell.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fcell.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fcell.stderr?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -1,15 +1,26 @@\n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n-  --> $DIR/cell.rs:5:35\n+error: encountered dangling pointer in final constant\n+  --> $DIR/cell.rs:6:1\n    |\n LL | static FOO: Wrap<*mut u32> = Wrap(Cell::new(42).as_ptr());\n-   |                                   ^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n-  --> $DIR/cell.rs:14:24\n+error: encountered dangling pointer in final constant\n+  --> $DIR/cell.rs:8:1\n+   |\n+LL | const FOO_CONST: Wrap<*mut u32> = Wrap(Cell::new(42).as_ptr());\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: encountered dangling pointer in final constant\n+  --> $DIR/cell.rs:22:1\n+   |\n+LL | const FOO4_CONST: Wrap<*mut u32> = Wrap(FOO3_CONST.0.as_ptr());\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: encountered dangling pointer in final constant\n+  --> $DIR/cell.rs:27:1\n    |\n LL | const FOO2: *mut u32 = Cell::new(42).as_ptr();\n-   |                        ^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0492`."}, {"sha": "2c735fcc9f91c1358ddac2badc6924953b6b6e02", "filename": "src/test/ui/error-codes/E0492.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Ferror-codes%2FE0492.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Ferror-codes%2FE0492.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0492.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -1,7 +1,10 @@\n use std::sync::atomic::AtomicUsize;\n \n const A: AtomicUsize = AtomicUsize::new(0);\n-static B: &'static AtomicUsize = &A; //~ ERROR E0492\n+const B: &'static AtomicUsize = &A; //~ ERROR E0492\n+static C: &'static AtomicUsize = &A; //~ ERROR E0492\n+\n+const NONE: &'static Option<AtomicUsize> = &None;\n \n fn main() {\n }"}, {"sha": "557c977e87d9c4c8748269e6e0a0827639e9a850", "filename": "src/test/ui/error-codes/E0492.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Ferror-codes%2FE0492.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Ferror-codes%2FE0492.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0492.stderr?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -1,9 +1,17 @@\n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n-  --> $DIR/E0492.rs:4:34\n+error[E0492]: constants cannot refer to interior mutable data\n+  --> $DIR/E0492.rs:4:33\n    |\n-LL | static B: &'static AtomicUsize = &A;\n-   |                                  ^^\n+LL | const B: &'static AtomicUsize = &A;\n+   |                                 ^^ this borrow of an interior mutable value may end up in the final value\n \n-error: aborting due to previous error\n+error[E0492]: statics cannot refer to interior mutable data\n+  --> $DIR/E0492.rs:5:34\n+   |\n+LL | static C: &'static AtomicUsize = &A;\n+   |                                  ^^ this borrow of an interior mutable value may end up in the final value\n+   |\n+   = help: to fix this, the value can be extracted to a separate `static` item and then referenced\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0492`."}, {"sha": "63159ed05532fb77cf64493ebe2c9dff300d5131", "filename": "src/test/ui/feature-gate/feature-gate-const_refs_to_cell.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-const_refs_to_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-const_refs_to_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-const_refs_to_cell.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+#![feature(const_refs_to_cell)]\n+\n+const FOO: () = {\n+    let x = std::cell::Cell::new(42);\n+    let y = &x;\n+};\n+\n+fn main() {\n+    FOO;\n+}"}, {"sha": "89316dbd5c41a0b9f8db8a55eb71041d3ddf158f", "filename": "src/test/ui/issues/issue-17718-const-borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-borrow.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -2,13 +2,13 @@ use std::cell::UnsafeCell;\n \n const A: UnsafeCell<usize> = UnsafeCell::new(1);\n const B: &'static UnsafeCell<usize> = &A;\n-//~^ ERROR: cannot borrow a constant which may contain interior mutability\n+//~^ ERROR: cannot refer to interior mutable\n \n struct C { a: UnsafeCell<usize> }\n const D: C = C { a: UnsafeCell::new(1) };\n const E: &'static UnsafeCell<usize> = &D.a;\n-//~^ ERROR: cannot borrow a constant which may contain interior mutability\n+//~^ ERROR: cannot refer to interior mutable\n const F: &'static C = &D;\n-//~^ ERROR: cannot borrow a constant which may contain interior mutability\n+//~^ ERROR: cannot refer to interior mutable\n \n fn main() {}"}, {"sha": "e3ff6c923ad7fa44d665d6b492231411b12ecf61", "filename": "src/test/ui/issues/issue-17718-const-borrow.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-borrow.stderr?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -1,20 +1,20 @@\n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0492]: constants cannot refer to interior mutable data\n   --> $DIR/issue-17718-const-borrow.rs:4:39\n    |\n LL | const B: &'static UnsafeCell<usize> = &A;\n-   |                                       ^^\n+   |                                       ^^ this borrow of an interior mutable value may end up in the final value\n \n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0492]: constants cannot refer to interior mutable data\n   --> $DIR/issue-17718-const-borrow.rs:9:39\n    |\n LL | const E: &'static UnsafeCell<usize> = &D.a;\n-   |                                       ^^^^\n+   |                                       ^^^^ this borrow of an interior mutable value may end up in the final value\n \n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0492]: constants cannot refer to interior mutable data\n   --> $DIR/issue-17718-const-borrow.rs:11:23\n    |\n LL | const F: &'static C = &D;\n-   |                       ^^\n+   |                       ^^ this borrow of an interior mutable value may end up in the final value\n \n error: aborting due to 3 previous errors\n "}, {"sha": "68e3e21df3e0841079bbece611ebcef22e160e6e", "filename": "src/test/ui/panic-handler/weak-lang-item.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fpanic-handler%2Fweak-lang-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Fpanic-handler%2Fweak-lang-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-handler%2Fweak-lang-item.stderr?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -10,10 +10,10 @@ help: you can use `as` to change the binding name of the import\n LL | extern crate core as other_core;\n    |\n \n-error: `#[panic_handler]` function required, but not found\n-\n error: language item required, but not found: `eh_personality`\n \n+error: `#[panic_handler]` function required, but not found\n+\n error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0259`."}, {"sha": "c069ae7da021232d8ab79ec6e543440857152d89", "filename": "src/test/ui/unsafe/ranged_ints3_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.rs?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -9,13 +9,13 @@ fn main() {}\n \n const fn foo() -> NonZero<Cell<u32>> {\n     let mut x = unsafe { NonZero(Cell::new(1)) };\n-    let y = &x.0; //~ ERROR cannot borrow a constant which may contain interior mutability\n+    let y = &x.0; //~ ERROR the borrowed element may contain interior mutability\n     //~^ ERROR borrow of layout constrained field with interior mutability\n     unsafe { NonZero(Cell::new(1)) }\n }\n \n const fn bar() -> NonZero<Cell<u32>> {\n     let mut x = unsafe { NonZero(Cell::new(1)) };\n-    let y = unsafe { &x.0 }; //~ ERROR cannot borrow a constant which may contain interior mut\n+    let y = unsafe { &x.0 }; //~ ERROR the borrowed element may contain interior mutability\n     unsafe { NonZero(Cell::new(1)) }\n }"}, {"sha": "215005571f6d740036e13e1d132691d79d4931db", "filename": "src/test/ui/unsafe/ranged_ints3_const.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8989689e728895147e41c497e7ca69e7f82f69d7/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.stderr?ref=8989689e728895147e41c497e7ca69e7f82f69d7", "patch": "@@ -1,14 +1,20 @@\n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0658]: cannot borrow here, since the borrowed element may contain interior mutability\n   --> $DIR/ranged_ints3_const.rs:12:13\n    |\n LL |     let y = &x.0;\n    |             ^^^^\n+   |\n+   = note: see issue #80384 <https://github.com/rust-lang/rust/issues/80384> for more information\n+   = help: add `#![feature(const_refs_to_cell)]` to the crate attributes to enable\n \n-error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+error[E0658]: cannot borrow here, since the borrowed element may contain interior mutability\n   --> $DIR/ranged_ints3_const.rs:19:22\n    |\n LL |     let y = unsafe { &x.0 };\n    |                      ^^^^\n+   |\n+   = note: see issue #80384 <https://github.com/rust-lang/rust/issues/80384> for more information\n+   = help: add `#![feature(const_refs_to_cell)]` to the crate attributes to enable\n \n error[E0133]: borrow of layout constrained field with interior mutability is unsafe and requires unsafe function or block\n   --> $DIR/ranged_ints3_const.rs:12:13\n@@ -20,5 +26,5 @@ LL |     let y = &x.0;\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0133, E0492.\n+Some errors have detailed explanations: E0133, E0658.\n For more information about an error, try `rustc --explain E0133`."}]}