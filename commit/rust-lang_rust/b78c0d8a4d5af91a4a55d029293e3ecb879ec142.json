{"sha": "b78c0d8a4d5af91a4a55d029293e3ecb879ec142", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3OGMwZDhhNGQ1YWY5MWE0YTU1ZDAyOTI5M2UzZWNiODc5ZWMxNDI=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-04-21T15:49:59Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-04-21T15:49:59Z"}, "message": "Review comments", "tree": {"sha": "ae3b4fa38507b9c1effd5822aef6e12fe05fcb45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae3b4fa38507b9c1effd5822aef6e12fe05fcb45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b78c0d8a4d5af91a4a55d029293e3ecb879ec142", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b78c0d8a4d5af91a4a55d029293e3ecb879ec142", "html_url": "https://github.com/rust-lang/rust/commit/b78c0d8a4d5af91a4a55d029293e3ecb879ec142", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b78c0d8a4d5af91a4a55d029293e3ecb879ec142/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4568e7d62edc52dca67e28ea771978513cf6f393", "url": "https://api.github.com/repos/rust-lang/rust/commits/4568e7d62edc52dca67e28ea771978513cf6f393", "html_url": "https://github.com/rust-lang/rust/commit/4568e7d62edc52dca67e28ea771978513cf6f393"}], "stats": {"total": 69, "additions": 33, "deletions": 36}, "files": [{"sha": "8a3f76415968ec84955837b9e75fde29ea6e15b2", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b78c0d8a4d5af91a4a55d029293e3ecb879ec142/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b78c0d8a4d5af91a4a55d029293e3ecb879ec142/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=b78c0d8a4d5af91a4a55d029293e3ecb879ec142", "patch": "@@ -81,13 +81,6 @@ struct AstValidator<'a> {\n     is_assoc_ty_bound_banned: bool,\n \n     lint_buffer: &'a mut LintBuffer,\n-\n-    /// This is slightly complicated. Our representation for poly-trait-refs contains a single\n-    /// binder and thus we only allow a single level of quantification. However,\n-    /// the syntax of Rust permits quantification in two places in where clauses,\n-    /// e.g., `T: for <'a> Foo<'a>` and `for <'a, 'b> &'b T: Foo<'a>`. If both are\n-    /// defined, then error.\n-    trait_ref_hack: bool,\n }\n \n impl<'a> AstValidator<'a> {\n@@ -1227,17 +1220,33 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n                     self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n \n-                    self.visit_ty(&bound_pred.bounded_ty);\n-\n-                    self.trait_ref_hack = !bound_pred.bound_generic_params.is_empty();\n-                    walk_list!(self, visit_param_bound, &bound_pred.bounds);\n-                    walk_list!(self, visit_generic_param, &bound_pred.bound_generic_params);\n-                    self.trait_ref_hack = false;\n-                }\n-                _ => {\n-                    self.visit_where_predicate(predicate);\n+                    // This is slightly complicated. Our representation for poly-trait-refs contains a single\n+                    // binder and thus we only allow a single level of quantification. However,\n+                    // the syntax of Rust permits quantification in two places in where clauses,\n+                    // e.g., `T: for <'a> Foo<'a>` and `for <'a, 'b> &'b T: Foo<'a>`. If both are\n+                    // defined, then error.\n+                    if !bound_pred.bound_generic_params.is_empty() {\n+                        for bound in &bound_pred.bounds {\n+                            match bound {\n+                                GenericBound::Trait(t, _) => {\n+                                    if !t.bound_generic_params.is_empty() {\n+                                        struct_span_err!(\n+                                            self.err_handler(),\n+                                            t.span,\n+                                            E0316,\n+                                            \"nested quantification of lifetimes\"\n+                                        )\n+                                        .emit();\n+                                    }\n+                                }\n+                                GenericBound::Outlives(_) => {}\n+                            }\n+                        }\n+                    }\n                 }\n+                _ => {}\n             }\n+            self.visit_where_predicate(predicate);\n         }\n     }\n \n@@ -1289,19 +1298,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n     fn visit_poly_trait_ref(&mut self, t: &'a PolyTraitRef, m: &'a TraitBoundModifier) {\n         self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n-        if self.trait_ref_hack && !t.bound_generic_params.is_empty() {\n-            struct_span_err!(\n-                self.err_handler(),\n-                t.span,\n-                E0316,\n-                \"nested quantification of lifetimes\"\n-            )\n-            .emit();\n-        }\n-        let trait_ref_hack = self.trait_ref_hack;\n-        self.trait_ref_hack = false;\n         visit::walk_poly_trait_ref(self, t, m);\n-        self.trait_ref_hack = trait_ref_hack;\n     }\n \n     fn visit_variant_data(&mut self, s: &'a VariantData) {\n@@ -1520,7 +1517,6 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n         lint_buffer: lints,\n-        trait_ref_hack: false,\n     };\n     visit::walk_crate(&mut validator, krate);\n "}, {"sha": "dfb6167c20cac84158fe95df8ecab7544e09fb14", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b78c0d8a4d5af91a4a55d029293e3ecb879ec142/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b78c0d8a4d5af91a4a55d029293e3ecb879ec142/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=b78c0d8a4d5af91a4a55d029293e3ecb879ec142", "patch": "@@ -1323,14 +1323,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         // of \"if there isn't a Binder scope above us, add one\", but I\n         // imagine there's a better way to go about this.\n         let mut scope = self.scope;\n-        let trait_ref_hack = loop {\n+        let (binders, scope_type) = loop {\n             match scope {\n                 Scope::TraitRefBoundary { .. } | Scope::Body { .. } | Scope::Root => {\n-                    break false;\n+                    break (vec![], BinderScopeType::PolyTraitRef);\n                 }\n \n-                Scope::Binder { .. } => {\n-                    break true;\n+                Scope::Binder { hir_id, .. } => {\n+                    let binders = self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n+                    break (binders, BinderScopeType::Concatenating);\n                 }\n \n                 Scope::Elision { s, .. }\n@@ -1341,16 +1342,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n         };\n         match bound {\n-            hir::GenericBound::LangItemTrait(_, _, hir_id, _) if !trait_ref_hack => {\n-                self.map.late_bound_vars.insert(*hir_id, vec![]);\n+            hir::GenericBound::LangItemTrait(_, _, hir_id, _) => {\n+                self.map.late_bound_vars.insert(*hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: *hir_id,\n                     lifetimes: FxHashMap::default(),\n                     s: self.scope,\n                     next_early_index: self.next_early_index(),\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    scope_type: BinderScopeType::Other,\n+                    scope_type,\n                 };\n                 self.with(scope, |_, this| {\n                     intravisit::walk_param_bound(this, bound);"}]}