{"sha": "8e6d2099145ee3d6bd349865e712b1a13e70115f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNmQyMDk5MTQ1ZWUzZDZiZDM0OTg2NWU3MTJiMWExM2U3MDExNWY=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-25T01:36:10Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-25T01:36:10Z"}, "message": "Remove and comment out more MergeState code", "tree": {"sha": "64656d1ac6a06f9f761266e9578d8fec96272ae6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64656d1ac6a06f9f761266e9578d8fec96272ae6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e6d2099145ee3d6bd349865e712b1a13e70115f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6d2099145ee3d6bd349865e712b1a13e70115f", "html_url": "https://github.com/rust-lang/rust/commit/8e6d2099145ee3d6bd349865e712b1a13e70115f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e6d2099145ee3d6bd349865e712b1a13e70115f/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "046460c7f6ff9d196b0d4c9757bce15cf99e1070", "url": "https://api.github.com/repos/rust-lang/rust/commits/046460c7f6ff9d196b0d4c9757bce15cf99e1070", "html_url": "https://github.com/rust-lang/rust/commit/046460c7f6ff9d196b0d4c9757bce15cf99e1070"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "498959982a9d34bf6a00d3cbcbcff79537c578e0", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d2099145ee3d6bd349865e712b1a13e70115f/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d2099145ee3d6bd349865e712b1a13e70115f/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=8e6d2099145ee3d6bd349865e712b1a13e70115f", "patch": "@@ -353,17 +353,17 @@ struct RunState {\n \n struct MergeState<T> {\n     mut min_gallop: uint,\n-    mut mergePt: uint,\n-    mut tmpPt: uint,\n+    //mut mergePt: uint,\n+    //mut tmpPt: uint,\n     mut array: &[mut T],\n     runs: DVec<RunState>,\n }\n \n fn MergeState<T>() -> MergeState<T> {\n     MergeState {\n         min_gallop: MIN_GALLOP,\n-        mergePt: 0,\n-        tmpPt: 0,\n+        //mergePt: 0,\n+        //tmpPt: 0,\n         array: &[mut],\n         runs: DVec(),\n     }\n@@ -427,13 +427,13 @@ impl<T: Copy Ord> MergeState<T> {\n             }\n \n             let slice = vec::mut_view(array, b1, b1+l1);\n-            self.mergePt = b1;\n+            //self.mergePt = b1;\n             let k = gallop_right(&const array[b2], slice, 0);\n             b1 += k;\n             l1 -= k;\n             if l1 != 0 {\n                 let slice = vec::mut_view(array, b2, b2+l2);\n-                self.mergePt = b2;\n+                //self.mergePt = b2;\n                 let l2 = gallop_left(\n                     &const array[b1+l1-1],slice,l2-1);\n                 if l2 > 0 {\n@@ -446,16 +446,16 @@ impl<T: Copy Ord> MergeState<T> {\n             }\n         }\n         self.runs.pop();\n-        self.mergePt = 0;\n+        //self.mergePt = 0;\n     }\n \n     fn merge_lo(&self, array: &[mut T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n \n         let tmp = vec::to_mut(vec::slice(array, base1, base1+len1));\n-        self.tmpPt = 0;\n-        self.mergePt = base1;\n+        //self.tmpPt = 0;\n+        //self.mergePt = base1;\n \n         let mut c1 = 0;\n         let mut c2 = base2;\n@@ -465,7 +465,7 @@ impl<T: Copy Ord> MergeState<T> {\n \n         array[dest] <-> array[c2];\n         dest += 1; c2 += 1; len2 -= 1;\n-        self.mergePt += 1;\n+        //self.mergePt += 1;\n \n         if len2 == 0 {\n             copy_vec(array, dest, tmp, 0, len1);\n@@ -488,16 +488,16 @@ impl<T: Copy Ord> MergeState<T> {\n                 if array[c2] < tmp[c1] {\n                     array[dest] <-> array[c2];\n                     dest += 1; c2 += 1; len2 -= 1;\n-                    self.mergePt += 1;\n+                    //self.mergePt += 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 0 {\n                         break_outer = true;\n                     }\n                 } else {\n                     array[dest] <-> tmp[c1];\n                     dest += 1; c1 += 1; len1 -= 1;\n-                    self.mergePt += 1;\n-                    self.tmpPt += 1;\n+                    //self.mergePt += 1;\n+                    //self.tmpPt += 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 1 {\n                         break_outer = true;\n@@ -519,25 +519,25 @@ impl<T: Copy Ord> MergeState<T> {\n                 if count1 != 0 {\n                     copy_vec(array, dest, tmp, c1, count1);\n                     dest += count1; c1 += count1; len1 -= count1;\n-                    self.mergePt += count1; self.tmpPt += count1;\n+                    //self.mergePt += count1; self.tmpPt += count1;\n                     if len1 <= 1 { break_outer = true; break; }\n                 }\n                 array[dest] <-> array[c2];\n                 dest += 1; c2 += 1; len2 -= 1;\n-                self.mergePt += 1;\n+                //self.mergePt += 1;\n                 if len2 == 0 { break_outer = true; break; }\n \n                 let tmp_view = vec::const_view(array, c2, c2+len2);\n                 count2 = gallop_left(&const tmp[c1], tmp_view, 0);\n                 if count2 != 0 {\n                     copy_vec(array, dest, array, c2, count2);\n                     dest += count2; c2 += count2; len2 -= count2;\n-                    self.mergePt += count2;\n+                    //self.mergePt += count2;\n                     if len2 == 0 { break_outer = true; break; }\n                 }\n                 array[dest] <-> tmp[c1];\n                 dest += 1; c1 += 1; len1 -= 1;\n-                self.mergePt += 1; self.tmpPt += 1;\n+                //self.mergePt += 1; self.tmpPt += 1;\n                 if len1 == 1 { break_outer = true; break; }\n                 min_gallop -= 1;\n                 if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n@@ -561,7 +561,7 @@ impl<T: Copy Ord> MergeState<T> {\n             assert len1 > 1;\n             copy_vec(array, dest, tmp, c1, len1);\n         }\n-        self.tmpPt = 0;\n+        //self.tmpPt = 0;\n     }\n \n     fn merge_hi(&self, array: &[mut T], base1: uint, len1: uint,\n@@ -576,8 +576,8 @@ impl<T: Copy Ord> MergeState<T> {\n         let mut len1 = len1;\n         let mut len2 = len2;\n \n-        self.mergePt = dest;\n-        self.tmpPt = len2 - 1;\n+        //self.mergePt = dest;\n+        //self.tmpPt = len2 - 1;\n \n         array[dest] <-> array[c1];\n         dest -= 1; c1 -= 1; len1 -= 1;\n@@ -605,15 +605,15 @@ impl<T: Copy Ord> MergeState<T> {\n                 if tmp[c2] < array[c1] {\n                     array[dest] <-> array[c1];\n                     dest -= 1; c1 -= 1; len1 -= 1;\n-                    self.mergePt -= 1;\n+                    //self.mergePt -= 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 0 {\n                         break_outer = true;\n                     }\n                 } else {\n                     array[dest] <-> tmp[c2];\n                     dest -= 1; c2 -= 1; len2 -= 1;\n-                    self.mergePt -= 1; self.tmpPt -= 1;\n+                    //self.mergePt -= 1; self.tmpPt -= 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 1 {\n                         break_outer = true;\n@@ -635,28 +635,28 @@ impl<T: Copy Ord> MergeState<T> {\n \n                 if count1 != 0 {\n                     dest -= count1; c1 -= count1; len1 -= count1;\n-                    self.mergePt -= count1;\n+                    //self.mergePt -= count1;\n                     copy_vec(array, dest+1, array, c1+1, count1);\n                     if len1 == 0 { break_outer = true; break; }\n                 }\n \n                 array[dest] <-> tmp[c2];\n                 dest -= 1; c2 -= 1; len2 -= 1;\n-                self.mergePt -= 1; self.tmpPt -= 1;\n+                //self.mergePt -= 1; self.tmpPt -= 1;\n                 if len2 == 1 { break_outer = true; break; }\n \n                 //let tmp_view = vec::mut_view(tmp, 0, len2);\n                 let count2 = len2 - gallop_left(&const array[c1],\n                             vec::mut_view(tmp, 0, len2), len2-1);\n                 if count2 != 0 {\n                     dest -= count2; c2 -= count2; len2 -= count2;\n-                    self.mergePt -= count2; self.tmpPt -= count2;\n+                    //self.mergePt -= count2; self.tmpPt -= count2;\n                     copy_vec(array, dest+1, tmp, c2+1, count2);\n                     if len2 <= 1 { break_outer = true; break; }\n                 }\n                 array[dest] <-> array[c1];\n                 dest -= 1; c1 -= 1; len1 -= 1;\n-                self.mergePt -= 1;\n+                //self.mergePt -= 1;\n                 if len1 == 0 { break_outer = true; break; }\n                 min_gallop -= 1;\n                 if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n@@ -683,7 +683,7 @@ impl<T: Copy Ord> MergeState<T> {\n             assert len2 != 0;\n             copy_vec(array, dest-(len2-1), tmp, 0, len2);\n         }\n-        self.tmpPt = 0;\n+        //self.tmpPt = 0;\n     }\n \n     fn merge_collapse(&self, array: &[mut T]) {\n@@ -1139,7 +1139,7 @@ mod big_tests {\n                 arr[idx] = @rng.gen_float();\n             }\n             tim_sort(arr);\n-            isSorted(arr, 1);\n+            isSorted(arr);\n \n             let arr = if n > 4 {\n                 let part = vec::view(arr, 0, 4);"}]}