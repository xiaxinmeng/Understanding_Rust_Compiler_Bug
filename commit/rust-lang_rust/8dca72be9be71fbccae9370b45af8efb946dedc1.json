{"sha": "8dca72be9be71fbccae9370b45af8efb946dedc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkY2E3MmJlOWJlNzFmYmNjYWU5MzcwYjQ1YWY4ZWZiOTQ2ZGVkYzE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-02-18T12:45:32Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-03T02:05:55Z"}, "message": "Optimize `syntax::tokenstream::Cursor`.", "tree": {"sha": "14206a82d643981cf64cf833166cbe173111e812", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14206a82d643981cf64cf833166cbe173111e812"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dca72be9be71fbccae9370b45af8efb946dedc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dca72be9be71fbccae9370b45af8efb946dedc1", "html_url": "https://github.com/rust-lang/rust/commit/8dca72be9be71fbccae9370b45af8efb946dedc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dca72be9be71fbccae9370b45af8efb946dedc1/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0143774cb5c21b18bf599b1726e122785c0de452", "url": "https://api.github.com/repos/rust-lang/rust/commits/0143774cb5c21b18bf599b1726e122785c0de452", "html_url": "https://github.com/rust-lang/rust/commit/0143774cb5c21b18bf599b1726e122785c0de452"}], "stats": {"total": 123, "additions": 63, "deletions": 60}, "files": [{"sha": "e3d85bca3e0d27fde2b0977b12122ebcefd04fd2", "filename": "src/libproc_macro_plugin/qquote.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8dca72be9be71fbccae9370b45af8efb946dedc1/src%2Flibproc_macro_plugin%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dca72be9be71fbccae9370b45af8efb946dedc1/src%2Flibproc_macro_plugin%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fqquote.rs?ref=8dca72be9be71fbccae9370b45af8efb946dedc1", "patch": "@@ -17,6 +17,7 @@ use syntax::symbol::Symbol;\n use syntax::tokenstream::{self, Delimited, TokenTree, TokenStream};\n use syntax_pos::DUMMY_SP;\n \n+use std::iter;\n use std::rc::Rc;\n \n pub fn qquote<'cx>(stream: TokenStream) -> TokenStream {\n@@ -75,14 +76,14 @@ impl Quote for TokenStream {\n             return quote!(::syntax::tokenstream::TokenStream::empty());\n         }\n \n-        struct Quote(tokenstream::Cursor);\n+        struct Quote(iter::Peekable<tokenstream::Cursor>);\n \n         impl Iterator for Quote {\n             type Item = TokenStream;\n \n             fn next(&mut self) -> Option<TokenStream> {\n                 let is_unquote = match self.0.peek() {\n-                    Some(TokenTree::Token(_, Token::Ident(ident))) if ident.name == \"unquote\" => {\n+                    Some(&TokenTree::Token(_, Token::Ident(ident))) if ident.name == \"unquote\" => {\n                         self.0.next();\n                         true\n                     }\n@@ -96,7 +97,7 @@ impl Quote for TokenStream {\n             }\n         }\n \n-        let quoted = Quote(self.trees()).collect::<TokenStream>();\n+        let quoted = Quote(self.trees().peekable()).collect::<TokenStream>();\n         quote!([(unquote quoted)].iter().cloned().collect::<::syntax::tokenstream::TokenStream>())\n     }\n }"}, {"sha": "552395945a11aa261764adc895418931d9e2e30c", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/8dca72be9be71fbccae9370b45af8efb946dedc1/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dca72be9be71fbccae9370b45af8efb946dedc1/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=8dca72be9be71fbccae9370b45af8efb946dedc1", "patch": "@@ -299,7 +299,7 @@ impl From<TokenTree> for TokenStream {\n \n impl<T: Into<TokenStream>> iter::FromIterator<T> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n-        TokenStream::concat(iter.into_iter().map(Into::into))\n+        TokenStream::concat(iter.into_iter().map(Into::into).collect::<Vec<_>>())\n     }\n }\n \n@@ -323,19 +323,16 @@ impl TokenStream {\n         }\n     }\n \n-    pub fn concat<I: IntoIterator<Item = TokenStream>>(streams: I) -> TokenStream {\n-        let mut streams = streams.into_iter().filter(|stream| !stream.is_empty());\n-        let first_stream = match streams.next() {\n-            Some(stream) => stream,\n-            None => return TokenStream::empty(),\n-        };\n-        let second_stream = match streams.next() {\n-            Some(stream) => stream,\n-            None => return first_stream,\n-        };\n-        let mut vec = vec![first_stream, second_stream];\n-        vec.extend(streams);\n-        TokenStream { kind: TokenStreamKind::Stream(RcSlice::new(vec)) }\n+    pub fn concat(mut streams: Vec<TokenStream>) -> TokenStream {\n+        match streams.len() {\n+            0 => TokenStream::empty(),\n+            1 => TokenStream::from(streams.pop().unwrap()),\n+            _ => TokenStream::concat_rc_slice(RcSlice::new(streams)),\n+        }\n+    }\n+\n+    fn concat_rc_slice(streams: RcSlice<TokenStream>) -> TokenStream {\n+        TokenStream { kind: TokenStreamKind::Stream(streams) }\n     }\n \n     pub fn trees(&self) -> Cursor {\n@@ -357,62 +354,67 @@ impl TokenStream {\n     }\n }\n \n-pub struct Cursor {\n-    current_frame: CursorFrame,\n-    stack: Vec<CursorFrame>,\n+pub struct Cursor(CursorKind);\n+\n+enum CursorKind {\n+    Empty,\n+    Tree(TokenTree, bool /* consumed? */),\n+    Stream(StreamCursor),\n+}\n+\n+struct StreamCursor {\n+    stream: RcSlice<TokenStream>,\n+    index: usize,\n+    stack: Vec<(RcSlice<TokenStream>, usize)>,\n }\n \n impl Iterator for Cursor {\n     type Item = TokenTree;\n \n     fn next(&mut self) -> Option<TokenTree> {\n-        let tree = self.peek();\n-        self.current_frame = self.stack.pop().unwrap_or(CursorFrame::Empty);\n-        tree\n-    }\n-}\n-\n-enum CursorFrame {\n-    Empty,\n-    Tree(TokenTree),\n-    Stream(RcSlice<TokenStream>, usize),\n-}\n+        let cursor = match self.0 {\n+            CursorKind::Stream(ref mut cursor) => cursor,\n+            CursorKind::Tree(ref tree, ref mut consumed @ false) => {\n+                *consumed = true;\n+                return Some(tree.clone());\n+            }\n+            _ => return None,\n+        };\n \n-impl CursorFrame {\n-    fn new(stream: TokenStream) -> Self {\n-        match stream.kind {\n-            TokenStreamKind::Empty => CursorFrame::Empty,\n-            TokenStreamKind::Tree(tree) => CursorFrame::Tree(tree),\n-            TokenStreamKind::Stream(stream) => CursorFrame::Stream(stream, 0),\n+        loop {\n+            if cursor.index < cursor.stream.len() {\n+                match cursor.stream[cursor.index].kind.clone() {\n+                    TokenStreamKind::Tree(tree) => {\n+                        cursor.index += 1;\n+                        return Some(tree);\n+                    }\n+                    TokenStreamKind::Stream(stream) => {\n+                        cursor.stack.push((mem::replace(&mut cursor.stream, stream),\n+                                           mem::replace(&mut cursor.index, 0) + 1));\n+                    }\n+                    TokenStreamKind::Empty => {\n+                        cursor.index += 1;\n+                    }\n+                }\n+            } else if let Some((stream, index)) = cursor.stack.pop() {\n+                cursor.stream = stream;\n+                cursor.index = index;\n+            } else {\n+                return None;\n+            }\n         }\n     }\n }\n \n impl Cursor {\n     fn new(stream: TokenStream) -> Self {\n-        Cursor {\n-            current_frame: CursorFrame::new(stream),\n-            stack: Vec::new(),\n-        }\n-    }\n-\n-    pub fn peek(&mut self) -> Option<TokenTree> {\n-        while let CursorFrame::Stream(stream, index) =\n-                mem::replace(&mut self.current_frame, CursorFrame::Empty) {\n-            self.current_frame = if index == stream.len() {\n-                self.stack.pop().unwrap_or(CursorFrame::Empty)\n-            } else {\n-                let frame = CursorFrame::new(stream[index].clone());\n-                self.stack.push(CursorFrame::Stream(stream, index + 1));\n-                frame\n-            };\n-        }\n-\n-        match self.current_frame {\n-            CursorFrame::Empty => None,\n-            CursorFrame::Tree(ref tree) => Some(tree.clone()),\n-            CursorFrame::Stream(..) => unreachable!(),\n-        }\n+        Cursor(match stream.kind {\n+            TokenStreamKind::Empty => CursorKind::Empty,\n+            TokenStreamKind::Tree(tree) => CursorKind::Tree(tree, false),\n+            TokenStreamKind::Stream(stream) => {\n+                CursorKind::Stream(StreamCursor { stream: stream, index: 0, stack: Vec::new() })\n+            }\n+        })\n     }\n }\n "}]}