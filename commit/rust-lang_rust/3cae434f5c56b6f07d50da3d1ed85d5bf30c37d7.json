{"sha": "3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjYWU0MzRmNWM1NmI2ZjA3ZDUwZGEzZDFlZDg1ZDViZjMwYzM3ZDc=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-05-21T19:07:48Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-05-24T02:32:30Z"}, "message": "librustc: Consolidate the attribute handling for tagging function arguments and returns.", "tree": {"sha": "c666024371564b2c45a1b7ac02744df8746390d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c666024371564b2c45a1b7ac02744df8746390d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "html_url": "https://github.com/rust-lang/rust/commit/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90eeb92e10d3a1ca058aa1fed24721aa3b7553cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/90eeb92e10d3a1ca058aa1fed24721aa3b7553cb", "html_url": "https://github.com/rust-lang/rust/commit/90eeb92e10d3a1ca058aa1fed24721aa3b7553cb"}], "stats": {"total": 590, "additions": 276, "deletions": 314}, "files": [{"sha": "dacda4e2a0b7c7bb3abffb5ede781e7a58196099", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "patch": "@@ -15,7 +15,7 @@\n use std::c_str::ToCStr;\n use std::cell::RefCell;\n use collections::HashMap;\n-use libc::{c_uint, c_ushort, c_void, free};\n+use libc::{c_uint, c_ushort, c_void, free, uint64_t};\n use std::str::raw::from_c_str;\n \n use middle::trans::type_::Type;\n@@ -92,6 +92,33 @@ pub enum Attribute {\n     NonLazyBindAttribute = 1 << 31,\n }\n \n+#[repr(u64)]\n+pub enum OtherAttribute {\n+    // The following are not really exposed in\n+    // the LLVM c api so instead to add these\n+    // we call a wrapper function in RustWrapper\n+    // that uses the C++ api.\n+    SanitizeAddressAttribute = 1 << 32,\n+    MinSizeAttribute = 1 << 33,\n+    NoDuplicateAttribute = 1 << 34,\n+    StackProtectStrongAttribute = 1 << 35,\n+    SanitizeThreadAttribute = 1 << 36,\n+    SanitizeMemoryAttribute = 1 << 37,\n+    NoBuiltinAttribute = 1 << 38,\n+    ReturnedAttribute = 1 << 39,\n+    ColdAttribute = 1 << 40,\n+    BuiltinAttribute = 1 << 41,\n+    OptimizeNoneAttribute = 1 << 42,\n+    InAllocaAttribute = 1 << 43,\n+    NonNullAttribute = 1 << 44,\n+}\n+\n+#[repr(C)]\n+pub enum AttributeSet {\n+    ReturnIndex = 0,\n+    FunctionIndex = !0\n+}\n+\n // enum for the LLVM IntPredicate type\n pub enum IntPredicate {\n     IntEQ = 32,\n@@ -308,7 +335,7 @@ pub mod llvm {\n     use super::{CodeGenModel, RelocMode, CodeGenOptLevel};\n     use super::debuginfo::*;\n     use libc::{c_char, c_int, c_longlong, c_ushort, c_uint, c_ulonglong,\n-                    size_t};\n+               size_t, uint64_t};\n \n     // Link to our native llvm bindings (things that we need to use the C++ api\n     // for) and because llvm is written in C++ we need to link against libstdc++\n@@ -706,23 +733,11 @@ pub mod llvm {\n         pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n         pub fn LLVMGetGC(Fn: ValueRef) -> *c_char;\n         pub fn LLVMSetGC(Fn: ValueRef, Name: *c_char);\n-        pub fn LLVMAddFunctionAttr(Fn: ValueRef, PA: c_uint);\n-        pub fn LLVMAddFunctionAttrString(Fn: ValueRef, Name: *c_char);\n-        pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, Name: *c_char);\n+        pub fn LLVMAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: uint64_t);\n+        pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *c_char);\n+        pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *c_char);\n         pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n \n-        pub fn LLVMAddReturnAttribute(Fn: ValueRef, PA: c_uint);\n-        pub fn LLVMRemoveReturnAttribute(Fn: ValueRef, PA: c_uint);\n-\n-        pub fn LLVMAddColdAttribute(Fn: ValueRef);\n-\n-        pub fn LLVMAddNonNullAttribute(Arg: ValueRef);\n-        pub fn LLVMAddNonNullReturnAttribute(Fn: ValueRef);\n-\n-        pub fn LLVMRemoveFunctionAttr(Fn: ValueRef,\n-                                      PA: c_ulonglong,\n-                                      HighPA: c_ulonglong);\n-\n         /* Operations on parameters */\n         pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n         pub fn LLVMGetParams(Fn: ValueRef, Params: *ValueRef);\n@@ -786,6 +801,9 @@ pub mod llvm {\n         pub fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n                                           index: c_uint,\n                                           align: c_uint);\n+        pub fn LLVMAddCallSiteAttribute(Instr: ValueRef,\n+                                        index: c_uint,\n+                                        Val: uint64_t);\n \n         /* Operations on call instructions (only) */\n         pub fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n@@ -1838,7 +1856,7 @@ pub fn ConstFCmp(pred: RealPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n \n pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n     unsafe {\n-        llvm::LLVMAddFunctionAttr(fn_, attr as c_uint)\n+        llvm::LLVMAddFunctionAttribute(fn_, FunctionIndex as c_uint, attr as uint64_t)\n     }\n }\n /* Memory-managed object interface to type handles. */"}, {"sha": "43f3442ec472ec79b29bcd379eb481c2777431e7", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 153, "deletions": 124, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "patch": "@@ -73,7 +73,7 @@ use util::sha2::Sha256;\n use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n-use libc::c_uint;\n+use libc::{c_uint, uint64_t};\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n@@ -167,6 +167,7 @@ impl<'a> Drop for StatRecorder<'a> {\n // only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n            ty: Type, output: ty::t) -> ValueRef {\n+\n     let llfn: ValueRef = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMGetOrInsertFunction(llmod, buf, ty.to_ref())\n@@ -177,14 +178,9 @@ fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n         // functions returning bottom may unwind, but can never return normally\n         ty::ty_bot => {\n             unsafe {\n-                llvm::LLVMAddFunctionAttr(llfn, lib::llvm::NoReturnAttribute as c_uint)\n-            }\n-        }\n-        // `~` pointer return values never alias because ownership is transferred\n-        ty::ty_uniq(..) // | ty::ty_trait(_, _, ty::UniqTraitStore, _, _)\n-         => {\n-            unsafe {\n-                llvm::LLVMAddReturnAttribute(llfn, lib::llvm::NoAliasAttribute as c_uint);\n+                llvm::LLVMAddFunctionAttribute(llfn,\n+                                               lib::llvm::FunctionIndex as c_uint,\n+                                               lib::llvm::NoReturnAttribute as uint64_t)\n             }\n         }\n         _ => {}\n@@ -207,8 +203,8 @@ pub fn decl_cdecl_fn(llmod: ModuleRef,\n }\n \n // only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n-pub fn get_extern_fn(externs: &mut ExternMap,\n-                     llmod: ModuleRef,\n+pub fn get_extern_fn(ccx: &CrateContext,\n+                     externs: &mut ExternMap,\n                      name: &str,\n                      cc: lib::llvm::CallConv,\n                      ty: Type,\n@@ -218,19 +214,19 @@ pub fn get_extern_fn(externs: &mut ExternMap,\n         Some(n) => return *n,\n         None => {}\n     }\n-    let f = decl_fn(llmod, name, cc, ty, output);\n+    let f = decl_fn(ccx.llmod, name, cc, ty, output);\n     externs.insert(name.to_strbuf(), f);\n     f\n }\n \n-fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n-                      name: &str, did: ast::DefId) -> ValueRef {\n+fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::DefId) -> ValueRef {\n     match ccx.externs.borrow().find_equiv(&name) {\n         Some(n) => return *n,\n         None => ()\n     }\n \n-    let f = decl_rust_fn(ccx, false, inputs, output, name);\n+    let f = decl_rust_fn(ccx, fn_ty, name);\n+\n     csearch::get_item_attrs(&ccx.sess().cstore, did, |meta_items| {\n         set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr_outer(x))\n                                     .collect::<Vec<_>>().as_slice(), f)\n@@ -240,92 +236,27 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n     f\n }\n \n-pub fn decl_rust_fn(ccx: &CrateContext, has_env: bool,\n-                    inputs: &[ty::t], output: ty::t,\n-                    name: &str) -> ValueRef {\n-    use middle::ty::{BrAnon, ReLateBound};\n-\n-    let llfty = type_of_rust_fn(ccx, has_env, inputs, output);\n-    let llfn = decl_cdecl_fn(ccx.llmod, name, llfty, output);\n-\n-    let uses_outptr = type_of::return_uses_outptr(ccx, output);\n-    let offset = if uses_outptr { 1 } else { 0 };\n-    let offset = if has_env { offset + 1 } else { offset };\n-\n-    for (i, &arg_ty) in inputs.iter().enumerate() {\n-        let llarg = unsafe { llvm::LLVMGetParam(llfn, (offset + i) as c_uint) };\n-        match ty::get(arg_ty).sty {\n-            // `~` pointer parameters never alias because ownership is transferred\n-            ty::ty_uniq(..) => {\n-                unsafe {\n-                    llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n-                    llvm::LLVMAddNonNullAttribute(llarg);\n-                }\n-            }\n-            // `&mut` pointer parameters never alias other parameters, or mutable global data\n-            ty::ty_rptr(_, mt) if mt.mutbl == ast::MutMutable => {\n-                unsafe {\n-                    llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n-                    llvm::LLVMAddNonNullAttribute(llarg);\n-                }\n-            }\n-            // When a reference in an argument has no named lifetime, it's impossible for that\n-            // reference to escape this function (returned or stored beyond the call by a closure).\n-            ty::ty_rptr(ReLateBound(_, BrAnon(_)), _) => {\n-                debug!(\"marking argument of {} as nocapture because of anonymous lifetime\", name);\n-                unsafe {\n-                    llvm::LLVMAddAttribute(llarg, lib::llvm::NoCaptureAttribute as c_uint);\n-                    llvm::LLVMAddNonNullAttribute(llarg);\n-                }\n-            }\n-            // `&` pointer parameters are never null\n-            ty::ty_rptr(..) => {\n-                unsafe {\n-                    llvm::LLVMAddNonNullAttribute(llarg);\n-                }\n-            }\n-            _ => {\n-                // For non-immediate arguments the callee gets its own copy of\n-                // the value on the stack, so there are no aliases\n-                if !type_is_immediate(ccx, arg_ty) {\n-                    unsafe {\n-                        llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n-                        llvm::LLVMAddAttribute(llarg, lib::llvm::NoCaptureAttribute as c_uint);\n-                    }\n-                }\n-            }\n-        }\n-    }\n+pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n+    let (inputs, output, has_env) = match ty::get(fn_ty).sty {\n+        ty::ty_bare_fn(ref f) => (f.sig.inputs.clone(), f.sig.output, false),\n+        ty::ty_closure(ref f) => (f.sig.inputs.clone(), f.sig.output, true),\n+        _ => fail!(\"expected closure or fn\")\n+    };\n \n-    // The out pointer will never alias with any other pointers, as the object only exists at a\n-    // language level after the call. It can also be tagged with SRet to indicate that it is\n-    // guaranteed to point to a usable block of memory for the type. We also know that it's\n-    // never null\n-    if uses_outptr {\n+    let llfty = type_of_rust_fn(ccx, has_env, inputs.as_slice(), output);\n+    let llfn = decl_fn(ccx.llmod, name, lib::llvm::CCallConv, llfty, output);\n+    let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n+    for &(idx, attr) in attrs.iter() {\n         unsafe {\n-            let outptr = llvm::LLVMGetParam(llfn, 0);\n-            llvm::LLVMAddAttribute(outptr, lib::llvm::StructRetAttribute as c_uint);\n-            llvm::LLVMAddAttribute(outptr, lib::llvm::NoAliasAttribute as c_uint);\n-            llvm::LLVMAddNonNullAttribute(outptr);\n-        }\n-    } else {\n-        match ty::get(output).sty {\n-            ty::ty_uniq(..) | ty::ty_rptr(..) => {\n-                unsafe {\n-                    llvm::LLVMAddNonNullReturnAttribute(llfn);\n-                }\n-            }\n-            _ => {}\n+            llvm::LLVMAddFunctionAttribute(llfn, idx as c_uint, attr);\n         }\n     }\n \n     llfn\n }\n \n-pub fn decl_internal_rust_fn(ccx: &CrateContext, has_env: bool,\n-                             inputs: &[ty::t], output: ty::t,\n-                             name: &str) -> ValueRef {\n-    let llfn = decl_rust_fn(ccx, has_env, inputs, output, name);\n+pub fn decl_internal_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n+    let llfn = decl_rust_fn(ccx, fn_ty, name);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     llfn\n }\n@@ -473,7 +404,11 @@ pub fn set_llvm_fn_attrs(attrs: &[ast::Attribute], llfn: ValueRef) {\n     }\n \n     if contains_name(attrs, \"cold\") {\n-        unsafe { llvm::LLVMAddColdAttribute(llfn) }\n+        unsafe {\n+            llvm::LLVMAddFunctionAttribute(llfn,\n+                                           lib::llvm::FunctionIndex as c_uint,\n+                                           lib::llvm::ColdAttribute as uint64_t)\n+        }\n     }\n }\n \n@@ -483,13 +418,13 @@ pub fn set_always_inline(f: ValueRef) {\n \n pub fn set_split_stack(f: ValueRef) {\n     \"split-stack\".with_c_str(|buf| {\n-        unsafe { llvm::LLVMAddFunctionAttrString(f, buf); }\n+        unsafe { llvm::LLVMAddFunctionAttrString(f, lib::llvm::FunctionIndex as c_uint, buf); }\n     })\n }\n \n pub fn unset_split_stack(f: ValueRef) {\n     \"split-stack\".with_c_str(|buf| {\n-        unsafe { llvm::LLVMRemoveFunctionAttrString(f, buf); }\n+        unsafe { llvm::LLVMRemoveFunctionAttrString(f, lib::llvm::FunctionIndex as c_uint, buf); }\n     })\n }\n \n@@ -505,6 +440,7 @@ pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: StrBuf) {\n \n pub fn get_res_dtor(ccx: &CrateContext,\n                     did: ast::DefId,\n+                    t: ty::t,\n                     parent_id: ast::DefId,\n                     substs: &ty::substs)\n                  -> ValueRef {\n@@ -530,13 +466,14 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         let class_ty = ty::subst(tcx, substs,\n                                  ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n-\n-        get_extern_fn(&mut *ccx.externs.borrow_mut(),\n-                      ccx.llmod,\n+        let dtor_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n+                                     [glue::get_drop_glue_type(ccx, t)], ty::mk_nil());\n+        get_extern_fn(ccx,\n+                      &mut *ccx.externs.borrow_mut(),\n                       name.as_slice(),\n                       lib::llvm::CCallConv,\n                       llty,\n-                      ty::mk_nil())\n+                      dtor_ty)\n     }\n }\n \n@@ -878,24 +815,16 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n             match fn_ty.abi.for_target(ccx.sess().targ_cfg.os,\n                                        ccx.sess().targ_cfg.arch) {\n                 Some(Rust) | Some(RustIntrinsic) => {\n-                    get_extern_rust_fn(ccx,\n-                                       fn_ty.sig.inputs.as_slice(),\n-                                       fn_ty.sig.output,\n-                                       name.as_slice(),\n-                                       did)\n+                    get_extern_rust_fn(ccx, t, name.as_slice(), did)\n                 }\n                 Some(..) | None => {\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t,\n                                                       name.as_slice(), None)\n                 }\n             }\n         }\n-        ty::ty_closure(ref f) => {\n-            get_extern_rust_fn(ccx,\n-                               f.sig.inputs.as_slice(),\n-                               f.sig.output,\n-                               name.as_slice(),\n-                               did)\n+        ty::ty_closure(_) => {\n+            get_extern_rust_fn(ccx, t, name.as_slice(), did)\n         }\n         _ => {\n             let llty = type_of(ccx, t);\n@@ -911,14 +840,16 @@ pub fn invoke<'a>(\n               bcx: &'a Block<'a>,\n               llfn: ValueRef,\n               llargs: Vec<ValueRef> ,\n-              attributes: &[(uint, lib::llvm::Attribute)],\n+              fn_ty: ty::t,\n               call_info: Option<NodeInfo>)\n               -> (ValueRef, &'a Block<'a>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n         return (C_null(Type::i8(bcx.ccx())), bcx);\n     }\n \n+    let attributes = get_fn_llvm_attributes(bcx.ccx(), fn_ty);\n+\n     match bcx.opt_node_id {\n         None => {\n             debug!(\"invoke at ???\");\n@@ -946,7 +877,7 @@ pub fn invoke<'a>(\n                               llargs.as_slice(),\n                               normal_bcx.llbb,\n                               landing_pad,\n-                              attributes);\n+                              attributes.as_slice());\n         return (llresult, normal_bcx);\n     } else {\n         debug!(\"calling {} at {}\", llfn, bcx.llbb);\n@@ -959,7 +890,7 @@ pub fn invoke<'a>(\n             None => debuginfo::clear_source_location(bcx.fcx)\n         };\n \n-        let llresult = Call(bcx, llfn, llargs.as_slice(), attributes);\n+        let llresult = Call(bcx, llfn, llargs.as_slice(), attributes.as_slice());\n         return (llresult, bcx);\n     }\n }\n@@ -1728,34 +1659,132 @@ fn register_fn(ccx: &CrateContext,\n                node_id: ast::NodeId,\n                node_type: ty::t)\n                -> ValueRef {\n-    let f = match ty::get(node_type).sty {\n+    match ty::get(node_type).sty {\n         ty::ty_bare_fn(ref f) => {\n             assert!(f.abi == Rust || f.abi == RustIntrinsic);\n-            f\n         }\n         _ => fail!(\"expected bare rust fn or an intrinsic\")\n     };\n \n-    let llfn = decl_rust_fn(ccx,\n-                            false,\n-                            f.sig.inputs.as_slice(),\n-                            f.sig.output,\n-                            sym.as_slice());\n+    let llfn = decl_rust_fn(ccx, node_type, sym.as_slice());\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n \n+pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t) -> Vec<(uint, u64)> {\n+    use middle::ty::{BrAnon, ReLateBound};\n+\n+    let (fn_sig, has_env) = match ty::get(fn_ty).sty {\n+        ty::ty_closure(ref f) => (f.sig.clone(), true),\n+        ty::ty_bare_fn(ref f) => (f.sig.clone(), false),\n+        _ => fail!(\"expected closure or function.\")\n+    };\n+\n+    // Since index 0 is the return value of the llvm func, we start\n+    // at either 1 or 2 depending on whether there's an env slot or not\n+    let mut first_arg_offset = if has_env { 2 } else { 1 };\n+    let mut attrs = Vec::new();\n+    let ret_ty = fn_sig.output;\n+\n+    // A function pointer is called without the declaration\n+    // available, so we have to apply any attributes with ABI\n+    // implications directly to the call instruction. Right now,\n+    // the only attribute we need to worry about is `sret`.\n+    if type_of::return_uses_outptr(ccx, ret_ty) {\n+        attrs.push((1, lib::llvm::StructRetAttribute as u64));\n+\n+        // The outptr can be noalias and nocapture because it's entirely\n+        // invisible to the program. We can also mark it as nonnull\n+        attrs.push((1, lib::llvm::NoAliasAttribute as u64));\n+        attrs.push((1, lib::llvm::NoCaptureAttribute as u64));\n+        attrs.push((1, lib::llvm::NonNullAttribute as u64));\n+\n+        // Add one more since there's an outptr\n+        first_arg_offset += 1;\n+    } else {\n+        // The `noalias` attribute on the return value is useful to a\n+        // function ptr caller.\n+        match ty::get(ret_ty).sty {\n+            // `~` pointer return values never alias because ownership\n+            // is transferred\n+            ty::ty_uniq(_) => {\n+                attrs.push((lib::llvm::ReturnIndex as uint, lib::llvm::NoAliasAttribute as u64));\n+            }\n+            _ => {}\n+        }\n+\n+        // We can also mark the return value as `nonnull` in certain cases\n+        match ty::get(ret_ty).sty {\n+            // These are not really pointers but pairs, (pointer, len)\n+            ty::ty_rptr(_, ty::mt { ty: it, .. }) |\n+            ty::ty_rptr(_, ty::mt { ty: it, .. }) if match ty::get(it).sty {\n+                ty::ty_str | ty::ty_vec(..) => true, _ => false\n+            } => {}\n+            ty::ty_uniq(_) | ty::ty_rptr(_, _) => {\n+                attrs.push((lib::llvm::ReturnIndex as uint, lib::llvm::NonNullAttribute as u64));\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    for (idx, &t) in fn_sig.inputs.iter().enumerate().map(|(i, v)| (i + first_arg_offset, v)) {\n+        match ty::get(t).sty {\n+            // `~` pointer parameters never alias because ownership is transferred\n+            ty::ty_uniq(_) => {\n+                attrs.push((idx, lib::llvm::NoAliasAttribute as u64));\n+                attrs.push((idx, lib::llvm::NonNullAttribute as u64));\n+            }\n+            // These are not really pointers but pairs, (pointer, len)\n+            ty::ty_rptr(_, ty::mt { ty: it, .. }) |\n+            ty::ty_rptr(_, ty::mt { ty: it, .. }) if match ty::get(it).sty {\n+                ty::ty_str | ty::ty_vec(..) => true, _ => false\n+            } => {}\n+            // `&mut` pointer parameters never alias other parameters, or mutable global data\n+            ty::ty_rptr(b, mt) if mt.mutbl == ast::MutMutable => {\n+                attrs.push((idx, lib::llvm::NoAliasAttribute as u64));\n+                attrs.push((idx, lib::llvm::NonNullAttribute as u64));\n+                match b {\n+                    ReLateBound(_, BrAnon(_)) => {\n+                        attrs.push((idx, lib::llvm::NoCaptureAttribute as u64));\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            // When a reference in an argument has no named lifetime, it's impossible for that\n+            // reference to escape this function (returned or stored beyond the call by a closure).\n+            ty::ty_rptr(ReLateBound(_, BrAnon(_)), _) => {\n+                attrs.push((idx, lib::llvm::NoCaptureAttribute as u64));\n+                attrs.push((idx, lib::llvm::NonNullAttribute as u64));\n+            }\n+            // & pointer parameters are never null\n+            ty::ty_rptr(_, _) => {\n+                attrs.push((idx, lib::llvm::NonNullAttribute as u64));\n+            }\n+            _ => {\n+                // For non-immediate arguments the callee gets its own copy of\n+                // the value on the stack, so there are no aliases. It's also\n+                // program-invisible so can't possibly capture\n+                if !type_is_immediate(ccx, t) {\n+                    attrs.push((idx, lib::llvm::NoAliasAttribute as u64));\n+                    attrs.push((idx, lib::llvm::NoCaptureAttribute as u64));\n+                }\n+            }\n+        }\n+    }\n+\n+    attrs\n+}\n+\n // only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n pub fn register_fn_llvmty(ccx: &CrateContext,\n                           sp: Span,\n                           sym: StrBuf,\n                           node_id: ast::NodeId,\n                           cc: lib::llvm::CallConv,\n-                          fn_ty: Type,\n-                          output: ty::t) -> ValueRef {\n+                          llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx.llmod, sym.as_slice(), cc, fn_ty, output);\n+    let llfn = decl_fn(ccx.llmod, sym.as_slice(), cc, llfty, ty::mk_nil());\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }"}, {"sha": "b0a73c4e6f7918a81f156278f7221ec2388d73e8", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "patch": "@@ -113,7 +113,7 @@ pub fn Invoke(cx: &Block,\n               args: &[ValueRef],\n               then: BasicBlockRef,\n               catch: BasicBlockRef,\n-              attributes: &[(uint, lib::llvm::Attribute)])\n+              attributes: &[(uint, u64)])\n               -> ValueRef {\n     if cx.unreachable.get() {\n         return C_null(Type::i8(cx.ccx()));\n@@ -679,13 +679,13 @@ pub fn InlineAsmCall(cx: &Block, asm: *c_char, cons: *c_char,\n }\n \n pub fn Call(cx: &Block, fn_: ValueRef, args: &[ValueRef],\n-            attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n+            attributes: &[(uint, u64)]) -> ValueRef {\n     if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n     B(cx).call(fn_, args, attributes)\n }\n \n pub fn CallWithConv(cx: &Block, fn_: ValueRef, args: &[ValueRef], conv: CallConv,\n-                    attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n+                    attributes: &[(uint, u64)]) -> ValueRef {\n     if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n     B(cx).call_with_conv(fn_, args, conv, attributes)\n }"}, {"sha": "278e586c6ac161b8074083d2b3356c70bf231935", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "patch": "@@ -156,7 +156,7 @@ impl<'a> Builder<'a> {\n                   args: &[ValueRef],\n                   then: BasicBlockRef,\n                   catch: BasicBlockRef,\n-                  attributes: &[(uint, lib::llvm::Attribute)])\n+                  attributes: &[(uint, u64)])\n                   -> ValueRef {\n         self.count_insn(\"invoke\");\n         unsafe {\n@@ -168,7 +168,7 @@ impl<'a> Builder<'a> {\n                                           catch,\n                                           noname());\n             for &(idx, attr) in attributes.iter() {\n-                llvm::LLVMAddInstrAttribute(v, idx as c_uint, attr as c_uint);\n+                llvm::LLVMAddCallSiteAttribute(v, idx as c_uint, attr);\n             }\n             v\n         }\n@@ -799,7 +799,7 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn call(&self, llfn: ValueRef, args: &[ValueRef],\n-                attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n+                attributes: &[(uint, u64)]) -> ValueRef {\n         self.count_insn(\"call\");\n \n         debug!(\"Call {} with args ({})\",\n@@ -813,14 +813,14 @@ impl<'a> Builder<'a> {\n             let v = llvm::LLVMBuildCall(self.llbuilder, llfn, args.as_ptr(),\n                                         args.len() as c_uint, noname());\n             for &(idx, attr) in attributes.iter() {\n-                llvm::LLVMAddInstrAttribute(v, idx as c_uint, attr as c_uint);\n+                llvm::LLVMAddCallSiteAttribute(v, idx as c_uint, attr);\n             }\n             v\n         }\n     }\n \n     pub fn call_with_conv(&self, llfn: ValueRef, args: &[ValueRef],\n-                          conv: CallConv, attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n+                          conv: CallConv, attributes: &[(uint, u64)]) -> ValueRef {\n         self.count_insn(\"callwithconv\");\n         let v = self.call(llfn, args, attributes);\n         lib::llvm::SetInstructionCallConv(v, conv);"}, {"sha": "90600ea2d3b2f869ee6419f7eafcbe06e62f3ea9", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 56, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "patch": "@@ -18,7 +18,7 @@\n \n use back::abi;\n use driver::session;\n-use lib::llvm::{ValueRef, NoAliasAttribute, StructRetAttribute, NoCaptureAttribute};\n+use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n use metadata::csearch;\n use middle::trans::base;\n@@ -614,13 +614,9 @@ pub fn trans_call_inner<'a>(\n             llargs.push(opt_llretslot.unwrap());\n         }\n \n-        // start at 1, because index 0 is the return value of the llvm func\n-        let mut first_arg_offset = 1;\n-\n         // Push the environment (or a trait object's self).\n         match (llenv, llself) {\n             (Some(llenv), None) => {\n-                first_arg_offset += 1;\n                 llargs.push(llenv)\n             },\n             (None, Some(llself)) => llargs.push(llself),\n@@ -634,61 +630,11 @@ pub fn trans_call_inner<'a>(\n \n         fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n \n-        // A function pointer is called without the declaration\n-        // available, so we have to apply any attributes with ABI\n-        // implications directly to the call instruction. Right now,\n-        // the only attribute we need to worry about is `sret`.\n-        let mut attrs = Vec::new();\n-        if type_of::return_uses_outptr(ccx, ret_ty) {\n-            attrs.push((1, StructRetAttribute));\n-            // The outptr can be noalias and nocapture because it's entirely\n-            // invisible to the program.\n-            attrs.push((1, NoAliasAttribute));\n-            attrs.push((1, NoCaptureAttribute));\n-            first_arg_offset += 1;\n-        }\n-\n-        // The `noalias` attribute on the return value is useful to a\n-        // function ptr caller.\n-        match ty::get(ret_ty).sty {\n-            // `~` pointer return values never alias because ownership\n-            // is transferred\n-            ty::ty_uniq(ty) => match ty::get(ty).sty {\n-                ty::ty_str => {}\n-                _ => attrs.push((0, NoAliasAttribute)),\n-            },\n-            _ => {}\n-        }\n-\n-        debug!(\"trans_callee_inner: first_arg_offset={}\", first_arg_offset);\n-\n-        for (idx, &t) in ty::ty_fn_args(callee_ty).iter().enumerate()\n-                                                  .map(|(i, v)| (i+first_arg_offset, v)) {\n-            use middle::ty::{BrAnon, ReLateBound};\n-            if !type_is_immediate(ccx, t) {\n-                // if it's not immediate, we have a program-invisible pointer,\n-                // which it can't possibly capture\n-                attrs.push((idx, NoCaptureAttribute));\n-                debug!(\"trans_callee_inner: argument {} nocapture because it's non-immediate\", idx);\n-                continue;\n-            }\n-\n-            let t_ = ty::get(t);\n-            match t_.sty {\n-                ty::ty_rptr(ReLateBound(_, BrAnon(_)), _) => {\n-                    debug!(\"trans_callee_inner: argument {} nocapture because \\\n-                           of anonymous lifetime\", idx);\n-                    attrs.push((idx, NoCaptureAttribute));\n-                },\n-                _ => { }\n-            }\n-        }\n-\n         // Invoke the actual rust fn and update bcx/llresult.\n         let (llret, b) = base::invoke(bcx,\n                                       llfn,\n                                       llargs,\n-                                      attrs.as_slice(),\n+                                      callee_ty,\n                                       call_info);\n         bcx = b;\n         llresult = llret;"}, {"sha": "5fe6c234579bb73513fa2e799fdd30e53073de57", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "patch": "@@ -340,21 +340,12 @@ pub fn trans_expr_fn<'a>(\n     };\n \n     let ccx = bcx.ccx();\n-    let fty = node_id_type(bcx, id);\n-    let f = match ty::get(fty).sty {\n-        ty::ty_closure(ref f) => f,\n-        _ => fail!(\"expected closure\")\n-    };\n-\n     let tcx = bcx.tcx();\n+    let fty = node_id_type(bcx, id);\n     let s = tcx.map.with_path(id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n-    let llfn = decl_internal_rust_fn(ccx,\n-                                     true,\n-                                     f.sig.inputs.as_slice(),\n-                                     f.sig.output,\n-                                     s.as_slice());\n+    let llfn = decl_internal_rust_fn(ccx, fty, s.as_slice());\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -414,17 +405,9 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         mangle_internal_name_by_path_and_seq(path, \"as_closure\")\n     });\n     let llfn = if is_local {\n-        decl_internal_rust_fn(ccx,\n-                              true,\n-                              f.sig.inputs.as_slice(),\n-                              f.sig.output,\n-                              name.as_slice())\n+        decl_internal_rust_fn(ccx, closure_ty, name.as_slice())\n     } else {\n-        decl_rust_fn(ccx,\n-                     true,\n-                     f.sig.inputs.as_slice(),\n-                     f.sig.output,\n-                     name.as_slice())\n+        decl_rust_fn(ccx, closure_ty, name.as_slice())\n     };\n \n     ccx.closure_bare_wrapper_cache.borrow_mut().insert(fn_ptr, llfn);"}, {"sha": "f723a4556b9a3982ad180fe051d3c61462de8818", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "patch": "@@ -227,12 +227,12 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: ty::t,\n     // Create the LLVM value for the C extern fn\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n \n-    let llfn = base::get_extern_fn(&mut *ccx.externs.borrow_mut(),\n-                                   ccx.llmod,\n+    let llfn = base::get_extern_fn(ccx,\n+                                   &mut *ccx.externs.borrow_mut(),\n                                    name,\n                                    cc,\n                                    llfn_ty,\n-                                   tys.fn_sig.output);\n+                                   fty);\n     add_argument_attributes(&tys, llfn);\n \n     llfn\n@@ -378,17 +378,21 @@ pub fn trans_native_call<'a>(\n     // A function pointer is called without the declaration available, so we have to apply\n     // any attributes with ABI implications directly to the call instruction. Right now, the\n     // only attribute we need to worry about is `sret`.\n-    let sret_attr = if fn_type.ret_ty.is_indirect() {\n-        Some((1, StructRetAttribute))\n-    } else {\n-        None\n+    let mut attrs = Vec::new();\n+    if fn_type.ret_ty.is_indirect() {\n+        attrs.push((1, lib::llvm::StructRetAttribute as u64));\n+\n+        // The outptr can be noalias and nocapture because it's entirely\n+        // invisible to the program. We can also mark it as nonnull\n+        attrs.push((1, lib::llvm::NoAliasAttribute as u64));\n+        attrs.push((1, lib::llvm::NoCaptureAttribute as u64));\n+        attrs.push((1, lib::llvm::NonNullAttribute as u64));\n     };\n-    let attrs = sret_attr.as_slice();\n     let llforeign_retval = CallWithConv(bcx,\n                                         llfn,\n                                         llargs_foreign.as_slice(),\n                                         cc,\n-                                        attrs);\n+                                        attrs.as_slice());\n \n     // If the function we just called does not use an outpointer,\n     // store the result into the rust outpointer. Cast the outpointer\n@@ -500,14 +504,14 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let tys = foreign_types_for_id(ccx, node_id);\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let t = ty::node_id_to_type(ccx.tcx(), node_id);\n-    let (cconv, output) = match ty::get(t).sty {\n+    let cconv = match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             let c = llvm_calling_convention(ccx, fn_ty.abi);\n-            (c.unwrap_or(lib::llvm::CCallConv), fn_ty.sig.output)\n+            c.unwrap_or(lib::llvm::CCallConv)\n         }\n         _ => fail!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n     };\n-    let llfn = base::register_fn_llvmty(ccx, sp, sym, node_id, cconv, llfn_ty, output);\n+    let llfn = base::register_fn_llvmty(ccx, sp, sym, node_id, cconv, llfn_ty);\n     add_argument_attributes(&tys, llfn);\n     debug!(\"register_rust_fn_with_foreign_abi(node_id={:?}, llfn_ty={}, llfn={})\",\n            node_id, ccx.tn.type_to_str(llfn_ty), ccx.tn.val_to_str(llfn));\n@@ -528,7 +532,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         let llrustfn = build_rust_fn(ccx, decl, body, attrs, id);\n \n         // Build up the foreign wrapper (`foo` above).\n-        return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys);\n+        return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys, id);\n     }\n \n     fn build_rust_fn(ccx: &CrateContext,\n@@ -548,10 +552,9 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n \n         // Compute the type that the function would have if it were just a\n         // normal Rust function. This will be the type of the wrappee fn.\n-        let f = match ty::get(t).sty {\n+        match ty::get(t).sty {\n             ty::ty_bare_fn(ref f) => {\n                 assert!(f.abi != Rust && f.abi != RustIntrinsic);\n-                f\n             }\n             _ => {\n                 ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n@@ -565,11 +568,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                ccx.tcx.map.path_to_str(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx,\n-                                               false,\n-                                               f.sig.inputs.as_slice(),\n-                                               f.sig.output,\n-                                               ps.as_slice());\n+        let llfn = base::decl_internal_rust_fn(ccx, t, ps.as_slice());\n         base::set_llvm_fn_attrs(attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, None, id, []);\n         llfn\n@@ -578,14 +577,18 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     unsafe fn build_wrap_fn(ccx: &CrateContext,\n                             llrustfn: ValueRef,\n                             llwrapfn: ValueRef,\n-                            tys: &ForeignTypes) {\n+                            tys: &ForeignTypes,\n+                            id: ast::NodeId) {\n         let _icx = push_ctxt(\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n         let tcx = ccx.tcx();\n \n-        debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={})\",\n+        let t = ty::node_id_to_type(tcx, id);\n+\n+        debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={}, t={})\",\n                ccx.tn.val_to_str(llrustfn),\n-               ccx.tn.val_to_str(llwrapfn));\n+               ccx.tn.val_to_str(llwrapfn),\n+               t.repr(ccx.tcx()));\n \n         // Avoid all the Rust generation stuff and just generate raw\n         // LLVM here.\n@@ -731,10 +734,15 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         }\n \n         // Perform the call itself\n-        debug!(\"calling llrustfn = {}\", ccx.tn.val_to_str(llrustfn));\n+        debug!(\"calling llrustfn = {}, t = {}\", ccx.tn.val_to_str(llrustfn), t.repr(ccx.tcx()));\n         let llrust_ret_val = llvm::LLVMBuildCall(builder, llrustfn, llrust_args.as_ptr(),\n                                                  llrust_args.len() as c_uint, noname());\n \n+        let attributes = base::get_fn_llvm_attributes(ccx, t);\n+        for &(idx, attr) in attributes.iter() {\n+            llvm::LLVMAddCallSiteAttribute(llrust_ret_val, idx as c_uint, attr);\n+        }\n+\n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {\n             Some(ty) => ty,"}, {"sha": "6d269756931f7a9c76d38736b894d0686b5c372f", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "patch": "@@ -88,7 +88,7 @@ pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     }\n }\n \n-fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n+pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n     let tcx = ccx.tcx();\n     if !ty::type_needs_drop(tcx, t) {\n         return ty::mk_i8();\n@@ -248,7 +248,7 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n     // Find and call the actual destructor\n-    let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did,\n+    let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, t,\n                                  class_did, substs);\n \n     // The second argument is the \"self\" argument for drop\n@@ -279,7 +279,9 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n                                   fld.mt.ty);\n     }\n \n-    let (_, bcx) = invoke(bcx, dtor_addr, args, [], None);\n+    let dtor_ty = ty::mk_ctor_fn(bcx.tcx(), ast::DUMMY_NODE_ID,\n+                                 [get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil());\n+    let (_, bcx) = invoke(bcx, dtor_addr, args, dtor_ty, None);\n \n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, field_scope)\n }\n@@ -459,10 +461,7 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n         t,\n         format!(\"glue_{}\", name).as_slice());\n     debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx(), t));\n-    let llfn = decl_cdecl_fn(ccx.llmod,\n-                             fn_nm.as_slice(),\n-                             llfnty,\n-                             ty::mk_nil());\n+    let llfn = decl_cdecl_fn(ccx.llmod, fn_nm.as_slice(), llfnty, ty::mk_nil());\n     note_unique_llvm_symbol(ccx, fn_nm);\n     return llfn;\n }"}, {"sha": "e0fd872fb06a7330a257db8ee175616713c05619", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "patch": "@@ -172,14 +172,6 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n     };\n \n-    let f = match ty::get(mono_ty).sty {\n-        ty::ty_bare_fn(ref f) => {\n-            assert!(f.abi == abi::Rust || f.abi == abi::RustIntrinsic);\n-            f\n-        }\n-        _ => fail!(\"expected bare rust fn or an intrinsic\")\n-    };\n-\n     ccx.stats.n_monos.set(ccx.stats.n_monos.get() + 1);\n \n     let depth;\n@@ -214,11 +206,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     // This shouldn't need to option dance.\n     let mut hash_id = Some(hash_id);\n     let mk_lldecl = || {\n-        let lldecl = decl_internal_rust_fn(ccx,\n-                                           false,\n-                                           f.sig.inputs.as_slice(),\n-                                           f.sig.output,\n-                                           s.as_slice());\n+        let lldecl = decl_internal_rust_fn(ccx, mono_ty, s.as_slice());\n         ccx.monomorphized.borrow_mut().insert(hash_id.take_unwrap(), lldecl);\n         lldecl\n     };"}, {"sha": "f5f3d4366f6e081f30d5d39f4334c4c72601a99b", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "patch": "@@ -291,10 +291,10 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                 let sym = mangle_internal_name_by_path_and_seq(\n                     ast_map::Values([].iter()).chain(None), \"get_disr\");\n \n+                let fn_ty = ty::mk_ctor_fn(&ccx.tcx, ast::DUMMY_NODE_ID,\n+                                           [opaqueptrty], ty::mk_u64());\n                 let llfdecl = decl_internal_rust_fn(ccx,\n-                                                    false,\n-                                                    [opaqueptrty],\n-                                                    ty::mk_u64(),\n+                                                    fn_ty,\n                                                     sym.as_slice());\n                 let arena = TypedArena::new();\n                 let fcx = new_fn_ctxt(ccx, llfdecl, -1, false,"}, {"sha": "2157aecf37613f18104337eca70833917825ef1f", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 31, "deletions": 40, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=3cae434f5c56b6f07d50da3d1ed85d5bf30c37d7", "patch": "@@ -12,6 +12,12 @@\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/ObjectFile.h\"\n \n+#if LLVM_VERSION_MINOR >= 5\n+#include \"llvm/IR/CallSite.h\"\n+#else\n+#include \"llvm/Support/CallSite.h\"\n+#endif\n+\n //===----------------------------------------------------------------------===\n //\n // This file defines alternate interfaces to core functions that are more\n@@ -83,58 +89,43 @@ extern \"C\" LLVMTypeRef LLVMMetadataTypeInContext(LLVMContextRef C) {\n   return wrap(Type::getMetadataTy(*unwrap(C)));\n }\n \n-extern \"C\" void LLVMAddFunctionAttrString(LLVMValueRef fn, const char *Name) {\n-  unwrap<Function>(fn)->addFnAttr(Name);\n+extern \"C\" void LLVMAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, uint64_t Val) {\n+  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  AttrBuilder B;\n+  B.addRawValue(Val);\n+  Call.setAttributes(\n+    Call.getAttributes().addAttributes(Call->getContext(), index,\n+                                       AttributeSet::get(Call->getContext(),\n+                                                         index, B)));\n }\n \n-extern \"C\" void LLVMRemoveFunctionAttrString(LLVMValueRef fn, const char *Name) {\n+extern \"C\" void LLVMAddFunctionAttribute(LLVMValueRef Fn, unsigned index, uint64_t Val) {\n+  Function *A = unwrap<Function>(Fn);\n+  AttrBuilder B;\n+  B.addRawValue(Val);\n+  A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n+}\n+\n+extern \"C\" void LLVMAddFunctionAttrString(LLVMValueRef Fn, unsigned index, const char *Name) {\n+  Function *F = unwrap<Function>(Fn);\n+  AttrBuilder B;\n+  B.addAttribute(Name);\n+  F->addAttributes(index, AttributeSet::get(F->getContext(), index, B));\n+}\n+\n+extern \"C\" void LLVMRemoveFunctionAttrString(LLVMValueRef fn, unsigned index, const char *Name) {\n   Function *f = unwrap<Function>(fn);\n   LLVMContext &C = f->getContext();\n   AttrBuilder B;\n   B.addAttribute(Name);\n-  AttributeSet to_remove = AttributeSet::get(C, AttributeSet::FunctionIndex, B);\n+  AttributeSet to_remove = AttributeSet::get(C, index, B);\n \n   AttributeSet attrs = f->getAttributes();\n   f->setAttributes(attrs.removeAttributes(f->getContext(),\n-                                          AttributeSet::FunctionIndex,\n+                                          index,\n                                           to_remove));\n }\n \n-extern \"C\" void LLVMAddReturnAttribute(LLVMValueRef Fn, LLVMAttribute PA) {\n-  Function *A = unwrap<Function>(Fn);\n-  AttrBuilder B(PA);\n-  A->addAttributes(AttributeSet::ReturnIndex,\n-                   AttributeSet::get(A->getContext(), AttributeSet::ReturnIndex,  B));\n-}\n-\n-extern \"C\" void LLVMRemoveReturnAttribute(LLVMValueRef Fn, LLVMAttribute PA) {\n-  Function *A = unwrap<Function>(Fn);\n-  AttrBuilder B(PA);\n-  A->removeAttributes(AttributeSet::ReturnIndex,\n-                      AttributeSet::get(A->getContext(), AttributeSet::ReturnIndex,  B));\n-}\n-\n-#if LLVM_VERSION_MINOR >= 5\n-extern \"C\" void LLVMAddColdAttribute(LLVMValueRef Fn) {\n-  Function *A = unwrap<Function>(Fn);\n-  A->addAttribute(AttributeSet::FunctionIndex, Attribute::Cold);\n-}\n-\n-extern \"C\" void LLVMAddNonNullAttribute(LLVMValueRef Arg) {\n-  Argument *A = unwrap<Argument>(Arg);\n-  A->addAttr(AttributeSet::get(A->getContext(), A->getArgNo() + 1, Attribute::NonNull));\n-}\n-\n-extern \"C\" void LLVMAddNonNullReturnAttribute(LLVMValueRef Fn) {\n-  Function *A = unwrap<Function>(Fn);\n-  A->addAttribute(AttributeSet::ReturnIndex, Attribute::NonNull);\n-}\n-#else\n-extern \"C\" void LLVMAddColdAttribute(LLVMValueRef Fn) {}\n-extern \"C\" void LLVMAddNonNullAttribute(LLVMValueRef Arg) {}\n-extern \"C\" void LLVMAddNonNullReturnAttribute(LLVMValueRef Fn) {}\n-#endif\n-\n extern \"C\" LLVMValueRef LLVMBuildAtomicLoad(LLVMBuilderRef B,\n                                             LLVMValueRef source,\n                                             const char* Name,"}]}