{"sha": "91b652695b97c5aef51fdc37c0111b0453ee584e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYjY1MjY5NWI5N2M1YWVmNTFmZGMzN2MwMTExYjA0NTNlZTU4NGU=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-05-21T23:57:21Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-05T19:01:40Z"}, "message": "moved TLS of sctable to ast_util, hid parameter in hygiene calls", "tree": {"sha": "5c06d1eb75ce662dc4bd971e3c22eb8e80020eb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c06d1eb75ce662dc4bd971e3c22eb8e80020eb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91b652695b97c5aef51fdc37c0111b0453ee584e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91b652695b97c5aef51fdc37c0111b0453ee584e", "html_url": "https://github.com/rust-lang/rust/commit/91b652695b97c5aef51fdc37c0111b0453ee584e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91b652695b97c5aef51fdc37c0111b0453ee584e/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe6baa9023cf599a7747e13c67d9adebc3161c59", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe6baa9023cf599a7747e13c67d9adebc3161c59", "html_url": "https://github.com/rust-lang/rust/commit/fe6baa9023cf599a7747e13c67d9adebc3161c59"}], "stats": {"total": 184, "additions": 103, "deletions": 81}, "files": [{"sha": "d99363d7ee5f7330e64261b1cbac3cf7c4883d48", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 75, "deletions": 37, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/91b652695b97c5aef51fdc37c0111b0453ee584e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b652695b97c5aef51fdc37c0111b0453ee584e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=91b652695b97c5aef51fdc37c0111b0453ee584e", "patch": "@@ -14,6 +14,8 @@ use ast::*;\n use ast;\n use ast_util;\n use codemap::{span, spanned};\n+use core::cast;\n+use core::local_data;\n use opt_vec;\n use parse::token;\n use visit;\n@@ -623,12 +625,18 @@ pub enum Privacy {\n pub fn new_ident(name: Name) -> ident { ident {name: name, ctxt: 0}}\n \n /// Extend a syntax context with a given mark\n-pub fn new_mark (m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n+pub fn new_mark(m:Mrk, tail:SyntaxContext) -> SyntaxContext {\n+    new_mark_internal(m,tail,get_sctable())\n+}\n+\n+// Extend a syntax context with a given mark and table\n+// FIXME #4536 : currently pub to allow testing\n+pub fn new_mark_internal(m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n     -> SyntaxContext {\n     let key = (tail,m);\n     // FIXME #5074 : can't use more natural style because we're missing\n     // flow-sensitivity. Results in two lookups on a hash table hit.\n-    // also applies to new_rename, below.\n+    // also applies to new_rename_internal, below.\n     // let try_lookup = table.mark_memo.find(&key);\n     match table.mark_memo.contains_key(&key) {\n         false => {\n@@ -646,7 +654,13 @@ pub fn new_mark (m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n }\n \n /// Extend a syntax context with a given rename\n-pub fn new_rename (id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n+pub fn new_rename(id:ident, to:Name, tail:SyntaxContext) -> SyntaxContext {\n+    new_rename_internal(id, to, tail, get_sctable())\n+}\n+\n+// Extend a syntax context with a given rename and sctable\n+// FIXME #4536 : currently pub to allow testing\n+pub fn new_rename_internal(id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n     -> SyntaxContext {\n     let key = (tail,id,to);\n     // FIXME #5074\n@@ -668,34 +682,58 @@ pub fn new_rename (id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n \n /// Make a fresh syntax context table with EmptyCtxt in slot zero\n /// and IllegalCtxt in slot one.\n-pub fn new_sctable() -> SCTable {\n+// FIXME #4536 : currently pub to allow testing\n+pub fn new_sctable_internal() -> SCTable {\n     SCTable {\n         table: ~[EmptyCtxt,IllegalCtxt],\n         mark_memo: HashMap::new(),\n         rename_memo: HashMap::new()\n     }\n }\n \n+// fetch the SCTable from TLS, create one if it doesn't yet exist.\n+pub fn get_sctable() -> @mut SCTable {\n+    unsafe {\n+        let sctable_key = (cast::transmute::<(uint, uint),\n+                           &fn(v: @@mut SCTable)>(\n+                               (-4 as uint, 0u)));\n+        match local_data::local_data_get(sctable_key) {\n+            None => {\n+                let new_table = @@mut new_sctable_internal();\n+                local_data::local_data_set(sctable_key,new_table);\n+                *new_table\n+            },\n+            Some(intr) => *intr\n+        }\n+    }\n+}\n+\n /// Add a value to the end of a vec, return its index\n fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n     vec.push(val);\n     vec.len() - 1\n }\n \n /// Resolve a syntax object to a name, per MTWT.\n-pub fn resolve (id : ident, table : &mut SCTable) -> Name {\n+pub fn resolve(id : ident) -> Name {\n+    resolve_internal(id, get_sctable())\n+}\n+\n+// Resolve a syntax object to a name, per MTWT.\n+// FIXME #4536 : currently pub to allow testing\n+pub fn resolve_internal(id : ident, table : &mut SCTable) -> Name {\n     match table.table[id.ctxt] {\n         EmptyCtxt => id.name,\n         // ignore marks here:\n-        Mark(_,subctxt) => resolve (ident{name:id.name, ctxt: subctxt},table),\n+        Mark(_,subctxt) => resolve_internal(ident{name:id.name, ctxt: subctxt},table),\n         // do the rename if necessary:\n         Rename(ident{name,ctxt},toname,subctxt) => {\n             // this could be cached or computed eagerly:\n-            let resolvedfrom = resolve(ident{name:name,ctxt:ctxt},table);\n-            let resolvedthis = resolve(ident{name:id.name,ctxt:subctxt},table);\n+            let resolvedfrom = resolve_internal(ident{name:name,ctxt:ctxt},table);\n+            let resolvedthis = resolve_internal(ident{name:id.name,ctxt:subctxt},table);\n             if ((resolvedthis == resolvedfrom)\n-                && (marksof (ctxt,resolvedthis,table)\n-                    == marksof (subctxt,resolvedthis,table))) {\n+                && (marksof(ctxt,resolvedthis,table)\n+                    == marksof(subctxt,resolvedthis,table))) {\n                 toname\n             } else {\n                 resolvedthis\n@@ -797,8 +835,8 @@ mod test {\n         -> SyntaxContext {\n         tscs.foldr(tail, |tsc : &TestSC,tail : SyntaxContext|\n                   {match *tsc {\n-                      M(mrk) => new_mark(mrk,tail,table),\n-                      R(ident,name) => new_rename(ident,name,tail,table)}})\n+                      M(mrk) => new_mark_internal(mrk,tail,table),\n+                      R(ident,name) => new_rename_internal(ident,name,tail,table)}})\n     }\n \n     // gather a SyntaxContext back into a vector of TestSCs\n@@ -823,7 +861,7 @@ mod test {\n     }\n \n     #[test] fn test_unfold_refold(){\n-        let mut t = new_sctable();\n+        let mut t = new_sctable_internal();\n \n         let test_sc = ~[M(3),R(id(101,0),14),M(9)];\n         assert_eq!(unfold_test_sc(copy test_sc,empty_ctxt,&mut t),4);\n@@ -837,11 +875,11 @@ mod test {\n     // in a vector. v[0] will be the outermost mark.\n     fn unfold_marks(mrks:~[Mrk],tail:SyntaxContext,table: &mut SCTable) -> SyntaxContext {\n         mrks.foldr(tail, |mrk:&Mrk,tail:SyntaxContext|\n-                   {new_mark(*mrk,tail,table)})\n+                   {new_mark_internal(*mrk,tail,table)})\n     }\n \n     #[test] fn unfold_marks_test() {\n-        let mut t = new_sctable();\n+        let mut t = new_sctable_internal();\n \n         assert_eq!(unfold_marks(~[3,7],empty_ctxt,&mut t),3);\n         assert_eq!(t.table[2],Mark(7,0));\n@@ -851,7 +889,7 @@ mod test {\n     #[test] fn test_marksof () {\n         let stopname = 242;\n         let name1 = 243;\n-        let mut t = new_sctable();\n+        let mut t = new_sctable_internal();\n         assert_eq!(marksof (empty_ctxt,stopname,&t),~[]);\n         // FIXME #5074: ANF'd to dodge nested calls\n         { let ans = unfold_marks(~[4,98],empty_ctxt,&mut t);\n@@ -865,13 +903,13 @@ mod test {\n         // rename where stop doesn't match:\n         { let chain = ~[M(9),\n                         R(id(name1,\n-                             new_mark (4, empty_ctxt,&mut t)),\n+                             new_mark_internal (4, empty_ctxt,&mut t)),\n                           100101102),\n                         M(14)];\n          let ans = unfold_test_sc(chain,empty_ctxt,&mut t);\n          assert_eq! (marksof (ans, stopname, &t), ~[9,14]);}\n         // rename where stop does match\n-        { let name1sc = new_mark(4, empty_ctxt, &mut t);\n+        { let name1sc = new_mark_internal(4, empty_ctxt, &mut t);\n          let chain = ~[M(9),\n                        R(id(name1, name1sc),\n                          stopname),\n@@ -883,59 +921,59 @@ mod test {\n \n     #[test] fn resolve_tests () {\n         let a = 40;\n-        let mut t = new_sctable();\n+        let mut t = new_sctable_internal();\n         // - ctxt is MT\n-        assert_eq!(resolve(id(a,empty_ctxt),&mut t),a);\n+        assert_eq!(resolve_internal(id(a,empty_ctxt),&mut t),a);\n         // - simple ignored marks\n         { let sc = unfold_marks(~[1,2,3],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t),a);}\n+         assert_eq!(resolve_internal(id(a,sc),&mut t),a);}\n         // - orthogonal rename where names don't match\n         { let sc = unfold_test_sc(~[R(id(50,empty_ctxt),51),M(12)],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t),a);}\n+         assert_eq!(resolve_internal(id(a,sc),&mut t),a);}\n         // - rename where names do match, but marks don't\n-        { let sc1 = new_mark(1,empty_ctxt,&mut t);\n+        { let sc1 = new_mark_internal(1,empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),\n                                    M(1),\n                                    M(2)],\n                                  empty_ctxt,&mut t);\n-        assert_eq!(resolve(id(a,sc),&mut t), a);}\n+        assert_eq!(resolve_internal(id(a,sc),&mut t), a);}\n         // - rename where names and marks match\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),M(1),M(2)],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t), 50); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t), 50); }\n         // - rename where names and marks match by literal sharing\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50)],sc1,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t), 50); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t), 50); }\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n         io::println(\"about to run bad test\");\n         { let sc = unfold_test_sc(~[R(id(a,empty_ctxt),50),\n                                     R(id(a,empty_ctxt),51)],\n                                   empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t), 51); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t), 51); }\n         // the simplest double-rename:\n-        { let a_to_a50 = new_rename(id(a,empty_ctxt),50,empty_ctxt,&mut t);\n-         let a50_to_a51 = new_rename(id(a,a_to_a50),51,a_to_a50,&mut t);\n-         assert_eq!(resolve(id(a,a50_to_a51),&mut t),51);\n+        { let a_to_a50 = new_rename_internal(id(a,empty_ctxt),50,empty_ctxt,&mut t);\n+         let a50_to_a51 = new_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n+         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t),51);\n          // mark on the outside doesn't stop rename:\n-         let sc = new_mark(9,a50_to_a51,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t),51);\n+         let sc = new_mark_internal(9,a50_to_a51,&mut t);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t),51);\n          // but mark on the inside does:\n          let a50_to_a51_b = unfold_test_sc(~[R(id(a,a_to_a50),51),\n                                               M(9)],\n                                            a_to_a50,\n                                            &mut t);\n-         assert_eq!(resolve(id(a,a50_to_a51_b),&mut t),50);}\n+         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t),50);}\n     }\n \n     #[test] fn hashing_tests () {\n-        let mut t = new_sctable();\n-        assert_eq!(new_mark(12,empty_ctxt,&mut t),2);\n-        assert_eq!(new_mark(13,empty_ctxt,&mut t),3);\n+        let mut t = new_sctable_internal();\n+        assert_eq!(new_mark_internal(12,empty_ctxt,&mut t),2);\n+        assert_eq!(new_mark_internal(13,empty_ctxt,&mut t),3);\n         // using the same one again should result in the same index:\n-        assert_eq!(new_mark(12,empty_ctxt,&mut t),2);\n+        assert_eq!(new_mark_internal(12,empty_ctxt,&mut t),2);\n         // I'm assuming that the rename table will behave the same....\n     }\n "}, {"sha": "96a0461de1eb24781ffaa1c96f45ad3003f15913", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 28, "deletions": 44, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/91b652695b97c5aef51fdc37c0111b0453ee584e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b652695b97c5aef51fdc37c0111b0453ee584e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=91b652695b97c5aef51fdc37c0111b0453ee584e", "patch": "@@ -15,17 +15,15 @@ use ast::{crate, decl_local, expr_, expr_mac, mac_invoc_tt};\n use ast::{item_mac, local_, stmt_, stmt_decl, stmt_mac, stmt_expr, stmt_semi};\n use ast::{SCTable, illegal_ctxt};\n use ast;\n-use ast_util::{new_rename, new_mark, resolve, new_sctable};\n+use ast_util::{new_rename, new_mark, resolve, get_sctable};\n use attr;\n use codemap;\n use codemap::{span, CallInfo, ExpandedFrom, NameAndSpan, spanned};\n-use core::cast;\n-use core::local_data;\n use ext::base::*;\n use fold::*;\n use parse;\n use parse::{parse_item_from_source_str};\n-use parse::token::{ident_to_str, intern};\n+use parse::token::{ident_to_str, intern, fresh_name};\n use visit;\n use visit::{Visitor,mk_vt};\n \n@@ -369,7 +367,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n // return a visitor that extracts the pat_ident paths\n // from a given pattern and puts them in a mutable\n-// array (passed in to the traversal\n+// array (passed in to the traversal)\n pub fn new_name_finder() -> @Visitor<@mut ~[ast::ident]> {\n     let default_visitor = visit::default_visitor();\n     @Visitor{\n@@ -395,8 +393,6 @@ pub fn new_name_finder() -> @Visitor<@mut ~[ast::ident]> {\n     }\n }\n \n-\n-\n pub fn expand_block(extsbox: @mut SyntaxEnv,\n                     cx: @ExtCtxt,\n                     blk: &blk_,\n@@ -422,14 +418,13 @@ fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n // given a mutable list of renames, return a tree-folder that applies those\n // renames.\n fn renames_to_fold(renames : @mut ~[(ast::ident,ast::Name)]) -> @ast_fold {\n-    let table = local_sctable_get();\n     let afp = default_ast_fold();\n     let f_pre = @AstFoldFns {\n         fold_ident: |id,_| {\n             // the individual elements are memoized... it would\n             // also be possible to memoize on the whole list at once.\n             let new_ctxt = renames.foldl(id.ctxt,|ctxt,&(from,to)| {\n-                new_rename(from,to,*ctxt,table)\n+                new_rename(from,to,*ctxt)\n             });\n             ast::ident{name:id.name,ctxt:new_ctxt}\n         },\n@@ -446,22 +441,6 @@ fn apply_pending_renames(folder : @ast_fold, stmt : ast::stmt) -> @ast::stmt {\n     }\n }\n \n-// fetch the SCTable from TLS, create one if it doesn't yet exist.\n-fn local_sctable_get() -> @mut SCTable {\n-    unsafe {\n-        let sctable_key = (cast::transmute::<(uint, uint),\n-                           &fn(v: @@mut SCTable)>(\n-                               (-4 as uint, 0u)));\n-        match local_data::local_data_get(sctable_key) {\n-            None => {\n-                let new_table = @@mut new_sctable();\n-                local_data::local_data_set(sctable_key,new_table);\n-                *new_table\n-            },\n-            Some(intr) => *intr\n-        }\n-    }\n-}\n \n \n pub fn new_span(cx: @ExtCtxt, sp: span) -> span {\n@@ -732,35 +711,33 @@ pub fn fun_to_ident_folder(f: @fn(ast::ident)->ast::ident) -> @ast_fold{\n \n // update the ctxts in a path to get a rename node\n pub fn new_ident_renamer(from: ast::ident,\n-                      to: ast::Name,\n-                      table: @mut SCTable) ->\n+                      to: ast::Name) ->\n     @fn(ast::ident)->ast::ident {\n     |id : ast::ident|\n     ast::ident{\n         name: id.name,\n-        ctxt: new_rename(from,to,id.ctxt,table)\n+        ctxt: new_rename(from,to,id.ctxt)\n     }\n }\n \n \n // update the ctxts in a path to get a mark node\n-pub fn new_ident_marker(mark: uint,\n-                        table: @mut SCTable) ->\n+pub fn new_ident_marker(mark: uint) ->\n     @fn(ast::ident)->ast::ident {\n     |id : ast::ident|\n     ast::ident{\n         name: id.name,\n-        ctxt: new_mark(mark,id.ctxt,table)\n+        ctxt: new_mark(mark,id.ctxt)\n     }\n }\n \n // perform resolution (in the MTWT sense) on all of the\n // idents in the tree. This is the final step in expansion.\n-pub fn new_ident_resolver(table: @mut SCTable) ->\n+pub fn new_ident_resolver() ->\n     @fn(ast::ident)->ast::ident {\n     |id : ast::ident|\n     ast::ident {\n-        name : resolve(id,table),\n+        name : resolve(id),\n         ctxt : illegal_ctxt\n     }\n }\n@@ -771,16 +748,18 @@ mod test {\n     use super::*;\n     use ast;\n     use ast::{attribute_, attr_outer, meta_word, empty_ctxt};\n-    use ast_util::{new_sctable};\n+    use ast_util::{get_sctable};\n     use codemap;\n     use codemap::spanned;\n     use parse;\n-    use parse::token::{gensym};\n-    use core::io;\n-    use core::option::{None, Some};\n+    use parse::token::{gensym, intern, get_ident_interner};\n+    use print::pprust;\n     use util::parser_testing::{string_to_item, string_to_pat, strs_to_idents};\n     use visit::{mk_vt,Visitor};\n \n+    use core::io;\n+    use core::option::{None, Some};\n+\n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n         let src = ~\"fn main() { fail!(\\\"something appropriately gloomy\\\");}\";\n@@ -883,22 +862,27 @@ mod test {\n \n     #[test]\n     fn renaming () {\n-        let maybe_item_ast = string_to_item(@~\"fn a() -> int { let b = 13; b} \");\n+        let maybe_item_ast = string_to_item(@~\"fn a() -> int { let b = 13; b }\");\n         let item_ast = match maybe_item_ast {\n             Some(x) => x,\n             None => fail!(\"test case fail\")\n         };\n-        let table = @mut new_sctable();\n-        let a_name = 100; // enforced by testing_interner\n-        let a2_name = gensym(\"a2\");\n+        let a_name = intern(\"a\");\n+        let a2_name = intern(\"a2\");\n         let renamer = new_ident_renamer(ast::ident{name:a_name,ctxt:empty_ctxt},\n-                                        a2_name,table);\n+                                        a2_name);\n         let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).get();\n-        let resolver = new_ident_resolver(table);\n+        let resolver = new_ident_resolver();\n         let resolved_ast = fun_to_ident_folder(resolver).fold_item(renamed_ast).get();\n-        io::print(fmt!(\"ast: %?\\n\",resolved_ast))\n+        let resolved_as_str = pprust::item_to_str(resolved_ast,\n+                                                  get_ident_interner());\n+        assert_eq!(resolved_as_str,~\"fn a2() -> int { let b = 13; b }\");\n+\n+\n     }\n \n+    // sigh... it looks like I have two different renaming mechanisms, now...\n+\n     #[test]\n     fn pat_idents(){\n         let pat = string_to_pat(@~\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");"}]}