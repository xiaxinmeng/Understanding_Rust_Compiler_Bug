{"sha": "c9eb9ee6121b10927de80d32e448691388545b3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZWI5ZWU2MTIxYjEwOTI3ZGU4MGQzMmU0NDg2OTEzODg1NDViM2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-24T03:55:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-24T12:19:44Z"}, "message": "rewrite purity check to search through scope chain", "tree": {"sha": "ac9961905de846366549694ea357317d3747cedc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac9961905de846366549694ea357317d3747cedc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9eb9ee6121b10927de80d32e448691388545b3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9eb9ee6121b10927de80d32e448691388545b3e", "html_url": "https://github.com/rust-lang/rust/commit/c9eb9ee6121b10927de80d32e448691388545b3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9eb9ee6121b10927de80d32e448691388545b3e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ca6a3b80be1c7a5638156638a8a11e514bc3ef3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ca6a3b80be1c7a5638156638a8a11e514bc3ef3", "html_url": "https://github.com/rust-lang/rust/commit/6ca6a3b80be1c7a5638156638a8a11e514bc3ef3"}], "stats": {"total": 130, "additions": 67, "deletions": 63}, "files": [{"sha": "85ee5b1c9573e14b0278a18e4a7fc578cd2761e2", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 67, "deletions": 63, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c9eb9ee6121b10927de80d32e448691388545b3e/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9eb9ee6121b10927de80d32e448691388545b3e/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=c9eb9ee6121b10927de80d32e448691388545b3e", "patch": "@@ -505,14 +505,11 @@ enum check_loan_ctxt = @{\n     // we are in a ctor, we track the self id\n     mut in_ctor: bool,\n \n-    mut is_pure: purity_cause\n+    mut declared_purity: ast::purity\n };\n \n // if we are enforcing purity, why are we doing so?\n enum purity_cause {\n-    // not enforcing purity:\n-    pc_impure,\n-\n     // enforcing purity because fn was declared pure:\n     pc_declaration,\n \n@@ -529,7 +526,7 @@ fn check_loans(bccx: borrowck_ctxt,\n                                  req_maps: req_maps,\n                                  reported: int_hash(),\n                                  mut in_ctor: false,\n-                                 mut is_pure: pc_impure});\n+                                 mut declared_purity: ast::impure_fn});\n     let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n                             visit_block: check_loans_in_block,\n                             visit_fn: check_loans_in_fn\n@@ -556,6 +553,37 @@ impl methods for assignment_type {\n impl methods for check_loan_ctxt {\n     fn tcx() -> ty::ctxt { self.bccx.tcx }\n \n+    fn purity(scope_id: ast::node_id) -> option<purity_cause> {\n+        let default_purity = alt self.declared_purity {\n+          // an unsafe declaration overrides all\n+          ast::unsafe_fn { ret none; }\n+\n+          // otherwise, remember what was declared as the\n+          // default, but we must scan for requirements\n+          // imposed by the borrow check\n+          ast::pure_fn { some(pc_declaration) }\n+          ast::crust_fn | ast::impure_fn { none }\n+        };\n+\n+        // scan to see if this scope or any enclosing scope requires\n+        // purity.  if so, that overrides the declaration.\n+\n+        let mut scope_id = scope_id;\n+        let region_map = self.tcx().region_map;\n+        let pure_map = self.req_maps.pure_map;\n+        loop {\n+            alt pure_map.find(scope_id) {\n+              none {}\n+              some(e) {ret some(pc_cmt(e));}\n+            }\n+\n+            alt region_map.find(scope_id) {\n+              none { ret default_purity; }\n+              some(next_scope_id) { scope_id = next_scope_id; }\n+            }\n+        }\n+    }\n+\n     fn walk_loans(scope_id: ast::node_id,\n                   f: fn(loan) -> bool) {\n         let mut scope_id = scope_id;\n@@ -590,7 +618,7 @@ impl methods for check_loan_ctxt {\n \n     // when we are in a pure context, we check each call to ensure\n     // that the function which is invoked is itself pure.\n-    fn check_pure(expr: @ast::expr) {\n+    fn check_pure(pc: purity_cause, expr: @ast::expr) {\n         let tcx = self.tcx();\n         alt ty::get(tcx.ty(expr)).struct {\n           ty::ty_fn(_) {\n@@ -645,7 +673,7 @@ impl methods for check_loan_ctxt {\n               }\n               ast::impure_fn | ast::unsafe_fn {\n                 self.report_purity_error(\n-                    expr.span,\n+                    pc, expr.span,\n                     \"access to non-pure functions\");\n               }\n             }\n@@ -654,21 +682,6 @@ impl methods for check_loan_ctxt {\n         }\n     }\n \n-    fn check_for_purity_requirement(scope_id: ast::node_id) {\n-        // if we are not already enforcing purity, check whether the\n-        // gather pass thought we needed to enforce purity for this\n-        // scope.\n-        alt self.is_pure {\n-          pc_declaration | pc_cmt(*) { }\n-          pc_impure {\n-            alt self.req_maps.pure_map.find(scope_id) {\n-              none {}\n-              some(e) {self.is_pure = pc_cmt(e)}\n-            }\n-          }\n-        }\n-    }\n-\n     fn check_for_conflicting_loans(scope_id: ast::node_id) {\n         let new_loanss = alt self.req_maps.req_loan_map.find(scope_id) {\n             none { ret; }\n@@ -739,10 +752,14 @@ impl methods for check_loan_ctxt {\n         // if this is a pure function, only loan-able state can be\n         // assigned, because it is uniquely tied to this function and\n         // is not visible from the outside\n-        if self.is_pure != pc_impure && cmt.lp.is_none() {\n-            self.report_purity_error(\n-                ex.span,\n-                at.ing_form(self.bccx.cmt_to_str(cmt)));\n+        alt self.purity(ex.id) {\n+          none {}\n+          some(pc) {\n+            if cmt.lp.is_none() {\n+                self.report_purity_error(\n+                    pc, ex.span, at.ing_form(self.bccx.cmt_to_str(cmt)));\n+            }\n+          }\n         }\n \n         // check for a conflicting loan as well, except in the case of\n@@ -775,11 +792,8 @@ impl methods for check_loan_ctxt {\n         self.bccx.add_to_mutbl_map(cmt);\n     }\n \n-    fn report_purity_error(sp: span, msg: str) {\n-        alt copy self.is_pure {\n-          pc_impure {\n-            self.tcx().sess.bug(\"report_purity_error() called when impure\");\n-          }\n+    fn report_purity_error(pc: purity_cause, sp: span, msg: str) {\n+        alt pc {\n           pc_declaration {\n             self.tcx().sess.span_err(\n                 sp,\n@@ -855,7 +869,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      visitor: visit::vt<check_loan_ctxt>) {\n \n     save_and_restore(self.in_ctor) {||\n-        save_and_restore(self.is_pure) {||\n+        save_and_restore(self.declared_purity) {||\n             // In principle, we could consider fk_anon(*) or\n             // fk_fn_block(*) to be in a ctor, I suppose, but the\n             // purpose of the in_ctor flag is to allow modifications\n@@ -870,10 +884,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n             // NDM this doesn't seem algother right, what about fn  items\n             // nested in pure fns? etc?\n \n-            alt decl.purity {\n-              ast::pure_fn { self.is_pure = pc_declaration; }\n-              _ { }\n-            }\n+            self.declared_purity = decl.purity;\n \n             visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n         }\n@@ -884,16 +895,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n                        &&self: check_loan_ctxt,\n                        vt: visit::vt<check_loan_ctxt>) {\n     self.check_for_conflicting_loans(expr.id);\n-    save_and_restore(self.is_pure) {||\n-        self.check_for_purity_requirement(expr.id);\n-        check_loans_in_expr_1(expr, self, vt);\n-    }\n-}\n \n-// avoid rightward drift by breaking this out into its own fn\n-fn check_loans_in_expr_1(expr: @ast::expr,\n-                         &&self: check_loan_ctxt,\n-                         vt: visit::vt<check_loan_ctxt>) {\n     alt expr.node {\n       ast::expr_swap(l, r) {\n         self.check_assignment(at_swap, l);\n@@ -936,9 +938,12 @@ fn check_loans_in_expr_1(expr: @ast::expr,\n         }\n       }\n       ast::expr_call(f, args, _) {\n-        if self.is_pure != pc_impure {\n-            self.check_pure(f);\n-            for args.each { |arg| self.check_pure(arg) }\n+        alt self.purity(expr.id) {\n+          none {}\n+          some(pc) {\n+            self.check_pure(pc, f);\n+            for args.each { |arg| self.check_pure(pc, arg) }\n+          }\n         }\n         let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n         vec::iter2(args, arg_tys) { |arg, arg_ty|\n@@ -963,28 +968,17 @@ fn check_loans_in_expr_1(expr: @ast::expr,\n fn check_loans_in_block(blk: ast::blk,\n                         &&self: check_loan_ctxt,\n                         vt: visit::vt<check_loan_ctxt>) {\n-    save_and_restore(self.is_pure) {||\n+    save_and_restore(self.declared_purity) {||\n         self.check_for_conflicting_loans(blk.node.id);\n-        self.check_for_purity_requirement(blk.node.id);\n \n         alt blk.node.rules {\n           ast::default_blk {\n           }\n           ast::unchecked_blk {\n-            alt self.is_pure {\n-              pc_impure | pc_declaration {\n-                self.is_pure = pc_impure;\n-              }\n-              pc_cmt(_) {\n-                // unchecked does not override purity requirements due\n-                // to borrows; unchecked didn't seem strong enough to\n-                // justify potential memory unsafety to me\n-              }\n-            }\n+            self.declared_purity = ast::impure_fn;\n           }\n           ast::unsafe_blk {\n-            // unsafe blocks override everything\n-            self.is_pure = pc_impure;\n+            self.declared_purity = ast::unsafe_fn;\n           }\n         }\n \n@@ -1472,6 +1466,15 @@ impl categorize_methods for borrowck_ctxt {\n              ty_to_str(self.tcx, cmt.ty)]\n     }\n \n+    fn pk_to_sigil(pk: ptr_kind) -> str {\n+        alt pk {\n+          uniq_ptr {\"~\"}\n+          gc_ptr {\"@\"}\n+          region_ptr {\"&\"}\n+          unsafe_ptr {\"*\"}\n+        }\n+    }\n+\n     fn cmt_to_str(cmt: cmt) -> str {\n         let mut_str = self.mut_to_str(cmt.mutbl);\n         alt cmt.cat {\n@@ -1482,7 +1485,8 @@ impl categorize_methods for borrowck_ctxt {\n           cat_rvalue { \"non-lvalue\" }\n           cat_local(_) { mut_str + \" local variable\" }\n           cat_arg(_) { mut_str + \" argument\" }\n-          cat_deref(*) { \"dereference of \" + mut_str + \" pointer\" }\n+          cat_deref(_, _, pk) { #fmt[\"dereference of %s %s pointer\",\n+                                     mut_str, self.pk_to_sigil(pk)] }\n           cat_stack_upvar(_) { mut_str + \" upvar\" }\n           cat_comp(_, comp_field(_)) { mut_str + \" field\" }\n           cat_comp(_, comp_tuple) { \"tuple content\" }"}]}