{"sha": "9061ffba8ceb6a3a927aff15b570f9bd4247862a", "node_id": "C_kwDOAAsO6NoAKDkwNjFmZmJhOGNlYjZhM2E5MjdhZmYxNWI1NzBmOWJkNDI0Nzg2MmE", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-11-23T18:55:24Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-11-23T20:25:27Z"}, "message": "use no type in ProjectionElem::Field for PlaceBuilder::UpVar", "tree": {"sha": "892569ad5055741ec648fa020fb7277d62f58221", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/892569ad5055741ec648fa020fb7277d62f58221"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9061ffba8ceb6a3a927aff15b570f9bd4247862a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9061ffba8ceb6a3a927aff15b570f9bd4247862a", "html_url": "https://github.com/rust-lang/rust/commit/9061ffba8ceb6a3a927aff15b570f9bd4247862a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9061ffba8ceb6a3a927aff15b570f9bd4247862a/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c39de61d2a8fd1f3226e623d67e1e5bac593dac6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c39de61d2a8fd1f3226e623d67e1e5bac593dac6", "html_url": "https://github.com/rust-lang/rust/commit/c39de61d2a8fd1f3226e623d67e1e5bac593dac6"}], "stats": {"total": 157, "additions": 105, "deletions": 52}, "files": [{"sha": "a646860ed45f16e3875216594a38f62dfb6eb3cf", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=9061ffba8ceb6a3a927aff15b570f9bd4247862a", "patch": "@@ -1517,7 +1517,7 @@ impl<'tcx> StatementKind<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Places\n \n-impl<V, T> ProjectionElem<V, T> {\n+impl<V, T, U> ProjectionElem<V, T, U> {\n     /// Returns `true` if the target of this projection may refer to a different region of memory\n     /// than the base.\n     fn is_indirect(&self) -> bool {\n@@ -1546,7 +1546,7 @@ impl<V, T> ProjectionElem<V, T> {\n \n /// Alias for projections as they appear in `UserTypeProjection`, where we\n /// need neither the `V` parameter for `Index` nor the `T` for `Field`.\n-pub type ProjectionKind = ProjectionElem<(), ()>;\n+pub type ProjectionKind = ProjectionElem<(), (), ()>;\n \n rustc_index::newtype_index! {\n     /// A [newtype'd][wrapper] index type in the MIR [control-flow graph][CFG]"}, {"sha": "004dd004c723d71a67943a8438c537abdf34c38f", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=9061ffba8ceb6a3a927aff15b570f9bd4247862a", "patch": "@@ -877,9 +877,9 @@ pub struct Place<'tcx> {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n-pub enum ProjectionElem<V, T> {\n+pub enum ProjectionElem<V, T1, T2> {\n     Deref,\n-    Field(Field, T),\n+    Field(Field, T1),\n     /// Index into a slice/array.\n     ///\n     /// Note that this does not also dereference, and so it does not exactly correspond to slice\n@@ -935,12 +935,36 @@ pub enum ProjectionElem<V, T> {\n \n     /// Like an explicit cast from an opaque type to a concrete type, but without\n     /// requiring an intermediate variable.\n-    OpaqueCast(T),\n+    OpaqueCast(T2),\n }\n \n /// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n-pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n+pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>, Ty<'tcx>>;\n+\n+/// Alias for projections that appear in `PlaceBuilder::UpVar`, for which\n+/// we cannot provide any field types.\n+pub type UpvarProjectionElem<'tcx> = ProjectionElem<Local, (), Ty<'tcx>>;\n+\n+impl<'tcx> From<PlaceElem<'tcx>> for UpvarProjectionElem<'tcx> {\n+    fn from(elem: PlaceElem<'tcx>) -> Self {\n+        match elem {\n+            ProjectionElem::Deref => ProjectionElem::Deref,\n+            ProjectionElem::Field(field, _) => ProjectionElem::Field(field, ()),\n+            ProjectionElem::Index(v) => ProjectionElem::Index(v),\n+            ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end }\n+            }\n+            ProjectionElem::Subslice { from, to, from_end } => {\n+                ProjectionElem::Subslice { from, to, from_end }\n+            }\n+            ProjectionElem::Downcast(opt_sym, variant_idx) => {\n+                ProjectionElem::Downcast(opt_sym, variant_idx)\n+            }\n+            ProjectionElem::OpaqueCast(ty) => ProjectionElem::OpaqueCast(ty),\n+        }\n+    }\n+}\n \n ///////////////////////////////////////////////////////////////////////////\n // Operands"}, {"sha": "e3ca1f41d7ea1b0b05e833217183dc4ff7c562c6", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=9061ffba8ceb6a3a927aff15b570f9bd4247862a", "patch": "@@ -28,8 +28,8 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `place_ty.field_ty(tcx, f)` computes the type at a given field\n     /// of a record or enum-variant. (Most clients of `PlaceTy` can\n     /// instead just extract the relevant type directly from their\n-    /// `PlaceElem`, but some instances of `ProjectionElem<V, T>` do\n-    /// not carry a `Ty` for `T`.)\n+    /// `PlaceElem`, but some instances of `ProjectionElem<V, T1, T2>` do\n+    /// not carry a `Ty` for `T1` or `T2`.)\n     ///\n     /// Note that the resulting type has not been normalized.\n     pub fn field_ty(self, tcx: TyCtxt<'tcx>, f: Field) -> Ty<'tcx> {\n@@ -64,17 +64,18 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `Ty` or downcast variant corresponding to that projection.\n     /// The `handle_field` callback must map a `Field` to its `Ty`,\n     /// (which should be trivial when `T` = `Ty`).\n-    pub fn projection_ty_core<V, T>(\n+    pub fn projection_ty_core<V, T1, T2>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        elem: &ProjectionElem<V, T>,\n-        mut handle_field: impl FnMut(&Self, Field, T) -> Ty<'tcx>,\n-        mut handle_opaque_cast: impl FnMut(&Self, T) -> Ty<'tcx>,\n+        elem: &ProjectionElem<V, T1, T2>,\n+        mut handle_field: impl FnMut(&Self, Field, T1) -> Ty<'tcx>,\n+        mut handle_opaque_cast: impl FnMut(&Self, T2) -> Ty<'tcx>,\n     ) -> PlaceTy<'tcx>\n     where\n         V: ::std::fmt::Debug,\n-        T: ::std::fmt::Debug + Copy,\n+        T1: ::std::fmt::Debug + Copy,\n+        T2: ::std::fmt::Debug + Copy,\n     {\n         if self.variant_index.is_some() && !matches!(elem, ProjectionElem::Field(..)) {\n             bug!(\"cannot use non field projection on downcasted place\")"}, {"sha": "bd27b6c2bebc5bf2a50f02c31f1999622c225c2a", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 60, "deletions": 32, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=9061ffba8ceb6a3a927aff15b570f9bd4247862a", "patch": "@@ -19,6 +19,7 @@ use rustc_target::abi::VariantIdx;\n use rustc_index::vec::Idx;\n \n use std::assert_matches::assert_matches;\n+use std::convert::From;\n use std::iter;\n \n /// `PlaceBuilder` is used to create places during MIR construction. It allows you to \"build up\" a\n@@ -66,7 +67,7 @@ pub(in crate::build) enum PlaceBuilder<'tcx> {\n     ///\n     /// Note: in contrast to `PlaceBuilder::Local` we have not yet determined all `Field` types\n     /// and will only do so once converting to `PlaceBuilder::Local`.\n-    UpVar(UpVar, Vec<PlaceElem<'tcx>>),\n+    UpVar(UpVar, Vec<UpvarProjectionElem<'tcx>>),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -82,7 +83,7 @@ pub(crate) struct UpVar {\n /// part of a path that is captured by a closure. We stop applying projections once we see the first\n /// projection that isn't captured by a closure.\n fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n-    mir_projections: &[PlaceElem<'tcx>],\n+    mir_projections: &[UpvarProjectionElem<'tcx>],\n ) -> Vec<HirProjectionKind> {\n     let mut hir_projections = Vec::new();\n     let mut variant = None;\n@@ -156,7 +157,7 @@ fn is_ancestor_or_same_capture(\n fn find_capture_matching_projections<'a, 'tcx>(\n     upvars: &'a CaptureMap<'tcx>,\n     var_hir_id: LocalVarId,\n-    projections: &[PlaceElem<'tcx>],\n+    projections: &[UpvarProjectionElem<'tcx>],\n ) -> Option<(usize, &'a Capture<'tcx>)> {\n     let hir_projections = convert_to_hir_projections_and_truncate_for_capture(projections);\n \n@@ -212,8 +213,7 @@ fn to_upvars_resolved_place_builder<'tcx>(\n         capture.captured_place.place.base_ty,\n         projection,\n         &capture.captured_place.place.projections,\n-    )\n-    .collect::<Vec<_>>();\n+    );\n \n     let upvar_resolved_place_builder = PlaceBuilder::construct_local_place_builder(\n         cx,\n@@ -222,6 +222,37 @@ fn to_upvars_resolved_place_builder<'tcx>(\n         upvar_projection,\n     );\n \n+    debug_assert!({\n+        let builder = upvar_resolved_place_builder.clone();\n+        let mut valid_conversion = true;\n+        match builder {\n+            PlaceBuilder::Local(_, projections) => {\n+                for proj in projections.iter() {\n+                    match proj {\n+                        ProjectionElem::Field(_, field_ty) => {\n+                            if matches!(field_ty.kind(), ty::Infer(..)) {\n+                                debug!(\n+                                    \"field ty should have been converted for projection {:?} in PlaceBuilder {:?}\",\n+                                    proj,\n+                                    upvar_resolved_place_builder.clone()\n+                                );\n+\n+                                valid_conversion = false;\n+                                break;\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            PlaceBuilder::UpVar(..) => {\n+                unreachable!()\n+            }\n+        }\n+\n+        valid_conversion\n+    });\n+\n     Some(upvar_resolved_place_builder)\n }\n \n@@ -233,14 +264,14 @@ fn to_upvars_resolved_place_builder<'tcx>(\n /// projection kinds are unsupported.\n fn strip_prefix<'a, 'tcx>(\n     mut base_ty: Ty<'tcx>,\n-    projections: &'a [PlaceElem<'tcx>],\n+    projections: &'a [UpvarProjectionElem<'tcx>],\n     prefix_projections: &[HirProjection<'tcx>],\n-) -> impl Iterator<Item = PlaceElem<'tcx>> + 'a {\n+) -> Vec<UpvarProjectionElem<'tcx>> {\n     let mut iter = projections\n         .iter()\n-        .copied()\n         // Filter out opaque casts, they are unnecessary in the prefix.\n-        .filter(|elem| !matches!(elem, ProjectionElem::OpaqueCast(..)));\n+        .filter(|elem| !matches!(elem, ProjectionElem::OpaqueCast(..)))\n+        .map(|elem| *elem);\n     for projection in prefix_projections {\n         debug!(?projection, ?projection.ty);\n \n@@ -261,7 +292,8 @@ fn strip_prefix<'a, 'tcx>(\n \n         base_ty = projection.ty;\n     }\n-    iter\n+\n+    iter.collect::<Vec<_>>()\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n@@ -292,11 +324,11 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         &self,\n         cx: &Builder<'_, 'tcx>,\n     ) -> Option<PlaceBuilder<'tcx>> {\n-        let PlaceBuilder::Upvar( Upvar {var_hir_id, closure_def_id }, projection) = self else {\n+        let PlaceBuilder::UpVar( UpVar {var_hir_id, closure_def_id }, projection) = self else {\n             return None;\n         };\n \n-        to_upvars_resolved_place_builder(cx, var_hir_id, closure_def_id, &projection)\n+        to_upvars_resolved_place_builder(cx, *var_hir_id, *closure_def_id, &projection)\n     }\n \n     pub(crate) fn get_local_projection(&self) -> &[PlaceElem<'tcx>] {\n@@ -309,19 +341,16 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     }\n \n     #[instrument(skip(cx), level = \"debug\")]\n-    pub(crate) fn field(\n-        self,\n-        cx: &Builder<'_, 'tcx>,\n-        f: Field,\n-        default_field_ty: Ty<'tcx>,\n-    ) -> Self {\n+    pub(crate) fn field(self, cx: &Builder<'_, 'tcx>, f: Field) -> Self {\n         let field_ty = match self {\n             PlaceBuilder::Local(..) => {\n                 let base_place = self.clone();\n-                PlaceBuilder::try_compute_field_ty(cx, f, base_place)\n-                    .unwrap_or_else(|| default_field_ty)\n+                PlaceBuilder::compute_field_ty(cx, f, base_place)\n+            }\n+            PlaceBuilder::UpVar(..) => {\n+                let dummy_ty = cx.tcx.mk_ty_infer(ty::FreshTy(0));\n+                dummy_ty\n             }\n-            PlaceBuilder::UpVar(..) => default_field_ty,\n         };\n \n         self.project(ProjectionElem::Field(f, field_ty))\n@@ -347,7 +376,7 @@ impl<'tcx> PlaceBuilder<'tcx> {\n                 PlaceBuilder::Local(local, proj)\n             }\n             PlaceBuilder::UpVar(upvar, mut proj) => {\n-                proj.push(elem);\n+                proj.push(elem.into());\n                 PlaceBuilder::UpVar(upvar, proj)\n             }\n         };\n@@ -363,8 +392,8 @@ impl<'tcx> PlaceBuilder<'tcx> {\n                 *local,\n                 Vec::from_iter(proj.iter().copied().chain([elem.into()])),\n             ),\n-            PlaceBuilder::Upvar(upvar, proj) => PlaceBuilder::UpVar(\n-                upvar,\n+            PlaceBuilder::UpVar(upvar, proj) => PlaceBuilder::UpVar(\n+                *upvar,\n                 Vec::from_iter(proj.iter().copied().chain([elem.into()])),\n             ),\n         }\n@@ -378,11 +407,11 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// Fallible as the root of this place may be an upvar for\n     /// which no base type can be determined.\n     #[instrument(skip(cx), level = \"debug\")]\n-    fn try_compute_field_ty(\n+    fn compute_field_ty(\n         cx: &Builder<'_, 'tcx>,\n         field: Field,\n         base_place: PlaceBuilder<'tcx>,\n-    ) -> Option<Ty<'tcx>> {\n+    ) -> Ty<'tcx> {\n         let field_idx = field.as_usize();\n         let PlaceTy { ty, variant_index } = base_place.to_place(cx).ty(&cx.local_decls, cx.tcx);\n         let base_ty = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n@@ -442,7 +471,7 @@ impl<'tcx> PlaceBuilder<'tcx> {\n             _ => bug!(\"couldn't create field type, unexpected base type: {:?}\", base_ty),\n         };\n \n-        Some(cx.tcx.normalize_erasing_regions(cx.param_env, field_ty))\n+        cx.tcx.normalize_erasing_regions(cx.param_env, field_ty)\n     }\n \n     /// Creates a `PlaceBuilder::Local` from a `PlaceBuilder::UpVar` whose upvars\n@@ -455,7 +484,7 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         cx: &Builder<'_, 'tcx>,\n         local: Local,\n         mut local_projection: Vec<PlaceElem<'tcx>>,\n-        upvar_projection: Vec<PlaceElem<'tcx>>,\n+        upvar_projection: Vec<UpvarProjectionElem<'tcx>>,\n     ) -> Self {\n         // We iterate through `upvar_projection` and whenever we find a `ProjectionElem::Field` we use\n         // the ancestor projections, i.e. those projection elements that come before the field projection,\n@@ -464,11 +493,10 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         for proj in upvar_projection.iter() {\n             debug!(\"proj: {:?}, local_projection: {:?}\", proj, local_projection);\n             match *proj {\n-                ProjectionElem::Field(field, default_field_ty) => {\n+                ProjectionElem::Field(field, _) => {\n                     let ancestor_proj = local_projection.to_vec();\n                     let base_place = PlaceBuilder::Local(local, ancestor_proj);\n-                    let field_ty = PlaceBuilder::try_compute_field_ty(cx, field, base_place)\n-                        .unwrap_or_else(|| default_field_ty);\n+                    let field_ty = PlaceBuilder::compute_field_ty(cx, field, base_place);\n                     debug!(?field_ty);\n \n                     local_projection.push(ProjectionElem::Field(field, field_ty));\n@@ -593,7 +621,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         place_builder = place_builder.downcast(*adt_def, variant_index);\n                     }\n                 }\n-                block.and(place_builder.field(this, name, expr.ty))\n+                block.and(place_builder.field(this, name))\n             }\n             ExprKind::Deref { arg } => {\n                 let place_builder = unpack!("}, {"sha": "e5c2f4f4cbeb0a13d53e62610e7c0594457d2772", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=9061ffba8ceb6a3a927aff15b570f9bd4247862a", "patch": "@@ -355,12 +355,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // base-supplied field, generate an operand that\n                     // reads it from the base.\n                     iter::zip(field_names, &**field_types)\n-                        .map(|(n, ty)| match fields_map.get(&n) {\n+                        .map(|(n, _ty)| match fields_map.get(&n) {\n                             Some(v) => v.clone(),\n                             None => {\n                                 let place_builder = place_builder.clone();\n                                 this.consume_by_copy_or_move(\n-                                    place_builder.field(this, n, *ty).to_place(this),\n+                                    place_builder.field(this, n).to_place(this),\n                                 )\n                             }\n                         })"}, {"sha": "c669016e0ed7feb2ce2c12694281a5635e57b08a", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=9061ffba8ceb6a3a927aff15b570f9bd4247862a", "patch": "@@ -760,7 +760,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let downcast_place = match_pair.place.downcast(adt_def, variant_index); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n-            let place = downcast_place.clone().field(self, subpattern.field, subpattern.pattern.ty);\n+            let place = downcast_place.clone().field(self, subpattern.field);\n             // e.g., `(x as Variant).0 @ P1`\n             MatchPair::new(place, &subpattern.pattern, self)\n         });"}, {"sha": "27a7b03465f67c4f9d0c4525ef45d09da493f5fd", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=9061ffba8ceb6a3a927aff15b570f9bd4247862a", "patch": "@@ -17,7 +17,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         subpatterns\n             .iter()\n             .map(|fieldpat| {\n-                let place = place.clone().field(self, fieldpat.field, fieldpat.pattern.ty);\n+                let place = place.clone().field(self, fieldpat.field);\n \n                 MatchPair::new(place, &fieldpat.pattern, self)\n             })"}, {"sha": "5cfbbb1ac01e773980cb20b726038875af7252cf", "filename": "compiler/rustc_mir_dataflow/src/move_paths/abs_domain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs?ref=9061ffba8ceb6a3a927aff15b570f9bd4247862a", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::ty::Ty;\n pub struct AbstractOperand;\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct AbstractType;\n-pub type AbstractElem = ProjectionElem<AbstractOperand, AbstractType>;\n+pub type AbstractElem = ProjectionElem<AbstractOperand, AbstractType, AbstractType>;\n \n pub trait Lift {\n     type Abstract;"}, {"sha": "b09503a3093055c3acce0b4a190d348f9fb01e2d", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9061ffba8ceb6a3a927aff15b570f9bd4247862a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=9061ffba8ceb6a3a927aff15b570f9bd4247862a", "patch": "@@ -777,10 +777,10 @@ pub enum TrackElem {\n     Field(Field),\n }\n \n-impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n+impl<V, T1, T2> TryFrom<ProjectionElem<V, T1, T2>> for TrackElem {\n     type Error = ();\n \n-    fn try_from(value: ProjectionElem<V, T>) -> Result<Self, Self::Error> {\n+    fn try_from(value: ProjectionElem<V, T1, T2>) -> Result<Self, Self::Error> {\n         match value {\n             ProjectionElem::Field(field, _) => Ok(TrackElem::Field(field)),\n             _ => Err(()),"}]}