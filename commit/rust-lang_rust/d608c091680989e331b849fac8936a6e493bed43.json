{"sha": "d608c091680989e331b849fac8936a6e493bed43", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MDhjMDkxNjgwOTg5ZTMzMWI4NDlmYWM4OTM2YTZlNDkzYmVkNDM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-28T16:39:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-28T16:39:43Z"}, "message": "Some fixme-to-issue housekeeping.", "tree": {"sha": "194928a43764fecce4f753533775994b13b98534", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/194928a43764fecce4f753533775994b13b98534"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d608c091680989e331b849fac8936a6e493bed43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d608c091680989e331b849fac8936a6e493bed43", "html_url": "https://github.com/rust-lang/rust/commit/d608c091680989e331b849fac8936a6e493bed43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d608c091680989e331b849fac8936a6e493bed43/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1f6749f9a7ca09ba9bb49d6bf5aad71c81d5925", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1f6749f9a7ca09ba9bb49d6bf5aad71c81d5925", "html_url": "https://github.com/rust-lang/rust/commit/e1f6749f9a7ca09ba9bb49d6bf5aad71c81d5925"}], "stats": {"total": 230, "additions": 117, "deletions": 113}, "files": [{"sha": "182096edcf2fc38b27e5a438189455b769c9385f", "filename": "src/boot/be/x86.ml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fbe%2Fx86.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fbe%2Fx86.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fx86.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -1245,8 +1245,9 @@ let fn_prologue\n         sub (rc esp) dynamic_frame_sz;\n \n         (* Zero the frame.\n-         *\n-         * FIXME: this is awful, will go away when we have proper CFI.\n+         * \n+         * FIXME (ssue 27): this is awful, will go away when we have proper\n+         * CFI.\n          *)\n \n         mov (rc edi) (ro esp);"}, {"sha": "764fd68848fe450d0929f641a47f8d82be960c8d", "filename": "src/boot/driver/lib.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fdriver%2Flib.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fdriver%2Flib.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Flib.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -12,7 +12,7 @@ let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n   else ()\n ;;\n \n-(* FIXME: move these to sess. *)\n+(* FIXME (issue #67): move these to sess. *)\n let ar_cache = Hashtbl.create 0 ;;\n let sects_cache = Hashtbl.create 0;;\n let meta_cache = Hashtbl.create 0;;\n@@ -138,7 +138,7 @@ let get_mod\n     then true\n     else\n       match meta.(i) with\n-          (* FIXME: bind the wildcards. *)\n+          (* FIXME (issue #68): bind the wildcards. *)\n           (_, None) -> meta_matches (i+1) f_meta\n         | (k, Some v) ->\n             match atab_search f_meta k with"}, {"sha": "61d419e75a63dcc345574ebe7fb75ce6ad585709", "filename": "src/boot/driver/main.ml", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fdriver%2Fmain.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fdriver%2Fmain.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fmain.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -9,7 +9,7 @@ let _ =\n let (targ:Common.target) =\n   match Sys.os_type with\n       \"Unix\" ->\n-        (* FIXME: this is an absurd heuristic. *)\n+        (* FIXME (issue #69): this is an absurd heuristic. *)\n         if Sys.file_exists \"/System/Library\"\n         then MacOS_x86_macho\n         else Linux_x86_elf\n@@ -26,7 +26,9 @@ let (sess:Session.sess) =\n     Session.sess_out = None;\n     Session.sess_library_mode = false;\n     Session.sess_alt_backend = false;\n-    (* FIXME: need something fancier here for unix sub-flavours. *)\n+    (* FIXME (issue #69): need something fancier here for unix\n+     * sub-flavours.\n+     *)\n     Session.sess_targ = targ;\n     Session.sess_log_lex = false;\n     Session.sess_log_parse = false;"}, {"sha": "bf5e32b863adbfbb299b263fa247c9a51b526e1d", "filename": "src/boot/fe/cexp.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Ffe%2Fcexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Ffe%2Fcexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fcexp.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -325,7 +325,7 @@ let unexpected_val (expected:string) (v:pval)  =\n       | PVAL_num i -> \"num \" ^ (Int64.to_string i)\n       | PVAL_bool b -> if b then \"bool true\" else \"bool false\"\n   in\n-    (* FIXME: proper error reporting, please. *)\n+    (* FIXME (issue #70): proper error reporting, please. *)\n     bug () \"expected %s, got %s\" expected got\n ;;\n "}, {"sha": "3efd4e2a061e0dd70a30266693a28ee72c96248d", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -960,7 +960,6 @@ and parse_mod_item_from_signature (ps:pstate)\n           let bpos = lexpos ps in\n             (ident, span ps apos bpos (decl params (Ast.MOD_ITEM_type t)))\n \n-    (* FIXME: parse obj. *)\n     | _ -> raise (unexpected ps)\n \n "}, {"sha": "5df44303664dffede99522b9311446455d8c88f8", "filename": "src/boot/fe/parser.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Ffe%2Fparser.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Ffe%2Fparser.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fparser.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -209,7 +209,7 @@ let build_tmp\n \n (* Simple helpers *)\n \n-(* FIXME: please rename these, they make eyes bleed. *)\n+(* FIXME (issue #71): please rename these, they make eyes bleed. *)\n \n let arr (ls:'a list) : 'a array = Array.of_list ls ;;\n let arl (ls:'a list) : 'a array = Array.of_list (List.rev ls) ;;"}, {"sha": "b7fdf309e5eec119b267a469fa8827a18b9eb5b3", "filename": "src/boot/me/dwarf.ml", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Fdwarf.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Fdwarf.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fdwarf.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -1356,7 +1356,6 @@ let (abbrev_variant:abbrev) =\n let (abbrev_subroutine_type:abbrev) =\n     (DW_TAG_subroutine_type, DW_CHILDREN_yes,\n      [|\n-       (* FIXME: model effects properly. *)\n        (DW_AT_type, DW_FORM_ref_addr); (* NB: output type. *)\n        (DW_AT_mutable, DW_FORM_flag);\n        (DW_AT_pure, DW_FORM_flag);\n@@ -1375,7 +1374,6 @@ let (abbrev_formal_type:abbrev) =\n let (abbrev_obj_subroutine_type:abbrev) =\n     (DW_TAG_subroutine_type, DW_CHILDREN_yes,\n      [|\n-       (* FIXME: model effects properly. *)\n        (DW_AT_name, DW_FORM_string);\n        (DW_AT_type, DW_FORM_ref_addr); (* NB: output type. *)\n        (DW_AT_mutable, DW_FORM_flag);\n@@ -1568,7 +1566,7 @@ let dwarf_visitor\n                                |]));\n                 ref_addr_for_fix fix\n \n-          (* FIXME: encode mutable-ness of interiors. *)\n+          (* FIXME (issue #72): encode mutable-ness of interiors. *)\n           | Ast.MODE_interior -> ref_type_die (slot_ty slot)\n \n           | Ast.MODE_alias ->\n@@ -2473,7 +2471,9 @@ let dwarf_visitor\n                     Some off ->\n                       begin\n                         match Il.size_to_expr64 off with\n-                            (* FIXME: handle dynamic-size slots. *)\n+                            (* FIXME (issue #73): handle dynamic-size\n+                             * slots.\n+                             *)\n                             None -> ()\n                           | Some off ->\n                               emit_var_die\n@@ -3001,7 +3001,9 @@ let rec extract_mod_items\n               Ast.slot_ty = Some ty }\n       | _ ->\n           let ty = get_ty die in\n-            (* FIXME: encode mutability of interior slots properly. *)\n+            (* FIXME (issue #28): encode mutability of interior slots\n+             * properly.\n+             *)\n             { Ast.slot_mode = Ast.MODE_interior;\n               Ast.slot_mutable = false;\n               Ast.slot_ty = Some ty }\n@@ -3114,7 +3116,7 @@ let rec extract_mod_items\n             htab_put mis ident (decl [||] mi)\n \n       | DW_TAG_subprogram ->\n-          (* FIXME: finish this. *)\n+          (* FIXME (issue #74): finish this. *)\n           let ident = get_name die in\n           let oslot = get_referenced_slot die in\n           let effect = get_effect die in"}, {"sha": "ad9a4cb362d11db54f0de27cf95e9920d53283cb", "filename": "src/boot/me/effect.ml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Feffect.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Feffect.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Feffect.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -40,7 +40,9 @@ let mutability_checking_visitor\n       then ()\n       else err (Some id) \"writing to non-mutable slot\"\n   in\n-    (* FIXME: enforce the no-write-alias-to-immutable-slot rule. *)\n+    (* FIXME (issue #75): enforce the no-write-alias-to-immutable-slot\n+     * rule.\n+     *)\n   let visit_stmt_pre s =\n     begin\n       match s.node with"}, {"sha": "489655f39e843be6b7c6203b8c7e6d0e3733a366", "filename": "src/boot/me/resolve.ml", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Fresolve.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Fresolve.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fresolve.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -170,7 +170,6 @@ let all_item_collecting_visitor\n     htab_put cx.ctxt_all_item_names i.id (Walk.path_to_name path);\n     log cx \"collected item #%d: %s\" (int_of_node i.id) n;\n     begin\n-      (* FIXME: this is incomplete. *)\n       match i.node.Ast.decl_item with\n           Ast.MOD_ITEM_fn f ->\n             note_header i.id f.Ast.fn_input_slots;\n@@ -345,8 +344,6 @@ let rec ty_iso_of\n   let group_table = Hashtbl.find recursive_tag_groups n in\n   let group_array = Array.of_list (htab_keys group_table) in\n   let compare_nodes a_id b_id =\n-    (* FIXME: this should sort by the sorted name-lists of the\n-     *constructors* of the tag, not the tag type name. *)\n     let a_name = Hashtbl.find cx.ctxt_all_item_names a_id in\n     let b_name = Hashtbl.find cx.ctxt_all_item_names b_id in\n       compare a_name b_name\n@@ -935,11 +932,11 @@ let pattern_resolving_visitor\n           let lval_id = lval_base_id lval in\n           let tag_ctor_id = lval_to_referent cx lval_id in\n             if referent_is_item cx tag_ctor_id\n-              (*\n-               * FIXME we should actually check here that the function\n-               * is a tag value-ctor.  For now this actually allows any\n-               * function returning a tag type to pass as a tag pattern.\n-               *)\n+\n+            (* FIXME (issue #76): we should actually check here that the\n+             * function is a tag value-ctor.  For now this actually allows\n+             * any function returning a tag type to pass as a tag\n+             * pattern.  *)\n             then resolve_pat_tag lval_nm lval_id pats tag_ctor_id\n             else not_tag_ctor lval_nm lval_id\n       | _ -> ()\n@@ -948,28 +945,29 @@ let pattern_resolving_visitor\n   let visit_stmt_pre stmt =\n     begin\n       match stmt.node with\n-        Ast.STMT_alt_tag { Ast.alt_tag_lval = _; Ast.alt_tag_arms = arms } ->\n-          Array.iter resolve_arm arms\n-      | _ -> ()\n+          Ast.STMT_alt_tag { Ast.alt_tag_lval = _;\n+                             Ast.alt_tag_arms = arms } ->\n+            Array.iter resolve_arm arms\n+        | _ -> ()\n     end;\n     inner.Walk.visit_stmt_pre stmt\n   in\n-  { inner with Walk.visit_stmt_pre = visit_stmt_pre }\n+    { inner with Walk.visit_stmt_pre = visit_stmt_pre }\n ;;\n \n let export_referencing_visitor\n     (cx:ctxt)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n-    let visit_mod_item_pre id params item =\n-      begin\n-        match item.node.Ast.decl_item with\n-            Ast.MOD_ITEM_mod (view, items) ->\n-              let is_defining_mod =\n-                (* auto-ref the default-export cases only if\n-                 * the containing mod is 'defining', meaning\n-                 * not-native / not-use\n-                 *)\n+  let visit_mod_item_pre id params item =\n+    begin\n+      match item.node.Ast.decl_item with\n+          Ast.MOD_ITEM_mod (view, items) ->\n+            let is_defining_mod =\n+              (* auto-ref the default-export cases only if\n+               * the containing mod is 'defining', meaning\n+               * not-native / not-use\n+               *)\n                  not (Hashtbl.mem cx.ctxt_required_items item.id)\n               in\n               let reference _ item ="}, {"sha": "3868d6f0f4ebc4374154cd300d6fd50190181b39", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -874,13 +874,10 @@ let rebuild_ty_under_params\n         }\n       in\n       let t' = fold_ty fold t in\n-        (* \n-         * FIXME: \"substituted\" and \"ty'\" here are only required\n-         * because the current type-equality-comparison code in Type\n-         * uses <> and will judge some cases, such as rebuilt tags, as\n-         * unequal simply due to the different hashtable order in the\n-         * fold. \n-         *)\n+        (* FIXME (issue #77): \"substituted\" and \"ty'\" here are only required\n+         * because the current type-equality-comparison code in Type uses <>\n+         * and will judge some cases, such as rebuilt tags, as unequal simply\n+         * due to the different hashtable order in the fold.  *)\n         if !substituted\n         then t'\n         else t\n@@ -2080,7 +2077,7 @@ let ty_str (ty:Ast.ty) : string =\n          ty_fold_vec = (fun s -> \"v\" ^ s);\n          ty_fold_iso = fold_iso;\n          ty_fold_idx = (fun i -> \"x\" ^ (string_of_int i));\n-         (* FIXME: encode constrs, aux as well. *)\n+         (* FIXME (issue #78): encode constrs, aux as well. *)\n          ty_fold_fn = (fun ((ins,_,out),_) -> \"f\" ^ ins ^ out);\n \n          (* Built-in special types. *)\n@@ -2092,10 +2089,10 @@ let ty_str (ty:Ast.ty) : string =\n          ty_fold_param = (fun _ -> \"P\");\n          ty_fold_type = (fun _ -> \"Y\");\n \n-         (* FIXME: encode obj types. *)\n-         (* FIXME: encode opaque and param numbers. *)\n+         (* FIXME (issue #78): encode obj types. *)\n+         (* FIXME (issue #78): encode opaque and param numbers. *)\n          ty_fold_named = (fun _ -> bug () \"string-encoding named type\");\n-         (* FIXME: encode constrs as well. *)\n+         (* FIXME (issue #78): encode constrs as well. *)\n          ty_fold_constrained = (fun (t,_)-> t) }\n   in\n     fold_ty fold ty\n@@ -2124,8 +2121,9 @@ let glue_str (cx:ctxt) (g:glue) : string =\n     | GLUE_drop_frame i -> \"glue$drop_frame$\" ^ (item_str cx i)\n     | GLUE_reloc_frame i -> \"glue$reloc_frame$\" ^ (item_str cx i)\n         (* \n-         * FIXME: the node_id here isn't an item, it's a statement; \n-         * lookup bind target and encode bound arg tuple type.\n+         * FIXME (issue #78): the node_id here isn't an item, it's \n+         * a statement; lookup bind target and encode bound arg \n+         * tuple type.\n          *)\n     | GLUE_fn_binding i\n       -> \"glue$fn_binding$\" ^ (string_of_int (int_of_node i))"}, {"sha": "584c2e793004339f4c32f57eda5a64debfc9ceab", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -832,13 +832,14 @@ let trans_visitor\n                               then\n                                 bug () \"unsupported nested for each loop\";\n                               for i = 2 to diff do\n-                                (* FIXME: access outer caller-block fps,\n-                                 * given nearest caller-block fp.\n+                                (* FIXME (issue #79): access outer\n+                                 * caller-block fps, given nearest\n+                                 * caller-block fp. \n                                  *)\n                                 let _ =\n                                   annotate \"step to outer-outer frame\"\n                                 in\n-                                mov fp (Il.Cell fp)\n+                                  mov fp (Il.Cell fp)\n                               done;\n                               let _ = annotate \"calculate size\" in\n                               let p =\n@@ -1179,7 +1180,7 @@ let trans_visitor\n         trans_copy_forward_args self_args_rty;\n \n         iflog (fun _ -> annotate \"call through to callee\");\n-        (* FIXME: use a tail-call here. *)\n+        (* FIXME (issue #80): use a tail-call here. *)\n         call_code (code_of_cell callee_fn_cell);\n         trans_glue_frame_exit fix spill g;\n         fix\n@@ -1419,7 +1420,7 @@ let trans_visitor\n     let (callee_ty:Ast.ty) = mk_simple_ty_fn arg_slots in\n \n     let self_closure_rty = closure_referent_type bound_slots in\n-    (* FIXME: binding type parameters doesn't work. *)\n+    (* FIXME (issue #81): binding type parameters doesn't work. *)\n     let self_args_rty =\n       call_args_referent_type cx 0 self_ty (Some self_closure_rty)\n     in\n@@ -2009,7 +2010,7 @@ let trans_visitor\n     let (fptr_operand, fn_ty) = trans_callee fn_lval in\n     (*let fn_ty_params = [| |] in*)\n     let _ =\n-      (* FIXME: handle indirect-spawns (clone closure). *)\n+      (* FIXME (issue #82): handle indirect-spawns (clone closure). *)\n       if not (lval_is_direct_fn cx fn_lval)\n       then bug () \"unhandled indirect-spawn\"\n     in\n@@ -2214,7 +2215,9 @@ let trans_visitor\n     let descs_ptr = next_vreg_cell Il.voidptr_t in\n       if (Array.length descs) > 0\n       then\n-      (* FIXME: this relies on knowledge that spills are contiguous. *)\n+        (* FIXME (issue #83): this relies on knowledge that spills are\n+         * contiguous.\n+         *)\n         let spills =\n           Array.map (fun _ -> next_spill_cell Il.voidptr_t) descs\n         in\n@@ -2229,7 +2232,7 @@ let trans_visitor\n       td\n \n   and get_tydesc (idopt:node_id option) (ty:Ast.ty) : Il.cell =\n-      log cx \"getting tydesc for %a\" Ast.sprintf_ty ty;\n+    log cx \"getting tydesc for %a\" Ast.sprintf_ty ty;\n     match ty with\n         Ast.TY_param (idx, _) ->\n           (get_ty_param_in_current_frame idx)\n@@ -2243,7 +2246,7 @@ let trans_visitor\n \n   and exterior_ctrl_cell (cell:Il.cell) (off:int) : Il.cell =\n     let (mem, _) = need_mem_cell (deref_imm cell (word_n off)) in\n-    word_at mem\n+      word_at mem\n \n   and exterior_rc_cell (cell:Il.cell) : Il.cell =\n     exterior_ctrl_cell cell Abi.exterior_rc_slot_field_refcnt\n@@ -2294,31 +2297,31 @@ let trans_visitor\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n     let tag_keys = sorted_htab_keys ttag in\n-      let src_tag = get_element_ptr src_cell 0 in\n-      let dst_tag = get_element_ptr dst_cell 0 in\n-      let src_union = get_element_ptr_dyn ty_params src_cell 1 in\n-      let dst_union = get_element_ptr_dyn ty_params dst_cell 1 in\n-      let tmp = next_vreg_cell word_ty in\n-        f dst_tag src_tag word_slot curr_iso;\n-        mov tmp (Il.Cell src_tag);\n-        Array.iteri\n-          begin\n-            fun i key ->\n-              (iflog (fun _ ->\n-                        annotate (Printf.sprintf \"tag case #%i == %a\" i\n-                                    Ast.sprintf_name key)));\n-              let jmps =\n-                trans_compare Il.JNE (Il.Cell tmp) (imm (Int64.of_int i))\n-              in\n-              let ttup = Hashtbl.find ttag key in\n-                iter_tup_slots\n-                  (get_element_ptr_dyn ty_params)\n-                  (get_variant_ptr dst_union i)\n-                  (get_variant_ptr src_union i)\n-                  ttup f curr_iso;\n-                List.iter patch jmps\n-          end\n-          tag_keys\n+    let src_tag = get_element_ptr src_cell 0 in\n+    let dst_tag = get_element_ptr dst_cell 0 in\n+    let src_union = get_element_ptr_dyn ty_params src_cell 1 in\n+    let dst_union = get_element_ptr_dyn ty_params dst_cell 1 in\n+    let tmp = next_vreg_cell word_ty in\n+      f dst_tag src_tag word_slot curr_iso;\n+      mov tmp (Il.Cell src_tag);\n+      Array.iteri\n+        begin\n+          fun i key ->\n+            (iflog (fun _ ->\n+                      annotate (Printf.sprintf \"tag case #%i == %a\" i\n+                                  Ast.sprintf_name key)));\n+            let jmps =\n+              trans_compare Il.JNE (Il.Cell tmp) (imm (Int64.of_int i))\n+            in\n+            let ttup = Hashtbl.find ttag key in\n+              iter_tup_slots\n+                (get_element_ptr_dyn ty_params)\n+                (get_variant_ptr dst_union i)\n+                (get_variant_ptr src_union i)\n+                ttup f curr_iso;\n+              List.iter patch jmps\n+        end\n+        tag_keys\n \n   and get_iso_tag tiso =\n     tiso.Ast.iso_group.(tiso.Ast.iso_index)\n@@ -3129,14 +3132,13 @@ let trans_visitor\n                 let src_cell = need_cell (trans_atom a) in\n                 let src_slot = interior_slot src_ty in\n \n-                (* FIXME: this is wrong. It treats the underlying obj-state\n-                 * as the same as the callee and simply substitutes the\n-                 * forwarding vtbl, which would be great if it had any way\n+                (* FIXME (issue #84): this is wrong. It treats the underlying\n+                 * obj-state as the same as the callee and simply substitutes\n+                 * the forwarding vtbl, which would be great if it had any way\n                  * convey the callee vtbl to the forwarding functions. But it\n                  * doesn't. Instead, we have to malloc a fresh 3-word\n                  * refcounted obj to hold the callee's vtbl+state pair, copy\n-                 * that in as the state here.\n-                 *)\n+                 * that in as the state here.  *)\n                 let _ =\n                   trans_copy_slot (get_ty_params_of_current_frame())\n                     initializing\n@@ -3260,10 +3262,8 @@ let trans_visitor\n               then\n                 match clone with\n                     CLONE_none ->\n-                      (* \n-                       * FIXME: this won't work on mutable aliases, it\n-                       * doesn't know to reload. Try something\n-                       * else.\n+                      (* Aliasing a literal is a bit weird since nobody\n+                       * else will ever see it, but it seems harmless.\n                        *)\n                       mov dst (Il.Cell (alias (Il.Mem (force_to_mem src))))\n                   | _ ->\n@@ -3326,7 +3326,7 @@ let trans_visitor\n                  call_iterator_args = call_iterator_args None;\n                  call_indirect_args = call_indirect_args flv cc }\n     in\n-      (* FIXME: true if caller is object fn *)\n+      (* FIXME (issue #85): true if caller is object fn *)\n     let caller_is_closure = false in\n       log cx \"trans_be_fn: %s call to lval %a\"\n         (call_ctrl_string cc) Ast.sprintf_lval flv;\n@@ -3796,9 +3796,9 @@ let trans_visitor\n           | CALL_vtbl ->\n               begin\n                 match flv with\n-                    (* \n-                     * FIXME: will need to pass both words of obj if we add\n-                     * a 'self' value for self-dispatch within objs.\n+                    (* FIXME (issue #84): will need to pass both words of obj\n+                     * if we add a 'self' value for self-dispatch within\n+                     * objs. Also to support forwarding-functions / 'as'.\n                      *)\n                     Ast.LVAL_ext (base, _) -> [| callee_binding_ptr base cc |]\n                   | _ ->"}, {"sha": "4e0e6ea96b763c06b15a1603606f92f0f0f76a22", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -859,9 +859,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                       unify_atom atom tv_a;\n                       unify_tyvars tv tv_a\n                 | Ast.UNOP_cast t ->\n-                    (* \n-                     * FIXME: check cast-validity in post-typecheck pass.\n-                     * Only some casts make sense.\n+                    (* FIXME (issue #84): check cast-validity in\n+                     * post-typecheck pass.  Only some casts make sense.\n                      *)\n                     let tv_a = ref TYSPEC_all in\n                     let t = Hashtbl.find cx.ctxt_all_cast_types t.id in\n@@ -889,8 +888,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                           begin\n                             fun _ ->\n                               let tv = Hashtbl.find bindings referent in\n-                              log cx \"lval-base slot tyspec for %a = %s\"\n-                                Ast.sprintf_lval lval (tyspec_to_str (!tv));\n+                                log cx \"lval-base slot tyspec for %a = %s\"\n+                                  Ast.sprintf_lval lval (tyspec_to_str (!tv));\n                           end;\n                         unify_slot slot (Some referent) tv\n \n@@ -949,7 +948,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n \n     and unify_lval (lval:Ast.lval) (tv:tyvar) : unit =\n       let id = lval_base_id lval in\n-      (* Fetch lval with type components resolved. *)\n+        (* Fetch lval with type components resolved. *)\n         let lval = Hashtbl.find cx.ctxt_all_lvals id in\n         iflog cx (fun _ -> log cx\n                     \"fetched resolved version of lval #%d = %a\"\n@@ -1056,7 +1055,6 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n \n         | Ast.STMT_decl _ -> ()\n \n-        (* FIXME: deal with difference between return-type vs. put-type *)\n         | Ast.STMT_ret atom_opt\n         | Ast.STMT_put atom_opt ->\n             begin\n@@ -1069,7 +1067,9 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n             check_callable (retval_tv()) callee args\n \n         | Ast.STMT_bind (bound, callee, arg_opts) ->\n-            (* FIXME: handle binding type parameters eventually. *)\n+            (* FIXME (issue #81): handle binding type parameters\n+             * eventually.\n+             *)\n             let out_tv = ref TYSPEC_all in\n             let residue = ref [] in\n             let gen_atom_opt_tvs atoms =\n@@ -1112,7 +1112,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n             let lval_tv = ref TYSPEC_all in\n               unify_lval lval lval_tv;\n               Array.iter (fun _ -> push_pat_tv lval_tv) arms\n-            \n+\n         (* FIXME (issue #52): plenty more to handle here. *)\n         | _ ->\n             log cx \"warning: not typechecking stmt %s\\n\""}, {"sha": "d42aaf6d5eda98fa665b5cbd515357324d21e2f2", "filename": "src/boot/me/typestate.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Ftypestate.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Ftypestate.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftypestate.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -487,7 +487,7 @@ let condition_assigning_visitor\n         | Ast.STMT_alt_tag at ->\n             let precond = slot_inits (lval_slots cx at.Ast.alt_tag_lval) in\n             let visit_arm { node = (pat, block) } =\n-              (* FIXME: propagate tag-carried constrs here. *)\n+              (* FIXME (issue #34): propagate tag-carried constrs here. *)\n               let rec get_slots pat =\n                 match pat with\n                     Ast.PAT_slot header_slot -> [| header_slot |]"}, {"sha": "203acfce7d6232689f5c172dbabb1502af45fe37", "filename": "src/boot/me/walk.ml", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Fwalk.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d608c091680989e331b849fac8936a6e493bed43/src%2Fboot%2Fme%2Fwalk.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fwalk.ml?ref=d608c091680989e331b849fac8936a6e493bed43", "patch": "@@ -524,7 +524,9 @@ and walk_stmt\n           walk_lval v lv;\n           Array.iter (walk_atom v) ats\n \n-      (* FIXME: this should have a param array, and invoke the visitors. *)\n+      (* FIXME (issue #86): this should have a param array, and invoke the\n+       * visitors. \n+       *)\n       | Ast.STMT_decl (Ast.DECL_mod_item (id, mi)) ->\n           walk_mod_item v id mi\n \n@@ -568,11 +570,11 @@ and walk_stmt\n       | Ast.STMT_alt_tag\n           { Ast.alt_tag_lval = lval; Ast.alt_tag_arms = arms } ->\n           walk_lval v lval;\n-          let walk_arm { node = (pat, block) } =\n-            walk_pat v pat;\n-            walk_block v block\n-          in\n-          Array.iter walk_arm arms\n+            let walk_arm { node = (pat, block) } =\n+              walk_pat v pat;\n+              walk_block v block\n+            in\n+              Array.iter walk_arm arms\n \n       (* FIXME (issue #20): finish this as needed. *)\n       | Ast.STMT_slice _"}]}