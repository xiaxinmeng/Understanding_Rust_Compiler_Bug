{"sha": "fb39efe26cfbc81e5ed5e6518262fcc2d44229c2", "node_id": "C_kwDOAAsO6NoAKGZiMzllZmUyNmNmYmM4MWU1ZWQ1ZTY1MTgyNjJmY2MyZDQ0MjI5YzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-12T15:25:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-12T15:25:12Z"}, "message": "Auto merge of #13934 - Veykril:unlinked-file-inline-modules, r=Veykril\n\nfeat: Make unlinked_file diagnostic quickfixes work for inline modules\n\nFinally got myself to fix this, bothered me quite a bit that this never worked\n![Code_Qe3WlMvt5Q](https://user-images.githubusercontent.com/3757771/211927799-023e48ee-7cdd-4dd7-8e25-a23eddc7d897.gif)\n\n(Just gotta fix up the indentation still)", "tree": {"sha": "d3c37451e3b25f798d5db73a8ccdb65d5416f5ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3c37451e3b25f798d5db73a8ccdb65d5416f5ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2", "html_url": "https://github.com/rust-lang/rust/commit/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80e616e00bce9e1ebb969805c01741ce1353d2c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/80e616e00bce9e1ebb969805c01741ce1353d2c4", "html_url": "https://github.com/rust-lang/rust/commit/80e616e00bce9e1ebb969805c01741ce1353d2c4"}, {"sha": "14777ce75190d21f52ae068e3d43a7d16de84ca7", "url": "https://api.github.com/repos/rust-lang/rust/commits/14777ce75190d21f52ae068e3d43a7d16de84ca7", "html_url": "https://github.com/rust-lang/rust/commit/14777ce75190d21f52ae068e3d43a7d16de84ca7"}], "stats": {"total": 256, "additions": 204, "deletions": 52}, "files": [{"sha": "b879eec4cc8d7156413acc25fbbfc9db98c59a07", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=fb39efe26cfbc81e5ed5e6518262fcc2d44229c2", "patch": "@@ -356,6 +356,14 @@ impl HirFileId {\n         }\n     }\n \n+    #[inline]\n+    pub fn file_id(self) -> Option<FileId> {\n+        match self.0 & Self::MACRO_FILE_TAG_MASK {\n+            0 => Some(FileId(self.0)),\n+            _ => None,\n+        }\n+    }\n+\n     fn repr(self) -> HirFileIdRepr {\n         match self.0 & Self::MACRO_FILE_TAG_MASK {\n             0 => HirFileIdRepr::FileId(FileId(self.0)),"}, {"sha": "3d45a75913ad8f68d9591902e869a8cd17ce8381", "filename": "crates/ide-diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 179, "deletions": 51, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=fb39efe26cfbc81e5ed5e6518262fcc2d44229c2", "patch": "@@ -1,13 +1,15 @@\n //! Diagnostic emitted for files that aren't part of any crate.\n \n-use hir::db::DefDatabase;\n+use std::iter;\n+\n+use hir::{db::DefDatabase, InFile, ModuleSource};\n use ide_db::{\n     base_db::{FileId, FileLoader, SourceDatabase, SourceDatabaseExt},\n     source_change::SourceChange,\n     RootDatabase,\n };\n use syntax::{\n-    ast::{self, HasModuleItem, HasName},\n+    ast::{self, edit::IndentLevel, HasModuleItem, HasName},\n     AstNode, TextRange, TextSize,\n };\n use text_edit::TextEdit;\n@@ -42,47 +44,99 @@ fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n \n     let source_root = ctx.sema.db.source_root(ctx.sema.db.file_source_root(file_id));\n     let our_path = source_root.path_for_file(&file_id)?;\n-    let (mut module_name, _) = our_path.name_and_extension()?;\n-\n-    // Candidates to look for:\n-    // - `mod.rs`, `main.rs` and `lib.rs` in the same folder\n-    // - `$dir.rs` in the parent folder, where `$dir` is the directory containing `self.file_id`\n     let parent = our_path.parent()?;\n-    let paths = {\n-        let parent = if module_name == \"mod\" {\n-            // for mod.rs we need to actually look up one higher\n-            // and take the parent as our to be module name\n-            let (name, _) = parent.name_and_extension()?;\n-            module_name = name;\n-            parent.parent()?\n-        } else {\n-            parent\n-        };\n-        let mut paths =\n-            vec![parent.join(\"mod.rs\")?, parent.join(\"lib.rs\")?, parent.join(\"main.rs\")?];\n-\n-        // `submod/bla.rs` -> `submod.rs`\n-        let parent_mod = (|| {\n+    let (module_name, _) = our_path.name_and_extension()?;\n+    let (parent, module_name) = match module_name {\n+        // for mod.rs we need to actually look up one higher\n+        // and take the parent as our to be module name\n+        \"mod\" => {\n             let (name, _) = parent.name_and_extension()?;\n-            parent.parent()?.join(&format!(\"{name}.rs\"))\n-        })();\n-        paths.extend(parent_mod);\n-        paths\n+            (parent.parent()?, name.to_owned())\n+        }\n+        _ => (parent, module_name.to_owned()),\n     };\n \n-    for &parent_id in paths.iter().filter_map(|path| source_root.file_for_path(path)) {\n-        for &krate in ctx.sema.db.relevant_crates(parent_id).iter() {\n-            let crate_def_map = ctx.sema.db.crate_def_map(krate);\n-            for (_, module) in crate_def_map.modules() {\n-                if module.origin.is_inline() {\n-                    // We don't handle inline `mod parent {}`s, they use different paths.\n-                    continue;\n-                }\n+    // check crate roots, i.e. main.rs, lib.rs, ...\n+    'crates: for &krate in &*ctx.sema.db.relevant_crates(file_id) {\n+        let crate_def_map = ctx.sema.db.crate_def_map(krate);\n+\n+        let root_module = &crate_def_map[crate_def_map.root()];\n+        let Some(root_file_id) = root_module.origin.file_id() else { continue };\n+        let Some(crate_root_path) = source_root.path_for_file(&root_file_id) else { continue };\n+        let Some(rel) = parent.strip_prefix(&crate_root_path.parent()?) else { continue };\n+\n+        // try resolving the relative difference of the paths as inline modules\n+        let mut current = root_module;\n+        for ele in rel.as_ref().components() {\n+            let seg = match ele {\n+                std::path::Component::Normal(seg) => seg.to_str()?,\n+                std::path::Component::RootDir => continue,\n+                // shouldn't occur\n+                _ => continue 'crates,\n+            };\n+            match current.children.iter().find(|(name, _)| name.to_smol_str() == seg) {\n+                Some((_, &child)) => current = &crate_def_map[child],\n+                None => continue 'crates,\n+            }\n+            if !current.origin.is_inline() {\n+                continue 'crates;\n+            }\n+        }\n+\n+        let InFile { file_id: parent_file_id, value: source } =\n+            current.definition_source(ctx.sema.db);\n+        let parent_file_id = parent_file_id.file_id()?;\n+        return make_fixes(ctx.sema.db, parent_file_id, source, &module_name, file_id);\n+    }\n \n-                if module.origin.file_id() == Some(parent_id) {\n-                    return make_fixes(ctx.sema.db, parent_id, module_name, file_id);\n+    // if we aren't adding to a crate root, walk backwards such that we support `#[path = ...]` overrides if possible\n+\n+    // build all parent paths of the form `../module_name/mod.rs` and `../module_name.rs`\n+    let paths = iter::successors(Some(parent.clone()), |prev| prev.parent()).filter_map(|path| {\n+        let parent = path.parent()?;\n+        let (name, _) = path.name_and_extension()?;\n+        Some(([parent.join(&format!(\"{name}.rs\"))?, path.join(\"mod.rs\")?], name.to_owned()))\n+    });\n+    let mut stack = vec![];\n+    let &parent_id =\n+        paths.inspect(|(_, name)| stack.push(name.clone())).find_map(|(paths, _)| {\n+            paths.into_iter().find_map(|path| source_root.file_for_path(&path))\n+        })?;\n+    stack.pop();\n+    'crates: for &krate in ctx.sema.db.relevant_crates(parent_id).iter() {\n+        let crate_def_map = ctx.sema.db.crate_def_map(krate);\n+        let Some((_, module)) =\n+            crate_def_map.modules()\n+            .find(|(_, module)| module.origin.file_id() == Some(parent_id) && !module.origin.is_inline())\n+        else { continue };\n+\n+        if stack.is_empty() {\n+            return make_fixes(\n+                ctx.sema.db,\n+                parent_id,\n+                module.definition_source(ctx.sema.db).value,\n+                &module_name,\n+                file_id,\n+            );\n+        } else {\n+            // direct parent file is missing,\n+            // try finding a parent that has an inline tree from here on\n+            let mut current = module;\n+            for s in stack.iter().rev() {\n+                match module.children.iter().find(|(name, _)| name.to_smol_str() == s) {\n+                    Some((_, child)) => {\n+                        current = &crate_def_map[*child];\n+                    }\n+                    None => continue 'crates,\n+                }\n+                if !current.origin.is_inline() {\n+                    continue 'crates;\n                 }\n             }\n+            let InFile { file_id: parent_file_id, value: source } =\n+                current.definition_source(ctx.sema.db);\n+            let parent_file_id = parent_file_id.file_id()?;\n+            return make_fixes(ctx.sema.db, parent_file_id, source, &module_name, file_id);\n         }\n     }\n \n@@ -92,6 +146,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n fn make_fixes(\n     db: &RootDatabase,\n     parent_file_id: FileId,\n+    source: ModuleSource,\n     new_mod_name: &str,\n     added_file_id: FileId,\n ) -> Option<Vec<Assist>> {\n@@ -102,14 +157,18 @@ fn make_fixes(\n     let mod_decl = format!(\"mod {new_mod_name};\");\n     let pub_mod_decl = format!(\"pub mod {new_mod_name};\");\n \n-    let ast: ast::SourceFile = db.parse(parent_file_id).tree();\n-\n     let mut mod_decl_builder = TextEdit::builder();\n     let mut pub_mod_decl_builder = TextEdit::builder();\n \n+    let mut items = match &source {\n+        ModuleSource::SourceFile(it) => it.items(),\n+        ModuleSource::Module(it) => it.item_list()?.items(),\n+        ModuleSource::BlockExpr(_) => return None,\n+    };\n+\n     // If there's an existing `mod m;` statement matching the new one, don't emit a fix (it's\n     // probably `#[cfg]`d out).\n-    for item in ast.items() {\n+    for item in items.clone() {\n         if let ast::Item::Module(m) = item {\n             if let Some(name) = m.name() {\n                 if m.item_list().is_none() && name.to_string() == new_mod_name {\n@@ -121,28 +180,40 @@ fn make_fixes(\n     }\n \n     // If there are existing `mod m;` items, append after them (after the first group of them, rather).\n-    match ast.items().skip_while(|item| !is_outline_mod(item)).take_while(is_outline_mod).last() {\n+    match items.clone().skip_while(|item| !is_outline_mod(item)).take_while(is_outline_mod).last() {\n         Some(last) => {\n             cov_mark::hit!(unlinked_file_append_to_existing_mods);\n             let offset = last.syntax().text_range().end();\n-            mod_decl_builder.insert(offset, format!(\"\\n{mod_decl}\"));\n-            pub_mod_decl_builder.insert(offset, format!(\"\\n{pub_mod_decl}\"));\n+            let indent = IndentLevel::from_node(last.syntax());\n+            mod_decl_builder.insert(offset, format!(\"\\n{indent}{mod_decl}\"));\n+            pub_mod_decl_builder.insert(offset, format!(\"\\n{indent}{pub_mod_decl}\"));\n         }\n         None => {\n             // Prepend before the first item in the file.\n-            match ast.items().next() {\n-                Some(item) => {\n+            match items.next() {\n+                Some(first) => {\n                     cov_mark::hit!(unlinked_file_prepend_before_first_item);\n-                    let offset = item.syntax().text_range().start();\n-                    mod_decl_builder.insert(offset, format!(\"{mod_decl}\\n\\n\"));\n-                    pub_mod_decl_builder.insert(offset, format!(\"{pub_mod_decl}\\n\\n\"));\n+                    let offset = first.syntax().text_range().start();\n+                    let indent = IndentLevel::from_node(first.syntax());\n+                    mod_decl_builder.insert(offset, format!(\"{mod_decl}\\n\\n{indent}\"));\n+                    pub_mod_decl_builder.insert(offset, format!(\"{pub_mod_decl}\\n\\n{indent}\"));\n                 }\n                 None => {\n                     // No items in the file, so just append at the end.\n                     cov_mark::hit!(unlinked_file_empty_file);\n-                    let offset = ast.syntax().text_range().end();\n-                    mod_decl_builder.insert(offset, format!(\"{mod_decl}\\n\"));\n-                    pub_mod_decl_builder.insert(offset, format!(\"{pub_mod_decl}\\n\"));\n+                    let mut indent = IndentLevel::from(0);\n+                    let offset = match &source {\n+                        ModuleSource::SourceFile(it) => it.syntax().text_range().end(),\n+                        ModuleSource::Module(it) => {\n+                            indent = IndentLevel::from_node(it.syntax()) + 1;\n+                            it.item_list()?.r_curly_token()?.text_range().start()\n+                        }\n+                        ModuleSource::BlockExpr(it) => {\n+                            it.stmt_list()?.r_curly_token()?.text_range().start()\n+                        }\n+                    };\n+                    mod_decl_builder.insert(offset, format!(\"{indent}{mod_decl}\\n\"));\n+                    pub_mod_decl_builder.insert(offset, format!(\"{indent}{pub_mod_decl}\\n\"));\n                 }\n             }\n         }\n@@ -167,7 +238,6 @@ fn make_fixes(\n \n #[cfg(test)]\n mod tests {\n-\n     use crate::tests::{check_diagnostics, check_fix, check_fixes, check_no_fix};\n \n     #[test]\n@@ -330,6 +400,64 @@ $0\n mod foo;\n \n //- /foo.rs\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_into_inline_simple() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod bar;\n+//- /bar.rs\n+mod foo {\n+}\n+//- /bar/foo/baz.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo {\n+    mod baz;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_into_inline_simple_modrs() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod bar;\n+//- /bar.rs\n+mod baz {\n+}\n+//- /bar/baz/foo/mod.rs\n+$0\n+\"#,\n+            r#\"\n+mod baz {\n+    mod foo;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_into_inline_simple_modrs_main() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod bar {\n+}\n+//- /bar/foo/mod.rs\n+$0\n+\"#,\n+            r#\"\n+mod bar {\n+    mod foo;\n+}\n \"#,\n         );\n     }"}, {"sha": "e70bc2ec54172aa563a3068b7c6f09b47d414467", "filename": "crates/ide/src/goto_declaration.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2/crates%2Fide%2Fsrc%2Fgoto_declaration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2/crates%2Fide%2Fsrc%2Fgoto_declaration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_declaration.rs?ref=fb39efe26cfbc81e5ed5e6518262fcc2d44229c2", "patch": "@@ -17,6 +17,7 @@ use crate::{\n // This is the same as `Go to Definition` with the following exceptions:\n // - outline modules will navigate to the `mod name;` item declaration\n // - trait assoc items will navigate to the assoc item of the trait declaration opposed to the trait impl\n+// - fields in patterns will navigate to the field declaration of the struct, union or variant\n pub(crate) fn goto_declaration(\n     db: &RootDatabase,\n     position: FilePosition,"}, {"sha": "38501a8ba5a3418c4160e903156a885dc2f1efc7", "filename": "crates/vfs/src/vfs_path.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb39efe26cfbc81e5ed5e6518262fcc2d44229c2/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=fb39efe26cfbc81e5ed5e6518262fcc2d44229c2", "patch": "@@ -1,7 +1,7 @@\n //! Abstract-ish representation of paths for VFS.\n use std::fmt;\n \n-use paths::{AbsPath, AbsPathBuf};\n+use paths::{AbsPath, AbsPathBuf, RelPath};\n \n /// Path in [`Vfs`].\n ///\n@@ -84,6 +84,14 @@ impl VfsPath {\n         }\n     }\n \n+    pub fn strip_prefix(&self, other: &VfsPath) -> Option<&RelPath> {\n+        match (&self.0, &other.0) {\n+            (VfsPathRepr::PathBuf(lhs), VfsPathRepr::PathBuf(rhs)) => lhs.strip_prefix(rhs),\n+            (VfsPathRepr::VirtualPath(lhs), VfsPathRepr::VirtualPath(rhs)) => lhs.strip_prefix(rhs),\n+            (VfsPathRepr::PathBuf(_) | VfsPathRepr::VirtualPath(_), _) => None,\n+        }\n+    }\n+\n     /// Returns the `VfsPath` without its final component, if there is one.\n     ///\n     /// Returns [`None`] if the path is a root or prefix.\n@@ -320,6 +328,13 @@ impl VirtualPath {\n         self.0.starts_with(&other.0)\n     }\n \n+    fn strip_prefix(&self, base: &VirtualPath) -> Option<&RelPath> {\n+        <_ as AsRef<std::path::Path>>::as_ref(&self.0)\n+            .strip_prefix(&base.0)\n+            .ok()\n+            .map(RelPath::new_unchecked)\n+    }\n+\n     /// Remove the last component of `self`.\n     ///\n     /// This will find the last `'/'` in `self`, and remove everything after it,"}]}