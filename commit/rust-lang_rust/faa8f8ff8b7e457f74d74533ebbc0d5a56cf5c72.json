{"sha": "faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhYThmOGZmOGI3ZTQ1N2Y3NGQ3NDUzM2ViYmMwZDVhNTZjZjVjNzI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-29T03:35:25Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-30T11:15:25Z"}, "message": "Convert vec::{bsearch, bsearch_elem} to methods.", "tree": {"sha": "e79b90f779583939d493b8a3e6dcb405fc0d461e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e79b90f779583939d493b8a3e6dcb405fc0d461e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72", "html_url": "https://github.com/rust-lang/rust/commit/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "562dea1820e51f7e87cdeef4024eb9e58c7800d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/562dea1820e51f7e87cdeef4024eb9e58c7800d0", "html_url": "https://github.com/rust-lang/rust/commit/562dea1820e51f7e87cdeef4024eb9e58c7800d0"}], "stats": {"total": 181, "additions": 95, "deletions": 86}, "files": [{"sha": "2a252f3f1f39486ce8c48d3a72ab06799ea029e1", "filename": "src/etc/unicode.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72", "patch": "@@ -124,9 +124,9 @@ def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n     fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n         use cmp::{Equal, Less, Greater};\n-        use vec::bsearch;\n+        use vec::ImmutableVector;\n         use option::None;\n-        (do bsearch(r) |&(lo,hi)| {\n+        (do r.bsearch |&(lo,hi)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }"}, {"sha": "c0049c7505d99cf739573656d107c4f34f9317b2", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72", "patch": "@@ -73,7 +73,7 @@ pub use tuple::{ImmutableTuple2, ImmutableTuple3, ImmutableTuple4, ImmutableTupl\n pub use tuple::{ImmutableTuple6, ImmutableTuple7, ImmutableTuple8, ImmutableTuple9};\n pub use tuple::{ImmutableTuple10, ImmutableTuple11, ImmutableTuple12};\n pub use vec::{VectorVector, CopyableVector, ImmutableVector};\n-pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n+pub use vec::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCopyableVector};\n pub use vec::{OwnedVector, OwnedCopyableVector, MutableVector};\n pub use io::{Reader, ReaderUtil, Writer, WriterUtil};\n "}, {"sha": "1e2d5c76feaa0d6f7731fb00c5cc5a89b9e3da5b", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72", "patch": "@@ -16,9 +16,9 @@ pub mod general_category {\n \n     fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n         use cmp::{Equal, Less, Greater};\n-        use vec::bsearch;\n+        use vec::ImmutableVector;\n         use option::None;\n-        (do bsearch(r) |&(lo,hi)| {\n+        (do r.bsearch |&(lo,hi)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n@@ -1451,9 +1451,9 @@ pub mod derived_property {\n \n     fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n         use cmp::{Equal, Less, Greater};\n-        use vec::bsearch;\n+        use vec::ImmutableVector;\n         use option::None;\n-        (do bsearch(r) |&(lo,hi)| {\n+        (do r.bsearch |&(lo,hi)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }"}, {"sha": "d7480617c12e4fd9ca259f9d2e54cf00d248ce20", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 88, "deletions": 79, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=faa8f8ff8b7e457f74d74533ebbc0d5a56cf5c72", "patch": "@@ -646,44 +646,6 @@ impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n     }\n }\n \n-/**\n- * Binary search a sorted vector with a comparator function.\n- *\n- * The comparator should implement an order consistent with the sort\n- * order of the underlying vector, returning an order code that indicates\n- * whether its argument is `Less`, `Equal` or `Greater` the desired target.\n- *\n- * Returns the index where the comparator returned `Equal`, or `None` if\n- * not found.\n- */\n-pub fn bsearch<T>(v: &[T], f: &fn(&T) -> Ordering) -> Option<uint> {\n-    let mut base : uint = 0;\n-    let mut lim : uint = v.len();\n-\n-    while lim != 0 {\n-        let ix = base + (lim >> 1);\n-        match f(&v[ix]) {\n-            Equal => return Some(ix),\n-            Less => {\n-                base = ix + 1;\n-                lim -= 1;\n-            }\n-            Greater => ()\n-        }\n-        lim >>= 1;\n-    }\n-    return None;\n-}\n-\n-/**\n- * Binary search a sorted vector for a given element.\n- *\n- * Returns the index of the element or None if not found.\n- */\n-pub fn bsearch_elem<T:TotalOrd>(v: &[T], x: &T) -> Option<uint> {\n-    bsearch(v, |p| p.cmp(x))\n-}\n-\n // FIXME: if issue #586 gets implemented, could have a postcondition\n // saying the two result lists have the same length -- or, could\n // return a nominal record with a constraint saying that, instead of\n@@ -1119,6 +1081,8 @@ pub trait ImmutableVector<'self, T> {\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n     fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n+\n+    fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint>;\n }\n \n /// Extension methods for vectors\n@@ -1264,6 +1228,35 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         let (ptr, _): (*T, uint) = transmute(*self);\n         ptr.offset(index)\n     }\n+\n+    /**\n+     * Binary search a sorted vector with a comparator function.\n+     *\n+     * The comparator should implement an order consistent with the sort\n+     * order of the underlying vector, returning an order code that indicates\n+     * whether its argument is `Less`, `Equal` or `Greater` the desired target.\n+     *\n+     * Returns the index where the comparator returned `Equal`, or `None` if\n+     * not found.\n+     */\n+    fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint> {\n+        let mut base : uint = 0;\n+        let mut lim : uint = self.len();\n+\n+        while lim != 0 {\n+            let ix = base + (lim >> 1);\n+            match f(&self[ix]) {\n+                Equal => return Some(ix),\n+                Less => {\n+                    base = ix + 1;\n+                    lim -= 1;\n+                }\n+                Greater => ()\n+            }\n+            lim >>= 1;\n+        }\n+        return None;\n+    }\n }\n \n #[allow(missing_doc)]\n@@ -1293,6 +1286,22 @@ impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n     }\n }\n \n+#[allow(missing_doc)]\n+pub trait ImmutableTotalOrdVector<T: TotalOrd> {\n+    fn bsearch_elem(&self, x: &T) -> Option<uint>;\n+}\n+\n+impl<'self, T: TotalOrd> ImmutableTotalOrdVector<T> for &'self [T] {\n+    /**\n+     * Binary search a sorted vector for a given element.\n+     *\n+     * Returns the index of the element or None if not found.\n+     */\n+    fn bsearch_elem(&self, x: &T) -> Option<uint> {\n+        self.bsearch(|p| p.cmp(x))\n+    }\n+}\n+\n #[allow(missing_doc)]\n pub trait ImmutableCopyableVector<T> {\n     fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n@@ -2841,47 +2850,47 @@ mod tests {\n \n     #[test]\n     fn test_bsearch_elem() {\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &5), Some(4));\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &4), Some(3));\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &3), Some(2));\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &2), Some(1));\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &1), Some(0));\n-\n-        assert_eq!(bsearch_elem([2,4,6,8,10], &1), None);\n-        assert_eq!(bsearch_elem([2,4,6,8,10], &5), None);\n-        assert_eq!(bsearch_elem([2,4,6,8,10], &4), Some(1));\n-        assert_eq!(bsearch_elem([2,4,6,8,10], &10), Some(4));\n-\n-        assert_eq!(bsearch_elem([2,4,6,8], &1), None);\n-        assert_eq!(bsearch_elem([2,4,6,8], &5), None);\n-        assert_eq!(bsearch_elem([2,4,6,8], &4), Some(1));\n-        assert_eq!(bsearch_elem([2,4,6,8], &8), Some(3));\n-\n-        assert_eq!(bsearch_elem([2,4,6], &1), None);\n-        assert_eq!(bsearch_elem([2,4,6], &5), None);\n-        assert_eq!(bsearch_elem([2,4,6], &4), Some(1));\n-        assert_eq!(bsearch_elem([2,4,6], &6), Some(2));\n-\n-        assert_eq!(bsearch_elem([2,4], &1), None);\n-        assert_eq!(bsearch_elem([2,4], &5), None);\n-        assert_eq!(bsearch_elem([2,4], &2), Some(0));\n-        assert_eq!(bsearch_elem([2,4], &4), Some(1));\n-\n-        assert_eq!(bsearch_elem([2], &1), None);\n-        assert_eq!(bsearch_elem([2], &5), None);\n-        assert_eq!(bsearch_elem([2], &2), Some(0));\n-\n-        assert_eq!(bsearch_elem([], &1), None);\n-        assert_eq!(bsearch_elem([], &5), None);\n-\n-        assert!(bsearch_elem([1,1,1,1,1], &1) != None);\n-        assert!(bsearch_elem([1,1,1,1,2], &1) != None);\n-        assert!(bsearch_elem([1,1,1,2,2], &1) != None);\n-        assert!(bsearch_elem([1,1,2,2,2], &1) != None);\n-        assert_eq!(bsearch_elem([1,2,2,2,2], &1), Some(0));\n-\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &6), None);\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &0), None);\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&5), Some(4));\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&4), Some(3));\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&3), Some(2));\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&2), Some(1));\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&1), Some(0));\n+\n+        assert_eq!([2,4,6,8,10].bsearch_elem(&1), None);\n+        assert_eq!([2,4,6,8,10].bsearch_elem(&5), None);\n+        assert_eq!([2,4,6,8,10].bsearch_elem(&4), Some(1));\n+        assert_eq!([2,4,6,8,10].bsearch_elem(&10), Some(4));\n+\n+        assert_eq!([2,4,6,8].bsearch_elem(&1), None);\n+        assert_eq!([2,4,6,8].bsearch_elem(&5), None);\n+        assert_eq!([2,4,6,8].bsearch_elem(&4), Some(1));\n+        assert_eq!([2,4,6,8].bsearch_elem(&8), Some(3));\n+\n+        assert_eq!([2,4,6].bsearch_elem(&1), None);\n+        assert_eq!([2,4,6].bsearch_elem(&5), None);\n+        assert_eq!([2,4,6].bsearch_elem(&4), Some(1));\n+        assert_eq!([2,4,6].bsearch_elem(&6), Some(2));\n+\n+        assert_eq!([2,4].bsearch_elem(&1), None);\n+        assert_eq!([2,4].bsearch_elem(&5), None);\n+        assert_eq!([2,4].bsearch_elem(&2), Some(0));\n+        assert_eq!([2,4].bsearch_elem(&4), Some(1));\n+\n+        assert_eq!([2].bsearch_elem(&1), None);\n+        assert_eq!([2].bsearch_elem(&5), None);\n+        assert_eq!([2].bsearch_elem(&2), Some(0));\n+\n+        assert_eq!([].bsearch_elem(&1), None);\n+        assert_eq!([].bsearch_elem(&5), None);\n+\n+        assert!([1,1,1,1,1].bsearch_elem(&1) != None);\n+        assert!([1,1,1,1,2].bsearch_elem(&1) != None);\n+        assert!([1,1,1,2,2].bsearch_elem(&1) != None);\n+        assert!([1,1,2,2,2].bsearch_elem(&1) != None);\n+        assert_eq!([1,2,2,2,2].bsearch_elem(&1), Some(0));\n+\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&6), None);\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&0), None);\n     }\n \n     #[test]"}]}