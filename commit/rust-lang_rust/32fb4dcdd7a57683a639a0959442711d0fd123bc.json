{"sha": "32fb4dcdd7a57683a639a0959442711d0fd123bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZmI0ZGNkZDdhNTc2ODNhNjM5YTA5NTk0NDI3MTFkMGZkMTIzYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-12T06:32:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-12T06:32:45Z"}, "message": "Auto merge of #69707 - estebank:impl-trait-missing-bounds, r=Centril\n\nHandle `impl Trait` where `Trait` has an assoc type with missing bounds\n\nWhen encountering a type parameter that needs more bounds the trivial case is `T` `where T: Bound`, but it can also be an `impl Trait` param that needs to be decomposed to a type param for cleaner code. For example, given\n\n```rust\nfn foo(constraints: impl Iterator) {\n    for constraint in constraints {\n        println!(\"{:?}\", constraint);\n    }\n}\n```\n\nthe previous output was\n\n```\nerror[E0277]: `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n --> src/main.rs:3:26\n  |\n1 | fn foo(constraints: impl Iterator) {\n  |                                    - help: consider further restricting the associated type: `where <impl Iterator as std::iter::Iterator>::Item: std::fmt::Debug`\n2 |     for constraint in constraints {\n3 |         println!(\"{:?}\", constraint);\n  |                          ^^^^^^^^^^ `<impl Iterator as std::iter::Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n  |\n  = help: the trait `std::fmt::Debug` is not implemented for `<impl Iterator as std::iter::Iterator>::Item`\n  = note: required by `std::fmt::Debug::fmt`\n```\n\nwhich is incorrect as `where <impl Iterator as std::iter::Iterator>::Item: std::fmt::Debug` is not valid syntax nor would it restrict the positional `impl Iterator` parameter if it were.\n\nThe output being introduced is\n\n```\nerror[E0277]: `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n --> src/main.rs:3:26\n  |\n3 |         println!(\"{:?}\", constraint);\n  |                          ^^^^^^^^^^ `<impl Iterator as std::iter::Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n  |\n  = help: the trait `std::fmt::Debug` is not implemented for `<impl Iterator as std::iter::Iterator>::Item`\n  = note: required by `std::fmt::Debug::fmt`\nhelp: introduce a type parameter with a trait bound instead of using `impl Trait`\n   |\nLL | fn foo<T: Iterator>(constraints: T) where <T as std::iter::Iterator>::Item: std::fmt::Debug  {\n   |       ^^^^^^^^^^^^^              ^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nThis suggestion is correct and lead the user in the right direction: because you have an associated type restriction you can no longer use `impl Trait`, the only reasonable alternative is to introduce a named type parameter, bound by `Trait` and with a `where` binding on the associated type for the new type parameter `as Trait` for the missing bound.\n\n*Ideally*, we would want to suggest something like the following, but that is not valid syntax today\n\n```\nerror[E0277]: `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n --> src/main.rs:3:26\n  |\n3 |         println!(\"{:?}\", constraint);\n  |                          ^^^^^^^^^^ `<impl Iterator as std::iter::Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n  |\n  = help: the trait `std::fmt::Debug` is not implemented for `<impl Iterator as std::iter::Iterator>::Item`\n  = note: required by `std::fmt::Debug::fmt`\nhelp: introduce a type parameter with a trait bound instead of using `impl Trait`\n   |\nLL | fn foo(constraints: impl Iterator<Item: std::fmt::Debug>) {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nFix #69638.", "tree": {"sha": "cf73c23e52b00a9c348029e90db22e5225ce9e0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf73c23e52b00a9c348029e90db22e5225ce9e0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32fb4dcdd7a57683a639a0959442711d0fd123bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32fb4dcdd7a57683a639a0959442711d0fd123bc", "html_url": "https://github.com/rust-lang/rust/commit/32fb4dcdd7a57683a639a0959442711d0fd123bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32fb4dcdd7a57683a639a0959442711d0fd123bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "941d4352d75bf5c8b509ac4a8c30f5e1e7bf8b8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/941d4352d75bf5c8b509ac4a8c30f5e1e7bf8b8a", "html_url": "https://github.com/rust-lang/rust/commit/941d4352d75bf5c8b509ac4a8c30f5e1e7bf8b8a"}, {"sha": "984aac6eed8fe80ed97cbc3f9fe585579733db60", "url": "https://api.github.com/repos/rust-lang/rust/commits/984aac6eed8fe80ed97cbc3f9fe585579733db60", "html_url": "https://github.com/rust-lang/rust/commit/984aac6eed8fe80ed97cbc3f9fe585579733db60"}], "stats": {"total": 354, "additions": 304, "deletions": 50}, "files": [{"sha": "9ada88098a5b508047ba12c0e921d0506f192266", "filename": "src/librustc_trait_selection/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Flibrustc_trait_selection%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Flibrustc_trait_selection%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Flib.rs?ref=32fb4dcdd7a57683a639a0959442711d0fd123bc", "patch": "@@ -16,6 +16,8 @@\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]\n #![feature(or_patterns)]\n+#![feature(str_strip)]\n+#![feature(option_zip)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "fef7adf02246b252ad02131d2064cbbaaa0a37b1", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=32fb4dcdd7a57683a639a0959442711d0fd123bc", "patch": "@@ -388,7 +388,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             // which is somewhat confusing.\n                             self.suggest_restricting_param_bound(\n                                 &mut err,\n-                                &trait_ref,\n+                                trait_ref,\n                                 obligation.cause.body_id,\n                             );\n                         } else {"}, {"sha": "14029f2915141dc7cfdd389137c12a855ea52259", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 174, "deletions": 32, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=32fb4dcdd7a57683a639a0959442711d0fd123bc", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n     self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n \n@@ -27,7 +27,7 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::PolyTraitRef<'_>,\n+        trait_ref: ty::PolyTraitRef<'_>,\n         body_id: hir::HirId,\n     );\n \n@@ -148,11 +148,128 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>);\n }\n \n+fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, String) {\n+    (\n+        generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n+        format!(\n+            \"{} {} \",\n+            if !generics.where_clause.predicates.is_empty() { \",\" } else { \" where\" },\n+            pred,\n+        ),\n+    )\n+}\n+\n+/// Type parameter needs more bounds. The trivial case is `T` `where T: Bound`, but\n+/// it can also be an `impl Trait` param that needs to be decomposed to a type\n+/// param for cleaner code.\n+fn suggest_restriction(\n+    generics: &hir::Generics<'_>,\n+    msg: &str,\n+    err: &mut DiagnosticBuilder<'_>,\n+    fn_sig: Option<&hir::FnSig<'_>>,\n+    projection: Option<&ty::ProjectionTy<'_>>,\n+    trait_ref: ty::PolyTraitRef<'_>,\n+) {\n+    let span = generics.where_clause.span_for_predicates_or_empty_place();\n+    if span.from_expansion() || span.desugaring_kind().is_some() {\n+        return;\n+    }\n+    // Given `fn foo(t: impl Trait)` where `Trait` requires assoc type `A`...\n+    if let Some((bound_str, fn_sig)) =\n+        fn_sig.zip(projection).and_then(|(sig, p)| match p.self_ty().kind {\n+            // Shenanigans to get the `Trait` from the `impl Trait`.\n+            ty::Param(param) => {\n+                // `fn foo(t: impl Trait)`\n+                //                 ^^^^^ get this string\n+                param.name.as_str().strip_prefix(\"impl\").map(|s| (s.trim_start().to_string(), sig))\n+            }\n+            _ => None,\n+        })\n+    {\n+        // We know we have an `impl Trait` that doesn't satisfy a required projection.\n+\n+        // Find all of the ocurrences of `impl Trait` for `Trait` in the function arguments'\n+        // types. There should be at least one, but there might be *more* than one. In that\n+        // case we could just ignore it and try to identify which one needs the restriction,\n+        // but instead we choose to suggest replacing all instances of `impl Trait` with `T`\n+        // where `T: Trait`.\n+        let mut ty_spans = vec![];\n+        let impl_trait_str = format!(\"impl {}\", bound_str);\n+        for input in fn_sig.decl.inputs {\n+            if let hir::TyKind::Path(hir::QPath::Resolved(\n+                None,\n+                hir::Path { segments: [segment], .. },\n+            )) = input.kind\n+            {\n+                if segment.ident.as_str() == impl_trait_str.as_str() {\n+                    // `fn foo(t: impl Trait)`\n+                    //            ^^^^^^^^^^ get this to suggest `T` instead\n+\n+                    // There might be more than one `impl Trait`.\n+                    ty_spans.push(input.span);\n+                }\n+            }\n+        }\n+\n+        let type_param_name = generics.params.next_type_param_name(Some(&bound_str));\n+        // The type param `T: Trait` we will suggest to introduce.\n+        let type_param = format!(\"{}: {}\", type_param_name, bound_str);\n+\n+        // FIXME: modify the `trait_ref` instead of string shenanigans.\n+        // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n+        let pred = trait_ref.without_const().to_predicate().to_string();\n+        let pred = pred.replace(&impl_trait_str, &type_param_name);\n+        let mut sugg = vec![\n+            match generics\n+                .params\n+                .iter()\n+                .filter(|p| match p.kind {\n+                    hir::GenericParamKind::Type {\n+                        synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                        ..\n+                    } => false,\n+                    _ => true,\n+                })\n+                .last()\n+            {\n+                // `fn foo(t: impl Trait)`\n+                //        ^ suggest `<T: Trait>` here\n+                None => (generics.span, format!(\"<{}>\", type_param)),\n+                // `fn foo<A>(t: impl Trait)`\n+                //        ^^^ suggest `<A, T: Trait>` here\n+                Some(param) => (\n+                    param.bounds_span().unwrap_or(param.span).shrink_to_hi(),\n+                    format!(\", {}\", type_param),\n+                ),\n+            },\n+            // `fn foo(t: impl Trait)`\n+            //                       ^ suggest `where <T as Trait>::A: Bound`\n+            predicate_constraint(generics, pred),\n+        ];\n+        sugg.extend(ty_spans.into_iter().map(|s| (s, type_param_name.to_string())));\n+\n+        // Suggest `fn foo<T: Trait>(t: T) where <T as Trait>::A: Bound`.\n+        // FIXME: once `#![feature(associated_type_bounds)]` is stabilized, we should suggest\n+        // `fn foo(t: impl Trait<A: Bound>)` instead.\n+        err.multipart_suggestion(\n+            \"introduce a type parameter with a trait bound instead of using `impl Trait`\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+    } else {\n+        // Trivial case: `T` needs an extra bound: `T: Bound`.\n+        let (sp, sugg) =\n+            predicate_constraint(generics, trait_ref.without_const().to_predicate().to_string());\n+        let appl = Applicability::MachineApplicable;\n+        err.span_suggestion(sp, &format!(\"consider further restricting {}\", msg), sugg, appl);\n+    }\n+}\n+\n impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         mut err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::PolyTraitRef<'_>,\n+        trait_ref: ty::PolyTraitRef<'_>,\n         body_id: hir::HirId,\n     ) {\n         let self_ty = trait_ref.self_ty();\n@@ -162,27 +279,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             _ => return,\n         };\n \n-        let suggest_restriction =\n-            |generics: &hir::Generics<'_>, msg, err: &mut DiagnosticBuilder<'_>| {\n-                let span = generics.where_clause.span_for_predicates_or_empty_place();\n-                if !span.from_expansion() && span.desugaring_kind().is_none() {\n-                    err.span_suggestion(\n-                        generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n-                        &format!(\"consider further restricting {}\", msg),\n-                        format!(\n-                            \"{} {} \",\n-                            if !generics.where_clause.predicates.is_empty() {\n-                                \",\"\n-                            } else {\n-                                \" where\"\n-                            },\n-                            trait_ref.without_const().to_predicate(),\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            };\n-\n         // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n         //        don't suggest `T: Sized + ?Sized`.\n         let mut hir_id = body_id;\n@@ -194,27 +290,47 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     ..\n                 }) if param_ty && self_ty == self.tcx.types.self_param => {\n                     // Restricting `Self` for a single method.\n-                    suggest_restriction(&generics, \"`Self`\", err);\n+                    suggest_restriction(&generics, \"`Self`\", err, None, projection, trait_ref);\n                     return;\n                 }\n \n                 hir::Node::TraitItem(hir::TraitItem {\n                     generics,\n-                    kind: hir::TraitItemKind::Fn(..),\n+                    kind: hir::TraitItemKind::Fn(fn_sig, ..),\n                     ..\n                 })\n                 | hir::Node::ImplItem(hir::ImplItem {\n                     generics,\n-                    kind: hir::ImplItemKind::Fn(..),\n+                    kind: hir::ImplItemKind::Fn(fn_sig, ..),\n                     ..\n                 })\n-                | hir::Node::Item(\n-                    hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. }\n-                    | hir::Item { kind: hir::ItemKind::Trait(_, _, generics, _, _), .. }\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(fn_sig, generics, _), ..\n+                }) if projection.is_some() => {\n+                    // Missing restriction on associated type of type parameter (unmet projection).\n+                    suggest_restriction(\n+                        &generics,\n+                        \"the associated type\",\n+                        err,\n+                        Some(fn_sig),\n+                        projection,\n+                        trait_ref,\n+                    );\n+                    return;\n+                }\n+                hir::Node::Item(\n+                    hir::Item { kind: hir::ItemKind::Trait(_, _, generics, _, _), .. }\n                     | hir::Item { kind: hir::ItemKind::Impl { generics, .. }, .. },\n                 ) if projection.is_some() => {\n-                    // Missing associated type bound.\n-                    suggest_restriction(&generics, \"the associated type\", err);\n+                    // Missing restriction on associated type of type parameter (unmet projection).\n+                    suggest_restriction(\n+                        &generics,\n+                        \"the associated type\",\n+                        err,\n+                        None,\n+                        projection,\n+                        trait_ref,\n+                    );\n                     return;\n                 }\n \n@@ -1588,3 +1704,29 @@ impl<'v> Visitor<'v> for ReturnsVisitor<'v> {\n         hir::intravisit::walk_body(self, body);\n     }\n }\n+\n+pub trait NextTypeParamName {\n+    fn next_type_param_name(&self, name: Option<&str>) -> String;\n+}\n+\n+impl NextTypeParamName for &[hir::GenericParam<'_>] {\n+    fn next_type_param_name(&self, name: Option<&str>) -> String {\n+        // This is the whitelist of possible parameter names that we might suggest.\n+        let name = name.and_then(|n| n.chars().next()).map(|c| c.to_string().to_uppercase());\n+        let name = name.as_ref().map(|s| s.as_str());\n+        let possible_names = [name.unwrap_or(\"T\"), \"T\", \"U\", \"V\", \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\"];\n+        let used_names = self\n+            .iter()\n+            .filter_map(|p| match p.name {\n+                hir::ParamName::Plain(ident) => Some(ident.name),\n+                _ => None,\n+            })\n+            .collect::<Vec<_>>();\n+\n+        possible_names\n+            .iter()\n+            .find(|n| !used_names.contains(&Symbol::intern(n)))\n+            .unwrap_or(&\"ParamName\")\n+            .to_string()\n+    }\n+}"}, {"sha": "8ae779a4783bb7783096d1c9cb0e3ff011219872", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=32fb4dcdd7a57683a639a0959442711d0fd123bc", "patch": "@@ -45,6 +45,7 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n+use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n \n mod type_of;\n \n@@ -135,20 +136,7 @@ crate fn placeholder_type_error(\n     if placeholder_types.is_empty() {\n         return;\n     }\n-    // This is the whitelist of possible parameter names that we might suggest.\n-    let possible_names = [\"T\", \"K\", \"L\", \"A\", \"B\", \"C\"];\n-    let used_names = generics\n-        .iter()\n-        .filter_map(|p| match p.name {\n-            hir::ParamName::Plain(ident) => Some(ident.name),\n-            _ => None,\n-        })\n-        .collect::<Vec<_>>();\n-\n-    let type_name = possible_names\n-        .iter()\n-        .find(|n| !used_names.contains(&Symbol::intern(n)))\n-        .unwrap_or(&\"ParamName\");\n+    let type_name = generics.next_type_param_name(None);\n \n     let mut sugg: Vec<_> =\n         placeholder_types.iter().map(|sp| (*sp, (*type_name).to_string())).collect();"}, {"sha": "6e9e8821cfea788236640aafe3733744b07a4c7a", "filename": "src/test/ui/suggestions/impl-trait-with-missing-bounds.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.rs?ref=32fb4dcdd7a57683a639a0959442711d0fd123bc", "patch": "@@ -0,0 +1,44 @@\n+// The double space in `impl  Iterator` is load bearing! We want to make sure we don't regress by\n+// accident if the internal string representation changes.\n+#[rustfmt::skip]\n+fn foo(constraints: impl  Iterator) {\n+    for constraint in constraints {\n+        qux(constraint);\n+//~^ ERROR `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+    }\n+}\n+\n+fn bar<T>(t: T, constraints: impl Iterator) where T: std::fmt::Debug {\n+    for constraint in constraints {\n+        qux(t);\n+        qux(constraint);\n+//~^ ERROR `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+    }\n+}\n+\n+fn baz(t: impl std::fmt::Debug, constraints: impl Iterator) {\n+    for constraint in constraints {\n+        qux(t);\n+        qux(constraint);\n+//~^ ERROR `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+    }\n+}\n+\n+fn bat<I, T: std::fmt::Debug>(t: T, constraints: impl Iterator, _: I) {\n+    for constraint in constraints {\n+        qux(t);\n+        qux(constraint);\n+//~^ ERROR `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+    }\n+}\n+\n+fn bak(constraints: impl  Iterator + std::fmt::Debug) {\n+    for constraint in constraints {\n+        qux(constraint);\n+//~^ ERROR `<impl Iterator + std::fmt::Debug as std::iter::Iterator>::Item` doesn't implement\n+    }\n+}\n+\n+fn qux(_: impl std::fmt::Debug) {}\n+\n+fn main() {}"}, {"sha": "6fc629b33a21e65a0f59e3b262130583bef8dd16", "filename": "src/test/ui/suggestions/impl-trait-with-missing-bounds.stderr", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr?ref=32fb4dcdd7a57683a639a0959442711d0fd123bc", "patch": "@@ -0,0 +1,78 @@\n+error[E0277]: `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+  --> $DIR/impl-trait-with-missing-bounds.rs:6:13\n+   |\n+LL |         qux(constraint);\n+   |             ^^^^^^^^^^ `<impl Iterator as std::iter::Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+...\n+LL | fn qux(_: impl std::fmt::Debug) {}\n+   |                --------------- required by this bound in `qux`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `<impl Iterator as std::iter::Iterator>::Item`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | fn foo<I: Iterator>(constraints: I) where <I as std::iter::Iterator>::Item: std::fmt::Debug  {\n+   |       ^^^^^^^^^^^^^              ^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+  --> $DIR/impl-trait-with-missing-bounds.rs:14:13\n+   |\n+LL |         qux(constraint);\n+   |             ^^^^^^^^^^ `<impl Iterator as std::iter::Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+...\n+LL | fn qux(_: impl std::fmt::Debug) {}\n+   |                --------------- required by this bound in `qux`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `<impl Iterator as std::iter::Iterator>::Item`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | fn bar<T, I: Iterator>(t: T, constraints: I) where T: std::fmt::Debug, <I as std::iter::Iterator>::Item: std::fmt::Debug  {\n+   |         ^^^^^^^^^^^^^                     ^                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+  --> $DIR/impl-trait-with-missing-bounds.rs:22:13\n+   |\n+LL |         qux(constraint);\n+   |             ^^^^^^^^^^ `<impl Iterator as std::iter::Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+...\n+LL | fn qux(_: impl std::fmt::Debug) {}\n+   |                --------------- required by this bound in `qux`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `<impl Iterator as std::iter::Iterator>::Item`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | fn baz<I: Iterator>(t: impl std::fmt::Debug, constraints: I) where <I as std::iter::Iterator>::Item: std::fmt::Debug  {\n+   |       ^^^^^^^^^^^^^                                       ^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `<impl Iterator as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+  --> $DIR/impl-trait-with-missing-bounds.rs:30:13\n+   |\n+LL |         qux(constraint);\n+   |             ^^^^^^^^^^ `<impl Iterator as std::iter::Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+...\n+LL | fn qux(_: impl std::fmt::Debug) {}\n+   |                --------------- required by this bound in `qux`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `<impl Iterator as std::iter::Iterator>::Item`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | fn bat<I, T: std::fmt::Debug, U: Iterator>(t: T, constraints: U, _: I) where <U as std::iter::Iterator>::Item: std::fmt::Debug  {\n+   |                             ^^^^^^^^^^^^^                     ^        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `<impl Iterator + std::fmt::Debug as std::iter::Iterator>::Item` doesn't implement `std::fmt::Debug`\n+  --> $DIR/impl-trait-with-missing-bounds.rs:37:13\n+   |\n+LL |         qux(constraint);\n+   |             ^^^^^^^^^^ `<impl Iterator + std::fmt::Debug as std::iter::Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+...\n+LL | fn qux(_: impl std::fmt::Debug) {}\n+   |                --------------- required by this bound in `qux`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `<impl Iterator + std::fmt::Debug as std::iter::Iterator>::Item`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | fn bak<I: Iterator + std::fmt::Debug>(constraints: I) where <I as std::iter::Iterator>::Item: std::fmt::Debug  {\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^              ^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "6c0653d5fcb7c64f28458f2cef69b81d33036122", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32fb4dcdd7a57683a639a0959442711d0fd123bc/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=32fb4dcdd7a57683a639a0959442711d0fd123bc", "patch": "@@ -106,7 +106,7 @@ LL | fn test6_b<T>(_: _, _: T) { }\n    |\n help: use type parameters instead\n    |\n-LL | fn test6_b<T, K>(_: K, _: T) { }\n+LL | fn test6_b<T, U>(_: U, _: T) { }\n    |             ^^^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n@@ -117,7 +117,7 @@ LL | fn test6_c<T, K, L, A, B>(_: _, _: (T, K, L, A, B)) { }\n    |\n help: use type parameters instead\n    |\n-LL | fn test6_c<T, K, L, A, B, C>(_: C, _: (T, K, L, A, B)) { }\n+LL | fn test6_c<T, K, L, A, B, U>(_: U, _: (T, K, L, A, B)) { }\n    |                         ^^^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n@@ -377,7 +377,7 @@ LL | struct BadStruct2<_, T>(_, T);\n    |\n help: use type parameters instead\n    |\n-LL | struct BadStruct2<K, T>(K, T);\n+LL | struct BadStruct2<U, T>(U, T);\n    |                   ^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures"}]}