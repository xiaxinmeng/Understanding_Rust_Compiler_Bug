{"sha": "af09d24ff66b336c8bc76b66dce19c5a4507e881", "node_id": "C_kwDOAAsO6NoAKGFmMDlkMjRmZjY2YjMzNmM4YmM3NmI2NmRjZTE5YzVhNDUwN2U4ODE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-21T07:33:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-21T07:33:37Z"}, "message": "Rollup merge of #91412 - compiler-errors:issue-86035, r=oli-obk\n\nImprove suggestions for importing out-of-scope traits reexported as `_`\n\n1. Fix up the `parent_map` query to prefer visible parents that _don't_ export items with the name `_`.\n    * I'm not sure if I modified this query properly. Not sure if we want to check for other idents than `kw::Underscore`.\n    * This also has the side-effect of not doing BFS on any modules re-exported as `_`, but I think that's desirable here too (or else we get suggestions for paths like `a::_::b` like in [this doctest example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d9505ea45bb80adf40bb991298f952be)).\n2. Bail in `try_print_visible_def_path` if the `def_id` is re-exported as `_`, which will fall back to printing the def-id's real (definition) path.\n    * Side-effect of this is that we print paths that are not actually public, but it seems we already sometimes suggest `use`ing paths that are private anyways. See [this doctest example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=bad513ed3241f8ff87579eed8046ad10) for demonstration of current behavior.\n3. Suggest a glob-import (for example `my_library::prelude::*`) if the trait in question is only pub-exported as `_`, as a fallback.\n    ```\n    use foo::bar::prelude::*; // trait MyTrait\n    ```\n    * I think this is good fallback behavior to suggest instead of doing nothing. Thanks to the original issue filer for suggesting this.\n\nI was somewhat opinionated about behaviors in this PR, and I'm totally open to limiting the impact of my changes or only landing parts of this. Happy to receive feedback if there are better ways to the same end.\n\nFixes #86035", "tree": {"sha": "40af40ee134cd4043c4926dad16f7aadfaf79939", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40af40ee134cd4043c4926dad16f7aadfaf79939"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af09d24ff66b336c8bc76b66dce19c5a4507e881", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhwYNRCRBK7hj4Ov3rIwAAelQIAGs1/NO5hYk/RexaOUhuyIB6\nsrpK2diPYbCARXb0NJRc5jabXveWh+vwfecRahRo/UqOV0G0XUO6SeG8kYApaEDf\nTX4XoFQWnIPO6hWjzDj9cJ1u1gpXhhOOPA28b0I2Ij4Dnfks28806wXuBYAli8j/\n/J+fWklQHqMWDDRbMejTjoYqT+hQsCl7CHzEka4aSFUes6NlqP+O8pBw+Yi50Eqq\nSNzqmLI6sWTQaXNL7CFtEXq0l5I/0GkwcYjhymp8sd70qArpyCkpcU2CcW5FX5ru\nToRTiSLTwqR/ll2ZPcIc9xT8SI1A2tdTKVOtc3X2pChR7tOKdkm7b1/dKPrOQUU=\n=Fw9D\n-----END PGP SIGNATURE-----\n", "payload": "tree 40af40ee134cd4043c4926dad16f7aadfaf79939\nparent 3009dd7c5a6da3c36c61ce89d5320ed8c0922a22\nparent 682a3428a3183812789f76ca4400c83366699cbd\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1640072017 +0100\ncommitter GitHub <noreply@github.com> 1640072017 +0100\n\nRollup merge of #91412 - compiler-errors:issue-86035, r=oli-obk\n\nImprove suggestions for importing out-of-scope traits reexported as `_`\n\n1. Fix up the `parent_map` query to prefer visible parents that _don't_ export items with the name `_`.\n    * I'm not sure if I modified this query properly. Not sure if we want to check for other idents than `kw::Underscore`.\n    * This also has the side-effect of not doing BFS on any modules re-exported as `_`, but I think that's desirable here too (or else we get suggestions for paths like `a::_::b` like in [this doctest example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d9505ea45bb80adf40bb991298f952be)).\n2. Bail in `try_print_visible_def_path` if the `def_id` is re-exported as `_`, which will fall back to printing the def-id's real (definition) path.\n    * Side-effect of this is that we print paths that are not actually public, but it seems we already sometimes suggest `use`ing paths that are private anyways. See [this doctest example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=bad513ed3241f8ff87579eed8046ad10) for demonstration of current behavior.\n3. Suggest a glob-import (for example `my_library::prelude::*`) if the trait in question is only pub-exported as `_`, as a fallback.\n    ```\n    use foo::bar::prelude::*; // trait MyTrait\n    ```\n    * I think this is good fallback behavior to suggest instead of doing nothing. Thanks to the original issue filer for suggesting this.\n\nI was somewhat opinionated about behaviors in this PR, and I'm totally open to limiting the impact of my changes or only landing parts of this. Happy to receive feedback if there are better ways to the same end.\n\nFixes #86035\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af09d24ff66b336c8bc76b66dce19c5a4507e881", "html_url": "https://github.com/rust-lang/rust/commit/af09d24ff66b336c8bc76b66dce19c5a4507e881", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af09d24ff66b336c8bc76b66dce19c5a4507e881/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3009dd7c5a6da3c36c61ce89d5320ed8c0922a22", "url": "https://api.github.com/repos/rust-lang/rust/commits/3009dd7c5a6da3c36c61ce89d5320ed8c0922a22", "html_url": "https://github.com/rust-lang/rust/commit/3009dd7c5a6da3c36c61ce89d5320ed8c0922a22"}, {"sha": "682a3428a3183812789f76ca4400c83366699cbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/682a3428a3183812789f76ca4400c83366699cbd", "html_url": "https://github.com/rust-lang/rust/commit/682a3428a3183812789f76ca4400c83366699cbd"}], "stats": {"total": 239, "additions": 212, "deletions": 27}, "files": [{"sha": "4e5d21049a0d98597bb419df916ad002b851fa29", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/af09d24ff66b336c8bc76b66dce19c5a4507e881/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af09d24ff66b336c8bc76b66dce19c5a4507e881/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=af09d24ff66b336c8bc76b66dce19c5a4507e881", "patch": "@@ -17,7 +17,7 @@ use rustc_session::utils::NativeLibKind;\n use rustc_session::{Session, StableCrateId};\n use rustc_span::hygiene::{ExpnHash, ExpnId};\n use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{kw, Symbol};\n \n use rustc_data_structures::sync::Lrc;\n use smallvec::SmallVec;\n@@ -295,6 +295,10 @@ pub fn provide(providers: &mut Providers) {\n             use std::collections::vec_deque::VecDeque;\n \n             let mut visible_parent_map: DefIdMap<DefId> = Default::default();\n+            // This is a secondary visible_parent_map, storing the DefId of parents that re-export\n+            // the child as `_`. Since we prefer parents that don't do this, merge this map at the\n+            // end, only if we're missing any keys from the former.\n+            let mut fallback_map: DefIdMap<DefId> = Default::default();\n \n             // Issue 46112: We want the map to prefer the shortest\n             // paths when reporting the path to an item. Therefore we\n@@ -317,12 +321,17 @@ pub fn provide(providers: &mut Providers) {\n                 bfs_queue.push_back(DefId { krate: cnum, index: CRATE_DEF_INDEX });\n             }\n \n-            let mut add_child = |bfs_queue: &mut VecDeque<_>, child: &Export, parent: DefId| {\n-                if !child.vis.is_public() {\n+            let mut add_child = |bfs_queue: &mut VecDeque<_>, export: &Export, parent: DefId| {\n+                if !export.vis.is_public() {\n                     return;\n                 }\n \n-                if let Some(child) = child.res.opt_def_id() {\n+                if let Some(child) = export.res.opt_def_id() {\n+                    if export.ident.name == kw::Underscore {\n+                        fallback_map.insert(child, parent);\n+                        return;\n+                    }\n+\n                     match visible_parent_map.entry(child) {\n                         Entry::Occupied(mut entry) => {\n                             // If `child` is defined in crate `cnum`, ensure\n@@ -345,6 +354,12 @@ pub fn provide(providers: &mut Providers) {\n                 }\n             }\n \n+            // Fill in any missing entries with the (less preferable) path ending in `::_`.\n+            // We still use this path in a diagnostic that suggests importing `::*`.\n+            for (child, parent) in fallback_map {\n+                visible_parent_map.entry(child).or_insert(parent);\n+            }\n+\n             visible_parent_map\n         },\n "}, {"sha": "47a9234419c2d9ca5c066bbf5dba383ae1c915d4", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/af09d24ff66b336c8bc76b66dce19c5a4507e881/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af09d24ff66b336c8bc76b66dce19c5a4507e881/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=af09d24ff66b336c8bc76b66dce19c5a4507e881", "patch": "@@ -319,6 +319,9 @@ pub trait PrettyPrinter<'tcx>:\n     ///\n     /// `callers` is a chain of visible_parent's leading to `def_id`,\n     /// to support cycle detection during recursion.\n+    ///\n+    /// This method returns false if we can't print the visible path, so\n+    /// `print_def_path` can fall back on the item's real definition path.\n     fn try_print_visible_def_path_recur(\n         mut self,\n         def_id: DefId,\n@@ -405,19 +408,7 @@ pub trait PrettyPrinter<'tcx>:\n             Some(parent) => parent,\n             None => return Ok((self, false)),\n         };\n-        if callers.contains(&visible_parent) {\n-            return Ok((self, false));\n-        }\n-        callers.push(visible_parent);\n-        // HACK(eddyb) this bypasses `path_append`'s prefix printing to avoid\n-        // knowing ahead of time whether the entire path will succeed or not.\n-        // To support printers that do not implement `PrettyPrinter`, a `Vec` or\n-        // linked list on the stack would need to be built, before any printing.\n-        match self.try_print_visible_def_path_recur(visible_parent, callers)? {\n-            (cx, false) => return Ok((cx, false)),\n-            (cx, true) => self = cx,\n-        }\n-        callers.pop();\n+\n         let actual_parent = self.tcx().parent(def_id);\n         debug!(\n             \"try_print_visible_def_path: visible_parent={:?} actual_parent={:?}\",\n@@ -463,14 +454,21 @@ pub trait PrettyPrinter<'tcx>:\n             // `visible_parent_map`), looking for the specific child we currently have and then\n             // have access to the re-exported name.\n             DefPathData::TypeNs(ref mut name) if Some(visible_parent) != actual_parent => {\n+                // Item might be re-exported several times, but filter for the one\n+                // that's public and whose identifier isn't `_`.\n                 let reexport = self\n                     .tcx()\n                     .item_children(visible_parent)\n                     .iter()\n-                    .find(|child| child.res.opt_def_id() == Some(def_id))\n+                    .filter(|child| child.res.opt_def_id() == Some(def_id))\n+                    .find(|child| child.vis.is_public() && child.ident.name != kw::Underscore)\n                     .map(|child| child.ident.name);\n-                if let Some(reexport) = reexport {\n-                    *name = reexport;\n+\n+                if let Some(new_name) = reexport {\n+                    *name = new_name;\n+                } else {\n+                    // There is no name that is public and isn't `_`, so bail.\n+                    return Ok((self, false));\n                 }\n             }\n             // Re-exported `extern crate` (#43189).\n@@ -481,6 +479,20 @@ pub trait PrettyPrinter<'tcx>:\n         }\n         debug!(\"try_print_visible_def_path: data={:?}\", data);\n \n+        if callers.contains(&visible_parent) {\n+            return Ok((self, false));\n+        }\n+        callers.push(visible_parent);\n+        // HACK(eddyb) this bypasses `path_append`'s prefix printing to avoid\n+        // knowing ahead of time whether the entire path will succeed or not.\n+        // To support printers that do not implement `PrettyPrinter`, a `Vec` or\n+        // linked list on the stack would need to be built, before any printing.\n+        match self.try_print_visible_def_path_recur(visible_parent, callers)? {\n+            (cx, false) => return Ok((cx, false)),\n+            (cx, true) => self = cx,\n+        }\n+        callers.pop();\n+\n         Ok((self.path_append(Ok, &DisambiguatedDefPathData { data, disambiguator: 0 })?, true))\n     }\n "}, {"sha": "d5a4de86d4d1eea4d3ea32967c4aadf5fdee1903", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 68, "deletions": 7, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/af09d24ff66b336c8bc76b66dce19c5a4507e881/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af09d24ff66b336c8bc76b66dce19c5a4507e881/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=af09d24ff66b336c8bc76b66dce19c5a4507e881", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::fast_reject::{simplify_type, SimplifyParams, StripReferences};\n use rustc_middle::ty::print::with_crate_prefix;\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_span::lev_distance;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{source_map, FileName, MultiSpan, Span, Symbol};\n@@ -1310,25 +1310,66 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         mut msg: String,\n         candidates: Vec<DefId>,\n     ) {\n+        let parent_map = self.tcx.visible_parent_map(());\n+\n+        // Separate out candidates that must be imported with a glob, because they are named `_`\n+        // and cannot be referred with their identifier.\n+        let (candidates, globs): (Vec<_>, Vec<_>) = candidates.into_iter().partition(|trait_did| {\n+            if let Some(parent_did) = parent_map.get(trait_did) {\n+                // If the item is re-exported as `_`, we should suggest a glob-import instead.\n+                if Some(*parent_did) != self.tcx.parent(*trait_did)\n+                    && self\n+                        .tcx\n+                        .item_children(*parent_did)\n+                        .iter()\n+                        .filter(|child| child.res.opt_def_id() == Some(*trait_did))\n+                        .all(|child| child.ident.name == kw::Underscore)\n+                {\n+                    return false;\n+                }\n+            }\n+\n+            true\n+        });\n+\n         let module_did = self.tcx.parent_module(self.body_id);\n         let (span, found_use) = find_use_placement(self.tcx, module_did);\n         if let Some(span) = span {\n-            let path_strings = candidates.iter().map(|did| {\n+            let path_strings = candidates.iter().map(|trait_did| {\n                 // Produce an additional newline to separate the new use statement\n                 // from the directly following item.\n                 let additional_newline = if found_use { \"\" } else { \"\\n\" };\n                 format!(\n                     \"use {};\\n{}\",\n-                    with_crate_prefix(|| self.tcx.def_path_str(*did)),\n+                    with_crate_prefix(|| self.tcx.def_path_str(*trait_did)),\n                     additional_newline\n                 )\n             });\n \n-            err.span_suggestions(span, &msg, path_strings, Applicability::MaybeIncorrect);\n+            let glob_path_strings = globs.iter().map(|trait_did| {\n+                let parent_did = parent_map.get(trait_did).unwrap();\n+\n+                // Produce an additional newline to separate the new use statement\n+                // from the directly following item.\n+                let additional_newline = if found_use { \"\" } else { \"\\n\" };\n+                format!(\n+                    \"use {}::*; // trait {}\\n{}\",\n+                    with_crate_prefix(|| self.tcx.def_path_str(*parent_did)),\n+                    self.tcx.item_name(*trait_did),\n+                    additional_newline\n+                )\n+            });\n+\n+            err.span_suggestions(\n+                span,\n+                &msg,\n+                path_strings.chain(glob_path_strings),\n+                Applicability::MaybeIncorrect,\n+            );\n         } else {\n-            let limit = if candidates.len() == 5 { 5 } else { 4 };\n+            let limit = if candidates.len() + globs.len() == 5 { 5 } else { 4 };\n             for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n-                if candidates.len() > 1 {\n+                if candidates.len() + globs.len() > 1 {\n                     msg.push_str(&format!(\n                         \"\\ncandidate #{}: `use {};`\",\n                         i + 1,\n@@ -1341,8 +1382,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ));\n                 }\n             }\n+            for (i, trait_did) in\n+                globs.iter().take(limit.saturating_sub(candidates.len())).enumerate()\n+            {\n+                let parent_did = parent_map.get(trait_did).unwrap();\n+\n+                if candidates.len() + globs.len() > 1 {\n+                    msg.push_str(&format!(\n+                        \"\\ncandidate #{}: `use {}::*; // trait {}`\",\n+                        candidates.len() + i + 1,\n+                        with_crate_prefix(|| self.tcx.def_path_str(*parent_did)),\n+                        self.tcx.item_name(*trait_did),\n+                    ));\n+                } else {\n+                    msg.push_str(&format!(\n+                        \"\\n`use {}::*; // trait {}`\",\n+                        with_crate_prefix(|| self.tcx.def_path_str(*parent_did)),\n+                        self.tcx.item_name(*trait_did),\n+                    ));\n+                }\n+            }\n             if candidates.len() > limit {\n-                msg.push_str(&format!(\"\\nand {} others\", candidates.len() - limit));\n+                msg.push_str(&format!(\"\\nand {} others\", candidates.len() + globs.len() - limit));\n             }\n             err.note(&msg);\n         }"}, {"sha": "2a25d60acff7bf9556cdf6d26a3a50910f4c5667", "filename": "src/test/ui/imports/auxiliary/overlapping_pub_trait_source.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Foverlapping_pub_trait_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Foverlapping_pub_trait_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Foverlapping_pub_trait_source.rs?ref=af09d24ff66b336c8bc76b66dce19c5a4507e881", "patch": "@@ -0,0 +1,13 @@\n+/* This crate declares an item as both `prelude::*` and `m::Tr`.\n+ * The compiler should always suggest `m::Tr`. */\n+\n+pub struct S;\n+\n+pub mod prelude {\n+    pub use crate::m::Tr as _;\n+}\n+\n+pub mod m {\n+    pub trait Tr { fn method(&self); }\n+    impl Tr for crate::S { fn method(&self) {} }\n+}"}, {"sha": "d73c9a795b673c04e4d31f10960b5ea172a00908", "filename": "src/test/ui/imports/auxiliary/unnamed_pub_trait_source.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Funnamed_pub_trait_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Funnamed_pub_trait_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Funnamed_pub_trait_source.rs?ref=af09d24ff66b336c8bc76b66dce19c5a4507e881", "patch": "@@ -0,0 +1,13 @@\n+/* This crate declares an item that is unnamed.\n+ * Its only public path is through `prelude::*`. */\n+\n+pub struct S;\n+\n+mod m {\n+    pub trait Tr { fn method(&self); }\n+    impl Tr for crate::S { fn method(&self) {} }\n+}\n+\n+pub mod prelude {\n+    pub use crate::m::Tr as _;\n+}"}, {"sha": "f5f5d4ed3804fe8c008f4d21e95d1baf09858813", "filename": "src/test/ui/imports/overlapping_pub_trait.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.rs?ref=af09d24ff66b336c8bc76b66dce19c5a4507e881", "patch": "@@ -0,0 +1,15 @@\n+// aux-build:overlapping_pub_trait_source.rs\n+\n+/*\n+ * This crate declares two public paths, `m::Tr` and `prelude::_`. Make sure we prefer the former.\n+ */\n+extern crate overlapping_pub_trait_source;\n+\n+fn main() {\n+    //~^ HELP the following trait is implemented but not in scope; perhaps add a `use` for it:\n+    //~| SUGGESTION overlapping_pub_trait_source::m::Tr\n+    use overlapping_pub_trait_source::S;\n+    S.method();\n+    //~^ ERROR no method named `method` found for struct `S` in the current scope [E0599]\n+    //~| HELP items from traits can only be used if the trait is in scope\n+}"}, {"sha": "d0c845a5e523f1588d7b2955818742e2fd6d22c3", "filename": "src/test/ui/imports/overlapping_pub_trait.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.stderr?ref=af09d24ff66b336c8bc76b66dce19c5a4507e881", "patch": "@@ -0,0 +1,20 @@\n+error[E0599]: no method named `method` found for struct `S` in the current scope\n+  --> $DIR/overlapping_pub_trait.rs:12:7\n+   |\n+LL |     S.method();\n+   |       ^^^^^^ method not found in `S`\n+   |\n+  ::: $DIR/auxiliary/overlapping_pub_trait_source.rs:11:23\n+   |\n+LL |     pub trait Tr { fn method(&self); }\n+   |                       ------ the method is available for `S` here\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n+   |\n+LL | use overlapping_pub_trait_source::m::Tr;\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "b06b1e1d07dced7d1c671982a69aed9583da0bc5", "filename": "src/test/ui/imports/unnamed_pub_trait.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.rs?ref=af09d24ff66b336c8bc76b66dce19c5a4507e881", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:unnamed_pub_trait_source.rs\n+\n+/*\n+ * This crate declares an unnameable public path for our item. Make sure we don't suggest\n+ * importing it by name, and instead we suggest importing it by glob.\n+ */\n+extern crate unnamed_pub_trait_source;\n+\n+fn main() {\n+    //~^ HELP the following trait is implemented but not in scope; perhaps add a `use` for it:\n+    //~| SUGGESTION unnamed_pub_trait_source::prelude::*; // trait Tr\n+    use unnamed_pub_trait_source::S;\n+    S.method();\n+    //~^ ERROR no method named `method` found for struct `S` in the current scope [E0599]\n+    //~| HELP items from traits can only be used if the trait is in scope\n+}"}, {"sha": "319dfd7e1b28b9e952d9513565f20a3c6c26e853", "filename": "src/test/ui/imports/unnamed_pub_trait.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af09d24ff66b336c8bc76b66dce19c5a4507e881/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.stderr?ref=af09d24ff66b336c8bc76b66dce19c5a4507e881", "patch": "@@ -0,0 +1,20 @@\n+error[E0599]: no method named `method` found for struct `S` in the current scope\n+  --> $DIR/unnamed_pub_trait.rs:13:7\n+   |\n+LL |     S.method();\n+   |       ^^^^^^ method not found in `S`\n+   |\n+  ::: $DIR/auxiliary/unnamed_pub_trait_source.rs:7:23\n+   |\n+LL |     pub trait Tr { fn method(&self); }\n+   |                       ------ the method is available for `S` here\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n+   |\n+LL | use unnamed_pub_trait_source::prelude::*; // trait Tr\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}]}