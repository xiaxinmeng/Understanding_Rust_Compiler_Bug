{"sha": "7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOThjZTlkNTI3NjI1ZjhhOWZkZWIwYmYyZTVlOTJiOWNkNDkyNzQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-08-27T21:33:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-27T21:33:08Z"}, "message": "Merge pull request #1925 from topecongiro/enhance-comment\n\nEnhance comment formatting", "tree": {"sha": "875121029003d3915b8871df1ff886699bcb4ec6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/875121029003d3915b8871df1ff886699bcb4ec6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "html_url": "https://github.com/rust-lang/rust/commit/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b90fb140f37fa0340ecb2521ff1859d9a39f933", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b90fb140f37fa0340ecb2521ff1859d9a39f933", "html_url": "https://github.com/rust-lang/rust/commit/4b90fb140f37fa0340ecb2521ff1859d9a39f933"}, {"sha": "1015dd8860b625b4d1d5c9462145044d26654c73", "url": "https://api.github.com/repos/rust-lang/rust/commits/1015dd8860b625b4d1d5c9462145044d26654c73", "html_url": "https://github.com/rust-lang/rust/commit/1015dd8860b625b4d1d5c9462145044d26654c73"}], "stats": {"total": 356, "additions": 232, "deletions": 124}, "files": [{"sha": "097b88644fa1e531f2ab91c8b6032a41e2beb18d", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -7,7 +7,7 @@ description = \"Tool to find and fix Rust formatting issues\"\n repository = \"https://github.com/rust-lang-nursery/rustfmt\"\n readme = \"README.md\"\n license = \"Apache-2.0/MIT\"\n-include = [\"src/*.rs\", \"Cargo.toml\", \"build.rs\", \"LICENSE-*\"]\n+include = [\"src/**\", \"Cargo.toml\", \"build.rs\", \"LICENSE-*\"]\n build = \"build.rs\"\n categories = [\"development-tools\"]\n "}, {"sha": "aa078f4dbf7cf93280385e3631d7300dea2b6c6a", "filename": "src/comment.rs", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -153,11 +153,10 @@ pub fn combine_strs_with_missing_comments(\n     let mut one_line_width =\n         last_line_width(prev_str) + first_line_width(next_str) + first_sep.len();\n \n-    let original_snippet = context.snippet(span);\n-    let trimmed_snippet = original_snippet.trim();\n     let indent_str = shape.indent.to_string(context.config);\n+    let missing_comment = try_opt!(rewrite_missing_comment(span, shape, context));\n \n-    if trimmed_snippet.is_empty() {\n+    if missing_comment.is_empty() {\n         if allow_extend && prev_str.len() + first_sep.len() + next_str.len() <= shape.width {\n             return Some(format!(\"{}{}{}\", prev_str, first_sep, next_str));\n         } else {\n@@ -175,18 +174,13 @@ pub fn combine_strs_with_missing_comments(\n     // Peek the the original source code and find out whether there is a newline between the first\n     // expression and the second expression or the missing comment. We will preserve the orginal\n     // layout whenever possible.\n+    let original_snippet = context.snippet(span);\n     let prefer_same_line = if let Some(pos) = original_snippet.chars().position(|c| c == '/') {\n         !original_snippet[..pos].contains('\\n')\n     } else {\n         !original_snippet.contains('\\n')\n     };\n \n-    let missing_comment = try_opt!(rewrite_comment(\n-        trimmed_snippet,\n-        false,\n-        shape,\n-        context.config\n-    ));\n     one_line_width -= first_sep.len();\n     let first_sep = if prev_str.is_empty() || missing_comment.is_empty() {\n         String::new()\n@@ -365,6 +359,50 @@ fn rewrite_comment_inner(\n     Some(result)\n }\n \n+/// Given the span, rewrite the missing comment inside it if available.\n+/// Note that the given span must only include comments (or leading/trailing whitespaces).\n+pub fn rewrite_missing_comment(\n+    span: Span,\n+    shape: Shape,\n+    context: &RewriteContext,\n+) -> Option<String> {\n+    let missing_snippet = context.snippet(span);\n+    let trimmed_snippet = missing_snippet.trim();\n+    if !trimmed_snippet.is_empty() {\n+        rewrite_comment(trimmed_snippet, false, shape, context.config)\n+    } else {\n+        Some(String::new())\n+    }\n+}\n+\n+/// Recover the missing comments in the specified span, if available.\n+/// The layout of the comments will be preserved as long as it does not break the code\n+/// and its total width does not exceed the max width.\n+pub fn recover_missing_comment_in_span(\n+    span: Span,\n+    shape: Shape,\n+    context: &RewriteContext,\n+    used_width: usize,\n+) -> Option<String> {\n+    let missing_comment = try_opt!(rewrite_missing_comment(span, shape, context));\n+    if missing_comment.is_empty() {\n+        Some(String::new())\n+    } else {\n+        let missing_snippet = context.snippet(span);\n+        let pos = missing_snippet.chars().position(|c| c == '/').unwrap_or(0);\n+        // 1 = ` `\n+        let total_width = missing_comment.len() + used_width + 1;\n+        let force_new_line_before_comment =\n+            missing_snippet[..pos].contains('\\n') || total_width > context.config.max_width();\n+        let sep = if force_new_line_before_comment {\n+            format!(\"\\n{}\", shape.indent.to_string(context.config))\n+        } else {\n+            String::from(\" \")\n+        };\n+        Some(format!(\"{}{}\", sep, missing_comment))\n+    }\n+}\n+\n /// Trims whitespace and aligns to indent, but otherwise does not change comments.\n fn light_rewrite_comment(orig: &str, offset: Indent, config: &Config) -> Option<String> {\n     let lines: Vec<&str> = orig.lines()"}, {"sha": "1bb910b61b3ab1b793596e58ffa10febaee5c9bc", "filename": "src/expr.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -20,7 +20,7 @@ use {Indent, Shape, Spanned};\n use chains::rewrite_chain;\n use codemap::{LineRangeUtils, SpanUtils};\n use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n-              rewrite_comment, FindUncommented};\n+              rewrite_comment, rewrite_missing_comment, FindUncommented};\n use config::{Config, ControlBraceStyle, IndentStyle, MultilineStyle, Style};\n use items::{span_hi_for_arg, span_lo_for_arg};\n use lists::{definitive_tactic, itemize_list, shape_for_tactic, struct_lit_formatting,\n@@ -1195,9 +1195,13 @@ impl<'a> ControlFlow<'a> {\n             mk_sp(self.block.span.lo, self.block.span.lo)\n         };\n \n-        // for event in event\n+        // `for event in event`\n+        // Do not include label in the span.\n+        let lo = self.label.map_or(self.span.lo, |label| label.span.hi);\n         let between_kwd_cond = mk_sp(\n-            context.codemap.span_after(self.span, self.keyword.trim()),\n+            context\n+                .codemap\n+                .span_after(mk_sp(lo, self.span.hi), self.keyword.trim()),\n             self.pat\n                 .map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n                     p.span.lo\n@@ -1378,21 +1382,13 @@ fn rewrite_label(label: Option<ast::SpannedIdent>) -> String {\n }\n \n fn extract_comment(span: Span, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    let comment_str = context.snippet(span);\n-    if contains_comment(&comment_str) {\n-        let comment = try_opt!(rewrite_comment(\n-            comment_str.trim(),\n-            false,\n-            shape,\n-            context.config,\n-        ));\n-        Some(format!(\n+    match rewrite_missing_comment(span, shape, context) {\n+        Some(ref comment) if !comment.is_empty() => Some(format!(\n             \"\\n{indent}{}\\n{indent}\",\n             comment,\n             indent = shape.indent.to_string(context.config)\n-        ))\n-    } else {\n-        None\n+        )),\n+        _ => None,\n     }\n }\n "}, {"sha": "94a13a502eb64c315fb42ed1a38e1dc355e13aed", "filename": "src/items.rs", "status": "modified", "additions": 75, "deletions": 74, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -19,7 +19,7 @@ use syntax::codemap::{BytePos, Span};\n use {Indent, Shape, Spanned};\n use codemap::{LineRangeUtils, SpanUtils};\n use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n-              rewrite_comment, FindUncommented};\n+              recover_missing_comment_in_span, rewrite_missing_comment, FindUncommented};\n use config::{BraceStyle, Config, Density, IndentStyle, ReturnIndent, Style};\n use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs,\n            rewrite_call_inner, ExprType};\n@@ -66,7 +66,7 @@ impl Rewrite for ast::Local {\n \n         // String that is placed within the assignment pattern and expression.\n         let infix = {\n-            let mut infix = String::new();\n+            let mut infix = String::with_capacity(32);\n \n             if let Some(ref ty) = self.ty {\n                 let separator = type_annotation_separator(context.config);\n@@ -517,8 +517,10 @@ pub fn format_impl(\n     where_span_end: Option<BytePos>,\n ) -> Option<String> {\n     if let ast::ItemKind::Impl(_, _, _, ref generics, _, ref self_ty, ref items) = item.node {\n-        let mut result = String::new();\n+        let mut result = String::with_capacity(128);\n         let ref_and_type = try_opt!(format_impl_ref_and_type(context, item, offset));\n+        let indent_str = offset.to_string(context.config);\n+        let sep = format!(\"\\n{}\", &indent_str);\n         result.push_str(&ref_and_type);\n \n         let where_budget = if result.contains('\\n') {\n@@ -543,6 +545,24 @@ pub fn format_impl(\n             option,\n         ));\n \n+        // If there is no where clause, we may have missing comments between the trait name and\n+        // the opening brace.\n+        if generics.where_clause.predicates.is_empty() {\n+            if let Some(hi) = where_span_end {\n+                match recover_missing_comment_in_span(\n+                    mk_sp(self_ty.span.hi, hi),\n+                    Shape::indented(offset, context.config),\n+                    context,\n+                    last_line_width(&result),\n+                ) {\n+                    Some(ref missing_comment) if !missing_comment.is_empty() => {\n+                        result.push_str(missing_comment);\n+                    }\n+                    _ => (),\n+                }\n+            }\n+        }\n+\n         if try_opt!(is_impl_single_line(\n             context,\n             &items,\n@@ -551,9 +571,8 @@ pub fn format_impl(\n             &item,\n         )) {\n             result.push_str(&where_clause_str);\n-            if where_clause_str.contains('\\n') {\n-                let white_space = offset.to_string(context.config);\n-                result.push_str(&format!(\"\\n{}{{\\n{}}}\", &white_space, &white_space));\n+            if where_clause_str.contains('\\n') || last_line_contains_single_line_comment(&result) {\n+                result.push_str(&format!(\"{}{{{}}}\", &sep, &sep));\n             } else {\n                 result.push_str(\" {}\");\n             }\n@@ -569,14 +588,11 @@ pub fn format_impl(\n         result.push_str(&where_clause_str);\n \n         match context.config.item_brace_style() {\n-            BraceStyle::AlwaysNextLine => {\n-                result.push('\\n');\n-                result.push_str(&offset.to_string(context.config));\n-            }\n+            _ if last_line_contains_single_line_comment(&result) => result.push_str(&sep),\n+            BraceStyle::AlwaysNextLine => result.push_str(&sep),\n             BraceStyle::PreferSameLine => result.push(' '),\n             BraceStyle::SameLineWhere => if !where_clause_str.is_empty() {\n-                result.push('\\n');\n-                result.push_str(&offset.to_string(context.config));\n+                result.push_str(&sep);\n             } else {\n                 result.push(' ');\n             },\n@@ -610,8 +626,7 @@ pub fn format_impl(\n         }\n \n         if result.chars().last().unwrap() == '{' {\n-            result.push('\\n');\n-            result.push_str(&offset.to_string(context.config));\n+            result.push_str(&sep);\n         }\n         result.push('}');\n \n@@ -632,7 +647,7 @@ fn is_impl_single_line(\n     let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n \n     Some(\n-        context.config.impl_empty_single_line() && items.is_empty() &&\n+        context.config.impl_empty_single_line() && items.is_empty() && !result.contains('\\n') &&\n             result.len() + where_clause_str.len() <= context.config.max_width() &&\n             !contains_comment(&snippet[open_pos..]),\n     )\n@@ -653,7 +668,7 @@ fn format_impl_ref_and_type(\n         _,\n     ) = item.node\n     {\n-        let mut result = String::new();\n+        let mut result = String::with_capacity(128);\n \n         result.push_str(&format_visibility(&item.vis));\n         result.push_str(&format_defaultness(defaultness));\n@@ -853,7 +868,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n     if let ast::ItemKind::Trait(unsafety, ref generics, ref type_param_bounds, ref trait_items) =\n         item.node\n     {\n-        let mut result = String::new();\n+        let mut result = String::with_capacity(128);\n         let header = format!(\n             \"{}{}trait {}\",\n             format_visibility(&item.vis),\n@@ -910,14 +925,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 .checked_sub(last_line_width(&result))\n         );\n         let pos_before_where = if type_param_bounds.is_empty() {\n-            if generics.where_clause.predicates.is_empty() {\n-                // We do not use this, so it does not matter\n-                item.span.lo\n-            } else {\n-                let snippet = context.snippet(item.span);\n-                let where_pos = snippet.find_uncommented(\"where\");\n-                item.span.lo + where_pos.map_or(BytePos(0), |p| BytePos(p as u32))\n-            }\n+            generics.where_clause.span.lo\n         } else {\n             type_param_bounds[type_param_bounds.len() - 1].span().hi\n         };\n@@ -946,7 +954,33 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         }\n         result.push_str(&where_clause_str);\n \n+        if generics.where_clause.predicates.is_empty() {\n+            let item_snippet = context.snippet(item.span);\n+            if let Some(lo) = item_snippet.chars().position(|c| c == '/') {\n+                // 1 = `{`\n+                let comment_hi = body_lo - BytePos(1);\n+                let comment_lo = item.span.lo + BytePos(lo as u32);\n+                if comment_lo < comment_hi {\n+                    match recover_missing_comment_in_span(\n+                        mk_sp(comment_lo, comment_hi),\n+                        Shape::indented(offset, context.config),\n+                        context,\n+                        last_line_width(&result),\n+                    ) {\n+                        Some(ref missing_comment) if !missing_comment.is_empty() => {\n+                            result.push_str(missing_comment);\n+                        }\n+                        _ => (),\n+                    }\n+                }\n+            }\n+        }\n+\n         match context.config.item_brace_style() {\n+            _ if last_line_contains_single_line_comment(&result) => {\n+                result.push('\\n');\n+                result.push_str(&offset.to_string(context.config));\n+            }\n             BraceStyle::AlwaysNextLine => {\n                 result.push('\\n');\n                 result.push_str(&offset.to_string(context.config));\n@@ -1231,7 +1265,7 @@ pub fn rewrite_type_alias(\n     vis: &ast::Visibility,\n     span: Span,\n ) -> Option<String> {\n-    let mut result = String::new();\n+    let mut result = String::with_capacity(128);\n \n     result.push_str(&format_visibility(vis));\n     result.push_str(\"type \");\n@@ -2006,33 +2040,17 @@ fn rewrite_fn_base(\n     // args and `{`.\n     if where_clause_str.is_empty() {\n         if let ast::FunctionRetTy::Default(ret_span) = fd.output {\n-            let sp = mk_sp(args_span.hi, ret_span.hi);\n-            let missing_snippet = context.snippet(sp);\n-            let trimmed_snippet = missing_snippet.trim();\n-            let missing_comment = if trimmed_snippet.is_empty() {\n-                String::new()\n-            } else {\n-                try_opt!(rewrite_comment(\n-                    trimmed_snippet,\n-                    false,\n-                    Shape::indented(indent, context.config),\n-                    context.config,\n-                ))\n-            };\n-            if !missing_comment.is_empty() {\n-                let pos = missing_snippet.chars().position(|c| c == '/').unwrap_or(0);\n-                // 1 = ` `\n-                let total_width = missing_comment.len() + last_line_width(&result) + 1;\n-                let force_new_line_before_comment = missing_snippet[..pos].contains('\\n') ||\n-                    total_width > context.config.max_width();\n-                let sep = if force_new_line_before_comment {\n-                    format!(\"\\n{}\", indent.to_string(context.config))\n-                } else {\n-                    String::from(\" \")\n-                };\n-                result.push_str(&sep);\n-                result.push_str(&missing_comment);\n-                force_new_line_for_brace = true;\n+            match recover_missing_comment_in_span(\n+                mk_sp(args_span.hi, ret_span.hi),\n+                shape,\n+                context,\n+                last_line_width(&result),\n+            ) {\n+                Some(ref missing_comment) if !missing_comment.is_empty() => {\n+                    result.push_str(missing_comment);\n+                    force_new_line_for_brace = true;\n+                }\n+                _ => (),\n             }\n         }\n     }\n@@ -2683,34 +2701,17 @@ fn missing_span_before_after_where(\n     (missing_span_before, missing_span_after)\n }\n \n-fn rewrite_missing_comment_in_where(\n-    context: &RewriteContext,\n-    comment: &str,\n-    shape: Shape,\n-) -> Option<String> {\n-    let comment = comment.trim();\n-    if comment.is_empty() {\n-        Some(String::new())\n-    } else {\n-        rewrite_comment(comment, false, shape, context.config)\n-    }\n-}\n-\n fn rewrite_comments_before_after_where(\n     context: &RewriteContext,\n     span_before_where: Span,\n     span_after_where: Span,\n     shape: Shape,\n ) -> Option<(String, String)> {\n-    let before_comment = try_opt!(rewrite_missing_comment_in_where(\n-        context,\n-        &context.snippet(span_before_where),\n-        shape,\n-    ));\n-    let after_comment = try_opt!(rewrite_missing_comment_in_where(\n-        context,\n-        &context.snippet(span_after_where),\n+    let before_comment = try_opt!(rewrite_missing_comment(span_before_where, shape, context));\n+    let after_comment = try_opt!(rewrite_missing_comment(\n+        span_after_where,\n         shape.block_indent(context.config.tab_spaces()),\n+        context,\n     ));\n     Some((before_comment, after_comment))\n }"}, {"sha": "f07dad4a6ba5e204825cf0dca5d55982b8539da1", "filename": "src/visitor.rs", "status": "modified", "additions": 51, "deletions": 20, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -18,7 +18,8 @@ use syntax::parse::ParseSess;\n \n use {Indent, Shape, Spanned};\n use codemap::{LineRangeUtils, SpanUtils};\n-use comment::{contains_comment, CodeCharKind, CommentCodeSlices, FindUncommented};\n+use comment::{contains_comment, recover_missing_comment_in_span, CodeCharKind, CommentCodeSlices,\n+              FindUncommented};\n use comment::rewrite_comment;\n use config::{BraceStyle, Config};\n use expr::{format_expr, ExprType};\n@@ -919,15 +920,17 @@ impl Rewrite for ast::Attribute {\n \n impl<'a> Rewrite for [ast::Attribute] {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let mut result = String::new();\n         if self.is_empty() {\n-            return Some(result);\n+            return Some(String::new());\n         }\n+        let mut result = String::with_capacity(128);\n         let indent = shape.indent.to_string(context.config);\n \n         let mut derive_args = Vec::new();\n \n         let mut iter = self.iter().enumerate().peekable();\n+        let mut insert_new_line = true;\n+        let mut is_prev_sugared_doc = false;\n         while let Some((i, a)) = iter.next() {\n             let a_str = try_opt!(a.rewrite(context, shape));\n \n@@ -937,31 +940,61 @@ impl<'a> Rewrite for [ast::Attribute] {\n                 // This particular horror show is to preserve line breaks in between doc\n                 // comments. An alternative would be to force such line breaks to start\n                 // with the usual doc comment token.\n-                let multi_line = a_str.starts_with(\"//\") && comment.matches('\\n').count() > 1;\n-                let comment = comment.trim();\n+                let (multi_line_before, multi_line_after) = if a.is_sugared_doc ||\n+                    is_prev_sugared_doc\n+                {\n+                    // Look at before and after comment and see if there are any empty lines.\n+                    let comment_begin = comment.chars().position(|c| c == '/');\n+                    let len = comment_begin.unwrap_or(comment.len());\n+                    let mlb = comment.chars().take(len).filter(|c| *c == '\\n').count() > 1;\n+                    let mla = if comment_begin.is_none() {\n+                        mlb\n+                    } else {\n+                        let comment_end = comment.chars().rev().position(|c| !c.is_whitespace());\n+                        let len = comment_end.unwrap();\n+                        comment\n+                            .chars()\n+                            .rev()\n+                            .take(len)\n+                            .filter(|c| *c == '\\n')\n+                            .count() > 1\n+                    };\n+                    (mlb, mla)\n+                } else {\n+                    (false, false)\n+                };\n+\n+                let comment = try_opt!(recover_missing_comment_in_span(\n+                    mk_sp(self[i - 1].span.hi, a.span.lo),\n+                    shape.with_max_width(context.config),\n+                    context,\n+                    0,\n+                ));\n+\n                 if !comment.is_empty() {\n-                    let comment = try_opt!(rewrite_comment(\n-                        comment,\n-                        false,\n-                        Shape::legacy(\n-                            context.config.comment_width() - shape.indent.width(),\n-                            shape.indent,\n-                        ),\n-                        context.config,\n-                    ));\n-                    result.push_str(&indent);\n+                    if multi_line_before {\n+                        result.push('\\n');\n+                    }\n                     result.push_str(&comment);\n                     result.push('\\n');\n-                } else if multi_line {\n+                    if multi_line_after {\n+                        result.push('\\n')\n+                    }\n+                } else if insert_new_line {\n                     result.push('\\n');\n+                    if multi_line_after {\n+                        result.push('\\n')\n+                    }\n                 }\n+\n                 if derive_args.is_empty() {\n                     result.push_str(&indent);\n                 }\n+\n+                insert_new_line = true;\n             }\n \n             // Write the attribute itself.\n-            let mut insert_new_line = true;\n             if context.config.merge_derives() {\n                 // If the attribute is `#[derive(...)]`, take the arguments.\n                 if let Some(mut args) = get_derive_args(context, a) {\n@@ -982,9 +1015,7 @@ impl<'a> Rewrite for [ast::Attribute] {\n                 result.push_str(&a_str);\n             }\n \n-            if insert_new_line && i < self.len() - 1 {\n-                result.push('\\n');\n-            }\n+            is_prev_sugared_doc = a.is_sugared_doc;\n         }\n         Some(result)\n     }"}, {"sha": "fe8a5e3615b98af3eb858535c79c7fe45d03bf39", "filename": "tests/source/attrib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Fsource%2Fattrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Fsource%2Fattrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fattrib.rs?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -1,6 +1,19 @@\n // rustfmt-wrap_comments: true\n // Test attributes and doc comments are preserved.\n \n+//! Doc comment\n+\n+#![attribute]\n+\n+//! Crate doc comment\n+\n+// Comment\n+\n+// Comment on attribute\n+#![the(attribute)]\n+\n+// Another comment\n+\n #[invalid attribute]\n fn foo() {}\n "}, {"sha": "7ed858a9ca6c9123216e039c225f978b2f27b55f", "filename": "tests/source/trait.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Fsource%2Ftrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Fsource%2Ftrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ftrait.rs?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -53,3 +53,7 @@ trait FooBar<T> : Tttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt\n \n trait WhereList<T, J> where T: Foo, J: Bar {}\n \n+trait X /* comment */ {}\n+trait Y // comment\n+{\n+}"}, {"sha": "677c920ff1b3bfb1e5c92d79baa9cfc50522692b", "filename": "tests/target/attrib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Ftarget%2Fattrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Ftarget%2Fattrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fattrib.rs?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -1,6 +1,19 @@\n // rustfmt-wrap_comments: true\n // Test attributes and doc comments are preserved.\n \n+//! Doc comment\n+\n+#![attribute]\n+\n+//! Crate doc comment\n+\n+// Comment\n+\n+// Comment on attribute\n+#![the(attribute)]\n+\n+// Another comment\n+\n #[invalid attribute]\n fn foo() {}\n \n@@ -33,11 +46,12 @@ impl Bar {\n     fn f3(self) -> Dog {}\n \n     /// Blah blah bing.\n+\n     #[attrib1]\n     /// Blah blah bing.\n     #[attrib2]\n-    // Another comment that needs rewrite because it's\n-    // tooooooooooooooooooooooooooooooo loooooooooooong.\n+    // Another comment that needs rewrite because it's tooooooooooooooooooooooooooooooo\n+    // loooooooooooong.\n     /// Blah blah bing.\n     fn f4(self) -> Cat {}\n "}, {"sha": "168fb28edb99e0ebb099bb22c1aa8b1e3d9a81d2", "filename": "tests/target/comment.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Ftarget%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Ftarget%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment.rs?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -83,6 +83,7 @@ fn some_fn3() // some comment some comment some comment some comment some commen\n }\n \n fn some_fn4()\n-// some comment some comment some comment some comment some comment some comment some comment\n+// some comment some comment some comment some comment some comment some comment\n+// some comment\n {\n }"}, {"sha": "2916f083ca0fcb5f3f0150e8dae195fd0a5f1b29", "filename": "tests/target/comment4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Ftarget%2Fcomment4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Ftarget%2Fcomment4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment4.rs?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -1,5 +1,5 @@\n-#![allow(dead_code)]\n-// bar\n+#![allow(dead_code)] // bar\n+\n //! Doc comment\n fn test() {\n     // comment"}, {"sha": "7fce1d9dd76542e0f0722ea76b31687cb8edc1ac", "filename": "tests/target/impl.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Ftarget%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Ftarget%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimpl.rs?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -18,6 +18,11 @@ where\n     }\n }\n \n+impl X<T> /* comment */ {}\n+impl Y<T> // comment\n+{\n+}\n+\n impl<T> Foo for T\n // comment1\n where"}, {"sha": "a2ea54e0f03b5b19be78125d8d0846de5f13f33c", "filename": "tests/target/trait.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Ftarget%2Ftrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274/tests%2Ftarget%2Ftrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftrait.rs?ref=7298ce9d527625f8a9fdeb0bf2e5e92b9cd49274", "patch": "@@ -79,3 +79,8 @@ where\n     J: Bar,\n {\n }\n+\n+trait X /* comment */ {}\n+trait Y // comment\n+{\n+}"}]}