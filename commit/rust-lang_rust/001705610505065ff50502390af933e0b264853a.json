{"sha": "001705610505065ff50502390af933e0b264853a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMTcwNTYxMDUwNTA2NWZmNTA1MDIzOTBhZjkzM2UwYjI2NDg1M2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-08T21:01:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-08T21:01:55Z"}, "message": "auto merge of #12768 : pnkfelix/rust/fsk-devecing, r=pnkfelix\n\nChange `~[T]` to Vec<T> in librustc.  Rebased and amended version of PR #12716.\r\n\r\nOriginal author (or perhaps I should say meta-author) was @pcwalton, as is reflected in the commits.\r\n\r\nI clean up!  :)", "tree": {"sha": "30b0fc185b522e76100b172c45c4283a6c18475a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30b0fc185b522e76100b172c45c4283a6c18475a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/001705610505065ff50502390af933e0b264853a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/001705610505065ff50502390af933e0b264853a", "html_url": "https://github.com/rust-lang/rust/commit/001705610505065ff50502390af933e0b264853a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/001705610505065ff50502390af933e0b264853a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96e8c00e95b1980c429c5cfa4aae33e3cc60f3c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/96e8c00e95b1980c429c5cfa4aae33e3cc60f3c5", "html_url": "https://github.com/rust-lang/rust/commit/96e8c00e95b1980c429c5cfa4aae33e3cc60f3c5"}, {"sha": "f978c772ba99955fe8c315963768b603bb8efd41", "url": "https://api.github.com/repos/rust-lang/rust/commits/f978c772ba99955fe8c315963768b603bb8efd41", "html_url": "https://github.com/rust-lang/rust/commit/f978c772ba99955fe8c315963768b603bb8efd41"}], "stats": {"total": 3567, "additions": 2053, "deletions": 1514}, "files": [{"sha": "d297df1301ea7983d281b99357de447f7fc159ed", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -16,6 +16,7 @@ use metadata::filesearch;\n use lib::llvm::{ArchiveRef, llvm};\n \n use std::cast;\n+use std::vec_ng::Vec;\n use std::io::fs;\n use std::io;\n use std::libc;\n@@ -41,7 +42,7 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n         paths: &[&Path]) -> ProcessOutput {\n     let ar = get_ar_prog(sess);\n \n-    let mut args = ~[args.to_owned()];\n+    let mut args = vec!(args.to_owned());\n     let mut paths = paths.iter().map(|p| p.as_str().unwrap().to_owned());\n     args.extend(&mut paths);\n     debug!(\"{} {}\", ar, args.connect(\" \"));\n@@ -89,17 +90,25 @@ impl Archive {\n     }\n \n     /// Read a file in the archive\n-    pub fn read(&self, file: &str) -> ~[u8] {\n+    pub fn read(&self, file: &str) -> Vec<u8> {\n         // Apparently if \"ar p\" is used on windows, it generates a corrupt file\n         // which has bad headers and LLVM will immediately choke on it\n         if cfg!(windows) && cfg!(windows) { // FIXME(#10734) double-and\n             let loc = TempDir::new(\"rsar\").unwrap();\n             let archive = os::make_absolute(&self.dst);\n             run_ar(self.sess, \"x\", Some(loc.path()), [&archive,\n                                                       &Path::new(file)]);\n-            fs::File::open(&loc.path().join(file)).read_to_end().unwrap()\n+            let result: Vec<u8> =\n+                fs::File::open(&loc.path().join(file)).read_to_end()\n+                                                      .unwrap()\n+                                                      .move_iter()\n+                                                      .collect();\n+            result\n         } else {\n-            run_ar(self.sess, \"p\", None, [&self.dst, &Path::new(file)]).output\n+            run_ar(self.sess,\n+                   \"p\",\n+                   None,\n+                   [&self.dst, &Path::new(file)]).output.move_iter().collect()\n         }\n     }\n \n@@ -119,11 +128,11 @@ impl Archive {\n                     lto: bool) -> io::IoResult<()> {\n         let object = format!(\"{}.o\", name);\n         let bytecode = format!(\"{}.bc\", name);\n-        let mut ignore = ~[METADATA_FILENAME, bytecode.as_slice()];\n+        let mut ignore = vec!(METADATA_FILENAME, bytecode.as_slice());\n         if lto {\n             ignore.push(object.as_slice());\n         }\n-        self.add_archive(rlib, name, ignore)\n+        self.add_archive(rlib, name, ignore.as_slice())\n     }\n \n     /// Adds an arbitrary file to this archive\n@@ -143,7 +152,7 @@ impl Archive {\n     }\n \n     /// Lists all files in an archive\n-    pub fn files(&self) -> ~[~str] {\n+    pub fn files(&self) -> Vec<~str> {\n         let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n         let output = str::from_utf8(output.output).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n@@ -168,7 +177,7 @@ impl Archive {\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n         let files = try!(fs::readdir(loc.path()));\n-        let mut inputs = ~[];\n+        let mut inputs = Vec::new();\n         for file in files.iter() {\n             let filename = file.filename_str().unwrap();\n             if skip.iter().any(|s| *s == filename) { continue }\n@@ -182,7 +191,7 @@ impl Archive {\n         if inputs.len() == 0 { return Ok(()) }\n \n         // Finally, add all the renamed files to this archive\n-        let mut args = ~[&self.dst];\n+        let mut args = vec!(&self.dst);\n         args.extend(&mut inputs.iter());\n         run_ar(self.sess, \"r\", None, args.as_slice());\n         Ok(())"}, {"sha": "f86c87af726746e6da28a093755b7bbf5e6c47a8", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -15,9 +15,9 @@ use syntax::abi;\n \n pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n     let cc_args = if target_triple.contains(\"thumb\") {\n-        ~[~\"-mthumb\"]\n+        vec!(~\"-mthumb\")\n     } else {\n-        ~[~\"-marm\"]\n+        vec!(~\"-marm\")\n     };\n     return target_strs::t {\n         module_asm: ~\"\","}, {"sha": "c15c55927a9c8b6e14bbb9b2c99ceb7443525244", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -34,6 +34,7 @@ use std::str;\n use std::io;\n use std::io::Process;\n use std::io::fs;\n+use std::vec_ng::Vec;\n use flate;\n use serialize::hex::ToHex;\n use extra::tempfile::TempDir;\n@@ -106,6 +107,7 @@ pub mod write {\n     use std::io::Process;\n     use std::libc::{c_uint, c_int};\n     use std::str;\n+    use std::vec_ng::Vec;\n \n     // On android, we by default compile for armv7 processors. This enables\n     // things like double word CAS instructions (rather than emulating them)\n@@ -222,7 +224,7 @@ pub mod write {\n \n             if sess.lto() {\n                 time(sess.time_passes(), \"all lto passes\", (), |()|\n-                     lto::run(sess, llmod, tm, trans.reachable));\n+                     lto::run(sess, llmod, tm, trans.reachable.as_slice()));\n \n                 if sess.opts.cg.save_temps {\n                     output.with_extension(\"lto.bc\").with_c_str(|buf| {\n@@ -363,8 +365,8 @@ pub mod write {\n         let vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n                             sess.opts.optimize == session::Aggressive;\n \n-        let mut llvm_c_strs = ~[];\n-        let mut llvm_args = ~[];\n+        let mut llvm_c_strs = Vec::new();\n+        let mut llvm_args = Vec::new();\n         {\n             let add = |arg: &str| {\n                 let s = arg.to_c_str();\n@@ -781,8 +783,8 @@ fn remove(sess: Session, path: &Path) {\n pub fn link_binary(sess: Session,\n                    trans: &CrateTranslation,\n                    outputs: &OutputFilenames,\n-                   id: &CrateId) -> ~[Path] {\n-    let mut out_filenames = ~[];\n+                   id: &CrateId) -> Vec<Path> {\n+    let mut out_filenames = Vec::new();\n     let crate_types = sess.crate_types.borrow();\n     for &crate_type in crate_types.get().iter() {\n         let out_file = link_binary_output(sess, trans, crate_type, outputs, id);\n@@ -931,7 +933,8 @@ fn link_rlib(sess: Session,\n             // the same filename for metadata (stomping over one another)\n             let tmpdir = TempDir::new(\"rustc\").expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n-            match fs::File::create(&metadata).write(trans.metadata) {\n+            match fs::File::create(&metadata).write(trans.metadata\n+                                                         .as_slice()) {\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(format!(\"failed to write {}: {}\",\n@@ -1035,7 +1038,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n     // Invoke the system linker\n     debug!(\"{} {}\", cc_prog, cc_args.connect(\" \"));\n     let prog = time(sess.time_passes(), \"running linker\", (), |()|\n-                    Process::output(cc_prog, cc_args));\n+                    Process::output(cc_prog, cc_args.as_slice()));\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n@@ -1071,15 +1074,15 @@ fn link_args(sess: Session,\n              dylib: bool,\n              tmpdir: &Path,\n              obj_filename: &Path,\n-             out_filename: &Path) -> ~[~str] {\n+             out_filename: &Path) -> Vec<~str> {\n \n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let lib_path = sess.filesearch.get_target_lib_path();\n     let stage: ~str = ~\"-L\" + lib_path.as_str().unwrap();\n \n-    let mut args = ~[stage];\n+    let mut args = vec!(stage);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     args.push_all([\n@@ -1198,7 +1201,7 @@ fn link_args(sess: Session,\n     // where extern libraries might live, based on the\n     // addl_lib_search_paths\n     if !sess.opts.cg.no_rpath {\n-        args.push_all(rpath::get_rpath_flags(sess, out_filename));\n+        args.push_all(rpath::get_rpath_flags(sess, out_filename).as_slice());\n     }\n \n     // Stack growth requires statically linking a __morestack function\n@@ -1210,7 +1213,7 @@ fn link_args(sess: Session,\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n-    args.push_all(sess.opts.cg.link_args);\n+    args.push_all(sess.opts.cg.link_args.as_slice());\n     let used_link_args = sess.cstore.get_used_link_args();\n     let used_link_args = used_link_args.borrow();\n     for arg in used_link_args.get().iter() {\n@@ -1230,7 +1233,7 @@ fn link_args(sess: Session,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n+fn add_local_native_libraries(args: &mut Vec<~str> , sess: Session) {\n     let addl_lib_search_paths = sess.opts.addl_lib_search_paths.borrow();\n     for path in addl_lib_search_paths.get().iter() {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1263,7 +1266,7 @@ fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n+fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n                             dylib: bool, tmpdir: &Path) {\n \n     // As a limitation of the current implementation, we require that everything\n@@ -1347,7 +1350,7 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n     // returning `None` if not all libraries could be found with that\n     // preference.\n     fn get_deps(cstore: &cstore::CStore,  preference: cstore::LinkagePreference)\n-            -> Option<~[(ast::CrateNum, Path)]>\n+            -> Option<Vec<(ast::CrateNum, Path)> >\n     {\n         let crates = cstore.get_used_crates(preference);\n         if crates.iter().all(|&(_, ref p)| p.is_some()) {\n@@ -1358,8 +1361,8 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n-    fn add_static_crates(args: &mut ~[~str], sess: Session, tmpdir: &Path,\n-                         crates: ~[(ast::CrateNum, Path)]) {\n+    fn add_static_crates(args: &mut Vec<~str> , sess: Session, tmpdir: &Path,\n+                         crates: Vec<(ast::CrateNum, Path)> ) {\n         for (cnum, cratepath) in crates.move_iter() {\n             // When performing LTO on an executable output, all of the\n             // bytecode from the upstream libraries has already been\n@@ -1405,8 +1408,8 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crates(args: &mut ~[~str], sess: Session,\n-                          crates: ~[(ast::CrateNum, Path)]) {\n+    fn add_dynamic_crates(args: &mut Vec<~str> , sess: Session,\n+                          crates: Vec<(ast::CrateNum, Path)> ) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n         assert!(!sess.lto());\n@@ -1440,7 +1443,7 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-fn add_upstream_native_libraries(args: &mut ~[~str], sess: Session) {\n+fn add_upstream_native_libraries(args: &mut Vec<~str> , sess: Session) {\n     let cstore = sess.cstore;\n     cstore.iter_crate_data(|cnum, _| {\n         let libs = csearch::get_native_libraries(cstore, cnum);"}, {"sha": "bc24660e306732bb5c6ae1411d1407640861a336", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -11,6 +11,7 @@\n use back::target_strs;\n use driver::session::sess_os_to_meta_os;\n use metadata::loader::meta_section_name;\n+use std::vec_ng::Vec;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n@@ -63,6 +64,6 @@ pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::\n \n         target_triple: target_triple,\n \n-        cc_args: ~[],\n+        cc_args: Vec::new(),\n     };\n }"}, {"sha": "9b543bb50cc5ca9dc22a1b09ac2edff60603952a", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -15,21 +15,22 @@ use metadata::filesearch;\n \n use collections::HashSet;\n use std::{os, vec};\n+use std::vec_ng::Vec;\n use syntax::abi;\n \n fn not_win32(os: abi::Os) -> bool {\n   os != abi::OsWin32\n }\n \n-pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> ~[~str] {\n+pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> Vec<~str> {\n     let os = sess.targ_cfg.os;\n \n     // No rpath on windows\n     if os == abi::OsWin32 {\n-        return ~[];\n+        return Vec::new();\n     }\n \n-    let mut flags = ~[];\n+    let mut flags = Vec::new();\n \n     if sess.targ_cfg.os == abi::OsFreebsd {\n         flags.push_all([~\"-Wl,-rpath,/usr/local/lib/gcc46\",\n@@ -49,7 +50,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> ~[~str] {\n \n     let rpaths = get_rpaths(os, sysroot, output, libs,\n                             sess.opts.target_triple);\n-    flags.push_all(rpaths_to_flags(rpaths));\n+    flags.push_all(rpaths_to_flags(rpaths.as_slice()).as_slice());\n     flags\n }\n \n@@ -60,8 +61,8 @@ fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n     p\n }\n \n-pub fn rpaths_to_flags(rpaths: &[~str]) -> ~[~str] {\n-    let mut ret = ~[];\n+pub fn rpaths_to_flags(rpaths: &[~str]) -> Vec<~str> {\n+    let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n         ret.push(\"-Wl,-rpath,\" + *rpath);\n     }\n@@ -72,7 +73,7 @@ fn get_rpaths(os: abi::Os,\n               sysroot: &Path,\n               output: &Path,\n               libs: &[Path],\n-              target_triple: &str) -> ~[~str] {\n+              target_triple: &str) -> Vec<~str> {\n     debug!(\"sysroot: {}\", sysroot.display());\n     debug!(\"output: {}\", output.display());\n     debug!(\"libs:\");\n@@ -91,7 +92,7 @@ fn get_rpaths(os: abi::Os,\n     let abs_rpaths = get_absolute_rpaths(libs);\n \n     // And a final backup rpath to the global library location.\n-    let fallback_rpaths = ~[get_install_prefix_rpath(target_triple)];\n+    let fallback_rpaths = vec!(get_install_prefix_rpath(target_triple));\n \n     fn log_rpaths(desc: &str, rpaths: &[~str]) {\n         debug!(\"{} rpaths:\", desc);\n@@ -100,22 +101,22 @@ fn get_rpaths(os: abi::Os,\n         }\n     }\n \n-    log_rpaths(\"relative\", rel_rpaths);\n-    log_rpaths(\"absolute\", abs_rpaths);\n-    log_rpaths(\"fallback\", fallback_rpaths);\n+    log_rpaths(\"relative\", rel_rpaths.as_slice());\n+    log_rpaths(\"absolute\", abs_rpaths.as_slice());\n+    log_rpaths(\"fallback\", fallback_rpaths.as_slice());\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(abs_rpaths);\n-    rpaths.push_all(fallback_rpaths);\n+    rpaths.push_all(abs_rpaths.as_slice());\n+    rpaths.push_all(fallback_rpaths.as_slice());\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(rpaths);\n+    let rpaths = minimize_rpaths(rpaths.as_slice());\n     return rpaths;\n }\n \n fn get_rpaths_relative_to_output(os: abi::Os,\n                                  output: &Path,\n-                                 libs: &[Path]) -> ~[~str] {\n+                                 libs: &[Path]) -> Vec<~str> {\n     libs.iter().map(|a| get_rpath_relative_to_output(os, output, a)).collect()\n }\n \n@@ -145,7 +146,7 @@ pub fn get_rpath_relative_to_output(os: abi::Os,\n     prefix+\"/\"+relative.as_str().expect(\"non-utf8 component in path\")\n }\n \n-fn get_absolute_rpaths(libs: &[Path]) -> ~[~str] {\n+fn get_absolute_rpaths(libs: &[Path]) -> Vec<~str> {\n     libs.iter().map(|a| get_absolute_rpath(a)).collect()\n }\n \n@@ -167,9 +168,9 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> ~str {\n     path.as_str().expect(\"non-utf8 component in rpath\").to_owned()\n }\n \n-pub fn minimize_rpaths(rpaths: &[~str]) -> ~[~str] {\n+pub fn minimize_rpaths(rpaths: &[~str]) -> Vec<~str> {\n     let mut set = HashSet::new();\n-    let mut minimized = ~[];\n+    let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {\n         if set.insert(rpath.as_slice()) {\n             minimized.push(rpath.clone());\n@@ -190,7 +191,7 @@ mod test {\n     #[test]\n     fn test_rpaths_to_flags() {\n         let flags = rpaths_to_flags([~\"path1\", ~\"path2\"]);\n-        assert_eq!(flags, ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n+        assert_eq!(flags, vec!(~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"));\n     }\n \n     #[test]"}, {"sha": "c2a1a5598d5b08267298c7947fcb2fe5fb6a23d3", "filename": "src/librustc/back/target_strs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Ftarget_strs.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -10,10 +10,12 @@\n \n #[allow(non_camel_case_types)];\n \n+use std::vec_ng::Vec;\n+\n pub struct t {\n     module_asm: ~str,\n     meta_sect_name: ~str,\n     data_layout: ~str,\n     target_triple: ~str,\n-    cc_args: ~[~str],\n+    cc_args: Vec<~str> ,\n }"}, {"sha": "9b22c82e91776a9f01061a694e736e9f755e1f7e", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -46,6 +46,6 @@ pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::\n \n         target_triple: target_triple,\n \n-        cc_args: ~[~\"-m32\"],\n+        cc_args: vec!(~\"-m32\"),\n     };\n }"}, {"sha": "524ae5e55248485c8b03b8bb16fbc364d4d2acbf", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -54,6 +54,6 @@ pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::\n \n         target_triple: target_triple,\n \n-        cc_args: ~[~\"-m64\"],\n+        cc_args: vec!(~\"-m64\"),\n     };\n }"}, {"sha": "2a92ef496c7be2c1a4cb2c44889f9c6eb621a191", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -11,8 +11,8 @@\n \n use back::link;\n use back::{arm, x86, x86_64, mips};\n-use driver::session::{Aggressive, CrateTypeExecutable, FullDebugInfo, LimitedDebugInfo,\n-                      NoDebugInfo};\n+use driver::session::{Aggressive, CrateTypeExecutable, CrateType,\n+                      FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use driver::session::{Session, Session_, No, Less, Default};\n use driver::session;\n use front;\n@@ -36,7 +36,6 @@ use std::io;\n use std::io::fs;\n use std::io::MemReader;\n use std::os;\n-use std::vec;\n use std::vec_ng::Vec;\n use std::vec_ng;\n use collections::HashMap;\n@@ -145,7 +144,7 @@ pub fn build_configuration(sess: Session) -> ast::CrateConfig {\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: ~[~str])\n+fn parse_cfgspecs(cfgspecs: Vec<~str> )\n                   -> ast::CrateConfig {\n     cfgspecs.move_iter().map(|s| {\n         let sess = parse::new_parse_sess();\n@@ -399,8 +398,8 @@ pub struct CrateTranslation {\n     module: ModuleRef,\n     metadata_module: ModuleRef,\n     link: LinkMeta,\n-    metadata: ~[u8],\n-    reachable: ~[~str],\n+    metadata: Vec<u8> ,\n+    reachable: Vec<~str> ,\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n@@ -434,7 +433,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             link::write::run_passes(sess,\n                                     trans,\n-                                    sess.opts.output_types,\n+                                    sess.opts.output_types.as_slice(),\n                                     outputs));\n     }\n }\n@@ -489,7 +488,7 @@ fn write_out_deps(sess: Session,\n                   krate: &ast::Crate) -> io::IoResult<()> {\n     let id = link::find_crate_id(krate.attrs.as_slice(), outputs);\n \n-    let mut out_filenames = ~[];\n+    let mut out_filenames = Vec::new();\n     for output_type in sess.opts.output_types.iter() {\n         let file = outputs.path(*output_type);\n         match *output_type {\n@@ -524,7 +523,7 @@ fn write_out_deps(sess: Session,\n \n     // Build a list of files used to compile the output and\n     // write Makefile-compatible dependency rules\n-    let files: ~[~str] = {\n+    let files: Vec<~str> = {\n         let files = sess.codemap.files.borrow();\n         files.get()\n              .iter()\n@@ -767,34 +766,39 @@ pub fn host_triple() -> ~str {\n \n pub fn build_session_options(matches: &getopts::Matches)\n                              -> @session::Options {\n-    let crate_types = matches.opt_strs(\"crate-type\").flat_map(|s| {\n-        s.split(',').map(|part| {\n-            match part {\n+    let mut crate_types: Vec<CrateType> = Vec::new();\n+    let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n+    for unparsed_crate_type in unparsed_crate_types.iter() {\n+        for part in unparsed_crate_type.split(',') {\n+            let new_part = match part {\n                 \"lib\"       => session::default_lib_output(),\n                 \"rlib\"      => session::CrateTypeRlib,\n                 \"staticlib\" => session::CrateTypeStaticlib,\n                 \"dylib\"     => session::CrateTypeDylib,\n                 \"bin\"       => session::CrateTypeExecutable,\n                 _ => early_error(format!(\"unknown crate type: `{}`\", part))\n-            }\n-        }).collect()\n-    });\n+            };\n+            crate_types.push(new_part)\n+        }\n+    }\n \n     let parse_only = matches.opt_present(\"parse-only\");\n     let no_trans = matches.opt_present(\"no-trans\");\n     let no_analysis = matches.opt_present(\"no-analysis\");\n \n     let lint_levels = [lint::allow, lint::warn,\n                        lint::deny, lint::forbid];\n-    let mut lint_opts = ~[];\n+    let mut lint_opts = Vec::new();\n     let lint_dict = lint::get_lint_dict();\n     for level in lint_levels.iter() {\n         let level_name = lint::level_to_str(*level);\n \n         let level_short = level_name.slice_chars(0, 1);\n         let level_short = level_short.to_ascii().to_upper().into_str();\n-        let flags = vec::append(matches.opt_strs(level_short),\n-                                matches.opt_strs(level_name));\n+        let flags = vec_ng::append(matches.opt_strs(level_short)\n+                                          .move_iter()\n+                                          .collect(),\n+                                   matches.opt_strs(level_name));\n         for lint_name in flags.iter() {\n             let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find_equiv(&lint_name) {\n@@ -828,23 +832,24 @@ pub fn build_session_options(matches: &getopts::Matches)\n         unsafe { llvm::LLVMSetDebug(1); }\n     }\n \n-    let mut output_types = if parse_only || no_trans {\n-        ~[]\n-    } else {\n-        matches.opt_strs(\"emit\").flat_map(|s| {\n-            s.split(',').map(|part| {\n-                match part.as_slice() {\n+    let mut output_types = Vec::new();\n+    if !parse_only && !no_trans {\n+        let unparsed_output_types = matches.opt_strs(\"emit\");\n+        for unparsed_output_type in unparsed_output_types.iter() {\n+            for part in unparsed_output_type.split(',') {\n+                let output_type = match part.as_slice() {\n                     \"asm\"  => link::OutputTypeAssembly,\n                     \"ir\"   => link::OutputTypeLlvmAssembly,\n                     \"bc\"   => link::OutputTypeBitcode,\n                     \"obj\"  => link::OutputTypeObject,\n                     \"link\" => link::OutputTypeExe,\n                     _ => early_error(format!(\"unknown emission type: `{}`\", part))\n-                }\n-            }).collect()\n-        })\n+                };\n+                output_types.push(output_type)\n+            }\n+        }\n     };\n-    output_types.sort();\n+    output_types.as_mut_slice().sort();\n     output_types.dedup();\n     if output_types.len() == 0 {\n         output_types.push(link::OutputTypeExe);\n@@ -890,7 +895,7 @@ pub fn build_session_options(matches: &getopts::Matches)\n         Path::new(s.as_slice())\n     }).move_iter().collect();\n \n-    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n+    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\").move_iter().collect());\n     let test = matches.opt_present(\"test\");\n     let write_dependency_info = (matches.opt_present(\"dep-info\"),\n                                  matches.opt_str(\"dep-info\").map(|p| Path::new(p)));\n@@ -1005,7 +1010,7 @@ pub fn build_session_(sopts: @session::Options,\n         working_dir: os::getcwd(),\n         lints: RefCell::new(HashMap::new()),\n         node_id: Cell::new(1),\n-        crate_types: @RefCell::new(~[]),\n+        crate_types: @RefCell::new(Vec::new()),\n         features: front::feature_gate::Features::new()\n     }\n }\n@@ -1026,8 +1031,8 @@ pub fn parse_pretty(sess: Session, name: &str) -> PpMode {\n }\n \n // rustc command line options\n-pub fn optgroups() -> ~[getopts::OptGroup] {\n- ~[\n+pub fn optgroups() -> Vec<getopts::OptGroup> {\n+ vec!(\n   optflag(\"h\", \"help\", \"Display this message\"),\n   optmulti(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n   optmulti(\"L\", \"\",   \"Add a directory to the library search path\", \"PATH\"),\n@@ -1071,8 +1076,7 @@ pub fn optgroups() -> ~[getopts::OptGroup] {\n   optmulti(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n   optmulti(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n   optmulti(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n-  optflag( \"v\", \"version\", \"Print version info and exit\"),\n- ]\n+  optflag( \"v\", \"version\", \"Print version info and exit\"))\n }\n \n pub struct OutputFilenames {\n@@ -1188,7 +1192,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts([~\"--test\"], optgroups()) {\n+            &match getopts([~\"--test\"], optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n             };\n@@ -1203,7 +1207,8 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n-            &match getopts([~\"--test\", ~\"--cfg=test\"], optgroups()) {\n+            &match getopts([~\"--test\", ~\"--cfg=test\"],\n+                           optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => {\n                 fail!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\","}, {"sha": "4845060dd12a39b0c59fd12badc2ae3a3333c600", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -74,8 +74,8 @@ debugging_opts!(\n     0\n )\n \n-pub fn debugging_opts_map() -> ~[(&'static str, &'static str, u64)] {\n-    ~[(\"verbose\", \"in general, enable more debug printouts\", VERBOSE),\n+pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n+    vec!((\"verbose\", \"in general, enable more debug printouts\", VERBOSE),\n      (\"time-passes\", \"measure time of each rustc pass\", TIME_PASSES),\n      (\"count-llvm-insns\", \"count where LLVM \\\n                            instrs originate\", COUNT_LLVM_INSNS),\n@@ -102,8 +102,7 @@ pub fn debugging_opts_map() -> ~[(&'static str, &'static str, u64)] {\n       PRINT_LLVM_PASSES),\n      (\"lto\", \"Perform LLVM link-time optimizations\", LTO),\n      (\"ast-json\", \"Print the AST as JSON and halt\", AST_JSON),\n-     (\"ast-json-noexpand\", \"Print the pre-expansion AST as JSON and halt\", AST_JSON_NOEXPAND),\n-    ]\n+     (\"ast-json-noexpand\", \"Print the pre-expansion AST as JSON and halt\", AST_JSON_NOEXPAND))\n }\n \n #[deriving(Clone, Eq)]\n@@ -125,13 +124,13 @@ pub enum DebugInfoLevel {\n pub struct Options {\n     // The crate config requested for the session, which may be combined\n     // with additional crate configurations during the compile process\n-    crate_types: ~[CrateType],\n+    crate_types: Vec<CrateType> ,\n \n     gc: bool,\n     optimize: OptLevel,\n     debuginfo: DebugInfoLevel,\n-    lint_opts: ~[(lint::Lint, lint::level)],\n-    output_types: ~[back::link::OutputType],\n+    lint_opts: Vec<(lint::Lint, lint::level)> ,\n+    output_types: Vec<back::link::OutputType> ,\n     // This was mutable for rustpkg, which updates search paths based on the\n     // parsed code. It remains mutable in case its replacements wants to use\n     // this.\n@@ -192,9 +191,9 @@ pub struct Session_ {\n     local_crate_source_file: Option<Path>,\n     working_dir: Path,\n     lints: RefCell<HashMap<ast::NodeId,\n-                           ~[(lint::Lint, codemap::Span, ~str)]>>,\n+                           Vec<(lint::Lint, codemap::Span, ~str)> >>,\n     node_id: Cell<ast::NodeId>,\n-    crate_types: @RefCell<~[CrateType]>,\n+    crate_types: @RefCell<Vec<CrateType> >,\n     features: front::feature_gate::Features\n }\n \n@@ -259,7 +258,7 @@ impl Session_ {\n             Some(arr) => { arr.push((lint, sp, msg)); return; }\n             None => {}\n         }\n-        lints.get().insert(id, ~[(lint, sp, msg)]);\n+        lints.get().insert(id, vec!((lint, sp, msg)));\n     }\n     pub fn next_node_id(&self) -> ast::NodeId {\n         self.reserve_node_ids(1)\n@@ -318,12 +317,12 @@ impl Session_ {\n /// Some reasonable defaults\n pub fn basic_options() -> @Options {\n     @Options {\n-        crate_types: ~[],\n+        crate_types: Vec::new(),\n         gc: false,\n         optimize: No,\n         debuginfo: NoDebugInfo,\n-        lint_opts: ~[],\n-        output_types: ~[],\n+        lint_opts: Vec::new(),\n+        output_types: Vec::new(),\n         addl_lib_search_paths: @RefCell::new(HashSet::new()),\n         maybe_sysroot: None,\n         target_triple: host_triple(),\n@@ -394,7 +393,8 @@ macro_rules! cgoptions(\n             }\n         }\n \n-        fn parse_list(slot: &mut ~[~str], v: Option<&str>) -> bool {\n+        fn parse_list(slot: &mut ::std::vec_ng::Vec<~str>, v: Option<&str>)\n+                      -> bool {\n             match v {\n                 Some(s) => {\n                     for s in s.words() {\n@@ -414,15 +414,15 @@ cgoptions!(\n         \"tool to assemble archives with\"),\n     linker: Option<~str> = (None, parse_opt_string,\n         \"system linker to link outputs with\"),\n-    link_args: ~[~str] = (~[], parse_list,\n+    link_args: Vec<~str> = (Vec::new(), parse_list,\n         \"extra arguments to pass to the linker (space separated)\"),\n     target_cpu: ~str = (~\"generic\", parse_string,\n         \"select target processor (llc -mcpu=help for details)\"),\n     target_feature: ~str = (~\"\", parse_string,\n         \"target specific attributes (llc -mattr=help for details)\"),\n-    passes: ~[~str] = (~[], parse_list,\n+    passes: Vec<~str> = (Vec::new(), parse_list,\n         \"a list of extra LLVM passes to run (space separated)\"),\n-    llvm_args: ~[~str] = (~[], parse_list,\n+    llvm_args: Vec<~str> = (Vec::new(), parse_list,\n         \"a list of arguments to pass to llvm (space separated)\"),\n     save_temps: bool = (false, parse_bool,\n         \"save all temporary output files during compilation\"),\n@@ -476,11 +476,11 @@ pub fn default_lib_output() -> CrateType {\n }\n \n pub fn collect_crate_types(session: &Session,\n-                           attrs: &[ast::Attribute]) -> ~[CrateType] {\n+                           attrs: &[ast::Attribute]) -> Vec<CrateType> {\n     // If we're generating a test executable, then ignore all other output\n     // styles at all other locations\n     if session.opts.test {\n-        return ~[CrateTypeExecutable];\n+        return vec!(CrateTypeExecutable)\n     }\n     let mut base = session.opts.crate_types.clone();\n     let mut iter = attrs.iter().filter_map(|a| {\n@@ -516,7 +516,7 @@ pub fn collect_crate_types(session: &Session,\n     if base.len() == 0 {\n         base.push(CrateTypeExecutable);\n     }\n-    base.sort();\n+    base.as_mut_slice().sort();\n     base.dedup();\n     return base;\n }"}, {"sha": "514d2a4a6e1183381babbef8674c15154886681e", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use std::vec_ng::Vec;\n use syntax::fold::Folder;\n use syntax::{ast, fold, attr};\n use syntax::codemap;\n@@ -58,7 +58,7 @@ fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::ViewItem)\n }\n \n fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n-    let filtered_items: ~[&@ast::Item] = m.items.iter()\n+    let filtered_items: Vec<&@ast::Item> = m.items.iter()\n             .filter(|&a| item_in_cfg(cx, *a))\n             .collect();\n     let flattened_items = filtered_items.move_iter()\n@@ -170,7 +170,7 @@ fn retain_stmt(cx: &Context, stmt: @ast::Stmt) -> bool {\n }\n \n fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n-    let resulting_stmts: ~[&@ast::Stmt] =\n+    let resulting_stmts: Vec<&@ast::Stmt> =\n         b.stmts.iter().filter(|&a| retain_stmt(cx, *a)).collect();\n     let resulting_stmts = resulting_stmts.move_iter()\n         .flat_map(|&stmt| cx.fold_stmt(stmt).move_iter())"}, {"sha": "6246000074db8d2656703bc4acebc66f32b9cef7", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -31,6 +31,7 @@ use syntax::parse::token;\n use driver::session::Session;\n \n use std::cell::Cell;\n+use std::vec_ng::Vec;\n \n /// This is a list of all known features since the beginning of time. This list\n /// can never shrink, it may only be expanded (in order to prevent old programs\n@@ -85,7 +86,7 @@ impl Features {\n }\n \n struct Context {\n-    features: ~[&'static str],\n+    features: Vec<&'static str> ,\n     sess: Session,\n }\n \n@@ -280,7 +281,7 @@ impl Visitor<()> for Context {\n \n pub fn check_crate(sess: Session, krate: &ast::Crate) {\n     let mut cx = Context {\n-        features: ~[],\n+        features: Vec::new(),\n         sess: sess,\n     };\n "}, {"sha": "703722ccb1cdbf8aec93bbca5451ae01e0feb355", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -40,17 +40,17 @@ use syntax::util::small_vector::SmallVector;\n \n struct Test {\n     span: Span,\n-    path: ~[ast::Ident],\n+    path: Vec<ast::Ident> ,\n     bench: bool,\n     ignore: bool,\n     should_fail: bool\n }\n \n struct TestCtxt<'a> {\n     sess: session::Session,\n-    path: RefCell<~[ast::Ident]>,\n+    path: RefCell<Vec<ast::Ident> >,\n     ext_cx: ExtCtxt<'a>,\n-    testfns: RefCell<~[Test]>,\n+    testfns: RefCell<Vec<Test> >,\n     is_test_crate: bool,\n     config: ast::CrateConfig,\n }\n@@ -93,7 +93,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             path.get().push(i.ident);\n         }\n         debug!(\"current path: {}\",\n-               ast_util::path_name_i(self.cx.path.get()));\n+               ast_util::path_name_i(self.cx.path.get().as_slice()));\n \n         if is_test_fn(&self.cx, i) || is_bench_fn(i) {\n             match i.node {\n@@ -171,8 +171,8 @@ fn generate_test_harness(sess: session::Session, krate: ast::Crate)\n                                  loader: loader,\n                                  deriving_hash_type_parameter: false,\n                              }),\n-        path: RefCell::new(~[]),\n-        testfns: RefCell::new(~[]),\n+        path: RefCell::new(Vec::new()),\n+        testfns: RefCell::new(Vec::new()),\n         is_test_crate: is_test_crate(&krate),\n         config: krate.config.clone(),\n     };\n@@ -303,7 +303,7 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     let vi = if cx.is_test_crate {\n         ast::ViewItemUse(\n             vec!(@nospan(ast::ViewPathSimple(id_test,\n-                                             path_node(~[id_test]),\n+                                             path_node(vec!(id_test)),\n                                              ast::DUMMY_NODE_ID))))\n     } else {\n         ast::ViewItemExternCrate(id_test,\n@@ -363,7 +363,7 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n     codemap::Spanned { node: t, span: DUMMY_SP }\n }\n \n-fn path_node(ids: ~[ast::Ident]) -> ast::Path {\n+fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n         global: false,\n@@ -375,7 +375,7 @@ fn path_node(ids: ~[ast::Ident]) -> ast::Path {\n     }\n }\n \n-fn path_node_global(ids: ~[ast::Ident]) -> ast::Path {\n+fn path_node_global(ids: Vec<ast::Ident> ) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n         global: true,\n@@ -432,11 +432,12 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     let span = test.span;\n     let path = test.path.clone();\n \n-    debug!(\"encoding {}\", ast_util::path_name_i(path));\n+    debug!(\"encoding {}\", ast_util::path_name_i(path.as_slice()));\n \n     let name_lit: ast::Lit =\n         nospan(ast::LitStr(token::intern_and_get_ident(\n-                    ast_util::path_name_i(path)), ast::CookedStr));\n+                    ast_util::path_name_i(path.as_slice())),\n+                    ast::CookedStr));\n \n     let name_expr = @ast::Expr {\n           id: ast::DUMMY_NODE_ID,"}, {"sha": "af0acee07fd217db8adeceaa6c9dd996f53c62de", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -53,8 +53,8 @@ use std::io;\n use std::os;\n use std::str;\n use std::task;\n-use std::vec;\n use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast;\n use syntax::diagnostic::Emitter;\n use syntax::diagnostic;\n@@ -149,7 +149,7 @@ Additional help:\n     -C help             Print codegen options\n     -W help             Print 'lint' options and default settings\n     -Z help             Print internal options for debugging rustc\\n\",\n-              getopts::usage(message, d::optgroups()));\n+              getopts::usage(message, d::optgroups().as_slice()));\n }\n \n pub fn describe_warnings() {\n@@ -164,8 +164,8 @@ Available lint options:\n     let lint_dict = lint::get_lint_dict();\n     let mut lint_dict = lint_dict.move_iter()\n                                  .map(|(k, v)| (v, k))\n-                                 .collect::<~[(lint::LintSpec, &'static str)]>();\n-    lint_dict.sort();\n+                                 .collect::<Vec<(lint::LintSpec, &'static str)> >();\n+    lint_dict.as_mut_slice().sort();\n \n     let mut max_key = 0;\n     for &(_, name) in lint_dict.iter() {\n@@ -224,7 +224,7 @@ pub fn run_compiler(args: &[~str]) {\n     if args.is_empty() { usage(binary); return; }\n \n     let matches =\n-        &match getopts::getopts(args, d::optgroups()) {\n+        &match getopts::getopts(args, d::optgroups().as_slice()) {\n           Ok(m) => m,\n           Err(f) => {\n             d::early_error(f.to_err_msg());\n@@ -236,8 +236,10 @@ pub fn run_compiler(args: &[~str]) {\n         return;\n     }\n \n-    let lint_flags = vec::append(matches.opt_strs(\"W\"),\n-                                 matches.opt_strs(\"warn\"));\n+    let lint_flags = vec_ng::append(matches.opt_strs(\"W\")\n+                                           .move_iter()\n+                                           .collect(),\n+                                    matches.opt_strs(\"warn\"));\n     if lint_flags.iter().any(|x| x == &~\"help\") {\n         describe_warnings();\n         return;\n@@ -312,8 +314,8 @@ pub fn run_compiler(args: &[~str]) {\n     if crate_id || crate_name || crate_file_name {\n         let attrs = parse_crate_attrs(sess, &input);\n         let t_outputs = d::build_output_filenames(&input, &odir, &ofile,\n-                                                  attrs, sess);\n-        let id = link::find_crate_id(attrs, &t_outputs);\n+                                                  attrs.as_slice(), sess);\n+        let id = link::find_crate_id(attrs.as_slice(), &t_outputs);\n \n         if crate_id {\n             println!(\"{}\", id.to_str());\n@@ -322,7 +324,8 @@ pub fn run_compiler(args: &[~str]) {\n             println!(\"{}\", id.name);\n         }\n         if crate_file_name {\n-            let crate_types = session::collect_crate_types(&sess, attrs);\n+            let crate_types = session::collect_crate_types(&sess,\n+                                                           attrs.as_slice());\n             for &style in crate_types.iter() {\n                 let fname = link::filename_for_input(&sess, style, &id,\n                                                      &t_outputs.with_extension(\"\"));\n@@ -337,7 +340,7 @@ pub fn run_compiler(args: &[~str]) {\n }\n \n fn parse_crate_attrs(sess: session::Session, input: &d::Input) ->\n-                     ~[ast::Attribute] {\n+                     Vec<ast::Attribute> {\n     let result = match *input {\n         d::FileInput(ref ifile) => {\n             parse::parse_crate_attrs_from_file(ifile,"}, {"sha": "7769d53865a6d8d7a23c44e1617866d9c06f8e55", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -46,7 +46,7 @@ pub fn read_crates(sess: Session,\n     let mut e = Env {\n         sess: sess,\n         os: os,\n-        crate_cache: @RefCell::new(~[]),\n+        crate_cache: @RefCell::new(Vec::new()),\n         next_crate_num: 1,\n         intr: intr\n     };\n@@ -58,8 +58,10 @@ pub fn read_crates(sess: Session,\n         visit::walk_crate(&mut v, krate, ());\n     }\n     let crate_cache = e.crate_cache.borrow();\n-    dump_crates(*crate_cache.get());\n-    warn_if_multiple_versions(&mut e, sess.diagnostic(), *crate_cache.get());\n+    dump_crates(crate_cache.get().as_slice());\n+    warn_if_multiple_versions(&mut e,\n+                              sess.diagnostic(),\n+                              crate_cache.get().as_slice());\n }\n \n struct ReadCrateVisitor<'a> {\n@@ -121,7 +123,7 @@ fn warn_if_multiple_versions(e: &mut Env,\n struct Env {\n     sess: Session,\n     os: loader::Os,\n-    crate_cache: @RefCell<~[cache_entry]>,\n+    crate_cache: @RefCell<Vec<cache_entry>>,\n     next_crate_num: ast::CrateNum,\n     intr: @IdentInterner\n }\n@@ -401,7 +403,7 @@ impl Loader {\n             env: Env {\n                 sess: sess,\n                 os: os,\n-                crate_cache: @RefCell::new(~[]),\n+                crate_cache: @RefCell::new(Vec::new()),\n                 next_crate_num: 1,\n                 intr: token::get_ident_interner(),\n             }"}, {"sha": "360ab4eefe0cecf4b77df9b93cf5f6ba34f7d49f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -18,9 +18,10 @@ use metadata::decoder;\n use middle::ty;\n use middle::typeck;\n \n-use std::vec;\n use reader = serialize::ebml::reader;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::diagnostic::expect;\n@@ -86,14 +87,15 @@ pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n                                           callback)\n }\n \n-pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> ~[ast_map::PathElem] {\n+pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     let path = decoder::get_item_path(cdata, def.node);\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    vec::append(~[ast_map::PathMod(token::intern(cdata.name))], path)\n+    vec_ng::append(vec!(ast_map::PathMod(token::intern(cdata.name))),\n+                   path.as_slice())\n }\n \n pub enum found_ast {\n@@ -114,7 +116,7 @@ pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::DefId,\n }\n \n pub fn get_enum_variants(tcx: ty::ctxt, def: ast::DefId)\n-                      -> ~[@ty::VariantInfo] {\n+                      -> Vec<@ty::VariantInfo> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n@@ -141,7 +143,7 @@ pub fn get_method_name_and_explicit_self(cstore: @cstore::CStore,\n }\n \n pub fn get_trait_method_def_ids(cstore: @cstore::CStore,\n-                                def: ast::DefId) -> ~[ast::DefId] {\n+                                def: ast::DefId) -> Vec<ast::DefId> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_method_def_ids(cdata, def.node)\n }\n@@ -154,13 +156,13 @@ pub fn get_item_variances(cstore: @cstore::CStore,\n \n pub fn get_provided_trait_methods(tcx: ty::ctxt,\n                                   def: ast::DefId)\n-                               -> ~[@ty::Method] {\n+                               -> Vec<@ty::Method> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits(tcx: ty::ctxt, def: ast::DefId) -> ~[@ty::TraitRef] {\n+pub fn get_supertraits(tcx: ty::ctxt, def: ast::DefId) -> Vec<@ty::TraitRef> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_supertraits(cdata, def.node, tcx)\n@@ -174,21 +176,21 @@ pub fn get_type_name_if_impl(cstore: @cstore::CStore, def: ast::DefId)\n \n pub fn get_static_methods_if_impl(cstore: @cstore::CStore,\n                                   def: ast::DefId)\n-                               -> Option<~[StaticMethodInfo]> {\n+                               -> Option<Vec<StaticMethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_static_methods_if_impl(cstore.intr, cdata, def.node)\n }\n \n pub fn get_item_attrs(cstore: @cstore::CStore,\n                       def_id: ast::DefId,\n-                      f: |~[@ast::MetaItem]|) {\n+                      f: |Vec<@ast::MetaItem> |) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n \n pub fn get_struct_fields(cstore: @cstore::CStore,\n                          def: ast::DefId)\n-                      -> ~[ty::field_ty] {\n+                      -> Vec<ty::field_ty> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_fields(cstore.intr, cdata, def.node)\n }\n@@ -222,8 +224,8 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n                  class_id, def) );\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {type_param_defs: Rc::new(~[]),\n-                                region_param_defs: Rc::new(~[])},\n+        generics: ty::Generics {type_param_defs: Rc::new(Vec::new()),\n+                                region_param_defs: Rc::new(Vec::new())},\n         ty: ty\n     }\n }\n@@ -262,7 +264,7 @@ pub fn get_item_visibility(cstore: @cstore::CStore,\n \n pub fn get_native_libraries(cstore: @cstore::CStore,\n                             crate_num: ast::CrateNum)\n-                                -> ~[(cstore::NativeLibaryKind, ~str)] {\n+                                -> Vec<(cstore::NativeLibaryKind, ~str)> {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_native_libraries(cdata)\n }\n@@ -308,7 +310,7 @@ pub fn get_macro_registrar_fn(cstore: @cstore::CStore,\n \n pub fn get_exported_macros(cstore: @cstore::CStore,\n                            crate_num: ast::CrateNum)\n-                           -> ~[~str] {\n+                           -> Vec<~str> {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_exported_macros(cdata)\n }"}, {"sha": "1d683ec60da0d6c164c8b1e4115204934e4c3e2f", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -18,6 +18,7 @@ use metadata::decoder;\n use metadata::loader;\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use collections::HashMap;\n use extra::c_vec::CVec;\n use syntax::ast;\n@@ -67,9 +68,9 @@ pub struct CrateSource {\n pub struct CStore {\n     priv metas: RefCell<HashMap<ast::CrateNum, @crate_metadata>>,\n     priv extern_mod_crate_map: RefCell<extern_mod_crate_map>,\n-    priv used_crate_sources: RefCell<~[CrateSource]>,\n-    priv used_libraries: RefCell<~[(~str, NativeLibaryKind)]>,\n-    priv used_link_args: RefCell<~[~str]>,\n+    priv used_crate_sources: RefCell<Vec<CrateSource> >,\n+    priv used_libraries: RefCell<Vec<(~str, NativeLibaryKind)> >,\n+    priv used_link_args: RefCell<Vec<~str> >,\n     intr: @IdentInterner\n }\n \n@@ -81,9 +82,9 @@ impl CStore {\n         CStore {\n             metas: RefCell::new(HashMap::new()),\n             extern_mod_crate_map: RefCell::new(HashMap::new()),\n-            used_crate_sources: RefCell::new(~[]),\n-            used_libraries: RefCell::new(~[]),\n-            used_link_args: RefCell::new(~[]),\n+            used_crate_sources: RefCell::new(Vec::new()),\n+            used_libraries: RefCell::new(Vec::new()),\n+            used_link_args: RefCell::new(Vec::new()),\n             intr: intr\n         }\n     }\n@@ -143,7 +144,7 @@ impl CStore {\n     }\n \n     pub fn get_used_crates(&self, prefer: LinkagePreference)\n-                           -> ~[(ast::CrateNum, Option<Path>)] {\n+                           -> Vec<(ast::CrateNum, Option<Path>)> {\n         let used_crate_sources = self.used_crate_sources.borrow();\n         used_crate_sources.get()\n             .iter()\n@@ -161,7 +162,7 @@ impl CStore {\n     }\n \n     pub fn get_used_libraries<'a>(&'a self)\n-                              -> &'a RefCell<~[(~str, NativeLibaryKind)]> {\n+                              -> &'a RefCell<Vec<(~str, NativeLibaryKind)> > {\n         &self.used_libraries\n     }\n \n@@ -172,7 +173,7 @@ impl CStore {\n         }\n     }\n \n-    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<~[~str]> {\n+    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<~str> > {\n         &self.used_link_args\n     }\n "}, {"sha": "caf4670b40a9f999e6487b24016c437444a495c2", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -33,7 +33,7 @@ use std::io;\n use std::io::extensions::u64_from_be_bytes;\n use std::option;\n use std::rc::Rc;\n-use std::vec;\n+use std::vec_ng::Vec;\n use serialize::ebml::reader;\n use serialize::ebml;\n use serialize::Decodable;\n@@ -250,8 +250,8 @@ fn item_ty_param_defs(item: ebml::Doc,\n                       tcx: ty::ctxt,\n                       cdata: Cmd,\n                       tag: uint)\n-                      -> Rc<~[ty::TypeParameterDef]> {\n-    let mut bounds = ~[];\n+                      -> Rc<Vec<ty::TypeParameterDef> > {\n+    let mut bounds = Vec::new();\n     reader::tagged_docs(item, tag, |p| {\n         let bd = parse_type_param_def_data(\n             p.data, p.start, cdata.cnum, tcx,\n@@ -263,8 +263,8 @@ fn item_ty_param_defs(item: ebml::Doc,\n }\n \n fn item_region_param_defs(item_doc: ebml::Doc, cdata: Cmd)\n-                          -> Rc<~[ty::RegionParameterDef]> {\n-    let mut v = ~[];\n+                          -> Rc<Vec<ty::RegionParameterDef> > {\n+    let mut v = Vec::new();\n     reader::tagged_docs(item_doc, tag_region_param_def, |rp_doc| {\n             let ident_str_doc = reader::get_doc(rp_doc,\n                                                 tag_region_param_def_ident);\n@@ -287,8 +287,8 @@ fn item_ty_param_count(item: ebml::Doc) -> uint {\n     n\n }\n \n-fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::DefId] {\n-    let mut ids: ~[ast::DefId] = ~[];\n+fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n+    let mut ids: Vec<ast::DefId> = Vec::new();\n     let v = tag_items_data_item_variant;\n     reader::tagged_docs(item, v, |p| {\n         let ext = reader::with_doc_data(p, parse_def_id);\n@@ -298,13 +298,13 @@ fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::DefId] {\n     return ids;\n }\n \n-fn item_path(item_doc: ebml::Doc) -> ~[ast_map::PathElem] {\n+fn item_path(item_doc: ebml::Doc) -> Vec<ast_map::PathElem> {\n     let path_doc = reader::get_doc(item_doc, tag_path);\n \n     let len_doc = reader::get_doc(path_doc, tag_path_len);\n     let len = reader::doc_as_u32(len_doc) as uint;\n \n-    let mut result = vec::with_capacity(len);\n+    let mut result = Vec::with_capacity(len);\n     reader::docs(path_doc, |tag, elt_doc| {\n         if tag == tag_path_elem_mod {\n             let s = elt_doc.as_str_slice();\n@@ -667,22 +667,22 @@ pub fn each_top_level_item_of_crate(intr: @IdentInterner,\n                                 callback)\n }\n \n-pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> ~[ast_map::PathElem] {\n+pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n     item_path(lookup_item(id, cdata.data()))\n }\n \n pub type DecodeInlinedItem<'a> = 'a |cdata: @cstore::crate_metadata,\n                                      tcx: ty::ctxt,\n-                                     path: ~[ast_map::PathElem],\n+                                     path: Vec<ast_map::PathElem> ,\n                                      par_doc: ebml::Doc|\n-                                     -> Result<ast::InlinedItem, ~[ast_map::PathElem]>;\n+                                     -> Result<ast::InlinedItem, Vec<ast_map::PathElem> >;\n \n pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt, id: ast::NodeId,\n                           decode_inlined_item: DecodeInlinedItem)\n                           -> csearch::found_ast {\n     debug!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data());\n-    let path = item_path(item_doc).init().to_owned();\n+    let path = Vec::from_slice(item_path(item_doc).init());\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n         Ok(ref ii) => csearch::found(*ii),\n         Err(path) => {\n@@ -702,11 +702,11 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt, id: ast::NodeId,\n }\n \n pub fn get_enum_variants(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n-                     tcx: ty::ctxt) -> ~[@ty::VariantInfo] {\n+                     tcx: ty::ctxt) -> Vec<@ty::VariantInfo> {\n     let data = cdata.data();\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n-    let mut infos: ~[@ty::VariantInfo] = ~[];\n+    let mut infos: Vec<@ty::VariantInfo> = Vec::new();\n     let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n     for did in variant_ids.iter() {\n@@ -716,7 +716,7 @@ pub fn get_enum_variants(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n         let name = item_name(intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n           ty::ty_bare_fn(ref f) => f.sig.inputs.clone(),\n-          _ => ~[], // Nullary enum variant.\n+          _ => Vec::new(), // Nullary enum variant.\n         };\n         match variant_disr_val(item) {\n           Some(val) => { disr_val = val; }\n@@ -761,8 +761,8 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n }\n \n fn item_impl_methods(intr: @IdentInterner, cdata: Cmd, item: ebml::Doc,\n-                     tcx: ty::ctxt) -> ~[@ty::Method] {\n-    let mut rslt = ~[];\n+                     tcx: ty::ctxt) -> Vec<@ty::Method> {\n+    let mut rslt = Vec::new();\n     reader::tagged_docs(item, tag_item_impl_method, |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n         rslt.push(@get_method(intr, cdata, m_did.node, tcx));\n@@ -838,10 +838,10 @@ pub fn get_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n }\n \n pub fn get_trait_method_def_ids(cdata: Cmd,\n-                                id: ast::NodeId) -> ~[ast::DefId] {\n+                                id: ast::NodeId) -> Vec<ast::DefId> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    let mut result = ~[];\n+    let mut result = Vec::new();\n     reader::tagged_docs(item, tag_item_trait_method, |mth| {\n         result.push(item_def_id(mth, cdata));\n         true\n@@ -859,10 +859,10 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n \n pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,\n                                   id: ast::NodeId, tcx: ty::ctxt) ->\n-        ~[@ty::Method] {\n+        Vec<@ty::Method> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    let mut result = ~[];\n+    let mut result = Vec::new();\n \n     reader::tagged_docs(item, tag_item_trait_method, |mth_id| {\n         let did = item_def_id(mth_id, cdata);\n@@ -879,8 +879,8 @@ pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,\n \n /// Returns the supertraits of the given trait.\n pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n-                    -> ~[@ty::TraitRef] {\n-    let mut results = ~[];\n+                    -> Vec<@ty::TraitRef> {\n+    let mut results = Vec::new();\n     let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n         // NB. Only reads the ones that *aren't* builtin-bounds. See also\n@@ -914,7 +914,7 @@ pub fn get_type_name_if_impl(cdata: Cmd,\n pub fn get_static_methods_if_impl(intr: @IdentInterner,\n                                   cdata: Cmd,\n                                   node_id: ast::NodeId)\n-                               -> Option<~[StaticMethodInfo]> {\n+                               -> Option<Vec<StaticMethodInfo> > {\n     let item = lookup_item(node_id, cdata.data());\n     if item_family(item) != Impl {\n         return None;\n@@ -927,13 +927,13 @@ pub fn get_static_methods_if_impl(intr: @IdentInterner,\n \n     if !ret { return None }\n \n-    let mut impl_method_ids = ~[];\n+    let mut impl_method_ids = Vec::new();\n     reader::tagged_docs(item, tag_item_impl_method, |impl_method_doc| {\n         impl_method_ids.push(reader::with_doc_data(impl_method_doc, parse_def_id));\n         true\n     });\n \n-    let mut static_impl_methods = ~[];\n+    let mut static_impl_methods = Vec::new();\n     for impl_method_id in impl_method_ids.iter() {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data());\n         let family = item_family(impl_method_doc);\n@@ -975,7 +975,7 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n \n pub fn get_item_attrs(cdata: Cmd,\n                       node_id: ast::NodeId,\n-                      f: |~[@ast::MetaItem]|) {\n+                      f: |Vec<@ast::MetaItem> |) {\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n@@ -1000,10 +1000,10 @@ fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n }\n \n pub fn get_struct_fields(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId)\n-    -> ~[ty::field_ty] {\n+    -> Vec<ty::field_ty> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    let mut result = ~[];\n+    let mut result = Vec::new();\n     reader::tagged_docs(item, tag_item_field, |an_item| {\n         let f = item_family(an_item);\n         if f == PublicField || f == PrivateField || f == InheritedField {\n@@ -1035,8 +1035,8 @@ pub fn get_item_visibility(cdata: Cmd, id: ast::NodeId)\n     item_visibility(lookup_item(id, cdata.data()))\n }\n \n-fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n-    let mut items: ~[@ast::MetaItem] = ~[];\n+fn get_meta_items(md: ebml::Doc) -> Vec<@ast::MetaItem> {\n+    let mut items: Vec<@ast::MetaItem> = Vec::new();\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n@@ -1063,16 +1063,16 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n     return items;\n }\n \n-fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n-    let mut attrs: ~[ast::Attribute] = ~[];\n+fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n+    let mut attrs: Vec<ast::Attribute> = Vec::new();\n     match reader::maybe_get_doc(md, tag_attributes) {\n       option::Some(attrs_d) => {\n         reader::tagged_docs(attrs_d, tag_attribute, |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n             assert_eq!(meta_items.len(), 1u);\n-            let meta_item = meta_items[0];\n+            let meta_item = *meta_items.get(0);\n             attrs.push(\n                 codemap::Spanned {\n                     node: ast::Attribute_ {\n@@ -1102,7 +1102,7 @@ fn list_crate_attributes(md: ebml::Doc, hash: &Svh,\n     write!(out, \"\\n\\n\")\n }\n \n-pub fn get_crate_attributes(data: &[u8]) -> ~[ast::Attribute] {\n+pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n     return get_attributes(reader::Doc(data));\n }\n \n@@ -1113,8 +1113,8 @@ pub struct CrateDep {\n     hash: Svh,\n }\n \n-pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n-    let mut deps: ~[CrateDep] = ~[];\n+pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n+    let mut deps: Vec<CrateDep> = Vec::new();\n     let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n@@ -1255,10 +1255,10 @@ pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n }\n \n \n-pub fn get_native_libraries(cdata: Cmd) -> ~[(cstore::NativeLibaryKind, ~str)] {\n+pub fn get_native_libraries(cdata: Cmd) -> Vec<(cstore::NativeLibaryKind, ~str)> {\n     let libraries = reader::get_doc(reader::Doc(cdata.data()),\n                                     tag_native_libraries);\n-    let mut result = ~[];\n+    let mut result = Vec::new();\n     reader::tagged_docs(libraries, tag_native_libraries_lib, |lib_doc| {\n         let kind_doc = reader::get_doc(lib_doc, tag_native_libraries_kind);\n         let name_doc = reader::get_doc(lib_doc, tag_native_libraries_name);\n@@ -1276,10 +1276,10 @@ pub fn get_macro_registrar_fn(cdata: Cmd) -> Option<ast::DefId> {\n         .map(|doc| item_def_id(doc, cdata))\n }\n \n-pub fn get_exported_macros(cdata: Cmd) -> ~[~str] {\n+pub fn get_exported_macros(cdata: Cmd) -> Vec<~str> {\n     let macros = reader::get_doc(reader::Doc(cdata.data()),\n                                  tag_exported_macros);\n-    let mut result = ~[];\n+    let mut result = Vec::new();\n     reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n         result.push(macro_doc.as_str());\n         true"}, {"sha": "91c0d093653f72f16ce55aab509f59c0e1baf5bc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -32,6 +32,7 @@ use std::hash;\n use std::hash::Hash;\n use std::io::MemWriter;\n use std::str;\n+use std::vec_ng::Vec;\n use collections::HashMap;\n use syntax::abi::AbiSet;\n use syntax::ast::*;\n@@ -324,7 +325,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             ebml_w: &mut writer::Encoder,\n                             id: NodeId,\n                             variants: &[P<Variant>],\n-                            index: @RefCell<~[entry<i64>]>,\n+                            index: @RefCell<Vec<entry<i64>> >,\n                             generics: &ast::Generics) {\n     debug!(\"encode_enum_variant_info(id={:?})\", id);\n \n@@ -367,9 +368,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 encode_index(ebml_w, bkts, write_i64);\n             }\n         }\n-        if vi[i].disr_val != disr_val {\n-            encode_disr_val(ecx, ebml_w, vi[i].disr_val);\n-            disr_val = vi[i].disr_val;\n+        if vi.get(i).disr_val != disr_val {\n+            encode_disr_val(ecx, ebml_w, vi.get(i).disr_val);\n+            disr_val = vi.get(i).disr_val;\n         }\n         encode_bounds_and_type(ebml_w, ecx,\n                                &lookup_item_type(ecx.tcx, def_id));\n@@ -687,11 +688,11 @@ fn encode_provided_source(ebml_w: &mut writer::Encoder,\n fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           fields: &[StructField],\n-                          global_index: @RefCell<~[entry<i64>]>)\n-                          -> ~[entry<i64>] {\n+                          global_index: @RefCell<Vec<entry<i64>> >)\n+                          -> Vec<entry<i64>> {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n-    let mut index = ~[];\n+    let mut index = Vec::new();\n     let tcx = ecx.tcx;\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n@@ -726,7 +727,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut writer::Encoder,\n                                name: ast::Ident,\n                                ctor_id: NodeId,\n-                               index: @RefCell<~[entry<i64>]>,\n+                               index: @RefCell<Vec<entry<i64>> >,\n                                struct_id: NodeId) {\n     {\n         let mut index = index.borrow_mut();\n@@ -888,13 +889,13 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: &Item,\n-                        index: @RefCell<~[entry<i64>]>,\n+                        index: @RefCell<Vec<entry<i64>> >,\n                         path: PathElems,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n     fn add_to_index(item: &Item, ebml_w: &writer::Encoder,\n-                     index: @RefCell<~[entry<i64>]>) {\n+                     index: @RefCell<Vec<entry<i64>> >) {\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n             val: item.id as i64,\n@@ -1239,7 +1240,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n                                 nitem: &ForeignItem,\n-                                index: @RefCell<~[entry<i64>]>,\n+                                index: @RefCell<Vec<entry<i64>> >,\n                                 path: PathElems,\n                                 abi: AbiSet) {\n     {\n@@ -1284,7 +1285,7 @@ fn my_visit_expr(_e: &Expr) { }\n fn my_visit_item(i: &Item,\n                  ebml_w: &mut writer::Encoder,\n                  ecx_ptr: *int,\n-                 index: @RefCell<~[entry<i64>]>) {\n+                 index: @RefCell<Vec<entry<i64>> >) {\n     let mut ebml_w = unsafe { ebml_w.unsafe_clone() };\n     // See above\n     let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n@@ -1296,7 +1297,7 @@ fn my_visit_item(i: &Item,\n fn my_visit_foreign_item(ni: &ForeignItem,\n                          ebml_w: &mut writer::Encoder,\n                          ecx_ptr:*int,\n-                         index: @RefCell<~[entry<i64>]>) {\n+                         index: @RefCell<Vec<entry<i64>> >) {\n     // See above\n     let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n     debug!(\"writing foreign item {}::{}\",\n@@ -1317,7 +1318,7 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n struct EncodeVisitor<'a,'b> {\n     ebml_w_for_visit_item: &'a mut writer::Encoder<'b>,\n     ecx_ptr:*int,\n-    index: @RefCell<~[entry<i64>]>,\n+    index: @RefCell<Vec<entry<i64>> >,\n }\n \n impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n@@ -1344,8 +1345,8 @@ impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n fn encode_info_for_items(ecx: &EncodeContext,\n                          ebml_w: &mut writer::Encoder,\n                          krate: &Crate)\n-                         -> ~[entry<i64>] {\n-    let index = @RefCell::new(~[]);\n+                         -> Vec<entry<i64>> {\n+    let index = @RefCell::new(Vec::new());\n     ebml_w.start_tag(tag_items_data);\n     {\n         let mut index = index.borrow_mut();\n@@ -1382,19 +1383,19 @@ fn encode_info_for_items(ecx: &EncodeContext,\n // Path and definition ID indexing\n \n fn create_index<T:Clone + Hash + 'static>(\n-                index: ~[entry<T>])\n-                -> ~[@~[entry<T>]] {\n-    let mut buckets: ~[@RefCell<~[entry<T>]>] = ~[];\n+                index: Vec<entry<T>> )\n+                -> Vec<@Vec<entry<T>> > {\n+    let mut buckets: Vec<@RefCell<Vec<entry<T>> >> = Vec::new();\n     for _ in range(0u, 256u) {\n-        buckets.push(@RefCell::new(~[]));\n+        buckets.push(@RefCell::new(Vec::new()));\n     }\n     for elt in index.iter() {\n         let h = hash::hash(&elt.val) as uint;\n-        let mut bucket = buckets[h % 256].borrow_mut();\n+        let mut bucket = buckets.get_mut(h % 256).borrow_mut();\n         bucket.get().push((*elt).clone());\n     }\n \n-    let mut buckets_frozen = ~[];\n+    let mut buckets_frozen = Vec::new();\n     for bucket in buckets.iter() {\n         buckets_frozen.push(@/*bad*/(**bucket).get());\n     }\n@@ -1403,10 +1404,10 @@ fn create_index<T:Clone + Hash + 'static>(\n \n fn encode_index<T:'static>(\n                 ebml_w: &mut writer::Encoder,\n-                buckets: ~[@~[entry<T>]],\n+                buckets: Vec<@Vec<entry<T>> > ,\n                 write_fn: |&mut MemWriter, &T|) {\n     ebml_w.start_tag(tag_index);\n-    let mut bucket_locs = ~[];\n+    let mut bucket_locs = Vec::new();\n     ebml_w.start_tag(tag_index_buckets);\n     for bucket in buckets.iter() {\n         bucket_locs.push(ebml_w.writer.tell().unwrap());\n@@ -1491,7 +1492,7 @@ fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[Attribute]) {\n // metadata that Rust cares about for linking crates. If the user didn't\n // provide it we will throw it in anyway with a default value.\n fn synthesize_crate_attrs(ecx: &EncodeContext,\n-                          krate: &Crate) -> ~[Attribute] {\n+                          krate: &Crate) -> Vec<Attribute> {\n \n     fn synthesize_crateid_attr(ecx: &EncodeContext) -> Attribute {\n         assert!(!ecx.link_meta.crateid.name.is_empty());\n@@ -1502,7 +1503,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n                 token::intern_and_get_ident(ecx.link_meta.crateid.to_str())))\n     }\n \n-    let mut attrs = ~[];\n+    let mut attrs = Vec::new();\n     for attr in krate.attrs.iter() {\n         if !attr.name().equiv(&(\"crate_id\")) {\n             attrs.push(*attr);\n@@ -1514,9 +1515,9 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n }\n \n fn encode_crate_deps(ebml_w: &mut writer::Encoder, cstore: &cstore::CStore) {\n-    fn get_ordered_deps(cstore: &cstore::CStore) -> ~[decoder::CrateDep] {\n+    fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<decoder::CrateDep> {\n         // Pull the cnums and name,vers,hash out of cstore\n-        let mut deps = ~[];\n+        let mut deps = Vec::new();\n         cstore.iter_crate_data(|key, val| {\n             let dep = decoder::CrateDep {\n                 cnum: key,\n@@ -1767,10 +1768,10 @@ pub static metadata_encoding_version : &'static [u8] =\n       0x74, //'t' as u8,\n       0, 0, 0, 1 ];\n \n-pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> ~[u8] {\n+pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {\n     let mut wr = MemWriter::new();\n     encode_metadata_inner(&mut wr, parms, krate);\n-    wr.unwrap()\n+    wr.unwrap().move_iter().collect()\n }\n \n fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate) {\n@@ -1822,7 +1823,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n \n     let mut i = ebml_w.writer.tell().unwrap();\n     let crate_attrs = synthesize_crate_attrs(&ecx, krate);\n-    encode_attributes(&mut ebml_w, crate_attrs);\n+    encode_attributes(&mut ebml_w, crate_attrs.as_slice());\n     ecx.stats.attr_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     i = ebml_w.writer.tell().unwrap();"}, {"sha": "9f6b78354e2e67c7855d543073a5055ea7dba40f", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -14,6 +14,7 @@ use std::cell::RefCell;\n use std::option;\n use std::os;\n use std::io::fs;\n+use std::vec_ng::Vec;\n use collections::HashSet;\n \n pub enum FileMatch { FileMatches, FileDoesntMatch }\n@@ -205,14 +206,14 @@ pub fn get_rust_path() -> Option<~str> {\n /// $HOME/.rust\n /// DIR/.rust for any DIR that's the current working directory\n /// or an ancestor of it\n-pub fn rust_path() -> ~[Path] {\n-    let mut env_rust_path: ~[Path] = match get_rust_path() {\n+pub fn rust_path() -> Vec<Path> {\n+    let mut env_rust_path: Vec<Path> = match get_rust_path() {\n         Some(env_path) => {\n-            let env_path_components: ~[&str] =\n+            let env_path_components: Vec<&str> =\n                 env_path.split_str(PATH_ENTRY_SEPARATOR).collect();\n             env_path_components.map(|&s| Path::new(s))\n         }\n-        None => ~[]\n+        None => Vec::new()\n     };\n     let mut cwd = os::getcwd();\n     // now add in default entries"}, {"sha": "7628c90d95df1658c10b580816494842ae7a3d05", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -31,6 +31,7 @@ use std::io;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::str;\n use std::vec;\n+use std::vec_ng::Vec;\n \n use collections::{HashMap, HashSet};\n use flate;\n@@ -183,7 +184,7 @@ impl<'a> Context<'a> {\n         // A Library candidate is created if the metadata for the set of\n         // libraries corresponds to the crate id and hash criteria that this\n         // serach is being performed for.\n-        let mut libraries = ~[];\n+        let mut libraries = Vec::new();\n         for (_hash, (rlibs, dylibs)) in candidates.move_iter() {\n             let mut metadata = None;\n             let rlib = self.extract_one(rlibs, \"rlib\", &mut metadata);\n@@ -205,7 +206,7 @@ impl<'a> Context<'a> {\n         // libraries or not.\n         match libraries.len() {\n             0 => None,\n-            1 => Some(libraries[0]),\n+            1 => Some(libraries.move_iter().next().unwrap()),\n             _ => {\n                 self.sess.span_err(self.span,\n                     format!(\"multiple matching crates for `{}`\","}, {"sha": "17e334d05fbab1ea510e31dd7cd0f22089171fbd", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -20,6 +20,7 @@ use middle::ty;\n \n use std::str;\n use std::uint;\n+use std::vec_ng::Vec;\n use syntax::abi::AbiSet;\n use syntax::abi;\n use syntax::ast;\n@@ -177,7 +178,7 @@ fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n     let self_ty = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)) );\n \n     assert_eq!(next(st), '[');\n-    let mut params: ~[ty::t] = ~[];\n+    let mut params: Vec<ty::t> = Vec::new();\n     while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n     st.pos = st.pos + 1u;\n \n@@ -362,7 +363,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'T' => {\n         assert_eq!(next(st), '[');\n-        let mut params = ~[];\n+        let mut params = Vec::new();\n         while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n         st.pos = st.pos + 1u;\n         return ty::mk_tup(st.tcx, params);\n@@ -520,7 +521,7 @@ fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n     let id = parse_uint(st) as ast::NodeId;\n     assert_eq!(next(st), '|');\n-    let mut inputs = ~[];\n+    let mut inputs = Vec::new();\n     while peek(st) != ']' {\n         inputs.push(parse_ty(st, |x,y| conv(x,y)));\n     }\n@@ -583,7 +584,7 @@ fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef\n fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n     let mut param_bounds = ty::ParamBounds {\n         builtin_bounds: ty::EmptyBuiltinBounds(),\n-        trait_bounds: ~[]\n+        trait_bounds: Vec::new()\n     };\n     loop {\n         match next(st) {"}, {"sha": "be3180596e02be89920c8caeec770d7ace9547b2", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -19,6 +19,7 @@ use std::io;\n use std::io::MemWriter;\n use std::str;\n use std::fmt;\n+use std::vec_ng::Vec;\n \n use middle::ty::param_ty;\n use middle::ty;\n@@ -286,7 +287,7 @@ fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n             enc_trait_store(w, cx, store);\n             enc_mutability(w, mt);\n             let bounds = ty::ParamBounds {builtin_bounds: bounds,\n-                                          trait_bounds: ~[]};\n+                                          trait_bounds: Vec::new()};\n             enc_bounds(w, cx, &bounds);\n             mywrite!(w, \"]\");\n         }\n@@ -383,7 +384,7 @@ fn enc_closure_ty(w: &mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_onceness(w, ft.onceness);\n     enc_region(w, cx, ft.region);\n     let bounds = ty::ParamBounds {builtin_bounds: ft.bounds,\n-                                  trait_bounds: ~[]};\n+                                  trait_bounds: Vec::new()};\n     enc_bounds(w, cx, &bounds);\n     enc_fn_sig(w, cx, &ft.sig);\n }"}, {"sha": "5959f5a9d02dd632f1541035d34afa77266665a7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -116,9 +116,9 @@ pub fn encode_exported_macro(ebml_w: &mut writer::Encoder, i: &ast::Item) {\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n-                           path: ~[ast_map::PathElem],\n+                           path: Vec<ast_map::PathElem> ,\n                            par_doc: ebml::Doc)\n-                           -> Result<ast::InlinedItem, ~[ast_map::PathElem]> {\n+                           -> Result<ast::InlinedItem, Vec<ast_map::PathElem> > {\n     let dcx = @DecodeContext {\n         cdata: cdata,\n         tcx: tcx,\n@@ -395,7 +395,7 @@ impl ast_map::FoldOps for AstRenumberer {\n \n fn renumber_and_map_ast(xcx: @ExtendedDecodeContext,\n                         map: &ast_map::Map,\n-                        path: ~[ast_map::PathElem],\n+                        path: Vec<ast_map::PathElem> ,\n                         ii: ast::InlinedItem) -> ast::InlinedItem {\n     ast_map::map_decoded_item(map,\n                               path.move_iter().collect(),\n@@ -654,15 +654,15 @@ pub fn encode_vtable_res(ecx: &e::EncodeContext,\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    ebml_w.emit_from_vec(*dr, |ebml_w, param_tables| {\n+    ebml_w.emit_from_vec(dr.as_slice(), |ebml_w, param_tables| {\n         encode_vtable_param_res(ecx, ebml_w, *param_tables);\n     })\n }\n \n pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      param_tables: typeck::vtable_param_res) {\n-    ebml_w.emit_from_vec(*param_tables, |ebml_w, vtable_origin| {\n+    ebml_w.emit_from_vec(param_tables.as_slice(), |ebml_w, vtable_origin| {\n         encode_vtable_origin(ecx, ebml_w, vtable_origin)\n     })\n }\n@@ -679,7 +679,7 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n                     ebml_w.emit_def_id(def_id)\n                 });\n                 ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n-                    ebml_w.emit_tys(ecx, *tys);\n+                    ebml_w.emit_tys(ecx, tys.as_slice());\n                 });\n                 ebml_w.emit_enum_variant_arg(2u, |ebml_w| {\n                     encode_vtable_res(ecx, ebml_w, vtable_res);\n@@ -718,13 +718,17 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                       -> typeck::vtable_res {\n         @self.read_to_vec(|this|\n                           this.read_vtable_param_res(tcx, cdata))\n+             .move_iter()\n+             .collect()\n     }\n \n     fn read_vtable_param_res(&mut self,\n                              tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_param_res {\n         @self.read_to_vec(|this|\n                           this.read_vtable_origin(tcx, cdata))\n+             .move_iter()\n+             .collect()\n     }\n \n     fn read_vtable_origin(&mut self,\n@@ -985,7 +989,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.tag(c::tag_table_node_type_subst, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_tys(ecx, **tys)\n+                    ebml_w.emit_tys(ecx, tys.as_slice())\n                 })\n             })\n         }\n@@ -998,7 +1002,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.tag(c::tag_table_freevars, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_from_vec(**fv, |ebml_w, fv_entry| {\n+                    ebml_w.emit_from_vec(fv.as_slice(), |ebml_w, fv_entry| {\n                         encode_freevar_entry(ebml_w, *fv_entry)\n                     })\n                 })\n@@ -1077,7 +1081,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_from_vec(*cap_vars.borrow(), |ebml_w, cap_var| {\n+                    ebml_w.emit_from_vec(cap_vars.borrow().as_slice(),\n+                                         |ebml_w, cap_var| {\n                         cap_var.encode(ebml_w);\n                     })\n                 })\n@@ -1100,7 +1105,7 @@ impl<'a> doc_decoder_helpers for ebml::Doc<'a> {\n \n trait ebml_decoder_decoder_helpers {\n     fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t;\n-    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> ~[ty::t];\n+    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> Vec<ty::t> ;\n     fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n                            -> ty::TypeParameterDef;\n     fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n@@ -1119,7 +1124,7 @@ trait ebml_decoder_decoder_helpers {\n                      tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t;\n     fn read_tys_noxcx(&mut self,\n                       tcx: ty::ctxt,\n-                      cdata: @cstore::crate_metadata) -> ~[ty::t];\n+                      cdata: @cstore::crate_metadata) -> Vec<ty::t> ;\n }\n \n impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n@@ -1137,8 +1142,10 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n     fn read_tys_noxcx(&mut self,\n                       tcx: ty::ctxt,\n-                      cdata: @cstore::crate_metadata) -> ~[ty::t] {\n+                      cdata: @cstore::crate_metadata) -> Vec<ty::t> {\n         self.read_to_vec(|this| this.read_ty_noxcx(tcx, cdata) )\n+            .move_iter()\n+            .collect()\n     }\n \n     fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t {\n@@ -1169,8 +1176,8 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }\n     }\n \n-    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> ~[ty::t] {\n-        self.read_to_vec(|this| this.read_ty(xcx) )\n+    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> Vec<ty::t> {\n+        self.read_to_vec(|this| this.read_ty(xcx)).move_iter().collect()\n     }\n \n     fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n@@ -1197,7 +1204,9 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n                                                        0,\n                                                        |this| {\n                                     Rc::new(this.read_to_vec(|this|\n-                                                             this.read_type_param_def(xcx)))\n+                                                             this.read_type_param_def(xcx))\n+                                                .move_iter()\n+                                                .collect())\n                             }),\n                             region_param_defs:\n                                 this.read_struct_field(\"region_param_defs\",\n@@ -1357,7 +1366,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     c::tag_table_freevars => {\n                         let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n                             @val_dsr.read_freevar_entry(xcx)\n-                        });\n+                        }).move_iter().collect();\n                         let mut freevars = dcx.tcx.freevars.borrow_mut();\n                         freevars.get().insert(id, fv_info);\n                     }\n@@ -1394,7 +1403,9 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_capture_map => {\n                         let cvars =\n-                                val_dsr.read_to_vec(|val_dsr| val_dsr.read_capture_var(xcx));\n+                                val_dsr.read_to_vec(|val_dsr| val_dsr.read_capture_var(xcx))\n+                                       .move_iter()\n+                                       .collect();\n                         let mut capture_map = dcx.maps\n                                                  .capture_map\n                                                  .borrow_mut();\n@@ -1510,14 +1521,14 @@ fn test_simplification() {\n     let item = quote_item!(cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n             fn eq_int(a: int, b: int) -> bool { a == b }\n-            return alist {eq_fn: eq_int, data: ~[]};\n+            return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap();\n     let item_in = e::IIItemRef(item);\n     let item_out = simplify_ast(item_in);\n     let item_exp = ast::IIItem(quote_item!(cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n-            return alist {eq_fn: eq_int, data: ~[]};\n+            return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap());\n     match (item_out, item_exp) {"}, {"sha": "53a363b44f88d403394f45c34b62cf2cef0e2ba9", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -22,6 +22,7 @@ use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::moves;\n use middle::ty;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -143,11 +144,11 @@ impl<'a> CheckLoanCtxt<'a> {\n         })\n     }\n \n-    pub fn loans_generated_by(&self, scope_id: ast::NodeId) -> ~[uint] {\n+    pub fn loans_generated_by(&self, scope_id: ast::NodeId) -> Vec<uint> {\n         //! Returns a vector of the loans that are generated as\n         //! we encounter `scope_id`.\n \n-        let mut result = ~[];\n+        let mut result = Vec::new();\n         self.dfcx_loans.each_gen_bit_frozen(scope_id, |loan_index| {\n             result.push(loan_index);\n             true"}, {"sha": "d6666eb6293102a3149fa5363d680a40cc32a125", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -27,6 +27,7 @@ use util::common::indenter;\n use util::ppaux::{Repr};\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::IdRange;\n@@ -70,10 +71,9 @@ struct GatherLoanCtxt<'a> {\n     bccx: &'a BorrowckCtxt,\n     id_range: IdRange,\n     move_data: move_data::MoveData,\n-    all_loans: @RefCell<~[Loan]>,\n+    all_loans: @RefCell<Vec<Loan> >,\n     item_ub: ast::NodeId,\n-    repeating_ids: ~[ast::NodeId]\n-}\n+    repeating_ids: Vec<ast::NodeId> }\n \n impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n@@ -103,13 +103,13 @@ impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n }\n \n pub fn gather_loans(bccx: &BorrowckCtxt, decl: &ast::FnDecl, body: &ast::Block)\n-                    -> (IdRange, @RefCell<~[Loan]>, move_data::MoveData) {\n+                    -> (IdRange, @RefCell<Vec<Loan> >, move_data::MoveData) {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         id_range: IdRange::max(),\n-        all_loans: @RefCell::new(~[]),\n+        all_loans: @RefCell::new(Vec::new()),\n         item_ub: body.id,\n-        repeating_ids: ~[body.id],\n+        repeating_ids: vec!(body.id),\n         move_data: MoveData::new()\n     };\n     glcx.gather_fn_arg_patterns(decl, body);"}, {"sha": "aa296bf0a622b9b5e8e68c6a6cf4ed6423eac05e", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -12,7 +12,8 @@\n  * Computes the restrictions that result from a borrow.\n  */\n \n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n@@ -21,7 +22,7 @@ use util::ppaux::Repr;\n \n pub enum RestrictionResult {\n     Safe,\n-    SafeIf(@LoanPath, ~[Restriction])\n+    SafeIf(@LoanPath, Vec<Restriction> )\n }\n \n pub fn compute_restrictions(bccx: &BorrowckCtxt,\n@@ -75,8 +76,8 @@ impl<'a> RestrictionsContext<'a> {\n             mc::cat_upvar(ty::UpvarId {var_id: local_id, ..}, _) => {\n                 // R-Variable\n                 let lp = @LpVar(local_id);\n-                SafeIf(lp, ~[Restriction {loan_path: lp,\n-                                          set: restrictions}])\n+                SafeIf(lp, vec!(Restriction {loan_path: lp,\n+                                          set: restrictions}))\n             }\n \n             mc::cat_downcast(cmt_base) => {\n@@ -173,9 +174,11 @@ impl<'a> RestrictionsContext<'a> {\n             Safe => Safe,\n             SafeIf(base_lp, base_vec) => {\n                 let lp = @LpExtend(base_lp, mc, elem);\n-                SafeIf(lp, vec::append_one(base_vec,\n-                                           Restriction {loan_path: lp,\n-                                                        set: restrictions}))\n+                SafeIf(lp, vec_ng::append_one(base_vec,\n+                                              Restriction {\n+                                                  loan_path: lp,\n+                                                  set: restrictions\n+                                              }))\n             }\n         }\n     }"}, {"sha": "9767b50ae96031fb7fbba7164183da504593253e", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -24,6 +24,7 @@ use std::cell::{Cell, RefCell};\n use collections::HashMap;\n use std::ops::{BitOr, BitAnd};\n use std::result::{Result};\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -146,7 +147,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                                                       body);\n \n     check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n-                             *all_loans.get(), body);\n+                             all_loans.get().as_slice(), body);\n \n     visit::walk_fn(this, fk, decl, body, sp, id, ());\n }\n@@ -209,7 +210,7 @@ pub struct Loan {\n     loan_path: @LoanPath,\n     cmt: mc::cmt,\n     kind: ty::BorrowKind,\n-    restrictions: ~[Restriction],\n+    restrictions: Vec<Restriction> ,\n     gen_scope: ast::NodeId,\n     kill_scope: ast::NodeId,\n     span: Span,"}, {"sha": "e1434a8ac4e9758a046f7ca1f1336055f37a1dfa", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -17,6 +17,7 @@ comments in the section \"Moves and initialization\" and in `doc.rs`.\n \n use std::cell::RefCell;\n use std::uint;\n+use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n use middle::borrowck::*;\n use middle::dataflow::DataFlowContext;\n@@ -32,23 +33,23 @@ use util::ppaux::Repr;\n \n pub struct MoveData {\n     /// Move paths. See section \"Move paths\" in `doc.rs`.\n-    paths: RefCell<~[MovePath]>,\n+    paths: RefCell<Vec<MovePath> >,\n \n     /// Cache of loan path to move path index, for easy lookup.\n     path_map: RefCell<HashMap<@LoanPath, MovePathIndex>>,\n \n     /// Each move or uninitialized variable gets an entry here.\n-    moves: RefCell<~[Move]>,\n+    moves: RefCell<Vec<Move> >,\n \n     /// Assignments to a variable, like `x = foo`. These are assigned\n     /// bits for dataflow, since we must track them to ensure that\n     /// immutable variables are assigned at most once along each path.\n-    var_assignments: RefCell<~[Assignment]>,\n+    var_assignments: RefCell<Vec<Assignment> >,\n \n     /// Assignments to a path, like `x.f = foo`. These are not\n     /// assigned dataflow bits, but we track them because they still\n     /// kill move bits.\n-    path_assignments: RefCell<~[Assignment]>,\n+    path_assignments: RefCell<Vec<Assignment> >,\n     assignee_ids: RefCell<HashSet<ast::NodeId>>,\n }\n \n@@ -173,58 +174,58 @@ pub type AssignDataFlow = DataFlowContext<AssignDataFlowOperator>;\n impl MoveData {\n     pub fn new() -> MoveData {\n         MoveData {\n-            paths: RefCell::new(~[]),\n+            paths: RefCell::new(Vec::new()),\n             path_map: RefCell::new(HashMap::new()),\n-            moves: RefCell::new(~[]),\n-            path_assignments: RefCell::new(~[]),\n-            var_assignments: RefCell::new(~[]),\n+            moves: RefCell::new(Vec::new()),\n+            path_assignments: RefCell::new(Vec::new()),\n+            var_assignments: RefCell::new(Vec::new()),\n             assignee_ids: RefCell::new(HashSet::new()),\n         }\n     }\n \n     fn path_loan_path(&self, index: MovePathIndex) -> @LoanPath {\n         let paths = self.paths.borrow();\n-        paths.get()[index.get()].loan_path\n+        paths.get().get(index.get()).loan_path\n     }\n \n     fn path_parent(&self, index: MovePathIndex) -> MovePathIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[index.get()].parent\n+        paths.get().get(index.get()).parent\n     }\n \n     fn path_first_move(&self, index: MovePathIndex) -> MoveIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[index.get()].first_move\n+        paths.get().get(index.get()).first_move\n     }\n \n     fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[index.get()].first_child\n+        paths.get().get(index.get()).first_child\n     }\n \n     fn path_next_sibling(&self, index: MovePathIndex) -> MovePathIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[index.get()].next_sibling\n+        paths.get().get(index.get()).next_sibling\n     }\n \n     fn set_path_first_move(&self,\n                            index: MovePathIndex,\n                            first_move: MoveIndex) {\n         let mut paths = self.paths.borrow_mut();\n-        paths.get()[index.get()].first_move = first_move\n+        paths.get().get_mut(index.get()).first_move = first_move\n     }\n \n     fn set_path_first_child(&self,\n                             index: MovePathIndex,\n                             first_child: MovePathIndex) {\n         let mut paths = self.paths.borrow_mut();\n-        paths.get()[index.get()].first_child = first_child\n+        paths.get().get_mut(index.get()).first_child = first_child\n     }\n \n     fn move_next_move(&self, index: MoveIndex) -> MoveIndex {\n         //! Type safe indexing operator\n         let moves = self.moves.borrow();\n-        moves.get()[index.get()].next_move\n+        moves.get().get(index.get()).next_move\n     }\n \n     fn is_var_path(&self, index: MovePathIndex) -> bool {\n@@ -605,7 +606,7 @@ impl FlowedMoveData {\n \n         self.dfcx_moves.each_gen_bit_frozen(id, |index| {\n             let moves = self.move_data.moves.borrow();\n-            let move = &moves.get()[index];\n+            let move = moves.get().get(index);\n             let moved_path = move.path;\n             f(move, self.move_data.path_loan_path(moved_path))\n         })\n@@ -644,7 +645,7 @@ impl FlowedMoveData {\n \n         self.dfcx_moves.each_bit_on_entry_frozen(id, |index| {\n             let moves = self.move_data.moves.borrow();\n-            let move = &moves.get()[index];\n+            let move = moves.get().get(index);\n             let moved_path = move.path;\n             if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n@@ -702,7 +703,7 @@ impl FlowedMoveData {\n \n         self.dfcx_assign.each_bit_on_entry_frozen(id, |index| {\n             let var_assignments = self.move_data.var_assignments.borrow();\n-            let assignment = &var_assignments.get()[index];\n+            let assignment = var_assignments.get().get(index);\n             if assignment.path == loan_path_index && !f(assignment) {\n                 false\n             } else {"}, {"sha": "ec1ddd99cc6bff8cb8f671ab9ae2f81bc5917c57", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -12,6 +12,7 @@ use middle::cfg::*;\n use middle::graph;\n use middle::typeck;\n use middle::ty;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::opt_vec;\n@@ -22,7 +23,7 @@ struct CFGBuilder {\n     method_map: typeck::MethodMap,\n     exit_map: NodeMap<CFGIndex>,\n     graph: CFGGraph,\n-    loop_scopes: ~[LoopScope],\n+    loop_scopes: Vec<LoopScope> ,\n }\n \n struct LoopScope {\n@@ -39,7 +40,7 @@ pub fn construct(tcx: ty::ctxt,\n         graph: graph::Graph::new(),\n         tcx: tcx,\n         method_map: method_map,\n-        loop_scopes: ~[]\n+        loop_scopes: Vec::new()\n     };\n     let entry = cfg_builder.add_node(0, []);\n     let exit = cfg_builder.block(blk, entry);\n@@ -328,7 +329,7 @@ impl CFGBuilder {\n \n             ast::ExprRet(v) => {\n                 let v_exit = self.opt_expr(v, pred);\n-                let loop_scope = self.loop_scopes[0];\n+                let loop_scope = *self.loop_scopes.get(0);\n                 self.add_exiting_edge(expr, v_exit,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_node(expr.id, [])\n@@ -375,9 +376,9 @@ impl CFGBuilder {\n \n             ast::ExprStruct(_, ref fields, base) => {\n                 let base_exit = self.opt_expr(base, pred);\n-                let field_exprs: ~[@ast::Expr] =\n+                let field_exprs: Vec<@ast::Expr> =\n                     fields.iter().map(|f| f.expr).collect();\n-                self.straightline(expr, base_exit, field_exprs)\n+                self.straightline(expr, base_exit, field_exprs.as_slice())\n             }\n \n             ast::ExprRepeat(elem, count, _) => {"}, {"sha": "680caf101bf72e5ec1a980294fcdf0f52dbb541e", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -15,6 +15,7 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux;\n \n+use std::vec_ng::Vec;\n use syntax::ast::*;\n use syntax::{ast_util, ast_map};\n use syntax::visit::Visitor;\n@@ -207,8 +208,7 @@ struct CheckItemRecursionVisitor<'a> {\n     sess: Session,\n     ast_map: &'a ast_map::Map,\n     def_map: resolve::DefMap,\n-    idstack: ~[NodeId]\n-}\n+    idstack: Vec<NodeId> }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n@@ -222,7 +222,7 @@ pub fn check_item_recursion<'a>(sess: Session,\n         sess: sess,\n         ast_map: ast_map,\n         def_map: def_map,\n-        idstack: ~[]\n+        idstack: Vec::new()\n     };\n     visitor.visit_item(it, ());\n }"}, {"sha": "fddad9214e8f086676fc1163a069941c91c30ce1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 65, "deletions": 48, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -21,7 +21,8 @@ use util::ppaux::ty_to_str;\n \n use std::cmp;\n use std::iter;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n use syntax::codemap::{DUMMY_SP, Span};\n@@ -105,7 +106,7 @@ fn check_expr(v: &mut CheckMatchVisitor,\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n \n-       let pats: ~[@Pat] = arms.iter()\n+       let pats: Vec<@Pat> = arms.iter()\n                                .filter_map(unguarded_pat)\n                                .flat_map(|pats| pats.move_iter())\n                                .collect();\n@@ -121,7 +122,7 @@ fn check_expr(v: &mut CheckMatchVisitor,\n \n // Check for unreachable patterns\n fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n-    let mut seen = ~[];\n+    let mut seen = Vec::new();\n     for arm in arms.iter() {\n         for pat in arm.pats.iter() {\n \n@@ -151,8 +152,8 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n                 true\n             });\n \n-            let v = ~[*pat];\n-            match is_useful(cx, &seen, v) {\n+            let v = vec!(*pat);\n+            match is_useful(cx, &seen, v.as_slice()) {\n               not_useful => {\n                 cx.tcx.sess.span_err(pat.span, \"unreachable pattern\");\n               }\n@@ -170,9 +171,9 @@ fn raw_pat(p: @Pat) -> @Pat {\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n+fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n     assert!((!pats.is_empty()));\n-    let ext = match is_useful(cx, &pats.map(|p| ~[*p]), [wild()]) {\n+    let ext = match is_useful(cx, &pats.map(|p| vec!(*p)), [wild()]) {\n         not_useful => {\n             // This is good, wildcard pattern isn't reachable\n             return;\n@@ -218,7 +219,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n     cx.tcx.sess.span_err(sp, msg);\n }\n \n-type matrix = ~[~[@Pat]];\n+type matrix = Vec<Vec<@Pat> > ;\n \n #[deriving(Clone)]\n enum useful {\n@@ -250,10 +251,14 @@ enum ctor {\n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n-    if m.len() == 0u { return useful_; }\n-    if m[0].len() == 0u { return not_useful; }\n-    let real_pat = match m.iter().find(|r| r[0].id != 0) {\n-      Some(r) => r[0], None => v[0]\n+    if m.len() == 0u {\n+        return useful_;\n+    }\n+    if m.get(0).len() == 0u {\n+        return not_useful\n+    }\n+    let real_pat = match m.iter().find(|r| r.get(0).id != 0) {\n+      Some(r) => *r.get(0), None => v[0]\n     };\n     let left_ty = if real_pat.id == 0 { ty::mk_nil() }\n                   else { ty::node_id_to_type(cx.tcx, real_pat.id) };\n@@ -290,7 +295,7 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n               }\n               ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n                 let max_len = m.rev_iter().fold(0, |max_len, r| {\n-                  match r[0].node {\n+                  match r.get(0).node {\n                     PatVec(ref before, _, ref after) => {\n                       cmp::max(before.len() + after.len(), max_len)\n                     }\n@@ -313,7 +318,9 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n           }\n           Some(ref ctor) => {\n             match is_useful(cx,\n-                            &m.iter().filter_map(|r| default(cx, *r)).collect::<matrix>(),\n+                            &m.iter().filter_map(|r| {\n+                                default(cx, r.as_slice())\n+                            }).collect::<matrix>(),\n                             v.tail()) {\n               useful_ => useful(left_ty, (*ctor).clone()),\n               ref u => (*u).clone(),\n@@ -334,10 +341,12 @@ fn is_useful_specialized(cx: &MatchCheckCtxt,\n                              ctor: ctor,\n                              arity: uint,\n                              lty: ty::t)\n-                          -> useful {\n-    let ms = m.iter().filter_map(|r| specialize(cx, *r, &ctor, arity, lty)).collect::<matrix>();\n+                             -> useful {\n+    let ms = m.iter().filter_map(|r| {\n+        specialize(cx, r.as_slice(), &ctor, arity, lty)\n+    }).collect::<matrix>();\n     let could_be_useful = is_useful(\n-        cx, &ms, specialize(cx, v, &ctor, arity, lty).unwrap());\n+        cx, &ms, specialize(cx, v, &ctor, arity, lty).unwrap().as_slice());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n       ref u => (*u).clone(),\n@@ -408,14 +417,14 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(..) | ty::ty_tup(_) |\n       ty::ty_struct(..) => {\n         for r in m.iter() {\n-            if !is_wild(cx, r[0]) { return None; }\n+            if !is_wild(cx, *r.get(0)) { return None; }\n         }\n         return Some(single);\n       }\n       ty::ty_enum(eid, _) => {\n-        let mut found = ~[];\n+        let mut found = Vec::new();\n         for r in m.iter() {\n-            let r = pat_ctor_id(cx, r[0]);\n+            let r = pat_ctor_id(cx, *r.get(0));\n             for id in r.iter() {\n                 if !found.contains(id) {\n                     found.push((*id).clone());\n@@ -437,7 +446,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n         let mut true_found = false;\n         let mut false_found = false;\n         for r in m.iter() {\n-            match pat_ctor_id(cx, r[0]) {\n+            match pat_ctor_id(cx, *r.get(0)) {\n               None => (),\n               Some(val(const_bool(true))) => true_found = true,\n               Some(val(const_bool(false))) => false_found = true,\n@@ -452,7 +461,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n         let mut missing = true;\n         let mut wrong = false;\n         for r in m.iter() {\n-          match r[0].node {\n+          match r.get(0).node {\n             PatVec(ref before, ref slice, ref after) => {\n               let count = before.len() + after.len();\n               if (count < n && slice.is_none()) || count > n {\n@@ -475,13 +484,13 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n \n         // Find the lengths and slices of all vector patterns.\n         let mut vec_pat_lens = m.iter().filter_map(|r| {\n-            match r[0].node {\n+            match r.get(0).node {\n                 PatVec(ref before, ref slice, ref after) => {\n                     Some((before.len() + after.len(), slice.is_some()))\n                 }\n                 _ => None\n             }\n-        }).collect::<~[(uint, bool)]>();\n+        }).collect::<Vec<(uint, bool)> >();\n \n         // Sort them by length such that for patterns of the same length,\n         // those with a destructured slice come first.\n@@ -559,17 +568,18 @@ fn specialize(cx: &MatchCheckCtxt,\n                   ctor_id: &ctor,\n                   arity: uint,\n                   left_ty: ty::t)\n-               -> Option<~[@Pat]> {\n+               -> Option<Vec<@Pat> > {\n     // Sad, but I can't get rid of this easily\n     let r0 = (*raw_pat(r[0])).clone();\n     match r0 {\n         Pat{id: pat_id, node: n, span: pat_span} =>\n             match n {\n             PatWild => {\n-                Some(vec::append(vec::from_elem(arity, wild()), r.tail()))\n+                Some(vec_ng::append(Vec::from_elem(arity, wild()), r.tail()))\n             }\n             PatWildMulti => {\n-                Some(vec::append(vec::from_elem(arity, wild_multi()), r.tail()))\n+                Some(vec_ng::append(Vec::from_elem(arity, wild_multi()),\n+                                    r.tail()))\n             }\n             PatIdent(_, _, _) => {\n                 let opt_def = {\n@@ -579,7 +589,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                 match opt_def {\n                     Some(DefVariant(_, id, _)) => {\n                         if variant(id) == *ctor_id {\n-                            Some(r.tail().to_owned())\n+                            Some(Vec::from_slice(r.tail()))\n                         } else {\n                             None\n                         }\n@@ -617,15 +627,15 @@ fn specialize(cx: &MatchCheckCtxt,\n                             _ => fail!(\"type error\")\n                         };\n                         if match_ {\n-                            Some(r.tail().to_owned())\n+                            Some(Vec::from_slice(r.tail()))\n                         } else {\n                             None\n                         }\n                     }\n                     _ => {\n                         Some(\n-                            vec::append(\n-                                vec::from_elem(arity, wild()),\n+                            vec_ng::append(\n+                                Vec::from_elem(arity, wild()),\n                                 r.tail()\n                             )\n                         )\n@@ -668,17 +678,17 @@ fn specialize(cx: &MatchCheckCtxt,\n                             _ => fail!(\"type error\")\n                         };\n                         if match_ {\n-                            Some(r.tail().to_owned())\n+                            Some(Vec::from_slice(r.tail()))\n                         } else {\n                             None\n                         }\n                     }\n                     DefVariant(_, id, _) if variant(id) == *ctor_id => {\n                         let args = match args {\n                             Some(args) => args.iter().map(|x| *x).collect(),\n-                            None => vec::from_elem(arity, wild())\n+                            None => Vec::from_elem(arity, wild())\n                         };\n-                        Some(vec::append(args, r.tail()))\n+                        Some(vec_ng::append(args, r.tail()))\n                     }\n                     DefVariant(_, _, _) => None,\n \n@@ -689,9 +699,9 @@ fn specialize(cx: &MatchCheckCtxt,\n                             Some(args) => {\n                                 new_args = args.iter().map(|x| *x).collect()\n                             }\n-                            None => new_args = vec::from_elem(arity, wild())\n+                            None => new_args = Vec::from_elem(arity, wild())\n                         }\n-                        Some(vec::append(new_args, r.tail()))\n+                        Some(vec_ng::append(new_args, r.tail()))\n                     }\n                     _ => None\n                 }\n@@ -712,7 +722,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                                     _ => wild()\n                                 }\n                             });\n-                            Some(vec::append(args, r.tail()))\n+                            Some(vec_ng::append(args, r.tail()))\n                         } else {\n                             None\n                         }\n@@ -743,15 +753,15 @@ fn specialize(cx: &MatchCheckCtxt,\n                                 _ => wild()\n                             }\n                         }).collect();\n-                        Some(vec::append(args, r.tail()))\n+                        Some(vec_ng::append(args, r.tail()))\n                     }\n                 }\n             }\n             PatTup(args) => {\n-                Some(vec::append(args.iter().map(|x| *x).collect(), r.tail()))\n+                Some(vec_ng::append(args.iter().map(|x| *x).collect(), r.tail()))\n             }\n             PatUniq(a) | PatRegion(a) => {\n-                Some(vec::append(~[a], r.tail()))\n+                Some(vec_ng::append(vec!(a), r.tail()))\n             }\n             PatLit(expr) => {\n                 let e_v = eval_const_expr(cx.tcx, expr);\n@@ -781,13 +791,17 @@ fn specialize(cx: &MatchCheckCtxt,\n                     single => true,\n                     _ => fail!(\"type error\")\n                 };\n-                if match_ { Some(r.tail().to_owned()) } else { None }\n+                if match_ {\n+                    Some(Vec::from_slice(r.tail()))\n+                } else {\n+                    None\n+                }\n             }\n             PatRange(lo, hi) => {\n                 let (c_lo, c_hi) = match *ctor_id {\n                     val(ref v) => ((*v).clone(), (*v).clone()),\n                     range(ref lo, ref hi) => ((*lo).clone(), (*hi).clone()),\n-                    single => return Some(r.tail().to_owned()),\n+                    single => return Some(Vec::from_slice(r.tail())),\n                     _ => fail!(\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo);\n@@ -797,7 +811,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                 let m2 = compare_const_vals(&c_hi, &v_hi);\n                 match (m1, m2) {\n                     (Some(val1), Some(val2)) if val1 >= 0 && val2 <= 0 => {\n-                        Some(r.tail().to_owned())\n+                        Some(Vec::from_slice(r.tail()))\n                     },\n                     (Some(_), Some(_)) => None,\n                     _ => {\n@@ -812,7 +826,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                     vec(_) => {\n                         let num_elements = before.len() + after.len();\n                         if num_elements < arity && slice.is_some() {\n-                            let mut result = ~[];\n+                            let mut result = Vec::new();\n                             for pat in before.iter() {\n                                 result.push((*pat).clone());\n                             }\n@@ -827,7 +841,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                             }\n                             Some(result)\n                         } else if num_elements == arity {\n-                            let mut result = ~[];\n+                            let mut result = Vec::new();\n                             for pat in before.iter() {\n                                 result.push((*pat).clone());\n                             }\n@@ -849,9 +863,12 @@ fn specialize(cx: &MatchCheckCtxt,\n     }\n }\n \n-fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<~[@Pat]> {\n-    if is_wild(cx, r[0]) { Some(r.tail().to_owned()) }\n-    else { None }\n+fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<Vec<@Pat> > {\n+    if is_wild(cx, r[0]) {\n+        Some(Vec::from_slice(r.tail()))\n+    } else {\n+        None\n+    }\n }\n \n fn check_local(v: &mut CheckMatchVisitor,"}, {"sha": "aaa623bd7b2fd527597d4bb85f3a7baa47e70252", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -27,6 +27,7 @@ use syntax::{ast, ast_map, ast_util};\n use std::cell::RefCell;\n use collections::HashMap;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -321,7 +322,7 @@ pub enum const_val {\n     const_int(i64),\n     const_uint(u64),\n     const_str(InternedString),\n-    const_binary(Rc<~[u8]>),\n+    const_binary(Rc<Vec<u8> >),\n     const_bool(bool)\n }\n "}, {"sha": "ba3fc34023d1828917b192a3dde7fef5970a95fc", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -20,6 +20,7 @@\n use std::io;\n use std::uint;\n use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::IdRange;\n@@ -54,15 +55,14 @@ pub struct DataFlowContext<O> {\n     // the full vector (see the method `compute_id_range()`).\n \n     /// bits generated as we exit the scope `id`. Updated by `add_gen()`.\n-    priv gens: ~[uint],\n+    priv gens: Vec<uint> ,\n \n     /// bits killed as we exit the scope `id`. Updated by `add_kill()`.\n-    priv kills: ~[uint],\n+    priv kills: Vec<uint> ,\n \n     /// bits that are valid on entry to the scope `id`. Updated by\n     /// `propagate()`.\n-    priv on_entry: ~[uint]\n-}\n+    priv on_entry: Vec<uint> }\n \n /// Parameterization for the precise form of data flow that is used.\n pub trait DataFlowOperator {\n@@ -80,7 +80,7 @@ struct PropagationContext<'a, O> {\n \n struct LoopScope<'a> {\n     loop_id: ast::NodeId,\n-    break_bits: ~[uint]\n+    break_bits: Vec<uint>\n }\n \n impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n@@ -131,9 +131,9 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         debug!(\"DataFlowContext::new(id_range={:?}, bits_per_id={:?}, words_per_id={:?})\",\n                id_range, bits_per_id, words_per_id);\n \n-        let gens = ~[];\n-        let kills = ~[];\n-        let on_entry = ~[];\n+        let gens = Vec::new();\n+        let kills = Vec::new();\n+        let on_entry = Vec::new();\n \n         DataFlowContext {\n             tcx: tcx,\n@@ -332,7 +332,7 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n             };\n \n             let mut temp = vec::from_elem(self.words_per_id, 0u);\n-            let mut loop_scopes = ~[];\n+            let mut loop_scopes = Vec::new();\n \n             while propcx.changed {\n                 propcx.changed = false;\n@@ -367,7 +367,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_block(&mut self,\n                   blk: &ast::Block,\n                   in_out: &mut [uint],\n-                  loop_scopes: &mut ~[LoopScope]) {\n+                  loop_scopes: &mut Vec<LoopScope> ) {\n         debug!(\"DataFlowContext::walk_block(blk.id={}, in_out={})\",\n                blk.id, bits_to_str(in_out));\n \n@@ -385,7 +385,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_stmt(&mut self,\n                  stmt: @ast::Stmt,\n                  in_out: &mut [uint],\n-                 loop_scopes: &mut ~[LoopScope]) {\n+                 loop_scopes: &mut Vec<LoopScope> ) {\n         match stmt.node {\n             ast::StmtDecl(decl, _) => {\n                 self.walk_decl(decl, in_out, loop_scopes);\n@@ -404,7 +404,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_decl(&mut self,\n                  decl: @ast::Decl,\n                  in_out: &mut [uint],\n-                 loop_scopes: &mut ~[LoopScope]) {\n+                 loop_scopes: &mut Vec<LoopScope> ) {\n         match decl.node {\n             ast::DeclLocal(local) => {\n                 self.walk_opt_expr(local.init, in_out, loop_scopes);\n@@ -418,7 +418,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_expr(&mut self,\n                  expr: &ast::Expr,\n                  in_out: &mut [uint],\n-                 loop_scopes: &mut ~[LoopScope]) {\n+                 loop_scopes: &mut Vec<LoopScope> ) {\n         debug!(\"DataFlowContext::walk_expr(expr={}, in_out={})\",\n                expr.repr(self.dfcx.tcx), bits_to_str(in_out));\n \n@@ -469,12 +469,12 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 let mut body_bits = in_out.to_owned();\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n-                    break_bits: in_out.to_owned()\n+                    break_bits: Vec::from_slice(in_out)\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n                 let new_loop_scope = loop_scopes.pop().unwrap();\n-                copy_bits(new_loop_scope.break_bits, in_out);\n+                copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n             }\n \n             ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n@@ -493,14 +493,14 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 self.reset(in_out);\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n-                    break_bits: in_out.to_owned()\n+                    break_bits: Vec::from_slice(in_out)\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n \n                 let new_loop_scope = loop_scopes.pop().unwrap();\n                 assert_eq!(new_loop_scope.loop_id, expr.id);\n-                copy_bits(new_loop_scope.break_bits, in_out);\n+                copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n             }\n \n             ast::ExprMatch(discr, ref arms) => {\n@@ -691,7 +691,9 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                      in_out: &mut [uint]) {\n         self.pop_scopes(from_expr, to_scope, in_out);\n         self.dfcx.apply_kill(from_expr.id, in_out);\n-        join_bits(&self.dfcx.oper, in_out, to_scope.break_bits);\n+        join_bits(&self.dfcx.oper,\n+                  in_out,\n+                  to_scope.break_bits.as_mut_slice());\n         debug!(\"break_from_to(from_expr={}, to_scope={}) final break_bits={}\",\n                from_expr.repr(self.tcx()),\n                to_scope.loop_id,\n@@ -701,7 +703,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_exprs(&mut self,\n                   exprs: &[@ast::Expr],\n                   in_out: &mut [uint],\n-                  loop_scopes: &mut ~[LoopScope]) {\n+                  loop_scopes: &mut Vec<LoopScope> ) {\n         for &expr in exprs.iter() {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n@@ -710,7 +712,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_opt_expr(&mut self,\n                      opt_expr: Option<@ast::Expr>,\n                      in_out: &mut [uint],\n-                     loop_scopes: &mut ~[LoopScope]) {\n+                     loop_scopes: &mut Vec<LoopScope> ) {\n         for &expr in opt_expr.iter() {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n@@ -720,7 +722,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                  call_id: ast::NodeId,\n                  args: &[@ast::Expr],\n                  in_out: &mut [uint],\n-                 loop_scopes: &mut ~[LoopScope]) {\n+                 loop_scopes: &mut Vec<LoopScope> ) {\n         self.walk_exprs(args, in_out, loop_scopes);\n \n         // FIXME(#6268) nested method calls\n@@ -737,7 +739,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_pat(&mut self,\n                 pat: @ast::Pat,\n                 in_out: &mut [uint],\n-                _loop_scopes: &mut ~[LoopScope]) {\n+                _loop_scopes: &mut Vec<LoopScope> ) {\n         debug!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n                pat.repr(self.dfcx.tcx), bits_to_str(in_out));\n \n@@ -752,7 +754,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_pat_alternatives(&mut self,\n                              pats: &[@ast::Pat],\n                              in_out: &mut [uint],\n-                             loop_scopes: &mut ~[LoopScope]) {\n+                             loop_scopes: &mut Vec<LoopScope> ) {\n         if pats.len() == 1 {\n             // Common special case:\n             return self.walk_pat(pats[0], in_out, loop_scopes);\n@@ -769,10 +771,12 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n         }\n     }\n \n-    fn find_scope<'a>(&self,\n-                      expr: &ast::Expr,\n-                      label: Option<ast::Ident>,\n-                      loop_scopes: &'a mut ~[LoopScope]) -> &'a mut LoopScope {\n+    fn find_scope<'a,'b>(\n+                  &self,\n+                  expr: &ast::Expr,\n+                  label: Option<ast::Ident>,\n+                  loop_scopes: &'a mut Vec<LoopScope<'b>>)\n+                  -> &'a mut LoopScope<'b> {\n         let index = match label {\n             None => {\n                 let len = loop_scopes.len();\n@@ -802,7 +806,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             }\n         };\n \n-        &mut loop_scopes[index]\n+        loop_scopes.get_mut(index)\n     }\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {"}, {"sha": "d226f2561b7bdae0d4e5dea031fa5f112f08e288", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -19,6 +19,7 @@ use middle::typeck;\n use util::nodemap::NodeSet;\n \n use collections::HashSet;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, def_id_of_def, is_local};\n@@ -49,7 +50,7 @@ fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n }\n \n struct MarkSymbolVisitor {\n-    worklist: ~[ast::NodeId],\n+    worklist: Vec<ast::NodeId> ,\n     method_map: typeck::MethodMap,\n     tcx: ty::ctxt,\n     live_symbols: ~HashSet<ast::NodeId>,\n@@ -58,7 +59,7 @@ struct MarkSymbolVisitor {\n impl MarkSymbolVisitor {\n     fn new(tcx: ty::ctxt,\n            method_map: typeck::MethodMap,\n-           worklist: ~[ast::NodeId]) -> MarkSymbolVisitor {\n+           worklist: Vec<ast::NodeId> ) -> MarkSymbolVisitor {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             method_map: method_map,\n@@ -216,7 +217,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n struct LifeSeeder {\n-    worklist: ~[ast::NodeId],\n+    worklist: Vec<ast::NodeId> ,\n }\n \n impl Visitor<()> for LifeSeeder {\n@@ -254,8 +255,8 @@ impl Visitor<()> for LifeSeeder {\n fn create_and_seed_worklist(tcx: ty::ctxt,\n                             exported_items: &privacy::ExportedItems,\n                             reachable_symbols: &NodeSet,\n-                            krate: &ast::Crate) -> ~[ast::NodeId] {\n-    let mut worklist = ~[];\n+                            krate: &ast::Crate) -> Vec<ast::NodeId> {\n+    let mut worklist = Vec::new();\n \n     // Preferably, we would only need to seed the worklist with reachable\n     // symbols. However, since the set of reachable symbols differs"}, {"sha": "a4ff72d55f259f5cfa2ad1d9cdd0409bcb8992ba", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -11,6 +11,7 @@\n \n use driver::session;\n use driver::session::Session;\n+use std::vec_ng::Vec;\n use syntax::ast::{Crate, Name, NodeId, Item, ItemFn};\n use syntax::ast_map;\n use syntax::attr;\n@@ -38,7 +39,7 @@ struct EntryContext<'a> {\n \n     // The functions that one might think are 'main' but aren't, e.g.\n     // main functions not defined at the top level. For diagnostics.\n-    non_main_fns: ~[(NodeId, Span)],\n+    non_main_fns: Vec<(NodeId, Span)> ,\n }\n \n impl<'a> Visitor<()> for EntryContext<'a> {\n@@ -66,7 +67,7 @@ pub fn find_entry_point(session: Session, krate: &Crate, ast_map: &ast_map::Map)\n         main_fn: None,\n         attr_main_fn: None,\n         start_fn: None,\n-        non_main_fns: ~[],\n+        non_main_fns: Vec::new(),\n     };\n \n     visit::walk_crate(&mut ctxt, krate, ());"}, {"sha": "8b8807e46f5dd103caa9c585f4acbb0f1be108d2", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -17,6 +17,7 @@ use middle::resolve;\n use middle::ty;\n use util::nodemap::{NodeMap, NodeSet};\n \n+use std::vec_ng::Vec;\n use syntax::codemap::Span;\n use syntax::{ast, ast_util};\n use syntax::visit;\n@@ -29,12 +30,12 @@ pub struct freevar_entry {\n     def: ast::Def, //< The variable being accessed free.\n     span: Span     //< First span where it is accessed (there can be multiple)\n }\n-pub type freevar_info = @~[@freevar_entry];\n+pub type freevar_info = @Vec<@freevar_entry> ;\n pub type freevar_map = NodeMap<freevar_info>;\n \n struct CollectFreevarsVisitor {\n     seen: NodeSet,\n-    refs: ~[@freevar_entry],\n+    refs: Vec<@freevar_entry> ,\n     def_map: resolve::DefMap,\n }\n \n@@ -90,7 +91,7 @@ impl Visitor<int> for CollectFreevarsVisitor {\n // in order to start the search.\n fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block) -> freevar_info {\n     let seen = NodeSet::new();\n-    let refs = ~[];\n+    let refs = Vec::new();\n \n     let mut v = CollectFreevarsVisitor {\n         seen: seen,"}, {"sha": "160a541bc34dd7da361e5d5dc8199b488cb15c97", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -35,11 +35,11 @@ be indexed by the direction (see the type `Direction`).\n */\n \n use std::uint;\n-use std::vec;\n+use std::vec_ng::Vec;\n \n pub struct Graph<N,E> {\n-    priv nodes: ~[Node<N>],\n-    priv edges: ~[Edge<E>],\n+    priv nodes: Vec<Node<N>> ,\n+    priv edges: Vec<Edge<E>> ,\n }\n \n pub struct Node<N> {\n@@ -77,27 +77,32 @@ impl EdgeIndex {\n \n impl<N,E> Graph<N,E> {\n     pub fn new() -> Graph<N,E> {\n-        Graph {nodes: ~[], edges: ~[]}\n+        Graph {\n+            nodes: Vec::new(),\n+            edges: Vec::new(),\n+        }\n     }\n \n     pub fn with_capacity(num_nodes: uint,\n                          num_edges: uint) -> Graph<N,E> {\n-        Graph {nodes: vec::with_capacity(num_nodes),\n-               edges: vec::with_capacity(num_edges)}\n+        Graph {\n+            nodes: Vec::with_capacity(num_nodes),\n+            edges: Vec::with_capacity(num_edges),\n+        }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n     // Simple accessors\n \n     #[inline]\n     pub fn all_nodes<'a>(&'a self) -> &'a [Node<N>] {\n-        let nodes: &'a [Node<N>] = self.nodes;\n+        let nodes: &'a [Node<N>] = self.nodes.as_slice();\n         nodes\n     }\n \n     #[inline]\n     pub fn all_edges<'a>(&'a self) -> &'a [Edge<E>] {\n-        let edges: &'a [Edge<E>] = self.edges;\n+        let edges: &'a [Edge<E>] = self.edges.as_slice();\n         edges\n     }\n \n@@ -118,15 +123,15 @@ impl<N,E> Graph<N,E> {\n     }\n \n     pub fn mut_node_data<'a>(&'a mut self, idx: NodeIndex) -> &'a mut N {\n-        &mut self.nodes[idx.get()].data\n+        &mut self.nodes.get_mut(idx.get()).data\n     }\n \n     pub fn node_data<'a>(&'a self, idx: NodeIndex) -> &'a N {\n-        &self.nodes[idx.get()].data\n+        &self.nodes.get(idx.get()).data\n     }\n \n     pub fn node<'a>(&'a self, idx: NodeIndex) -> &'a Node<N> {\n-        &self.nodes[idx.get()]\n+        self.nodes.get(idx.get())\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -143,8 +148,10 @@ impl<N,E> Graph<N,E> {\n         let idx = self.next_edge_index();\n \n         // read current first of the list of edges from each node\n-        let source_first = self.nodes[source.get()].first_edge[Outgoing.repr];\n-        let target_first = self.nodes[target.get()].first_edge[Incoming.repr];\n+        let source_first = self.nodes.get(source.get())\n+                                     .first_edge[Outgoing.repr];\n+        let target_first = self.nodes.get(target.get())\n+                                     .first_edge[Incoming.repr];\n \n         // create the new edge, with the previous firsts from each node\n         // as the next pointers\n@@ -156,38 +163,38 @@ impl<N,E> Graph<N,E> {\n         });\n \n         // adjust the firsts for each node target be the next object.\n-        self.nodes[source.get()].first_edge[Outgoing.repr] = idx;\n-        self.nodes[target.get()].first_edge[Incoming.repr] = idx;\n+        self.nodes.get_mut(source.get()).first_edge[Outgoing.repr] = idx;\n+        self.nodes.get_mut(target.get()).first_edge[Incoming.repr] = idx;\n \n         return idx;\n     }\n \n     pub fn mut_edge_data<'a>(&'a mut self, idx: EdgeIndex) -> &'a mut E {\n-        &mut self.edges[idx.get()].data\n+        &mut self.edges.get_mut(idx.get()).data\n     }\n \n     pub fn edge_data<'a>(&'a self, idx: EdgeIndex) -> &'a E {\n-        &self.edges[idx.get()].data\n+        &self.edges.get(idx.get()).data\n     }\n \n     pub fn edge<'a>(&'a self, idx: EdgeIndex) -> &'a Edge<E> {\n-        &self.edges[idx.get()]\n+        self.edges.get(idx.get())\n     }\n \n     pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the index of the first edge adjacent to `node`.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.nodes[node.get()].first_edge[dir.repr]\n+        self.nodes.get(node.get()).first_edge[dir.repr]\n     }\n \n     pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the next edge in a given direction.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.edges[edge.get()].next_edge[dir.repr]\n+        self.edges.get(edge.get()).next_edge[dir.repr]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -231,7 +238,7 @@ impl<N,E> Graph<N,E> {\n \n         let mut edge_idx = self.first_adjacent(node, dir);\n         while edge_idx != InvalidEdgeIndex {\n-            let edge = &self.edges[edge_idx.get()];\n+            let edge = self.edges.get(edge_idx.get());\n             if !f(edge_idx, edge) {\n                 return false;\n             }"}, {"sha": "90c86cb5e74e2613573bed75859fbf1a0283df28", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -16,6 +16,7 @@ use middle::typeck;\n use util::ppaux::{Repr, ty_to_str};\n use util::ppaux::UserString;\n \n+use std::vec_ng::Vec;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -94,7 +95,7 @@ fn check_struct_safe_for_destructor(cx: &mut Context,\n         let struct_ty = ty::mk_struct(cx.tcx, struct_did, ty::substs {\n             regions: ty::NonerasedRegions(opt_vec::Empty),\n             self_ty: None,\n-            tps: ~[]\n+            tps: Vec::new()\n         });\n         if !ty::type_is_sendable(cx.tcx, struct_ty) {\n             cx.tcx.sess.span_err(span,\n@@ -533,7 +534,7 @@ pub fn check_cast_for_escaping_regions(\n     // Collect up the regions that appear in the target type.  We want to\n     // ensure that these lifetimes are shorter than all lifetimes that are in\n     // the source type.  See test `src/test/compile-fail/regions-trait-2.rs`\n-    let mut target_regions = ~[];\n+    let mut target_regions = Vec::new();\n     ty::walk_regions_and_ty(\n         cx.tcx,\n         target_ty,"}, {"sha": "ccf81840a418538efacc328ff31d7d34eff81c34", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -33,6 +33,7 @@ use syntax::visit;\n use collections::HashMap;\n use std::iter::Enumerate;\n use std::vec;\n+use std::vec_ng::Vec;\n \n // The actual lang items defined come at the end of this file in one handy table.\n // So you probably just want to nip down to the end.\n@@ -47,15 +48,15 @@ pub enum LangItem {\n }\n \n pub struct LanguageItems {\n-    items: ~[Option<ast::DefId>],\n+    items: Vec<Option<ast::DefId>> ,\n }\n \n impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         fn foo(_: LangItem) -> Option<ast::DefId> { None }\n \n         LanguageItems {\n-            items: ~[$(foo($variant)),*]\n+            items: vec!($(foo($variant)),*)\n         }\n     }\n \n@@ -72,10 +73,12 @@ impl LanguageItems {\n     }\n \n     pub fn require(&self, it: LangItem) -> Result<ast::DefId, ~str> {\n-        match self.items[it as uint] {\n-            Some(id) => Ok(id),\n-            None => Err(format!(\"requires `{}` lang_item\",\n-                             LanguageItems::item_name(it as uint)))\n+        match self.items.get(it as uint) {\n+            &Some(id) => Ok(id),\n+            &None => {\n+                Err(format!(\"requires `{}` lang_item\",\n+                            LanguageItems::item_name(it as uint)))\n+            }\n         }\n     }\n \n@@ -95,7 +98,7 @@ impl LanguageItems {\n \n     $(\n         pub fn $method(&self) -> Option<ast::DefId> {\n-            self.items[$variant as uint]\n+            *self.items.get($variant as uint)\n         }\n     )*\n }\n@@ -147,18 +150,18 @@ impl LanguageItemCollector {\n \n     pub fn collect_item(&mut self, item_index: uint, item_def_id: ast::DefId) {\n         // Check for duplicates.\n-        match self.items.items[item_index] {\n-            Some(original_def_id) if original_def_id != item_def_id => {\n+        match self.items.items.get(item_index) {\n+            &Some(original_def_id) if original_def_id != item_def_id => {\n                 self.session.err(format!(\"duplicate entry for `{}`\",\n                                       LanguageItems::item_name(item_index)));\n             }\n-            Some(_) | None => {\n+            &Some(_) | &None => {\n                 // OK.\n             }\n         }\n \n         // Matched.\n-        self.items.items[item_index] = Some(item_def_id);\n+        *self.items.items.get_mut(item_index) = Some(item_def_id);\n     }\n \n     pub fn collect_local_language_items(&mut self, krate: &ast::Crate) {"}, {"sha": "ddf75d1f0b652d9638d172fb83d3f8108c665be6", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -45,7 +45,6 @@ use middle::ty;\n use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n use middle::typeck::infer;\n use middle::typeck;\n-use std::to_str::ToStr;\n use util::ppaux::{ty_to_str};\n \n use std::cmp;\n@@ -54,10 +53,12 @@ use std::i16;\n use std::i32;\n use std::i64;\n use std::i8;\n+use std::to_str::ToStr;\n use std::u16;\n use std::u32;\n use std::u64;\n use std::u8;\n+use std::vec_ng::Vec;\n use collections::SmallIntMap;\n use syntax::ast_map;\n use syntax::ast_util::IdVisitingOperation;\n@@ -432,7 +433,7 @@ struct Context<'a> {\n     // When recursing into an attributed node of the ast which modifies lint\n     // levels, this stack keeps track of the previous lint levels of whatever\n     // was modified.\n-    lint_stack: ~[(Lint, level, LintSource)],\n+    lint_stack: Vec<(Lint, level, LintSource)> ,\n \n     // id of the last visited negated expression\n     negated_expr_id: ast::NodeId\n@@ -1091,7 +1092,7 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n                 }\n             } else {\n                 csearch::get_item_attrs(cx.tcx.sess.cstore, did, |attrs| {\n-                    if attr::contains_name(attrs, \"must_use\") {\n+                    if attr::contains_name(attrs.as_slice(), \"must_use\") {\n                         cx.span_lint(UnusedMustUse, s.span,\n                                      \"unused result which must be used\");\n                         warned = true;\n@@ -1738,7 +1739,7 @@ pub fn check_crate(tcx: ty::ctxt,\n         exported_items: exported_items,\n         cur_struct_def_id: -1,\n         is_doc_hidden: false,\n-        lint_stack: ~[],\n+        lint_stack: Vec::new(),\n         negated_expr_id: -1\n     };\n "}, {"sha": "04f2b2f28231935aaf3a229c0d5503a93c8be6a0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -116,7 +116,7 @@ use std::fmt;\n use std::io;\n use std::str;\n use std::uint;\n-use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n@@ -260,9 +260,9 @@ pub struct IrMaps {\n     num_vars: Cell<uint>,\n     live_node_map: RefCell<NodeMap<LiveNode>>,\n     variable_map: RefCell<NodeMap<Variable>>,\n-    capture_info_map: RefCell<NodeMap<@~[CaptureInfo]>>,\n-    var_kinds: RefCell<~[VarKind]>,\n-    lnks: RefCell<~[LiveNodeKind]>,\n+    capture_info_map: RefCell<NodeMap<@Vec<CaptureInfo> >>,\n+    var_kinds: RefCell<Vec<VarKind> >,\n+    lnks: RefCell<Vec<LiveNodeKind> >,\n }\n \n fn IrMaps(tcx: ty::ctxt,\n@@ -278,8 +278,8 @@ fn IrMaps(tcx: ty::ctxt,\n         live_node_map: RefCell::new(NodeMap::new()),\n         variable_map: RefCell::new(NodeMap::new()),\n         capture_info_map: RefCell::new(NodeMap::new()),\n-        var_kinds: RefCell::new(~[]),\n-        lnks: RefCell::new(~[]),\n+        var_kinds: RefCell::new(Vec::new()),\n+        lnks: RefCell::new(Vec::new()),\n     }\n }\n \n@@ -339,20 +339,20 @@ impl IrMaps {\n \n     pub fn variable_name(&self, var: Variable) -> ~str {\n         let var_kinds = self.var_kinds.borrow();\n-        match var_kinds.get()[var.get()] {\n-            Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n+        match var_kinds.get().get(var.get()) {\n+            &Local(LocalInfo { ident: nm, .. }) | &Arg(_, nm) => {\n                 token::get_ident(nm).get().to_str()\n             },\n-            ImplicitRet => ~\"<implicit-ret>\"\n+            &ImplicitRet => ~\"<implicit-ret>\"\n         }\n     }\n \n-    pub fn set_captures(&self, node_id: NodeId, cs: ~[CaptureInfo]) {\n+    pub fn set_captures(&self, node_id: NodeId, cs: Vec<CaptureInfo> ) {\n         let mut capture_info_map = self.capture_info_map.borrow_mut();\n         capture_info_map.get().insert(node_id, @cs);\n     }\n \n-    pub fn captures(&self, expr: &Expr) -> @~[CaptureInfo] {\n+    pub fn captures(&self, expr: &Expr) -> @Vec<CaptureInfo> {\n         let capture_info_map = self.capture_info_map.borrow();\n         match capture_info_map.get().find(&expr.id) {\n           Some(&caps) => caps,\n@@ -364,7 +364,7 @@ impl IrMaps {\n \n     pub fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n         let lnks = self.lnks.borrow();\n-        lnks.get()[ln.get()]\n+        *lnks.get().get(ln.get())\n     }\n }\n \n@@ -504,7 +504,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n         // construction site.\n         let capture_map = this.capture_map.borrow();\n         let cvs = capture_map.get().get(&expr.id);\n-        let mut call_caps = ~[];\n+        let mut call_caps = Vec::new();\n         for cv in cvs.borrow().iter() {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n@@ -590,11 +590,11 @@ pub struct Liveness {\n     tcx: ty::ctxt,\n     ir: @IrMaps,\n     s: Specials,\n-    successors: @RefCell<~[LiveNode]>,\n-    users: @RefCell<~[Users]>,\n+    successors: @RefCell<Vec<LiveNode> >,\n+    users: @RefCell<Vec<Users> >,\n     // The list of node IDs for the nested loop scopes\n     // we're in.\n-    loop_scope: @RefCell<~[NodeId]>,\n+    loop_scope: @RefCell<Vec<NodeId> >,\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n@@ -607,12 +607,12 @@ fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n         ir: ir,\n         tcx: ir.tcx,\n         s: specials,\n-        successors: @RefCell::new(vec::from_elem(ir.num_live_nodes.get(),\n+        successors: @RefCell::new(Vec::from_elem(ir.num_live_nodes.get(),\n                                                  invalid_node())),\n-        users: @RefCell::new(vec::from_elem(ir.num_live_nodes.get() *\n+        users: @RefCell::new(Vec::from_elem(ir.num_live_nodes.get() *\n                                             ir.num_vars.get(),\n                                             invalid_users())),\n-        loop_scope: @RefCell::new(~[]),\n+        loop_scope: @RefCell::new(Vec::new()),\n         break_ln: @RefCell::new(NodeMap::new()),\n         cont_ln: @RefCell::new(NodeMap::new()),\n     }\n@@ -686,7 +686,7 @@ impl Liveness {\n                          -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n         let users = self.users.borrow();\n-        let reader = users.get()[self.idx(ln, var)].reader;\n+        let reader = users.get().get(self.idx(ln, var)).reader;\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n \n@@ -697,30 +697,30 @@ impl Liveness {\n                         -> Option<LiveNodeKind> {\n         let successor = {\n             let successors = self.successors.borrow();\n-            successors.get()[ln.get()]\n+            *successors.get().get(ln.get())\n         };\n         self.live_on_entry(successor, var)\n     }\n \n     pub fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert!(ln.is_valid());\n         let users = self.users.borrow();\n-        users.get()[self.idx(ln, var)].used\n+        users.get().get(self.idx(ln, var)).used\n     }\n \n     pub fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n                              -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n         let users = self.users.borrow();\n-        let writer = users.get()[self.idx(ln, var)].writer;\n+        let writer = users.get().get(self.idx(ln, var)).writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n \n     pub fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n                             -> Option<LiveNodeKind> {\n         let successor = {\n             let successors = self.successors.borrow();\n-            successors.get()[ln.get()]\n+            *successors.get().get(ln.get())\n         };\n         self.assigned_on_entry(successor, var)\n     }\n@@ -795,14 +795,14 @@ impl Liveness {\n                 write!(wr,\n                        \"[ln({}) of kind {:?} reads\",\n                        ln.get(),\n-                       lnks.and_then(|lnks| Some(lnks.get()[ln.get()])));\n+                       lnks.and_then(|lnks| Some(*lnks.get().get(ln.get()))));\n             }\n             let users = self.users.try_borrow();\n             match users {\n                 Some(users) => {\n-                    self.write_vars(wr, ln, |idx| users.get()[idx].reader);\n+                    self.write_vars(wr, ln, |idx| users.get().get(idx).reader);\n                     write!(wr, \"  writes\");\n-                    self.write_vars(wr, ln, |idx| users.get()[idx].writer);\n+                    self.write_vars(wr, ln, |idx| users.get().get(idx).writer);\n                 }\n                 None => {\n                     write!(wr, \"  (users borrowed)\");\n@@ -811,7 +811,9 @@ impl Liveness {\n             let successors = self.successors.try_borrow();\n             match successors {\n                 Some(successors) => {\n-                    write!(wr, \"  precedes {}]\", successors.get()[ln.get()].to_str());\n+                    write!(wr,\n+                           \"  precedes {}]\",\n+                           successors.get().get(ln.get()).to_str());\n                 }\n                 None => {\n                     write!(wr, \"  precedes (successors borrowed)]\");\n@@ -824,7 +826,7 @@ impl Liveness {\n     pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n         {\n             let mut successors = self.successors.borrow_mut();\n-            successors.get()[ln.get()] = succ_ln;\n+            *successors.get().get_mut(ln.get()) = succ_ln;\n         }\n \n         // It is not necessary to initialize the\n@@ -841,12 +843,12 @@ impl Liveness {\n         // more efficient version of init_empty() / merge_from_succ()\n         {\n             let mut successors = self.successors.borrow_mut();\n-            successors.get()[ln.get()] = succ_ln;\n+            *successors.get().get_mut(ln.get()) = succ_ln;\n         }\n \n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n             let mut users = self.users.borrow_mut();\n-            users.get()[idx] = users.get()[succ_idx]\n+            *users.get().get_mut(idx) = *users.get().get(succ_idx)\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n@@ -862,12 +864,12 @@ impl Liveness {\n         let mut changed = false;\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n             let mut users = self.users.borrow_mut();\n-            changed |= copy_if_invalid(users.get()[succ_idx].reader,\n-                                       &mut users.get()[idx].reader);\n-            changed |= copy_if_invalid(users.get()[succ_idx].writer,\n-                                       &mut users.get()[idx].writer);\n-            if users.get()[succ_idx].used && !users.get()[idx].used {\n-                users.get()[idx].used = true;\n+            changed |= copy_if_invalid(users.get().get(succ_idx).reader,\n+                                       &mut users.get().get_mut(idx).reader);\n+            changed |= copy_if_invalid(users.get().get(succ_idx).writer,\n+                                       &mut users.get().get_mut(idx).writer);\n+            if users.get().get(succ_idx).used && !users.get().get(idx).used {\n+                users.get().get_mut(idx).used = true;\n                 changed = true;\n             }\n         });\n@@ -893,8 +895,8 @@ impl Liveness {\n     pub fn define(&self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n         let mut users = self.users.borrow_mut();\n-        users.get()[idx].reader = invalid_node();\n-        users.get()[idx].writer = invalid_node();\n+        users.get().get_mut(idx).reader = invalid_node();\n+        users.get().get_mut(idx).writer = invalid_node();\n \n         debug!(\"{} defines {} (idx={}): {}\", writer.to_str(), var.to_str(),\n                idx, self.ln_str(writer));\n@@ -904,7 +906,7 @@ impl Liveness {\n     pub fn acc(&self, ln: LiveNode, var: Variable, acc: uint) {\n         let idx = self.idx(ln, var);\n         let mut users = self.users.borrow_mut();\n-        let user = &mut users.get()[idx];\n+        let user = users.get().get_mut(idx);\n \n         if (acc & ACC_WRITE) != 0 {\n             user.reader = invalid_node();"}, {"sha": "ba93e52bc48eced6ad2a2c2c86f0433ec5db7bc1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -65,6 +65,7 @@\n use middle::ty;\n use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n \n+use std::vec_ng::Vec;\n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -723,7 +724,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         // know what type lies at the other end, so we just call it\n         // `()` (the empty tuple).\n \n-        let opaque_ty = ty::mk_tup(self.tcx(), ~[]);\n+        let opaque_ty = ty::mk_tup(self.tcx(), Vec::new());\n         return self.cat_deref_common(node, base_cmt, deref_cnt, opaque_ty);\n     }\n "}, {"sha": "16655474d3a85ef4834c487c4815f95536444ce4", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -139,6 +139,7 @@ use util::nodemap::{NodeMap, NodeSet};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n use syntax::ast::*;\n use syntax::ast_util;\n use syntax::visit;\n@@ -159,7 +160,7 @@ pub struct CaptureVar {\n     mode: CaptureMode // How variable is being accessed\n }\n \n-pub type CaptureMap = @RefCell<NodeMap<Rc<~[CaptureVar]>>>;\n+pub type CaptureMap = @RefCell<NodeMap<Rc<Vec<CaptureVar> >>>;\n \n pub type MovesMap = @RefCell<NodeSet>;\n \n@@ -680,7 +681,7 @@ impl VisitContext {\n         self.consume_expr(arg_expr)\n     }\n \n-    pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> Rc<~[CaptureVar]> {\n+    pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> Rc<Vec<CaptureVar> > {\n         debug!(\"compute_capture_vars(fn_expr_id={:?})\", fn_expr_id);\n         let _indenter = indenter();\n "}, {"sha": "3e645491699ecaf063c5a5120e48ff7bc175e847", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -12,6 +12,7 @@\n use middle::resolve;\n \n use collections::HashMap;\n+use std::vec_ng::Vec;\n use syntax::ast::*;\n use syntax::ast_util::{path_to_ident, walk_pat};\n use syntax::codemap::Span;\n@@ -88,8 +89,8 @@ pub fn pat_bindings(dm: resolve::DefMap,\n     });\n }\n \n-pub fn pat_binding_ids(dm: resolve::DefMap, pat: &Pat) -> ~[NodeId] {\n-    let mut found = ~[];\n+pub fn pat_binding_ids(dm: resolve::DefMap, pat: &Pat) -> Vec<NodeId> {\n+    let mut found = Vec::new();\n     pat_bindings(dm, pat, |_bm, b_id, _sp, _pt| found.push(b_id) );\n     return found;\n }"}, {"sha": "fac7e7a36e69cbb38c1199cee408e2c8c53fd08b", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -21,6 +21,7 @@ use middle::privacy;\n use util::nodemap::NodeSet;\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use collections::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n@@ -92,11 +93,11 @@ struct ReachableContext {\n     reachable_symbols: @RefCell<NodeSet>,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: @RefCell<~[ast::NodeId]>,\n+    worklist: @RefCell<Vec<ast::NodeId> >,\n }\n \n struct MarkSymbolVisitor {\n-    worklist: @RefCell<~[ast::NodeId]>,\n+    worklist: @RefCell<Vec<ast::NodeId> >,\n     method_map: typeck::MethodMap,\n     tcx: ty::ctxt,\n     reachable_symbols: @RefCell<NodeSet>,\n@@ -190,7 +191,7 @@ impl ReachableContext {\n             tcx: tcx,\n             method_map: method_map,\n             reachable_symbols: @RefCell::new(NodeSet::new()),\n-            worklist: @RefCell::new(~[]),\n+            worklist: @RefCell::new(Vec::new()),\n         }\n     }\n "}, {"sha": "15d228662c753a3454c946f806e801b64064d540", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -27,6 +27,7 @@ use middle::ty;\n use util::nodemap::NodeMap;\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n@@ -77,7 +78,7 @@ The region maps encode information about region relationships.\n pub struct RegionMaps {\n     priv scope_map: RefCell<NodeMap<ast::NodeId>>,\n     priv var_map: RefCell<NodeMap<ast::NodeId>>,\n-    priv free_region_map: RefCell<HashMap<FreeRegion, ~[FreeRegion]>>,\n+    priv free_region_map: RefCell<HashMap<FreeRegion, Vec<FreeRegion> >>,\n     priv rvalue_scopes: RefCell<NodeMap<ast::NodeId>>,\n     priv terminating_scopes: RefCell<HashSet<ast::NodeId>>,\n }\n@@ -113,7 +114,7 @@ impl RegionMaps {\n \n         debug!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n \n-        free_region_map.get().insert(sub, ~[sup]);\n+        free_region_map.get().insert(sub, vec!(sup));\n     }\n \n     pub fn record_encl_scope(&self, sub: ast::NodeId, sup: ast::NodeId) {\n@@ -283,11 +284,11 @@ impl RegionMaps {\n         // doubles as a way to detect if we've seen a particular FR\n         // before.  Note that we expect this graph to be an *extremely\n         // shallow* tree.\n-        let mut queue = ~[sub];\n+        let mut queue = vec!(sub);\n         let mut i = 0;\n         while i < queue.len() {\n             let free_region_map = self.free_region_map.borrow();\n-            match free_region_map.get().find(&queue[i]) {\n+            match free_region_map.get().find(queue.get(i)) {\n                 Some(parents) => {\n                     for parent in parents.iter() {\n                         if *parent == sup {\n@@ -369,7 +370,7 @@ impl RegionMaps {\n         // where they diverge.  If one vector is a suffix of the other,\n         // then the corresponding scope is a superscope of the other.\n \n-        if a_ancestors[a_index] != b_ancestors[b_index] {\n+        if *a_ancestors.get(a_index) != *b_ancestors.get(b_index) {\n             return None;\n         }\n \n@@ -380,16 +381,15 @@ impl RegionMaps {\n             if b_index == 0u { return Some(scope_b); }\n             a_index -= 1u;\n             b_index -= 1u;\n-            if a_ancestors[a_index] != b_ancestors[b_index] {\n-                return Some(a_ancestors[a_index + 1u]);\n+            if *a_ancestors.get(a_index) != *b_ancestors.get(b_index) {\n+                return Some(*a_ancestors.get(a_index + 1u));\n             }\n         }\n \n         fn ancestors_of(this: &RegionMaps, scope: ast::NodeId)\n-            -> ~[ast::NodeId]\n-        {\n+            -> Vec<ast::NodeId> {\n             // debug!(\"ancestors_of(scope={})\", scope);\n-            let mut result = ~[scope];\n+            let mut result = vec!(scope);\n             let mut scope = scope;\n             loop {\n                 let scope_map = this.scope_map.borrow();"}, {"sha": "77e44c137a983099ec4ad230cc2b258d3a28112f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 62, "deletions": 56, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -34,6 +34,7 @@ use syntax::visit::Visitor;\n use std::cell::{Cell, RefCell};\n use std::uint;\n use std::mem::replace;\n+use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n \n // Definition mapping\n@@ -48,11 +49,11 @@ struct binding_info {\n type BindingMap = HashMap<Name,binding_info>;\n \n // Trait method resolution\n-pub type TraitMap = NodeMap<~[DefId]>;\n+pub type TraitMap = NodeMap<Vec<DefId> >;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n-pub type ExportMap2 = @RefCell<NodeMap<~[Export2]>>;\n+pub type ExportMap2 = @RefCell<NodeMap<Vec<Export2> >>;\n \n pub struct Export2 {\n     name: ~str,        // The name of the target.\n@@ -319,15 +320,15 @@ impl Rib {\n \n /// One import directive.\n struct ImportDirective {\n-    module_path: ~[Ident],\n+    module_path: Vec<Ident> ,\n     subclass: @ImportDirectiveSubclass,\n     span: Span,\n     id: NodeId,\n     is_public: bool, // see note in ImportResolution about how to use this\n }\n \n impl ImportDirective {\n-    fn new(module_path: ~[Ident],\n+    fn new(module_path: Vec<Ident> ,\n            subclass: @ImportDirectiveSubclass,\n            span: Span,\n            id: NodeId,\n@@ -438,7 +439,7 @@ struct Module {\n     is_public: bool,\n \n     children: RefCell<HashMap<Name, @NameBindings>>,\n-    imports: RefCell<~[@ImportDirective]>,\n+    imports: RefCell<Vec<@ImportDirective> >,\n \n     // The external module children of this node that were declared with\n     // `extern crate`.\n@@ -488,7 +489,7 @@ impl Module {\n             kind: Cell::new(kind),\n             is_public: is_public,\n             children: RefCell::new(HashMap::new()),\n-            imports: RefCell::new(~[]),\n+            imports: RefCell::new(Vec::new()),\n             external_module_children: RefCell::new(HashMap::new()),\n             anonymous_children: RefCell::new(NodeMap::new()),\n             import_resolutions: RefCell::new(HashMap::new()),\n@@ -815,9 +816,9 @@ fn Resolver(session: Session,\n         unresolved_imports: 0,\n \n         current_module: current_module,\n-        value_ribs: @RefCell::new(~[]),\n-        type_ribs: @RefCell::new(~[]),\n-        label_ribs: @RefCell::new(~[]),\n+        value_ribs: @RefCell::new(Vec::new()),\n+        type_ribs: @RefCell::new(Vec::new()),\n+        label_ribs: @RefCell::new(Vec::new()),\n \n         current_trait_refs: None,\n \n@@ -826,7 +827,7 @@ fn Resolver(session: Session,\n \n         primitive_type_table: @PrimitiveTypeTable(),\n \n-        namespaces: ~[ TypeNS, ValueNS ],\n+        namespaces: vec!(TypeNS, ValueNS),\n \n         def_map: @RefCell::new(NodeMap::new()),\n         export_map2: @RefCell::new(NodeMap::new()),\n@@ -859,16 +860,16 @@ struct Resolver {\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: @RefCell<~[@Rib]>,\n+    value_ribs: @RefCell<Vec<@Rib> >,\n \n     // The current set of local scopes, for types.\n-    type_ribs: @RefCell<~[@Rib]>,\n+    type_ribs: @RefCell<Vec<@Rib> >,\n \n     // The current set of local scopes, for labels.\n-    label_ribs: @RefCell<~[@Rib]>,\n+    label_ribs: @RefCell<Vec<@Rib> >,\n \n     // The trait that the current context can refer to.\n-    current_trait_refs: Option<~[DefId]>,\n+    current_trait_refs: Option<Vec<DefId> >,\n \n     // The ident for the keyword \"self\".\n     self_ident: Ident,\n@@ -879,7 +880,7 @@ struct Resolver {\n     primitive_type_table: @PrimitiveTypeTable,\n \n     // The four namespaces.\n-    namespaces: ~[Namespace],\n+    namespaces: Vec<Namespace> ,\n \n     def_map: DefMap,\n     export_map2: ExportMap2,\n@@ -1452,7 +1453,7 @@ impl Resolver {\n                     // globs and lists, the path is found directly in the AST;\n                     // for simple paths we have to munge the path a little.\n \n-                    let mut module_path = ~[];\n+                    let mut module_path = Vec::new();\n                     match view_path.node {\n                         ViewPathSimple(_, ref full_path, _) => {\n                             let path_len = full_path.segments.len();\n@@ -1951,7 +1952,7 @@ impl Resolver {\n     /// Creates and adds an import directive to the given module.\n     fn build_import_directive(&mut self,\n                               module_: @Module,\n-                              module_path: ~[Ident],\n+                              module_path: Vec<Ident> ,\n                               subclass: @ImportDirectiveSubclass,\n                               span: Span,\n                               id: NodeId,\n@@ -1972,7 +1973,7 @@ impl Resolver {\n             SingleImport(target, _) => {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n-                       self.idents_to_str(directive.module_path),\n+                       self.idents_to_str(directive.module_path.as_slice()),\n                        token::get_ident(target));\n \n                 let mut import_resolutions = module_.import_resolutions\n@@ -2085,13 +2086,14 @@ impl Resolver {\n         let import_count = imports.get().len();\n         while module.resolved_import_count.get() < import_count {\n             let import_index = module.resolved_import_count.get();\n-            let import_directive = imports.get()[import_index];\n+            let import_directive = *imports.get().get(import_index);\n             match self.resolve_import_for_module(module, import_directive) {\n                 Failed => {\n                     // We presumably emitted an error. Continue.\n                     let msg = format!(\"failed to resolve import `{}`\",\n                                    self.import_path_to_str(\n-                                       import_directive.module_path,\n+                                       import_directive.module_path\n+                                                       .as_slice(),\n                                        *import_directive.subclass));\n                     self.resolve_error(import_directive.span, msg);\n                 }\n@@ -2124,11 +2126,11 @@ impl Resolver {\n     }\n \n     fn path_idents_to_str(&mut self, path: &Path) -> ~str {\n-        let identifiers: ~[ast::Ident] = path.segments\n+        let identifiers: Vec<ast::Ident> = path.segments\n                                              .iter()\n                                              .map(|seg| seg.identifier)\n                                              .collect();\n-        self.idents_to_str(identifiers)\n+        self.idents_to_str(identifiers.as_slice())\n     }\n \n     fn import_directive_subclass_to_str(&mut self,\n@@ -2169,7 +2171,7 @@ impl Resolver {\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in \\\n                 `{}`\",\n-               self.idents_to_str(*module_path),\n+               self.idents_to_str(module_path.as_slice()),\n                self.module_to_str(module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -2178,7 +2180,7 @@ impl Resolver {\n             Some((self.graph_root.get_module(), LastMod(AllPublic)))\n         } else {\n             match self.resolve_module_path(module_,\n-                                           *module_path,\n+                                           module_path.as_slice(),\n                                            DontUseLexicalScope,\n                                            import_directive.span,\n                                            ImportSearch) {\n@@ -3274,15 +3276,15 @@ impl Resolver {\n         if index != import_count {\n             let sn = self.session\n                          .codemap\n-                         .span_to_snippet(imports.get()[index].span)\n+                         .span_to_snippet(imports.get().get(index).span)\n                          .unwrap();\n             if sn.contains(\"::\") {\n-                self.resolve_error(imports.get()[index].span,\n+                self.resolve_error(imports.get().get(index).span,\n                                    \"unresolved import\");\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                sn.slice(0, sn.len()));\n-                self.resolve_error(imports.get()[index].span, err);\n+                self.resolve_error(imports.get().get(index).span, err);\n             }\n         }\n \n@@ -3374,7 +3376,7 @@ impl Resolver {\n     }\n \n     fn record_exports_for_module(&mut self, module_: @Module) {\n-        let mut exports2 = ~[];\n+        let mut exports2 = Vec::new();\n \n         self.add_exports_for_module(&mut exports2, module_);\n         match module_.def_id.get() {\n@@ -3389,7 +3391,7 @@ impl Resolver {\n     }\n \n     fn add_exports_of_namebindings(&mut self,\n-                                   exports2: &mut ~[Export2],\n+                                   exports2: &mut Vec<Export2> ,\n                                    name: Name,\n                                    namebindings: @NameBindings,\n                                    ns: Namespace) {\n@@ -3410,7 +3412,7 @@ impl Resolver {\n     }\n \n     fn add_exports_for_module(&mut self,\n-                              exports2: &mut ~[Export2],\n+                              exports2: &mut Vec<Export2> ,\n                               module_: @Module) {\n         let import_resolutions = module_.import_resolutions.borrow();\n         for (name, importresolution) in import_resolutions.get().iter() {\n@@ -3495,7 +3497,7 @@ impl Resolver {\n     /// Wraps the given definition in the appropriate number of `def_upvar`\n     /// wrappers.\n     fn upvarify(&mut self,\n-                    ribs: &mut ~[@Rib],\n+                    ribs: &mut Vec<@Rib> ,\n                     rib_index: uint,\n                     def_like: DefLike,\n                     span: Span)\n@@ -3520,7 +3522,7 @@ impl Resolver {\n \n         let mut rib_index = rib_index + 1;\n         while rib_index < ribs.len() {\n-            match ribs[rib_index].kind {\n+            match ribs.get(rib_index).kind {\n                 NormalRibKind => {\n                     // Nothing to do. Continue.\n                 }\n@@ -3610,7 +3612,7 @@ impl Resolver {\n     }\n \n     fn search_ribs(&mut self,\n-                       ribs: &mut ~[@Rib],\n+                       ribs: &mut Vec<@Rib> ,\n                        name: Name,\n                        span: Span)\n                        -> Option<DefLike> {\n@@ -3621,7 +3623,7 @@ impl Resolver {\n         while i != 0 {\n             i -= 1;\n             let binding_opt = {\n-                let bindings = ribs[i].bindings.borrow();\n+                let bindings = ribs.get(i).bindings.borrow();\n                 bindings.get().find_copy(&name)\n             };\n             match binding_opt {\n@@ -4095,7 +4097,7 @@ impl Resolver {\n                         TraitImplementation);\n \n                     // Record the current set of trait references.\n-                    let mut new_trait_refs = ~[];\n+                    let mut new_trait_refs = Vec::new();\n                     {\n                         let def_map = this.def_map.borrow();\n                         let r = def_map.get().find(&trait_reference.ref_id);\n@@ -4492,8 +4494,9 @@ impl Resolver {\n                                     {\n                                         let mut value_ribs =\n                                             this.value_ribs.borrow_mut();\n-                                        let last_rib = value_ribs.get()[\n-                                            value_ribs.get().len() - 1];\n+                                        let length = value_ribs.get().len();\n+                                        let last_rib = value_ribs.get().get(\n+                                            length - 1);\n                                         let mut bindings =\n                                             last_rib.bindings.borrow_mut();\n                                         bindings.get().insert(renamed,\n@@ -4518,8 +4521,9 @@ impl Resolver {\n                                     {\n                                         let mut value_ribs =\n                                             this.value_ribs.borrow_mut();\n-                                        let last_rib = value_ribs.get()[\n-                                                value_ribs.get().len() - 1];\n+                                        let length = value_ribs.get().len();\n+                                        let last_rib = value_ribs.get().get(\n+                                                length - 1);\n                                         let mut bindings =\n                                             last_rib.bindings.borrow_mut();\n                                         bindings.get().insert(renamed,\n@@ -5054,8 +5058,8 @@ impl Resolver {\n                                 -> Option<~str> {\n         let this = &mut *self;\n \n-        let mut maybes: ~[token::InternedString] = ~[];\n-        let mut values: ~[uint] = ~[];\n+        let mut maybes: Vec<token::InternedString> = Vec::new();\n+        let mut values: Vec<uint> = Vec::new();\n \n         let mut j = {\n             let value_ribs = this.value_ribs.borrow();\n@@ -5064,7 +5068,7 @@ impl Resolver {\n         while j != 0 {\n             j -= 1;\n             let value_ribs = this.value_ribs.borrow();\n-            let bindings = value_ribs.get()[j].bindings.borrow();\n+            let bindings = value_ribs.get().get(j).bindings.borrow();\n             for (&k, _) in bindings.get().iter() {\n                 maybes.push(token::get_name(k));\n                 values.push(uint::MAX);\n@@ -5073,20 +5077,20 @@ impl Resolver {\n \n         let mut smallest = 0;\n         for (i, other) in maybes.iter().enumerate() {\n-            values[i] = name.lev_distance(other.get());\n+            *values.get_mut(i) = name.lev_distance(other.get());\n \n-            if values[i] <= values[smallest] {\n+            if *values.get(i) <= *values.get(smallest) {\n                 smallest = i;\n             }\n         }\n \n         if values.len() > 0 &&\n-            values[smallest] != uint::MAX &&\n-            values[smallest] < name.len() + 2 &&\n-            values[smallest] <= max_distance &&\n-            name != maybes[smallest].get() {\n+            *values.get(smallest) != uint::MAX &&\n+            *values.get(smallest) < name.len() + 2 &&\n+            *values.get(smallest) <= max_distance &&\n+            name != maybes.get(smallest).get() {\n \n-            Some(maybes[smallest].get().to_str())\n+            Some(maybes.get(smallest).get().to_str())\n \n         } else {\n             None\n@@ -5212,8 +5216,8 @@ impl Resolver {\n                     let def_like = DlDef(DefLabel(expr.id));\n                     {\n                         let mut label_ribs = this.label_ribs.borrow_mut();\n-                        let rib = label_ribs.get()[label_ribs.get().len() -\n-                                                   1];\n+                        let length = label_ribs.get().len();\n+                        let rib = label_ribs.get().get(length - 1);\n                         let mut bindings = rib.bindings.borrow_mut();\n                         let renamed = mtwt::resolve(label);\n                         bindings.get().insert(renamed, def_like);\n@@ -5274,11 +5278,11 @@ impl Resolver {\n         }\n     }\n \n-    fn search_for_traits_containing_method(&mut self, name: Ident) -> ~[DefId] {\n+    fn search_for_traits_containing_method(&mut self, name: Ident) -> Vec<DefId> {\n         debug!(\"(searching for traits containing method) looking for '{}'\",\n                token::get_ident(name));\n \n-        let mut found_traits = ~[];\n+        let mut found_traits = Vec::new();\n         let mut search_module = self.current_module;\n         let method_map = self.method_map.borrow();\n         match method_map.get().find(&name.name) {\n@@ -5350,7 +5354,7 @@ impl Resolver {\n     }\n \n     fn add_trait_info(&self,\n-                          found_traits: &mut ~[DefId],\n+                          found_traits: &mut Vec<DefId> ,\n                           trait_def_id: DefId,\n                           name: Ident) {\n         debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n@@ -5495,7 +5499,7 @@ impl Resolver {\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n     fn module_to_str(&mut self, module_: @Module) -> ~str {\n-        let mut idents = ~[];\n+        let mut idents = Vec::new();\n         let mut current_module = module_;\n         loop {\n             match current_module.parent_link {\n@@ -5516,7 +5520,9 @@ impl Resolver {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-        return self.idents_to_str(idents.move_rev_iter().collect::<~[ast::Ident]>());\n+        return self.idents_to_str(idents.move_rev_iter()\n+                                        .collect::<Vec<ast::Ident>>()\n+                                        .as_slice());\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "6c48440421f6f8c60f8862ccf09e71711c36a1d8", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -16,6 +16,7 @@ use middle::ty_fold::TypeFolder;\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n+use std::vec_ng::Vec;\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n \n@@ -88,7 +89,7 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n         match ty::get(t).sty {\n             ty::ty_param(p) => {\n                 if p.idx < self.substs.tps.len() {\n-                    self.substs.tps[p.idx]\n+                    *self.substs.tps.get(p.idx)\n                 } else {\n                     let root_msg = match self.root_ty {\n                         Some(root) => format!(\" in the substitution of `{}`\",\n@@ -130,10 +131,10 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n ///////////////////////////////////////////////////////////////////////////\n // Other types\n \n-impl<T:Subst> Subst for ~[T] {\n+impl<T:Subst> Subst for Vec<T> {\n     fn subst_spanned(&self, tcx: ty::ctxt,\n                      substs: &ty::substs,\n-                     span: Option<Span>) -> ~[T] {\n+                     span: Option<Span>) -> Vec<T> {\n         self.map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }"}, {"sha": "4f190c5d697aae9146c11e1d27ac8f49454d92b7", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 141, "deletions": 101, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -223,9 +223,10 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, vec_map_to_str};\n \n-use std::cell::Cell;\n use collections::HashMap;\n-use std::vec;\n+use std::cell::Cell;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::ast_util::path_to_ident;\n@@ -421,10 +422,9 @@ impl<'a,'b> Clone for ArmData<'a, 'b> {\n  */\n #[deriving(Clone)]\n struct Match<'a,'b> {\n-    pats: ~[@ast::Pat],\n+    pats: Vec<@ast::Pat> ,\n     data: ArmData<'a,'b>,\n-    bound_ptrs: ~[(Ident, ValueRef)]\n-}\n+    bound_ptrs: Vec<(Ident, ValueRef)> }\n \n impl<'a,'b> Repr for Match<'a,'b> {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n@@ -439,9 +439,9 @@ impl<'a,'b> Repr for Match<'a,'b> {\n \n fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     for br in m.iter() {\n-        match br.pats[col].node {\n-          ast::PatIdent(_, _, Some(_)) => return true,\n-          _ => ()\n+        match br.pats.get(col).node {\n+            ast::PatIdent(_, _, Some(_)) => return true,\n+            _ => ()\n         }\n     }\n     return false;\n@@ -452,22 +452,22 @@ fn expand_nested_bindings<'r,'b>(\n                           m: &[Match<'r,'b>],\n                           col: uint,\n                           val: ValueRef)\n-                          -> ~[Match<'r,'b>] {\n+                          -> Vec<Match<'r,'b>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    m.map(|br| {\n-        match br.pats[col].node {\n+    m.iter().map(|br| {\n+        match br.pats.get(col).node {\n             ast::PatIdent(_, ref path, Some(inner)) => {\n-                let pats = vec::append(\n-                    br.pats.slice(0u, col).to_owned(),\n-                    vec::append(~[inner],\n+                let pats = vec_ng::append(\n+                    Vec::from_slice(br.pats.slice(0u, col)),\n+                    vec_ng::append(vec!(inner),\n                                 br.pats.slice(col + 1u,\n-                                           br.pats.len())));\n+                                           br.pats.len())).as_slice());\n \n                 let mut res = Match {\n                     pats: pats,\n@@ -479,7 +479,7 @@ fn expand_nested_bindings<'r,'b>(\n             }\n             _ => (*br).clone(),\n         }\n-    })\n+    }).collect()\n }\n \n fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n@@ -491,7 +491,7 @@ fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n     }\n }\n \n-type enter_pat<'a> = 'a |@ast::Pat| -> Option<~[@ast::Pat]>;\n+type enter_pat<'a> = 'a |@ast::Pat| -> Option<Vec<@ast::Pat> >;\n \n fn enter_match<'r,'b>(\n                bcx: &'b Block<'b>,\n@@ -500,24 +500,24 @@ fn enter_match<'r,'b>(\n                col: uint,\n                val: ValueRef,\n                e: enter_pat)\n-               -> ~[Match<'r,'b>] {\n+               -> Vec<Match<'r,'b>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let mut result = ~[];\n+    let mut result = Vec::new();\n     for br in m.iter() {\n-        match e(br.pats[col]) {\n+        match e(*br.pats.get(col)) {\n             Some(sub) => {\n                 let pats =\n-                    vec::append(\n-                        vec::append(sub, br.pats.slice(0u, col)),\n+                    vec_ng::append(\n+                        vec_ng::append(sub, br.pats.slice(0u, col)),\n                         br.pats.slice(col + 1u, br.pats.len()));\n \n-                let this = br.pats[col];\n+                let this = *br.pats.get(col);\n                 let mut bound_ptrs = br.bound_ptrs.clone();\n                 match this.node {\n                     ast::PatIdent(_, ref path, None) => {\n@@ -550,7 +550,7 @@ fn enter_default<'r,'b>(\n                  col: uint,\n                  val: ValueRef,\n                  chk: &FailureHandler)\n-                 -> ~[Match<'r,'b>] {\n+                 -> Vec<Match<'r,'b>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -561,8 +561,8 @@ fn enter_default<'r,'b>(\n     // Collect all of the matches that can match against anything.\n     let matches = enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n-          ast::PatWild | ast::PatWildMulti | ast::PatTup(_) => Some(~[]),\n-          ast::PatIdent(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n+          ast::PatWild | ast::PatWildMulti | ast::PatTup(_) => Some(Vec::new()),\n+          ast::PatIdent(_, _, None) if pat_is_binding(dm, p) => Some(Vec::new()),\n           _ => None\n         }\n     });\n@@ -587,7 +587,7 @@ fn enter_default<'r,'b>(\n         _ => false\n     };\n \n-    if is_exhaustive { ~[] } else { matches }\n+    if is_exhaustive { Vec::new() } else { matches }\n }\n \n // <pcwalton> nmatsakis: what does enter_opt do?\n@@ -621,7 +621,7 @@ fn enter_opt<'r,'b>(\n              col: uint,\n              variant_size: uint,\n              val: ValueRef)\n-             -> ~[Match<'r,'b>] {\n+             -> Vec<Match<'r,'b>> {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -643,7 +643,7 @@ fn enter_opt<'r,'b>(\n                 };\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n-                    Some(~[])\n+                    Some(Vec::new())\n                 } else {\n                     None\n                 }\n@@ -652,7 +652,7 @@ fn enter_opt<'r,'b>(\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // FIXME: Must we clone?\n                     match *subpats {\n-                        None => Some(vec::from_elem(variant_size, dummy)),\n+                        None => Some(Vec::from_elem(variant_size, dummy)),\n                         Some(ref subpats) => {\n                             Some((*subpats).iter().map(|x| *x).collect())\n                         }\n@@ -664,16 +664,16 @@ fn enter_opt<'r,'b>(\n             ast::PatIdent(_, _, None)\n                     if pat_is_variant_or_struct(tcx.def_map, p) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n-                    Some(~[])\n+                    Some(Vec::new())\n                 } else {\n                     None\n                 }\n             }\n             ast::PatLit(l) => {\n-                if opt_eq(tcx, &lit(ExprLit(l)), opt) {Some(~[])} else {None}\n+                if opt_eq(tcx, &lit(ExprLit(l)), opt) {Some(Vec::new())} else {None}\n             }\n             ast::PatRange(l1, l2) => {\n-                if opt_eq(tcx, &range(l1, l2), opt) {Some(~[])} else {None}\n+                if opt_eq(tcx, &range(l1, l2), opt) {Some(Vec::new())} else {None}\n             }\n             ast::PatStruct(_, ref field_pats, _) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n@@ -695,7 +695,7 @@ fn enter_opt<'r,'b>(\n                     // Reorder the patterns into the same order they were\n                     // specified in the struct definition. Also fill in\n                     // unspecified fields with dummy.\n-                    let mut reordered_patterns = ~[];\n+                    let mut reordered_patterns = Vec::new();\n                     let r = ty::lookup_struct_fields(tcx, struct_id);\n                     for field in r.iter() {\n                             match field_pats.iter().find(|p| p.ident.name\n@@ -722,7 +722,7 @@ fn enter_opt<'r,'b>(\n                         let this_opt = vec_len(n, vec_len_ge(before.len()),\n                                                (lo, hi));\n                         if opt_eq(tcx, &this_opt, opt) {\n-                            let mut new_before = ~[];\n+                            let mut new_before = Vec::new();\n                             for pat in before.iter() {\n                                 new_before.push(*pat);\n                             }\n@@ -738,7 +738,7 @@ fn enter_opt<'r,'b>(\n                     None if i >= lo && i <= hi => {\n                         let n = before.len();\n                         if opt_eq(tcx, &vec_len(n, vec_len_eq, (lo,hi)), opt) {\n-                            let mut new_before = ~[];\n+                            let mut new_before = Vec::new();\n                             for pat in before.iter() {\n                                 new_before.push(*pat);\n                             }\n@@ -762,7 +762,7 @@ fn enter_opt<'r,'b>(\n                 // cause the default match to fire spuriously.\n                 match *opt {\n                     vec_len(..) => None,\n-                    _ => Some(vec::from_elem(variant_size, dummy))\n+                    _ => Some(Vec::from_elem(variant_size, dummy))\n                 }\n             }\n         };\n@@ -778,7 +778,7 @@ fn enter_rec_or_struct<'r,'b>(\n                        col: uint,\n                        fields: &[ast::Ident],\n                        val: ValueRef)\n-                       -> ~[Match<'r,'b>] {\n+                       -> Vec<Match<'r,'b>> {\n     debug!(\"enter_rec_or_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -790,7 +790,7 @@ fn enter_rec_or_struct<'r,'b>(\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatStruct(_, ref fpats, _) => {\n-                let mut pats = ~[];\n+                let mut pats = Vec::new();\n                 for fname in fields.iter() {\n                     match fpats.iter().find(|p| p.ident.name == fname.name) {\n                         None => pats.push(dummy),\n@@ -801,7 +801,7 @@ fn enter_rec_or_struct<'r,'b>(\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(vec::from_elem(fields.len(), dummy))\n+                Some(Vec::from_elem(fields.len(), dummy))\n             }\n         }\n     })\n@@ -814,7 +814,7 @@ fn enter_tup<'r,'b>(\n              col: uint,\n              val: ValueRef,\n              n_elts: uint)\n-             -> ~[Match<'r,'b>] {\n+             -> Vec<Match<'r,'b>> {\n     debug!(\"enter_tup(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -826,15 +826,15 @@ fn enter_tup<'r,'b>(\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatTup(ref elts) => {\n-                let mut new_elts = ~[];\n+                let mut new_elts = Vec::new();\n                 for elt in elts.iter() {\n                     new_elts.push((*elt).clone())\n                 }\n                 Some(new_elts)\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(vec::from_elem(n_elts, dummy))\n+                Some(Vec::from_elem(n_elts, dummy))\n             }\n         }\n     })\n@@ -847,7 +847,7 @@ fn enter_tuple_struct<'r,'b>(\n                       col: uint,\n                       val: ValueRef,\n                       n_elts: uint)\n-                      -> ~[Match<'r,'b>] {\n+                      -> Vec<Match<'r,'b>> {\n     debug!(\"enter_tuple_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -863,7 +863,7 @@ fn enter_tuple_struct<'r,'b>(\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(vec::from_elem(n_elts, dummy))\n+                Some(Vec::from_elem(n_elts, dummy))\n             }\n         }\n     })\n@@ -875,7 +875,7 @@ fn enter_uniq<'r,'b>(\n               m: &[Match<'r,'b>],\n               col: uint,\n               val: ValueRef)\n-              -> ~[Match<'r,'b>] {\n+              -> Vec<Match<'r,'b>> {\n     debug!(\"enter_uniq(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -887,11 +887,11 @@ fn enter_uniq<'r,'b>(\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatUniq(sub) => {\n-                Some(~[sub])\n+                Some(vec!(sub))\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(~[dummy])\n+                Some(vec!(dummy))\n             }\n         }\n     })\n@@ -904,7 +904,7 @@ fn enter_region<'r,\n                 m: &[Match<'r,'b>],\n                 col: uint,\n                 val: ValueRef)\n-                -> ~[Match<'r,'b>] {\n+                -> Vec<Match<'r,'b>> {\n     debug!(\"enter_region(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -916,11 +916,11 @@ fn enter_region<'r,\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatRegion(sub) => {\n-                Some(~[sub])\n+                Some(vec!(sub))\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(~[dummy])\n+                Some(vec!(dummy))\n             }\n         }\n     })\n@@ -929,32 +929,35 @@ fn enter_region<'r,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-fn get_options(bcx: &Block, m: &[Match], col: uint) -> ~[Opt] {\n+fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n     let ccx = bcx.ccx();\n-    fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n+    fn add_to_set(tcx: ty::ctxt, set: &mut Vec<Opt> , val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n     // Vector comparisions are special in that since the actual\n     // conditions over-match, we need to be careful about them. This\n     // means that in order to properly handle things in order, we need\n     // to not always merge conditions.\n-    fn add_veclen_to_set(set: &mut ~[Opt], i: uint,\n+    fn add_veclen_to_set(set: &mut Vec<Opt> , i: uint,\n                          len: uint, vlo: VecLenOpt) {\n         match set.last() {\n             // If the last condition in the list matches the one we want\n             // to add, then extend its range. Otherwise, make a new\n             // vec_len with a range just covering the new entry.\n             Some(&vec_len(len2, vlo2, (start, end)))\n-                 if len == len2 && vlo == vlo2 =>\n-                 set[set.len() - 1] = vec_len(len, vlo, (start, end+1)),\n+                 if len == len2 && vlo == vlo2 => {\n+                let length = set.len();\n+                 *set.get_mut(length - 1) =\n+                     vec_len(len, vlo, (start, end+1))\n+            }\n             _ => set.push(vec_len(len, vlo, (i, i)))\n         }\n     }\n \n-    let mut found = ~[];\n+    let mut found = Vec::new();\n     for (i, br) in m.iter().enumerate() {\n-        let cur = br.pats[col];\n+        let cur = *br.pats.get(col);\n         match cur.node {\n             ast::PatLit(l) => {\n                 add_to_set(ccx.tcx, &mut found, lit(ExprLit(l)));\n@@ -1020,7 +1023,7 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> ~[Opt] {\n }\n \n struct ExtractedBlock<'a> {\n-    vals: ~[ValueRef],\n+    vals: Vec<ValueRef> ,\n     bcx: &'a Block<'a>,\n }\n \n@@ -1031,7 +1034,7 @@ fn extract_variant_args<'a>(\n                         val: ValueRef)\n                         -> ExtractedBlock<'a> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n-    let args = vec::from_fn(adt::num_args(repr, disr_val), |i| {\n+    let args = Vec::from_fn(adt::num_args(repr, disr_val), |i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n     });\n \n@@ -1066,7 +1069,7 @@ fn extract_vec_elems<'a>(\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n \n-    let mut elems = vec::from_fn(elem_count, |i| {\n+    let mut elems = Vec::from_fn(elem_count, |i| {\n         match slice {\n             None => GEPi(bcx, base, [i]),\n             Some(n) if i < n => GEPi(bcx, base, [i]),\n@@ -1092,7 +1095,7 @@ fn extract_vec_elems<'a>(\n         Store(bcx, slice_begin,\n               GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n         Store(bcx, slice_len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n-        elems[n] = scratch.val;\n+        *elems.get_mut(n) = scratch.val;\n     }\n \n     ExtractedBlock { vals: elems, bcx: bcx }\n@@ -1108,13 +1111,13 @@ fn collect_record_or_struct_fields<'a>(\n                                    bcx: &'a Block<'a>,\n                                    m: &[Match],\n                                    col: uint)\n-                                   -> Option<~[ast::Ident]> {\n-    let mut fields: ~[ast::Ident] = ~[];\n+                                   -> Option<Vec<ast::Ident> > {\n+    let mut fields: Vec<ast::Ident> = Vec::new();\n     let mut found = false;\n     for br in m.iter() {\n-        match br.pats[col].node {\n+        match br.pats.get(col).node {\n           ast::PatStruct(_, ref fs, _) => {\n-            match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n+            match ty::get(node_id_type(bcx, br.pats.get(col).id)).sty {\n               ty::ty_struct(..) => {\n                    extend(&mut fields, fs.as_slice());\n                    found = true;\n@@ -1131,7 +1134,7 @@ fn collect_record_or_struct_fields<'a>(\n         return None;\n     }\n \n-    fn extend(idents: &mut ~[ast::Ident], field_pats: &[ast::FieldPat]) {\n+    fn extend(idents: &mut Vec<ast::Ident> , field_pats: &[ast::FieldPat]) {\n         for field_pat in field_pats.iter() {\n             let field_ident = field_pat.ident;\n             if !idents.iter().any(|x| x.name == field_ident.name) {\n@@ -1143,7 +1146,7 @@ fn collect_record_or_struct_fields<'a>(\n \n fn pats_require_rooting(bcx: &Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n-        let pat_id = br.pats[col].id;\n+        let pat_id = br.pats.get(col).id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n         let root_map = bcx.ccx().maps.root_map.borrow();\n         root_map.get().contains_key(&key)\n@@ -1157,7 +1160,7 @@ fn pats_require_rooting(bcx: &Block, m: &[Match], col: uint) -> bool {\n macro_rules! any_pat (\n     ($m:expr, $pattern:pat) => (\n         ($m).iter().any(|br| {\n-            match br.pats[col].node {\n+            match br.pats.get(col).node {\n                 $pattern => true,\n                 _ => false\n             }\n@@ -1179,7 +1182,7 @@ fn any_tup_pat(m: &[Match], col: uint) -> bool {\n \n fn any_tuple_struct_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n-        let pat = br.pats[col];\n+        let pat = *br.pats.get(col);\n         match pat.node {\n             ast::PatEnum(_, Some(_)) => {\n                 let def_map = bcx.tcx().def_map.borrow();\n@@ -1256,10 +1259,10 @@ fn pick_col(m: &[Match]) -> uint {\n           _ => 0u\n         }\n     }\n-    let mut scores = vec::from_elem(m[0].pats.len(), 0u);\n+    let mut scores = Vec::from_elem(m[0].pats.len(), 0u);\n     for br in m.iter() {\n         for (i, p) in br.pats.iter().enumerate() {\n-            scores[i] += score(*p);\n+            *scores.get_mut(i) += score(*p);\n         }\n     }\n     let mut max_score = 0u;\n@@ -1512,7 +1515,12 @@ fn compile_submatch<'r,\n \n     if has_nested_bindings(m, col) {\n         let expanded = expand_nested_bindings(bcx, m, col, val);\n-        compile_submatch_continue(bcx, expanded, vals, chk, col, val)\n+        compile_submatch_continue(bcx,\n+                                  expanded.as_slice(),\n+                                  vals,\n+                                  chk,\n+                                  col,\n+                                  val)\n     } else {\n         compile_submatch_continue(bcx, m, vals, chk, col, val)\n     }\n@@ -1530,15 +1538,15 @@ fn compile_submatch_continue<'r,\n     let tcx = bcx.tcx();\n     let dm = tcx.def_map;\n \n-    let vals_left = vec::append(vals.slice(0u, col).to_owned(),\n-                                vals.slice(col + 1u, vals.len()));\n+    let vals_left = vec_ng::append(Vec::from_slice(vals.slice(0u, col)),\n+                                   vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n     for br in m.iter() {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 {\n-            pat_id = br.pats[col].id;\n+            pat_id = br.pats.get(col).id;\n         }\n     }\n \n@@ -1557,8 +1565,14 @@ fn compile_submatch_continue<'r,\n                         });\n                 compile_submatch(\n                         bcx,\n-                        enter_rec_or_struct(bcx, dm, m, col, *rec_fields, val),\n-                        vec::append(rec_vals, vals_left),\n+                        enter_rec_or_struct(bcx,\n+                                            dm,\n+                                            m,\n+                                            col,\n+                                            rec_fields.as_slice(),\n+                                            val).as_slice(),\n+                        vec_ng::append(rec_vals,\n+                                       vals_left.as_slice()).as_slice(),\n                         chk);\n             });\n             return;\n@@ -1573,11 +1587,19 @@ fn compile_submatch_continue<'r,\n           ty::ty_tup(ref elts) => elts.len(),\n           _ => ccx.sess.bug(\"non-tuple type in tuple pattern\")\n         };\n-        let tup_vals = vec::from_fn(n_tup_elts, |i| {\n+        let tup_vals = Vec::from_fn(n_tup_elts, |i| {\n             adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n         });\n-        compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n-                         vec::append(tup_vals, vals_left), chk);\n+        compile_submatch(bcx,\n+                         enter_tup(bcx,\n+                                   dm,\n+                                   m,\n+                                   col,\n+                                   val,\n+                                   n_tup_elts).as_slice(),\n+                         vec_ng::append(tup_vals,\n+                                        vals_left.as_slice()).as_slice(),\n+                         chk);\n         return;\n     }\n \n@@ -1595,28 +1617,35 @@ fn compile_submatch_continue<'r,\n         }\n \n         let struct_repr = adt::represent_type(bcx.ccx(), struct_ty);\n-        let llstructvals = vec::from_fn(struct_element_count, |i| {\n+        let llstructvals = Vec::from_fn(struct_element_count, |i| {\n             adt::trans_field_ptr(bcx, struct_repr, val, 0, i)\n         });\n         compile_submatch(bcx,\n                          enter_tuple_struct(bcx, dm, m, col, val,\n-                                            struct_element_count),\n-                         vec::append(llstructvals, vals_left),\n+                                            struct_element_count).as_slice(),\n+                         vec_ng::append(llstructvals,\n+                                        vals_left.as_slice()).as_slice(),\n                          chk);\n         return;\n     }\n \n     if any_uniq_pat(m, col) {\n         let llbox = Load(bcx, val);\n-        compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n-                         vec::append(~[llbox], vals_left), chk);\n+        compile_submatch(bcx,\n+                         enter_uniq(bcx, dm, m, col, val).as_slice(),\n+                         vec_ng::append(vec!(llbox),\n+                                        vals_left.as_slice()).as_slice(),\n+                         chk);\n         return;\n     }\n \n     if any_region_pat(m, col) {\n         let loaded_val = Load(bcx, val);\n-        compile_submatch(bcx, enter_region(bcx, dm, m, col, val),\n-                         vec::append(~[loaded_val], vals_left), chk);\n+        compile_submatch(bcx,\n+                         enter_region(bcx, dm, m, col, val).as_slice(),\n+                         vec_ng::append(vec!(loaded_val),\n+                                        vals_left.as_slice()).as_slice(),\n+                         chk);\n         return;\n     }\n \n@@ -1627,7 +1656,7 @@ fn compile_submatch_continue<'r,\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_str(test_val));\n     if opts.len() > 0u {\n-        match opts[0] {\n+        match *opts.get(0) {\n             var(_, repr) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, repr, val);\n                 kind = the_kind;\n@@ -1773,7 +1802,7 @@ fn compile_submatch_continue<'r,\n         }\n \n         let mut size = 0u;\n-        let mut unpacked = ~[];\n+        let mut unpacked = Vec::new();\n         match *opt {\n             var(disr_val, repr) => {\n                 let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n@@ -1796,12 +1825,20 @@ fn compile_submatch_continue<'r,\n             lit(_) | range(_, _) => ()\n         }\n         let opt_ms = enter_opt(opt_cx, m, opt, col, size, val);\n-        let opt_vals = vec::append(unpacked, vals_left);\n+        let opt_vals = vec_ng::append(unpacked, vals_left.as_slice());\n \n         match branch_chk {\n-            None => compile_submatch(opt_cx, opt_ms, opt_vals, chk),\n+            None => {\n+                compile_submatch(opt_cx,\n+                                 opt_ms.as_slice(),\n+                                 opt_vals.as_slice(),\n+                                 chk)\n+            }\n             Some(branch_chk) => {\n-                compile_submatch(opt_cx, opt_ms, opt_vals, &branch_chk)\n+                compile_submatch(opt_cx,\n+                                 opt_ms.as_slice(),\n+                                 opt_vals.as_slice(),\n+                                 &branch_chk)\n             }\n         }\n     }\n@@ -1812,7 +1849,10 @@ fn compile_submatch_continue<'r,\n             Br(bcx, else_cx.llbb);\n         }\n         if kind != single {\n-            compile_submatch(else_cx, defaults, vals_left, chk);\n+            compile_submatch(else_cx,\n+                             defaults.as_slice(),\n+                             vals_left.as_slice(),\n+                             chk);\n         }\n     }\n }\n@@ -1884,8 +1924,8 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         return bcx;\n     }\n \n-    let mut arm_datas = ~[];\n-    let mut matches = ~[];\n+    let mut arm_datas = Vec::new();\n+    let mut matches = Vec::new();\n     for arm in arms.iter() {\n         let body = fcx.new_id_block(\"case_body\", arm.body.id);\n         let bindings_map = create_bindings_map(bcx, *arm.pats.get(0));\n@@ -1897,9 +1937,9 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         arm_datas.push(arm_data.clone());\n         for p in arm.pats.iter() {\n             matches.push(Match {\n-                pats: ~[*p],\n+                pats: vec!(*p),\n                 data: arm_data.clone(),\n-                bound_ptrs: ~[],\n+                bound_ptrs: Vec::new(),\n             });\n         }\n     }\n@@ -1922,9 +1962,9 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         }\n     };\n     let lldiscr = discr_datum.val;\n-    compile_submatch(bcx, matches, [lldiscr], &chk);\n+    compile_submatch(bcx, matches.as_slice(), [lldiscr], &chk);\n \n-    let mut arm_cxs = ~[];\n+    let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {\n         let mut bcx = arm_data.bodycx;\n \n@@ -1945,7 +1985,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs);\n+    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs.as_slice());\n     return bcx;\n }\n "}, {"sha": "00a93b66ce0175b59d46fb91548f4bed3200fb58", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 72, "deletions": 44, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -53,17 +53,18 @@ use middle::trans::_match;\n use middle::trans::build::*;\n use middle::trans::common::*;\n use middle::trans::machine;\n+use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n use middle::ty::Disr;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::IntType;\n use util::ppaux::ty_to_str;\n \n-use middle::trans::type_::Type;\n-\n type Hint = attr::ReprAttr;\n \n \n@@ -83,7 +84,7 @@ pub enum Repr {\n      * General-case enums: for each case there is a struct, and they\n      * all start with a field for the discriminant.\n      */\n-    General(IntType, ~[Struct]),\n+    General(IntType, Vec<Struct> ),\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n      * `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n@@ -96,16 +97,15 @@ pub enum Repr {\n      * identity function.\n      */\n     NullablePointer{ nonnull: Struct, nndiscr: Disr, ptrfield: uint,\n-                     nullfields: ~[ty::t] }\n+                     nullfields: Vec<ty::t> }\n }\n \n /// For structs, and struct-like parts of anything fancier.\n pub struct Struct {\n     size: u64,\n     align: u64,\n     packed: bool,\n-    fields: ~[ty::t]\n-}\n+    fields: Vec<ty::t> }\n \n /**\n  * Convenience for `represent_type`.  There should probably be more or\n@@ -137,7 +137,7 @@ pub fn represent_type(cx: &CrateContext, t: ty::t) -> @Repr {\n fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n     match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n-            return Univariant(mk_struct(cx, *elems, false), false)\n+            return Univariant(mk_struct(cx, elems.as_slice(), false), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n@@ -148,7 +148,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let dtor = ty::ty_dtor(cx.tcx, def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n \n-            return Univariant(mk_struct(cx, ftys, packed), dtor)\n+            return Univariant(mk_struct(cx, ftys.as_slice(), packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             let cases = get_cases(cx.tcx, def_id, substs);\n@@ -186,23 +186,29 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 // Equivalent to a struct/tuple/newtype.\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                return Univariant(mk_struct(cx, cases[0].tys, false), false)\n+                return Univariant(mk_struct(cx,\n+                                            cases.get(0).tys.as_slice(),\n+                                            false),\n+                                  false)\n             }\n \n             if cases.len() == 2 && hint == attr::ReprAny {\n                 // Nullable pointer optimization\n                 let mut discr = 0;\n                 while discr < 2 {\n-                    if cases[1 - discr].is_zerolen(cx) {\n-                        match cases[discr].find_ptr() {\n+                    if cases.get(1 - discr).is_zerolen(cx) {\n+                        match cases.get(discr).find_ptr() {\n                             Some(ptrfield) => {\n                                 return NullablePointer {\n-                                    nndiscr: discr,\n+                                    nndiscr: discr as u64,\n                                     nonnull: mk_struct(cx,\n-                                                       cases[discr].tys,\n+                                                       cases.get(discr)\n+                                                            .tys\n+                                                            .as_slice(),\n                                                        false),\n                                     ptrfield: ptrfield,\n-                                    nullfields: cases[1 - discr].tys.clone()\n+                                    nullfields: cases.get(1 - discr).tys\n+                                                                    .clone()\n                                 }\n                             }\n                             None => { }\n@@ -217,8 +223,12 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n                                      slo: 0, shi: (cases.len() - 1) as i64 };\n             let ity = range_to_inttype(cx, hint, &bounds);\n-            let discr = ~[ty_of_inttype(ity)];\n-            return General(ity, cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n+            return General(ity, cases.map(|c| {\n+                let discr = vec!(ty_of_inttype(ity));\n+                mk_struct(cx,\n+                          vec_ng::append(discr, c.tys.as_slice()).as_slice(),\n+                          false)\n+            }))\n         }\n         _ => cx.sess.bug(\"adt::represent_type called on non-ADT type\")\n     }\n@@ -254,17 +264,17 @@ pub fn is_ffi_safe(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n }\n \n // this should probably all be in ty\n-struct Case { discr: Disr, tys: ~[ty::t] }\n+struct Case { discr: Disr, tys: Vec<ty::t> }\n impl Case {\n     fn is_zerolen(&self, cx: &CrateContext) -> bool {\n-        mk_struct(cx, self.tys, false).size == 0\n+        mk_struct(cx, self.tys.as_slice(), false).size == 0\n     }\n     fn find_ptr(&self) -> Option<uint> {\n         self.tys.iter().position(|&ty| mono_data_classify(ty) == MonoNonNull)\n     }\n }\n \n-fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> ~[Case] {\n+fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> Vec<Case> {\n     ty::enum_variants(tcx, def_id).map(|vi| {\n         let arg_tys = vi.args.map(|&raw_ty| {\n             ty::subst(tcx, substs, raw_ty)\n@@ -281,7 +291,7 @@ fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n         align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n         packed: packed,\n-        fields: tys.to_owned(),\n+        fields: Vec::from_slice(tys),\n     }\n }\n \n@@ -394,7 +404,8 @@ pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n     match *r {\n         CEnum(..) | General(..) => { }\n         Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } =>\n-            llty.set_struct_body(struct_llfields(cx, st, false), st.packed)\n+            llty.set_struct_body(struct_llfields(cx, st, false).as_slice(),\n+                                 st.packed)\n     }\n }\n \n@@ -403,7 +414,10 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n         Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } => {\n             match name {\n-                None => Type::struct_(struct_llfields(cx, st, sizing), st.packed),\n+                None => {\n+                    Type::struct_(struct_llfields(cx, st, sizing).as_slice(),\n+                                  st.packed)\n+                }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(name) }\n             }\n         }\n@@ -438,22 +452,22 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n             };\n             assert_eq!(machine::llalign_of_min(cx, pad_ty) as u64, align);\n             assert_eq!(align % discr_size, 0);\n-            let fields = ~[discr_ty,\n+            let fields = vec!(discr_ty,\n                            Type::array(&discr_ty, align / discr_size - 1),\n-                           pad_ty];\n+                           pad_ty);\n             match name {\n-                None => Type::struct_(fields, false),\n+                None => Type::struct_(fields.as_slice(), false),\n                 Some(name) => {\n                     let mut llty = Type::named_struct(name);\n-                    llty.set_struct_body(fields, false);\n+                    llty.set_struct_body(fields.as_slice(), false);\n                     llty\n                 }\n             }\n         }\n     }\n }\n \n-fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> ~[Type] {\n+fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> Vec<Type> {\n     if sizing {\n         st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n     } else {\n@@ -518,7 +532,7 @@ fn nullable_bitdiscr(bcx: &Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uin\n                      scrutinee: ValueRef) -> ValueRef {\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n-    let llptrty = type_of::type_of(bcx.ccx(), nonnull.fields[ptrfield]);\n+    let llptrty = type_of::type_of(bcx.ccx(), *nonnull.fields.get(ptrfield));\n     ICmp(bcx, cmp, llptr, C_null(llptrty))\n }\n \n@@ -599,7 +613,8 @@ pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             if discr != nndiscr {\n                 let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n-                let llptrty = type_of::type_of(bcx.ccx(), nonnull.fields[ptrfield]);\n+                let llptrty = type_of::type_of(bcx.ccx(),\n+                                               *nonnull.fields.get(ptrfield));\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n         }\n@@ -624,7 +639,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n             assert_eq!(discr, 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n-        General(_, ref cases) => cases[discr].fields.len() - 1,\n+        General(_, ref cases) => cases.get(discr as uint).fields.len() - 1,\n         NullablePointer{ nonnull: ref nonnull, nndiscr,\n                          nullfields: ref nullfields, .. } => {\n             if discr == nndiscr { nonnull.fields.len() } else { nullfields.len() }\n@@ -639,11 +654,11 @@ pub fn deref_ty(ccx: &CrateContext, r: &Repr) -> ty::t {\n             ccx.sess.bug(\"deref of c-like enum\")\n         }\n         Univariant(ref st, _) => {\n-            st.fields[0]\n+            *st.fields.get(0)\n         }\n         General(_, ref cases) => {\n             assert!(cases.len() == 1);\n-            cases[0].fields[0]\n+            *cases.get(0).fields.get(0)\n         }\n         NullablePointer{ .. } => {\n             ccx.sess.bug(\"deref of nullable ptr\")\n@@ -666,7 +681,7 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(_, ref cases) => {\n-            struct_field_ptr(bcx, &cases[discr], val, ix + 1, true)\n+            struct_field_ptr(bcx, cases.get(discr as uint), val, ix + 1, true)\n         }\n         NullablePointer{ nonnull: ref nonnull, nullfields: ref nullfields,\n                          nndiscr, .. } => {\n@@ -675,7 +690,7 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n             } else {\n                 // The unit-like case might have a nonzero number of unit-like fields.\n                 // (e.g., Result or Either with () as one side.)\n-                let ty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n+                let ty = type_of::type_of(bcx.ccx(), *nullfields.get(ix));\n                 assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n                 // The contents of memory at this pointer can't matter, but use\n                 // the value that's \"reasonable\" in case of pointer comparison.\n@@ -691,7 +706,7 @@ fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef, ix: uint,\n \n     let val = if needs_cast {\n         let fields = st.fields.map(|&ty| type_of::type_of(ccx, ty));\n-        let real_ty = Type::struct_(fields, st.packed);\n+        let real_ty = Type::struct_(fields.as_slice(), st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -738,27 +753,40 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n             C_integral(ll_inttype(ccx, ity), discr as u64, true)\n         }\n         General(ity, ref cases) => {\n-            let case = &cases[discr];\n+            let case = cases.get(discr as uint);\n             let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n-            let contents = build_const_struct(ccx, case, ~[lldiscr] + vals);\n-            C_struct(contents + &[padding(max_sz - case.size)], false)\n+            let contents = build_const_struct(ccx,\n+                                              case,\n+                                              vec_ng::append(\n+                                                  vec!(lldiscr),\n+                                                  vals).as_slice());\n+            C_struct(vec_ng::append(\n+                        contents,\n+                        &[padding(max_sz - case.size)]).as_slice(),\n+                     false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(contents, st.packed)\n+            C_struct(contents.as_slice(), st.packed)\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, .. } => {\n             if discr == nndiscr {\n-                C_struct(build_const_struct(ccx, nonnull, vals), false)\n+                C_struct(build_const_struct(ccx,\n+                                            nonnull,\n+                                            vals.as_slice()).as_slice(),\n+                         false)\n             } else {\n                 let vals = nonnull.fields.map(|&ty| {\n                     // Always use null even if it's not the `ptrfield`th\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n-                });\n-                C_struct(build_const_struct(ccx, nonnull, vals), false)\n+                }).move_iter().collect::<Vec<ValueRef> >();\n+                C_struct(build_const_struct(ccx,\n+                                            nonnull,\n+                                            vals.as_slice()).as_slice(),\n+                         false)\n             }\n         }\n     }\n@@ -775,11 +803,11 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n  * will read the wrong memory.\n  */\n fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n-    -> ~[ValueRef] {\n+    -> Vec<ValueRef> {\n     assert_eq!(vals.len(), st.fields.len());\n \n     let mut offset = 0;\n-    let mut cfields = ~[];\n+    let mut cfields = Vec::new();\n     for (i, &ty) in st.fields.iter().enumerate() {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         let type_align = machine::llalign_of_min(ccx, llty)"}, {"sha": "adcef0278f8b474f199a21d39bdc8dca6f7a95e7", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -12,8 +12,6 @@\n # Translation of inline assembly.\n */\n \n-use std::c_str::ToCStr;\n-\n use lib;\n use middle::trans::build::*;\n use middle::trans::callee;\n@@ -22,18 +20,19 @@ use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::expr;\n use middle::trans::type_of;\n-\n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n+use std::vec_ng::Vec;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n                         -> &'a Block<'a> {\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n-    let mut constraints = ~[];\n-    let mut output_types = ~[];\n+    let mut constraints = Vec::new();\n+    let mut output_types = Vec::new();\n \n     let temp_scope = fcx.push_custom_cleanup_scope();\n \n@@ -88,9 +87,9 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     let output_type = if num_outputs == 0 {\n         Type::void()\n     } else if num_outputs == 1 {\n-        output_types[0]\n+        *output_types.get(0)\n     } else {\n-        Type::struct_(output_types, false)\n+        Type::struct_(output_types.as_slice(), false)\n     };\n \n     let dialect = match ia.dialect {"}, {"sha": "362f5fbacf089bdc0f773f6aeecd53b91a179abb", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 64, "deletions": 41, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -73,11 +73,12 @@ use util::sha2::Sha256;\n use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n+use collections::HashMap;\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n-use collections::HashMap;\n use std::libc::c_uint;\n use std::local_data;\n+use std::vec_ng::Vec;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n use syntax::ast_map::PathName;\n use syntax::ast_util::{local_def, is_local};\n@@ -94,19 +95,19 @@ use time;\n \n pub use middle::trans::context::task_llcx;\n \n-local_data_key!(task_local_insn_key: ~[&'static str])\n+local_data_key!(task_local_insn_key: Vec<&'static str> )\n \n pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n     local_data::get(task_local_insn_key, |c| {\n         match c {\n-            Some(ctx) => blk(*ctx),\n+            Some(ctx) => blk(ctx.as_slice()),\n             None => ()\n         }\n     })\n }\n \n pub fn init_insn_ctxt() {\n-    local_data::set(task_local_insn_key, ~[]);\n+    local_data::set(task_local_insn_key, Vec::new());\n }\n \n pub struct _InsnCtxt { _x: () }\n@@ -543,7 +544,7 @@ pub fn get_res_dtor(ccx: @CrateContext,\n         let tsubsts = ty::substs {\n             regions: ty::ErasedRegions,\n             self_ty: None,\n-            tps: substs.to_owned()\n+            tps: Vec::from_slice(substs),\n         };\n \n         let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx, did.node, &tsubsts);\n@@ -752,8 +753,8 @@ pub fn iter_structural_ty<'r,\n \n           match adt::trans_switch(cx, repr, av) {\n               (_match::single, None) => {\n-                  cx = iter_variant(cx, repr, av, variants[0],\n-                                    substs.tps, f);\n+                  cx = iter_variant(cx, repr, av, *variants.get(0),\n+                                    substs.tps.as_slice(), f);\n               }\n               (_match::switch, Some(lldiscrim_a)) => {\n                   cx = f(cx, lldiscrim_a, ty::mk_int());\n@@ -775,8 +776,12 @@ pub fn iter_structural_ty<'r,\n                                                 in iter_structural_ty\")\n                       }\n                       let variant_cx =\n-                          iter_variant(variant_cx, repr, av, *variant,\n-                                       substs.tps, |x,y,z| f(x,y,z));\n+                          iter_variant(variant_cx,\n+                                       repr,\n+                                       av,\n+                                       *variant,\n+                                       substs.tps.as_slice(),\n+                                       |x,y,z| f(x,y,z));\n                       Br(variant_cx, next_cx.llbb);\n                   }\n                   cx = next_cx;\n@@ -876,7 +881,11 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n             match fn_ty.abis.for_target(ccx.sess.targ_cfg.os,\n                                         ccx.sess.targ_cfg.arch) {\n                 Some(Rust) | Some(RustIntrinsic) => {\n-                    get_extern_rust_fn(ccx, fn_ty.sig.inputs, fn_ty.sig.output, name, did)\n+                    get_extern_rust_fn(ccx,\n+                                       fn_ty.sig.inputs.as_slice(),\n+                                       fn_ty.sig.output,\n+                                       name,\n+                                       did)\n                 }\n                 Some(..) | None => {\n                     let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n@@ -889,7 +898,11 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n             }\n         }\n         ty::ty_closure(ref f) => {\n-            get_extern_rust_fn(ccx, f.sig.inputs, f.sig.output, name, did)\n+            get_extern_rust_fn(ccx,\n+                               f.sig.inputs.as_slice(),\n+                               f.sig.output,\n+                               name,\n+                               did)\n         }\n         _ => {\n             let llty = type_of(ccx, t);\n@@ -902,7 +915,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n pub fn invoke<'a>(\n               bcx: &'a Block<'a>,\n               llfn: ValueRef,\n-              llargs: ~[ValueRef],\n+              llargs: Vec<ValueRef> ,\n               attributes: &[(uint, lib::llvm::Attribute)],\n               call_info: Option<NodeInfo>)\n               -> (ValueRef, &'a Block<'a>) {\n@@ -935,7 +948,7 @@ pub fn invoke<'a>(\n \n         let llresult = Invoke(bcx,\n                               llfn,\n-                              llargs,\n+                              llargs.as_slice(),\n                               normal_bcx.llbb,\n                               landing_pad,\n                               attributes);\n@@ -951,7 +964,7 @@ pub fn invoke<'a>(\n             None => debuginfo::clear_source_location(bcx.fcx)\n         };\n \n-        let llresult = Call(bcx, llfn, llargs, attributes);\n+        let llresult = Call(bcx, llfn, llargs.as_slice(), attributes);\n         return (llresult, bcx);\n     }\n }\n@@ -1231,7 +1244,10 @@ pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n     let substd_output_type = match param_substs {\n         None => output_type,\n         Some(substs) => {\n-            ty::subst_tps(ccx.tcx, substs.tys, substs.self_ty, output_type)\n+            ty::subst_tps(ccx.tcx,\n+                          substs.tys.as_slice(),\n+                          substs.self_ty,\n+                          output_type)\n         }\n     };\n     let uses_outptr = type_of::return_uses_outptr(ccx, substd_output_type);\n@@ -1255,7 +1271,7 @@ pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n           block_arena: block_arena,\n           ccx: ccx,\n           debug_context: debug_context,\n-          scopes: RefCell::new(~[])\n+          scopes: RefCell::new(Vec::new())\n     };\n \n     if has_env {\n@@ -1289,7 +1305,7 @@ pub fn init_function<'a>(\n         None => output_type,\n         Some(substs) => {\n             ty::subst_tps(fcx.ccx.tcx,\n-                          substs.tys,\n+                          substs.tys.as_slice(),\n                           substs.self_ty,\n                           output_type)\n         }\n@@ -1331,7 +1347,7 @@ pub type LvalueDatum = datum::Datum<datum::Lvalue>;\n // appropriate lvalue datums.\n pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n                                  arg_tys: &[ty::t])\n-                                 -> ~[RvalueDatum] {\n+                                 -> Vec<RvalueDatum> {\n     let _icx = push_ctxt(\"create_datums_for_fn_args\");\n \n     // Return an array wrapping the ValueRefs that we get from\n@@ -1348,7 +1364,7 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n                             arg_scope: cleanup::CustomScopeIndex,\n                             bcx: &'a Block<'a>,\n                             args: &[ast::Arg],\n-                            arg_datums: ~[RvalueDatum])\n+                            arg_datums: Vec<RvalueDatum> )\n                             -> &'a Block<'a> {\n     debug!(\"copy_args_to_allocas\");\n \n@@ -1472,7 +1488,7 @@ pub fn trans_closure<'a>(ccx: @CrateContext,\n \n     // Set up arguments to the function.\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys);\n+    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n \n     bcx = copy_args_to_allocas(&fcx,\n                                arg_scope,\n@@ -1583,7 +1599,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n     let no_substs: &[ty::t] = [];\n     let ty_param_substs = match param_substs {\n         Some(ref substs) => {\n-            let v: &[ty::t] = substs.tys;\n+            let v: &[ty::t] = substs.tys.as_slice();\n             v\n         }\n         None => {\n@@ -1612,7 +1628,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys);\n+    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n \n     let bcx = fcx.entry_bcx.get().unwrap();\n \n@@ -1633,10 +1649,10 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n }\n \n pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::EnumDef,\n-                      id: ast::NodeId, vi: @~[@ty::VariantInfo],\n+                      id: ast::NodeId, vi: @Vec<@ty::VariantInfo> ,\n                       i: &mut uint) {\n     for &variant in enum_definition.variants.iter() {\n-        let disr_val = vi[*i].disr_val;\n+        let disr_val = vi.get(*i).disr_val;\n         *i += 1;\n \n         match variant.node.kind {\n@@ -1801,7 +1817,11 @@ fn register_fn(ccx: @CrateContext,\n         _ => fail!(\"expected bare rust fn or an intrinsic\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, false, f.sig.inputs, f.sig.output, sym);\n+    let llfn = decl_rust_fn(ccx,\n+                            false,\n+                            f.sig.inputs.as_slice(),\n+                            f.sig.output,\n+                            sym);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -1876,25 +1896,27 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n                         llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p().to_ref(), buf)\n                     });\n \n-                    ~[\n+                    vec!(\n                         opaque_rust_main,\n                         llvm::LLVMGetParam(llfn, 0),\n                         llvm::LLVMGetParam(llfn, 1)\n-                     ]\n+                     )\n                 };\n                 (start_fn, args)\n             } else {\n                 debug!(\"using user-defined start fn\");\n-                let args = ~[\n+                let args = vec!(\n                     llvm::LLVMGetParam(llfn, 0 as c_uint),\n                     llvm::LLVMGetParam(llfn, 1 as c_uint)\n-                ];\n+                );\n \n                 (rust_main, args)\n             };\n \n-            let result = llvm::LLVMBuildCall(bld, start_fn,\n-                                             args.as_ptr(), args.len() as c_uint,\n+            let result = llvm::LLVMBuildCall(bld,\n+                                             start_fn,\n+                                             args.as_ptr(),\n+                                             args.len() as c_uint,\n                                              noname());\n \n             llvm::LLVMBuildRet(bld, result);\n@@ -2450,13 +2472,13 @@ pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n         }\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n-    let mut elts: ~[ValueRef] = ~[];\n+    let mut elts: Vec<ValueRef> = Vec::new();\n \n     // This is not ideal, but the borrow checker doesn't\n     // like the multiple borrows. At least, it doesn't\n     // like them on the current snapshot. (2013-06-14)\n     let keys = {\n-        let mut keys = ~[];\n+        let mut keys = Vec::new();\n         let module_data = ccx.module_data.borrow();\n         for (k, _) in module_data.get().iter() {\n             keys.push(k.clone());\n@@ -2476,7 +2498,7 @@ pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n         elts.push(elt);\n     }\n     unsafe {\n-        llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n+        llvm::LLVMSetInitializer(map, C_array(elttype, elts.as_slice()));\n     }\n     return (map, keys.len())\n }\n@@ -2526,7 +2548,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n }\n \n pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n-    let mut subcrates: ~[ValueRef] = ~[];\n+    let mut subcrates: Vec<ValueRef> = Vec::new();\n     let mut i = 1;\n     let cstore = ccx.sess.cstore;\n     while cstore.have_crate_data(i) {\n@@ -2564,7 +2586,8 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n         });\n         lib::llvm::SetLinkage(vec_elements, lib::llvm::InternalLinkage);\n \n-        llvm::LLVMSetInitializer(vec_elements, C_array(ccx.int_type, subcrates));\n+        llvm::LLVMSetInitializer(vec_elements,\n+                                 C_array(ccx.int_type, subcrates.as_slice()));\n         let (mod_map, mod_count) = create_module_map(ccx);\n \n         llvm::LLVMSetInitializer(map, C_struct(\n@@ -2600,11 +2623,11 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeI\n         }\n }\n \n-pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> ~[u8] {\n+pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     use flate;\n \n     if !cx.sess.building_library.get() {\n-        return ~[]\n+        return Vec::new()\n     }\n \n     let encode_inlined_item: encoder::EncodeInlinedItem =\n@@ -2613,7 +2636,7 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> ~[u8] {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let compressed = encoder::metadata_encoding_version +\n-                        flate::deflate_bytes(metadata).as_slice();\n+                        flate::deflate_bytes(metadata.as_slice()).as_slice();\n     let llmeta = C_bytes(compressed);\n     let llconst = C_struct([llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.crateid.name,\n@@ -2744,12 +2767,12 @@ pub fn trans_crate(sess: session::Session,\n     let link_meta = ccx.link_meta.clone();\n     let llmod = ccx.llmod;\n \n-    let mut reachable = {\n+    let mut reachable: Vec<~str> = {\n         let reachable_map = ccx.reachable.borrow();\n         reachable_map.get().iter().filter_map(|id| {\n             let item_symbols = ccx.item_symbols.borrow();\n             item_symbols.get().find(id).map(|s| s.to_owned())\n-        }).to_owned_vec()\n+        }).collect()\n     };\n \n     // Make sure that some other crucial symbols are not eliminated from the"}, {"sha": "15e74b1b55d434c93f91e787e68c50c53a977772", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -17,8 +17,10 @@ use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::machine::llalign_of_pref;\n use middle::trans::type_::Type;\n-use std::libc::{c_uint, c_ulonglong, c_char};\n+\n use collections::HashMap;\n+use std::libc::{c_uint, c_ulonglong, c_char};\n+use std::vec_ng::Vec;\n use syntax::codemap::Span;\n \n pub struct Builder<'a> {\n@@ -540,9 +542,9 @@ impl<'a> Builder<'a> {\n             }\n             self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n         } else {\n-            let v = ixs.iter().map(|i| C_i32(*i as i32)).collect::<~[ValueRef]>();\n+            let v = ixs.iter().map(|i| C_i32(*i as i32)).collect::<Vec<ValueRef> >();\n             self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, v)\n+            self.inbounds_gep(base, v.as_slice())\n         }\n     }\n "}, {"sha": "b8ab8d81d2f1adede8e7dfdc2f0513f7dd0b9f04", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -16,6 +16,7 @@ use middle::trans::cabi_x86_64;\n use middle::trans::cabi_arm;\n use middle::trans::cabi_mips;\n use middle::trans::type_::Type;\n+use std::vec_ng::Vec;\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n #[deriving(Clone, Eq)]\n@@ -83,7 +84,7 @@ impl ArgType {\n /// comments are reverse-engineered and may be inaccurate. -NDM\n pub struct FnType {\n     /// The LLVM types of each argument.\n-    arg_tys: ~[ArgType],\n+    arg_tys: Vec<ArgType> ,\n \n     /// LLVM return type.\n     ret_ty: ArgType,"}, {"sha": "341844a3be0a0c7d134c392396447ff806743b4c", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -14,11 +14,11 @@ use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::StructRetAttribute;\n use middle::trans::cabi::{FnType, ArgType};\n use middle::trans::context::CrateContext;\n-\n use middle::trans::type_::Type;\n \n use std::cmp;\n use std::option::{None, Some};\n+use std::vec_ng::Vec;\n \n fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n@@ -131,7 +131,7 @@ pub fn compute_abi_info(_ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    let mut arg_tys = ~[];\n+    let mut arg_tys = Vec::new();\n     for &aty in atys.iter() {\n         let ty = classify_arg_ty(aty);\n         arg_tys.push(ty);"}, {"sha": "4bd695422a2bf77ae53b66fe722cbb1d360506db", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -17,9 +17,10 @@ use lib::llvm::StructRetAttribute;\n use middle::trans::context::CrateContext;\n use middle::trans::context::task_llcx;\n use middle::trans::cabi::*;\n-\n use middle::trans::type_::Type;\n \n+use std::vec_ng::Vec;\n+\n fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n }\n@@ -132,9 +133,9 @@ fn padding_ty(align: uint, offset: uint) -> Option<Type> {\n     return None;\n }\n \n-fn coerce_to_int(size: uint) -> ~[Type] {\n+fn coerce_to_int(size: uint) -> Vec<Type> {\n     let int_ty = Type::i32();\n-    let mut args = ~[];\n+    let mut args = Vec::new();\n \n     let mut n = size / 32;\n     while n > 0 {\n@@ -155,7 +156,7 @@ fn coerce_to_int(size: uint) -> ~[Type] {\n fn struct_ty(ty: Type) -> Type {\n     let size = ty_size(ty) * 8;\n     let fields = coerce_to_int(size);\n-    return Type::struct_(fields, false);\n+    return Type::struct_(fields.as_slice(), false);\n }\n \n pub fn compute_abi_info(_ccx: &CrateContext,\n@@ -169,7 +170,7 @@ pub fn compute_abi_info(_ccx: &CrateContext,\n     };\n \n     let sret = ret_ty.is_indirect();\n-    let mut arg_tys = ~[];\n+    let mut arg_tys = Vec::new();\n     let mut offset = if sret { 4 } else { 0 };\n \n     for aty in atys.iter() {"}, {"sha": "194197e50118b42326057df0bacecdb6455c8c0f", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -15,12 +15,13 @@ use super::cabi::*;\n use super::common::*;\n use super::machine::*;\n use middle::trans::type_::Type;\n+use std::vec_ng::Vec;\n \n pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    let mut arg_tys = ~[];\n+    let mut arg_tys = Vec::new();\n \n     let ret_ty;\n     if !ret_def {"}, {"sha": "d3ffa7865a228a7290d9284cd74b5d6ceb52d197", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -18,11 +18,10 @@ use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute, ByValAttribute};\n use middle::trans::cabi::*;\n use middle::trans::context::CrateContext;\n-\n use middle::trans::type_::Type;\n \n use std::cmp;\n-use std::vec;\n+use std::vec_ng::Vec;\n \n #[deriving(Clone, Eq)]\n enum RegClass {\n@@ -84,7 +83,7 @@ impl<'a> ClassList for &'a [RegClass] {\n     }\n }\n \n-fn classify_ty(ty: Type) -> ~[RegClass] {\n+fn classify_ty(ty: Type) -> Vec<RegClass> {\n     fn align(off: uint, ty: Type) -> uint {\n         let a = ty_align(ty);\n         return (off + a - 1u) / a * a;\n@@ -220,7 +219,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 unify(cls, ix + off / 8u, SSEDs);\n             }\n             Struct => {\n-                classify_struct(ty.field_types(), cls, ix, off);\n+                classify_struct(ty.field_types().as_slice(), cls, ix, off);\n             }\n             Array => {\n                 let len = ty.array_length();\n@@ -282,13 +281,13 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n     }\n \n     let words = (ty_size(ty) + 7) / 8;\n-    let mut cls = vec::from_elem(words, NoClass);\n+    let mut cls = Vec::from_elem(words, NoClass);\n     if words > 4 {\n-        all_mem(cls);\n+        all_mem(cls.as_mut_slice());\n         return cls;\n     }\n-    classify(ty, cls, 0, 0);\n-    fixup(ty, cls);\n+    classify(ty, cls.as_mut_slice(), 0, 0);\n+    fixup(ty, cls.as_mut_slice());\n     return cls;\n }\n \n@@ -304,7 +303,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n         return len;\n     }\n \n-    let mut tys = ~[];\n+    let mut tys = Vec::new();\n     let mut i = 0u;\n     let e = cls.len();\n     while i < e {\n@@ -329,7 +328,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n         }\n         i += 1u;\n     }\n-    return Type::struct_(tys, false);\n+    return Type::struct_(tys.as_slice(), false);\n }\n \n pub fn compute_abi_info(_ccx: &CrateContext,\n@@ -342,17 +341,20 @@ pub fn compute_abi_info(_ccx: &CrateContext,\n                  -> ArgType {\n         if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n-            if is_mem_cls(cls) {\n+            if is_mem_cls(cls.as_slice()) {\n                 ArgType::indirect(ty, Some(attr))\n             } else {\n-                ArgType::direct(ty, Some(llreg_ty(cls)), None, None)\n+                ArgType::direct(ty,\n+                                Some(llreg_ty(cls.as_slice())),\n+                                None,\n+                                None)\n             }\n         } else {\n             ArgType::direct(ty, None, None, None)\n         }\n     }\n \n-    let mut arg_tys = ~[];\n+    let mut arg_tys = Vec::new();\n     for t in atys.iter() {\n         let ty = x86_64_ty(*t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);"}, {"sha": "1ede187245e6dff0620c6d090dbecb99eb52974e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -48,6 +48,8 @@ use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast;\n use syntax::abi::AbiSet;\n use syntax::ast_map;\n@@ -174,7 +176,12 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId,\n     debug!(\"trans_fn_ref(def_id={}, ref_id={:?}, type_params={}, vtables={})\",\n            def_id.repr(bcx.tcx()), ref_id, type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n-    trans_fn_ref_with_vtables(bcx, def_id, ref_id, is_method, type_params, vtables)\n+    trans_fn_ref_with_vtables(bcx,\n+                              def_id,\n+                              ref_id,\n+                              is_method,\n+                              type_params.as_slice(),\n+                              vtables)\n }\n \n fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n@@ -218,10 +225,11 @@ fn resolve_default_method_vtables(bcx: &Block,\n                 vtables.len() - num_method_vtables;\n             vtables.tailn(num_impl_type_parameters).to_owned()\n         },\n-        None => vec::from_elem(num_method_vtables, @~[])\n+        None => vec::from_elem(num_method_vtables, @Vec::new())\n     };\n \n-    let param_vtables = @(*trait_vtables_fixed + method_vtables);\n+    let param_vtables = @(vec_ng::append((*trait_vtables_fixed).clone(),\n+                                          method_vtables));\n \n     let self_vtables = resolve_param_vtables_under_param_substs(\n         bcx.tcx(), param_substs, impl_res.self_vtables);\n@@ -272,7 +280,7 @@ pub fn trans_fn_ref_with_vtables(\n \n     let substs = ty::substs { regions: ty::ErasedRegions,\n                               self_ty: None,\n-                              tps: /*bad*/ type_params.to_owned() };\n+                              tps: /*bad*/ Vec::from_slice(type_params) };\n \n     // Load the info for the appropriate trait if necessary.\n     match ty::trait_of_method(tcx, def_id) {\n@@ -640,7 +648,7 @@ pub fn trans_call_inner<'a>(\n     // written in opt_llretslot (if it is Some) or `llresult` will be\n     // set appropriately (otherwise).\n     if is_rust_fn {\n-        let mut llargs = ~[];\n+        let mut llargs = Vec::new();\n \n         // Push the out-pointer if we use an out-pointer for this\n         // return type, otherwise push \"undef\".\n@@ -666,7 +674,7 @@ pub fn trans_call_inner<'a>(\n         // available, so we have to apply any attributes with ABI\n         // implications directly to the call instruction. Right now,\n         // the only attribute we need to worry about is `sret`.\n-        let mut attrs = ~[];\n+        let mut attrs = Vec::new();\n         if type_of::return_uses_outptr(ccx, ret_ty) {\n             attrs.push((1, StructRetAttribute));\n         }\n@@ -683,7 +691,11 @@ pub fn trans_call_inner<'a>(\n         }\n \n         // Invoke the actual rust fn and update bcx/llresult.\n-        let (llret, b) = base::invoke(bcx, llfn, llargs, attrs, call_info);\n+        let (llret, b) = base::invoke(bcx,\n+                                      llfn,\n+                                      llargs,\n+                                      attrs.as_slice(),\n+                                      call_info);\n         bcx = b;\n         llresult = llret;\n \n@@ -704,16 +716,20 @@ pub fn trans_call_inner<'a>(\n         // they are always Rust fns.\n         assert!(dest.is_some());\n \n-        let mut llargs = ~[];\n+        let mut llargs = Vec::new();\n         bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n                          cleanup::CustomScope(arg_cleanup_scope), false);\n         fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n         let arg_tys = match args {\n             ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, *x)).collect(),\n             _ => fail!(\"expected arg exprs.\")\n         };\n-        bcx = foreign::trans_native_call(bcx, callee_ty,\n-                                         llfn, opt_llretslot.unwrap(), llargs, arg_tys);\n+        bcx = foreign::trans_native_call(bcx,\n+                                         callee_ty,\n+                                         llfn,\n+                                         opt_llretslot.unwrap(),\n+                                         llargs.as_slice(),\n+                                         arg_tys);\n     }\n \n     // If the caller doesn't care about the result of this fn call,\n@@ -746,7 +762,7 @@ pub enum CallArgs<'a> {\n fn trans_args<'a>(cx: &'a Block<'a>,\n                   args: CallArgs,\n                   fn_ty: ty::t,\n-                  llargs: &mut ~[ValueRef],\n+                  llargs: &mut Vec<ValueRef> ,\n                   arg_cleanup_scope: cleanup::ScopeId,\n                   ignore_self: bool)\n                   -> &'a Block<'a> {\n@@ -770,7 +786,7 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n                     assert!(variadic);\n                     expr_ty_adjusted(cx, *arg_expr)\n                 } else {\n-                    arg_tys[i]\n+                    *arg_tys.get(i)\n                 };\n                 llargs.push(unpack_result!(bcx, {\n                     trans_arg_expr(bcx, arg_ty, *arg_expr,\n@@ -783,7 +799,7 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n             assert!(!variadic);\n \n             llargs.push(unpack_result!(bcx, {\n-                trans_arg_expr(bcx, arg_tys[0], arg_expr,\n+                trans_arg_expr(bcx, *arg_tys.get(0), arg_expr,\n                                arg_cleanup_scope,\n                                DontAutorefArg)\n             }));\n@@ -793,7 +809,7 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n                     assert_eq!(arg_tys.len(), 2);\n \n                     llargs.push(unpack_result!(bcx, {\n-                        trans_arg_expr(bcx, arg_tys[1], arg2_expr,\n+                        trans_arg_expr(bcx, *arg_tys.get(1), arg2_expr,\n                                        arg_cleanup_scope,\n                                        DoAutorefArg)\n                     }));"}, {"sha": "be5eab0e8eca735b8d3fc6a8097b15f4a0349be9", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -349,7 +349,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         assert!(self.is_valid_custom_scope(custom_scope));\n \n         let mut scopes = self.scopes.borrow_mut();\n-        let scope = &mut scopes.get()[custom_scope.index];\n+        let scope = scopes.get().get_mut(custom_scope.index);\n         scope.cleanups.push(cleanup);\n         scope.clear_cached_exits();\n     }\n@@ -433,7 +433,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n     fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n         let scopes = self.scopes.borrow();\n         custom_scope.index < scopes.get().len() &&\n-            scopes.get()[custom_scope.index].kind.is_temp()\n+            scopes.get().get(custom_scope.index).kind.is_temp()\n     }\n \n     fn trans_scope_cleanups(&self, // cannot borrow self, will recurse"}, {"sha": "f18456a674dd257d5c5adf5568569b217de8cc1e", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -27,6 +27,7 @@ use util::ppaux::Repr;\n use util::ppaux::ty_to_str;\n \n use arena::TypedArena;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n \n@@ -139,20 +140,20 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     // is the actual types that will be stored in the map, not the\n     // logical types as the user sees them, so by-ref upvars must be\n     // converted to ptrs.\n-    let bound_tys = bound_values.map(|bv| {\n+    let bound_tys = bound_values.iter().map(|bv| {\n         match bv.action {\n             EnvCopy | EnvMove => bv.datum.ty,\n             EnvRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n         }\n-    });\n+    }).collect();\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n     debug!(\"cdata_ty={}\", ty_to_str(tcx, cdata_ty));\n     return cdata_ty;\n }\n \n fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let ptr = ty::mk_imm_ptr(tcx, ty::mk_i8());\n-    ty::mk_tup(tcx, ~[ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t])\n+    ty::mk_tup(tcx, vec!(ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }\n \n fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n@@ -191,15 +192,15 @@ pub struct ClosureResult<'a> {\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n pub fn store_environment<'a>(\n                          bcx: &'a Block<'a>,\n-                         bound_values: ~[EnvValue],\n+                         bound_values: Vec<EnvValue> ,\n                          sigil: ast::Sigil)\n                          -> ClosureResult<'a> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n     // compute the type of the closure\n-    let cdata_ty = mk_closure_tys(tcx, bound_values);\n+    let cdata_ty = mk_closure_tys(tcx, bound_values.as_slice());\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n@@ -258,7 +259,7 @@ fn build_closure<'a>(bcx0: &'a Block<'a>,\n     let bcx = bcx0;\n \n     // Package up the captured upvars\n-    let mut env_vals = ~[];\n+    let mut env_vals = Vec::new();\n     for cap_var in cap_vars.iter() {\n         debug!(\"Building closure: captured variable {:?}\", *cap_var);\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n@@ -387,7 +388,11 @@ pub fn trans_expr_fn<'a>(\n     let s = tcx.map.with_path(id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n-    let llfn = decl_internal_rust_fn(ccx, true, f.sig.inputs, f.sig.output, s);\n+    let llfn = decl_internal_rust_fn(ccx,\n+                                     true,\n+                                     f.sig.inputs.as_slice(),\n+                                     f.sig.output,\n+                                     s);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -396,11 +401,17 @@ pub fn trans_expr_fn<'a>(\n         let capture_map = ccx.maps.capture_map.borrow();\n         capture_map.get().get_copy(&id)\n     };\n-    let ClosureResult {llbox, cdata_ty, bcx} = build_closure(bcx, *cap_vars.borrow(), sigil);\n+    let ClosureResult {llbox, cdata_ty, bcx} =\n+        build_closure(bcx, cap_vars.borrow().as_slice(), sigil);\n     trans_closure(ccx, decl, body, llfn,\n                   bcx.fcx.param_substs, id,\n                   [], ty::ty_fn_ret(fty),\n-                  |bcx| load_environment(bcx, cdata_ty, *cap_vars.borrow(), sigil));\n+                  |bcx| {\n+                      load_environment(bcx,\n+                                       cdata_ty,\n+                                       cap_vars.borrow().as_slice(),\n+                                       sigil)\n+                  });\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n \n     bcx\n@@ -447,9 +458,13 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n         mangle_internal_name_by_path_and_seq(path, \"as_closure\")\n     });\n     let llfn = if is_local {\n-        decl_internal_rust_fn(ccx, true, f.sig.inputs, f.sig.output, name)\n+        decl_internal_rust_fn(ccx,\n+                              true,\n+                              f.sig.inputs.as_slice(),\n+                              f.sig.output,\n+                              name)\n     } else {\n-        decl_rust_fn(ccx, true, f.sig.inputs, f.sig.output, name)\n+        decl_rust_fn(ccx, true, f.sig.inputs.as_slice(), f.sig.output, name)\n     };\n \n     {\n@@ -470,8 +485,10 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n     init_function(&fcx, true, f.sig.output, None);\n     let bcx = fcx.entry_bcx.get().unwrap();\n \n-    let args = create_datums_for_fn_args(&fcx, ty::ty_fn_args(closure_ty));\n-    let mut llargs = ~[];\n+    let args = create_datums_for_fn_args(&fcx,\n+                                         ty::ty_fn_args(closure_ty)\n+                                            .as_slice());\n+    let mut llargs = Vec::new();\n     match fcx.llretptr.get() {\n         Some(llretptr) => {\n             llargs.push(llretptr);\n@@ -480,7 +497,7 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n     }\n     llargs.extend(&mut args.iter().map(|arg| arg.val));\n \n-    let retval = Call(bcx, fn_ptr, llargs, []);\n+    let retval = Call(bcx, fn_ptr, llargs.as_slice(), []);\n     if type_is_zero_size(ccx, f.sig.output) || fcx.llretptr.get().is_some() {\n         RetVoid(bcx);\n     } else {"}, {"sha": "4194f3ff57c06c8b5409b76d690fd7ebc815cc74", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -32,10 +32,11 @@ use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n+use collections::HashMap;\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n-use collections::HashMap;\n use std::libc::{c_uint, c_longlong, c_ulonglong, c_char};\n+use std::vec_ng::Vec;\n use syntax::ast::Ident;\n use syntax::ast;\n use syntax::ast_map::{PathElem, PathName};\n@@ -50,8 +51,9 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::struct_fields(ccx.tcx, def_id, substs);\n             fields.len() == 1 &&\n-                fields[0].ident.name == token::special_idents::unnamed_field.name &&\n-                type_is_immediate(ccx, fields[0].mt.ty)\n+                fields.get(0).ident.name ==\n+                    token::special_idents::unnamed_field.name &&\n+                type_is_immediate(ccx, fields.get(0).mt.ty)\n         }\n         _ => false\n     }\n@@ -161,7 +163,7 @@ pub struct Stats {\n     n_llvm_insns: Cell<uint>,\n     llvm_insns: RefCell<HashMap<~str, uint>>,\n     // (ident, time-in-ms, llvm-instructions)\n-    fn_stats: RefCell<~[(~str, uint, uint)]>,\n+    fn_stats: RefCell<Vec<(~str, uint, uint)> >,\n }\n \n pub struct BuilderRef_res {\n@@ -187,7 +189,7 @@ pub type ExternMap = HashMap<~str, ValueRef>;\n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n pub struct param_substs {\n-    tys: ~[ty::t],\n+    tys: Vec<ty::t> ,\n     self_ty: Option<ty::t>,\n     vtables: Option<typeck::vtable_res>,\n     self_vtables: Option<typeck::vtable_param_res>\n@@ -285,7 +287,7 @@ pub struct FunctionContext<'a> {\n     debug_context: debuginfo::FunctionDebugContext,\n \n     // Cleanup scopes.\n-    scopes: RefCell<~[cleanup::CleanupScope<'a>]>,\n+    scopes: RefCell<Vec<cleanup::CleanupScope<'a>> >,\n }\n \n impl<'a> FunctionContext<'a> {\n@@ -639,7 +641,7 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n     unsafe {\n         let mut i = 0u;\n-        let mut elts: ~[ValueRef] = ~[];\n+        let mut elts: Vec<ValueRef> = Vec::new();\n         while i < size { elts.push(C_u8(0u)); i += 1u; }\n         return llvm::LLVMConstArray(Type::i8().to_ref(),\n                                     elts.as_ptr(), elts.len() as c_uint);\n@@ -725,7 +727,7 @@ pub fn is_null(val: ValueRef) -> bool {\n // Used to identify cached monomorphized functions and vtables\n #[deriving(Eq, Hash)]\n pub enum mono_param_id {\n-    mono_precise(ty::t, Option<@~[mono_id]>),\n+    mono_precise(ty::t, Option<@Vec<mono_id> >),\n     mono_any,\n     mono_repr(uint /* size */,\n               uint /* align */,\n@@ -758,8 +760,7 @@ pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n #[deriving(Eq, Hash)]\n pub struct mono_id_ {\n     def: ast::DefId,\n-    params: ~[mono_param_id]\n-}\n+    params: Vec<mono_param_id> }\n \n pub type mono_id = @mono_id_;\n \n@@ -782,7 +783,7 @@ pub fn align_to(cx: &Block, off: ValueRef, align: ValueRef) -> ValueRef {\n pub fn monomorphize_type(bcx: &Block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n         Some(substs) => {\n-            ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n+            ty::subst_tps(bcx.tcx(), substs.tys.as_slice(), substs.self_ty, t)\n         }\n         _ => {\n             assert!(!ty::type_has_params(t));\n@@ -808,7 +809,7 @@ pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n     monomorphize_type(bcx, t)\n }\n \n-pub fn node_id_type_params(bcx: &Block, id: ast::NodeId, is_method: bool) -> ~[ty::t] {\n+pub fn node_id_type_params(bcx: &Block, id: ast::NodeId, is_method: bool) -> Vec<ty::t> {\n     let tcx = bcx.tcx();\n     let params = if is_method {\n         bcx.ccx().maps.method_map.borrow().get().get(&id).substs.tps.clone()\n@@ -825,7 +826,7 @@ pub fn node_id_type_params(bcx: &Block, id: ast::NodeId, is_method: bool) -> ~[t\n     match bcx.fcx.param_substs {\n       Some(substs) => {\n         params.iter().map(|t| {\n-            ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n+            ty::subst_tps(tcx, substs.tys.as_slice(), substs.self_ty, *t)\n         }).collect()\n       }\n       _ => params\n@@ -882,10 +883,13 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n             let tys = match param_substs {\n                 Some(substs) => {\n                     tys.iter().map(|t| {\n-                        ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n+                        ty::subst_tps(tcx,\n+                                      substs.tys.as_slice(),\n+                                      substs.self_ty,\n+                                      *t)\n                     }).collect()\n                 }\n-                _ => tys.to_owned()\n+                _ => Vec::from_slice(tys.as_slice())\n             };\n             typeck::vtable_static(\n                 trait_id, tys,\n@@ -919,13 +923,13 @@ pub fn find_vtable(tcx: ty::ctxt,\n         typeck::param_numbered(n) => {\n             let tables = ps.vtables\n                 .expect(\"vtables missing where they are needed\");\n-            tables[n]\n+            *tables.get(n)\n         }\n     };\n-    param_bounds[n_bound].clone()\n+    param_bounds.get(n_bound).clone()\n }\n \n-pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n+pub fn dummy_substs(tps: Vec<ty::t> ) -> ty::substs {\n     substs {\n         regions: ty::ErasedRegions,\n         self_ty: None,"}, {"sha": "f1e6fff533985cfd12f5ca505793d124d8254966", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -25,15 +25,16 @@ use middle::trans::consts;\n use middle::trans::expr;\n use middle::trans::inline;\n use middle::trans::machine;\n+use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n use util::ppaux::{Repr, ty_to_str};\n \n-use middle::trans::type_::Type;\n-\n use std::c_str::ToCStr;\n use std::libc::c_uint;\n use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::{ast, ast_util};\n \n pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n@@ -302,8 +303,9 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                          is_local: bool) -> (ValueRef, bool) {\n     let map_list = |exprs: &[@ast::Expr]| {\n         exprs.iter().map(|&e| const_expr(cx, e, is_local))\n-             .fold((~[], true), |(l, all_inlineable), (val, inlineable)| {\n-                (vec::append_one(l, val), all_inlineable && inlineable)\n+             .fold((Vec::new(), true),\n+                   |(l, all_inlineable), (val, inlineable)| {\n+                (vec_ng::append_one(l, val), all_inlineable && inlineable)\n              })\n     };\n     unsafe {\n@@ -532,7 +534,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n               let (vals, inlineable) = map_list(es.as_slice());\n-              (adt::trans_const(cx, repr, 0, vals), inlineable)\n+              (adt::trans_const(cx, repr, 0, vals.as_slice()), inlineable)\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n@@ -666,7 +668,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n-                      (adt::trans_const(cx, repr, 0, arg_vals), inlineable)\n+                      (adt::trans_const(cx, repr, 0, arg_vals.as_slice()),\n+                       inlineable)\n                   }\n                   Some(ast::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n@@ -675,8 +678,10 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                                                            enum_did,\n                                                            variant_did);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n-                      (adt::trans_const(cx, repr, vinfo.disr_val, arg_vals),\n-                       inlineable)\n+                      (adt::trans_const(cx,\n+                                        repr,\n+                                        vinfo.disr_val,\n+                                        arg_vals.as_slice()), inlineable)\n                   }\n                   _ => cx.sess.span_bug(e.span, \"expected a struct or variant def\")\n               }"}, {"sha": "517bef52a9939f448373d31f1212e39674c007b4", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -33,6 +33,7 @@ use std::cell::{Cell, RefCell};\n use std::c_str::ToCStr;\n use std::local_data;\n use std::libc::c_uint;\n+use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -226,7 +227,7 @@ impl CrateContext {\n                    n_closures: Cell::new(0u),\n                    n_llvm_insns: Cell::new(0u),\n                    llvm_insns: RefCell::new(HashMap::new()),\n-                   fn_stats: RefCell::new(~[]),\n+                   fn_stats: RefCell::new(Vec::new()),\n                  },\n                  tydesc_type: tydesc_type,\n                  int_type: int_type,\n@@ -250,7 +251,7 @@ impl CrateContext {\n                                indices: &[uint]) -> ValueRef {\n         debug!(\"const_inbounds_gepi: pointer={} indices={:?}\",\n                self.tn.val_to_str(pointer), indices);\n-        let v: ~[ValueRef] =\n+        let v: Vec<ValueRef> =\n             indices.iter().map(|i| C_i32(*i as i32)).collect();\n         unsafe {\n             llvm::LLVMConstInBoundsGEP(pointer,"}, {"sha": "261660c13bb2a39316c47fc2bffacd1ca2d3a00a", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -341,9 +341,12 @@ pub fn trans_fail<'a>(\n     let v_line = loc.line as int;\n     let v_str = PointerCast(bcx, v_fail_str, Type::i8p());\n     let v_filename = PointerCast(bcx, v_filename, Type::i8p());\n-    let args = ~[v_str, v_filename, C_int(ccx, v_line)];\n+    let args = vec!(v_str, v_filename, C_int(ccx, v_line));\n     let did = langcall(bcx, Some(sp), \"\", FailFnLangItem);\n-    let bcx = callee::trans_lang_call(bcx, did, args, Some(expr::Ignore)).bcx;\n+    let bcx = callee::trans_lang_call(bcx,\n+                                      did,\n+                                      args.as_slice(),\n+                                      Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;\n }\n@@ -356,9 +359,12 @@ pub fn trans_fail_bounds_check<'a>(\n                                -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n     let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n-    let args = ~[filename, line, index, len];\n+    let args = vec!(filename, line, index, len);\n     let did = langcall(bcx, Some(sp), \"\", FailBoundsCheckFnLangItem);\n-    let bcx = callee::trans_lang_call(bcx, did, args, Some(expr::Ignore)).bcx;\n+    let bcx = callee::trans_lang_call(bcx,\n+                                      did,\n+                                      args.as_slice(),\n+                                      Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;\n }"}, {"sha": "0e7c371b43d7f10554d49e9a8ef7cbe542dfb785", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 86, "deletions": 65, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -149,6 +149,7 @@ use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::sync::atomics;\n use std::vec;\n+use std::vec_ng::Vec;\n use syntax::codemap::{Span, Pos};\n use syntax::{abi, ast, codemap, ast_util, ast_map, opt_vec};\n use syntax::parse::token;\n@@ -177,7 +178,7 @@ pub struct CrateDebugContext {\n     priv current_debug_location: Cell<DebugLocation>,\n     priv created_files: RefCell<HashMap<~str, DIFile>>,\n     priv created_types: RefCell<HashMap<uint, DIType>>,\n-    priv namespace_map: RefCell<HashMap<~[ast::Name], @NamespaceTreeNode>>,\n+    priv namespace_map: RefCell<HashMap<Vec<ast::Name> , @NamespaceTreeNode>>,\n     // This collection is used to assert that composite types (structs, enums, ...) have their\n     // members only set once:\n     priv composite_types_completed: RefCell<HashSet<DIType>>,\n@@ -725,7 +726,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 let return_type = match param_substs {\n                     None => return_type,\n                     Some(substs) => {\n-                        ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, return_type)\n+                        ty::subst_tps(cx.tcx,\n+                                      substs.tys.as_slice(),\n+                                      substs.self_ty,\n+                                      return_type)\n                     }\n                 };\n \n@@ -740,7 +744,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             let arg_type = match param_substs {\n                 None => arg_type,\n                 Some(substs) => {\n-                    ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, arg_type)\n+                    ty::subst_tps(cx.tcx,\n+                                  substs.tys.as_slice(),\n+                                  substs.self_ty,\n+                                  arg_type)\n                 }\n             };\n \n@@ -771,7 +778,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         name_to_append_suffix_to.push_char('<');\n \n         // The list to be filled with template parameters:\n-        let mut template_params: ~[DIDescriptor] = vec::with_capacity(generics.ty_params.len() + 1);\n+        let mut template_params: Vec<DIDescriptor> =\n+            Vec::with_capacity(generics.ty_params.len() + 1);\n \n         // Handle self type\n         if has_self_type {\n@@ -814,12 +822,12 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         let actual_types = match param_substs {\n             Some(param_substs) => &param_substs.tys,\n             None => {\n-                return create_DIArray(DIB(cx), template_params);\n+                return create_DIArray(DIB(cx), template_params.as_slice());\n             }\n         };\n \n         for (index, &ast::TyParam{ ident: ident, .. }) in generics.ty_params.iter().enumerate() {\n-            let actual_type = actual_types[index];\n+            let actual_type = *actual_types.get(index);\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = ppaux::ty_to_str(cx.tcx, actual_type);\n             name_to_append_suffix_to.push_str(actual_type_name);\n@@ -850,7 +858,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n         name_to_append_suffix_to.push_char('>');\n \n-        return create_DIArray(DIB(cx), template_params);\n+        return create_DIArray(DIB(cx), template_params.as_slice());\n     }\n }\n \n@@ -1136,7 +1144,7 @@ enum MemberDescriptionFactory {\n \n impl MemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> ~[MemberDescription] {\n+                                  -> Vec<MemberDescription> {\n         match *self {\n             StructMD(ref this) => {\n                 this.create_member_descriptions(cx)\n@@ -1155,13 +1163,13 @@ impl MemberDescriptionFactory {\n }\n \n struct StructMemberDescriptionFactory {\n-    fields: ~[ty::field],\n+    fields: Vec<ty::field> ,\n     span: Span,\n }\n \n impl StructMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> ~[MemberDescription] {\n+                                  -> Vec<MemberDescription> {\n         self.fields.map(|field| {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n                 ~\"\"\n@@ -1250,7 +1258,7 @@ impl RecursiveTypeDescription {\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n                                               llvm_type,\n-                                              member_descriptions,\n+                                              member_descriptions.as_slice(),\n                                               file_metadata,\n                                               codemap::DUMMY_SP);\n                 return metadata_stub;\n@@ -1260,13 +1268,13 @@ impl RecursiveTypeDescription {\n }\n \n struct TupleMemberDescriptionFactory {\n-    component_types: ~[ty::t],\n+    component_types: Vec<ty::t> ,\n     span: Span,\n }\n \n impl TupleMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> ~[MemberDescription] {\n+                                  -> Vec<MemberDescription> {\n         self.component_types.map(|&component_type| {\n             MemberDescription {\n                 name: ~\"\",\n@@ -1300,15 +1308,15 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n         llvm_type: tuple_llvm_type,\n         file_metadata: file_metadata,\n         member_description_factory: TupleMD(TupleMemberDescriptionFactory {\n-            component_types: component_types.to_owned(),\n+            component_types: Vec::from_slice(component_types),\n             span: span,\n         })\n     }\n }\n \n struct GeneralMemberDescriptionFactory {\n     type_rep: @adt::Repr,\n-    variants: @~[@ty::VariantInfo],\n+    variants: @Vec<@ty::VariantInfo> ,\n     discriminant_type_metadata: ValueRef,\n     containing_scope: DIScope,\n     file_metadata: DIFile,\n@@ -1317,7 +1325,7 @@ struct GeneralMemberDescriptionFactory {\n \n impl GeneralMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> ~[MemberDescription] {\n+                                  -> Vec<MemberDescription> {\n         // Capture type_rep, so we don't have to copy the struct_defs array\n         let struct_defs = match *self.type_rep {\n             adt::General(_, ref struct_defs) => struct_defs,\n@@ -1331,7 +1339,7 @@ impl GeneralMemberDescriptionFactory {\n                 let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n                     describe_enum_variant(cx,\n                                           struct_def,\n-                                          self.variants[i],\n+                                          *self.variants.get(i),\n                                           Some(self.discriminant_type_metadata),\n                                           self.containing_scope,\n                                           self.file_metadata,\n@@ -1343,7 +1351,7 @@ impl GeneralMemberDescriptionFactory {\n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n                                               variant_llvm_type,\n-                                              member_descriptions,\n+                                              member_descriptions.as_slice(),\n                                               self.file_metadata,\n                                               codemap::DUMMY_SP);\n                 MemberDescription {\n@@ -1357,14 +1365,14 @@ impl GeneralMemberDescriptionFactory {\n }\n \n struct EnumVariantMemberDescriptionFactory {\n-    args: ~[(~str, ty::t)],\n+    args: Vec<(~str, ty::t)> ,\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n }\n \n impl EnumVariantMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> ~[MemberDescription] {\n+                                  -> Vec<MemberDescription> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n             MemberDescription {\n                 name: name.to_str(),\n@@ -1387,8 +1395,11 @@ fn describe_enum_variant(cx: &CrateContext,\n                          file_metadata: DIFile,\n                          span: Span)\n                       -> (DICompositeType, Type, MemberDescriptionFactory) {\n-    let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n-                                          struct_def.packed);\n+    let variant_llvm_type =\n+        Type::struct_(struct_def.fields\n+                                .map(|&t| type_of::type_of(cx, t))\n+                                .as_slice(),\n+                      struct_def.packed);\n     // Could some consistency checks here: size, align, field count, discr type\n \n     // Find the source code location of the variant's definition\n@@ -1420,7 +1431,7 @@ fn describe_enum_variant(cx: &CrateContext,\n     }\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args: ~[(~str, ty::t)] = arg_names.iter()\n+    let args: Vec<(~str, ty::t)> = arg_names.iter()\n         .zip(struct_def.fields.iter())\n         .map(|(s, &t)| (s.to_str(), t))\n         .collect();\n@@ -1462,7 +1473,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n \n     let variants = ty::enum_variants(cx.tcx, enum_def_id);\n \n-    let enumerators_metadata: ~[DIDescriptor] = variants\n+    let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n         .map(|v| {\n             token::get_ident(v.name).get().with_c_str(|name| {\n@@ -1491,7 +1502,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                     loc.line as c_uint,\n                     bytes_to_bits(discriminant_size),\n                     bytes_to_bits(discriminant_align),\n-                    create_DIArray(DIB(cx), enumerators_metadata),\n+                    create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n                     discriminant_base_type_metadata)\n             }\n         })\n@@ -1507,13 +1518,14 @@ fn prepare_enum_metadata(cx: &CrateContext,\n             assert!(variants.len() == 1);\n             let (metadata_stub,\n                  variant_llvm_type,\n-                 member_description_factory) = describe_enum_variant(cx,\n-                                                                     struct_def,\n-                                                                     variants[0],\n-                                                                     None,\n-                                                                     containing_scope,\n-                                                                     file_metadata,\n-                                                                     span);\n+                 member_description_factory) =\n+                    describe_enum_variant(cx,\n+                                          struct_def,\n+                                          *variants.get(0),\n+                                          None,\n+                                          containing_scope,\n+                                          file_metadata,\n+                                          span);\n             UnfinishedMetadata {\n                 cache_id: cache_id_for_type(enum_type),\n                 metadata_stub: metadata_stub,\n@@ -1565,13 +1577,14 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         adt::NullablePointer { nonnull: ref struct_def, nndiscr, .. } => {\n             let (metadata_stub,\n                  variant_llvm_type,\n-                 member_description_factory) = describe_enum_variant(cx,\n-                                                                     struct_def,\n-                                                                     variants[nndiscr],\n-                                                                     None,\n-                                                                     containing_scope,\n-                                                                     file_metadata,\n-                                                                     span);\n+                 member_description_factory) =\n+                    describe_enum_variant(cx,\n+                                          struct_def,\n+                                          *variants.get(nndiscr as uint),\n+                                          None,\n+                                          containing_scope,\n+                                          file_metadata,\n+                                          span);\n             UnfinishedMetadata {\n                 cache_id: cache_id_for_type(enum_type),\n                 metadata_stub: metadata_stub,\n@@ -1650,7 +1663,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n \n     let loc = span_start(cx, definition_span);\n \n-    let member_metadata: ~[DIDescriptor] = member_descriptions\n+    let member_metadata: Vec<DIDescriptor> = member_descriptions\n         .iter()\n         .enumerate()\n         .map(|(i, member_description)| {\n@@ -1679,7 +1692,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         .collect();\n \n     unsafe {\n-        let type_array = create_DIArray(DIB(cx), member_metadata);\n+        let type_array = create_DIArray(DIB(cx), member_metadata.as_slice());\n         llvm::LLVMDICompositeTypeSetTypeArray(composite_type_metadata, type_array);\n     }\n }\n@@ -1739,7 +1752,9 @@ fn boxed_type_metadata(cx: &CrateContext,\n \n     let box_llvm_type = Type::at_box(cx, content_llvm_type);\n     let member_llvm_types = box_llvm_type.field_types();\n-    assert!(box_layout_is_correct(cx, member_llvm_types, content_llvm_type));\n+    assert!(box_layout_is_correct(cx,\n+                                  member_llvm_types.as_slice(),\n+                                  content_llvm_type));\n \n     let int_type = ty::mk_int();\n     let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n@@ -1748,31 +1763,31 @@ fn boxed_type_metadata(cx: &CrateContext,\n     let member_descriptions = [\n         MemberDescription {\n             name: ~\"refcnt\",\n-            llvm_type: member_llvm_types[0],\n+            llvm_type: *member_llvm_types.get(0),\n             type_metadata: type_metadata(cx, int_type, codemap::DUMMY_SP),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"drop_glue\",\n-            llvm_type: member_llvm_types[1],\n+            llvm_type: *member_llvm_types.get(1),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"prev\",\n-            llvm_type: member_llvm_types[2],\n+            llvm_type: *member_llvm_types.get(2),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"next\",\n-            llvm_type: member_llvm_types[3],\n+            llvm_type: *member_llvm_types.get(3),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"val\",\n-            llvm_type: member_llvm_types[4],\n+            llvm_type: *member_llvm_types.get(4),\n             type_metadata: content_type_metadata,\n             offset: ComputedMemberOffset,\n         }\n@@ -1859,19 +1874,19 @@ fn vec_metadata(cx: &CrateContext,\n     let member_descriptions = [\n         MemberDescription {\n             name: ~\"fill\",\n-            llvm_type: member_llvm_types[0],\n+            llvm_type: *member_llvm_types.get(0),\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"alloc\",\n-            llvm_type: member_llvm_types[1],\n+            llvm_type: *member_llvm_types.get(1),\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"elements\",\n-            llvm_type: member_llvm_types[2],\n+            llvm_type: *member_llvm_types.get(2),\n             type_metadata: array_type_metadata,\n             offset: ComputedMemberOffset,\n         }\n@@ -1904,20 +1919,22 @@ fn vec_slice_metadata(cx: &CrateContext,\n     let slice_type_name = ppaux::ty_to_str(cx.tcx, vec_type);\n \n     let member_llvm_types = slice_llvm_type.field_types();\n-    assert!(slice_layout_is_correct(cx, member_llvm_types, element_type));\n+    assert!(slice_layout_is_correct(cx,\n+                                    member_llvm_types.as_slice(),\n+                                    element_type));\n \n     let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::MutImmutable });\n \n     let member_descriptions = [\n         MemberDescription {\n             name: ~\"data_ptr\",\n-            llvm_type: member_llvm_types[0],\n+            llvm_type: *member_llvm_types.get(0),\n             type_metadata: type_metadata(cx, data_ptr_type, span),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"length\",\n-            llvm_type: member_llvm_types[1],\n+            llvm_type: *member_llvm_types.get(1),\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n             offset: ComputedMemberOffset,\n         },\n@@ -1954,7 +1971,8 @@ fn subroutine_type_metadata(cx: &CrateContext,\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let mut signature_metadata: ~[DIType] = vec::with_capacity(signature.inputs.len() + 1);\n+    let mut signature_metadata: Vec<DIType> =\n+        Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n     signature_metadata.push(match ty::get(signature.output).sty {\n@@ -1971,7 +1989,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n         llvm::LLVMDIBuilderCreateSubroutineType(\n             DIB(cx),\n             file_metadata,\n-            create_DIArray(DIB(cx), signature_metadata))\n+            create_DIArray(DIB(cx), signature_metadata.as_slice()))\n     };\n }\n \n@@ -1993,7 +2011,7 @@ fn trait_metadata(cx: &CrateContext,\n                ident_string.get();\n     // Add type and region parameters\n     let name = ppaux::parameterized(cx.tcx, name, &substs.regions,\n-                                    substs.tps, def_id, true);\n+                                    substs.tps.as_slice(), def_id, true);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n \n@@ -2121,7 +2139,10 @@ fn type_metadata(cx: &CrateContext,\n             }\n         },\n         ty::ty_tup(ref elements) => {\n-            prepare_tuple_metadata(cx, t, *elements, usage_site_span).finalize(cx)\n+            prepare_tuple_metadata(cx,\n+                                   t,\n+                                   elements.as_slice(),\n+                                   usage_site_span).finalize(cx)\n         }\n         _ => cx.sess.bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n     };\n@@ -2265,7 +2286,7 @@ fn populate_scope_map(cx: &CrateContext,\n         ident: Option<ast::Ident>\n     }\n \n-    let mut scope_stack = ~[ScopeStackEntry { scope_metadata: fn_metadata, ident: None }];\n+    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, ident: None });\n \n     // Push argument identifiers onto the stack so arguments integrate nicely with variable\n     // shadowing.\n@@ -2288,10 +2309,10 @@ fn populate_scope_map(cx: &CrateContext,\n     // local helper functions for walking the AST.\n     fn with_new_scope(cx: &CrateContext,\n                       scope_span: Span,\n-                      scope_stack: &mut ~[ScopeStackEntry],\n+                      scope_stack: &mut Vec<ScopeStackEntry> ,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>,\n                       inner_walk: |&CrateContext,\n-                                   &mut ~[ScopeStackEntry],\n+                                   &mut Vec<ScopeStackEntry> ,\n                                    &mut HashMap<ast::NodeId, DIScope>|) {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess.codemap.lookup_char_pos(scope_span.lo);\n@@ -2325,7 +2346,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n     fn walk_block(cx: &CrateContext,\n                   block: &ast::Block,\n-                  scope_stack: &mut ~[ScopeStackEntry],\n+                  scope_stack: &mut Vec<ScopeStackEntry> ,\n                   scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n \n@@ -2349,7 +2370,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n     fn walk_decl(cx: &CrateContext,\n                  decl: &ast::Decl,\n-                 scope_stack: &mut ~[ScopeStackEntry],\n+                 scope_stack: &mut Vec<ScopeStackEntry> ,\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         match *decl {\n             codemap::Spanned { node: ast::DeclLocal(local), .. } => {\n@@ -2367,7 +2388,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n     fn walk_pattern(cx: &CrateContext,\n                     pat: @ast::Pat,\n-                    scope_stack: &mut ~[ScopeStackEntry],\n+                    scope_stack: &mut Vec<ScopeStackEntry> ,\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n         let def_map = cx.tcx.def_map;\n@@ -2512,7 +2533,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n     fn walk_expr(cx: &CrateContext,\n                  exp: &ast::Expr,\n-                 scope_stack: &mut ~[ScopeStackEntry],\n+                 scope_stack: &mut Vec<ScopeStackEntry> ,\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n         scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n@@ -2741,7 +2762,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n         };\n         let mut path = krate.move_iter().chain(path).peekable();\n \n-        let mut current_key = ~[];\n+        let mut current_key = Vec::new();\n         let mut parent_node: Option<@NamespaceTreeNode> = None;\n \n         // Create/Lookup namespace for each element of the path."}, {"sha": "be0faf2b6445d6f38791225912d65d2579570475", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -71,6 +71,7 @@ use middle::trans::machine::llsize_of;\n use middle::trans::type_::Type;\n \n use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::codemap;\n@@ -741,9 +742,9 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprTup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n-            let numbered_fields: ~[(uint, @ast::Expr)] =\n+            let numbered_fields: Vec<(uint, @ast::Expr)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n-            trans_adt(bcx, repr, 0, numbered_fields, None, dest)\n+            trans_adt(bcx, repr, 0, numbered_fields.as_slice(), None, dest)\n         }\n         ast::ExprLit(lit) => {\n             match lit.node {\n@@ -973,7 +974,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n \n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n-            op(0, struct_fields(tcx, did, substs))\n+            op(0, struct_fields(tcx, did, substs).as_slice())\n         }\n \n         ty::ty_enum(_, ref substs) => {\n@@ -995,7 +996,9 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n                             op(variant_info.disr_val,\n-                               struct_fields(tcx, variant_id, substs))\n+                               struct_fields(tcx,\n+                                             variant_id,\n+                                             substs).as_slice())\n                         }\n                         _ => {\n                             tcx.sess.bug(\"resolve didn't map this expr to a \\\n@@ -1047,7 +1050,7 @@ fn trans_rec_or_struct<'a>(\n         });\n         let optbase = match base {\n             Some(base_expr) => {\n-                let mut leftovers = ~[];\n+                let mut leftovers = Vec::new();\n                 for (i, b) in need_base.iter().enumerate() {\n                     if *b {\n                         leftovers.push((i, field_tys[i].mt.ty))\n@@ -1081,8 +1084,7 @@ struct StructBaseInfo {\n     /// The base expression; will be evaluated after all explicit fields.\n     expr: @ast::Expr,\n     /// The indices of fields to copy paired with their types.\n-    fields: ~[(uint, ty::t)]\n-}\n+    fields: Vec<(uint, ty::t)> }\n \n /**\n  * Constructs an ADT instance:\n@@ -1709,7 +1711,7 @@ fn trans_log_level<'a>(bcx: &'a Block<'a>) -> DatumBlock<'a, Expr> {\n                     _ => false\n                 }\n             });\n-            let modpath: ~[ast_map::PathElem] = path.collect();\n+            let modpath: Vec<ast_map::PathElem> = path.collect();\n             let modname = ast_map::path_to_str(ast_map::Values(modpath.iter()));\n             (modpath, modname)\n         })"}, {"sha": "374c85ffa6af105bacb413085b35744abea5422e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -27,6 +27,7 @@ use middle::ty::FnSig;\n use middle::ty;\n use std::cmp;\n use std::libc::c_uint;\n+use std::vec_ng::Vec;\n use syntax::abi::{Cdecl, Aapcs, C, AbiSet, Win64};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall, System};\n use syntax::codemap::Span;\n@@ -56,7 +57,7 @@ struct ForeignTypes {\n \n struct LlvmSignature {\n     // LLVM versions of the types of this function's arguments.\n-    llarg_tys: ~[Type],\n+    llarg_tys: Vec<Type> ,\n \n     // LLVM version of the type that this function returns.  Note that\n     // this *may not be* the declared return type of the foreign\n@@ -163,7 +164,7 @@ pub fn trans_native_call<'a>(\n                          llfn: ValueRef,\n                          llretptr: ValueRef,\n                          llargs_rust: &[ValueRef],\n-                         passed_arg_tys: ~[ty::t])\n+                         passed_arg_tys: Vec<ty::t> )\n                          -> &'a Block<'a> {\n     /*!\n      * Prepares a call to a native function. This requires adapting\n@@ -196,16 +197,16 @@ pub fn trans_native_call<'a>(\n         ty::ty_bare_fn(ref fn_ty) => (fn_ty.abis, fn_ty.sig.clone()),\n         _ => ccx.sess.bug(\"trans_native_call called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys);\n+    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.as_slice());\n     let ret_def = !return_type_is_void(bcx.ccx(), fn_sig.output);\n     let fn_type = cabi::compute_abi_info(ccx,\n-                                         llsig.llarg_tys,\n+                                         llsig.llarg_tys.as_slice(),\n                                          llsig.llret_ty,\n                                          ret_def);\n \n-    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys;\n+    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys.as_slice();\n \n-    let mut llargs_foreign = ~[];\n+    let mut llargs_foreign = Vec::new();\n \n     // If the foreign ABI expects return value by pointer, supply the\n     // pointer that Rust gave us. Sometimes we have to bitcast\n@@ -228,7 +229,8 @@ pub fn trans_native_call<'a>(\n         let mut llarg_rust = llarg_rust;\n \n         // Does Rust pass this argument by pointer?\n-        let rust_indirect = type_of::arg_is_indirect(ccx, passed_arg_tys[i]);\n+        let rust_indirect = type_of::arg_is_indirect(ccx,\n+                                                     *passed_arg_tys.get(i));\n \n         debug!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n                i,\n@@ -239,7 +241,10 @@ pub fn trans_native_call<'a>(\n         // Ensure that we always have the Rust value indirectly,\n         // because it makes bitcasting easier.\n         if !rust_indirect {\n-            let scratch = base::alloca(bcx, type_of::type_of(ccx, passed_arg_tys[i]), \"__arg\");\n+            let scratch =\n+                base::alloca(bcx,\n+                             type_of::type_of(ccx, *passed_arg_tys.get(i)),\n+                             \"__arg\");\n             Store(bcx, llarg_rust, scratch);\n             llarg_rust = scratch;\n         }\n@@ -295,7 +300,11 @@ pub fn trans_native_call<'a>(\n         None\n     };\n     let attrs = sret_attr.as_slice();\n-    let llforeign_retval = CallWithConv(bcx, llfn, llargs_foreign, cc, attrs);\n+    let llforeign_retval = CallWithConv(bcx,\n+                                        llfn,\n+                                        llargs_foreign.as_slice(),\n+                                        cc,\n+                                        attrs);\n \n     // If the function we just called does not use an outpointer,\n     // store the result into the rust outpointer. Cast the outpointer\n@@ -466,7 +475,11 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                ccx.tcx.map.path_to_str(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx, false, f.sig.inputs, f.sig.output, ps);\n+        let llfn = base::decl_internal_rust_fn(ccx,\n+                                               false,\n+                                               f.sig.inputs.as_slice(),\n+                                               f.sig.output,\n+                                               ps);\n         base::set_llvm_fn_attrs(attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, None, id, []);\n         llfn\n@@ -503,7 +516,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n         llvm::LLVMPositionBuilderAtEnd(builder, the_block);\n \n         // Array for the arguments we will pass to the rust function.\n-        let mut llrust_args = ~[];\n+        let mut llrust_args = Vec::new();\n         let mut next_foreign_arg_counter: c_uint = 0;\n         let next_foreign_arg: |pad: bool| -> c_uint = |pad: bool| {\n             next_foreign_arg_counter += if pad {\n@@ -579,10 +592,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa.\n         for i in range(0, tys.fn_sig.inputs.len()) {\n-            let rust_ty = tys.fn_sig.inputs[i];\n-            let llrust_ty = tys.llsig.llarg_tys[i];\n+            let rust_ty = *tys.fn_sig.inputs.get(i);\n+            let llrust_ty = *tys.llsig.llarg_tys.get(i);\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n-            let llforeign_arg_ty = tys.fn_ty.arg_tys[i];\n+            let llforeign_arg_ty = *tys.fn_ty.arg_tys.get(i);\n             let foreign_indirect = llforeign_arg_ty.is_indirect();\n \n             // skip padding\n@@ -730,7 +743,7 @@ fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n      * values by pointer like we do.\n      */\n \n-    let llarg_tys = arg_tys.map(|&arg| type_of(ccx, arg));\n+    let llarg_tys = arg_tys.iter().map(|&arg| type_of(ccx, arg)).collect();\n     let llret_ty = type_of::type_of(ccx, fn_sig.output);\n     LlvmSignature {\n         llarg_tys: llarg_tys,\n@@ -750,10 +763,10 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess.bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs);\n+    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n     let ret_def = !return_type_is_void(ccx, fn_sig.output);\n     let fn_ty = cabi::compute_abi_info(ccx,\n-                                       llsig.llarg_tys,\n+                                       llsig.llarg_tys.as_slice(),\n                                        llsig.llret_ty,\n                                        ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n@@ -762,9 +775,9 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n            ty.repr(ccx.tcx),\n-           ccx.tn.types_to_str(llsig.llarg_tys),\n+           ccx.tn.types_to_str(llsig.llarg_tys.as_slice()),\n            ccx.tn.type_to_str(llsig.llret_ty),\n-           ccx.tn.types_to_str(fn_ty.arg_tys.map(|t| t.ty)),\n+           ccx.tn.types_to_str(fn_ty.arg_tys.map(|t| t.ty).as_slice()),\n            ccx.tn.type_to_str(fn_ty.ret_ty.ty),\n            ret_def);\n \n@@ -777,7 +790,7 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n }\n \n fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n-    let mut llargument_tys = ~[];\n+    let mut llargument_tys = Vec::new();\n \n     let ret_ty = tys.fn_ty.ret_ty;\n     let llreturn_ty = if ret_ty.is_indirect() {\n@@ -810,9 +823,9 @@ fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n     }\n \n     if tys.fn_sig.variadic {\n-        Type::variadic_func(llargument_tys, &llreturn_ty)\n+        Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n     } else {\n-        Type::func(llargument_tys, &llreturn_ty)\n+        Type::func(llargument_tys.as_slice(), &llreturn_ty)\n     }\n }\n "}, {"sha": "6d4737eeff12dc74ee6cd3acbd4c0eb5c82e16a7", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -245,7 +245,7 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n \n     // Find and call the actual destructor\n     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did,\n-                                 class_did, substs.tps.clone());\n+                                 class_did, substs.tps.as_slice());\n \n     // The second argument is the \"self\" argument for drop\n     let params = unsafe {\n@@ -262,8 +262,8 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n     // destructors if the user destructor fails.\n     let field_scope = bcx.fcx.push_custom_cleanup_scope();\n \n-    let self_arg = PointerCast(bcx, v0, params[0]);\n-    let args = ~[self_arg];\n+    let self_arg = PointerCast(bcx, v0, *params.get(0));\n+    let args = vec!(self_arg);\n \n     // Add all the fields as a value which needs to be cleaned at the end of\n     // this scope."}, {"sha": "1a5d794c1a45405067e2dfe1485e330daacaadf5", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -25,6 +25,7 @@ use middle::trans::machine;\n use middle::trans::machine::llsize_of;\n use middle::trans::type_::Type;\n use middle::ty;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::parse::token;\n@@ -207,12 +208,12 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n     // This requires that atomic intrinsics follow a specific naming pattern:\n     // \"atomic_<operation>[_<ordering>], and no ordering means SeqCst\n     if name.get().starts_with(\"atomic_\") {\n-        let split: ~[&str] = name.get().split('_').collect();\n+        let split: Vec<&str> = name.get().split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n         let order = if split.len() == 2 {\n             lib::llvm::SequentiallyConsistent\n         } else {\n-            match split[2] {\n+            match *split.get(2) {\n                 \"relaxed\" => lib::llvm::Monotonic,\n                 \"acq\"     => lib::llvm::Acquire,\n                 \"rel\"     => lib::llvm::Release,\n@@ -221,7 +222,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             }\n         };\n \n-        match split[1] {\n+        match *split.get(1) {\n             \"cxchg\" => {\n                 let old = AtomicCmpXchg(bcx, get_param(decl, first_real_arg),\n                                         get_param(decl, first_real_arg + 1u),\n@@ -284,7 +285,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             RetVoid(bcx);\n         }\n         \"size_of\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty) as uint));\n         }\n@@ -294,7 +295,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             // if the value is non-immediate. Note that, with\n             // intrinsics, there are no argument cleanups to\n             // concern ourselves with, so we can use an rvalue datum.\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let mode = appropriate_rvalue_mode(ccx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty,\n@@ -303,17 +304,17 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             RetVoid(bcx);\n         }\n         \"min_align_of\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty) as uint));\n         }\n         \"pref_align_of\"=> {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty) as uint));\n         }\n         \"get_tydesc\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let static_ti = get_tydesc(ccx, tp_ty);\n             glue::lazily_emit_visit_glue(ccx, static_ti);\n \n@@ -328,7 +329,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         \"type_id\" => {\n             let hash = ty::hash_crate_independent(\n                 ccx.tcx,\n-                substs.tys[0],\n+                *substs.tys.get(0),\n                 &ccx.link_meta.crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n@@ -342,7 +343,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             }\n         }\n         \"init\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             match bcx.fcx.llretptr.get() {\n                 Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n@@ -352,7 +353,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         }\n         \"uninit\" => {\n             // Do nothing, this is effectively a no-op\n-            let retty = substs.tys[0];\n+            let retty = *substs.tys.get(0);\n             if type_is_immediate(ccx, retty) && !return_type_is_void(ccx, retty) {\n                 unsafe {\n                     Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n@@ -365,7 +366,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             RetVoid(bcx);\n         }\n         \"transmute\" => {\n-            let (in_type, out_type) = (substs.tys[0], substs.tys[1]);\n+            let (in_type, out_type) = (*substs.tys.get(0), *substs.tys.get(1));\n             let llintype = type_of::type_of(ccx, in_type);\n             let llouttype = type_of::type_of(ccx, out_type);\n \n@@ -432,11 +433,11 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             }\n         }\n         \"needs_drop\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             Ret(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)));\n         }\n         \"owns_managed\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).owns_managed()));\n         }\n         \"visit_tydesc\" => {\n@@ -452,9 +453,11 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let lladdr = InBoundsGEP(bcx, ptr, [offset]);\n             Ret(bcx, lladdr);\n         }\n-        \"copy_nonoverlapping_memory\" => copy_intrinsic(bcx, false, substs.tys[0]),\n-        \"copy_memory\" => copy_intrinsic(bcx, true, substs.tys[0]),\n-        \"set_memory\" => memset_intrinsic(bcx, substs.tys[0]),\n+        \"copy_nonoverlapping_memory\" => {\n+            copy_intrinsic(bcx, false, *substs.tys.get(0))\n+        }\n+        \"copy_memory\" => copy_intrinsic(bcx, true, *substs.tys.get(0)),\n+        \"set_memory\" => memset_intrinsic(bcx, *substs.tys.get(0)),\n         \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n         \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),\n         \"ctlz32\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\"),"}, {"sha": "cfc88d163c0b05d240cd9ac158dd75b00e9806c1", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -25,16 +25,16 @@ use middle::trans::expr::{SaveIn, Ignore};\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::monomorphize;\n+use middle::trans::type_::Type;\n use middle::trans::type_of::*;\n use middle::ty;\n use middle::typeck;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n-use middle::trans::type_::Type;\n-\n use std::c_str::ToCStr;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::parse::token;\n use syntax::{ast, ast_map, visit};\n \n@@ -202,18 +202,21 @@ pub fn trans_static_method_callee(bcx: &Block,\n     let vtbls = ccx.maps.vtable_map.borrow().get().get_copy(&expr_id);\n     let vtbls = resolve_vtables_in_fn_ctxt(bcx.fcx, vtbls);\n \n-    match vtbls[bound_index][0] {\n-        typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n+    match vtbls.get(bound_index).get(0) {\n+        &typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n                     bcx, mth_id, expr_id, false,\n-                    *rcvr_substs, rcvr_origins);\n+                    rcvr_substs.as_slice(), rcvr_origins);\n \n-            let llfn = trans_fn_ref_with_vtables(bcx, mth_id, expr_id,\n-                                                 false, callee_substs,\n+            let llfn = trans_fn_ref_with_vtables(bcx,\n+                                                 mth_id,\n+                                                 expr_id,\n+                                                 false,\n+                                                 callee_substs.as_slice(),\n                                                  Some(callee_origins));\n \n             let callee_ty = node_id_type(bcx, expr_id);\n@@ -268,14 +271,14 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n           let (callee_substs, callee_origins) =\n               combine_impl_and_methods_tps(\n                   bcx, mth_id, expr_id, true,\n-                  *rcvr_substs, rcvr_origins);\n+                  rcvr_substs.as_slice(), rcvr_origins);\n \n           // translate the function\n           let llfn = trans_fn_ref_with_vtables(bcx,\n                                                mth_id,\n                                                expr_id,\n                                                true,\n-                                               callee_substs,\n+                                               callee_substs.as_slice(),\n                                                Some(callee_origins));\n \n           Callee { bcx: bcx, data: Fn(llfn) }\n@@ -292,7 +295,7 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n                                 is_method: bool,\n                                 rcvr_substs: &[ty::t],\n                                 rcvr_origins: typeck::vtable_res)\n-                                -> (~[ty::t], typeck::vtable_res) {\n+                                -> (Vec<ty::t> , typeck::vtable_res) {\n     /*!\n     *\n     * Creates a concatenated set of substitutions which includes\n@@ -316,8 +319,8 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     let node_substs = node_id_type_params(bcx, expr_id, is_method);\n     debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs\n-        = vec::append(rcvr_substs.to_owned(),\n-                      node_substs.tailn(node_substs.len() - n_m_tps));\n+        = vec_ng::append(Vec::from_slice(rcvr_substs),\n+                         node_substs.tailn(node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps={:?}\", n_m_tps);\n     debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx));\n     debug!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx));\n@@ -327,11 +330,11 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     // exist, in which case we need to make them.\n     let r_m_origins = match node_vtables(bcx, expr_id) {\n         Some(vt) => vt,\n-        None => @vec::from_elem(node_substs.len(), @~[])\n+        None => @Vec::from_elem(node_substs.len(), @Vec::new())\n     };\n     let vtables\n-        = @vec::append(rcvr_origins.to_owned(),\n-                       r_m_origins.tailn(r_m_origins.len() - n_m_tps));\n+        = @vec_ng::append(Vec::from_slice(rcvr_origins.as_slice()),\n+                          r_m_origins.tailn(r_m_origins.len() - n_m_tps));\n \n     (ty_substs, vtables)\n }\n@@ -460,7 +463,7 @@ pub fn get_vtable(bcx: &Block,\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n     // Check the cache.\n-    let hash_id = (self_ty, vtable_id(ccx, &origins[0]));\n+    let hash_id = (self_ty, vtable_id(ccx, origins.get(0)));\n     {\n         let vtables = ccx.vtables.borrow();\n         match vtables.get().find(&hash_id) {\n@@ -470,18 +473,25 @@ pub fn get_vtable(bcx: &Block,\n     }\n \n     // Not in the cache. Actually build it.\n-    let methods = origins.flat_map(|origin| {\n+    let mut methods = Vec::new();\n+    for origin in origins.iter() {\n         match *origin {\n             typeck::vtable_static(id, ref substs, sub_vtables) => {\n-                emit_vtable_methods(bcx, id, *substs, sub_vtables)\n+                let vtable_methods = emit_vtable_methods(bcx,\n+                                                         id,\n+                                                         substs.as_slice(),\n+                                                         sub_vtables);\n+                for vtable_method in vtable_methods.move_iter() {\n+                    methods.push(vtable_method)\n+                }\n             }\n             _ => ccx.sess.bug(\"get_vtable: expected a static origin\"),\n         }\n-    });\n+    }\n \n     // Generate a destructor for the vtable.\n     let drop_glue = glue::get_drop_glue(ccx, self_ty);\n-    let vtable = make_vtable(ccx, drop_glue, methods);\n+    let vtable = make_vtable(ccx, drop_glue, methods.as_slice());\n \n     let mut vtables = ccx.vtables.borrow_mut();\n     vtables.get().insert(hash_id, vtable);\n@@ -496,12 +506,12 @@ pub fn make_vtable(ccx: &CrateContext,\n     unsafe {\n         let _icx = push_ctxt(\"meth::make_vtable\");\n \n-        let mut components = ~[drop_glue];\n+        let mut components = vec!(drop_glue);\n         for &ptr in ptrs.iter() {\n             components.push(ptr)\n         }\n \n-        let tbl = C_struct(components, false);\n+        let tbl = C_struct(components.as_slice(), false);\n         let sym = token::gensym(\"vtable\");\n         let vt_gvar = format!(\"vtable{}\", sym).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n@@ -517,7 +527,7 @@ fn emit_vtable_methods(bcx: &Block,\n                        impl_id: ast::DefId,\n                        substs: &[ty::t],\n                        vtables: typeck::vtable_res)\n-                       -> ~[ValueRef] {\n+                       -> Vec<ValueRef> {\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n@@ -589,7 +599,7 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n             *vtable_map.get().get(&id)\n         };\n         let res = resolve_vtables_in_fn_ctxt(bcx.fcx, res);\n-        res[0]\n+        *res.get(0)\n     };\n     let vtable = get_vtable(bcx, v_ty, origins);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);"}, {"sha": "ecfc1aae3d99bb2b270f36fbd6ab163060f406e0", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -23,6 +23,7 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n \n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n@@ -51,7 +52,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let mut must_cast = false;\n \n     let psubsts = @param_substs {\n-        tys: real_substs.tps.to_owned(),\n+        tys: real_substs.tps.clone(),\n         vtables: vtables,\n         self_ty: real_substs.self_ty.clone(),\n         self_vtables: self_vtables\n@@ -124,7 +125,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx));\n     let mono_ty = match is_static_provided {\n-        None => ty::subst_tps(ccx.tcx, psubsts.tys,\n+        None => ty::subst_tps(ccx.tcx, psubsts.tys.as_slice(),\n                               psubsts.self_ty, llitem_ty),\n         Some(num_method_ty_params) => {\n             // Static default methods are a little unfortunate, in\n@@ -186,7 +187,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n \n     let mk_lldecl = || {\n         let lldecl = decl_internal_rust_fn(ccx, false,\n-                                           f.sig.inputs,\n+                                           f.sig.inputs.as_slice(),\n                                            f.sig.output, s);\n         let mut monomorphized = ccx.monomorphized.borrow_mut();\n         monomorphized.get().insert(hash_id, lldecl);\n@@ -299,7 +300,7 @@ pub fn make_mono_id(ccx: @CrateContext,\n     // FIXME (possibly #5801): Need a lot of type hints to get\n     // .collect() to work.\n     let substs_iter = substs.self_ty.iter().chain(substs.tys.iter());\n-    let precise_param_ids: ~[(ty::t, Option<@~[mono_id]>)] = match substs.vtables {\n+    let precise_param_ids: Vec<(ty::t, Option<@Vec<mono_id> >)> = match substs.vtables {\n       Some(vts) => {\n         debug!(\"make_mono_id vtables={} substs={}\",\n                vts.repr(ccx.tcx), substs.tys.repr(ccx.tcx));\n@@ -309,7 +310,7 @@ pub fn make_mono_id(ccx: @CrateContext,\n             (*subst, if !v.is_empty() { Some(@v) } else { None })\n         }).collect()\n       }\n-      None => substs_iter.map(|subst| (*subst, None::<@~[mono_id]>)).collect()\n+      None => substs_iter.map(|subst| (*subst, None::<@Vec<mono_id> >)).collect()\n     };\n \n "}, {"sha": "6c87ae94ba4b3e12c8f1d5771699e50e87f3c49a", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 71, "deletions": 64, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -28,7 +28,8 @@ use util::ppaux::ty_to_str;\n use arena::TypedArena;\n use std::libc::c_uint;\n use std::option::{Some,None};\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast::DefId;\n use syntax::ast;\n use syntax::ast_map;\n@@ -37,7 +38,7 @@ use syntax::parse::token;\n \n pub struct Reflector<'a> {\n     visitor_val: ValueRef,\n-    visitor_methods: @~[@ty::Method],\n+    visitor_methods: @Vec<@ty::Method> ,\n     final_bcx: &'a Block<'a>,\n     tydesc_ty: Type,\n     bcx: &'a Block<'a>\n@@ -70,12 +71,12 @@ impl<'a> Reflector<'a> {\n         scratch.val\n     }\n \n-    pub fn c_size_and_align(&mut self, t: ty::t) -> ~[ValueRef] {\n+    pub fn c_size_and_align(&mut self, t: ty::t) -> Vec<ValueRef> {\n         let tr = type_of(self.bcx.ccx(), t);\n         let s = machine::llsize_of_real(self.bcx.ccx(), tr);\n         let a = machine::llalign_of_min(self.bcx.ccx(), tr);\n-        return ~[self.c_uint(s as uint),\n-             self.c_uint(a as uint)];\n+        return vec!(self.c_uint(s as uint),\n+             self.c_uint(a as uint));\n     }\n \n     pub fn c_tydesc(&mut self, t: ty::t) -> ValueRef {\n@@ -85,20 +86,20 @@ impl<'a> Reflector<'a> {\n         PointerCast(bcx, static_ti.tydesc, self.tydesc_ty.ptr_to())\n     }\n \n-    pub fn c_mt(&mut self, mt: &ty::mt) -> ~[ValueRef] {\n-        ~[self.c_uint(mt.mutbl as uint),\n-          self.c_tydesc(mt.ty)]\n+    pub fn c_mt(&mut self, mt: &ty::mt) -> Vec<ValueRef> {\n+        vec!(self.c_uint(mt.mutbl as uint),\n+          self.c_tydesc(mt.ty))\n     }\n \n     pub fn visit(&mut self, ty_name: &str, args: &[ValueRef]) {\n         let fcx = self.bcx.fcx;\n         let tcx = self.bcx.tcx();\n-        let mth_idx = ty::method_idx(\n-            token::str_to_ident(~\"visit_\" + ty_name),\n-            *self.visitor_methods).expect(format!(\"couldn't find visit method \\\n-                                                for {}\", ty_name));\n+        let mth_idx = ty::method_idx(token::str_to_ident(~\"visit_\" + ty_name),\n+                                     self.visitor_methods.as_slice()).expect(\n+                format!(\"couldn't find visit method for {}\", ty_name));\n         let mth_ty =\n-            ty::mk_bare_fn(tcx, self.visitor_methods[mth_idx].fty.clone());\n+            ty::mk_bare_fn(tcx,\n+                           self.visitor_methods.get(mth_idx).fty.clone());\n         let v = self.visitor_val;\n         debug!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n@@ -130,15 +131,16 @@ impl<'a> Reflector<'a> {\n     pub fn vstore_name_and_extra(&mut self,\n                                  t: ty::t,\n                                  vstore: ty::vstore)\n-                                 -> (~str, ~[ValueRef]) {\n+                                 -> (~str, Vec<ValueRef> ) {\n         match vstore {\n             ty::vstore_fixed(n) => {\n-                let extra = vec::append(~[self.c_uint(n)],\n-                                        self.c_size_and_align(t));\n+                let extra = vec_ng::append(vec!(self.c_uint(n)),\n+                                           self.c_size_and_align(t)\n+                                               .as_slice());\n                 (~\"fixed\", extra)\n             }\n-            ty::vstore_slice(_) => (~\"slice\", ~[]),\n-            ty::vstore_uniq => (~\"uniq\", ~[]),\n+            ty::vstore_slice(_) => (~\"slice\", Vec::new()),\n+            ty::vstore_uniq => (~\"uniq\", Vec::new()),\n         }\n     }\n \n@@ -172,50 +174,50 @@ impl<'a> Reflector<'a> {\n \n           ty::ty_unboxed_vec(ref mt) => {\n               let values = self.c_mt(mt);\n-              self.visit(\"vec\", values)\n+              self.visit(\"vec\", values.as_slice())\n           }\n \n           // Should rename to str_*/vec_*.\n           ty::ty_str(vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n-              self.visit(~\"estr_\" + name, extra)\n+              self.visit(~\"estr_\" + name, extra.as_slice())\n           }\n           ty::ty_vec(ref mt, vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n-              let extra = extra + self.c_mt(mt);\n-              self.visit(~\"evec_\" + name, extra)\n+              let extra = vec_ng::append(extra, self.c_mt(mt).as_slice());\n+              self.visit(~\"evec_\" + name, extra.as_slice())\n           }\n           // Should remove mt from box and uniq.\n           ty::ty_box(typ) => {\n               let extra = self.c_mt(&ty::mt {\n                   ty: typ,\n                   mutbl: ast::MutImmutable,\n               });\n-              self.visit(\"box\", extra)\n+              self.visit(\"box\", extra.as_slice())\n           }\n           ty::ty_uniq(typ) => {\n               let extra = self.c_mt(&ty::mt {\n                   ty: typ,\n                   mutbl: ast::MutImmutable,\n               });\n-              self.visit(\"uniq\", extra)\n+              self.visit(\"uniq\", extra.as_slice())\n           }\n           ty::ty_ptr(ref mt) => {\n               let extra = self.c_mt(mt);\n-              self.visit(\"ptr\", extra)\n+              self.visit(\"ptr\", extra.as_slice())\n           }\n           ty::ty_rptr(_, ref mt) => {\n               let extra = self.c_mt(mt);\n-              self.visit(\"rptr\", extra)\n+              self.visit(\"rptr\", extra.as_slice())\n           }\n \n           ty::ty_tup(ref tys) => {\n-              let extra = ~[self.c_uint(tys.len())]\n-                  + self.c_size_and_align(t);\n-              self.bracketed(\"tup\", extra, |this| {\n+              let extra = vec_ng::append(vec!(self.c_uint(tys.len())),\n+                                         self.c_size_and_align(t).as_slice());\n+              self.bracketed(\"tup\", extra.as_slice(), |this| {\n                   for (i, t) in tys.iter().enumerate() {\n-                      let extra = ~[this.c_uint(i), this.c_tydesc(*t)];\n-                      this.visit(\"tup_field\", extra);\n+                      let extra = vec!(this.c_uint(i), this.c_tydesc(*t));\n+                      this.visit(\"tup_field\", extra.as_slice());\n                   }\n               })\n           }\n@@ -226,13 +228,13 @@ impl<'a> Reflector<'a> {\n             let pureval = ast_purity_constant(fty.purity);\n             let sigilval = ast_sigil_constant(fty.sigil);\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n-            let extra = ~[self.c_uint(pureval),\n+            let extra = vec!(self.c_uint(pureval),\n                           self.c_uint(sigilval),\n                           self.c_uint(fty.sig.inputs.len()),\n-                          self.c_uint(retval)];\n-            self.visit(\"enter_fn\", extra);\n+                          self.c_uint(retval));\n+            self.visit(\"enter_fn\", extra.as_slice());\n             self.visit_sig(retval, &fty.sig);\n-            self.visit(\"leave_fn\", extra);\n+            self.visit(\"leave_fn\", extra.as_slice());\n           }\n \n           // FIXME (#2594): fetch constants out of intrinsic:: for the\n@@ -241,37 +243,37 @@ impl<'a> Reflector<'a> {\n             let pureval = ast_purity_constant(fty.purity);\n             let sigilval = 0u;\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n-            let extra = ~[self.c_uint(pureval),\n+            let extra = vec!(self.c_uint(pureval),\n                           self.c_uint(sigilval),\n                           self.c_uint(fty.sig.inputs.len()),\n-                          self.c_uint(retval)];\n-            self.visit(\"enter_fn\", extra);\n+                          self.c_uint(retval));\n+            self.visit(\"enter_fn\", extra.as_slice());\n             self.visit_sig(retval, &fty.sig);\n-            self.visit(\"leave_fn\", extra);\n+            self.visit(\"leave_fn\", extra.as_slice());\n           }\n \n           ty::ty_struct(did, ref substs) => {\n               let fields = ty::struct_fields(tcx, did, substs);\n               let mut named_fields = false;\n               if !fields.is_empty() {\n-                  named_fields =\n-                        fields[0].ident.name != special_idents::unnamed_field.name;\n+                  named_fields = fields.get(0).ident.name !=\n+                      special_idents::unnamed_field.name;\n               }\n \n-              let extra = ~[\n+              let extra = vec_ng::append(vec!(\n                   self.c_slice(token::intern_and_get_ident(ty_to_str(tcx,\n                                                                      t))),\n                   self.c_bool(named_fields),\n                   self.c_uint(fields.len())\n-              ] + self.c_size_and_align(t);\n-              self.bracketed(\"class\", extra, |this| {\n+              ), self.c_size_and_align(t).as_slice());\n+              self.bracketed(\"class\", extra.as_slice(), |this| {\n                   for (i, field) in fields.iter().enumerate() {\n-                      let extra = ~[\n+                      let extra = vec_ng::append(vec!(\n                         this.c_uint(i),\n                         this.c_slice(token::get_ident(field.ident)),\n                         this.c_bool(named_fields)\n-                      ] + this.c_mt(&field.mt);\n-                      this.visit(\"class_field\", extra);\n+                      ), this.c_mt(&field.mt).as_slice());\n+                      this.visit(\"class_field\", extra.as_slice());\n                   }\n               })\n           }\n@@ -319,25 +321,30 @@ impl<'a> Reflector<'a> {\n                 llfdecl\n             };\n \n-            let enum_args = ~[self.c_uint(variants.len()), make_get_disr()]\n-                + self.c_size_and_align(t);\n-            self.bracketed(\"enum\", enum_args, |this| {\n+            let enum_args = vec_ng::append(vec!(self.c_uint(variants.len()),\n+                                                make_get_disr()),\n+                                           self.c_size_and_align(t)\n+                                               .as_slice());\n+            self.bracketed(\"enum\", enum_args.as_slice(), |this| {\n                 for (i, v) in variants.iter().enumerate() {\n                     let name = token::get_ident(v.name);\n-                    let variant_args = ~[this.c_uint(i),\n+                    let variant_args = vec!(this.c_uint(i),\n                                          C_u64(v.disr_val),\n                                          this.c_uint(v.args.len()),\n-                                         this.c_slice(name)];\n-                    this.bracketed(\"enum_variant\", variant_args, |this| {\n+                                         this.c_slice(name));\n+                    this.bracketed(\"enum_variant\",\n+                                   variant_args.as_slice(),\n+                                   |this| {\n                         for (j, a) in v.args.iter().enumerate() {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n                             let ptr = adt::trans_field_ptr(bcx, repr, null, v.disr_val, j);\n                             let offset = p2i(ccx, ptr);\n-                            let field_args = ~[this.c_uint(j),\n+                            let field_args = vec!(this.c_uint(j),\n                                                offset,\n-                                               this.c_tydesc(*a)];\n-                            this.visit(\"enum_variant_field\", field_args);\n+                                               this.c_tydesc(*a));\n+                            this.visit(\"enum_variant_field\",\n+                                       field_args.as_slice());\n                         }\n                     })\n                 }\n@@ -355,8 +362,8 @@ impl<'a> Reflector<'a> {\n           ty::ty_infer(_) => self.leaf(\"infer\"),\n           ty::ty_err => self.leaf(\"err\"),\n           ty::ty_param(ref p) => {\n-              let extra = ~[self.c_uint(p.idx)];\n-              self.visit(\"param\", extra)\n+              let extra = vec!(self.c_uint(p.idx));\n+              self.visit(\"param\", extra.as_slice())\n           }\n           ty::ty_self(..) => self.leaf(\"self\")\n         }\n@@ -365,15 +372,15 @@ impl<'a> Reflector<'a> {\n     pub fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig) {\n         for (i, arg) in sig.inputs.iter().enumerate() {\n             let modeval = 5u;   // \"by copy\"\n-            let extra = ~[self.c_uint(i),\n+            let extra = vec!(self.c_uint(i),\n                          self.c_uint(modeval),\n-                         self.c_tydesc(*arg)];\n-            self.visit(\"fn_input\", extra);\n+                         self.c_tydesc(*arg));\n+            self.visit(\"fn_input\", extra.as_slice());\n         }\n-        let extra = ~[self.c_uint(retval),\n+        let extra = vec!(self.c_uint(retval),\n                       self.c_bool(sig.variadic),\n-                      self.c_tydesc(sig.output)];\n-        self.visit(\"fn_output\", extra);\n+                      self.c_tydesc(sig.output));\n+        self.visit(\"fn_output\", extra.as_slice());\n     }\n }\n "}, {"sha": "3127231259d85a09268073a71efb1d4b69b446e1", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -20,8 +20,9 @@ use syntax::ast;\n use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n \n use std::c_str::ToCStr;\n-use std::vec;\n use std::cast;\n+use std::vec;\n+use std::vec_ng::Vec;\n \n use std::libc::{c_uint};\n \n@@ -295,14 +296,14 @@ impl Type {\n         }\n     }\n \n-    pub fn field_types(&self) -> ~[Type] {\n+    pub fn field_types(&self) -> Vec<Type> {\n         unsafe {\n             let n_elts = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n             if n_elts == 0 {\n-                return ~[];\n+                return Vec::new();\n             }\n-            let mut elts = vec::from_elem(n_elts, 0 as TypeRef);\n-            llvm::LLVMGetStructElementTypes(self.to_ref(), &mut elts[0]);\n+            let mut elts = Vec::from_elem(n_elts, 0 as TypeRef);\n+            llvm::LLVMGetStructElementTypes(self.to_ref(), elts.get_mut(0));\n             cast::transmute(elts)\n         }\n     }\n@@ -311,10 +312,10 @@ impl Type {\n         ty!(llvm::LLVMGetReturnType(self.to_ref()))\n     }\n \n-    pub fn func_params(&self) -> ~[Type] {\n+    pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n-            let args = vec::from_elem(n_args, 0 as TypeRef);\n+            let args = Vec::from_elem(n_args, 0 as TypeRef);\n             llvm::LLVMGetParamTypes(self.to_ref(), args.as_ptr());\n             cast::transmute(args)\n         }"}, {"sha": "de3aff0fff61358599d8ef0b0a3ee096bd0c45d9", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -19,6 +19,7 @@ use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::opt_vec;\n \n@@ -41,7 +42,7 @@ pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: ty::t) -> Type {\n \n pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n                        inputs: &[ty::t], output: ty::t) -> Type {\n-    let mut atys: ~[Type] = ~[];\n+    let mut atys: Vec<Type> = Vec::new();\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n@@ -62,21 +63,24 @@ pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n \n     // Use the output as the actual return value if it's immediate.\n     if use_out_pointer || return_type_is_void(cx, output) {\n-        Type::func(atys, &Type::void())\n+        Type::func(atys.as_slice(), &Type::void())\n     } else {\n-        Type::func(atys, &lloutputtype)\n+        Type::func(atys.as_slice(), &lloutputtype)\n     }\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n     match ty::get(fty).sty {\n         ty::ty_closure(ref f) => {\n-            type_of_rust_fn(cx, true, f.sig.inputs, f.sig.output)\n+            type_of_rust_fn(cx, true, f.sig.inputs.as_slice(), f.sig.output)\n         }\n         ty::ty_bare_fn(ref f) => {\n             if f.abis.is_rust() || f.abis.is_intrinsic() {\n-                type_of_rust_fn(cx, false, f.sig.inputs, f.sig.output)\n+                type_of_rust_fn(cx,\n+                                false,\n+                                f.sig.inputs.as_slice(),\n+                                f.sig.output)\n             } else {\n                 foreign::lltype_for_foreign_fn(cx, fty)\n             }\n@@ -216,7 +220,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         // avoids creating more than one copy of the enum when one\n         // of the enum's variants refers to the enum itself.\n         let repr = adt::represent_type(cx, t);\n-        let name = llvm_type_name(cx, an_enum, did, substs.tps);\n+        let name = llvm_type_name(cx, an_enum, did, substs.tps.as_slice());\n         adt::incomplete_type_of(cx, repr, name)\n       }\n       ty::ty_box(typ) => {\n@@ -277,7 +281,10 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               // in *after* placing it into the type cache. This prevents\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n-              let name = llvm_type_name(cx, a_struct, did, substs.tps);\n+              let name = llvm_type_name(cx,\n+                                        a_struct,\n+                                        did,\n+                                        substs.tps.as_slice());\n               adt::incomplete_type_of(cx, repr, name)\n           }\n       }"}, {"sha": "4d0f6704379d553a8bda75756846182200333493", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 100, "deletions": 87, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -40,7 +40,8 @@ use std::fmt;\n use std::hash::{Hash, sip};\n use std::ops;\n use std::rc::Rc;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use collections::{HashMap, HashSet};\n use syntax::ast::*;\n use syntax::ast_util::{is_local, lit_is_str};\n@@ -122,8 +123,7 @@ impl Method {\n pub struct Impl {\n     did: DefId,\n     ident: Ident,\n-    methods: ~[@Method]\n-}\n+    methods: Vec<@Method> }\n \n #[deriving(Clone, Eq, Hash)]\n pub struct mt {\n@@ -280,16 +280,16 @@ pub struct ctxt_ {\n     // of this node.  This only applies to nodes that refer to entities\n     // parameterized by type parameters, such as generic fns, types, or\n     // other items.\n-    node_type_substs: RefCell<NodeMap<~[t]>>,\n+    node_type_substs: RefCell<NodeMap<Vec<t>>>,\n \n     // Maps from a method to the method \"descriptor\"\n     methods: RefCell<DefIdMap<@Method>>,\n \n     // Maps from a trait def-id to a list of the def-ids of its methods\n-    trait_method_def_ids: RefCell<DefIdMap<@~[DefId]>>,\n+    trait_method_def_ids: RefCell<DefIdMap<@Vec<DefId> >>,\n \n     // A cache for the trait_methods() routine\n-    trait_methods_cache: RefCell<DefIdMap<@~[@Method]>>,\n+    trait_methods_cache: RefCell<DefIdMap<@Vec<@Method> >>,\n \n     impl_trait_cache: RefCell<DefIdMap<Option<@ty::TraitRef>>>,\n \n@@ -305,14 +305,14 @@ pub struct ctxt_ {\n     needs_unwind_cleanup_cache: RefCell<HashMap<t, bool>>,\n     tc_cache: RefCell<HashMap<uint, TypeContents>>,\n     ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry>>,\n-    enum_var_cache: RefCell<DefIdMap<@~[@VariantInfo]>>,\n+    enum_var_cache: RefCell<DefIdMap<@Vec<@VariantInfo> >>,\n     ty_param_defs: RefCell<NodeMap<TypeParameterDef>>,\n     adjustments: RefCell<NodeMap<@AutoAdjustment>>,\n     normalized_cache: RefCell<HashMap<t, t>>,\n     lang_items: @middle::lang_items::LanguageItems,\n     // A mapping of fake provided method def_ids to the default implementation\n     provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n-    supertraits: RefCell<DefIdMap<@~[@TraitRef]>>,\n+    supertraits: RefCell<DefIdMap<@Vec<@TraitRef> >>,\n \n     // Maps from def-id of a type or region parameter to its\n     // (inferred) variance.\n@@ -328,12 +328,12 @@ pub struct ctxt_ {\n     destructors: RefCell<DefIdSet>,\n \n     // Maps a trait onto a list of impls of that trait.\n-    trait_impls: RefCell<DefIdMap<@RefCell<~[@Impl]>>>,\n+    trait_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl> >>>,\n \n     // Maps a def_id of a type to a list of its inherent impls.\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    inherent_impls: RefCell<DefIdMap<@RefCell<~[@Impl]>>>,\n+    inherent_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl> >>>,\n \n     // Maps a def_id of an impl to an Impl structure.\n     // Note that this contains all of the impls that we know about,\n@@ -461,7 +461,7 @@ pub struct ClosureTy {\n #[deriving(Clone, Eq, Hash)]\n pub struct FnSig {\n     binder_id: ast::NodeId,\n-    inputs: ~[t],\n+    inputs: Vec<t>,\n     output: t,\n     variadic: bool\n }\n@@ -684,7 +684,7 @@ pub enum RegionSubsts {\n #[deriving(Clone, Eq, Hash)]\n pub struct substs {\n     self_ty: Option<ty::t>,\n-    tps: ~[t],\n+    tps: Vec<t>,\n     regions: RegionSubsts,\n }\n \n@@ -756,7 +756,7 @@ pub enum sty {\n     ty_closure(ClosureTy),\n     ty_trait(DefId, substs, TraitStore, ast::Mutability, BuiltinBounds),\n     ty_struct(DefId, substs),\n-    ty_tup(~[t]),\n+    ty_tup(Vec<t>),\n \n     ty_param(param_ty), // type parameter\n     ty_self(DefId), /* special, implicit `self` type parameter;\n@@ -836,8 +836,7 @@ pub enum type_err {\n #[deriving(Eq, Hash)]\n pub struct ParamBounds {\n     builtin_bounds: BuiltinBounds,\n-    trait_bounds: ~[@TraitRef]\n-}\n+    trait_bounds: Vec<@TraitRef> }\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n@@ -1006,10 +1005,10 @@ pub struct RegionParameterDef {\n #[deriving(Clone)]\n pub struct Generics {\n     /// List of type parameters declared on the item.\n-    type_param_defs: Rc<~[TypeParameterDef]>,\n+    type_param_defs: Rc<Vec<TypeParameterDef> >,\n \n     /// List of region parameters declared on the item.\n-    region_param_defs: Rc<~[RegionParameterDef]>,\n+    region_param_defs: Rc<Vec<RegionParameterDef> >,\n }\n \n impl Generics {\n@@ -1048,7 +1047,7 @@ pub struct ParameterEnvironment {\n     self_param_bound: Option<@TraitRef>,\n \n     /// Bounds on each numbered type parameter\n-    type_param_bounds: ~[ParamBounds],\n+    type_param_bounds: Vec<ParamBounds> ,\n }\n \n /// A polytype.\n@@ -1412,7 +1411,7 @@ pub fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::MutImmutable}))\n }\n \n-pub fn mk_tup(cx: ctxt, ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n+pub fn mk_tup(cx: ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n \n pub fn mk_closure(cx: ctxt, fty: ClosureTy) -> t {\n     mk_t(cx, ty_closure(fty))\n@@ -1433,7 +1432,7 @@ pub fn mk_ctor_fn(cx: ctxt,\n                    abis: AbiSet::Rust(),\n                    sig: FnSig {\n                     binder_id: binder_id,\n-                    inputs: input_args,\n+                    inputs: Vec::from_slice(input_args),\n                     output: output,\n                     variadic: false\n                    }\n@@ -1667,7 +1666,7 @@ pub fn simd_type(cx: ctxt, ty: t) -> t {\n     match get(ty).sty {\n         ty_struct(did, ref substs) => {\n             let fields = lookup_struct_fields(cx, did);\n-            lookup_field_type(cx, did, fields[0].id, substs)\n+            lookup_field_type(cx, did, fields.get(0).id, substs)\n         }\n         _ => fail!(\"simd_type called on invalid type\")\n     }\n@@ -1685,7 +1684,7 @@ pub fn simd_size(cx: ctxt, ty: t) -> uint {\n \n pub fn get_element_type(ty: t, i: uint) -> t {\n     match get(ty).sty {\n-      ty_tup(ref ts) => return ts[i],\n+      ty_tup(ref ts) => return *ts.get(i),\n       _ => fail!(\"get_element_type called on invalid type\")\n     }\n }\n@@ -2198,22 +2197,25 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             ty_struct(did, ref substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(flds, |f| tc_mt(cx, f.mt, cache));\n+                    TypeContents::union(flds.as_slice(),\n+                                        |f| tc_mt(cx, f.mt, cache));\n                 if ty::has_dtor(cx, did) {\n                     res = res | TC::OwnsDtor;\n                 }\n                 apply_lang_items(cx, did, res)\n             }\n \n             ty_tup(ref tys) => {\n-                TypeContents::union(*tys, |ty| tc_ty(cx, *ty, cache))\n+                TypeContents::union(tys.as_slice(),\n+                                    |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, ref substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let res =\n-                    TypeContents::union(variants, |variant| {\n-                        TypeContents::union(variant.args, |arg_ty| {\n+                    TypeContents::union(variants.as_slice(), |variant| {\n+                        TypeContents::union(variant.args.as_slice(),\n+                                            |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n                     });\n@@ -2233,7 +2235,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 let tp_def = ty_param_defs.get().get(&p.def_id.node);\n                 kind_bounds_to_contents(cx,\n                                         tp_def.bounds.builtin_bounds,\n-                                        tp_def.bounds.trait_bounds)\n+                                        tp_def.bounds.trait_bounds.as_slice())\n             }\n \n             ty_self(def_id) => {\n@@ -2391,7 +2393,7 @@ pub fn type_moves_by_default(cx: ctxt, ty: t) -> bool {\n \n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n-    fn type_requires(cx: ctxt, seen: &mut ~[DefId],\n+    fn type_requires(cx: ctxt, seen: &mut Vec<DefId> ,\n                      r_ty: t, ty: t) -> bool {\n         debug!(\"type_requires({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n@@ -2409,7 +2411,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n         return r;\n     }\n \n-    fn subtypes_require(cx: ctxt, seen: &mut ~[DefId],\n+    fn subtypes_require(cx: ctxt, seen: &mut Vec<DefId> ,\n                         r_ty: t, ty: t) -> bool {\n         debug!(\"subtypes_require({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n@@ -2497,7 +2499,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n         return r;\n     }\n \n-    let mut seen = ~[];\n+    let mut seen = Vec::new();\n     !subtypes_require(cx, &mut seen, r_ty, r_ty)\n }\n \n@@ -2518,7 +2520,7 @@ pub enum Representability {\n pub fn is_type_representable(cx: ctxt, ty: t) -> Representability {\n \n     // Iterate until something non-representable is found\n-    fn find_nonrepresentable<It: Iterator<t>>(cx: ctxt, seen: &mut ~[DefId],\n+    fn find_nonrepresentable<It: Iterator<t>>(cx: ctxt, seen: &mut Vec<DefId> ,\n                                               mut iter: It) -> Representability {\n         for ty in iter {\n             let r = type_structurally_recursive(cx, seen, ty);\n@@ -2531,7 +2533,7 @@ pub fn is_type_representable(cx: ctxt, ty: t) -> Representability {\n \n     // Does the type `ty` directly (without indirection through a pointer)\n     // contain any types on stack `seen`?\n-    fn type_structurally_recursive(cx: ctxt, seen: &mut ~[DefId],\n+    fn type_structurally_recursive(cx: ctxt, seen: &mut Vec<DefId> ,\n                                    ty: t) -> Representability {\n         debug!(\"type_structurally_recursive: {}\",\n                ::util::ppaux::ty_to_str(cx, ty));\n@@ -2597,7 +2599,7 @@ pub fn is_type_representable(cx: ctxt, ty: t) -> Representability {\n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack\n     // of seen types and check recursion for each of them (issues #3008, #3779).\n-    let mut seen: ~[DefId] = ~[];\n+    let mut seen: Vec<DefId> = Vec::new();\n     type_structurally_recursive(cx, &mut seen, ty)\n }\n \n@@ -2788,10 +2790,10 @@ pub fn node_id_to_type_opt(cx: ctxt, id: ast::NodeId) -> Option<t> {\n }\n \n // FIXME(pcwalton): Makes a copy, bleh. Probably better to not do that.\n-pub fn node_id_to_type_params(cx: ctxt, id: ast::NodeId) -> ~[t] {\n+pub fn node_id_to_type_params(cx: ctxt, id: ast::NodeId) -> Vec<t> {\n     let node_type_substs = cx.node_type_substs.borrow();\n     match node_type_substs.get().find(&id) {\n-      None => return ~[],\n+      None => return Vec::new(),\n       Some(ts) => return (*ts).clone(),\n     }\n }\n@@ -2822,7 +2824,7 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n }\n \n // Type accessors for substructures of types\n-pub fn ty_fn_args(fty: t) -> ~[t] {\n+pub fn ty_fn_args(fty: t) -> Vec<t> {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.inputs.clone(),\n         ty_closure(ref f) => f.sig.inputs.clone(),\n@@ -2925,8 +2927,8 @@ pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n }\n \n // Returns a vec of all the input and output types of fty.\n-pub fn tys_in_fn_sig(sig: &FnSig) -> ~[t] {\n-    vec::append_one(sig.inputs.map(|a| *a), sig.output)\n+pub fn tys_in_fn_sig(sig: &FnSig) -> Vec<t> {\n+    vec_ng::append_one(sig.inputs.map(|a| *a), sig.output)\n }\n \n // Type accessors for AST nodes\n@@ -3213,7 +3215,7 @@ impl AutoRef {\n }\n \n pub struct ParamsTy {\n-    params: ~[t],\n+    params: Vec<t>,\n     ty: t\n }\n \n@@ -3231,7 +3233,7 @@ pub fn expr_has_ty_params(cx: ctxt, expr: &ast::Expr) -> bool {\n }\n \n pub fn method_call_type_param_defs(tcx: ctxt, origin: typeck::MethodOrigin)\n-                                   -> Rc<~[TypeParameterDef]> {\n+                                   -> Rc<Vec<TypeParameterDef> > {\n     match origin {\n         typeck::MethodStatic(did) => {\n             // n.b.: When we encode impl methods, the bounds\n@@ -3250,8 +3252,8 @@ pub fn method_call_type_param_defs(tcx: ctxt, origin: typeck::MethodOrigin)\n             // trait itself.  This ought to be harmonized.\n             let trait_type_param_defs =\n                 lookup_trait_def(tcx, trt_id).generics.type_param_defs();\n-            Rc::new(vec::append(\n-                trait_type_param_defs.to_owned(),\n+            Rc::new(vec_ng::append(\n+                Vec::from_slice(trait_type_param_defs),\n                 ty::trait_method(tcx,\n                                  trt_id,\n                                  n_mth).generics.type_param_defs()))\n@@ -3432,9 +3434,11 @@ pub fn expr_kind(tcx: ctxt,\n                 None => fail!(\"no def for place\"),\n             };\n             let def_id = ast_util::def_id_of_def(definition);\n-            match tcx.lang_items.items[ExchangeHeapLangItem as uint] {\n-                Some(item_def_id) if def_id == item_def_id => RvalueDatumExpr,\n-                Some(_) | None => RvalueDpsExpr,\n+            match tcx.lang_items.items.get(ExchangeHeapLangItem as uint) {\n+                &Some(item_def_id) if def_id == item_def_id => {\n+                    RvalueDatumExpr\n+                }\n+                &Some(_) | &None => RvalueDpsExpr,\n             }\n         }\n \n@@ -3480,8 +3484,8 @@ pub fn method_idx(id: ast::Ident, meths: &[@Method]) -> Option<uint> {\n /// Returns a vector containing the indices of all type parameters that appear\n /// in `ty`.  The vector may contain duplicates.  Probably should be converted\n /// to a bitset or some other representation.\n-pub fn param_tys_in_type(ty: t) -> ~[param_ty] {\n-    let mut rslt = ~[];\n+pub fn param_tys_in_type(ty: t) -> Vec<param_ty> {\n+    let mut rslt = Vec::new();\n     walk_ty(ty, |ty| {\n         match get(ty).sty {\n           ty_param(p) => {\n@@ -3496,8 +3500,8 @@ pub fn param_tys_in_type(ty: t) -> ~[param_ty] {\n pub fn occurs_check(tcx: ctxt, sp: Span, vid: TyVid, rt: t) {\n     // Returns a vec of all the type variables occurring in `ty`. It may\n     // contain duplicates.  (Integral type vars aren't counted.)\n-    fn vars_in_type(ty: t) -> ~[TyVid] {\n-        let mut rslt = ~[];\n+    fn vars_in_type(ty: t) -> Vec<TyVid> {\n+        let mut rslt = Vec::new();\n         walk_ty(ty, |ty| {\n             match get(ty).sty {\n               ty_infer(TyVar(v)) => rslt.push(v),\n@@ -3742,7 +3746,7 @@ pub fn provided_source(cx: ctxt, id: ast::DefId) -> Option<ast::DefId> {\n     provided_method_sources.get().find(&id).map(|x| *x)\n }\n \n-pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n+pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> Vec<@Method> {\n     if is_local(id) {\n         {\n             match cx.map.find(id.node) {\n@@ -3774,7 +3778,7 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n     }\n }\n \n-pub fn trait_supertraits(cx: ctxt, id: ast::DefId) -> @~[@TraitRef] {\n+pub fn trait_supertraits(cx: ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n     // Check the cache.\n     {\n         let supertraits = cx.supertraits.borrow();\n@@ -3796,7 +3800,7 @@ pub fn trait_supertraits(cx: ctxt, id: ast::DefId) -> @~[@TraitRef] {\n     return result;\n }\n \n-pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> ~[@TraitRef] {\n+pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> Vec<@TraitRef> {\n     let supertrait_refs = trait_supertraits(cx, trait_ref.def_id);\n     supertrait_refs.map(\n         |supertrait_ref| supertrait_ref.subst(cx, &trait_ref.substs))\n@@ -3831,12 +3835,12 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n }\n \n pub fn trait_method(cx: ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n-    let method_def_id = ty::trait_method_def_ids(cx, trait_did)[idx];\n+    let method_def_id = *ty::trait_method_def_ids(cx, trait_did).get(idx);\n     ty::method(cx, method_def_id)\n }\n \n \n-pub fn trait_methods(cx: ctxt, trait_did: ast::DefId) -> @~[@Method] {\n+pub fn trait_methods(cx: ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n     let mut trait_methods_cache = cx.trait_methods_cache.borrow_mut();\n     match trait_methods_cache.get().find(&trait_did) {\n         Some(&methods) => methods,\n@@ -3856,7 +3860,7 @@ pub fn method(cx: ctxt, id: ast::DefId) -> @Method {\n     })\n }\n \n-pub fn trait_method_def_ids(cx: ctxt, id: ast::DefId) -> @~[DefId] {\n+pub fn trait_method_def_ids(cx: ctxt, id: ast::DefId) -> @Vec<DefId> {\n     let mut trait_method_def_ids = cx.trait_method_def_ids.borrow_mut();\n     lookup_locally_or_in_crate_store(\"trait_method_def_ids\",\n                                      id,\n@@ -3934,8 +3938,8 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n // Enum information\n #[deriving(Clone)]\n pub struct VariantInfo {\n-    args: ~[t],\n-    arg_names: Option<~[ast::Ident]>,\n+    args: Vec<t>,\n+    arg_names: Option<Vec<ast::Ident> >,\n     ctor_ty: t,\n     name: ast::Ident,\n     id: ast::DefId,\n@@ -3955,7 +3959,11 @@ impl VariantInfo {\n \n         match ast_variant.node.kind {\n             ast::TupleVariantKind(ref args) => {\n-                let arg_tys = if args.len() > 0 { ty_fn_args(ctor_ty).map(|a| *a) } else { ~[] };\n+                let arg_tys = if args.len() > 0 {\n+                    ty_fn_args(ctor_ty).map(|a| *a)\n+                } else {\n+                    Vec::new()\n+                };\n \n                 return VariantInfo {\n                     args: arg_tys,\n@@ -3974,13 +3982,13 @@ impl VariantInfo {\n                 assert!(fields.len() > 0);\n \n                 let arg_tys = ty_fn_args(ctor_ty).map(|a| *a);\n-                let arg_names = fields.map(|field| {\n+                let arg_names = fields.iter().map(|field| {\n                     match field.node.kind {\n                         NamedField(ident, _) => ident,\n                         UnnamedField => cx.sess.bug(\n                             \"enum_variants: all fields in struct must have a name\")\n                     }\n-                });\n+                }).collect();\n \n                 return VariantInfo {\n                     args: arg_tys,\n@@ -3999,7 +4007,7 @@ impl VariantInfo {\n pub fn substd_enum_variants(cx: ctxt,\n                             id: ast::DefId,\n                             substs: &substs)\n-                         -> ~[@VariantInfo] {\n+                         -> Vec<@VariantInfo> {\n     enum_variants(cx, id).iter().map(|variant_info| {\n         let substd_args = variant_info.args.iter()\n             .map(|aty| subst(cx, substs, *aty)).collect();\n@@ -4080,7 +4088,7 @@ pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n      }\n }\n \n-pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n+pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n     {\n         let enum_var_cache = cx.enum_var_cache.borrow();\n         match enum_var_cache.get().find(&id) {\n@@ -4170,8 +4178,10 @@ pub fn enum_variant_with_id(cx: ctxt,\n     let variants = enum_variants(cx, enum_id);\n     let mut i = 0;\n     while i < variants.len() {\n-        let variant = variants[i];\n-        if variant.id == variant_id { return variant; }\n+        let variant = *variants.get(i);\n+        if variant.id == variant_id {\n+            return variant\n+        }\n         i += 1;\n     }\n     cx.sess.bug(\"enum_variant_with_id(): no variant exists with that ID\");\n@@ -4295,7 +4305,7 @@ pub fn lookup_field_type(tcx: ctxt,\n \n // Look up the list of field names and IDs for a given struct\n // Fails if the id is not bound to a struct.\n-pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n+pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> Vec<field_ty> {\n   if did.krate == ast::LOCAL_CRATE {\n       {\n           match cx.map.find(did.node) {\n@@ -4342,8 +4352,8 @@ pub fn lookup_struct_field(cx: ctxt,\n     }\n }\n \n-fn struct_field_tys(fields: &[StructField]) -> ~[field_ty] {\n-    fields.map(|field| {\n+fn struct_field_tys(fields: &[StructField]) -> Vec<field_ty> {\n+    fields.iter().map(|field| {\n         match field.node.kind {\n             NamedField(ident, visibility) => {\n                 field_ty {\n@@ -4360,13 +4370,13 @@ fn struct_field_tys(fields: &[StructField]) -> ~[field_ty] {\n                 }\n             }\n         }\n-    })\n+    }).collect()\n }\n \n // Returns a list of fields corresponding to the struct's items. trans uses\n // this. Takes a list of substs with which to instantiate field types.\n pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n-                     -> ~[field] {\n+                     -> Vec<field> {\n     lookup_struct_fields(cx, did).map(|f| {\n        field {\n             // FIXME #6993: change type of field to Name and get rid of new()\n@@ -4451,8 +4461,8 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n     return tbl[tycat(cx, ty)][opcat(op)];\n }\n \n-pub fn ty_params_to_tys(tcx: ty::ctxt, generics: &ast::Generics) -> ~[t] {\n-    vec::from_fn(generics.ty_params.len(), |i| {\n+pub fn ty_params_to_tys(tcx: ty::ctxt, generics: &ast::Generics) -> Vec<t> {\n+    Vec::from_fn(generics.ty_params.len(), |i| {\n         let id = generics.ty_params.get(i).id;\n         ty::mk_param(tcx, i, ast_util::local_def(id))\n     })\n@@ -4504,18 +4514,20 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n                        -> substs {\n             substs { regions: ErasedRegions,\n                      self_ty: ty_fold::fold_opt_ty(self, substs.self_ty),\n-                     tps: ty_fold::fold_ty_vec(self, substs.tps) }\n+                     tps: ty_fold::fold_ty_vec(self, substs.tps.as_slice()) }\n         }\n \n         fn fold_sig(&mut self,\n                     sig: &ty::FnSig)\n                     -> ty::FnSig {\n             // The binder-id is only relevant to bound regions, which\n             // are erased at trans time.\n-            ty::FnSig { binder_id: ast::DUMMY_NODE_ID,\n-                        inputs: ty_fold::fold_ty_vec(self, sig.inputs),\n-                        output: self.fold_ty(sig.output),\n-                        variadic: sig.variadic }\n+            ty::FnSig {\n+                binder_id: ast::DUMMY_NODE_ID,\n+                inputs: ty_fold::fold_ty_vec(self, sig.inputs.as_slice()),\n+                output: self.fold_ty(sig.output),\n+                variadic: sig.variadic,\n+            }\n         }\n     }\n }\n@@ -4607,7 +4619,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n                                         -> bool {\n     for &bound_trait_ref in bounds.iter() {\n         let mut supertrait_set = HashMap::new();\n-        let mut trait_refs = ~[];\n+        let mut trait_refs = Vec::new();\n         let mut i = 0;\n \n         // Seed the worklist with the trait from the bound\n@@ -4617,14 +4629,15 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n         // Add the given trait ty to the hash map\n         while i < trait_refs.len() {\n             debug!(\"each_bound_trait_and_supertraits(i={:?}, trait_ref={})\",\n-                   i, trait_refs[i].repr(tcx));\n+                   i, trait_refs.get(i).repr(tcx));\n \n-            if !f(trait_refs[i]) {\n+            if !f(*trait_refs.get(i)) {\n                 return false;\n             }\n \n             // Add supertraits to supertrait_set\n-            let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n+            let supertrait_refs = trait_ref_supertraits(tcx,\n+                                                        *trait_refs.get(i));\n             for &supertrait_ref in supertrait_refs.iter() {\n                 debug!(\"each_bound_trait_and_supertraits(supertrait_ref={})\",\n                        supertrait_ref.repr(tcx));\n@@ -4648,7 +4661,7 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n     let mut total = 0;\n     for type_param_def in type_param_defs.iter() {\n         each_bound_trait_and_supertraits(\n-            tcx, type_param_def.bounds.trait_bounds, |_| {\n+            tcx, type_param_def.bounds.trait_bounds.as_slice(), |_| {\n             total += 1;\n             true\n         });\n@@ -4681,7 +4694,7 @@ pub fn visitor_object_ty(tcx: ctxt,\n     let substs = substs {\n         regions: ty::NonerasedRegions(opt_vec::Empty),\n         self_ty: None,\n-        tps: ~[]\n+        tps: Vec::new()\n     };\n     let trait_ref = @TraitRef { def_id: trait_lang_item, substs: substs };\n     Ok((trait_ref,\n@@ -4708,7 +4721,7 @@ fn record_trait_implementation(tcx: ctxt,\n     let mut trait_impls = tcx.trait_impls.borrow_mut();\n     match trait_impls.get().find(&trait_def_id) {\n         None => {\n-            implementation_list = @RefCell::new(~[]);\n+            implementation_list = @RefCell::new(Vec::new());\n             trait_impls.get().insert(trait_def_id, implementation_list);\n         }\n         Some(&existing_implementation_list) => {\n@@ -4763,7 +4776,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n             let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n             match inherent_impls.get().find(&type_id) {\n                 None => {\n-                    implementation_list = @RefCell::new(~[]);\n+                    implementation_list = @RefCell::new(Vec::new());\n                     inherent_impls.get().insert(type_id, implementation_list);\n                 }\n                 Some(&existing_implementation_list) => {\n@@ -5080,7 +5093,7 @@ pub fn construct_parameter_environment(\n     let num_item_type_params = item_type_params.len();\n     let num_method_type_params = method_type_params.len();\n     let num_type_params = num_item_type_params + num_method_type_params;\n-    let type_params = vec::from_fn(num_type_params, |i| {\n+    let type_params = Vec::from_fn(num_type_params, |i| {\n             let def_id = if i < num_item_type_params {\n                 item_type_params[i].def_id\n             } else {\n@@ -5108,7 +5121,7 @@ pub fn construct_parameter_environment(\n     //\n \n     let self_bound_substd = self_bound.map(|b| b.subst(tcx, &free_substs));\n-    let type_param_bounds_substd = vec::from_fn(num_type_params, |i| {\n+    let type_param_bounds_substd = Vec::from_fn(num_type_params, |i| {\n         if i < num_item_type_params {\n             (*item_type_params[i].bounds).subst(tcx, &free_substs)\n         } else {\n@@ -5128,7 +5141,7 @@ impl substs {\n     pub fn empty() -> substs {\n         substs {\n             self_ty: None,\n-            tps: ~[],\n+            tps: Vec::new(),\n             regions: NonerasedRegions(opt_vec::Empty)\n         }\n     }"}, {"sha": "769924c02c864d3a3f7a9bb51b6594b14a4a0b11", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -13,6 +13,8 @@\n use middle::ty;\n use util::ppaux::Repr;\n \n+use std::vec_ng::Vec;\n+\n pub trait TypeFolder {\n     fn tcx(&self) -> ty::ctxt;\n \n@@ -84,10 +86,8 @@ pub fn fold_opt_ty<T:TypeFolder>(this: &mut T,\n     t.map(|t| this.fold_ty(t))\n }\n \n-pub fn fold_ty_vec<T:TypeFolder>(this: &mut T,\n-                                 tys: &[ty::t])\n-                                 -> ~[ty::t] {\n-    tys.map(|t| this.fold_ty(*t))\n+pub fn fold_ty_vec<T:TypeFolder>(this: &mut T, tys: &[ty::t]) -> Vec<ty::t> {\n+    tys.iter().map(|t| this.fold_ty(*t)).collect()\n }\n \n pub fn super_fold_ty<T:TypeFolder>(this: &mut T,\n@@ -110,14 +110,14 @@ pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n \n     ty::substs { regions: regions,\n                  self_ty: fold_opt_ty(this, substs.self_ty),\n-                 tps: fold_ty_vec(this, substs.tps), }\n+                 tps: fold_ty_vec(this, substs.tps.as_slice()), }\n }\n \n pub fn super_fold_sig<T:TypeFolder>(this: &mut T,\n                                     sig: &ty::FnSig)\n                                     -> ty::FnSig {\n     ty::FnSig { binder_id: sig.binder_id,\n-                inputs: fold_ty_vec(this, sig.inputs),\n+                inputs: fold_ty_vec(this, sig.inputs.as_slice()),\n                 output: this.fold_ty(sig.output),\n                 variadic: sig.variadic }\n }\n@@ -166,7 +166,7 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n                      bounds)\n         }\n         ty::ty_tup(ref ts) => {\n-            ty::ty_tup(fold_ty_vec(this, *ts))\n+            ty::ty_tup(fold_ty_vec(this, ts.as_slice()))\n         }\n         ty::ty_bare_fn(ref f) => {\n             ty::ty_bare_fn(this.fold_bare_fn_ty(f))"}, {"sha": "40e836ac0d9adb565c16f27e2c50cb43b9526126", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -136,7 +136,7 @@ fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n                 }\n \n                 Ok(rs) => {\n-                    rs[0]\n+                    *rs.get(0)\n                 }\n             }\n         }\n@@ -791,7 +791,11 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n         let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n             // no guarantee that the correct number of expected args\n             // were supplied\n-            if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n+            if i < e.inputs.len() {\n+                Some(*e.inputs.get(i))\n+            } else {\n+                None\n+            }\n         });\n         ty_of_arg(this, &rb, a, expected_arg_ty)\n     }).collect();"}, {"sha": "6c59ce09e05cb057c4f4f179d834fddab56bf620", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -115,7 +115,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let arg_types: ~[ty::t];\n+    let arg_types: Vec<ty::t> ;\n     let kind_name;\n \n     // structure_of requires type variables to be resolved.\n@@ -295,7 +295,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                span: Span,\n                                path: &ast::Path,\n                                fields: &[ast::FieldPat],\n-                               class_fields: ~[ty::field_ty],\n+                               class_fields: Vec<ty::field_ty> ,\n                                class_id: ast::DefId,\n                                substitutions: &ty::substs,\n                                etc: bool) {\n@@ -319,7 +319,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             }\n             Some(&(index, ref mut used)) => {\n                 *used = true;\n-                let class_field = class_fields[index];\n+                let class_field = *class_fields.get(index);\n                 let field_type = ty::lookup_field_type(tcx,\n                                                        class_id,\n                                                        class_field.id,\n@@ -562,7 +562,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                                           supplied_def_id,\n                                           &ty::substs {\n                                               self_ty: None,\n-                                              tps: ~[],\n+                                              tps: Vec::new(),\n                                               regions: ty::ErasedRegions,\n                                           });\n                     }\n@@ -585,7 +585,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         match *s {\n             ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n                 for (i, elt) in elts.iter().enumerate() {\n-                    check_pat(pcx, *elt, ex_elts[i]);\n+                    check_pat(pcx, *elt, *ex_elts.get(i));\n                 }\n                 fcx.write_ty(pat.id, expected);\n             }"}, {"sha": "0cf0fa5897aa91fdef9fb67a670492ad36de5f1a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -100,7 +100,8 @@ use util::ppaux::Repr;\n use std::cell::RefCell;\n use collections::HashSet;\n use std::result;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast::{DefId, SelfValue, SelfRegion};\n use syntax::ast::{SelfUniq, SelfStatic};\n use syntax::ast::{MutMutable, MutImmutable};\n@@ -139,8 +140,8 @@ pub fn lookup(\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n         impl_dups: @RefCell::new(HashSet::new()),\n-        inherent_candidates: @RefCell::new(~[]),\n-        extension_candidates: @RefCell::new(~[]),\n+        inherent_candidates: @RefCell::new(Vec::new()),\n+        extension_candidates: @RefCell::new(Vec::new()),\n         deref_args: deref_args,\n         check_traits: check_traits,\n         autoderef_receiver: autoderef_receiver,\n@@ -184,8 +185,8 @@ pub fn lookup_in_trait(\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n         impl_dups: @RefCell::new(HashSet::new()),\n-        inherent_candidates: @RefCell::new(~[]),\n-        extension_candidates: @RefCell::new(~[]),\n+        inherent_candidates: @RefCell::new(Vec::new()),\n+        extension_candidates: @RefCell::new(Vec::new()),\n         deref_args: check::DoDerefArgs,\n         check_traits: CheckTraitsOnly,\n         autoderef_receiver: autoderef_receiver,\n@@ -208,8 +209,8 @@ pub struct LookupContext<'a> {\n     m_name: ast::Name,\n     supplied_tps: &'a [ty::t],\n     impl_dups: @RefCell<HashSet<DefId>>,\n-    inherent_candidates: @RefCell<~[Candidate]>,\n-    extension_candidates: @RefCell<~[Candidate]>,\n+    inherent_candidates: @RefCell<Vec<Candidate> >,\n+    extension_candidates: @RefCell<Vec<Candidate> >,\n     deref_args: check::DerefArgs,\n     check_traits: CheckTraitsFlag,\n     autoderef_receiver: AutoderefReceiverFlag,\n@@ -311,8 +312,8 @@ impl<'a> LookupContext<'a> {\n     // Candidate collection (see comment at start of file)\n \n     fn reset_candidates(&self) {\n-        self.inherent_candidates.set(~[]);\n-        self.extension_candidates.set(~[]);\n+        self.inherent_candidates.set(Vec::new());\n+        self.extension_candidates.set(Vec::new());\n     }\n \n     fn push_inherent_candidates(&self, self_ty: ty::t) {\n@@ -450,7 +451,7 @@ impl<'a> LookupContext<'a> {\n                 self.get_method_index(new_trait_ref, trait_ref, method_num);\n             let mut m = (*m).clone();\n             // We need to fix up the transformed self type.\n-            m.fty.sig.inputs[0] =\n+            *m.fty.sig.inputs.get_mut(0) =\n                 self.construct_transformed_self_ty_for_object(\n                     did, &rcvr_substs, &m);\n \n@@ -476,7 +477,13 @@ impl<'a> LookupContext<'a> {\n                param_ty);\n         self.push_inherent_candidates_from_bounds(\n             rcvr_ty,\n-            self.fcx.inh.param_env.type_param_bounds[param_ty.idx].trait_bounds,\n+            self.fcx\n+                .inh\n+                .param_env\n+                .type_param_bounds\n+                .get(param_ty.idx)\n+                .trait_bounds\n+                .as_slice(),\n             restrict_to,\n             param_numbered(param_ty.idx));\n     }\n@@ -541,10 +548,9 @@ impl<'a> LookupContext<'a> {\n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n             match trait_methods.iter().position(|m| {\n                 m.explicit_self != ast::SelfStatic &&\n-                m.ident.name == self.m_name })\n-            {\n+                m.ident.name == self.m_name }) {\n                 Some(pos) => {\n-                    let method = trait_methods[pos];\n+                    let method = *trait_methods.get(pos);\n \n                     match mk_cand(bound_trait_ref, method, pos, this_bound_idx) {\n                         Some(cand) => {\n@@ -584,7 +590,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn push_candidates_from_impl(&self,\n-                                     candidates: &mut ~[Candidate],\n+                                     candidates: &mut Vec<Candidate> ,\n                                      impl_info: &ty::Impl) {\n         {\n             let mut impl_dups = self.impl_dups.borrow_mut();\n@@ -599,13 +605,16 @@ impl<'a> LookupContext<'a> {\n                impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n \n         let idx = {\n-            match impl_info.methods.iter().position(|m| m.ident.name == self.m_name) {\n+            match impl_info.methods\n+                           .iter()\n+                           .position(|m| m.ident.name == self.m_name) {\n                 Some(idx) => idx,\n                 None => { return; } // No method with the right name.\n             }\n         };\n \n-        let method = ty::method(self.tcx(), impl_info.methods[idx].def_id);\n+        let method = ty::method(self.tcx(),\n+                                impl_info.methods.get(idx).def_id);\n \n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n@@ -892,14 +901,15 @@ impl<'a> LookupContext<'a> {\n \n     fn consider_candidates(&self,\n                            rcvr_ty: ty::t,\n-                           candidates: &mut ~[Candidate])\n+                           candidates: &mut Vec<Candidate> )\n                            -> Option<MethodCallee> {\n         // FIXME(pcwalton): Do we need to clone here?\n-        let relevant_candidates: ~[Candidate] =\n+        let relevant_candidates: Vec<Candidate> =\n             candidates.iter().map(|c| (*c).clone()).\n                 filter(|c| self.is_relevant(rcvr_ty, c)).collect();\n \n-        let relevant_candidates = self.merge_candidates(relevant_candidates);\n+        let relevant_candidates =\n+            self.merge_candidates(relevant_candidates.as_slice());\n \n         if relevant_candidates.len() == 0 {\n             return None;\n@@ -914,11 +924,11 @@ impl<'a> LookupContext<'a> {\n             }\n         }\n \n-        Some(self.confirm_candidate(rcvr_ty, &relevant_candidates[0]))\n+        Some(self.confirm_candidate(rcvr_ty, relevant_candidates.get(0)))\n     }\n \n-    fn merge_candidates(&self, candidates: &[Candidate]) -> ~[Candidate] {\n-        let mut merged = ~[];\n+    fn merge_candidates(&self, candidates: &[Candidate]) -> Vec<Candidate> {\n+        let mut merged = Vec::new();\n         let mut i = 0;\n         while i < candidates.len() {\n             let candidate_a = &candidates[i];\n@@ -1004,14 +1014,15 @@ impl<'a> LookupContext<'a> {\n                      parameters given for this method\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else {\n-                self.supplied_tps.to_owned()\n+                Vec::from_slice(self.supplied_tps)\n             }\n         };\n \n         // Construct the full set of type parameters for the method,\n         // which is equal to the class tps + the method tps.\n         let all_substs = substs {\n-            tps: vec::append(candidate.rcvr_substs.tps.clone(), m_substs),\n+            tps: vec_ng::append(candidate.rcvr_substs.tps.clone(),\n+                                m_substs.as_slice()),\n             regions: candidate.rcvr_substs.regions.clone(),\n             self_ty: candidate.rcvr_substs.self_ty,\n         };\n@@ -1031,7 +1042,7 @@ impl<'a> LookupContext<'a> {\n                 let args = fn_sig.inputs.slice_from(1).iter().map(|t| {\n                     t.subst(tcx, &all_substs)\n                 });\n-                Some(fn_sig.inputs[0]).move_iter().chain(args).collect()\n+                Some(*fn_sig.inputs.get(0)).move_iter().chain(args).collect()\n             }\n             _ => fn_sig.inputs.subst(tcx, &all_substs)\n         };\n@@ -1050,7 +1061,7 @@ impl<'a> LookupContext<'a> {\n             self.fcx.infcx().next_region_var(\n                 infer::BoundRegionInFnCall(self.expr.span, br))\n         });\n-        let transformed_self_ty = fn_sig.inputs[0];\n+        let transformed_self_ty = *fn_sig.inputs.get(0);\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n             purity: bare_fn_ty.purity,\n@@ -1118,7 +1129,7 @@ impl<'a> LookupContext<'a> {\n                 ty::mk_err() // error reported in `enforce_object_limitations()`\n             }\n             ast::SelfRegion(..) | ast::SelfUniq => {\n-                let transformed_self_ty = method_ty.fty.sig.inputs[0];\n+                let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n                 match ty::get(transformed_self_ty).sty {\n                     ty::ty_rptr(r, mt) => { // must be SelfRegion\n                         ty::mk_trait(self.tcx(), trait_def_id,"}, {"sha": "3c98f3defd6e610eeb820f3fbdaa182ae6502389", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 152, "deletions": 147, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -118,6 +118,8 @@ use collections::HashMap;\n use std::mem::replace;\n use std::result;\n use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::abi::AbiSet;\n use syntax::ast::{Provided, Required};\n use syntax::ast;\n@@ -280,7 +282,7 @@ pub fn blank_fn_ctxt(ccx: @CrateCtxt,\n     // and statement context, but we might as well do write the code only once\n     let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n                                                self_param_bound: None,\n-                                               type_param_bounds: ~[] };\n+                                               type_param_bounds: Vec::new() };\n     @FnCtxt {\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n@@ -510,7 +512,7 @@ fn check_fn(ccx: @CrateCtxt,\n }\n \n pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n-                                 fields: ~[(ast::Ident, Span)]) {\n+                                 fields: Vec<(ast::Ident, Span)> ) {\n     let mut field_names = HashMap::new();\n \n     for p in fields.iter() {\n@@ -730,7 +732,7 @@ fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n     // Check for missing methods from trait\n     let provided_methods = ty::provided_trait_methods(tcx,\n                                                       impl_trait_ref.def_id);\n-    let mut missing_methods = ~[];\n+    let mut missing_methods = Vec::new();\n     for trait_method in trait_methods.iter() {\n         let is_implemented =\n             impl_methods.iter().any(\n@@ -887,11 +889,11 @@ fn compare_impl_method(tcx: ty::ctxt,\n     // in the self type with free regions.  So, for example, if the\n     // impl type is \"&'a str\", then this would replace the self\n     // type with a free region `self`.\n-    let dummy_impl_tps: ~[ty::t] =\n+    let dummy_impl_tps: Vec<ty::t> =\n         impl_generics.type_param_defs().iter().enumerate().\n         map(|(i,t)| ty::mk_param(tcx, i, t.def_id)).\n         collect();\n-    let dummy_method_tps: ~[ty::t] =\n+    let dummy_method_tps: Vec<ty::t> =\n         impl_m.generics.type_param_defs().iter().enumerate().\n         map(|(i,t)| ty::mk_param(tcx, i + impl_tps, t.def_id)).\n         collect();\n@@ -902,7 +904,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n                 bound_region: ty::BrNamed(l.def_id, l.ident)})).\n         collect();\n     let dummy_substs = ty::substs {\n-        tps: vec::append(dummy_impl_tps, dummy_method_tps),\n+        tps: vec_ng::append(dummy_impl_tps, dummy_method_tps.as_slice()),\n         regions: ty::NonerasedRegions(dummy_impl_regions),\n         self_ty: None };\n \n@@ -929,7 +931,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n                      self_ty: self_ty } = trait_substs.subst(tcx, &dummy_substs);\n         let substs = substs {\n             regions: trait_regions,\n-            tps: vec::append(trait_tps, dummy_method_tps),\n+            tps: vec_ng::append(trait_tps, dummy_method_tps.as_slice()),\n             self_ty: self_ty,\n         };\n         debug!(\"trait_fty (pre-subst): {} substs={}\",\n@@ -987,8 +989,8 @@ impl FnCtxt {\n \n impl RegionScope for infer::InferCtxt {\n     fn anon_regions(&self, span: Span, count: uint)\n-                    -> Result<~[ty::Region], ()> {\n-        Ok(vec::from_fn(count, |_| {\n+                    -> Result<Vec<ty::Region> , ()> {\n+        Ok(Vec::from_fn(count, |_| {\n             self.next_region_var(infer::MiscVariable(span))\n         }))\n     }\n@@ -1259,7 +1261,7 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n      * so that trans/borrowck/etc know about this autoderef. */\n \n     let mut t1 = t;\n-    let mut enum_dids = ~[];\n+    let mut enum_dids = Vec::new();\n     let mut autoderefs = 0;\n     loop {\n         let sty = structure_of(fcx, sp, t1);\n@@ -1672,7 +1674,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         let args = args.slice_from(1);\n         if ty::type_is_error(method_fn_ty) {\n             let err_inputs = err_args(args.len());\n-            check_argument_types(fcx, sp, err_inputs, callee_expr,\n+            check_argument_types(fcx, sp, err_inputs.as_slice(), callee_expr,\n                                  args, deref_args, false);\n             method_fn_ty\n         } else {\n@@ -1713,10 +1715,10 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         let supplied_arg_count = args.len();\n         let expected_arg_count = fn_inputs.len();\n         let formal_tys = if expected_arg_count == supplied_arg_count {\n-            fn_inputs.map(|a| *a)\n+            fn_inputs.iter().map(|a| *a).collect()\n         } else if variadic {\n             if supplied_arg_count >= expected_arg_count {\n-                fn_inputs.map(|a| *a)\n+                fn_inputs.iter().map(|a| *a).collect()\n             } else {\n                 let msg = format!(\n                     \"this function takes at least {nexpected, plural, =1{# parameter} \\\n@@ -1782,7 +1784,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n \n                 if is_block == check_blocks {\n                     debug!(\"checking the argument\");\n-                    let mut formal_ty = formal_tys[i];\n+                    let mut formal_ty = *formal_tys.get(i);\n \n                     match deref_args {\n                         DoDerefArgs => {\n@@ -1840,8 +1842,8 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n     }\n \n-    fn err_args(len: uint) -> ~[ty::t] {\n-        vec::from_fn(len, |_| ty::mk_err())\n+    fn err_args(len: uint) -> Vec<ty::t> {\n+        Vec::from_fn(len, |_| ty::mk_err())\n     }\n \n     fn write_call(fcx: @FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n@@ -1892,7 +1894,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         });\n \n         // Call the generic checker.\n-        check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n+        check_argument_types(fcx, call_expr.span, fn_sig.inputs.as_slice(), f,\n                              args, DontDerefArgs, fn_sig.variadic);\n \n         write_call(fcx, call_expr, fn_sig.output);\n@@ -2310,7 +2312,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                 // field\n                 debug!(\"class named {}\", ppaux::ty_to_str(tcx, base_t));\n                 let cls_items = ty::lookup_struct_fields(tcx, base_id);\n-                match lookup_field_ty(tcx, base_id, cls_items,\n+                match lookup_field_ty(tcx, base_id, cls_items.as_slice(),\n                                       field, &(*substs)) {\n                     Some(field_ty) => {\n                         // (2) look up what field's type is, and return it\n@@ -2324,13 +2326,13 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n             _ => ()\n         }\n \n-        let tps: ~[ty::t] = tys.iter().map(|&ty| fcx.to_ty(ty)).collect();\n+        let tps: Vec<ty::t> = tys.iter().map(|&ty| fcx.to_ty(ty)).collect();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n                              field,\n                              expr_t,\n-                             tps,\n+                             tps.as_slice(),\n                              DontDerefArgs,\n                              CheckTraitsAndInherentMethods,\n                              AutoderefReceiver) {\n@@ -2426,7 +2428,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n             // Make sure the programmer specified all the fields.\n             assert!(fields_found <= field_types.len());\n             if fields_found < field_types.len() {\n-                let mut missing_fields = ~[];\n+                let mut missing_fields = Vec::new();\n                 for class_field in field_types.iter() {\n                     let name = class_field.name;\n                     let (_, seen) = *class_field_map.get(&name);\n@@ -2484,7 +2486,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                            class_id,\n                                            id,\n                                            substitutions,\n-                                           class_fields,\n+                                           class_fields.as_slice(),\n                                            fields,\n                                            base_expr.is_none());\n         if ty::type_is_error(fcx.node_ty(id)) {\n@@ -2542,7 +2544,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                        variant_id,\n                                        id,\n                                        substitutions,\n-                                       variant_fields,\n+                                       variant_fields.as_slice(),\n                                        fields,\n                                        true);\n         fcx.write_ty(id, enum_type);\n@@ -2621,18 +2623,21 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                   // places: the exchange heap and the managed heap.\n                   let definition = lookup_def(fcx, path.span, place.id);\n                   let def_id = ast_util::def_id_of_def(definition);\n-                  match tcx.lang_items.items[ExchangeHeapLangItem as uint] {\n-                      Some(item_def_id) if def_id == item_def_id => {\n+                  match tcx.lang_items\n+                           .items\n+                           .get(ExchangeHeapLangItem as uint) {\n+                      &Some(item_def_id) if def_id == item_def_id => {\n                           fcx.write_ty(id, ty::mk_uniq(tcx,\n                                                        fcx.expr_ty(subexpr)));\n                           checked = true\n                       }\n-                      Some(_) | None => {}\n+                      &Some(_) | &None => {}\n                   }\n                   if !checked {\n                       match tcx.lang_items\n-                               .items[ManagedHeapLangItem as uint] {\n-                          Some(item_def_id) if def_id == item_def_id => {\n+                               .items\n+                               .get(ManagedHeapLangItem as uint) {\n+                          &Some(item_def_id) if def_id == item_def_id => {\n                               // Assign the magic `Gc<T>` struct.\n                               let gc_struct_id =\n                                   match tcx.lang_items\n@@ -2652,16 +2657,16 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                       gc_struct_id,\n                                                       substs {\n                                                         self_ty: None,\n-                                                        tps: ~[\n+                                                        tps: vec!(\n                                                             fcx.expr_ty(\n                                                                 subexpr)\n-                                                        ],\n+                                                        ),\n                                                         regions: regions,\n                                                       });\n                               fcx.write_ty(id, sty);\n                               checked = true\n                           }\n-                          Some(_) | None => {}\n+                          &Some(_) | &None => {}\n                       }\n                   }\n               }\n@@ -2750,7 +2755,8 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                     ty::ty_struct(did, ref substs) => {\n                                         let fields = ty::struct_fields(fcx.tcx(), did, substs);\n                                         fields.len() == 1\n-                                        && fields[0].ident == token::special_idents::unnamed_field\n+                                        && fields.get(0).ident ==\n+                                        token::special_idents::unnamed_field\n                                     }\n                                     _ => false\n                                 };\n@@ -3129,7 +3135,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n \n         let elt_ts = elts.iter().enumerate().map(|(i, e)| {\n             let opt_hint = match flds {\n-                Some(ref fs) if i < fs.len() => Some(fs[i]),\n+                Some(ref fs) if i < fs.len() => Some(*fs.get(i)),\n                 _ => None\n             };\n             check_expr_with_opt_hint(fcx, *e, opt_hint);\n@@ -3492,7 +3498,7 @@ pub fn check_simd(tcx: ty::ctxt, sp: Span, id: ast::NodeId) {\n                 tcx.sess.span_err(sp, \"SIMD vector cannot be empty\");\n                 return;\n             }\n-            let e = ty::lookup_field_type(tcx, did, fields[0].id, substs);\n+            let e = ty::lookup_field_type(tcx, did, fields.get(0).id, substs);\n             if !fields.iter().all(\n                          |f| ty::lookup_field_type(tcx, did, f.id, substs) == e) {\n                 tcx.sess.span_err(sp, \"SIMD vector should be homogeneous\");\n@@ -3544,11 +3550,11 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n                 vs: &[ast::P<ast::Variant>],\n                 id: ast::NodeId,\n                 hint: attr::ReprAttr)\n-                -> ~[@ty::VariantInfo] {\n+                -> Vec<@ty::VariantInfo> {\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n-        let mut variants: ~[@ty::VariantInfo] = ~[];\n-        let mut disr_vals: ~[ty::Disr] = ~[];\n+        let mut variants: Vec<@ty::VariantInfo> = Vec::new();\n+        let mut disr_vals: Vec<ty::Disr> = Vec::new();\n         let mut prev_disr_val: Option<ty::Disr> = None;\n \n         for &v in vs.iter() {\n@@ -3797,15 +3803,15 @@ pub fn instantiate_path(fcx: @FnCtxt,\n \n         // Build up the list of type parameters, inserting the self parameter\n         // at the appropriate position.\n-        let mut tps = ~[];\n+        let mut tps = Vec::new();\n         let mut pushed = false;\n         for (i, ty) in pth.segments.iter()\n                                    .flat_map(|segment| segment.types.iter())\n                                    .map(|&ast_type| fcx.to_ty(ast_type))\n                                    .enumerate() {\n             match self_parameter_index {\n                 Some(index) if index == i => {\n-                    tps.push(fcx.infcx().next_ty_vars(1)[0]);\n+                    tps.push(*fcx.infcx().next_ty_vars(1).get(0));\n                     pushed = true;\n                 }\n                 _ => {}\n@@ -3829,7 +3835,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n         for (i, default) in defaults.skip(ty_substs_len).enumerate() {\n             match self_parameter_index {\n                 Some(index) if index == i + ty_substs_len => {\n-                    substs.tps.push(fcx.infcx().next_ty_vars(1)[0]);\n+                    substs.tps.push(*fcx.infcx().next_ty_vars(1).get(0));\n                     pushed = true;\n                 }\n                 _ => {}\n@@ -3848,7 +3854,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n \n         // If the self parameter goes at the end, insert it there.\n         if !pushed && self_parameter_index.is_some() {\n-            substs.tps.push(fcx.infcx().next_ty_vars(1)[0])\n+            substs.tps.push(*fcx.infcx().next_ty_vars(1).get(0))\n         }\n \n         assert_eq!(substs.tps.len(), ty_param_count)\n@@ -4024,40 +4030,39 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n     let tcx = ccx.tcx;\n     let name = token::get_ident(it.ident);\n     let (n_tps, inputs, output) = if name.get().starts_with(\"atomic_\") {\n-        let split : ~[&str] = name.get().split('_').collect();\n+        let split : Vec<&str> = name.get().split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n         //We only care about the operation here\n-        match split[1] {\n-            \"cxchg\" => (1, ~[ty::mk_mut_rptr(tcx,\n+        match *split.get(1) {\n+            \"cxchg\" => (1, vec!(ty::mk_mut_rptr(tcx,\n                                              ty::ReLateBound(it.id, ty::BrAnon(0)),\n                                              param(ccx, 0)),\n                         param(ccx, 0),\n-                        param(ccx, 0),\n-                        ], param(ccx, 0)),\n+                        param(ccx, 0)), param(ccx, 0)),\n             \"load\" => (1,\n-               ~[\n+               vec!(\n                   ty::mk_imm_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)),\n                                   param(ccx, 0))\n-               ],\n+               ),\n               param(ccx, 0)),\n             \"store\" => (1,\n-               ~[\n+               vec!(\n                   ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)),\n                                   param(ccx, 0)),\n                   param(ccx, 0)\n-               ],\n+               ),\n                ty::mk_nil()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n-                (1, ~[ty::mk_mut_rptr(tcx,\n+                (1, vec!(ty::mk_mut_rptr(tcx,\n                                       ty::ReLateBound(it.id, ty::BrAnon(0)),\n-                                      param(ccx, 0)), param(ccx, 0) ],\n+                                      param(ccx, 0)), param(ccx, 0) ),\n                  param(ccx, 0))\n             }\n             \"fence\" => {\n-                (0, ~[], ty::mk_nil())\n+                (0, Vec::new(), ty::mk_nil())\n             }\n             op => {\n                 tcx.sess.span_err(it.span,\n@@ -4069,24 +4074,24 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n \n     } else {\n         match name.get() {\n-            \"abort\" => (0, ~[], ty::mk_bot()),\n-            \"breakpoint\" => (0, ~[], ty::mk_nil()),\n+            \"abort\" => (0, Vec::new(), ty::mk_bot()),\n+            \"breakpoint\" => (0, Vec::new(), ty::mk_nil()),\n             \"size_of\" |\n-            \"pref_align_of\" | \"min_align_of\" => (1u, ~[], ty::mk_uint()),\n-            \"init\" => (1u, ~[], param(ccx, 0u)),\n-            \"uninit\" => (1u, ~[], param(ccx, 0u)),\n-            \"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n-            \"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n+            \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ty::mk_uint()),\n+            \"init\" => (1u, Vec::new(), param(ccx, 0u)),\n+            \"uninit\" => (1u, Vec::new(), param(ccx, 0u)),\n+            \"forget\" => (1u, vec!( param(ccx, 0) ), ty::mk_nil()),\n+            \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n             \"move_val_init\" => {\n                 (1u,\n-                 ~[\n+                 vec!(\n                     ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), param(ccx, 0)),\n                     param(ccx, 0u)\n-                  ],\n+                  ),\n                ty::mk_nil())\n             }\n-            \"needs_drop\" => (1u, ~[], ty::mk_bool()),\n-            \"owns_managed\" => (1u, ~[], ty::mk_bool()),\n+            \"needs_drop\" => (1u, Vec::new(), ty::mk_bool()),\n+            \"owns_managed\" => (1u, Vec::new(), ty::mk_bool()),\n \n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n@@ -4097,14 +4102,14 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n                   ty: tydesc_ty,\n                   mutbl: ast::MutImmutable\n               });\n-              (1u, ~[], td_ptr)\n+              (1u, Vec::new(), td_ptr)\n             }\n             \"type_id\" => {\n                 let langid = ccx.tcx.lang_items.require(TypeIdLangItem);\n                 match langid {\n-                    Ok(did) => (1u, ~[], ty::mk_struct(ccx.tcx, did, substs {\n+                    Ok(did) => (1u, Vec::new(), ty::mk_struct(ccx.tcx, did, substs {\n                                                  self_ty: None,\n-                                                 tps: ~[],\n+                                                 tps: Vec::new(),\n                                                  regions: ty::NonerasedRegions(opt_vec::Empty)\n                                                  }) ),\n                     Err(msg) => { tcx.sess.span_fatal(it.span, msg); }\n@@ -4125,25 +4130,25 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n                   ty: tydesc_ty,\n                   mutbl: ast::MutImmutable\n               });\n-              (0, ~[ td_ptr, visitor_object_ty ], ty::mk_nil())\n+              (0, vec!( td_ptr, visitor_object_ty ), ty::mk_nil())\n             }\n             \"offset\" => {\n               (1,\n-               ~[\n+               vec!(\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n                   ty::mk_int()\n-               ],\n+               ),\n                ty::mk_ptr(tcx, ty::mt {\n                    ty: param(ccx, 0),\n                    mutbl: ast::MutImmutable\n                }))\n             }\n             \"copy_nonoverlapping_memory\" => {\n               (1,\n-               ~[\n+               vec!(\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n@@ -4153,12 +4158,12 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n                       mutbl: ast::MutImmutable\n                   }),\n                   ty::mk_uint()\n-               ],\n+               ),\n                ty::mk_nil())\n             }\n             \"copy_memory\" => {\n               (1,\n-               ~[\n+               vec!(\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n@@ -4168,135 +4173,135 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n                       mutbl: ast::MutImmutable\n                   }),\n                   ty::mk_uint()\n-               ],\n+               ),\n                ty::mk_nil())\n             }\n             \"set_memory\" => {\n               (1,\n-               ~[\n+               vec!(\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n                   ty::mk_u8(),\n                   ty::mk_uint()\n-               ],\n+               ),\n                ty::mk_nil())\n             }\n-            \"sqrtf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"sqrtf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"sqrtf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"sqrtf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n             \"powif32\" => {\n                (0,\n-                ~[ ty::mk_f32(), ty::mk_i32() ],\n+                vec!( ty::mk_f32(), ty::mk_i32() ),\n                 ty::mk_f32())\n             }\n             \"powif64\" => {\n                (0,\n-                ~[ ty::mk_f64(), ty::mk_i32() ],\n+                vec!( ty::mk_f64(), ty::mk_i32() ),\n                 ty::mk_f64())\n             }\n-            \"sinf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"sinf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"cosf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"cosf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"sinf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"sinf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"cosf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"cosf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n             \"powf32\" => {\n                (0,\n-                ~[ ty::mk_f32(), ty::mk_f32() ],\n+                vec!( ty::mk_f32(), ty::mk_f32() ),\n                 ty::mk_f32())\n             }\n             \"powf64\" => {\n                (0,\n-                ~[ ty::mk_f64(), ty::mk_f64() ],\n+                vec!( ty::mk_f64(), ty::mk_f64() ),\n                 ty::mk_f64())\n             }\n-            \"expf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"expf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"exp2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"exp2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"logf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"logf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"log10f32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"log10f64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"log2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"log2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"expf32\"   => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"expf64\"   => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"exp2f32\"  => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"exp2f64\"  => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"logf32\"   => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"logf64\"   => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"log10f32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"log10f64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"log2f32\"  => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"log2f64\"  => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n             \"fmaf32\" => {\n                 (0,\n-                 ~[ ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ],\n+                 vec!( ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ),\n                  ty::mk_f32())\n             }\n             \"fmaf64\" => {\n                 (0,\n-                 ~[ ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ],\n+                 vec!( ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ),\n                  ty::mk_f64())\n             }\n-            \"fabsf32\"      => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"fabsf64\"      => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"copysignf32\"  => (0, ~[ ty::mk_f32(), ty::mk_f32() ], ty::mk_f32()),\n-            \"copysignf64\"  => (0, ~[ ty::mk_f64(), ty::mk_f64() ], ty::mk_f64()),\n-            \"floorf32\"     => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"floorf64\"     => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"ceilf32\"      => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"ceilf64\"      => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"truncf32\"     => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"truncf64\"     => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"rintf32\"      => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"rintf64\"      => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"nearbyintf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"nearbyintf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"roundf32\"     => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"roundf64\"     => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"ctpop8\"       => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-            \"ctpop16\"      => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-            \"ctpop32\"      => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-            \"ctpop64\"      => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-            \"ctlz8\"        => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-            \"ctlz16\"       => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-            \"ctlz32\"       => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-            \"ctlz64\"       => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-            \"cttz8\"        => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-            \"cttz16\"       => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-            \"cttz32\"       => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-            \"cttz64\"       => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-            \"bswap16\"      => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-            \"bswap32\"      => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-            \"bswap64\"      => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+            \"fabsf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"fabsf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"copysignf32\"  => (0, vec!( ty::mk_f32(), ty::mk_f32() ), ty::mk_f32()),\n+            \"copysignf64\"  => (0, vec!( ty::mk_f64(), ty::mk_f64() ), ty::mk_f64()),\n+            \"floorf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"floorf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"ceilf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"ceilf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"truncf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"truncf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"rintf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"rintf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"nearbyintf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"nearbyintf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"roundf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"roundf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"ctpop8\"       => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n+            \"ctpop16\"      => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n+            \"ctpop32\"      => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n+            \"ctpop64\"      => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n+            \"ctlz8\"        => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n+            \"ctlz16\"       => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n+            \"ctlz32\"       => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n+            \"ctlz64\"       => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n+            \"cttz8\"        => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n+            \"cttz16\"       => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n+            \"cttz32\"       => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n+            \"cttz64\"       => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n+            \"bswap16\"      => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n+            \"bswap32\"      => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n+            \"bswap64\"      => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n \n             \"volatile_load\" =>\n-                (1, ~[ ty::mk_imm_ptr(tcx, param(ccx, 0)) ], param(ccx, 0)),\n+                (1, vec!( ty::mk_imm_ptr(tcx, param(ccx, 0)) ), param(ccx, 0)),\n             \"volatile_store\" =>\n-                (1, ~[ ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ], ty::mk_nil()),\n+                (1, vec!( ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ), ty::mk_nil()),\n \n             \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n-                (0, ~[ty::mk_i8(), ty::mk_i8()],\n-                ty::mk_tup(tcx, ~[ty::mk_i8(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_i8(), ty::mk_i8()),\n+                ty::mk_tup(tcx, vec!(ty::mk_i8(), ty::mk_bool()))),\n \n             \"i16_add_with_overflow\" | \"i16_sub_with_overflow\" | \"i16_mul_with_overflow\" =>\n-                (0, ~[ty::mk_i16(), ty::mk_i16()],\n-                ty::mk_tup(tcx, ~[ty::mk_i16(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_i16(), ty::mk_i16()),\n+                ty::mk_tup(tcx, vec!(ty::mk_i16(), ty::mk_bool()))),\n \n             \"i32_add_with_overflow\" | \"i32_sub_with_overflow\" | \"i32_mul_with_overflow\" =>\n-                (0, ~[ty::mk_i32(), ty::mk_i32()],\n-                ty::mk_tup(tcx, ~[ty::mk_i32(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_i32(), ty::mk_i32()),\n+                ty::mk_tup(tcx, vec!(ty::mk_i32(), ty::mk_bool()))),\n \n             \"i64_add_with_overflow\" | \"i64_sub_with_overflow\" | \"i64_mul_with_overflow\" =>\n-                (0, ~[ty::mk_i64(), ty::mk_i64()],\n-                ty::mk_tup(tcx, ~[ty::mk_i64(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_i64(), ty::mk_i64()),\n+                ty::mk_tup(tcx, vec!(ty::mk_i64(), ty::mk_bool()))),\n \n             \"u8_add_with_overflow\" | \"u8_sub_with_overflow\" | \"u8_mul_with_overflow\" =>\n-                (0, ~[ty::mk_u8(), ty::mk_u8()],\n-                ty::mk_tup(tcx, ~[ty::mk_u8(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_u8(), ty::mk_u8()),\n+                ty::mk_tup(tcx, vec!(ty::mk_u8(), ty::mk_bool()))),\n \n             \"u16_add_with_overflow\" | \"u16_sub_with_overflow\" | \"u16_mul_with_overflow\" =>\n-                (0, ~[ty::mk_u16(), ty::mk_u16()],\n-                ty::mk_tup(tcx, ~[ty::mk_u16(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_u16(), ty::mk_u16()),\n+                ty::mk_tup(tcx, vec!(ty::mk_u16(), ty::mk_bool()))),\n \n             \"u32_add_with_overflow\" | \"u32_sub_with_overflow\" | \"u32_mul_with_overflow\"=>\n-                (0, ~[ty::mk_u32(), ty::mk_u32()],\n-                ty::mk_tup(tcx, ~[ty::mk_u32(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_u32(), ty::mk_u32()),\n+                ty::mk_tup(tcx, vec!(ty::mk_u32(), ty::mk_bool()))),\n \n             \"u64_add_with_overflow\" | \"u64_sub_with_overflow\"  | \"u64_mul_with_overflow\" =>\n-                (0, ~[ty::mk_u64(), ty::mk_u64()],\n-                ty::mk_tup(tcx, ~[ty::mk_u64(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_u64(), ty::mk_u64()),\n+                ty::mk_tup(tcx, vec!(ty::mk_u64(), ty::mk_bool()))),\n \n             ref other => {\n                 tcx.sess.span_err(it.span,"}, {"sha": "d0bb1f32fb8fff053975f261eccbd672de774697", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -13,7 +13,9 @@\n use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n+\n use collections::HashMap;\n+use std::vec_ng::Vec;\n use util::ppaux::Repr;\n use util::ppaux;\n \n@@ -74,7 +76,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n      */\n \n     let mut rr = RegionRelator { tcx: tcx,\n-                                 stack: ~[],\n+                                 stack: Vec::new(),\n                                  relate_op: relate_op };\n     match opt_region {\n         Some(o_r) => { rr.stack.push(o_r); }\n@@ -84,7 +86,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n \n     struct RegionRelator<'a> {\n         tcx: ty::ctxt,\n-        stack: ~[ty::Region],\n+        stack: Vec<ty::Region> ,\n         relate_op: 'a |ty::Region, ty::Region|,\n     }\n \n@@ -147,7 +149,7 @@ pub fn relate_free_regions(tcx: ty::ctxt, fn_sig: &ty::FnSig) {\n \n     debug!(\"relate_free_regions >>\");\n \n-    let mut all_tys = ~[];\n+    let mut all_tys = Vec::new();\n     for arg in fn_sig.inputs.iter() {\n         all_tys.push(*arg);\n     }"}, {"sha": "32e1dfd98db57772f5e828e8231ae6306e41dd9d", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -26,9 +26,10 @@ use util::common::indenter;\n use util::ppaux;\n use util::ppaux::Repr;\n \n-use std::cell::RefCell;\n use collections::HashSet;\n+use std::cell::RefCell;\n use std::result;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -100,13 +101,13 @@ fn lookup_vtables(vcx: &VtableContext,\n \n     // We do this backwards for reasons discussed above.\n     assert_eq!(substs.tps.len(), type_param_defs.len());\n-    let mut result =\n+    let mut result: Vec<vtable_param_res> =\n         substs.tps.rev_iter()\n         .zip(type_param_defs.rev_iter())\n         .map(|(ty, def)|\n                    lookup_vtables_for_param(vcx, location_info, Some(substs),\n                                             &*def.bounds, *ty, is_early))\n-        .to_owned_vec();\n+        .collect();\n     result.reverse();\n \n     assert_eq!(substs.tps.len(), result.len());\n@@ -132,9 +133,12 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n     let tcx = vcx.tcx();\n \n     // ty is the value supplied for the type parameter A...\n-    let mut param_result = ~[];\n+    let mut param_result = Vec::new();\n \n-    ty::each_bound_trait_and_supertraits(tcx, type_param_bounds.trait_bounds, |trait_ref| {\n+    ty::each_bound_trait_and_supertraits(tcx,\n+                                         type_param_bounds.trait_bounds\n+                                                          .as_slice(),\n+                                         |trait_ref| {\n         // ...and here trait_ref is each bound that was declared on A,\n         // expressed in terms of the type parameters.\n \n@@ -252,7 +256,11 @@ fn lookup_vtable(vcx: &VtableContext,\n     let vtable_opt = match ty::get(ty).sty {\n         ty::ty_param(param_ty {idx: n, ..}) => {\n             let type_param_bounds: &[@ty::TraitRef] =\n-                vcx.param_env.type_param_bounds[n].trait_bounds;\n+                vcx.param_env\n+                   .type_param_bounds\n+                   .get(n)\n+                   .trait_bounds\n+                   .as_slice();\n             lookup_vtable_from_bounds(vcx,\n                                       location_info,\n                                       type_param_bounds,\n@@ -323,7 +331,7 @@ fn search_for_vtable(vcx: &VtableContext,\n                      -> Option<vtable_origin> {\n     let tcx = vcx.tcx();\n \n-    let mut found = ~[];\n+    let mut found = Vec::new();\n     let mut impls_seen = HashSet::new();\n \n     // Load the implementations from external metadata if necessary.\n@@ -336,7 +344,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         let trait_impls = tcx.trait_impls.borrow();\n         trait_impls.get()\n                    .find(&trait_ref.def_id)\n-                   .map_or(@RefCell::new(~[]), |x| *x)\n+                   .map_or(@RefCell::new(Vec::new()), |x| *x)\n     };\n     // impls is the list of all impls in scope for trait_ref.\n     let impls = impls.borrow();\n@@ -392,7 +400,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         // the type self_ty, and substs is bound to [T].\n         debug!(\"The self ty is {} and its substs are {}\",\n                vcx.infcx.ty_to_str(for_ty),\n-               vcx.infcx.tys_to_str(substs.tps));\n+               vcx.infcx.tys_to_str(substs.tps.as_slice()));\n \n         // Next, we unify trait_ref -- the type that we want to cast\n         // to -- with of_trait_ref -- the trait that im implements. At\n@@ -445,7 +453,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         debug!(\"The fixed-up substs are {} - \\\n                 they will be unified with the bounds for \\\n                 the target ty, {}\",\n-               vcx.infcx.tys_to_str(substs_f.tps),\n+               vcx.infcx.tys_to_str(substs_f.tps.as_slice()),\n                vcx.infcx.trait_ref_to_str(trait_ref));\n \n         // Next, we unify the fixed-up substitutions for the impl self\n@@ -465,14 +473,14 @@ fn search_for_vtable(vcx: &VtableContext,\n \n     match found.len() {\n         0 => { return None }\n-        1 => return Some(found[0].clone()),\n+        1 => return Some(found.get(0).clone()),\n         _ => {\n             if !is_early {\n                 vcx.tcx().sess.span_err(\n                     location_info.span,\n                     \"multiple applicable methods in scope\");\n             }\n-            return Some(found[0].clone());\n+            return Some(found.get(0).clone());\n         }\n     }\n }\n@@ -614,7 +622,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n \n                       let param_bounds = ty::ParamBounds {\n                           builtin_bounds: ty::EmptyBuiltinBounds(),\n-                          trait_bounds: ~[target_trait_ref]\n+                          trait_bounds: vec!(target_trait_ref)\n                       };\n                       let vtables =\n                             lookup_vtables_for_param(&vcx,\n@@ -625,7 +633,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                                      is_early);\n \n                       if !is_early {\n-                          insert_vtables(fcx, ex.id, @~[vtables]);\n+                          insert_vtables(fcx, ex.id, @vec!(vtables));\n                       }\n \n                       // Now, if this is &trait, we need to link the\n@@ -701,11 +709,15 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n             debug!(\"vtable resolution on parameter bounds for method call {}\",\n                    ex.repr(fcx.tcx()));\n             let type_param_defs = ty::method_call_type_param_defs(cx.tcx, method.origin);\n-            if has_trait_bounds(*type_param_defs.borrow()) {\n+            if has_trait_bounds(type_param_defs.borrow().as_slice()) {\n                 let substs = fcx.method_ty_substs(ex.id);\n                 let vcx = fcx.vtable_context();\n-                let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n-                                           *type_param_defs.borrow(), &substs, is_early);\n+                let vtbls = lookup_vtables(&vcx,\n+                                           &location_info_for_expr(ex),\n+                                           type_param_defs.borrow()\n+                                                          .as_slice(),\n+                                           &substs,\n+                                           is_early);\n                 if !is_early {\n                     insert_vtables(fcx, ex.id, vtbls);\n                 }\n@@ -787,7 +799,7 @@ pub fn resolve_impl(tcx: ty::ctxt,\n     // but that falls out of doing this.\n     let param_bounds = ty::ParamBounds {\n         builtin_bounds: ty::EmptyBuiltinBounds(),\n-        trait_bounds: ~[impl_trait_ref]\n+        trait_bounds: vec!(impl_trait_ref)\n     };\n     let t = ty::node_id_to_type(tcx, impl_item.id);\n     let t = t.subst(tcx, &param_env.free_substs);\n@@ -817,7 +829,7 @@ pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n                             substs: &ty::substs) -> Option<vtable_res> {\n     let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n     let type_param_defs = generics.type_param_defs.borrow();\n-    if has_trait_bounds(*type_param_defs) {\n+    if has_trait_bounds(type_param_defs.as_slice()) {\n         let vcx = VtableContext {\n             infcx: &infer::new_infer_ctxt(tcx),\n             param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], id)\n@@ -827,7 +839,11 @@ pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n             span: tcx.map.span(id)\n         };\n \n-        Some(lookup_vtables(&vcx, &loc_info, *type_param_defs, substs, false))\n+        Some(lookup_vtables(&vcx,\n+                            &loc_info,\n+                            type_param_defs.as_slice(),\n+                            substs,\n+                            false))\n     } else {\n         None\n     }"}, {"sha": "ced9db069545beb8301b0ca5407bc070793f9953", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -28,6 +28,7 @@ use middle::typeck::write_ty_to_tcx;\n use util::ppaux;\n use util::ppaux::Repr;\n \n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::print::pprust::pat_to_str;\n@@ -53,13 +54,13 @@ fn resolve_type_vars_in_type(fcx: @FnCtxt, sp: Span, typ: ty::t)\n }\n \n fn resolve_type_vars_in_types(fcx: @FnCtxt, sp: Span, tys: &[ty::t])\n-                          -> ~[ty::t] {\n-    tys.map(|t| {\n+                          -> Vec<ty::t> {\n+    tys.iter().map(|t| {\n         match resolve_type_vars_in_type(fcx, sp, *t) {\n             Some(t1) => t1,\n             None => ty::mk_err()\n         }\n-    })\n+    }).collect()\n }\n \n fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n@@ -78,7 +79,7 @@ fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n                     return;\n                 }\n             };\n-            let mut new_tps = ~[];\n+            let mut new_tps = Vec::new();\n             for &subst in method.substs.tps.iter() {\n                 match resolve_type_vars_in_type(fcx, sp, subst) {\n                     Some(t) => new_tps.push(t),\n@@ -122,7 +123,9 @@ fn resolve_vtable_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n                       origin: &vtable_origin) -> vtable_origin {\n         match origin {\n             &vtable_static(def_id, ref tys, origins) => {\n-                let r_tys = resolve_type_vars_in_types(fcx, sp, *tys);\n+                let r_tys = resolve_type_vars_in_types(fcx,\n+                                                       sp,\n+                                                       tys.as_slice());\n                 let r_origins = resolve_origins(fcx, sp, origins);\n                 vtable_static(def_id, r_tys, r_origins)\n             }\n@@ -242,7 +245,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n         write_ty_to_tcx(tcx, id, t);\n         let mut ret = Some(t);\n         fcx.opt_node_ty_substs(id, |substs| {\n-          let mut new_tps = ~[];\n+          let mut new_tps = Vec::new();\n           for subst in substs.tps.iter() {\n               match resolve_type_vars_in_type(fcx, sp, *subst) {\n                 Some(t) => new_tps.push(t),"}, {"sha": "e85d71fa982ce0d140bdf835578d9f63d20c385f", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -46,15 +46,16 @@ use syntax::opt_vec;\n use syntax::parse::token;\n use syntax::visit;\n \n-use std::cell::RefCell;\n use collections::HashSet;\n+use std::cell::RefCell;\n use std::rc::Rc;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n \n struct UniversalQuantificationResult {\n     monotype: t,\n-    type_variables: ~[ty::t],\n-    type_param_defs: Rc<~[ty::TypeParameterDef]>\n+    type_variables: Vec<ty::t> ,\n+    type_param_defs: Rc<Vec<ty::TypeParameterDef> >\n }\n \n fn get_base_type(inference_context: &InferCtxt,\n@@ -323,7 +324,7 @@ impl CoherenceChecker {\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n     fn instantiate_default_methods(&self, impl_id: ast::DefId,\n                                    trait_ref: &ty::TraitRef,\n-                                   all_methods: &mut ~[@Method]) {\n+                                   all_methods: &mut Vec<@Method> ) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n@@ -354,8 +355,9 @@ impl CoherenceChecker {\n             // construct the polytype for the method based on the method_ty\n             let new_generics = ty::Generics {\n                 type_param_defs:\n-                    Rc::new(vec::append(\n-                        impl_poly_type.generics.type_param_defs().to_owned(),\n+                    Rc::new(vec_ng::append(\n+                        Vec::from_slice(impl_poly_type.generics\n+                                                      .type_param_defs()),\n                             new_method_ty.generics.type_param_defs())),\n                 region_param_defs:\n                     impl_poly_type.generics.region_param_defs.clone()\n@@ -390,7 +392,7 @@ impl CoherenceChecker {\n         let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n         match inherent_impls.get().find(&base_def_id) {\n             None => {\n-                implementation_list = @RefCell::new(~[]);\n+                implementation_list = @RefCell::new(Vec::new());\n                 inherent_impls.get().insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n@@ -409,7 +411,7 @@ impl CoherenceChecker {\n         let mut trait_impls = tcx.trait_impls.borrow_mut();\n         match trait_impls.get().find(&base_def_id) {\n             None => {\n-                implementation_list = @RefCell::new(~[]);\n+                implementation_list = @RefCell::new(Vec::new());\n                 trait_impls.get().insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n@@ -611,7 +613,7 @@ impl CoherenceChecker {\n         let tcx = self.crate_context.tcx;\n         match item.node {\n             ItemImpl(_, ref trait_refs, _, ref ast_methods) => {\n-                let mut methods = ~[];\n+                let mut methods = Vec::new();\n                 for ast_method in ast_methods.iter() {\n                     methods.push(ty::method(tcx, local_def(ast_method.id)));\n                 }\n@@ -722,7 +724,7 @@ impl CoherenceChecker {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;\n             }\n-            let method_def_id = impl_info.methods[0].def_id;\n+            let method_def_id = impl_info.methods.get(0).def_id;\n \n             let self_type = self.get_self_type_for_implementation(*impl_info);\n             match ty::get(self_type.ty).sty {\n@@ -789,10 +791,10 @@ pub fn make_substs_for_receiver_types(tcx: ty::ctxt,\n         num_trait_type_parameters + method.generics.type_param_defs().len();\n \n     // the new method type will have the type parameters from the impl + method\n-    let combined_tps = vec::from_fn(num_method_type_parameters, |i| {\n+    let combined_tps = Vec::from_fn(num_method_type_parameters, |i| {\n         if i < num_trait_type_parameters {\n             // replace type parameters that come from trait with new value\n-            trait_ref.substs.tps[i]\n+            *trait_ref.substs.tps.get(i)\n         } else {\n             // replace type parameters that belong to method with another\n             // type parameter, this time with the index adjusted"}, {"sha": "18fbb47aad1b28c02c303be109f54ccf5225cf0e", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -46,6 +46,8 @@ use util::ppaux::Repr;\n \n use std::rc::Rc;\n use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::abi::AbiSet;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n@@ -324,7 +326,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let substs = substs {\n             regions: ty::NonerasedRegions(rps_from_trait),\n             self_ty: Some(self_param),\n-            tps: non_shifted_trait_tps + shifted_method_tps\n+            tps: vec_ng::append(Vec::from_slice(non_shifted_trait_tps),\n+                                shifted_method_tps)\n         };\n \n         // create the type of `foo`, applying the substitution above\n@@ -336,10 +339,11 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         // the substitution to any traits that appear in their bounds.\n \n         // add in the type parameters from the trait\n-        let mut new_type_param_defs = ~[];\n+        let mut new_type_param_defs = Vec::new();\n         let substd_type_param_defs =\n             trait_ty_generics.type_param_defs.subst(tcx, &substs);\n-        new_type_param_defs.push_all(*substd_type_param_defs.borrow());\n+        new_type_param_defs.push_all(substd_type_param_defs.borrow()\n+                                                           .as_slice());\n \n         // add in the \"self\" type parameter\n         let self_trait_def = get_trait_def(ccx, local_def(trait_id));\n@@ -349,14 +353,15 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n             def_id: dummy_defid,\n             bounds: @ty::ParamBounds {\n                 builtin_bounds: ty::EmptyBuiltinBounds(),\n-                trait_bounds: ~[self_trait_ref]\n+                trait_bounds: vec!(self_trait_ref)\n             },\n             default: None\n         });\n \n         // add in the type parameters from the method\n         let substd_type_param_defs = m.generics.type_param_defs.subst(tcx, &substs);\n-        new_type_param_defs.push_all(*substd_type_param_defs.borrow());\n+        new_type_param_defs.push_all(substd_type_param_defs.borrow()\n+                                                           .as_slice());\n \n         debug!(\"static method {} type_param_defs={} ty={}, substs={}\",\n                m.def_id.repr(tcx),\n@@ -420,7 +425,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n     }\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n-    let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n+    let mut ty_trait_refs: Vec<@ty::TraitRef> = Vec::new();\n     let mut bounds = ty::EmptyBuiltinBounds();\n     for ast_trait_ref in ast_trait_refs.iter() {\n         let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, ast_trait_ref);\n@@ -494,8 +499,9 @@ fn convert_methods(ccx: &CrateCtxt,\n                 // itself\n                 ty_param_bounds_and_ty {\n                     generics: ty::Generics {\n-                        type_param_defs: Rc::new(vec::append(\n-                            rcvr_ty_generics.type_param_defs().to_owned(),\n+                        type_param_defs: Rc::new(vec_ng::append(\n+                            Vec::from_slice(\n+                                rcvr_ty_generics.type_param_defs()),\n                             m_ty_generics.type_param_defs())),\n                         region_param_defs: rcvr_ty_generics.region_param_defs.clone(),\n                     },\n@@ -860,7 +866,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             let tpt = ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: ty_generics.type_param_defs.clone(),\n-                    region_param_defs: Rc::new(~[]),\n+                    region_param_defs: Rc::new(Vec::new()),\n                 },\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n             };\n@@ -946,8 +952,8 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n         ast::ForeignItemStatic(t, _) => {\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n-                    type_param_defs: Rc::new(~[]),\n-                    region_param_defs: Rc::new(~[]),\n+                    type_param_defs: Rc::new(Vec::new()),\n+                    region_param_defs: Rc::new(Vec::new()),\n                 },\n                 ty: ast_ty_to_ty(ccx, &ExplicitRscope, t)\n             }\n@@ -1008,7 +1014,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n \n         let mut param_bounds = ty::ParamBounds {\n             builtin_bounds: ty::EmptyBuiltinBounds(),\n-            trait_bounds: ~[]\n+            trait_bounds: Vec::new()\n         };\n         for ast_bound in ast_bounds.iter() {\n             match *ast_bound {\n@@ -1083,7 +1089,7 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n                       ty_generics: &ty::Generics,\n                       self_ty: Option<ty::t>) -> ty::substs\n {\n-    let params: ~[ty::t] =\n+    let params: Vec<ty::t> =\n         ty_generics.type_param_defs().iter().enumerate().map(\n             |(i, t)| ty::mk_param(ccx.tcx, i, t.def_id)).collect();\n "}, {"sha": "32b6da40b085577643871a60857e5964ca85efac", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -63,6 +63,7 @@ use util::common::indent;\n use util::ppaux::Repr;\n \n use std::result;\n+use std::vec_ng::Vec;\n use syntax::ast::{Onceness, Purity};\n use syntax::ast;\n use syntax::opt_vec;\n@@ -82,7 +83,7 @@ pub trait Combine {\n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n \n-    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n+    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<Vec<ty::t> > {\n \n         // Note: type parameters are always treated as *invariant*\n         // (otherwise the type system would be unsound).  In the\n@@ -92,7 +93,7 @@ pub trait Combine {\n         if as_.len() == bs.len() {\n             result::fold_(as_.iter().zip(bs.iter())\n                           .map(|(a, b)| eq_tys(self, *a, *b)))\n-                .then(|| Ok(as_.to_owned()))\n+                .then(|| Ok(Vec::from_slice(as_)))\n         } else {\n             Err(ty::terr_ty_param_size(expected_found(self,\n                                                       as_.len(),\n@@ -180,7 +181,7 @@ pub trait Combine {\n             }\n         }\n \n-        let tps = if_ok!(self.tps(as_.tps, bs.tps));\n+        let tps = if_ok!(self.tps(as_.tps.as_slice(), bs.tps.as_slice()));\n         let self_ty = if_ok!(self.self_tys(as_.self_ty, bs.self_ty));\n         let regions = if_ok!(relate_region_params(self,\n                                                   item_def_id,\n@@ -396,7 +397,7 @@ pub fn eq_opt_regions<C:Combine>(\n \n pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n \n-    fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<~[ty::t]> {\n+    fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<Vec<ty::t> > {\n         if a_args.len() == b_args.len() {\n             result::collect(a_args.iter().zip(b_args.iter())\n                             .map(|(a, b)| this.args(*a, *b)))\n@@ -409,7 +410,9 @@ pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<\n         return Err(ty::terr_variadic_mismatch(expected_found(this, a.variadic, b.variadic)));\n     }\n \n-    let inputs = if_ok!(argvecs(this, a.inputs, b.inputs));\n+    let inputs = if_ok!(argvecs(this,\n+                                a.inputs.as_slice(),\n+                                b.inputs.as_slice()));\n     let output = if_ok!(this.tys(a.output, b.output));\n     Ok(FnSig {binder_id: a.binder_id,\n               inputs: inputs,"}, {"sha": "68b609000f41b08db67fdda9dc4e0568fb152cb4", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -155,10 +155,16 @@ impl<'f> Combine for Glb<'f> {\n             fold_regions_in_sig(\n                 self.get_ref().infcx.tcx,\n                 &sig0,\n-                |r| generalize_region(self, snapshot,\n-                                      new_vars, sig0.binder_id,\n-                                      &a_map, a_vars, b_vars,\n-                                      r));\n+                |r| {\n+                generalize_region(self,\n+                                  snapshot,\n+                                  new_vars.as_slice(),\n+                                  sig0.binder_id,\n+                                  &a_map,\n+                                  a_vars.as_slice(),\n+                                  b_vars.as_slice(),\n+                                  r)\n+            });\n         debug!(\"sig1 = {}\", sig1.inf_str(self.get_ref().infcx));\n         return Ok(sig1);\n "}, {"sha": "a97f1561c8dbb9dbe9f6d7d927a67c6fd44ab30f", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -43,9 +43,11 @@ use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::unify::*;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n-use collections::HashMap;\n use util::common::indenter;\n \n+use collections::HashMap;\n+use std::vec_ng::Vec;\n+\n pub trait LatticeValue {\n     fn sub(cf: &CombineFields, a: &Self, b: &Self) -> ures;\n     fn lub(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n@@ -522,7 +524,7 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n \n pub fn var_ids<T:Combine>(this: &T,\n                           map: &HashMap<ty::BoundRegion, ty::Region>)\n-                          -> ~[RegionVid] {\n+                          -> Vec<RegionVid> {\n     map.iter().map(|(_, r)| match *r {\n             ty::ReInfer(ty::ReVar(r)) => { r }\n             r => {"}, {"sha": "0f2b2da397e9d128f39c6f3acdb91b21a5e34b96", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -143,7 +143,7 @@ impl<'f> Combine for Lub<'f> {\n             fold_regions_in_sig(\n                 self.get_ref().infcx.tcx,\n                 &sig0,\n-                |r| generalize_region(self, snapshot, new_vars,\n+                |r| generalize_region(self, snapshot, new_vars.as_slice(),\n                                       sig0.binder_id, &a_map, r));\n         return Ok(sig1);\n "}, {"sha": "5500d9afc6750affc7b90ca9f53e2eeeba851937", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -21,6 +21,7 @@ pub use middle::typeck::infer::resolve::{resolve_ivar, resolve_all};\n pub use middle::typeck::infer::resolve::{resolve_nested_tvar};\n pub use middle::typeck::infer::resolve::{resolve_rvar};\n \n+use collections::HashMap;\n use collections::SmallIntMap;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty;\n@@ -37,9 +38,8 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::infer::error_reporting::ErrorReporting;\n use std::cell::{Cell, RefCell};\n-use collections::HashMap;\n use std::result;\n-use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap;\n@@ -260,7 +260,7 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n fn new_ValsAndBindings<V:Clone,T:Clone>() -> ValsAndBindings<V, T> {\n     ValsAndBindings {\n         vals: SmallIntMap::new(),\n-        bindings: ~[]\n+        bindings: Vec::new()\n     }\n }\n \n@@ -622,8 +622,8 @@ impl InferCtxt {\n         ty::mk_var(self.tcx, self.next_ty_var_id())\n     }\n \n-    pub fn next_ty_vars(&self, n: uint) -> ~[ty::t] {\n-        vec::from_fn(n, |_i| self.next_ty_var())\n+    pub fn next_ty_vars(&self, n: uint) -> Vec<ty::t> {\n+        Vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -659,8 +659,8 @@ impl InferCtxt {\n     pub fn next_region_vars(&self,\n                             origin: RegionVariableOrigin,\n                             count: uint)\n-                            -> ~[ty::Region] {\n-        vec::from_fn(count, |_| self.next_region_var(origin))\n+                            -> Vec<ty::Region> {\n+        Vec::from_fn(count, |_| self.next_region_var(origin))\n     }\n \n     pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {"}, {"sha": "57168eaec89099b30f2fbb1ff8a7908c009b8762", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -27,6 +27,7 @@ use util::ppaux::{Repr};\n use std::cell::{Cell, RefCell};\n use std::uint;\n use std::vec;\n+use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n use syntax::opt_vec;\n@@ -88,7 +89,7 @@ pub type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings {\n     tcx: ty::ctxt,\n-    var_origins: RefCell<~[RegionVariableOrigin]>,\n+    var_origins: RefCell<Vec<RegionVariableOrigin> >,\n     constraints: RefCell<HashMap<Constraint, SubregionOrigin>>,\n     lubs: RefCell<CombineMap>,\n     glbs: RefCell<CombineMap>,\n@@ -103,24 +104,24 @@ pub struct RegionVarBindings {\n     // actively snapshotting.  The reason for this is that otherwise\n     // we end up adding entries for things like the lower bound on\n     // a variable and so forth, which can never be rolled back.\n-    undo_log: RefCell<~[UndoLogEntry]>,\n+    undo_log: RefCell<Vec<UndoLogEntry> >,\n \n     // This contains the results of inference.  It begins as an empty\n     // option and only acquires a value after inference is complete.\n-    values: RefCell<Option<~[VarValue]>>,\n+    values: RefCell<Option<Vec<VarValue> >>,\n }\n \n pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     RegionVarBindings {\n         tcx: tcx,\n-        var_origins: RefCell::new(~[]),\n+        var_origins: RefCell::new(Vec::new()),\n         values: RefCell::new(None),\n         constraints: RefCell::new(HashMap::new()),\n         lubs: RefCell::new(HashMap::new()),\n         glbs: RefCell::new(HashMap::new()),\n         skolemization_count: Cell::new(0),\n         bound_count: Cell::new(0),\n-        undo_log: RefCell::new(~[])\n+        undo_log: RefCell::new(Vec::new())\n     }\n }\n \n@@ -354,11 +355,11 @@ impl RegionVarBindings {\n             None => {\n                 let var_origins = self.var_origins.borrow();\n                 self.tcx.sess.span_bug(\n-                    var_origins.get()[rid.to_uint()].span(),\n+                    var_origins.get().get(rid.to_uint()).span(),\n                     format!(\"attempt to resolve region variable before \\\n                              values have been computed!\"))\n             }\n-            Some(ref values) => values[rid.to_uint()]\n+            Some(ref values) => *values.get(rid.to_uint())\n         };\n \n         debug!(\"RegionVarBindings: resolve_var({:?}={})={:?}\",\n@@ -423,7 +424,7 @@ impl RegionVarBindings {\n     }\n \n     pub fn vars_created_since_snapshot(&self, snapshot: uint)\n-                                       -> ~[RegionVid] {\n+                                       -> Vec<RegionVid> {\n         let undo_log = self.undo_log.borrow();\n         undo_log.get().slice_from(snapshot).iter()\n             .filter_map(|&elt| match elt {\n@@ -433,7 +434,7 @@ impl RegionVarBindings {\n             .collect()\n     }\n \n-    pub fn tainted(&self, snapshot: uint, r0: Region) -> ~[Region] {\n+    pub fn tainted(&self, snapshot: uint, r0: Region) -> Vec<Region> {\n         /*!\n          * Computes all regions that have been related to `r0` in any\n          * way since the snapshot `snapshot` was taken---`r0` itself\n@@ -453,11 +454,11 @@ impl RegionVarBindings {\n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n-        let mut result_set = ~[r0];\n+        let mut result_set = vec!(r0);\n         let mut result_index = 0;\n         while result_index < result_set.len() {\n             // nb: can't use uint::range() here because result_set grows\n-            let r = result_set[result_index];\n+            let r = *result_set.get(result_index);\n \n             debug!(\"result_index={}, r={:?}\", result_index, r);\n \n@@ -466,18 +467,18 @@ impl RegionVarBindings {\n                 // nb: can't use uint::range() here as we move result_set\n                 let regs = {\n                     let undo_log = self.undo_log.borrow();\n-                    match undo_log.get()[undo_index] {\n-                        AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n+                    match undo_log.get().get(undo_index) {\n+                        &AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n                             Some((ReInfer(ReVar(*a)),\n                                   ReInfer(ReVar(*b))))\n                         }\n-                        AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n+                        &AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n                             Some((*a, ReInfer(ReVar(*b))))\n                         }\n-                        AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n+                        &AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n                             Some((ReInfer(ReVar(*a)), *b))\n                         }\n-                        AddConstraint(ConstrainRegSubReg(a, b)) => {\n+                        &AddConstraint(ConstrainRegSubReg(a, b)) => {\n                             Some((a, b))\n                         }\n                         _ => {\n@@ -504,11 +505,10 @@ impl RegionVarBindings {\n \n         return result_set;\n \n-        fn consider_adding_edge(result_set: ~[Region],\n+        fn consider_adding_edge(result_set: Vec<Region> ,\n                                 r: Region,\n                                 r1: Region,\n-                                r2: Region) -> ~[Region]\n-        {\n+                                r2: Region) -> Vec<Region> {\n             let mut result_set = result_set;\n             if r == r1 { // Clearly, this is potentially inefficient.\n                 if !result_set.iter().any(|x| *x == r2) {\n@@ -564,7 +564,7 @@ impl RegionVarBindings {\n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             let var_origins = self.var_origins.borrow();\n             self.tcx.sess.span_bug(\n-                var_origins.get()[v_id.to_uint()].span(),\n+                var_origins.get().get(v_id.to_uint()).span(),\n                 format!(\"lub_concrete_regions invoked with \\\n                       non-concrete regions: {:?}, {:?}\", a, b));\n           }\n@@ -669,7 +669,7 @@ impl RegionVarBindings {\n             (_, ReInfer(ReVar(v_id))) => {\n                 let var_origins = self.var_origins.borrow();\n                 self.tcx.sess.span_bug(\n-                    var_origins.get()[v_id.to_uint()].span(),\n+                    var_origins.get().get(v_id.to_uint()).span(),\n                     format!(\"glb_concrete_regions invoked with \\\n                           non-concrete regions: {:?}, {:?}\", a, b));\n             }\n@@ -781,16 +781,16 @@ type RegionGraph = graph::Graph<(), Constraint>;\n impl RegionVarBindings {\n     fn infer_variable_values(&self,\n                              errors: &mut OptVec<RegionResolutionError>)\n-                             -> ~[VarValue] {\n+                             -> Vec<VarValue> {\n         let mut var_data = self.construct_var_data();\n-        self.expansion(var_data);\n-        self.contraction(var_data);\n-        self.collect_concrete_region_errors(errors);\n-        self.extract_values_and_collect_conflicts(var_data, errors)\n+        self.expansion(var_data.as_mut_slice());\n+        self.contraction(var_data.as_mut_slice());\n+        self.collect_concrete_region_errors(&mut *errors);\n+        self.extract_values_and_collect_conflicts(var_data.as_slice(), errors)\n     }\n \n-    fn construct_var_data(&self) -> ~[VarData] {\n-        vec::from_fn(self.num_vars(), |_| {\n+    fn construct_var_data(&self) -> Vec<VarData> {\n+        Vec::from_fn(self.num_vars(), |_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n@@ -999,8 +999,7 @@ impl RegionVarBindings {\n         &self,\n         var_data: &[VarData],\n         errors: &mut OptVec<RegionResolutionError>)\n-        -> ~[VarValue]\n-    {\n+        -> Vec<VarValue> {\n         debug!(\"extract_values_and_collect_conflicts()\");\n \n         // This is the best way that I have found to suppress\n@@ -1073,7 +1072,7 @@ impl RegionVarBindings {\n             }\n         }\n \n-        vec::from_fn(self.num_vars(), |idx| var_data[idx].value)\n+        Vec::from_fn(self.num_vars(), |idx| var_data[idx].value)\n     }\n \n     fn construct_graph(&self) -> RegionGraph {\n@@ -1145,7 +1144,7 @@ impl RegionVarBindings {\n                     {\n                         let var_origins = self.var_origins.borrow();\n                         errors.push(SubSupConflict(\n-                            var_origins.get()[node_idx.to_uint()],\n+                            *var_origins.get().get(node_idx.to_uint()),\n                             lower_bound.origin,\n                             lower_bound.region,\n                             upper_bound.origin,\n@@ -1158,7 +1157,7 @@ impl RegionVarBindings {\n \n         let var_origins = self.var_origins.borrow();\n         self.tcx.sess.span_bug(\n-            var_origins.get()[node_idx.to_uint()].span(),\n+            var_origins.get().get(node_idx.to_uint()).span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n                   for var {:?}, lower_bounds={}, upper_bounds={}\",\n                  node_idx,\n@@ -1192,7 +1191,7 @@ impl RegionVarBindings {\n                   Err(_) => {\n                     let var_origins = self.var_origins.borrow();\n                     errors.push(SupSupConflict(\n-                        var_origins.get()[node_idx.to_uint()],\n+                        *var_origins.get().get(node_idx.to_uint()),\n                         upper_bound_1.origin,\n                         upper_bound_1.region,\n                         upper_bound_2.origin,\n@@ -1205,7 +1204,7 @@ impl RegionVarBindings {\n \n         let var_origins = self.var_origins.borrow();\n         self.tcx.sess.span_bug(\n-            var_origins.get()[node_idx.to_uint()].span(),\n+            var_origins.get().get(node_idx.to_uint()).span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                   for var {:?}, upper_bounds={}\",\n                  node_idx,\n@@ -1218,17 +1217,17 @@ impl RegionVarBindings {\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n                                 dup_vec: &mut [uint])\n-                                -> (~[RegionAndOrigin], bool) {\n+                                -> (Vec<RegionAndOrigin> , bool) {\n         struct WalkState {\n             set: HashSet<RegionVid>,\n-            stack: ~[RegionVid],\n-            result: ~[RegionAndOrigin],\n+            stack: Vec<RegionVid> ,\n+            result: Vec<RegionAndOrigin> ,\n             dup_found: bool\n         }\n         let mut state = WalkState {\n             set: HashSet::new(),\n-            stack: ~[orig_node_idx],\n-            result: ~[],\n+            stack: vec!(orig_node_idx),\n+            result: Vec::new(),\n             dup_found: false\n         };\n         state.set.insert(orig_node_idx);"}, {"sha": "d4ee567ba41b7ffaa1a893a8d7fea48cf4cb3930", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -58,6 +58,7 @@ use middle::typeck::infer::unify::{Root, UnifyInferCtxtMethods};\n use util::common::{indent, indenter};\n use util::ppaux::ty_to_str;\n \n+use std::vec_ng::Vec;\n use syntax::ast;\n \n pub static resolve_nested_tvar: uint = 0b0000000001;\n@@ -83,7 +84,7 @@ pub struct ResolveState<'a> {\n     infcx: &'a InferCtxt,\n     modes: uint,\n     err: Option<fixup_err>,\n-    v_seen: ~[TyVid],\n+    v_seen: Vec<TyVid> ,\n     type_depth: uint\n }\n \n@@ -92,7 +93,7 @@ pub fn resolver<'a>(infcx: &'a InferCtxt, modes: uint) -> ResolveState<'a> {\n         infcx: infcx,\n         modes: modes,\n         err: None,\n-        v_seen: ~[],\n+        v_seen: Vec::new(),\n         type_depth: 0\n     }\n }"}, {"sha": "a3f44c9a06906a4961c0de5c359c6a6e20e17b5d", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -46,7 +46,7 @@ static EMPTY_SOURCE_STR: &str = \"/* Hello, world! */\";\n \n fn setup_env(test_name: &str, source_string: &str) -> Env {\n     let messages = @DVec();\n-    let matches = getopts(~[~\"-Z\", ~\"verbose\"], optgroups()).get();\n+    let matches = getopts(vec!(~\"-Z\", ~\"verbose\"), optgroups()).get();\n     let diag = diagnostic::collect(messages);\n     let sessopts = build_session_options(~\"rustc\", &matches, diag);\n     let sess = build_session(sessopts, None, diag);\n@@ -186,7 +186,7 @@ impl Env {\n                           proto: ast::ProtoBare,\n                           onceness: ast::Many,\n                           region: ty::ReStatic,\n-                          bounds: @~[]},\n+                          bounds: @Vec::new()},\n             sig: FnSig {\n                 inputs: inputs,\n                 output: output_ty,"}, {"sha": "b58fa905ca4eb1dc25abf3cd77d1d8ada4b1c3f7", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -17,6 +17,7 @@ use middle::typeck::infer::{Bounds, uok, ures};\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::to_str::InferStr;\n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use syntax::ast;\n \n #[deriving(Clone)]\n@@ -27,7 +28,7 @@ pub enum VarValue<V, T> {\n \n pub struct ValsAndBindings<V, T> {\n     vals: SmallIntMap<VarValue<V, T>>,\n-    bindings: ~[(V, VarValue<V, T>)],\n+    bindings: Vec<(V, VarValue<V, T>)> ,\n }\n \n pub struct Node<V, T> {"}, {"sha": "86f642a228d89104926daf3e460faaa0f45ee1b7", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -72,6 +72,7 @@ use util::nodemap::{DefIdMap, NodeMap};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n use collections::List;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n@@ -152,9 +153,9 @@ pub struct MethodCallee {\n // of the method to be invoked\n pub type MethodMap = @RefCell<NodeMap<MethodCallee>>;\n \n-pub type vtable_param_res = @~[vtable_origin];\n+pub type vtable_param_res = @Vec<vtable_origin> ;\n // Resolutions for bounds of all parameters, left to right, for a given path.\n-pub type vtable_res = @~[vtable_param_res];\n+pub type vtable_res = @Vec<vtable_param_res> ;\n \n #[deriving(Clone)]\n pub enum vtable_origin {\n@@ -163,7 +164,7 @@ pub enum vtable_origin {\n       from whence comes the vtable, and tys are the type substs.\n       vtable_res is the vtable itself\n      */\n-    vtable_static(ast::DefId, ~[ty::t], vtable_res),\n+    vtable_static(ast::DefId, Vec<ty::t> , vtable_res),\n \n     /*\n       Dynamic vtable, comes from a parameter that has a bound on it:\n@@ -235,7 +236,7 @@ pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n                            node_id: ast::NodeId,\n-                           substs: ~[ty::t]) {\n+                           substs: Vec<ty::t> ) {\n     if substs.len() > 0u {\n         debug!(\"write_substs_to_tcx({}, {:?})\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n@@ -271,8 +272,8 @@ pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n \n pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {type_param_defs: Rc::new(~[]),\n-                                region_param_defs: Rc::new(~[])},\n+        generics: ty::Generics {type_param_defs: Rc::new(Vec::new()),\n+                                region_param_defs: Rc::new(Vec::new())},\n         ty: t\n     }\n }\n@@ -352,7 +353,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {\n                     binder_id: main_id,\n-                    inputs: ~[],\n+                    inputs: Vec::new(),\n                     output: ty::mk_nil(),\n                     variadic: false\n                 }\n@@ -398,10 +399,10 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {\n                     binder_id: start_id,\n-                    inputs: ~[\n+                    inputs: vec!(\n                         ty::mk_int(),\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))\n-                    ],\n+                    ),\n                     output: ty::mk_int(),\n                     variadic: false\n                 }"}, {"sha": "eb633eb2eee01012f184fd0d263cc2ab1bf0cadd", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -12,7 +12,7 @@\n use middle::ty;\n \n use std::cell::Cell;\n-use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n@@ -31,7 +31,7 @@ pub trait RegionScope {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: uint)\n-                    -> Result<~[ty::Region], ()>;\n+                    -> Result<Vec<ty::Region> , ()>;\n }\n \n // A scope in which all regions must be explicitly named\n@@ -41,7 +41,7 @@ impl RegionScope for ExplicitRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: uint)\n-                    -> Result<~[ty::Region], ()> {\n+                    -> Result<Vec<ty::Region> , ()> {\n         Err(())\n     }\n }\n@@ -66,10 +66,10 @@ impl RegionScope for BindingRscope {\n     fn anon_regions(&self,\n                     _: Span,\n                     count: uint)\n-                    -> Result<~[ty::Region], ()> {\n+                    -> Result<Vec<ty::Region> , ()> {\n         let idx = self.anon_bindings.get();\n         self.anon_bindings.set(idx + count);\n-        Ok(vec::from_fn(count, |i| ty::ReLateBound(self.binder_id,\n+        Ok(Vec::from_fn(count, |i| ty::ReLateBound(self.binder_id,\n                                                    ty::BrAnon(idx + i))))\n     }\n }"}, {"sha": "3712f04635878c680b40fa7ff1818d325c0b1f4e", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -196,8 +196,8 @@ use collections::HashMap;\n use arena;\n use arena::Arena;\n use middle::ty;\n-use std::vec;\n use std::fmt;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::opt_vec;\n@@ -261,7 +261,7 @@ struct TermsContext<'a> {\n     inferred_map: HashMap<ast::NodeId, InferredIndex>,\n \n     // Maps from an InferredIndex to the info for that variable.\n-    inferred_infos: ~[InferredInfo<'a>],\n+    inferred_infos: Vec<InferredInfo<'a>> ,\n }\n \n enum ParamKind { TypeParam, RegionParam, SelfParam }\n@@ -282,7 +282,7 @@ fn determine_parameters_to_be_inferred<'a>(tcx: ty::ctxt,\n         tcx: tcx,\n         arena: arena,\n         inferred_map: HashMap::new(),\n-        inferred_infos: ~[],\n+        inferred_infos: Vec::new(),\n \n         // cache and share the variance struct used for items with\n         // no type/region parameters\n@@ -410,7 +410,7 @@ struct ConstraintContext<'a> {\n     invariant: VarianceTermPtr<'a>,\n     bivariant: VarianceTermPtr<'a>,\n \n-    constraints: ~[Constraint<'a>],\n+    constraints: Vec<Constraint<'a>> ,\n }\n \n /// Declares that the variable `decl_id` appears in a location with\n@@ -457,7 +457,7 @@ fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n         contravariant: contravariant,\n         invariant: invariant,\n         bivariant: bivariant,\n-        constraints: ~[],\n+        constraints: Vec::new(),\n     };\n     visit::walk_crate(&mut constraint_cx, krate, ());\n     constraint_cx\n@@ -561,7 +561,7 @@ impl<'a> ConstraintContext<'a> {\n             // variance not yet inferred, so return a symbolic\n             // variance.\n             let InferredIndex(index) = self.inferred_index(param_def_id.node);\n-            self.terms_cx.inferred_infos[index].term\n+            self.terms_cx.inferred_infos.get(index).term\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n@@ -749,7 +749,7 @@ impl<'a> ConstraintContext<'a> {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam, i);\n             let variance_i = self.xform(variance, variance_decl);\n-            self.add_constraints_from_ty(substs.tps[i], variance_i);\n+            self.add_constraints_from_ty(*substs.tps.get(i), variance_i);\n         }\n \n         match substs.regions {\n@@ -835,15 +835,14 @@ impl<'a> ConstraintContext<'a> {\n \n struct SolveContext<'a> {\n     terms_cx: TermsContext<'a>,\n-    constraints: ~[Constraint<'a>],\n+    constraints: Vec<Constraint<'a>> ,\n \n     // Maps from an InferredIndex to the inferred value for that variable.\n-    solutions: ~[ty::Variance]\n-}\n+    solutions: Vec<ty::Variance> }\n \n fn solve_constraints(constraints_cx: ConstraintContext) {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n-    let solutions = vec::from_elem(terms_cx.num_inferred(), ty::Bivariant);\n+    let solutions = Vec::from_elem(terms_cx.num_inferred(), ty::Bivariant);\n     let mut solutions_cx = SolveContext {\n         terms_cx: terms_cx,\n         constraints: constraints,\n@@ -868,18 +867,21 @@ impl<'a> SolveContext<'a> {\n                 let Constraint { inferred, variance: term } = *constraint;\n                 let InferredIndex(inferred) = inferred;\n                 let variance = self.evaluate(term);\n-                let old_value = self.solutions[inferred];\n+                let old_value = *self.solutions.get(inferred);\n                 let new_value = glb(variance, old_value);\n                 if old_value != new_value {\n                     debug!(\"Updating inferred {} (node {}) \\\n                             from {:?} to {:?} due to {}\",\n                             inferred,\n-                            self.terms_cx.inferred_infos[inferred].param_id,\n+                            self.terms_cx\n+                                .inferred_infos\n+                                .get(inferred)\n+                                .param_id,\n                             old_value,\n                             new_value,\n                             term.to_str());\n \n-                    self.solutions[inferred] = new_value;\n+                    *self.solutions.get_mut(inferred) = new_value;\n                     changed = true;\n                 }\n             }\n@@ -902,25 +904,28 @@ impl<'a> SolveContext<'a> {\n         let mut index = 0;\n         let num_inferred = self.terms_cx.num_inferred();\n         while index < num_inferred {\n-            let item_id = inferred_infos[index].item_id;\n+            let item_id = inferred_infos.get(index).item_id;\n             let mut item_variances = ty::ItemVariances {\n                 self_param: None,\n                 type_params: opt_vec::Empty,\n                 region_params: opt_vec::Empty\n             };\n             while index < num_inferred &&\n-                  inferred_infos[index].item_id == item_id {\n-                let info = &inferred_infos[index];\n+                  inferred_infos.get(index).item_id == item_id {\n+                let info = inferred_infos.get(index);\n                 match info.kind {\n                     SelfParam => {\n                         assert!(item_variances.self_param.is_none());\n-                        item_variances.self_param = Some(solutions[index]);\n+                        item_variances.self_param =\n+                            Some(*solutions.get(index));\n                     }\n                     TypeParam => {\n-                        item_variances.type_params.push(solutions[index]);\n+                        item_variances.type_params\n+                                      .push(*solutions.get(index));\n                     }\n                     RegionParam => {\n-                        item_variances.region_params.push(solutions[index]);\n+                        item_variances.region_params\n+                                      .push(*solutions.get(index));\n                     }\n                 }\n                 index += 1;\n@@ -959,7 +964,7 @@ impl<'a> SolveContext<'a> {\n             }\n \n             InferredTerm(InferredIndex(index)) => {\n-                self.solutions[index]\n+                *self.solutions.get(index)\n             }\n         }\n     }"}, {"sha": "fb417390905ae7f3d12ba7b4c1f4340b25b3be24", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -16,6 +16,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::local_data;\n+use std::vec_ng::Vec;\n \n use time;\n \n@@ -66,7 +67,7 @@ pub fn indenter() -> _indenter {\n \n pub fn field_expr(f: ast::Field) -> @ast::Expr { return f.expr; }\n \n-pub fn field_exprs(fields: ~[ast::Field]) -> ~[@ast::Expr] {\n+pub fn field_exprs(fields: Vec<ast::Field> ) -> Vec<@ast::Expr> {\n     fields.map(|f| f.expr)\n }\n "}, {"sha": "ecba394b88e244e3896fe6a603efd694d604470a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -22,6 +22,8 @@ use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_self, ty_tup};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_unboxed_vec, ty_infer};\n use middle::ty;\n use middle::typeck;\n+\n+use std::vec_ng::Vec;\n use syntax::abi::AbiSet;\n use syntax::ast_map;\n use syntax::codemap::{Span, Pos};\n@@ -476,12 +478,17 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_self(..) => ~\"Self\",\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n         let base = ty::item_path_str(cx, did);\n-        parameterized(cx, base, &substs.regions, substs.tps, did, false)\n+        parameterized(cx,\n+                      base,\n+                      &substs.regions,\n+                      substs.tps.as_slice(),\n+                      did,\n+                      false)\n       }\n       ty_trait(did, ref substs, s, mutbl, ref bounds) => {\n         let base = ty::item_path_str(cx, did);\n         let ty = parameterized(cx, base, &substs.regions,\n-                               substs.tps, did, true);\n+                               substs.tps.as_slice(), did, true);\n         let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n         let bound_str = bounds.repr(cx);\n         format!(\"{}{}{}{}{}\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty,\n@@ -501,7 +508,7 @@ pub fn parameterized(cx: ctxt,\n                      did: ast::DefId,\n                      is_trait: bool) -> ~str {\n \n-    let mut strs = ~[];\n+    let mut strs = Vec::new();\n     match *regions {\n         ty::ErasedRegions => { }\n         ty::NonerasedRegions(ref regions) => {\n@@ -521,7 +528,7 @@ pub fn parameterized(cx: ctxt,\n     let num_defaults = if has_defaults {\n         // We should have a borrowed version of substs instead of cloning.\n         let mut substs = ty::substs {\n-            tps: tps.to_owned(),\n+            tps: Vec::from_slice(tps),\n             regions: regions.clone(),\n             self_ty: None\n         };\n@@ -610,9 +617,9 @@ impl<T:Repr> Repr for OptVec<T> {\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n-impl<T:Repr> Repr for ~[T] {\n+impl<T:Repr> Repr for Vec<T> {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        repr_vec(tcx, *self)\n+        repr_vec(tcx, self.as_slice())\n     }\n }\n \n@@ -658,7 +665,7 @@ impl Repr for ty::RegionSubsts {\n \n impl Repr for ty::ParamBounds {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        let mut res = ~[];\n+        let mut res = Vec::new();\n         for b in self.builtin_bounds.iter() {\n             res.push(match b {\n                 ty::BoundStatic => ~\"'static\",\n@@ -973,7 +980,7 @@ impl<A:UserString> UserString for @A {\n impl UserString for ty::BuiltinBounds {\n     fn user_string(&self, tcx: ctxt) -> ~str {\n         if self.is_empty() { ~\"<no-bounds>\" } else {\n-            let mut result = ~[];\n+            let mut result = Vec::new();\n             for bb in self.iter() {\n                 result.push(bb.user_string(tcx));\n             }\n@@ -989,10 +996,10 @@ impl UserString for ty::TraitRef {\n             let mut all_tps = self.substs.tps.clone();\n             for &t in self.substs.self_ty.iter() { all_tps.push(t); }\n             parameterized(tcx, base, &self.substs.regions,\n-                          all_tps, self.def_id, true)\n+                          all_tps.as_slice(), self.def_id, true)\n         } else {\n             parameterized(tcx, base, &self.substs.regions,\n-                          self.substs.tps, self.def_id, true)\n+                          self.substs.tps.as_slice(), self.def_id, true)\n         }\n     }\n }"}, {"sha": "c5e75b52bf33c819a8457cb2204d7fdcbcba5fc1", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -14,8 +14,8 @@\n \n use std::iter::range_step;\n use std::num::Zero;\n-use std::vec;\n use std::vec::bytes::{MutableByteVector, copy_memory};\n+use std::vec_ng::Vec;\n use serialize::hex::ToHex;\n \n /// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n@@ -253,16 +253,16 @@ pub trait Digest {\n \n     /// Convenience function that retrieves the result of a digest as a\n     /// newly allocated vec of bytes.\n-    fn result_bytes(&mut self) -> ~[u8] {\n-        let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n-        self.result(buf);\n+    fn result_bytes(&mut self) -> Vec<u8> {\n+        let mut buf = Vec::from_elem((self.output_bits()+7)/8, 0u8);\n+        self.result(buf.as_mut_slice());\n         buf\n     }\n \n     /// Convenience function that retrieves the result of a digest as a\n     /// ~str in hexadecimal format.\n     fn result_str(&mut self) -> ~str {\n-        self.result_bytes().to_hex()\n+        self.result_bytes().as_slice().to_hex()\n     }\n }\n \n@@ -527,6 +527,7 @@ mod tests {\n     use super::{Digest, Sha256, FixedBuffer};\n     use std::num::Bounded;\n     use std::vec;\n+    use std::vec_ng::Vec;\n     use std::rand::isaac::IsaacRng;\n     use std::rand::Rng;\n     use serialize::hex::FromHex;\n@@ -576,7 +577,7 @@ mod tests {\n     #[test]\n     fn test_sha256() {\n         // Examples from wikipedia\n-        let wikipedia_tests = ~[\n+        let wikipedia_tests = vec!(\n             Test {\n                 input: ~\"\",\n                 output_str: ~\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n@@ -588,14 +589,13 @@ mod tests {\n             Test {\n                 input: ~\"The quick brown fox jumps over the lazy dog.\",\n                 output_str: ~\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\"\n-            },\n-        ];\n+            });\n \n         let tests = wikipedia_tests;\n \n         let mut sh = ~Sha256::new();\n \n-        test_hash(sh, tests);\n+        test_hash(sh, tests.as_slice());\n     }\n \n     /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n@@ -620,7 +620,12 @@ mod tests {\n         let result_bytes = digest.result_bytes();\n \n         assert_eq!(expected, result_str.as_slice());\n-        assert_eq!(expected.from_hex().unwrap(), result_bytes);\n+\n+        let expected_vec: Vec<u8> = expected.from_hex()\n+                                            .unwrap()\n+                                            .move_iter()\n+                                            .collect();\n+        assert_eq!(expected_vec, result_bytes);\n     }\n \n     #[test]"}, {"sha": "f26977e211ca20d7a94827e7ef19cb8197d90808", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -110,6 +110,8 @@ impl Clean<ExternalCrate> for cstore::crate_metadata {\n         ExternalCrate {\n             name: self.name.to_owned(),\n             attrs: decoder::get_crate_attributes(self.data()).clean()\n+                                                             .move_iter()\n+                                                             .collect(),\n         }\n     }\n }"}, {"sha": "58bed8a9df993d495db52bb8163c93c960509b7f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -53,7 +53,7 @@ fn get_ast_and_resolve(cpath: &Path,\n     let sessopts = @driver::session::Options {\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: @RefCell::new(libs),\n-        crate_types: ~[driver::session::CrateTypeDylib],\n+        crate_types: vec!(driver::session::CrateTypeDylib),\n         .. (*rustc::driver::session::basic_options()).clone()\n     };\n "}, {"sha": "f34ce016f2825f526c319a00c03e1e7a0df78c40", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -44,7 +44,7 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n     let sessopts = @session::Options {\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: libs,\n-        crate_types: ~[session::CrateTypeDylib],\n+        crate_types: vec!(session::CrateTypeDylib),\n         .. (*session::basic_options()).clone()\n     };\n \n@@ -106,8 +106,8 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool)\n     let sessopts = @session::Options {\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: @RefCell::new(libs),\n-        crate_types: ~[session::CrateTypeExecutable],\n-        output_types: ~[link::OutputTypeExe],\n+        crate_types: vec!(session::CrateTypeExecutable),\n+        output_types: vec!(link::OutputTypeExe),\n         cg: session::CodegenOptions {\n             prefer_dynamic: true,\n             .. session::basic_codegen_options()"}, {"sha": "a195ce8deaebc977addfd1f1a0863991c575320c", "filename": "src/libstd/vec_ng.rs", "status": "modified", "additions": 131, "deletions": 2, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/001705610505065ff50502390af933e0b264853a/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001705610505065ff50502390af933e0b264853a/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=001705610505065ff50502390af933e0b264853a", "patch": "@@ -14,12 +14,13 @@\n use cast::{forget, transmute};\n use clone::Clone;\n use cmp::{Ord, Eq, Ordering, TotalEq, TotalOrd};\n-use container::Container;\n+use container::{Container, Mutable};\n use default::Default;\n use fmt;\n-use iter::{DoubleEndedIterator, FromIterator, Extendable, Iterator};\n+use iter::{DoubleEndedIterator, FromIterator, Extendable, Iterator, Rev};\n use libc::{free, c_void};\n use mem::{size_of, move_val_init};\n+use mem;\n use num;\n use num::{CheckedMul, CheckedAdd};\n use ops::Drop;\n@@ -66,6 +67,10 @@ impl<T> Vec<T> {\n }\n \n impl<T: Clone> Vec<T> {\n+    pub fn from_slice(values: &[T]) -> Vec<T> {\n+        values.iter().map(|x| x.clone()).collect()\n+    }\n+\n     pub fn from_elem(length: uint, value: T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -282,6 +287,11 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    #[inline]\n+    pub fn move_rev_iter(self) -> Rev<MoveItems<T>> {\n+        self.move_iter().rev()\n+    }\n+\n     #[inline]\n     pub unsafe fn set_len(&mut self, len: uint) {\n         self.len = len;\n@@ -322,6 +332,11 @@ impl<T> Vec<T> {\n         self.as_slice().tail()\n     }\n \n+    #[inline]\n+    pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n+        self.as_slice().tailn(n)\n+    }\n+\n     #[inline]\n     pub fn last<'a>(&'a self) -> Option<&'a T> {\n         self.as_slice().last()\n@@ -387,21 +402,135 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    #[inline]\n+    pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)\n+                     -> &'a mut [T] {\n+        self.as_mut_slice().mut_slice(start, end)\n+    }\n+\n+    #[inline]\n+    pub fn reverse(&mut self) {\n+        self.as_mut_slice().reverse()\n+    }\n+\n+    #[inline]\n     pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n         self.as_slice().slice_from(start)\n     }\n \n+    #[inline]\n+    pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n+        self.as_slice().slice_to(end)\n+    }\n+\n     #[inline]\n     pub fn init<'a>(&'a self) -> &'a [T] {\n         self.slice(0, self.len() - 1)\n     }\n+\n+    #[inline]\n+    pub fn as_ptr(&self) -> *T {\n+        self.as_slice().as_ptr()\n+    }\n+}\n+\n+impl<T> Mutable for Vec<T> {\n+    /// Clear the vector, removing all values.\n+    #[inline]\n+    fn clear(&mut self) {\n+        self.truncate(0)\n+    }\n }\n \n impl<T:Eq> Vec<T> {\n     /// Return true if a vector contains an element with the given value\n     pub fn contains(&self, x: &T) -> bool {\n         self.as_slice().contains(x)\n     }\n+\n+    pub fn dedup(&mut self) {\n+        unsafe {\n+            // Although we have a mutable reference to `self`, we cannot make\n+            // *arbitrary* changes. The `Eq` comparisons could fail, so we\n+            // must ensure that the vector is in a valid state at all time.\n+            //\n+            // The way that we handle this is by using swaps; we iterate\n+            // over all the elements, swapping as we go so that at the end\n+            // the elements we wish to keep are in the front, and those we\n+            // wish to reject are at the back. We can then truncate the\n+            // vector. This operation is still O(n).\n+            //\n+            // Example: We start in this state, where `r` represents \"next\n+            // read\" and `w` represents \"next_write`.\n+            //\n+            //           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //           w\n+            //\n+            // Comparing self[r] against self[w-1], tis is not a duplicate, so\n+            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n+            // r and w, leaving us with:\n+            //\n+            //               r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this value is a duplicate,\n+            // so we increment `r` but leave everything else unchanged:\n+            //\n+            //                   r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this is not a duplicate,\n+            // so swap self[r] and self[w] and advance r and w:\n+            //\n+            //                       r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                   w\n+            //\n+            // Not a duplicate, repeat:\n+            //\n+            //                           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                       w\n+            //\n+            // Duplicate, advance r. End of vec. Truncate to w.\n+\n+            let ln = self.len();\n+            if ln < 1 { return; }\n+\n+            // Avoid bounds checks by using unsafe pointers.\n+            let p = self.as_mut_slice().as_mut_ptr();\n+            let mut r = 1;\n+            let mut w = 1;\n+\n+            while r < ln {\n+                let p_r = p.offset(r as int);\n+                let p_wm1 = p.offset((w - 1) as int);\n+                if *p_r != *p_wm1 {\n+                    if r != w {\n+                        let p_w = p_wm1.offset(1);\n+                        mem::swap(&mut *p_r, &mut *p_w);\n+                    }\n+                    w += 1;\n+                }\n+                r += 1;\n+            }\n+\n+            self.truncate(w);\n+        }\n+    }\n }\n \n #[inline]"}]}