{"sha": "b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NWYwYmVkZDJmMjJkOTY2MWVjYjcwOTJmMDc3NDZkYzJjY2ZiMGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-01T19:04:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-01T19:04:33Z"}, "message": "Auto merge of #46735 - Manishearth:memchr-find, r=burntsushi\n\nUse memchr for str::find(char)\n\nThis is a 10x improvement for searching for characters.\n\nThis also contains the patches from https://github.com/rust-lang/rust/pull/46713 . Feel free to land both separately or together.\n\ncc @mystor @alexcrichton\n\nr? @bluss\n\nfixes #46693", "tree": {"sha": "142a5b0bdf6197e8a87847d881d9b8616494f3ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/142a5b0bdf6197e8a87847d881d9b8616494f3ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d", "html_url": "https://github.com/rust-lang/rust/commit/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5deba220d4c42b5313d7e71731ce5e8698866684", "url": "https://api.github.com/repos/rust-lang/rust/commits/5deba220d4c42b5313d7e71731ce5e8698866684", "html_url": "https://github.com/rust-lang/rust/commit/5deba220d4c42b5313d7e71731ce5e8698866684"}, {"sha": "5cf55165fae5c8538db5c00e252ad9ba42aaf246", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cf55165fae5c8538db5c00e252ad9ba42aaf246", "html_url": "https://github.com/rust-lang/rust/commit/5cf55165fae5c8538db5c00e252ad9ba42aaf246"}], "stats": {"total": 603, "additions": 519, "deletions": 84}, "files": [{"sha": "677c0ecc33d7f5baa8ee63da15d3e2905117de9f", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 253, "deletions": 84, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d", "patch": "@@ -19,6 +19,7 @@\n \n use cmp;\n use fmt;\n+use slice::memchr;\n use usize;\n \n // Pattern\n@@ -127,6 +128,11 @@ pub unsafe trait Searcher<'a> {\n     fn next(&mut self) -> SearchStep;\n \n     /// Find the next `Match` result. See `next()`\n+    ///\n+    /// Unlike next(), there is no guarantee that the returned ranges\n+    /// of this and next_reject will overlap. This will return (start_match, end_match),\n+    /// where start_match is the index of where the match begins, and end_match is\n+    /// the index after the end of the match.\n     #[inline]\n     fn next_match(&mut self) -> Option<(usize, usize)> {\n         loop {\n@@ -138,7 +144,10 @@ pub unsafe trait Searcher<'a> {\n         }\n     }\n \n-    /// Find the next `Reject` result. See `next()`\n+    /// Find the next `Reject` result. See `next()` and `next_match()`\n+    ///\n+    /// Unlike next(), there is no guarantee that the returned ranges\n+    /// of this and next_match will overlap.\n     #[inline]\n     fn next_reject(&mut self) -> Option<(usize, usize)> {\n         loop {\n@@ -234,70 +243,280 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n /// `\"[aa]a\"` or `\"a[aa]\"`, depending from which side it is searched.\n pub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}\n \n+\n /////////////////////////////////////////////////////////////////////////////\n-// Impl for a CharEq wrapper\n+// Impl for char\n /////////////////////////////////////////////////////////////////////////////\n \n-#[doc(hidden)]\n-trait CharEq {\n-    fn matches(&mut self, c: char) -> bool;\n-    fn only_ascii(&self) -> bool;\n+/// Associated type for `<char as Pattern<'a>>::Searcher`.\n+#[derive(Clone, Debug)]\n+pub struct CharSearcher<'a> {\n+    haystack: &'a str,\n+    // safety invariant: `finger`/`finger_back` must be a valid utf8 byte index of `haystack`\n+    // This invariant can be broken *within* next_match and next_match_back, however\n+    // they must exit with fingers on valid code point boundaries.\n+\n+    /// `finger` is the current byte index of the forward search.\n+    /// Imagine that it exists before the byte at its index, i.e.\n+    /// haystack[finger] is the first byte of the slice we must inspect during\n+    /// forward searching\n+    finger: usize,\n+    /// `finger_back` is the current byte index of the reverse search.\n+    /// Imagine that it exists after the byte at its index, i.e.\n+    /// haystack[finger_back - 1] is the last byte of the slice we must inspect during\n+    /// forward searching (and thus the first byte to be inspected when calling next_back())\n+    finger_back: usize,\n+    /// The character being searched for\n+    needle: char,\n+\n+    // safety invariant: `utf8_size` must be less than 5\n+    /// The number of bytes `needle` takes up when encoded in utf8\n+    utf8_size: usize,\n+    /// A utf8 encoded copy of the `needle`\n+    utf8_encoded: [u8; 4],\n }\n \n-impl CharEq for char {\n+unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n+    #[inline]\n+    fn haystack(&self) -> &'a str {\n+        self.haystack\n+    }\n+    #[inline]\n+    fn next(&mut self) -> SearchStep {\n+        let old_finger = self.finger;\n+        let slice = unsafe { self.haystack.get_unchecked(old_finger..self.haystack.len()) };\n+        let mut iter = slice.chars();\n+        let old_len = iter.iter.len();\n+        if let Some(ch) = iter.next() {\n+            // add byte offset of current character\n+            // without re-encoding as utf-8\n+            self.finger += old_len - iter.iter.len();\n+            if ch == self.needle {\n+                SearchStep::Match(old_finger, self.finger)\n+            } else {\n+                SearchStep::Reject(old_finger, self.finger)\n+            }\n+        } else {\n+            SearchStep::Done\n+        }\n+    }\n     #[inline]\n-    fn matches(&mut self, c: char) -> bool { *self == c }\n+    fn next_match(&mut self) -> Option<(usize, usize)> {\n+        loop {\n+            // get the haystack after the last character found\n+            let bytes = if let Some(slice) = self.haystack.as_bytes().get(self.finger..) {\n+                slice\n+            } else {\n+                return None;\n+            };\n+            // the last byte of the utf8 encoded needle\n+            let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n+            if let Some(index) = memchr::memchr(last_byte, bytes) {\n+                // The new finger is the index of the byte we found,\n+                // plus one, since we memchr'd for the last byte of the character.\n+                //\n+                // Note that this doesn't always give us a finger on a UTF8 boundary.\n+                // If we *didn't* find our character\n+                // we may have indexed to the non-last byte of a 3-byte or 4-byte character.\n+                // We can't just skip to the next valid starting byte because a character like\n+                // \ua041 (U+A041 YI SYLLABLE PA), utf-8 `EA 81 81` will have us always find\n+                // the second byte when searching for the third.\n+                //\n+                // However, this is totally okay. While we have the invariant that\n+                // self.finger is on a UTF8 boundary, this invariant is not relid upon\n+                // within this method (it is relied upon in CharSearcher::next()).\n+                //\n+                // We only exit this method when we reach the end of the string, or if we\n+                // find something. When we find something the `finger` will be set\n+                // to a UTF8 boundary.\n+                self.finger += index + 1;\n+                if self.finger >= self.utf8_size {\n+                    let found_char = self.finger - self.utf8_size;\n+                    if let Some(slice) = self.haystack.as_bytes().get(found_char..self.finger) {\n+                        if slice == &self.utf8_encoded[0..self.utf8_size] {\n+                            return Some((found_char, self.finger));\n+                        }\n+                    }\n+                }\n+            } else {\n+                // found nothing, exit\n+                self.finger = self.haystack.len();\n+                return None;\n+            }\n+        }\n+    }\n \n+    // let next_reject use the default implementation from the Searcher trait\n+}\n+\n+unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep {\n+        let old_finger = self.finger_back;\n+        let slice = unsafe { self.haystack.slice_unchecked(0, old_finger) };\n+        let mut iter = slice.chars();\n+        let old_len = iter.iter.len();\n+        if let Some(ch) = iter.next_back() {\n+            // subtract byte offset of current character\n+            // without re-encoding as utf-8\n+            self.finger_back -= old_len - iter.iter.len();\n+            if ch == self.needle {\n+                SearchStep::Match(self.finger_back, old_finger)\n+            } else {\n+                SearchStep::Reject(self.finger_back, old_finger)\n+            }\n+        } else {\n+            SearchStep::Done\n+        }\n+    }\n     #[inline]\n-    fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n+    fn next_match_back(&mut self) -> Option<(usize, usize)> {\n+        let haystack = self.haystack.as_bytes();\n+        loop {\n+            // get the haystack up to but not including the last character searched\n+            let bytes = if let Some(slice) = haystack.get(..self.finger_back) {\n+                slice\n+            } else {\n+                return None;\n+            };\n+            // the last byte of the utf8 encoded needle\n+            let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n+            if let Some(index) = memchr::memrchr(last_byte, bytes) {\n+                // memrchr will return the index of the byte we wish to\n+                // find. In case of an ASCII character, this is indeed\n+                // were we wish our new finger to be (\"after\" the found\n+                // char in the paradigm of reverse iteration). For\n+                // multibyte chars we need to skip down by the number of more\n+                // bytes they have than ASCII\n+                let shift = self.utf8_size - 1;\n+                if index >= shift {\n+                    let found_char = index - shift;\n+                    if let Some(slice) = haystack.get(found_char..(found_char + self.utf8_size)) {\n+                        if slice == &self.utf8_encoded[0..self.utf8_size] {\n+                            // move finger to before the character found (i.e. at its start index)\n+                            self.finger_back = found_char;\n+                            return Some((self.finger_back, self.finger_back + self.utf8_size));\n+                        }\n+                    }\n+                }\n+                // We can't use finger_back = index - size + 1 here. If we found the last char\n+                // of a different-sized character (or the middle byte of a different character)\n+                // we need to bump the finger_back down to `index`. This similarly makes\n+                // `finger_back` have the potential to no longer be on a boundary,\n+                // but this is OK since we only exit this function on a boundary\n+                // or when the haystack has been searched completely.\n+                //\n+                // Unlike next_match this does not\n+                // have the problem of repeated bytes in utf-8 because\n+                // we're searching for the last byte, and we can only have\n+                // found the last byte when searching in reverse.\n+                self.finger_back = index;\n+            } else {\n+                self.finger_back = 0;\n+                // found nothing, exit\n+                return None;\n+            }\n+        }\n+    }\n+\n+    // let next_reject_back use the default implementation from the Searcher trait\n }\n \n-impl<F> CharEq for F where F: FnMut(char) -> bool {\n+impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n+\n+/// Searches for chars that are equal to a given char\n+impl<'a> Pattern<'a> for char {\n+    type Searcher = CharSearcher<'a>;\n+\n     #[inline]\n-    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n+    fn into_searcher(self, haystack: &'a str) -> Self::Searcher {\n+        let mut utf8_encoded = [0; 4];\n+        self.encode_utf8(&mut utf8_encoded);\n+        let utf8_size = self.len_utf8();\n+        CharSearcher {\n+            haystack,\n+            finger: 0,\n+            finger_back: haystack.len(),\n+            needle: self,\n+            utf8_size,\n+            utf8_encoded\n+        }\n+    }\n \n     #[inline]\n-    fn only_ascii(&self) -> bool { false }\n-}\n+    fn is_contained_in(self, haystack: &'a str) -> bool {\n+        if (self as u32) < 128 {\n+            haystack.as_bytes().contains(&(self as u8))\n+        } else {\n+            let mut buffer = [0u8; 4];\n+            self.encode_utf8(&mut buffer).is_contained_in(haystack)\n+        }\n+    }\n \n-impl<'a> CharEq for &'a [char] {\n     #[inline]\n-    fn matches(&mut self, c: char) -> bool {\n-        self.iter().any(|&m| { let mut m = m; m.matches(c) })\n+    fn is_prefix_of(self, haystack: &'a str) -> bool {\n+        if let Some(ch) = haystack.chars().next() {\n+            self == ch\n+        } else {\n+            false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_suffix_of(self, haystack: &'a str) -> bool where Self::Searcher: ReverseSearcher<'a>\n+    {\n+        if let Some(ch) = haystack.chars().next_back() {\n+            self == ch\n+        } else {\n+            false\n+        }\n     }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Impl for a MultiCharEq wrapper\n+/////////////////////////////////////////////////////////////////////////////\n+\n+#[doc(hidden)]\n+trait MultiCharEq {\n+    fn matches(&mut self, c: char) -> bool;\n+}\n \n+impl<F> MultiCharEq for F where F: FnMut(char) -> bool {\n     #[inline]\n-    fn only_ascii(&self) -> bool {\n-        self.iter().all(|m| m.only_ascii())\n+    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n+}\n+\n+impl<'a> MultiCharEq for &'a [char] {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool {\n+        self.iter().any(|&m| { m == c })\n     }\n }\n \n-struct CharEqPattern<C: CharEq>(C);\n+struct MultiCharEqPattern<C: MultiCharEq>(C);\n \n #[derive(Clone, Debug)]\n-struct CharEqSearcher<'a, C: CharEq> {\n+struct MultiCharEqSearcher<'a, C: MultiCharEq> {\n     char_eq: C,\n     haystack: &'a str,\n     char_indices: super::CharIndices<'a>,\n-    #[allow(dead_code)]\n-    ascii_only: bool,\n }\n \n-impl<'a, C: CharEq> Pattern<'a> for CharEqPattern<C> {\n-    type Searcher = CharEqSearcher<'a, C>;\n+impl<'a, C: MultiCharEq> Pattern<'a> for MultiCharEqPattern<C> {\n+    type Searcher = MultiCharEqSearcher<'a, C>;\n \n     #[inline]\n-    fn into_searcher(self, haystack: &'a str) -> CharEqSearcher<'a, C> {\n-        CharEqSearcher {\n-            ascii_only: self.0.only_ascii(),\n+    fn into_searcher(self, haystack: &'a str) -> MultiCharEqSearcher<'a, C> {\n+        MultiCharEqSearcher {\n             haystack,\n             char_eq: self.0,\n             char_indices: haystack.char_indices(),\n         }\n     }\n }\n \n-unsafe impl<'a, C: CharEq> Searcher<'a> for CharEqSearcher<'a, C> {\n+unsafe impl<'a, C: MultiCharEq> Searcher<'a> for MultiCharEqSearcher<'a, C> {\n     #[inline]\n     fn haystack(&self) -> &'a str {\n         self.haystack\n@@ -322,7 +541,7 @@ unsafe impl<'a, C: CharEq> Searcher<'a> for CharEqSearcher<'a, C> {\n     }\n }\n \n-unsafe impl<'a, C: CharEq> ReverseSearcher<'a> for CharEqSearcher<'a, C> {\n+unsafe impl<'a, C: MultiCharEq> ReverseSearcher<'a> for MultiCharEqSearcher<'a, C> {\n     #[inline]\n     fn next_back(&mut self) -> SearchStep {\n         let s = &mut self.char_indices;\n@@ -342,7 +561,7 @@ unsafe impl<'a, C: CharEq> ReverseSearcher<'a> for CharEqSearcher<'a, C> {\n     }\n }\n \n-impl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}\n+impl<'a, C: MultiCharEq> DoubleEndedSearcher<'a> for MultiCharEqSearcher<'a, C> {}\n \n /////////////////////////////////////////////////////////////////////////////\n \n@@ -409,55 +628,6 @@ macro_rules! searcher_methods {\n     }\n }\n \n-/////////////////////////////////////////////////////////////////////////////\n-// Impl for char\n-/////////////////////////////////////////////////////////////////////////////\n-\n-/// Associated type for `<char as Pattern<'a>>::Searcher`.\n-#[derive(Clone, Debug)]\n-pub struct CharSearcher<'a>(<CharEqPattern<char> as Pattern<'a>>::Searcher);\n-\n-unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n-    searcher_methods!(forward);\n-}\n-\n-unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n-    searcher_methods!(reverse);\n-}\n-\n-impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n-\n-/// Searches for chars that are equal to a given char\n-impl<'a> Pattern<'a> for char {\n-    type Searcher = CharSearcher<'a>;\n-\n-    #[inline]\n-    fn into_searcher(self, haystack: &'a str) -> Self::Searcher {\n-        CharSearcher(CharEqPattern(self).into_searcher(haystack))\n-    }\n-\n-    #[inline]\n-    fn is_contained_in(self, haystack: &'a str) -> bool {\n-        if (self as u32) < 128 {\n-            haystack.as_bytes().contains(&(self as u8))\n-        } else {\n-            let mut buffer = [0u8; 4];\n-            self.encode_utf8(&mut buffer).is_contained_in(haystack)\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_prefix_of(self, haystack: &'a str) -> bool {\n-        CharEqPattern(self).is_prefix_of(haystack)\n-    }\n-\n-    #[inline]\n-    fn is_suffix_of(self, haystack: &'a str) -> bool where Self::Searcher: ReverseSearcher<'a>\n-    {\n-        CharEqPattern(self).is_suffix_of(haystack)\n-    }\n-}\n-\n /////////////////////////////////////////////////////////////////////////////\n // Impl for &[char]\n /////////////////////////////////////////////////////////////////////////////\n@@ -466,7 +636,7 @@ impl<'a> Pattern<'a> for char {\n \n /// Associated type for `<&[char] as Pattern<'a>>::Searcher`.\n #[derive(Clone, Debug)]\n-pub struct CharSliceSearcher<'a, 'b>(<CharEqPattern<&'b [char]> as Pattern<'a>>::Searcher);\n+pub struct CharSliceSearcher<'a, 'b>(<MultiCharEqPattern<&'b [char]> as Pattern<'a>>::Searcher);\n \n unsafe impl<'a, 'b> Searcher<'a> for CharSliceSearcher<'a, 'b> {\n     searcher_methods!(forward);\n@@ -480,7 +650,7 @@ impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n \n /// Searches for chars that are equal to any of the chars in the array\n impl<'a, 'b> Pattern<'a> for &'b [char] {\n-    pattern_methods!(CharSliceSearcher<'a, 'b>, CharEqPattern, CharSliceSearcher);\n+    pattern_methods!(CharSliceSearcher<'a, 'b>, MultiCharEqPattern, CharSliceSearcher);\n }\n \n /////////////////////////////////////////////////////////////////////////////\n@@ -489,7 +659,7 @@ impl<'a, 'b> Pattern<'a> for &'b [char] {\n \n /// Associated type for `<F as Pattern<'a>>::Searcher`.\n #[derive(Clone)]\n-pub struct CharPredicateSearcher<'a, F>(<CharEqPattern<F> as Pattern<'a>>::Searcher)\n+pub struct CharPredicateSearcher<'a, F>(<MultiCharEqPattern<F> as Pattern<'a>>::Searcher)\n     where F: FnMut(char) -> bool;\n \n impl<'a, F> fmt::Debug for CharPredicateSearcher<'a, F>\n@@ -499,7 +669,6 @@ impl<'a, F> fmt::Debug for CharPredicateSearcher<'a, F>\n         f.debug_struct(\"CharPredicateSearcher\")\n             .field(\"haystack\", &self.0.haystack)\n             .field(\"char_indices\", &self.0.char_indices)\n-            .field(\"ascii_only\", &self.0.ascii_only)\n             .finish()\n     }\n }\n@@ -520,7 +689,7 @@ impl<'a, F> DoubleEndedSearcher<'a> for CharPredicateSearcher<'a, F>\n \n /// Searches for chars that match the given predicate\n impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n-    pattern_methods!(CharPredicateSearcher<'a, F>, CharEqPattern, CharPredicateSearcher);\n+    pattern_methods!(CharPredicateSearcher<'a, F>, MultiCharEqPattern, CharPredicateSearcher);\n }\n \n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "c4b85b829812c4cb792c5fdd47348b16149f65f7", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d", "patch": "@@ -28,6 +28,7 @@\n #![feature(iter_rfind)]\n #![feature(iter_rfold)]\n #![feature(nonzero)]\n+#![feature(pattern)]\n #![feature(raw)]\n #![feature(refcell_replace_swap)]\n #![feature(sip_hash_13)]\n@@ -61,6 +62,7 @@ mod nonzero;\n mod num;\n mod ops;\n mod option;\n+mod pattern;\n mod ptr;\n mod result;\n mod slice;"}, {"sha": "d0fd15263b219644b17bf07829b521f222572773", "filename": "src/libcore/tests/pattern.rs", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d/src%2Flibcore%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d/src%2Flibcore%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fpattern.rs?ref=b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d", "patch": "@@ -0,0 +1,264 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::str::pattern::*;\n+\n+// This macro makes it easier to write\n+// tests that do a series of iterations\n+macro_rules! search_asserts {\n+    ($haystack:expr, $needle:expr, $testname:expr, [$($func:ident),*], $result:expr) => {\n+        let mut searcher = $needle.into_searcher($haystack);\n+        let arr = [$( Step::from(searcher.$func()) ),+];\n+        assert_eq!(&arr[..], &$result, $testname);\n+    }\n+}\n+\n+/// Combined enum for the results of next() and next_match()/next_reject()\n+#[derive(Debug, PartialEq, Eq)]\n+enum Step {\n+    // variant names purposely chosen to\n+    // be the same length for easy alignment\n+    Matches(usize, usize),\n+    Rejects(usize, usize),\n+    InRange(usize, usize),\n+    Done\n+}\n+\n+use self::Step::*;\n+\n+impl From<SearchStep> for Step {\n+    fn from(x: SearchStep) -> Self {\n+        match x {\n+            SearchStep::Match(a, b) => Matches(a, b),\n+            SearchStep::Reject(a, b) => Rejects(a, b),\n+            SearchStep::Done => Done\n+        }\n+    }\n+}\n+\n+impl From<Option<(usize, usize)>> for Step {\n+    fn from(x: Option<(usize, usize)>) -> Self {\n+        match x {\n+            Some((a, b)) => InRange(a, b),\n+            None => Done\n+        }\n+    }\n+}\n+\n+// ignore-tidy-linelength\n+\n+// FIXME(Manishearth) these tests focus on single-character searching  (CharSearcher)\n+// and on next()/next_match(), not next_reject(). This is because\n+// the memchr changes make next_match() for single chars complex, but next_reject()\n+// continues to use next() under the hood. We should add more test cases for all\n+// of these, as well as tests for StrSearcher and higher level tests for str::find() (etc)\n+\n+#[test]\n+fn test_simple_iteration() {\n+    search_asserts! (\"abcdeabcd\", 'a', \"forward iteration for ASCII string\",\n+        // a            b              c              d              e              a              b              c              d              EOF\n+        [next,          next,          next,          next,          next,          next,          next,          next,          next,          next],\n+        [Matches(0, 1), Rejects(1, 2), Rejects(2, 3), Rejects(3, 4), Rejects(4, 5), Matches(5, 6), Rejects(6, 7), Rejects(7, 8), Rejects(8, 9), Done]\n+    );\n+\n+    search_asserts! (\"abcdeabcd\", 'a', \"reverse iteration for ASCII string\",\n+        // d            c              b              a            e                d              c              b              a             EOF\n+        [next_back,     next_back,     next_back,     next_back,     next_back,     next_back,     next_back,     next_back,     next_back,     next_back],\n+        [Rejects(8, 9), Rejects(7, 8), Rejects(6, 7), Matches(5, 6), Rejects(4, 5), Rejects(3, 4), Rejects(2, 3), Rejects(1, 2), Matches(0, 1), Done]\n+    );\n+\n+    search_asserts! (\"\u6211\u7231\u6211\u7684\u732b\", '\u6211', \"forward iteration for Chinese string\",\n+        // \u6211           \u611b             \u6211             \u7684              \u8c93               EOF\n+        [next,          next,          next,          next,           next,            next],\n+        [Matches(0, 3), Rejects(3, 6), Matches(6, 9), Rejects(9, 12), Rejects(12, 15), Done]\n+    );\n+\n+    search_asserts! (\"\u6211\u7684\u732b\u8bf4meow\", 'm', \"forward iteration for mixed string\",\n+        // \u6211           \u7684             \u732b             \u8bf4              m                e                o                w                EOF\n+        [next,          next,          next,          next,           next,            next,            next,            next,            next],\n+        [Rejects(0, 3), Rejects(3, 6), Rejects(6, 9), Rejects(9, 12), Matches(12, 13), Rejects(13, 14), Rejects(14, 15), Rejects(15, 16), Done]\n+    );\n+\n+    search_asserts! (\"\u6211\u7684\u732b\u8bf4meow\", '\u732b', \"reverse iteration for mixed string\",\n+        // w             o                 e                m                \u8bf4              \u732b             \u7684             \u6211             EOF\n+        [next_back,       next_back,       next_back,       next_back,       next_back,      next_back,      next_back,    next_back,     next_back],\n+        [Rejects(15, 16), Rejects(14, 15), Rejects(13, 14), Rejects(12, 13), Rejects(9, 12), Matches(6, 9), Rejects(3, 6), Rejects(0, 3), Done]\n+    );\n+}\n+\n+#[test]\n+fn test_simple_search() {\n+    search_asserts!(\"abcdeabcdeabcde\", 'a', \"next_match for ASCII string\",\n+        [next_match,    next_match,    next_match,      next_match],\n+        [InRange(0, 1), InRange(5, 6), InRange(10, 11), Done]\n+    );\n+\n+    search_asserts!(\"abcdeabcdeabcde\", 'a', \"next_match_back for ASCII string\",\n+        [next_match_back, next_match_back, next_match_back, next_match_back],\n+        [InRange(10, 11), InRange(5, 6),   InRange(0, 1),   Done]\n+    );\n+\n+    search_asserts!(\"abcdeab\", 'a', \"next_reject for ASCII string\",\n+        [next_reject,   next_reject,   next_match,    next_reject,   next_reject],\n+        [InRange(1, 2), InRange(2, 3), InRange(5, 6), InRange(6, 7), Done]\n+    );\n+\n+    search_asserts!(\"abcdeabcdeabcde\", 'a', \"next_reject_back for ASCII string\",\n+        [next_reject_back, next_reject_back, next_match_back, next_reject_back, next_reject_back, next_reject_back],\n+        [InRange(14, 15),  InRange(13, 14),  InRange(10, 11), InRange(9, 10),   InRange(8, 9),    InRange(7, 8)]\n+    );\n+}\n+\n+// \u00c1, \uac01, \u0e01, \ud83d\ude00 all end in 0x81\n+// \ud83c\udc40, \u1600 do not end in 0x81 but contain the byte\n+// \ua041 has 0x81 as its second and third bytes.\n+//\n+// The memchr-using implementation of next_match\n+// and next_match_back temporarily violate\n+// the property that the search is always on a unicode boundary,\n+// which is fine as long as this never reaches next() or next_back().\n+// So we test if next() is correct after each next_match() as well.\n+const STRESS: &str = \"\u00c1a\ud83c\udc40b\u00c1\ua041fg\ud83d\ude01\uac01\u0e01\u1600\uac01a\u00c1\uac01\ua041\u0e01\ud83d\ude01a\";\n+\n+#[test]\n+fn test_stress_indices() {\n+    // this isn't really a test, more of documentation on the indices of each character in the stresstest string\n+\n+    search_asserts!(STRESS, 'x', \"Indices of characters in stress test\",\n+        [next, next, next, next, next, next, next, next, next, next, next, next, next, next, next, next, next, next, next, next, next],\n+        [Rejects(0, 2), // \u00c1\n+         Rejects(2, 3), // a\n+         Rejects(3, 7), // \ud83c\udc40\n+         Rejects(7, 8), // b\n+         Rejects(8, 10), // \u00c1\n+         Rejects(10, 13), // \ua041\n+         Rejects(13, 14), // f\n+         Rejects(14, 15), // g\n+         Rejects(15, 19), // \ud83d\ude00\n+         Rejects(19, 22), // \uac01\n+         Rejects(22, 25), // \u0e01\n+         Rejects(25, 28), // \u1600\n+         Rejects(28, 31), // \uac01\n+         Rejects(31, 32), // a\n+         Rejects(32, 34), // \u00c1\n+         Rejects(34, 37), // \uac01\n+         Rejects(37, 40), // \ua041\n+         Rejects(40, 43), // \u0e01\n+         Rejects(43, 47), // \ud83d\ude00\n+         Rejects(47, 48), // a\n+         Done]\n+    );\n+}\n+\n+#[test]\n+fn test_forward_search_shared_bytes() {\n+    search_asserts!(STRESS, '\u00c1', \"Forward search for two-byte Latin character\",\n+        [next_match,    next_match,     next_match,      next_match],\n+        [InRange(0, 2), InRange(8, 10), InRange(32, 34), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\u00c1', \"Forward search for two-byte Latin character; check if next() still works\",\n+        [next_match,    next,          next_match,     next,             next_match,     next,            next_match],\n+        [InRange(0, 2), Rejects(2, 3), InRange(8, 10), Rejects(10, 13), InRange(32, 34), Rejects(34, 37), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\uac01', \"Forward search for three-byte Hangul character\",\n+        [next_match,      next,            next_match,      next_match,      next_match],\n+        [InRange(19, 22), Rejects(22, 25), InRange(28, 31), InRange(34, 37), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\uac01', \"Forward search for three-byte Hangul character; check if next() still works\",\n+        [next_match,      next,            next_match,      next,            next_match,      next,            next_match],\n+        [InRange(19, 22), Rejects(22, 25), InRange(28, 31), Rejects(31, 32), InRange(34, 37), Rejects(37, 40), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\u0e01', \"Forward search for three-byte Thai character\",\n+        [next_match,      next,            next_match,      next,            next_match],\n+        [InRange(22, 25), Rejects(25, 28), InRange(40, 43), Rejects(43, 47), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\u0e01', \"Forward search for three-byte Thai character; check if next() still works\",\n+        [next_match,      next,            next_match,      next,            next_match],\n+        [InRange(22, 25), Rejects(25, 28), InRange(40, 43), Rejects(43, 47), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\ud83d\ude01', \"Forward search for four-byte emoji\",\n+        [next_match,      next,            next_match,      next,            next_match],\n+        [InRange(15, 19), Rejects(19, 22), InRange(43, 47), Rejects(47, 48), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\ud83d\ude01', \"Forward search for four-byte emoji; check if next() still works\",\n+        [next_match,      next,            next_match,      next,            next_match],\n+        [InRange(15, 19), Rejects(19, 22), InRange(43, 47), Rejects(47, 48), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\ua041', \"Forward search for three-byte Yi character with repeated bytes\",\n+        [next_match,      next,            next_match,      next,            next_match],\n+        [InRange(10, 13), Rejects(13, 14), InRange(37, 40), Rejects(40, 43), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\ua041', \"Forward search for three-byte Yi character with repeated bytes; check if next() still works\",\n+        [next_match,      next,            next_match,      next,            next_match],\n+        [InRange(10, 13), Rejects(13, 14), InRange(37, 40), Rejects(40, 43), Done]\n+    );\n+}\n+\n+#[test]\n+fn test_reverse_search_shared_bytes() {\n+    search_asserts!(STRESS, '\u00c1', \"Reverse search for two-byte Latin character\",\n+        [next_match_back, next_match_back, next_match_back, next_match_back],\n+        [InRange(32, 34), InRange(8, 10),  InRange(0, 2),   Done]\n+    );\n+\n+    search_asserts!(STRESS, '\u00c1', \"Reverse search for two-byte Latin character; check if next_back() still works\",\n+        [next_match_back, next_back,       next_match_back, next_back,     next_match_back, next_back],\n+        [InRange(32, 34), Rejects(31, 32), InRange(8, 10),  Rejects(7, 8), InRange(0, 2),   Done]\n+    );\n+\n+    search_asserts!(STRESS, '\uac01', \"Reverse search for three-byte Hangul character\",\n+        [next_match_back, next_back,        next_match_back, next_match_back, next_match_back],\n+        [InRange(34, 37), Rejects(32, 34), InRange(28, 31),  InRange(19, 22), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\uac01', \"Reverse search for three-byte Hangul character; check if next_back() still works\",\n+        [next_match_back, next_back,       next_match_back, next_back,       next_match_back, next_back,       next_match_back],\n+        [InRange(34, 37), Rejects(32, 34), InRange(28, 31), Rejects(25, 28), InRange(19, 22), Rejects(15, 19), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\u0e01', \"Reverse search for three-byte Thai character\",\n+        [next_match_back, next_back,       next_match_back, next_back,       next_match_back],\n+        [InRange(40, 43), Rejects(37, 40), InRange(22, 25), Rejects(19, 22), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\u0e01', \"Reverse search for three-byte Thai character; check if next_back() still works\",\n+        [next_match_back, next_back,       next_match_back, next_back,       next_match_back],\n+        [InRange(40, 43), Rejects(37, 40), InRange(22, 25), Rejects(19, 22), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\ud83d\ude01', \"Reverse search for four-byte emoji\",\n+        [next_match_back, next_back,       next_match_back, next_back,       next_match_back],\n+        [InRange(43, 47), Rejects(40, 43), InRange(15, 19), Rejects(14, 15), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\ud83d\ude01', \"Reverse search for four-byte emoji; check if next_back() still works\",\n+        [next_match_back, next_back,       next_match_back, next_back,       next_match_back],\n+        [InRange(43, 47), Rejects(40, 43), InRange(15, 19), Rejects(14, 15), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\ua041', \"Reverse search for three-byte Yi character with repeated bytes\",\n+        [next_match_back, next_back,       next_match_back, next_back,      next_match_back],\n+        [InRange(37, 40), Rejects(34, 37), InRange(10, 13), Rejects(8, 10), Done]\n+    );\n+\n+    search_asserts!(STRESS, '\ua041', \"Reverse search for three-byte Yi character with repeated bytes; check if next_back() still works\",\n+        [next_match_back, next_back,       next_match_back, next_back,      next_match_back],\n+        [InRange(37, 40), Rejects(34, 37), InRange(10, 13), Rejects(8, 10), Done]\n+    );\n+}"}]}