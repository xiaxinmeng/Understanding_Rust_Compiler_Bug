{"sha": "c31623b0e42e73ef2c9411445d3172e2e9c9e467", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMTYyM2IwZTQyZTczZWYyYzk0MTE0NDVkMzE3MmUyZTljOWU0Njc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-17T20:12:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-25T11:06:27Z"}, "message": "Integrate caching of results. Measurements show approx 90% hit rate.", "tree": {"sha": "fb9dad887de3a6c76e9426aaf58129aa30cbc5b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb9dad887de3a6c76e9426aaf58129aa30cbc5b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c31623b0e42e73ef2c9411445d3172e2e9c9e467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c31623b0e42e73ef2c9411445d3172e2e9c9e467", "html_url": "https://github.com/rust-lang/rust/commit/c31623b0e42e73ef2c9411445d3172e2e9c9e467", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c31623b0e42e73ef2c9411445d3172e2e9c9e467/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "effb3636cc416ae81450e857352b832a86d5dd44", "url": "https://api.github.com/repos/rust-lang/rust/commits/effb3636cc416ae81450e857352b832a86d5dd44", "html_url": "https://github.com/rust-lang/rust/commit/effb3636cc416ae81450e857352b832a86d5dd44"}], "stats": {"total": 173, "additions": 98, "deletions": 75}, "files": [{"sha": "ad3e1ae0242b1566ff8db24e8cffc166c440e8c0", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c31623b0e42e73ef2c9411445d3172e2e9c9e467/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31623b0e42e73ef2c9411445d3172e2e9c9e467/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=c31623b0e42e73ef2c9411445d3172e2e9c9e467", "patch": "@@ -22,6 +22,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n \n pub use self::fulfill::FulfillmentContext;\n pub use self::select::SelectionContext;\n+pub use self::select::SelectionCache;\n pub use self::util::supertraits;\n pub use self::util::transitive_bounds;\n pub use self::util::Supertraits;"}, {"sha": "63fbeb797c4d46e37ea80f8228b1551083d6ab8e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 83, "deletions": 67, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/c31623b0e42e73ef2c9411445d3172e2e9c9e467/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31623b0e42e73ef2c9411445d3172e2e9c9e467/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c31623b0e42e73ef2c9411445d3172e2e9c9e467", "patch": "@@ -28,6 +28,8 @@ use middle::ty_fold::TypeFoldable;\n use middle::typeck::check::regionmanip;\n use middle::typeck::infer;\n use middle::typeck::infer::{InferCtxt, TypeSkolemizer};\n+use std::cell::RefCell;\n+use std::collections::hashmap::HashMap;\n use std::rc::Rc;\n use syntax::ast;\n use util::ppaux::Repr;\n@@ -46,15 +48,15 @@ struct ObligationStack<'prev> {\n     previous: Option<&'prev ObligationStack<'prev>>\n }\n \n-// pub struct SelectionCache {\n-//     hashmap: RefCell<HashMap<CacheKey, Candidate>>,\n-// }\n+pub struct SelectionCache {\n+    hashmap: RefCell<HashMap<CacheKey, SelectionResult<Candidate>>>,\n+}\n \n-// #[deriving(Hash,Eq,PartialEq)]\n-// struct CacheKey {\n-//     trait_def_id: ast::DefId,\n-//     skol_obligation_self_ty: ty::t,\n-// }\n+#[deriving(Hash,Eq,PartialEq)]\n+struct CacheKey {\n+    trait_def_id: ast::DefId,\n+    skol_obligation_self_ty: ty::t,\n+}\n \n #[deriving(PartialEq,Eq)]\n enum MatchResult<T> {\n@@ -309,14 +311,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // First, check the cache.\n         match self.check_candidate_cache(stack.obligation, stack.skol_obligation_self_ty) {\n             Some(c) => {\n-                return Ok(Some(c));\n+                debug!(\"check_candidate_cache(obligation={}, skol_obligation_self_ty={}, \\\n+                       candidate={})\",\n+                       stack.obligation.trait_ref.def_id,\n+                       stack.skol_obligation_self_ty.repr(self.tcx()),\n+                       c.repr(self.tcx()));\n+                return c;\n             }\n             None => { }\n         }\n \n         // If no match, compute result and insert into cache.\n         let result = self.pick_candidate(stack);\n-        // self.insert_candidate_cache(obligation, skol_obligation_self_ty, result.clone());\n+        self.insert_candidate_cache(stack.obligation,\n+                                    stack.skol_obligation_self_ty,\n+                                    result.clone());\n         result\n     }\n \n@@ -330,9 +339,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let mut candidates = try!(self.assemble_candidates(stack));\n \n-        debug!(\"candidate_from_obligation: {} candidates for {}\",\n-               candidates.len(),\n-               stack.repr(self.tcx()));\n+        debug!(\"assembled {} candidates for {}\",\n+               candidates.len(), stack.repr(self.tcx()));\n \n         // Examine candidates to determine outcome. Ideally we will\n         // have exactly one candidate that is definitively applicable.\n@@ -348,55 +356,63 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 debug!(\"0 matches, unimpl\");\n                 Err(Unimplemented)\n             } else {\n-                debug!(\"candidate_from_obligation({}) -> 0 matches, ambig\",\n-                       stack.repr(self.tcx()));\n+                debug!(\"0 matches, ambig\");\n                 Ok(None)\n-            };\n-        }\n-\n-        if candidates.len() > 1 {\n+            }\n+        } else if candidates.len() > 1 {\n             // Ambiguity. Possibly we should report back more\n             // information on the potential candidates so we can give\n             // a better error message.\n-            debug!(\"candidate_from_obligation({}) -> multiple matches, ambig\",\n-                   stack.repr(self.tcx()));\n-\n-            return Ok(None);\n+            debug!(\"multiple matches, ambig\");\n+            Ok(None)\n+        } else {\n+            let candidate = candidates.pop().unwrap();\n+            Ok(Some(candidate))\n         }\n+    }\n \n-        let candidate = candidates.pop().unwrap();\n-        self.insert_candidate_cache(stack.obligation,\n-                                    stack.skol_obligation_self_ty,\n-                                    candidate.clone());\n-        Ok(Some(candidate))\n+    fn pick_candidate_cache(&self,\n+                            _obligation: &Obligation,\n+                            skol_obligation_self_ty: ty::t)\n+                            -> &SelectionCache\n+    {\n+        if\n+            ty::type_has_self(skol_obligation_self_ty) ||\n+            ty::type_has_params(skol_obligation_self_ty)\n+        {\n+            &self.param_env.selection_cache\n+        } else {\n+            &self.tcx().selection_cache\n+        }\n     }\n \n     fn check_candidate_cache(&mut self,\n-                             _obligation: &Obligation,\n-                             _skol_obligation_self_ty: ty::t)\n-                             -> Option<Candidate>\n+                             obligation: &Obligation,\n+                             skol_obligation_self_ty: ty::t)\n+                             -> Option<SelectionResult<Candidate>>\n     {\n-        // let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n-        //                               skol_obligation_self_ty);\n-        // let hashmap = self.tcx().selection_cache.hashmap.borrow();\n-        // hashmap.find(&cache_key).map(|c| (*c).clone())\n-        None\n+        let cache = self.pick_candidate_cache(obligation, skol_obligation_self_ty);\n+        let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n+                                      skol_obligation_self_ty);\n+        let hashmap = cache.hashmap.borrow();\n+        hashmap.find(&cache_key).map(|c| (*c).clone())\n     }\n \n     fn insert_candidate_cache(&mut self,\n-                              _obligation: &Obligation,\n-                              _skol_obligation_self_ty: ty::t,\n-                              _candidate: Candidate)\n+                              obligation: &Obligation,\n+                              skol_obligation_self_ty: ty::t,\n+                              candidate: SelectionResult<Candidate>)\n     {\n-        // FIXME -- Enable caching. I think the right place to put the cache\n-        // is in the ParameterEnvironment, not the tcx, because otherwise\n-        // when there are distinct where clauses in scope the cache can get\n-        // confused.\n-        //\n-        //let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n-        //                              skol_obligation_self_ty);\n-        //let mut hashmap = self.tcx().selection_cache.hashmap.borrow_mut();\n-        //hashmap.insert(cache_key, candidate);\n+        debug!(\"insert_candidate_cache(obligation={}, skol_obligation_self_ty={}, candidate={})\",\n+               obligation.trait_ref.def_id,\n+               skol_obligation_self_ty.repr(self.tcx()),\n+               candidate.repr(self.tcx()));\n+\n+        let cache = self.pick_candidate_cache(obligation, skol_obligation_self_ty);\n+        let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n+                                      skol_obligation_self_ty);\n+        let mut hashmap = cache.hashmap.borrow_mut();\n+        hashmap.insert(cache_key, candidate);\n     }\n \n     fn assemble_candidates(&mut self,\n@@ -1487,6 +1503,14 @@ impl Repr for ImplCandidate {\n     }\n }\n \n+impl SelectionCache {\n+    pub fn new() -> SelectionCache {\n+        SelectionCache {\n+            hashmap: RefCell::new(HashMap::new())\n+        }\n+    }\n+}\n+\n impl<'o> ObligationStack<'o> {\n     fn iter(&self) -> Option<&ObligationStack> {\n         Some(self)\n@@ -1515,22 +1539,14 @@ impl<'o> Repr for ObligationStack<'o> {\n     }\n }\n \n-// impl SelectionCache {\n-//     pub fn new() -> SelectionCache {\n-//         SelectionCache {\n-//             hashmap: RefCell::new(HashMap::new())\n-//         }\n-//     }\n-// }\n-\n-// impl CacheKey {\n-//     pub fn new(trait_def_id: ast::DefId,\n-//                skol_obligation_self_ty: ty::t)\n-//                -> CacheKey\n-//     {\n-//         CacheKey {\n-//             trait_def_id: trait_def_id,\n-//             skol_obligation_self_ty: skol_obligation_self_ty\n-//         }\n-//     }\n-// }\n+impl CacheKey {\n+    pub fn new(trait_def_id: ast::DefId,\n+               skol_obligation_self_ty: ty::t)\n+               -> CacheKey\n+    {\n+        CacheKey {\n+            trait_def_id: trait_def_id,\n+            skol_obligation_self_ty: skol_obligation_self_ty\n+        }\n+    }\n+}"}, {"sha": "c54f638ab2abf860a03cfb082ad9e5263cb00687", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c31623b0e42e73ef2c9411445d3172e2e9c9e467/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31623b0e42e73ef2c9411445d3172e2e9c9e467/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c31623b0e42e73ef2c9411445d3172e2e9c9e467", "patch": "@@ -579,6 +579,10 @@ pub struct ctxt<'tcx> {\n     /// Maps def IDs of traits to information about their associated types.\n     pub trait_associated_types:\n         RefCell<DefIdMap<Rc<Vec<AssociatedTypeInfo>>>>,\n+\n+    /// Caches the results of trait selection. This cache is used\n+    /// for things that do not have to do with the parameters in scope.\n+    pub selection_cache: traits::SelectionCache,\n }\n \n pub enum tbox_flag {\n@@ -1281,6 +1285,10 @@ pub struct ParameterEnvironment {\n     /// Note: This effectively *duplicates* the `bounds` array for\n     /// now.\n     pub caller_obligations: VecPerParamSpace<traits::Obligation>,\n+\n+    /// Caches the results of trait selection. This cache is used\n+    /// for things that have to do with the parameters in scope.\n+    pub selection_cache: traits::SelectionCache,\n }\n \n impl ParameterEnvironment {\n@@ -1524,7 +1532,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         capture_modes: capture_modes,\n         associated_types: RefCell::new(DefIdMap::new()),\n         trait_associated_types: RefCell::new(DefIdMap::new()),\n-    }\n+        selection_cache: traits::SelectionCache::new(),\n+   }\n }\n \n // Type constructors\n@@ -5324,7 +5333,8 @@ pub fn empty_parameter_environment() -> ParameterEnvironment {\n     ty::ParameterEnvironment { free_substs: Substs::empty(),\n                                bounds: VecPerParamSpace::empty(),\n                                caller_obligations: VecPerParamSpace::empty(),\n-                               implicit_region_bound: ty::ReEmpty }\n+                               implicit_region_bound: ty::ReEmpty,\n+                               selection_cache: traits::SelectionCache::new(), }\n }\n \n pub fn construct_parameter_environment(\n@@ -5396,6 +5406,7 @@ pub fn construct_parameter_environment(\n         bounds: bounds,\n         implicit_region_bound: ty::ReScope(free_id),\n         caller_obligations: obligations,\n+        selection_cache: traits::SelectionCache::new(),\n     };\n \n     fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,"}, {"sha": "6ef2e7b8fcafd1ecda44688a8bb152dbc16e4789", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c31623b0e42e73ef2c9411445d3172e2e9c9e467/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31623b0e42e73ef2c9411445d3172e2e9c9e467/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c31623b0e42e73ef2c9411445d3172e2e9c9e467", "patch": "@@ -368,12 +368,7 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n                                     -> Inherited<'a, 'tcx> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n-    let param_env = ty::ParameterEnvironment {\n-        free_substs: subst::Substs::empty(),\n-        bounds: subst::VecPerParamSpace::empty(),\n-        implicit_region_bound: ty::ReStatic,\n-        caller_obligations: subst::VecPerParamSpace::empty(),\n-    };\n+    let param_env = ty::empty_parameter_environment();\n     Inherited::new(ccx.tcx, param_env)\n }\n "}]}