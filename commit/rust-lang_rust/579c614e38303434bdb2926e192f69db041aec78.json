{"sha": "579c614e38303434bdb2926e192f69db041aec78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3OWM2MTRlMzgzMDM0MzRiZGIyOTI2ZTE5MmY2OWRiMDQxYWVjNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-15T22:16:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-15T22:16:17Z"}, "message": "auto merge of #7124 : Aatch/rust/trans-refactor-pt1, r=brson\n\nThis removes all of the explicit `@mut` fields from `CrateContext`. There are still a few that are managed, but no longer do we have `@mut bool` in the structure.\r\n\r\nMost of the changes are changing `@CrateContext` to `@mut CrateContext`, though I did change as many as I could get away with to `&CrateContext` and `&mut CrateContext`. The biggest thing preventing me from changing to `&[mut]` in most places was the instruction counter thing. In two cases, where I got a static borrow error and a dynamic borrow error, I opted to remove the count call there as it was literally the only thing preventing me from switching to `&mut CrateContext` parameters in both cases.\r\n\r\nOther things to note:\r\n\r\n* the EncoderContext uses borrowed pointers with lifetimes, since it can, though that required me to work around the limitation of not being able to move a structure with borrowed pointers into a heap closure. I changed as much as I could to stack closures, but unfortunately I hit the AST visitor and changing that is somewhat outside the scope of this PR. Instead (and there is a comment to this effect) I choose to unsafely get the structure into the heap, this is because I know the lifetimes involved are safe, even though the compiler can't prove it.\r\n\r\n* Many of the changes are workarounds because of the borrow checker, either dynamically freezing it for too long, or inferring too large a scope. This is mostly just from nested function calls where each borrow is considered to last for the entire statement. Other cases are where `CrateContext` was borrowed in a `match` causing it to be borrowed for the entire length of the match, even though that wasn't wanted (or needed).\r\n\r\n* I haven't yet tested to see if this changes compilation times in any way. I doubt there will be much of an impact however, as the only major improvements are less indirection and fewer refcount bumps.\r\n\r\n* This lays the foundations to remove many more heap allocations in trans as many cases can be changed to use lifetimes instead.\r\n\r\n=====\r\n\r\nThis change includes some other, minor refactorings, as I am planning a series, however I don't want to submit them all at once as it will be hell to continually rebase.", "tree": {"sha": "22cca87779018f1b67a850a38a5c3586019fdd75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22cca87779018f1b67a850a38a5c3586019fdd75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/579c614e38303434bdb2926e192f69db041aec78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/579c614e38303434bdb2926e192f69db041aec78", "html_url": "https://github.com/rust-lang/rust/commit/579c614e38303434bdb2926e192f69db041aec78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/579c614e38303434bdb2926e192f69db041aec78/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "998e41a11a977413dcfc6716ab936ab9dcecb76d", "url": "https://api.github.com/repos/rust-lang/rust/commits/998e41a11a977413dcfc6716ab936ab9dcecb76d", "html_url": "https://github.com/rust-lang/rust/commit/998e41a11a977413dcfc6716ab936ab9dcecb76d"}, {"sha": "f2a7fc69daaa672696641042e97611fbfa0f0013", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a7fc69daaa672696641042e97611fbfa0f0013", "html_url": "https://github.com/rust-lang/rust/commit/f2a7fc69daaa672696641042e97611fbfa0f0013"}], "stats": {"total": 1849, "additions": 1005, "deletions": 844}, "files": [{"sha": "6aa97e393eab732d7dae73cc479904a8891c9f01", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -18,7 +18,7 @@ use lib::llvm::ModuleRef;\n use lib;\n use metadata::common::LinkMeta;\n use metadata::{encoder, csearch, cstore};\n-use middle::trans::common::CrateContext;\n+use middle::trans::context::CrateContext;\n use middle::ty;\n use util::ppaux;\n \n@@ -622,11 +622,11 @@ pub fn symbol_hash(tcx: ty::ctxt,\n     hash.to_managed()\n }\n \n-pub fn get_symbol_hash(ccx: @CrateContext, t: ty::t) -> @str {\n+pub fn get_symbol_hash(ccx: &mut CrateContext, t: ty::t) -> @str {\n     match ccx.type_hashcodes.find(&t) {\n       Some(&h) => h,\n       None => {\n-        let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);\n+        let hash = symbol_hash(ccx.tcx, &mut ccx.symbol_hasher, t, ccx.link_meta);\n         ccx.type_hashcodes.insert(t, hash);\n         hash\n       }\n@@ -705,7 +705,7 @@ pub fn exported_name(sess: Session,\n             path_name(sess.ident_of(vers))));\n }\n \n-pub fn mangle_exported_name(ccx: @CrateContext,\n+pub fn mangle_exported_name(ccx: &mut CrateContext,\n                             path: path,\n                             t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n@@ -714,7 +714,7 @@ pub fn mangle_exported_name(ccx: @CrateContext,\n                          ccx.link_meta.vers);\n }\n \n-pub fn mangle_internal_name_by_type_only(ccx: @CrateContext,\n+pub fn mangle_internal_name_by_type_only(ccx: &mut CrateContext,\n                                          t: ty::t,\n                                          name: &str) -> ~str {\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n@@ -725,7 +725,7 @@ pub fn mangle_internal_name_by_type_only(ccx: @CrateContext,\n           path_name(ccx.sess.ident_of(hash))]);\n }\n \n-pub fn mangle_internal_name_by_type_and_seq(ccx: @CrateContext,\n+pub fn mangle_internal_name_by_type_and_seq(ccx: &mut CrateContext,\n                                          t: ty::t,\n                                          name: &str) -> ~str {\n     let s = ppaux::ty_to_str(ccx.tcx, t);\n@@ -736,18 +736,18 @@ pub fn mangle_internal_name_by_type_and_seq(ccx: @CrateContext,\n           path_name((ccx.names)(name))]);\n }\n \n-pub fn mangle_internal_name_by_path_and_seq(ccx: @CrateContext,\n+pub fn mangle_internal_name_by_path_and_seq(ccx: &mut CrateContext,\n                                             path: path,\n                                             flav: &str) -> ~str {\n     return mangle(ccx.sess,\n                   vec::append_one(path, path_name((ccx.names)(flav))));\n }\n \n-pub fn mangle_internal_name_by_path(ccx: @CrateContext, path: path) -> ~str {\n+pub fn mangle_internal_name_by_path(ccx: &mut CrateContext, path: path) -> ~str {\n     return mangle(ccx.sess, path);\n }\n \n-pub fn mangle_internal_name_by_seq(ccx: @CrateContext, flav: &str) -> ~str {\n+pub fn mangle_internal_name_by_seq(ccx: &mut CrateContext, flav: &str) -> ~str {\n     return fmt!(\"%s_%u\", flav, (ccx.names)(flav).name);\n }\n "}, {"sha": "73347f2b91d61ba2cfa0045a71322a4e7cebef62", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -219,109 +219,109 @@ pub fn compile_rest(sess: Session,\n     crate = time(time_passes, ~\"intrinsic injection\", ||\n                  front::intrinsic_inject::inject_intrinsic(sess, crate));\n \n-    crate = time(time_passes, ~\"extra injection\", ||\n-                 front::std_inject::maybe_inject_libstd_ref(sess, crate));\n+        crate = time(time_passes, ~\"extra injection\", ||\n+                     front::std_inject::maybe_inject_libstd_ref(sess, crate));\n \n-    let ast_map = time(time_passes, ~\"ast indexing\", ||\n-                       syntax::ast_map::map_crate(sess.diagnostic(), crate));\n+        let ast_map = time(time_passes, ~\"ast indexing\", ||\n+                           syntax::ast_map::map_crate(sess.diagnostic(), crate));\n \n-    time(time_passes, ~\"external crate/lib resolution\", ||\n-         creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n-                              sess.filesearch,\n-                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n-                              sess.opts.is_static,\n-                              token::get_ident_interner()));\n+        time(time_passes, ~\"external crate/lib resolution\", ||\n+             creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n+                                  sess.filesearch,\n+                                  session::sess_os_to_meta_os(sess.targ_cfg.os),\n+                                  sess.opts.is_static,\n+                                  token::get_ident_interner()));\n \n-    let lang_items = time(time_passes, ~\"language item collection\", ||\n-                          middle::lang_items::collect_language_items(crate, sess));\n+        let lang_items = time(time_passes, ~\"language item collection\", ||\n+                              middle::lang_items::collect_language_items(crate, sess));\n \n-    let middle::resolve::CrateMap {\n-        def_map: def_map,\n-        exp_map2: exp_map2,\n-        trait_map: trait_map\n-    } =\n-        time(time_passes, ~\"resolution\", ||\n-             middle::resolve::resolve_crate(sess, lang_items, crate));\n+        let middle::resolve::CrateMap {\n+            def_map: def_map,\n+            exp_map2: exp_map2,\n+            trait_map: trait_map\n+        } =\n+            time(time_passes, ~\"resolution\", ||\n+                 middle::resolve::resolve_crate(sess, lang_items, crate));\n \n-    time(time_passes, ~\"looking for entry point\",\n-         || middle::entry::find_entry_point(sess, crate, ast_map));\n+        time(time_passes, ~\"looking for entry point\",\n+             || middle::entry::find_entry_point(sess, crate, ast_map));\n \n-    let freevars = time(time_passes, ~\"freevar finding\", ||\n-                        freevars::annotate_freevars(def_map, crate));\n+        let freevars = time(time_passes, ~\"freevar finding\", ||\n+                            freevars::annotate_freevars(def_map, crate));\n \n-    let region_map = time(time_passes, ~\"region resolution\", ||\n-                          middle::region::resolve_crate(sess, def_map, crate));\n+        let region_map = time(time_passes, ~\"region resolution\", ||\n+                              middle::region::resolve_crate(sess, def_map, crate));\n \n-    let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n-                      middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n+        let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n+                          middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n \n-    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n-                            region_map, rp_set, lang_items);\n+        let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n+                                region_map, rp_set, lang_items);\n \n-    // passes are timed inside typeck\n-    let (method_map, vtable_map) = typeck::check_crate(\n-        ty_cx, trait_map, crate);\n+        // passes are timed inside typeck\n+        let (method_map, vtable_map) = typeck::check_crate(\n+            ty_cx, trait_map, crate);\n \n-    // These next two const passes can probably be merged\n-    time(time_passes, ~\"const marking\", ||\n-         middle::const_eval::process_crate(crate, ty_cx));\n+        // These next two const passes can probably be merged\n+        time(time_passes, ~\"const marking\", ||\n+             middle::const_eval::process_crate(crate, ty_cx));\n \n-    time(time_passes, ~\"const checking\", ||\n-         middle::check_const::check_crate(sess, crate, ast_map, def_map,\n-                                          method_map, ty_cx));\n+        time(time_passes, ~\"const checking\", ||\n+             middle::check_const::check_crate(sess, crate, ast_map, def_map,\n+                                              method_map, ty_cx));\n \n-    if phases.to == cu_typeck { return (Some(crate), Some(ty_cx)); }\n+        if phases.to == cu_typeck { return (Some(crate), Some(ty_cx)); }\n \n-    time(time_passes, ~\"privacy checking\", ||\n-         middle::privacy::check_crate(ty_cx, &method_map, crate));\n+        time(time_passes, ~\"privacy checking\", ||\n+             middle::privacy::check_crate(ty_cx, &method_map, crate));\n \n-    time(time_passes, ~\"effect checking\", ||\n-         middle::effect::check_crate(ty_cx, method_map, crate));\n+        time(time_passes, ~\"effect checking\", ||\n+             middle::effect::check_crate(ty_cx, method_map, crate));\n \n-    time(time_passes, ~\"loop checking\", ||\n-         middle::check_loop::check_crate(ty_cx, crate));\n+        time(time_passes, ~\"loop checking\", ||\n+             middle::check_loop::check_crate(ty_cx, crate));\n \n-    let middle::moves::MoveMaps {moves_map, moved_variables_set,\n-                                 capture_map} =\n-        time(time_passes, ~\"compute moves\", ||\n-             middle::moves::compute_moves(ty_cx, method_map, crate));\n+        let middle::moves::MoveMaps {moves_map, moved_variables_set,\n+                                     capture_map} =\n+            time(time_passes, ~\"compute moves\", ||\n+                 middle::moves::compute_moves(ty_cx, method_map, crate));\n \n-    time(time_passes, ~\"match checking\", ||\n-         middle::check_match::check_crate(ty_cx, method_map,\n-                                          moves_map, crate));\n+        time(time_passes, ~\"match checking\", ||\n+             middle::check_match::check_crate(ty_cx, method_map,\n+                                              moves_map, crate));\n \n-    time(time_passes, ~\"liveness checking\", ||\n-         middle::liveness::check_crate(ty_cx, method_map,\n-                                       capture_map, crate));\n-\n-    let (root_map, write_guard_map) =\n-        time(time_passes, ~\"borrow checking\", ||\n-             middle::borrowck::check_crate(ty_cx, method_map,\n-                                           moves_map, moved_variables_set,\n+        time(time_passes, ~\"liveness checking\", ||\n+             middle::liveness::check_crate(ty_cx, method_map,\n                                            capture_map, crate));\n \n-    time(time_passes, ~\"kind checking\", ||\n-         kind::check_crate(ty_cx, method_map, crate));\n+        let (root_map, write_guard_map) =\n+            time(time_passes, ~\"borrow checking\", ||\n+                 middle::borrowck::check_crate(ty_cx, method_map,\n+                                               moves_map, moved_variables_set,\n+                                               capture_map, crate));\n \n-    time(time_passes, ~\"lint checking\", ||\n-         lint::check_crate(ty_cx, crate));\n+        time(time_passes, ~\"kind checking\", ||\n+             kind::check_crate(ty_cx, method_map, crate));\n \n-    if phases.to == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n+        time(time_passes, ~\"lint checking\", ||\n+             lint::check_crate(ty_cx, crate));\n \n-    let maps = astencode::Maps {\n-        root_map: root_map,\n-        method_map: method_map,\n-        vtable_map: vtable_map,\n-        write_guard_map: write_guard_map,\n-        moves_map: moves_map,\n-        capture_map: capture_map\n-    };\n+        if phases.to == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n \n-    let outputs = outputs.get_ref();\n-    time(time_passes, ~\"translation\", ||\n-         trans::base::trans_crate(sess, crate, ty_cx,\n-                                  &outputs.obj_filename,\n-                                  exp_map2, maps))\n+        let maps = astencode::Maps {\n+            root_map: root_map,\n+            method_map: method_map,\n+            vtable_map: vtable_map,\n+            write_guard_map: write_guard_map,\n+            moves_map: moves_map,\n+            capture_map: capture_map\n+        };\n+\n+        let outputs = outputs.get_ref();\n+        time(time_passes, ~\"translation\", ||\n+             trans::base::trans_crate(sess, crate, ty_cx,\n+                                      &outputs.obj_filename,\n+                                      exp_map2, maps))\n     };\n \n     let outputs = outputs.get_ref();"}, {"sha": "110f686e5a6642b63d512dce47d5c519f547670c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 84, "deletions": 66, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -47,24 +47,26 @@ use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n+use core::cast;\n+\n // used by astencode:\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n-pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n+pub type encode_inlined_item<'self> = &'self fn(ecx: &EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    path: &[ast_map::path_elt],\n                                    ii: ast::inlined_item);\n \n-pub struct EncodeParams {\n+pub struct EncodeParams<'self> {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n     reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: @mut HashMap<ast::node_id, ~str>,\n-    discrim_symbols: @mut HashMap<ast::node_id, @str>,\n-    link_meta: LinkMeta,\n+    item_symbols: &'self HashMap<ast::node_id, ~str>,\n+    discrim_symbols: &'self HashMap<ast::node_id, @str>,\n+    link_meta: &'self LinkMeta,\n     cstore: @mut cstore::CStore,\n-    encode_inlined_item: encode_inlined_item\n+    encode_inlined_item: encode_inlined_item<'self>\n }\n \n struct Stats {\n@@ -81,31 +83,31 @@ struct Stats {\n     n_inlines: uint\n }\n \n-pub struct EncodeContext {\n+pub struct EncodeContext<'self> {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n     reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: @mut HashMap<ast::node_id, ~str>,\n-    discrim_symbols: @mut HashMap<ast::node_id, @str>,\n-    link_meta: LinkMeta,\n-    cstore: @mut cstore::CStore,\n-    encode_inlined_item: encode_inlined_item,\n+    item_symbols: &'self HashMap<ast::node_id, ~str>,\n+    discrim_symbols: &'self HashMap<ast::node_id, @str>,\n+    link_meta: &'self LinkMeta,\n+    cstore: &'self cstore::CStore,\n+    encode_inlined_item: encode_inlined_item<'self>,\n     type_abbrevs: abbrev_map\n }\n \n-pub fn reachable(ecx: @EncodeContext, id: node_id) -> bool {\n+pub fn reachable(ecx: &EncodeContext, id: node_id) -> bool {\n     ecx.reachable.contains(&id)\n }\n \n-fn encode_name(ecx: @EncodeContext,\n+fn encode_name(ecx: &EncodeContext,\n                ebml_w: &mut writer::Encoder,\n                name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_impl_type_basename(ecx: @EncodeContext,\n+fn encode_impl_type_basename(ecx: &EncodeContext,\n                              ebml_w: &mut writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n@@ -116,7 +118,7 @@ pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @EncodeContext,\n+fn encode_region_param(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n@@ -147,14 +149,15 @@ fn add_to_index(ebml_w: &mut writer::Encoder,\n }\n \n fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n-                    ecx: @EncodeContext,\n+                    ecx: &EncodeContext,\n                     trait_ref: &ty::TraitRef,\n                     tag: uint) {\n+    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n+        reachable: |a| r.contains(&a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n \n     ebml_w.start_tag(tag);\n@@ -174,14 +177,15 @@ pub fn def_to_str(did: def_id) -> ~str {\n }\n \n fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n-                             ecx: @EncodeContext,\n+                             ecx: &EncodeContext,\n                              params: @~[ty::TypeParameterDef],\n                              tag: uint) {\n+    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n+        reachable: |a| r.contains(&a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for params.each |param| {\n         ebml_w.start_tag(tag);\n@@ -191,7 +195,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n }\n \n fn encode_type_param_bounds(ebml_w: &mut writer::Encoder,\n-                            ecx: @EncodeContext,\n+                            ecx: &EncodeContext,\n                             params: &OptVec<TyParam>) {\n     let ty_param_defs =\n         @params.map_to_vec(|param| ecx.tcx.ty_param_defs.get_copy(&param.id));\n@@ -206,39 +210,41 @@ fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: def_id) {\n     ebml_w.end_tag();\n }\n \n-pub fn write_type(ecx: @EncodeContext,\n+pub fn write_type(ecx: &EncodeContext,\n                   ebml_w: &mut writer::Encoder,\n                   typ: ty::t) {\n+    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n+        reachable: |a| r.contains(&a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-pub fn write_vstore(ecx: @EncodeContext,\n+pub fn write_vstore(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     vstore: ty::vstore) {\n+    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n+        reachable: |a| r.contains(&a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-fn encode_type(ecx: @EncodeContext,\n+fn encode_type(ecx: &EncodeContext,\n                ebml_w: &mut writer::Encoder,\n                typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n-fn encode_transformed_self_ty(ecx: @EncodeContext,\n+fn encode_transformed_self_ty(ecx: &EncodeContext,\n                               ebml_w: &mut writer::Encoder,\n                               opt_typ: Option<ty::t>) {\n     for opt_typ.iter().advance |&typ| {\n@@ -248,23 +254,24 @@ fn encode_transformed_self_ty(ecx: @EncodeContext,\n     }\n }\n \n-fn encode_method_fty(ecx: @EncodeContext,\n+fn encode_method_fty(ecx: &EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      typ: &ty::BareFnTy) {\n     ebml_w.start_tag(tag_item_method_fty);\n \n+    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n+        reachable: |a| r.contains(&a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n \n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @EncodeContext,\n+fn encode_symbol(ecx: &EncodeContext,\n                  ebml_w: &mut writer::Encoder,\n                  id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n@@ -281,15 +288,15 @@ fn encode_symbol(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @EncodeContext,\n+fn encode_discriminant(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(ecx.discrim_symbols.get_copy(&id).as_bytes());\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_: @EncodeContext,\n+fn encode_disr_val(_: &EncodeContext,\n                    ebml_w: &mut writer::Encoder,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n@@ -305,7 +312,7 @@ fn encode_parent_item(ebml_w: &mut writer::Encoder, id: def_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @EncodeContext,\n+fn encode_enum_variant_info(ecx: &EncodeContext,\n                             ebml_w: &mut writer::Encoder,\n                             id: node_id,\n                             variants: &[variant],\n@@ -349,11 +356,11 @@ fn encode_enum_variant_info(ecx: @EncodeContext,\n     }\n }\n \n-fn encode_path(ecx: @EncodeContext,\n+fn encode_path(ecx: &EncodeContext,\n                ebml_w: &mut writer::Encoder,\n                path: &[ast_map::path_elt],\n                name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @EncodeContext,\n+    fn encode_path_elt(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n@@ -373,7 +380,7 @@ fn encode_path(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_reexported_static_method(ecx: @EncodeContext,\n+fn encode_reexported_static_method(ecx: &EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: def_id,\n@@ -390,7 +397,7 @@ fn encode_reexported_static_method(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_reexported_static_base_methods(ecx: @EncodeContext,\n+fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          ebml_w: &mut writer::Encoder,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n@@ -411,7 +418,7 @@ fn encode_reexported_static_base_methods(ecx: @EncodeContext,\n     }\n }\n \n-fn encode_reexported_static_trait_methods(ecx: @EncodeContext,\n+fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           ebml_w: &mut writer::Encoder,\n                                           exp: &middle::resolve::Export2)\n                                           -> bool {\n@@ -430,7 +437,7 @@ fn encode_reexported_static_trait_methods(ecx: @EncodeContext,\n     }\n }\n \n-fn encode_reexported_static_methods(ecx: @EncodeContext,\n+fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n                                     mod_path: &[ast_map::path_elt],\n                                     exp: &middle::resolve::Export2) {\n@@ -466,7 +473,7 @@ fn encode_reexported_static_methods(ecx: @EncodeContext,\n     }\n }\n \n-fn encode_info_for_mod(ecx: @EncodeContext,\n+fn encode_info_for_mod(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        md: &_mod,\n                        id: node_id,\n@@ -598,7 +605,7 @@ fn encode_method_sort(ebml_w: &mut writer::Encoder, sort: char) {\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_struct(ecx: @EncodeContext,\n+fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           path: &[ast_map::path_elt],\n                           fields: &[@struct_field],\n@@ -633,7 +640,7 @@ fn encode_info_for_struct(ecx: @EncodeContext,\n }\n \n // This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: @EncodeContext,\n+fn encode_info_for_ctor(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         id: node_id,\n                         ident: ident,\n@@ -662,7 +669,7 @@ fn encode_info_for_ctor(ecx: @EncodeContext,\n         ebml_w.end_tag();\n }\n \n-fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n+fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut writer::Encoder,\n                                path: &[ast_map::path_elt],\n                                name: ast::ident,\n@@ -684,7 +691,7 @@ fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_method_ty_fields(ecx: @EncodeContext,\n+fn encode_method_ty_fields(ecx: &EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            method_ty: &ty::Method) {\n     encode_def_id(ebml_w, method_ty.def_id);\n@@ -698,7 +705,7 @@ fn encode_method_ty_fields(ecx: @EncodeContext,\n     encode_explicit_self(ebml_w, method_ty.explicit_self);\n }\n \n-fn encode_info_for_method(ecx: @EncodeContext,\n+fn encode_info_for_method(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           impl_path: &[ast_map::path_elt],\n                           should_inline: bool,\n@@ -769,7 +776,7 @@ fn should_inline(attrs: &[attribute]) -> bool {\n     }\n }\n \n-fn encode_info_for_item(ecx: @EncodeContext,\n+fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: @item,\n                         index: @mut ~[entry<int>],\n@@ -1075,7 +1082,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: @EncodeContext,\n+fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n@@ -1109,7 +1116,7 @@ fn encode_info_for_foreign_item(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @EncodeContext,\n+fn encode_info_for_items(ecx: &EncodeContext,\n                          ebml_w: &mut writer::Encoder,\n                          crate: &crate)\n                          -> ~[entry<int>] {\n@@ -1119,15 +1126,22 @@ fn encode_info_for_items(ecx: @EncodeContext,\n     encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n                         crate_node_id, [],\n                         syntax::parse::token::special_idents::invalid);\n+    let items = ecx.tcx.items;\n+\n+    // See comment in `encode_side_tables_for_ii` in astencode\n+    let ecx_ptr : *() = unsafe { cast::transmute(ecx) };\n+\n     visit::visit_crate(crate, ((), visit::mk_vt(@visit::Visitor {\n         visit_expr: |_e, (_cx, _v)| { },\n         visit_item: {\n             let ebml_w = copy *ebml_w;\n             |i, (cx, v)| {\n                 visit::visit_item(i, (cx, v));\n-                match ecx.tcx.items.get_copy(&i.id) {\n+                match items.get_copy(&i.id) {\n                     ast_map::node_item(_, pt) => {\n                         let mut ebml_w = copy ebml_w;\n+                        // See above\n+                        let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n                         encode_info_for_item(ecx, &mut ebml_w, i, index, *pt);\n                     }\n                     _ => fail!(\"bad item\")\n@@ -1138,9 +1152,11 @@ fn encode_info_for_items(ecx: @EncodeContext,\n             let ebml_w = copy *ebml_w;\n             |ni, (cx, v)| {\n                 visit::visit_foreign_item(ni, (cx, v));\n-                match ecx.tcx.items.get_copy(&ni.id) {\n+                match items.get_copy(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, _, pt) => {\n                         let mut ebml_w = copy ebml_w;\n+                        // See above\n+                        let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n                         encode_info_for_foreign_item(ecx,\n                                                      &mut ebml_w,\n                                                      ni,\n@@ -1267,10 +1283,10 @@ fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[attribute]) {\n // metadata that Rust cares about for linking crates. This attribute requires\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n // them in anyway with default values.\n-fn synthesize_crate_attrs(ecx: @EncodeContext,\n+fn synthesize_crate_attrs(ecx: &EncodeContext,\n                           crate: &crate) -> ~[attribute] {\n \n-    fn synthesize_link_attr(ecx: @EncodeContext, items: ~[@meta_item]) ->\n+    fn synthesize_link_attr(ecx: &EncodeContext, items: ~[@meta_item]) ->\n        attribute {\n \n         assert!(!ecx.link_meta.name.is_empty());\n@@ -1317,10 +1333,10 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n     return attrs;\n }\n \n-fn encode_crate_deps(ecx: @EncodeContext,\n+fn encode_crate_deps(ecx: &EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n-                     cstore: @mut cstore::CStore) {\n-    fn get_ordered_deps(ecx: @EncodeContext, cstore: @mut cstore::CStore)\n+                     cstore: &cstore::CStore) {\n+    fn get_ordered_deps(ecx: &EncodeContext, cstore: &cstore::CStore)\n                      -> ~[decoder::crate_dep] {\n         type numdep = decoder::crate_dep;\n \n@@ -1359,7 +1375,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_lang_items(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n+fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_lang_items);\n \n     for ecx.tcx.lang_items.each_item |def_id, i| {\n@@ -1383,7 +1399,7 @@ fn encode_lang_items(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();   // tag_lang_items\n }\n \n-fn encode_link_args(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n+fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_link_args);\n \n     let link_args = cstore::get_used_link_args(ecx.cstore);\n@@ -1396,7 +1412,7 @@ fn encode_link_args(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @EncodeContext,\n+fn encode_crate_dep(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n@@ -1444,47 +1460,49 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     let EncodeParams{item_symbols, diag, tcx, reachable, reexports2,\n                      discrim_symbols, cstore, encode_inlined_item,\n                      link_meta, _} = parms;\n-    let ecx = @EncodeContext {\n+    let type_abbrevs = @mut HashMap::new();\n+    let stats = @mut stats;\n+    let ecx = EncodeContext {\n         diag: diag,\n         tcx: tcx,\n-        stats: @mut stats,\n+        stats: stats,\n         reachable: reachable,\n         reexports2: reexports2,\n         item_symbols: item_symbols,\n         discrim_symbols: discrim_symbols,\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: encode_inlined_item,\n-        type_abbrevs: @mut HashMap::new()\n+        type_abbrevs: type_abbrevs\n      };\n \n     let mut ebml_w = writer::Encoder(wr as @io::Writer);\n \n     encode_hash(&mut ebml_w, ecx.link_meta.extras_hash);\n \n     let mut i = *wr.pos;\n-    let crate_attrs = synthesize_crate_attrs(ecx, crate);\n+    let crate_attrs = synthesize_crate_attrs(&ecx, crate);\n     encode_attributes(&mut ebml_w, crate_attrs);\n     ecx.stats.attr_bytes = *wr.pos - i;\n \n     i = *wr.pos;\n-    encode_crate_deps(ecx, &mut ebml_w, ecx.cstore);\n+    encode_crate_deps(&ecx, &mut ebml_w, ecx.cstore);\n     ecx.stats.dep_bytes = *wr.pos - i;\n \n     // Encode the language items.\n     i = *wr.pos;\n-    encode_lang_items(ecx, &mut ebml_w);\n+    encode_lang_items(&ecx, &mut ebml_w);\n     ecx.stats.lang_item_bytes = *wr.pos - i;\n \n     // Encode the link args.\n     i = *wr.pos;\n-    encode_link_args(ecx, &mut ebml_w);\n+    encode_link_args(&ecx, &mut ebml_w);\n     ecx.stats.link_args_bytes = *wr.pos - i;\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     i = *wr.pos;\n-    let items_index = encode_info_for_items(ecx, &mut ebml_w, crate);\n+    let items_index = encode_info_for_items(&ecx, &mut ebml_w, crate);\n     ecx.stats.item_bytes = *wr.pos - i;\n \n     i = *wr.pos;"}, {"sha": "e11367a7a7da606911e4a91f3b8d27ad6efa63b0", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -44,6 +44,8 @@ use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n+use core::cast;\n+\n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n \n@@ -80,7 +82,7 @@ trait tr_intern {\n // ______________________________________________________________________\n // Top-level methods.\n \n-pub fn encode_inlined_item(ecx: @e::EncodeContext,\n+pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            path: &[ast_map::path_elt],\n                            ii: ast::inlined_item,\n@@ -527,7 +529,7 @@ trait read_method_map_entry_helper {\n                              -> method_map_entry;\n }\n \n-fn encode_method_map_entry(ecx: @e::EncodeContext,\n+fn encode_method_map_entry(ecx: &e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            mme: method_map_entry) {\n     do ebml_w.emit_struct(\"method_map_entry\", 3) |ebml_w| {\n@@ -604,7 +606,7 @@ impl tr for method_origin {\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n-fn encode_vtable_res(ecx: @e::EncodeContext,\n+fn encode_vtable_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n@@ -616,7 +618,7 @@ fn encode_vtable_res(ecx: @e::EncodeContext,\n     }\n }\n \n-fn encode_vtable_origin(ecx: @e::EncodeContext,\n+fn encode_vtable_origin(ecx: &e::EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n     do ebml_w.emit_enum(\"vtable_origin\") |ebml_w| {\n@@ -702,53 +704,53 @@ impl vtable_decoder_helpers for reader::Decoder {\n // Encoding and decoding the side tables\n \n trait get_ty_str_ctxt {\n-    fn ty_str_ctxt(@self) -> @tyencode::ctxt;\n+    fn ty_str_ctxt(&self) -> @tyencode::ctxt;\n }\n \n-impl get_ty_str_ctxt for e::EncodeContext {\n-    // IMPLICIT SELF WARNING: fix this!\n-    fn ty_str_ctxt(@self) -> @tyencode::ctxt {\n+impl<'self> get_ty_str_ctxt for e::EncodeContext<'self> {\n+    fn ty_str_ctxt(&self) -> @tyencode::ctxt {\n+        let r = self.reachable;\n         @tyencode::ctxt {diag: self.tcx.sess.diagnostic(),\n                         ds: e::def_to_str,\n                         tcx: self.tcx,\n-                        reachable: |a| encoder::reachable(self, a),\n+                        reachable: |a| r.contains(&a),\n                         abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n     }\n }\n \n trait ebml_writer_helpers {\n-    fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t);\n-    fn emit_vstore(&mut self, ecx: @e::EncodeContext, vstore: ty::vstore);\n-    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: &[ty::t]);\n+    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t);\n+    fn emit_vstore(&mut self, ecx: &e::EncodeContext, vstore: ty::vstore);\n+    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]);\n     fn emit_type_param_def(&mut self,\n-                           ecx: @e::EncodeContext,\n+                           ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef);\n     fn emit_tpbt(&mut self,\n-                 ecx: @e::EncodeContext,\n+                 ecx: &e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty);\n }\n \n impl ebml_writer_helpers for writer::Encoder {\n-    fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t) {\n+    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n         do self.emit_opaque |this| {\n             e::write_type(ecx, this, ty)\n         }\n     }\n \n-    fn emit_vstore(&mut self, ecx: @e::EncodeContext, vstore: ty::vstore) {\n+    fn emit_vstore(&mut self, ecx: &e::EncodeContext, vstore: ty::vstore) {\n         do self.emit_opaque |this| {\n             e::write_vstore(ecx, this, vstore)\n         }\n     }\n \n-    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: &[ty::t]) {\n+    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]) {\n         do self.emit_from_vec(tys) |this, ty| {\n             this.emit_ty(ecx, *ty)\n         }\n     }\n \n     fn emit_type_param_def(&mut self,\n-                           ecx: @e::EncodeContext,\n+                           ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef) {\n         do self.emit_opaque |this| {\n             tyencode::enc_type_param_def(this.writer,\n@@ -758,7 +760,7 @@ impl ebml_writer_helpers for writer::Encoder {\n     }\n \n     fn emit_tpbt(&mut self,\n-                 ecx: @e::EncodeContext,\n+                 ecx: &e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n         do self.emit_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n             do this.emit_struct_field(\"generics\", 0) |this| {\n@@ -800,25 +802,33 @@ impl write_tag_and_id for writer::Encoder {\n     }\n }\n \n-fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n+fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: &mut writer::Encoder,\n                              ii: &ast::inlined_item) {\n     ebml_w.start_tag(c::tag_table as uint);\n     let new_ebml_w = copy *ebml_w;\n+\n+    // Because the ast visitor uses @fn, I can't pass in\n+    // ecx directly, but /I/ know that it'll be fine since\n+    // the lifetime is tied to the CrateContext that\n+    // lives this entire section.\n+    let ecx_ptr : *() = unsafe { cast::transmute(ecx) };\n     ast_util::visit_ids_for_inlined_item(\n         ii,\n         |id: ast::node_id| {\n             // Note: this will cause a copy of ebml_w, which is bad as\n             // it is mutable. But I believe it's harmless since we generate\n             // balanced EBML.\n             let mut new_ebml_w = copy new_ebml_w;\n+            // See above\n+            let ecx : &e::EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n             encode_side_tables_for_id(ecx, maps, &mut new_ebml_w, id)\n         });\n     ebml_w.end_tag();\n }\n \n-fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n+fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: &mut writer::Encoder,\n                              id: ast::node_id) {"}, {"sha": "029063b8c0df1bca0ac4c20e8b3bc75ed99378d0", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -1314,7 +1314,7 @@ pub fn compile_submatch(bcx: block,\n \n     let vals_left = vec::append(vec::slice(vals, 0u, col).to_vec(),\n                                 vec::slice(vals, col + 1u, vals.len()));\n-    let ccx = *bcx.fcx.ccx;\n+    let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n     let mut pat_span = dummy_sp();\n     for m.each |br| {\n@@ -1755,7 +1755,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                             binding_mode: IrrefutablePatternBindingMode)\n                          -> block {\n     let _icx = bcx.insn_ctxt(\"match::bind_irrefutable_pat\");\n-    let ccx = *bcx.fcx.ccx;\n+    let ccx = bcx.fcx.ccx;\n     let mut bcx = bcx;\n \n     // Necessary since bind_irrefutable_pat is called outside trans_match"}, {"sha": "ad07f41f8c30ec4da9d239f1eab99b3e1bc1d268", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -111,7 +111,7 @@ pub fn represent_node(bcx: block, node: ast::node_id) -> @Repr {\n }\n \n /// Decides how to represent a given type.\n-pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n+pub fn represent_type(cx: &mut CrateContext, t: ty::t) -> @Repr {\n     debug!(\"Representing: %s\", ty_to_str(cx.tcx, t));\n     match cx.adt_reprs.find(&t) {\n         Some(repr) => return *repr,\n@@ -123,7 +123,7 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n     return repr;\n }\n \n-fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n+fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n     match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n             return Univariant(mk_struct(cx, *elems, false), false)\n@@ -142,7 +142,7 @@ fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n         ty::ty_enum(def_id, ref substs) => {\n             struct Case { discr: int, tys: ~[ty::t] };\n             impl Case {\n-                fn is_zerolen(&self, cx: @CrateContext) -> bool {\n+                fn is_zerolen(&self, cx: &mut CrateContext) -> bool {\n                     mk_struct(cx, self.tys, false).size == 0\n                 }\n                 fn find_ptr(&self) -> Option<uint> {\n@@ -211,7 +211,7 @@ fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n     }\n }\n \n-fn mk_struct(cx: @CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n+fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n     let llty_rec = T_struct(lltys, packed);\n     Struct {\n@@ -227,14 +227,14 @@ fn mk_struct(cx: @CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n  * All nominal types are LLVM structs, in order to be able to use\n  * forward-declared opaque types to prevent circularity in `type_of`.\n  */\n-pub fn fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n+pub fn fields_of(cx: &mut CrateContext, r: &Repr) -> ~[TypeRef] {\n     generic_fields_of(cx, r, false)\n }\n /// Like `fields_of`, but for `type_of::sizing_type_of` (q.v.).\n-pub fn sizing_fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n+pub fn sizing_fields_of(cx: &mut CrateContext, r: &Repr) -> ~[TypeRef] {\n     generic_fields_of(cx, r, true)\n }\n-fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n+fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool)\n     -> ~[TypeRef] {\n     match *r {\n         CEnum(*) => ~[T_enum_discrim(cx)],\n@@ -268,7 +268,7 @@ fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n     }\n }\n \n-fn struct_llfields(cx: @CrateContext, st: &Struct, sizing: bool)\n+fn struct_llfields(cx: &mut CrateContext, st: &Struct, sizing: bool)\n     -> ~[TypeRef] {\n     if sizing {\n         st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n@@ -454,9 +454,10 @@ fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n     let ccx = bcx.ccx();\n \n     let val = if needs_cast {\n-        let real_llty = T_struct(st.fields.map(\n-            |&ty| type_of::type_of(ccx, ty)),\n-                                 st.packed);\n+        let fields = do st.fields.map |&ty| {\n+            type_of::type_of(ccx, ty)\n+        };\n+        let real_llty = T_struct(fields, st.packed);\n         PointerCast(bcx, val, T_ptr(real_llty))\n     } else {\n         val\n@@ -494,7 +495,7 @@ pub fn trans_drop_flag_ptr(bcx: block, r: &Repr, val: ValueRef) -> ValueRef {\n  * this could be changed in the future to avoid allocating unnecessary\n  * space after values of shorter-than-maximum cases.\n  */\n-pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n+pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: int,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n         CEnum(min, max) => {\n@@ -509,8 +510,9 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n         General(ref cases) => {\n             let case = &cases[discr as uint];\n             let max_sz = cases.map(|s| s.size).max();\n+            let discr_ty = C_int(ccx, discr);\n             let contents = build_const_struct(ccx, case,\n-                                              ~[C_int(ccx, discr)] + vals);\n+                                              ~[discr_ty] + vals);\n             C_struct(contents + [padding(max_sz - case.size)])\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n@@ -538,7 +540,7 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n  * a two-element struct will locate it at offset 4, and accesses to it\n  * will read the wrong memory.\n  */\n-fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n+fn build_const_struct(ccx: &mut CrateContext, st: &Struct, vals: &[ValueRef])\n     -> ~[ValueRef] {\n     assert_eq!(vals.len(), st.fields.len());\n \n@@ -579,7 +581,7 @@ fn padding(size: u64) -> ValueRef {\n fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.  (Not currently used.)\n-pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n+pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n     -> int {\n     match *r {\n         CEnum(*) => const_to_int(val) as int,\n@@ -598,7 +600,7 @@ pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n  * (Not to be confused with `common::const_get_elt`, which operates on\n  * raw LLVM-level structs and arrays.)\n  */\n-pub fn const_get_field(ccx: @CrateContext, r: &Repr, val: ValueRef,\n+pub fn const_get_field(ccx: &mut CrateContext, r: &Repr, val: ValueRef,\n                        _discr: int, ix: uint) -> ValueRef {\n     match *r {\n         CEnum(*) => ccx.sess.bug(\"element access in C-like enum const\"),\n@@ -609,7 +611,7 @@ pub fn const_get_field(ccx: @CrateContext, r: &Repr, val: ValueRef,\n }\n \n /// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(ccx: @CrateContext, val: ValueRef, ix: uint)\n+fn const_struct_field(ccx: &mut CrateContext, val: ValueRef, ix: uint)\n     -> ValueRef {\n     // Get the ix-th non-undef element of the struct.\n     let mut real_ix = 0; // actual position in the struct"}, {"sha": "e2073d21fe3969a556d3f1e0acf0afd4d059f2f3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 172, "deletions": 250, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -26,12 +26,11 @@\n use core::prelude::*;\n \n use back::link::{mangle_exported_name};\n-use back::{link, abi, upcall};\n+use back::{link, abi};\n use driver::session;\n use driver::session::Session;\n use lib::llvm::{ContextRef, ModuleRef, ValueRef, TypeRef, BasicBlockRef};\n-use lib::llvm::{True, False};\n-use lib::llvm::{llvm, mk_target_data, mk_type_names};\n+use lib::llvm::{llvm, True, False};\n use lib;\n use metadata::common::LinkMeta;\n use metadata::{csearch, cstore, encoder};\n@@ -65,7 +64,7 @@ use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n \n use core::hash;\n-use core::hashmap::{HashMap, HashSet};\n+use core::hashmap::{HashMap};\n use core::int;\n use core::io;\n use core::libc::c_uint;\n@@ -86,8 +85,10 @@ use syntax::visit;\n use syntax::{ast, ast_util, codemap, ast_map};\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n+pub use middle::trans::context::task_llcx;\n+\n pub struct icx_popper {\n-    ccx: @CrateContext,\n+    ccx: @mut CrateContext,\n }\n \n #[unsafe_destructor]\n@@ -99,7 +100,7 @@ impl Drop for icx_popper {\n     }\n }\n \n-pub fn icx_popper(ccx: @CrateContext) -> icx_popper {\n+pub fn icx_popper(ccx: @mut CrateContext) -> icx_popper {\n     icx_popper {\n         ccx: ccx\n     }\n@@ -109,7 +110,7 @@ pub trait get_insn_ctxt {\n     fn insn_ctxt(&self, s: &str) -> icx_popper;\n }\n \n-impl get_insn_ctxt for @CrateContext {\n+impl get_insn_ctxt for @mut CrateContext {\n     fn insn_ctxt(&self, s: &str) -> icx_popper {\n         debug!(\"new insn_ctxt: %s\", s);\n         if self.sess.count_llvm_insns() {\n@@ -138,7 +139,7 @@ fn fcx_has_nonzero_span(fcx: fn_ctxt) -> bool {\n     }\n }\n \n-pub fn log_fn_time(ccx: @CrateContext, name: ~str, start: time::Timespec,\n+pub fn log_fn_time(ccx: @mut CrateContext, name: ~str, start: time::Timespec,\n                    end: time::Timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.nsec as int) - (start.nsec as int)) / 1000000;\n@@ -174,7 +175,7 @@ pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: ~str, llty: TypeRef) ->\n     return llfn;\n }\n \n-pub fn get_extern_fn(externs: ExternMap,\n+pub fn get_extern_fn(externs: &mut ExternMap,\n                      llmod: ModuleRef,\n                      name: @str,\n                      cc: lib::llvm::CallConv,\n@@ -188,7 +189,7 @@ pub fn get_extern_fn(externs: ExternMap,\n     return f;\n }\n \n-pub fn get_extern_const(externs: ExternMap, llmod: ModuleRef,\n+pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n                         name: @str, ty: TypeRef) -> ValueRef {\n     match externs.find(&name) {\n         Some(n) => return copy *n,\n@@ -203,11 +204,11 @@ pub fn get_extern_const(externs: ExternMap, llmod: ModuleRef,\n     }\n }\n \n-    fn get_simple_extern_fn(cx: block,\n-                            externs: ExternMap,\n-                            llmod: ModuleRef,\n-                            name: @str,\n-                            n_args: int) -> ValueRef {\n+fn get_simple_extern_fn(cx: block,\n+                        externs: &mut ExternMap,\n+                        llmod: ModuleRef,\n+                        name: @str,\n+                        n_args: int) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"get_simple_extern_fn\");\n     let ccx = cx.fcx.ccx;\n     let inputs = vec::from_elem(n_args as uint, ccx.int_type);\n@@ -216,7 +217,7 @@ pub fn get_extern_const(externs: ExternMap, llmod: ModuleRef,\n     return get_extern_fn(externs, llmod, name, lib::llvm::CCallConv, t);\n }\n \n-pub fn trans_foreign_call(cx: block, externs: ExternMap,\n+pub fn trans_foreign_call(cx: block, externs: &mut ExternMap,\n                           llmod: ModuleRef, name: @str, args: &[ValueRef]) ->\n    ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_foreign_call\");\n@@ -268,7 +269,9 @@ pub fn opaque_box_body(bcx: block,\n                        boxptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n-    let boxptr = PointerCast(bcx, boxptr, T_ptr(T_box(ccx, type_of(ccx, body_t))));\n+    let ty = type_of(ccx, body_t);\n+    let ty = T_box(ccx, ty);\n+    let boxptr = PointerCast(bcx, boxptr, T_ptr(ty));\n     GEPi(bcx, boxptr, [0u, abi::box_field_body])\n }\n \n@@ -334,7 +337,9 @@ pub fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n pub fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> Result {\n-    malloc_raw_dyn(bcx, t, heap, llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n+    let ty = type_of(bcx.ccx(), t);\n+    let size = llsize_of(bcx.ccx(), ty);\n+    malloc_raw_dyn(bcx, t, heap, size)\n }\n \n pub struct MallocResult {\n@@ -357,8 +362,8 @@ pub fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n \n pub fn malloc_general(bcx: block, t: ty::t, heap: heap)\n     -> MallocResult {\n-    malloc_general_dyn(bcx, t, heap,\n-                       llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n+        let ty = type_of(bcx.ccx(), t);\n+    malloc_general_dyn(bcx, t, heap, llsize_of(bcx.ccx(), ty))\n }\n pub fn malloc_boxed(bcx: block, t: ty::t)\n     -> MallocResult {\n@@ -380,7 +385,8 @@ pub fn maybe_set_managed_unique_rc(bcx: block, bx: ValueRef, heap: heap) {\n         // such as a ~(@foo) or such. These need to have their refcount forced\n         // to -2 so the annihilator ignores them.\n         let rc = GEPi(bcx, bx, [0u, abi::box_field_refcnt]);\n-        Store(bcx, C_int(bcx.ccx(), -2), rc);\n+        let rc_val = C_int(bcx.ccx(), -2);\n+        Store(bcx, rc_val, rc);\n     }\n }\n \n@@ -391,11 +397,11 @@ pub fn malloc_unique(bcx: block, t: ty::t)\n \n // Type descriptor and type glue stuff\n \n-pub fn get_tydesc_simple(ccx: @CrateContext, t: ty::t) -> ValueRef {\n+pub fn get_tydesc_simple(ccx: &mut CrateContext, t: ty::t) -> ValueRef {\n     get_tydesc(ccx, t).tydesc\n }\n \n-pub fn get_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n+pub fn get_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     match ccx.tydescs.find(&t) {\n         Some(&inf) => {\n             return inf;\n@@ -484,15 +490,15 @@ pub fn set_glue_inlining(f: ValueRef, t: ty::t) {\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n-pub fn note_unique_llvm_symbol(ccx: @CrateContext, sym: @str) {\n+pub fn note_unique_llvm_symbol(ccx: &mut CrateContext, sym: @str) {\n     if ccx.all_llvm_symbols.contains(&sym) {\n         ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n     }\n     ccx.all_llvm_symbols.insert(sym);\n }\n \n \n-pub fn get_res_dtor(ccx: @CrateContext,\n+pub fn get_res_dtor(ccx: @mut CrateContext,\n                     did: ast::def_id,\n                     parent_id: ast::def_id,\n                     substs: &[ty::t])\n@@ -526,7 +532,7 @@ pub fn get_res_dtor(ccx: @CrateContext,\n                                      ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n         let name = name.to_managed(); // :-(\n-        get_extern_fn(ccx.externs,\n+        get_extern_fn(&mut ccx.externs,\n                       ccx.llmod,\n                       name,\n                       lib::llvm::CCallConv,\n@@ -535,7 +541,7 @@ pub fn get_res_dtor(ccx: @CrateContext,\n }\n \n // Structural comparison: a rather involved form of glue.\n-pub fn maybe_name_value(cx: @CrateContext, v: ValueRef, s: &str) {\n+pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n     if cx.sess.opts.save_temps {\n         let _: () = str::as_c_str(s, |buf| {\n             unsafe {\n@@ -817,18 +823,18 @@ pub fn null_env_ptr(bcx: block) -> ValueRef {\n     C_null(T_opaque_box_ptr(bcx.ccx()))\n }\n \n-pub fn trans_external_path(ccx: @CrateContext, did: ast::def_id, t: ty::t)\n+pub fn trans_external_path(ccx: &mut CrateContext, did: ast::def_id, t: ty::t)\n     -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did).to_managed(); // Sad\n     match ty::get(t).sty {\n       ty::ty_bare_fn(_) | ty::ty_closure(_) => {\n         let llty = type_of_fn_from_ty(ccx, t);\n-        return get_extern_fn(ccx.externs, ccx.llmod, name,\n+        return get_extern_fn(&mut ccx.externs, ccx.llmod, name,\n                              lib::llvm::CCallConv, llty);\n       }\n       _ => {\n         let llty = type_of(ccx, t);\n-        return get_extern_const(ccx.externs, ccx.llmod, name, llty);\n+        return get_extern_const(&mut ccx.externs, ccx.llmod, name, llty);\n       }\n     };\n }\n@@ -1165,7 +1171,7 @@ pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n                         debuginfo::create_local_var(bcx, *local);\n                     }\n                 }\n-                ast::decl_item(i) => trans_item(*cx.fcx.ccx, i)\n+                ast::decl_item(i) => trans_item(cx.fcx.ccx, i)\n             }\n         }\n         ast::stmt_mac(*) => cx.tcx().sess.bug(\"unexpanded macro\")\n@@ -1455,7 +1461,7 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n         X86 | Arm | Mips => \"llvm.memcpy.p0i8.p0i8.i32\",\n         X86_64 => \"llvm.memcpy.p0i8.p0i8.i64\"\n     };\n-    let memcpy = *ccx.intrinsics.get(&key);\n+    let memcpy = ccx.intrinsics.get_copy(&key);\n     let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n     let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n@@ -1499,7 +1505,7 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n         X86_64 => \"llvm.memset.p0i8.i64\"\n     };\n \n-    let llintrinsicfn = *ccx.intrinsics.get(&intrinsic_key);\n+    let llintrinsicfn = ccx.intrinsics.get_copy(&intrinsic_key);\n     let llptr = PointerCast(cx, llptr, T_ptr(T_i8()));\n     let llzeroval = C_u8(0);\n     let size = IntCast(cx, machine::llsize_of(ccx, llty), ccx.int_type);\n@@ -1571,7 +1577,7 @@ pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n         if !ty::type_is_immediate(output_type) {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n-            let lloutputtype = type_of::type_of(*fcx.ccx, output_type);\n+            let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n             alloca(raw_block(fcx, false, fcx.llstaticallocas), lloutputtype)\n         }\n     }\n@@ -1583,7 +1589,7 @@ pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n+pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         path: path,\n                         llfndecl: ValueRef,\n                         id: ast::node_id,\n@@ -1631,7 +1637,7 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n           param_substs: param_substs,\n           span: sp,\n           path: path,\n-          ccx: @ccx\n+          ccx: ccx\n     };\n     fcx.llenv = unsafe {\n           llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n@@ -1640,7 +1646,7 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n     fcx\n }\n \n-pub fn new_fn_ctxt(ccx: @CrateContext,\n+pub fn new_fn_ctxt(ccx: @mut CrateContext,\n                    path: path,\n                    llfndecl: ValueRef,\n                    output_type: ty::t,\n@@ -1816,7 +1822,7 @@ pub enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-pub fn trans_closure(ccx: @CrateContext,\n+pub fn trans_closure(ccx: @mut CrateContext,\n                      path: path,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n@@ -1860,7 +1866,7 @@ pub fn trans_closure(ccx: @CrateContext,\n                 llvm::LLVMSetGC(fcx.llfn, strategy);\n             }\n         }\n-        *ccx.uses_gc = true;\n+        ccx.uses_gc = true;\n     }\n \n     // Create the first basic block in the function and keep a handle on it to\n@@ -1897,7 +1903,7 @@ pub fn trans_closure(ccx: @CrateContext,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-pub fn trans_fn(ccx: @CrateContext,\n+pub fn trans_fn(ccx: @mut CrateContext,\n                 path: path,\n                 decl: &ast::fn_decl,\n                 body: &ast::blk,\n@@ -1941,7 +1947,7 @@ pub fn trans_fn(ccx: @CrateContext,\n     }\n }\n \n-pub fn trans_enum_variant(ccx: @CrateContext,\n+pub fn trans_enum_variant(ccx: @mut CrateContext,\n                           enum_id: ast::node_id,\n                           variant: &ast::variant,\n                           args: &[ast::variant_arg],\n@@ -2017,7 +2023,7 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n \n // NB: In theory this should be merged with the function above. But the AST\n // structures are completely different, so very little code would be shared.\n-pub fn trans_tuple_struct(ccx: @CrateContext,\n+pub fn trans_tuple_struct(ccx: @mut CrateContext,\n                           fields: &[@ast::struct_field],\n                           ctor_id: ast::node_id,\n                           param_substs: Option<@param_substs>,\n@@ -2084,7 +2090,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n     finish_fn(fcx, lltop);\n }\n \n-pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n+pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n                       id: ast::node_id, vi: @~[ty::VariantInfo],\n                       i: &mut uint) {\n     for enum_definition.variants.each |variant| {\n@@ -2107,7 +2113,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n     }\n }\n \n-pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n+pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_item\");\n     let path = match ccx.tcx.items.get_copy(&item.id) {\n         ast_map::node_item(_, p) => p,\n@@ -2195,7 +2201,7 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n     }\n }\n \n-pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def) {\n+pub fn trans_struct_def(ccx: @mut CrateContext, struct_def: @ast::struct_def) {\n     // If this is a tuple-like struct, translate the constructor.\n     match struct_def.ctor_id {\n         // We only need to translate a constructor if there are fields;\n@@ -2214,14 +2220,14 @@ pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def) {\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-pub fn trans_mod(ccx: @CrateContext, m: &ast::_mod) {\n+pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n     let _icx = ccx.insn_ctxt(\"trans_mod\");\n     for m.items.each |item| {\n         trans_item(ccx, *item);\n     }\n }\n \n-pub fn register_fn(ccx: @CrateContext,\n+pub fn register_fn(ccx: @mut CrateContext,\n                    sp: span,\n                    path: path,\n                    node_id: ast::node_id,\n@@ -2231,7 +2237,7 @@ pub fn register_fn(ccx: @CrateContext,\n     register_fn_full(ccx, sp, path, node_id, attrs, t)\n }\n \n-pub fn register_fn_full(ccx: @CrateContext,\n+pub fn register_fn_full(ccx: @mut CrateContext,\n                         sp: span,\n                         path: path,\n                         node_id: ast::node_id,\n@@ -2243,7 +2249,7 @@ pub fn register_fn_full(ccx: @CrateContext,\n                        lib::llvm::CCallConv, llfty)\n }\n \n-pub fn register_fn_fuller(ccx: @CrateContext,\n+pub fn register_fn_fuller(ccx: @mut CrateContext,\n                           sp: span,\n                           path: path,\n                           node_id: ast::node_id,\n@@ -2285,7 +2291,7 @@ pub fn is_entry_fn(sess: &Session, node_id: ast::node_id) -> bool {\n \n // Create a _rust_main(args: ~[str]) function which will be called from the\n // runtime rust_start function\n-pub fn create_entry_wrapper(ccx: @CrateContext,\n+pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                            _sp: span, main_llfn: ValueRef) {\n     let et = ccx.sess.entry_type.unwrap();\n     if et == session::EntryMain {\n@@ -2295,7 +2301,7 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n         create_entry_fn(ccx, main_llfn, false);\n     }\n \n-    fn create_main(ccx: @CrateContext, main_llfn: ValueRef) -> ValueRef {\n+    fn create_main(ccx: @mut CrateContext, main_llfn: ValueRef) -> ValueRef {\n         let nt = ty::mk_nil();\n \n         let llfty = type_of_fn(ccx, [], nt);\n@@ -2325,7 +2331,7 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n         return llfdecl;\n     }\n \n-    fn create_entry_fn(ccx: @CrateContext,\n+    fn create_entry_fn(ccx: @mut CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n         let llfty = T_fn([ccx.int_type, T_ptr(T_ptr(T_i8()))], ccx.int_type);\n@@ -2419,7 +2425,7 @@ pub fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n-pub fn item_path(ccx: @CrateContext, i: @ast::item) -> path {\n+pub fn item_path(ccx: &CrateContext, i: @ast::item) -> path {\n     let base = match ccx.tcx.items.get_copy(&i.id) {\n         ast_map::node_item(_, p) => p,\n             // separate map for paths?\n@@ -2428,20 +2434,21 @@ pub fn item_path(ccx: @CrateContext, i: @ast::item) -> path {\n     vec::append(/*bad*/copy *base, [path_name(i.ident)])\n }\n \n-pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n+pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n     debug!(\"get_item_val(id=`%?`)\", id);\n-    let tcx = ccx.tcx;\n-    match ccx.item_vals.find(&id) {\n-      Some(&v) => v,\n+    let val = ccx.item_vals.find_copy(&id);\n+    match val {\n+      Some(v) => v,\n       None => {\n         let mut exprt = false;\n-        let val = match tcx.items.get_copy(&id) {\n+        let item = ccx.tcx.items.get_copy(&id);\n+        let val = match item {\n           ast_map::node_item(i, pth) => {\n             let my_path = vec::append(/*bad*/copy *pth,\n                                       [path_name(i.ident)]);\n             match i.node {\n               ast::item_const(_, expr) => {\n-                let typ = ty::node_id_to_type(tcx, i.id);\n+                let typ = ty::node_id_to_type(ccx.tcx, i.id);\n                 let s = mangle_exported_name(ccx, my_path, typ);\n                 // We need the translated value here, because for enums the\n                 // LLVM type is not fully determined by the Rust type.\n@@ -2500,13 +2507,12 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n                                 ni.attrs)\n                 }\n                 ast::foreign_item_const(*) => {\n-                    let typ = ty::node_id_to_type(tcx, ni.id);\n+                    let typ = ty::node_id_to_type(ccx.tcx, ni.id);\n                     let ident = token::ident_to_str(&ni.ident);\n                     let g = do str::as_c_str(ident) |buf| {\n                         unsafe {\n-                            llvm::LLVMAddGlobal(ccx.llmod,\n-                                                type_of(ccx, typ),\n-                                                buf)\n+                            let ty = type_of(ccx, typ);\n+                            llvm::LLVMAddGlobal(ccx.llmod, ty, buf)\n                         }\n                     };\n                     g\n@@ -2541,7 +2547,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             // Only register the constructor if this is a tuple-like struct.\n             match struct_def.ctor_id {\n                 None => {\n-                    tcx.sess.bug(\"attempt to register a constructor of \\\n+                    ccx.tcx.sess.bug(\"attempt to register a constructor of \\\n                                   a non-tuple-like struct\")\n                 }\n                 Some(ctor_id) => {\n@@ -2570,7 +2576,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n     }\n }\n \n-pub fn register_method(ccx: @CrateContext,\n+pub fn register_method(ccx: @mut CrateContext,\n                        id: ast::node_id,\n                        pth: @ast_map::path,\n                        m: @ast::method) -> ValueRef {\n@@ -2583,7 +2589,7 @@ pub fn register_method(ccx: @CrateContext,\n }\n \n // The constant translation pass.\n-pub fn trans_constant(ccx: @CrateContext, it: @ast::item) {\n+pub fn trans_constant(ccx: @mut CrateContext, it: @ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_constant\");\n     match it.node {\n       ast::item_enum(ref enum_definition, _) => {\n@@ -2619,7 +2625,7 @@ pub fn trans_constant(ccx: @CrateContext, it: @ast::item) {\n     }\n }\n \n-pub fn trans_constants(ccx: @CrateContext, crate: &ast::crate) {\n+pub fn trans_constants(ccx: @mut CrateContext, crate: &ast::crate) {\n     visit::visit_crate(\n         crate, ((),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n@@ -2633,7 +2639,7 @@ pub fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n     return PtrToInt(cx, v, ccx.int_type);\n }\n \n-pub fn p2i(ccx: @CrateContext, v: ValueRef) -> ValueRef {\n+pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstPtrToInt(v, ccx.int_type);\n     }\n@@ -2852,8 +2858,8 @@ pub fn trap(bcx: block) {\n     }\n }\n \n-pub fn decl_gc_metadata(ccx: @CrateContext, llmod_id: &str) {\n-    if !ccx.sess.opts.gc || !*ccx.uses_gc {\n+pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n+    if !ccx.sess.opts.gc || !ccx.uses_gc {\n         return;\n     }\n \n@@ -2870,7 +2876,7 @@ pub fn decl_gc_metadata(ccx: @CrateContext, llmod_id: &str) {\n     }\n }\n \n-pub fn create_module_map(ccx: @CrateContext) -> ValueRef {\n+pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n     let elttype = T_struct([ccx.int_type, ccx.int_type], false);\n     let maptype = T_array(elttype, ccx.module_data.len() + 1);\n     let map = str::as_c_str(\"_rust_mod_map\", |buf| {\n@@ -2880,9 +2886,21 @@ pub fn create_module_map(ccx: @CrateContext) -> ValueRef {\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     let mut elts: ~[ValueRef] = ~[];\n-    for ccx.module_data.each |key, &val| {\n-        let elt = C_struct([p2i(ccx, C_cstr(ccx, /* bad */key.to_managed())),\n-                            p2i(ccx, val)]);\n+\n+    // This is not ideal, but the borrow checker doesn't\n+    // like the multiple borrows. At least, it doesn't\n+    // like them on the current snapshot. (2013-06-14)\n+    let mut keys = ~[];\n+    for ccx.module_data.each_key |k| {\n+        keys.push(k.to_managed());\n+    }\n+\n+    for keys.each |key| {\n+        let val = *ccx.module_data.find_equiv(key).get();\n+        let s_const = C_cstr(ccx, *key);\n+        let s_ptr = p2i(ccx, s_const);\n+        let v_ptr = p2i(ccx, val);\n+        let elt = C_struct([s_ptr, v_ptr]);\n         elts.push(elt);\n     }\n     let term = C_struct([C_int(ccx, 0), C_int(ccx, 0)]);\n@@ -2918,7 +2936,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     return map;\n }\n \n-pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n+pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n     let mut subcrates: ~[ValueRef] = ~[];\n     let mut i = 1;\n     let cstore = ccx.sess.cstore;\n@@ -2951,37 +2969,44 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n     }\n \n     unsafe {\n+        let mod_map = create_module_map(ccx);\n         llvm::LLVMSetInitializer(map, C_struct(\n             [C_i32(1),\n              lib::llvm::llvm::LLVMConstPointerCast(llannihilatefn,\n                                                    T_ptr(T_i8())),\n-             p2i(ccx, create_module_map(ccx)),\n+             p2i(ccx, mod_map),\n              C_array(ccx.int_type, subcrates)]));\n     }\n }\n \n-pub fn crate_ctxt_to_encode_parms(cx: @CrateContext)\n-    -> encoder::EncodeParams {\n+pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_inlined_item<'r>)\n+    -> encoder::EncodeParams<'r> {\n+\n+        let diag = cx.sess.diagnostic();\n+        let item_symbols = &cx.item_symbols;\n+        let discrim_symbols = &cx.discrim_symbols;\n+        let link_meta = &cx.link_meta;\n+        encoder::EncodeParams {\n+            diag: diag,\n+            tcx: cx.tcx,\n+            reachable: cx.reachable,\n+            reexports2: cx.exp_map2,\n+            item_symbols: item_symbols,\n+            discrim_symbols: discrim_symbols,\n+            link_meta: link_meta,\n+            cstore: cx.sess.cstore,\n+            encode_inlined_item: ie\n+        }\n+}\n+\n+pub fn write_metadata(cx: &mut CrateContext, crate: &ast::crate) {\n+    if !*cx.sess.building_library { return; }\n+\n     let encode_inlined_item: encoder::encode_inlined_item =\n         |ecx, ebml_w, path, ii|\n         astencode::encode_inlined_item(ecx, ebml_w, path, ii, cx.maps);\n \n-    encoder::EncodeParams {\n-        diag: cx.sess.diagnostic(),\n-        tcx: cx.tcx,\n-        reachable: cx.reachable,\n-        reexports2: cx.exp_map2,\n-        item_symbols: cx.item_symbols,\n-        discrim_symbols: cx.discrim_symbols,\n-        link_meta: /*bad*/copy cx.link_meta,\n-        cstore: cx.sess.cstore,\n-        encode_inlined_item: encode_inlined_item\n-    }\n-}\n-\n-pub fn write_metadata(cx: @CrateContext, crate: &ast::crate) {\n-    if !*cx.sess.building_library { return; }\n-    let encode_parms = crate_ctxt_to_encode_parms(cx);\n+    let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n     let llconst = C_struct([llmeta]);\n     let mut llglobal = str::as_c_str(\"rust_metadata\", |buf| {\n@@ -3007,7 +3032,7 @@ pub fn write_metadata(cx: @CrateContext, crate: &ast::crate) {\n }\n \n // Writes the current ABI version into the crate.\n-pub fn write_abi_version(ccx: @CrateContext) {\n+pub fn write_abi_version(ccx: &mut CrateContext) {\n     mk_global(ccx, ~\"rust_abi_version\", C_uint(ccx, abi::abi_version),\n                      false);\n }\n@@ -3019,8 +3044,8 @@ pub fn trans_crate(sess: session::Session,\n                    emap2: resolve::ExportMap2,\n                    maps: astencode::Maps) -> (ContextRef, ModuleRef, LinkMeta) {\n \n-    let symbol_hasher = @mut hash::default_state();\n-    let link_meta = link::build_link_meta(sess, crate, output, symbol_hasher);\n+    let mut symbol_hasher = hash::default_state();\n+    let link_meta = link::build_link_meta(sess, crate, output, &mut symbol_hasher);\n     let reachable = reachable::find_reachable(\n         &crate.node.module,\n         emap2,\n@@ -3038,164 +3063,61 @@ pub fn trans_crate(sess: session::Session,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = link_meta.name.to_owned() + \".rc\";\n \n-    unsafe {\n-        // FIXME(#6511): get LLVM building with --enable-threads so this\n-        //               function can be called\n-        // if !llvm::LLVMRustStartMultithreading() {\n-        //     sess.bug(\"couldn't enable multi-threaded LLVM\");\n-        // }\n-        let llcx = llvm::LLVMContextCreate();\n-        set_task_llcx(llcx);\n-        let llmod = str::as_c_str(llmod_id, |buf| {\n-            llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n-        });\n-        let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n-        let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n-        let _: () =\n-            str::as_c_str(data_layout,\n-                        |buf| llvm::LLVMSetDataLayout(llmod, buf));\n-        let _: () =\n-            str::as_c_str(targ_triple,\n-                        |buf| llvm::LLVMSetTarget(llmod, buf));\n-        let targ_cfg = sess.targ_cfg;\n-        let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n-        let tn = mk_type_names();\n-        let mut intrinsics = declare_intrinsics(llmod);\n-        if sess.opts.extra_debuginfo {\n-            declare_dbg_intrinsics(llmod, &mut intrinsics);\n-        }\n-        let int_type = T_int(targ_cfg);\n-        let float_type = T_float(targ_cfg);\n-        let tydesc_type = T_tydesc(targ_cfg);\n-        lib::llvm::associate_type(tn, @\"tydesc\", tydesc_type);\n-        let crate_map = decl_crate_map(sess, link_meta, llmod);\n-        let dbg_cx = if sess.opts.debuginfo {\n-            Some(debuginfo::mk_ctxt(copy llmod_id))\n-        } else {\n-            None\n-        };\n+    // FIXME(#6511): get LLVM building with --enable-threads so this\n+    //               function can be called\n+    // if !llvm::LLVMRustStartMultithreading() {\n+    //     sess.bug(\"couldn't enable multi-threaded LLVM\");\n+    // }\n \n-        let ccx = @CrateContext {\n-              sess: sess,\n-              llmod: llmod,\n-              llcx: llcx,\n-              td: td,\n-              tn: tn,\n-              externs: @mut HashMap::new(),\n-              intrinsics: intrinsics,\n-              item_vals: @mut HashMap::new(),\n-              exp_map2: emap2,\n-              reachable: reachable,\n-              item_symbols: @mut HashMap::new(),\n-              link_meta: link_meta,\n-              enum_sizes: @mut HashMap::new(),\n-              discrims: @mut HashMap::new(),\n-              discrim_symbols: @mut HashMap::new(),\n-              tydescs: @mut HashMap::new(),\n-              finished_tydescs: @mut false,\n-              external: @mut HashMap::new(),\n-              monomorphized: @mut HashMap::new(),\n-              monomorphizing: @mut HashMap::new(),\n-              type_use_cache: @mut HashMap::new(),\n-              vtables: @mut HashMap::new(),\n-              const_cstr_cache: @mut HashMap::new(),\n-              const_globals: @mut HashMap::new(),\n-              const_values: @mut HashMap::new(),\n-              extern_const_values: @mut HashMap::new(),\n-              impl_method_cache: @mut HashMap::new(),\n-              module_data: @mut HashMap::new(),\n-              lltypes: @mut HashMap::new(),\n-              llsizingtypes: @mut HashMap::new(),\n-              adt_reprs: @mut HashMap::new(),\n-              names: new_namegen(),\n-              next_addrspace: new_addrspace_gen(),\n-              symbol_hasher: symbol_hasher,\n-              type_hashcodes: @mut HashMap::new(),\n-              type_short_names: @mut HashMap::new(),\n-              all_llvm_symbols: @mut HashSet::new(),\n-              tcx: tcx,\n-              maps: maps,\n-              stats: @mut Stats {\n-                n_static_tydescs: 0u,\n-                n_glues_created: 0u,\n-                n_null_glues: 0u,\n-                n_real_glues: 0u,\n-                n_fns: 0u,\n-                n_monos: 0u,\n-                n_inlines: 0u,\n-                n_closures: 0u,\n-                llvm_insn_ctxt: @mut ~[],\n-                llvm_insns: @mut HashMap::new(),\n-                fn_times: @mut ~[]\n-              },\n-              upcalls: upcall::declare_upcalls(targ_cfg, llmod),\n-              tydesc_type: tydesc_type,\n-              int_type: int_type,\n-              float_type: float_type,\n-              opaque_vec_type: T_opaque_vec(targ_cfg),\n-              builder: BuilderRef_res(unsafe {\n-                  llvm::LLVMCreateBuilderInContext(llcx)\n-              }),\n-              shape_cx: mk_ctxt(llmod),\n-              crate_map: crate_map,\n-              uses_gc: @mut false,\n-              dbg_cx: dbg_cx,\n-              do_not_commit_warning_issued: @mut false\n-        };\n+    let ccx = @mut CrateContext::new(sess, llmod_id, tcx, emap2, maps,\n+                                 symbol_hasher, link_meta, reachable);\n+    // FIXME(#6511): get LLVM building with --enable-threads so this\n+    //               function can be called\n+    // if !llvm::LLVMRustStartMultithreading() {\n+    //     sess.bug(\"couldn't enable multi-threaded LLVM\");\n+    // }\n \n-        {\n-            let _icx = ccx.insn_ctxt(\"data\");\n-            trans_constants(ccx, crate);\n-        }\n-\n-        {\n-            let _icx = ccx.insn_ctxt(\"text\");\n-            trans_mod(ccx, &crate.node.module);\n-        }\n-\n-        decl_gc_metadata(ccx, llmod_id);\n-        fill_crate_map(ccx, crate_map);\n-        glue::emit_tydescs(ccx);\n-        write_abi_version(ccx);\n-\n-        // Translate the metadata.\n-        write_metadata(ccx, crate);\n-        if ccx.sess.trans_stats() {\n-            io::println(\"--- trans stats ---\");\n-            io::println(fmt!(\"n_static_tydescs: %u\",\n-                             ccx.stats.n_static_tydescs));\n-            io::println(fmt!(\"n_glues_created: %u\",\n-                             ccx.stats.n_glues_created));\n-            io::println(fmt!(\"n_null_glues: %u\", ccx.stats.n_null_glues));\n-            io::println(fmt!(\"n_real_glues: %u\", ccx.stats.n_real_glues));\n-\n-            io::println(fmt!(\"n_fns: %u\", ccx.stats.n_fns));\n-            io::println(fmt!(\"n_monos: %u\", ccx.stats.n_monos));\n-            io::println(fmt!(\"n_inlines: %u\", ccx.stats.n_inlines));\n-            io::println(fmt!(\"n_closures: %u\", ccx.stats.n_closures));\n-        }\n+    {\n+        let _icx = ccx.insn_ctxt(\"data\");\n+        trans_constants(ccx, crate);\n+    }\n \n-        if ccx.sess.count_llvm_insns() {\n-            for ccx.stats.llvm_insns.each |&k, &v| {\n-                io::println(fmt!(\"%-7u %s\", v, k));\n-            }\n+    {\n+        let _icx = ccx.insn_ctxt(\"text\");\n+        trans_mod(ccx, &crate.node.module);\n+    }\n+\n+    decl_gc_metadata(ccx, llmod_id);\n+    fill_crate_map(ccx, ccx.crate_map);\n+    glue::emit_tydescs(ccx);\n+    write_abi_version(ccx);\n+\n+    // Translate the metadata.\n+    write_metadata(ccx, crate);\n+    if ccx.sess.trans_stats() {\n+        io::println(\"--- trans stats ---\");\n+        io::println(fmt!(\"n_static_tydescs: %u\",\n+                         ccx.stats.n_static_tydescs));\n+        io::println(fmt!(\"n_glues_created: %u\",\n+                         ccx.stats.n_glues_created));\n+        io::println(fmt!(\"n_null_glues: %u\", ccx.stats.n_null_glues));\n+        io::println(fmt!(\"n_real_glues: %u\", ccx.stats.n_real_glues));\n+\n+        io::println(fmt!(\"n_fns: %u\", ccx.stats.n_fns));\n+        io::println(fmt!(\"n_monos: %u\", ccx.stats.n_monos));\n+        io::println(fmt!(\"n_inlines: %u\", ccx.stats.n_inlines));\n+        io::println(fmt!(\"n_closures: %u\", ccx.stats.n_closures));\n+    }\n+\n+    if ccx.sess.count_llvm_insns() {\n+        for ccx.stats.llvm_insns.each |&k, &v| {\n+            io::println(fmt!(\"%-7u %s\", v, k));\n         }\n-        unset_task_llcx();\n-        return (llcx, llmod, link_meta);\n     }\n-}\n+    let llcx = ccx.llcx;\n+    let link_meta = ccx.link_meta;\n+    let llmod = ccx.llmod;\n \n-fn task_local_llcx_key(_v: @ContextRef) {}\n-\n-pub fn task_llcx() -> ContextRef {\n-    let opt = unsafe { local_data::local_data_get(task_local_llcx_key) };\n-    *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")\n-}\n-\n-unsafe fn set_task_llcx(c: ContextRef) {\n-    local_data::local_data_set(task_local_llcx_key, @c);\n+    return (llcx, llmod, link_meta);\n }\n \n-unsafe fn unset_task_llcx() {\n-    local_data::local_data_pop(task_local_llcx_key);\n-}"}, {"sha": "604cd3d2ba66b013cc4eaab757e15a5b718538e2", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -46,8 +46,8 @@ pub fn B(cx: block) -> BuilderRef {\n pub fn count_insn(cx: block, category: &str) {\n     if cx.ccx().sess.count_llvm_insns() {\n \n-        let h = cx.ccx().stats.llvm_insns;\n-        let v = &*cx.ccx().stats.llvm_insn_ctxt;\n+        let h = &mut cx.ccx().stats.llvm_insns;\n+        let v : &[~str] = cx.ccx().stats.llvm_insn_ctxt;\n \n         // Build version of path with cycles removed.\n \n@@ -547,7 +547,7 @@ pub fn AtomicLoad(cx: block, PointerVal: ValueRef, order: AtomicOrdering) -> Val\n             return llvm::LLVMGetUndef(ccx.int_type);\n         }\n         count_insn(cx, \"load.atomic\");\n-        let align = llalign_of_min(*ccx, ccx.int_type);\n+        let align = llalign_of_min(ccx, ccx.int_type);\n         return llvm::LLVMBuildAtomicLoad(B(cx), PointerVal, noname(), order, align as c_uint);\n     }\n }"}, {"sha": "0c771d21da5cef64fab00a7fed71d59f89342d1c", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -18,7 +18,7 @@ use lib::llvm::{llvm, TypeRef, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute};\n use lib::llvm::True;\n-use middle::trans::base::task_llcx;\n+use middle::trans::context::task_llcx;\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n "}, {"sha": "53af55bca6ca269fb0d90f2717826f8cbc66b4d2", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -18,7 +18,7 @@ use super::common::*;\n use super::machine::*;\n \n struct X86_ABIInfo {\n-    ccx: @CrateContext\n+    ccx: @mut CrateContext\n }\n \n impl ABIInfo for X86_ABIInfo {\n@@ -71,7 +71,7 @@ impl ABIInfo for X86_ABIInfo {\n     }\n }\n \n-pub fn abi_info(ccx: @CrateContext) -> @ABIInfo {\n+pub fn abi_info(ccx: @mut CrateContext) -> @ABIInfo {\n     return @X86_ABIInfo {\n         ccx: ccx\n     } as @ABIInfo;"}, {"sha": "1440d3856f09a7df15cac3b2de44c38ada50e293", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -129,7 +129,7 @@ impl EnvAction {\n }\n \n impl EnvValue {\n-    pub fn to_str(&self, ccx: @CrateContext) -> ~str {\n+    pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         fmt!(\"%s(%s)\", self.action.to_str(), self.datum.to_str(ccx))\n     }\n }"}, {"sha": "f5919ca2586f12fd98a86ae7bab37b433633df31", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 45, "deletions": 132, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -12,26 +12,18 @@\n \n use core::prelude::*;\n \n-use back::{abi, upcall};\n+use back::{abi};\n use driver::session;\n use driver::session::Session;\n-use lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n-use lib::llvm::{ContextRef, True, False, Bool};\n-use lib::llvm::{llvm, TargetData, TypeNames, associate_type, name_has_type};\n+use lib::llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n+use lib::llvm::{True, False, Bool};\n+use lib::llvm::{llvm, TypeNames, associate_type, name_has_type};\n use lib;\n-use metadata::common::LinkMeta;\n-use middle::astencode;\n-use middle::resolve;\n-use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build;\n use middle::trans::datum;\n-use middle::trans::debuginfo;\n use middle::trans::glue;\n-use middle::trans::reachable;\n-use middle::trans::shape;\n use middle::trans::type_of;\n-use middle::trans::type_use;\n use middle::trans::write_guard;\n use middle::ty::substs;\n use middle::ty;\n@@ -41,8 +33,7 @@ use util::ppaux::{Repr};\n \n use core::cast::transmute;\n use core::cast;\n-use core::hash;\n-use core::hashmap::{HashMap, HashSet};\n+use core::hashmap::{HashMap};\n use core::libc::{c_uint, c_longlong, c_ulonglong};\n use core::str;\n use core::to_bytes;\n@@ -55,6 +46,8 @@ use syntax::parse::token;\n use syntax::{ast, ast_map};\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n+pub use middle::trans::context::CrateContext;\n+\n // NOTE: this thunk is totally pointless now that we're not passing\n // interners around...\n pub type namegen = @fn(s: &str) -> ident;\n@@ -131,9 +124,9 @@ pub struct Stats {\n     n_monos: uint,\n     n_inlines: uint,\n     n_closures: uint,\n-    llvm_insn_ctxt: @mut ~[~str],\n-    llvm_insns: @mut HashMap<~str, uint>,\n-    fn_times: @mut ~[(~str, int)] // (ident, time)\n+    llvm_insn_ctxt: ~[~str],\n+    llvm_insns: HashMap<~str, uint>,\n+    fn_times: ~[(~str, int)] // (ident, time)\n }\n \n pub struct BuilderRef_res {\n@@ -154,87 +147,7 @@ pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n-pub type ExternMap = @mut HashMap<@str, ValueRef>;\n-\n-// Crate context.  Every crate we compile has one of these.\n-pub struct CrateContext {\n-     sess: session::Session,\n-     llmod: ModuleRef,\n-     llcx: ContextRef,\n-     td: TargetData,\n-     tn: @TypeNames,\n-     externs: ExternMap,\n-     intrinsics: HashMap<&'static str, ValueRef>,\n-     item_vals: @mut HashMap<ast::node_id, ValueRef>,\n-     exp_map2: resolve::ExportMap2,\n-     reachable: reachable::map,\n-     item_symbols: @mut HashMap<ast::node_id, ~str>,\n-     link_meta: LinkMeta,\n-     enum_sizes: @mut HashMap<ty::t, uint>,\n-     discrims: @mut HashMap<ast::def_id, ValueRef>,\n-     discrim_symbols: @mut HashMap<ast::node_id, @str>,\n-     tydescs: @mut HashMap<ty::t, @mut tydesc_info>,\n-     // Set when running emit_tydescs to enforce that no more tydescs are\n-     // created.\n-     finished_tydescs: @mut bool,\n-     // Track mapping of external ids to local items imported for inlining\n-     external: @mut HashMap<ast::def_id, Option<ast::node_id>>,\n-     // Cache instances of monomorphized functions\n-     monomorphized: @mut HashMap<mono_id, ValueRef>,\n-     monomorphizing: @mut HashMap<ast::def_id, uint>,\n-     // Cache computed type parameter uses (see type_use.rs)\n-     type_use_cache: @mut HashMap<ast::def_id, @~[type_use::type_uses]>,\n-     // Cache generated vtables\n-     vtables: @mut HashMap<mono_id, ValueRef>,\n-     // Cache of constant strings,\n-     const_cstr_cache: @mut HashMap<@str, ValueRef>,\n-\n-     // Reverse-direction for const ptrs cast from globals.\n-     // Key is an int, cast from a ValueRef holding a *T,\n-     // Val is a ValueRef holding a *[T].\n-     //\n-     // Needed because LLVM loses pointer->pointee association\n-     // when we ptrcast, and we have to ptrcast during translation\n-     // of a [T] const because we form a slice, a [*T,int] pair, not\n-     // a pointer to an LLVM array type.\n-     const_globals: @mut HashMap<int, ValueRef>,\n-\n-     // Cache of emitted const values\n-     const_values: @mut HashMap<ast::node_id, ValueRef>,\n-\n-     // Cache of external const values\n-     extern_const_values: @mut HashMap<ast::def_id, ValueRef>,\n-\n-     impl_method_cache: @mut HashMap<(ast::def_id, ast::ident), ast::def_id>,\n-\n-     module_data: @mut HashMap<~str, ValueRef>,\n-     lltypes: @mut HashMap<ty::t, TypeRef>,\n-     llsizingtypes: @mut HashMap<ty::t, TypeRef>,\n-     adt_reprs: @mut HashMap<ty::t, @adt::Repr>,\n-     names: namegen,\n-     next_addrspace: addrspace_gen,\n-     symbol_hasher: @mut hash::State,\n-     type_hashcodes: @mut HashMap<ty::t, @str>,\n-     type_short_names: @mut HashMap<ty::t, ~str>,\n-     all_llvm_symbols: @mut HashSet<@str>,\n-     tcx: ty::ctxt,\n-     maps: astencode::Maps,\n-     stats: @mut Stats,\n-     upcalls: @upcall::Upcalls,\n-     tydesc_type: TypeRef,\n-     int_type: TypeRef,\n-     float_type: TypeRef,\n-     opaque_vec_type: TypeRef,\n-     builder: BuilderRef_res,\n-     shape_cx: shape::Ctxt,\n-     crate_map: ValueRef,\n-     // Set when at least one function uses GC. Needed so that\n-     // decl_gc_metadata knows whether to link to the module metadata, which\n-     // is not emitted by LLVM's GC pass when no functions use GC.\n-     uses_gc: @mut bool,\n-     dbg_cx: Option<debuginfo::DebugContext>,\n-     do_not_commit_warning_issued: @mut bool\n-}\n+pub type ExternMap = HashMap<@str, ValueRef>;\n \n // Types used for llself.\n pub struct ValSelfData {\n@@ -353,7 +266,7 @@ pub struct fn_ctxt_ {\n     path: path,\n \n     // This function's enclosing crate context.\n-    ccx: @@CrateContext\n+    ccx: @mut CrateContext\n }\n \n impl fn_ctxt_ {\n@@ -382,9 +295,9 @@ impl fn_ctxt_ {\n \n pub type fn_ctxt = @mut fn_ctxt_;\n \n-pub fn warn_not_to_commit(ccx: @CrateContext, msg: &str) {\n-    if !*ccx.do_not_commit_warning_issued {\n-        *ccx.do_not_commit_warning_issued = true;\n+pub fn warn_not_to_commit(ccx: &mut CrateContext, msg: &str) {\n+    if !ccx.do_not_commit_warning_issued {\n+        ccx.do_not_commit_warning_issued = true;\n         ccx.sess.warn(msg.to_str() + \" -- do not commit like this!\");\n     }\n }\n@@ -746,7 +659,7 @@ pub fn block_parent(cx: block) -> block {\n // Accessors\n \n impl block_ {\n-    pub fn ccx(@mut self) -> @CrateContext { *self.fcx.ccx }\n+    pub fn ccx(@mut self) -> @mut CrateContext { self.fcx.ccx }\n     pub fn tcx(@mut self) -> ty::ctxt { self.fcx.ccx.tcx }\n     pub fn sess(@mut self) -> Session { self.fcx.ccx.sess }\n \n@@ -841,7 +754,7 @@ pub fn T_f64() -> TypeRef {\n \n pub fn T_bool() -> TypeRef { return T_i8(); }\n \n-pub fn T_int(targ_cfg: @session::config) -> TypeRef {\n+pub fn T_int(targ_cfg: &session::config) -> TypeRef {\n     return match targ_cfg.arch {\n         X86 => T_i32(),\n         X86_64 => T_i64(),\n@@ -850,7 +763,7 @@ pub fn T_int(targ_cfg: @session::config) -> TypeRef {\n     };\n }\n \n-pub fn T_int_ty(cx: @CrateContext, t: ast::int_ty) -> TypeRef {\n+pub fn T_int_ty(cx: &CrateContext, t: ast::int_ty) -> TypeRef {\n     match t {\n       ast::ty_i => cx.int_type,\n       ast::ty_char => T_char(),\n@@ -861,7 +774,7 @@ pub fn T_int_ty(cx: @CrateContext, t: ast::int_ty) -> TypeRef {\n     }\n }\n \n-pub fn T_uint_ty(cx: @CrateContext, t: ast::uint_ty) -> TypeRef {\n+pub fn T_uint_ty(cx: &CrateContext, t: ast::uint_ty) -> TypeRef {\n     match t {\n       ast::ty_u => cx.int_type,\n       ast::ty_u8 => T_i8(),\n@@ -871,15 +784,15 @@ pub fn T_uint_ty(cx: @CrateContext, t: ast::uint_ty) -> TypeRef {\n     }\n }\n \n-pub fn T_float_ty(cx: @CrateContext, t: ast::float_ty) -> TypeRef {\n+pub fn T_float_ty(cx: &CrateContext, t: ast::float_ty) -> TypeRef {\n     match t {\n       ast::ty_f => cx.float_type,\n       ast::ty_f32 => T_f32(),\n       ast::ty_f64 => T_f64()\n     }\n }\n \n-pub fn T_float(targ_cfg: @session::config) -> TypeRef {\n+pub fn T_float(targ_cfg: &session::config) -> TypeRef {\n     return match targ_cfg.arch {\n         X86 => T_f64(),\n         X86_64 => T_f64(),\n@@ -890,7 +803,7 @@ pub fn T_float(targ_cfg: @session::config) -> TypeRef {\n \n pub fn T_char() -> TypeRef { return T_i32(); }\n \n-pub fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n+pub fn T_size_t(targ_cfg: &session::config) -> TypeRef {\n     return T_int(targ_cfg);\n }\n \n@@ -902,7 +815,7 @@ pub fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n     }\n }\n \n-pub fn T_fn_pair(cx: @CrateContext, tfn: TypeRef) -> TypeRef {\n+pub fn T_fn_pair(cx: &CrateContext, tfn: TypeRef) -> TypeRef {\n     return T_struct([T_ptr(tfn), T_opaque_cbox_ptr(cx)], false);\n }\n \n@@ -952,7 +865,7 @@ pub fn T_empty_struct() -> TypeRef { return T_struct([], false); }\n // they are described by this opaque type.\n pub fn T_vtable() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n \n-pub fn T_tydesc_field(cx: @CrateContext, field: uint) -> TypeRef {\n+pub fn T_tydesc_field(cx: &CrateContext, field: uint) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     unsafe {\n@@ -965,7 +878,7 @@ pub fn T_tydesc_field(cx: @CrateContext, field: uint) -> TypeRef {\n     }\n }\n \n-pub fn T_generic_glue_fn(cx: @CrateContext) -> TypeRef {\n+pub fn T_generic_glue_fn(cx: &mut CrateContext) -> TypeRef {\n     let s = @\"glue_fn\";\n     match name_has_type(cx.tn, s) {\n       Some(t) => return t,\n@@ -1005,14 +918,14 @@ pub fn T_vector(t: TypeRef, n: uint) -> TypeRef {\n }\n \n // Interior vector.\n-pub fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n+pub fn T_vec2(targ_cfg: &session::config, t: TypeRef) -> TypeRef {\n     return T_struct([T_int(targ_cfg), // fill\n                      T_int(targ_cfg), // alloc\n                      T_array(t, 0u)], // elements\n                     false);\n }\n \n-pub fn T_vec(ccx: @CrateContext, t: TypeRef) -> TypeRef {\n+pub fn T_vec(ccx: &CrateContext, t: TypeRef) -> TypeRef {\n     return T_vec2(ccx.sess.targ_cfg, t);\n }\n \n@@ -1034,16 +947,16 @@ pub fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n                          t]);\n }\n \n-pub fn T_box_header_fields(cx: @CrateContext) -> ~[TypeRef] {\n+pub fn T_box_header_fields(cx: &CrateContext) -> ~[TypeRef] {\n     let ptr = T_ptr(T_i8());\n     return ~[cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n }\n \n-pub fn T_box_header(cx: @CrateContext) -> TypeRef {\n+pub fn T_box_header(cx: &CrateContext) -> TypeRef {\n     return T_struct(T_box_header_fields(cx), false);\n }\n \n-pub fn T_box(cx: @CrateContext, t: TypeRef) -> TypeRef {\n+pub fn T_box(cx: &CrateContext, t: TypeRef) -> TypeRef {\n     return T_struct(vec::append(T_box_header_fields(cx), [t]), false);\n }\n \n@@ -1053,15 +966,15 @@ pub fn T_box_ptr(t: TypeRef) -> TypeRef {\n     }\n }\n \n-pub fn T_opaque_box(cx: @CrateContext) -> TypeRef {\n+pub fn T_opaque_box(cx: &CrateContext) -> TypeRef {\n     return T_box(cx, T_i8());\n }\n \n-pub fn T_opaque_box_ptr(cx: @CrateContext) -> TypeRef {\n+pub fn T_opaque_box_ptr(cx: &CrateContext) -> TypeRef {\n     return T_box_ptr(T_opaque_box(cx));\n }\n \n-pub fn T_unique(cx: @CrateContext, t: TypeRef) -> TypeRef {\n+pub fn T_unique(cx: &CrateContext, t: TypeRef) -> TypeRef {\n     return T_struct(vec::append(T_box_header_fields(cx), [t]), false);\n }\n \n@@ -1071,32 +984,32 @@ pub fn T_unique_ptr(t: TypeRef) -> TypeRef {\n     }\n }\n \n-pub fn T_port(cx: @CrateContext, _t: TypeRef) -> TypeRef {\n+pub fn T_port(cx: &CrateContext, _t: TypeRef) -> TypeRef {\n     return T_struct([cx.int_type], false); // Refcount\n \n }\n \n-pub fn T_chan(cx: @CrateContext, _t: TypeRef) -> TypeRef {\n+pub fn T_chan(cx: &CrateContext, _t: TypeRef) -> TypeRef {\n     return T_struct([cx.int_type], false); // Refcount\n \n }\n \n \n-pub fn T_opaque_cbox_ptr(cx: @CrateContext) -> TypeRef {\n+pub fn T_opaque_cbox_ptr(cx: &CrateContext) -> TypeRef {\n     // closures look like boxes (even when they are ~fn or &fn)\n     // see trans_closure.rs\n     return T_opaque_box_ptr(cx);\n }\n \n-pub fn T_enum_discrim(cx: @CrateContext) -> TypeRef {\n+pub fn T_enum_discrim(cx: &CrateContext) -> TypeRef {\n     return cx.int_type;\n }\n \n-pub fn T_captured_tydescs(cx: @CrateContext, n: uint) -> TypeRef {\n+pub fn T_captured_tydescs(cx: &CrateContext, n: uint) -> TypeRef {\n     return T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)), false);\n }\n \n-pub fn T_opaque_trait(cx: @CrateContext, store: ty::TraitStore) -> TypeRef {\n+pub fn T_opaque_trait(cx: &CrateContext, store: ty::TraitStore) -> TypeRef {\n     match store {\n         ty::BoxTraitStore => {\n             T_struct([T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)], false)\n@@ -1162,11 +1075,11 @@ pub fn C_i64(i: i64) -> ValueRef {\n     return C_integral(T_i64(), i as u64, True);\n }\n \n-pub fn C_int(cx: @CrateContext, i: int) -> ValueRef {\n+pub fn C_int(cx: &CrateContext, i: int) -> ValueRef {\n     return C_integral(cx.int_type, i as u64, True);\n }\n \n-pub fn C_uint(cx: @CrateContext, i: uint) -> ValueRef {\n+pub fn C_uint(cx: &CrateContext, i: uint) -> ValueRef {\n     return C_integral(cx.int_type, i as u64, False);\n }\n \n@@ -1177,7 +1090,7 @@ pub fn C_u8(i: uint) -> ValueRef {\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: @CrateContext, s: @str) -> ValueRef {\n+pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         match cx.const_cstr_cache.find(&s) {\n             Some(&llval) => return llval,\n@@ -1203,7 +1116,7 @@ pub fn C_cstr(cx: @CrateContext, s: @str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_estr_slice(cx: @CrateContext, s: @str) -> ValueRef {\n+pub fn C_estr_slice(cx: &mut CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n@@ -1281,7 +1194,7 @@ pub fn C_bytes_plus_null(bytes: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn C_shape(ccx: @CrateContext, bytes: ~[u8]) -> ValueRef {\n+pub fn C_shape(ccx: &CrateContext, bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         let llshape = C_bytes_plus_null(bytes);\n         let name = fmt!(\"shape%u\", (ccx.names)(\"shape\").name);\n@@ -1301,7 +1214,7 @@ pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n     }\n }\n \n-pub fn const_get_elt(cx: @CrateContext, v: ValueRef, us: &[c_uint])\n+pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n                   -> ValueRef {\n     unsafe {\n         let r = do vec::as_imm_buf(us) |p, len| {"}, {"sha": "f6b1ba0ffe4c198c3e7ce8c5e08c26c667434f3a", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -34,7 +34,7 @@ use core::libc::c_uint;\n use core::str;\n use syntax::{ast, ast_util, ast_map};\n \n-pub fn const_lit(cx: @CrateContext, e: @ast::expr, lit: ast::lit)\n+pub fn const_lit(cx: @mut CrateContext, e: @ast::expr, lit: ast::lit)\n     -> ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_lit\");\n     match lit.node {\n@@ -73,15 +73,15 @@ pub fn const_lit(cx: @CrateContext, e: @ast::expr, lit: ast::lit)\n     }\n }\n \n-pub fn const_ptrcast(cx: @CrateContext, a: ValueRef, t: TypeRef) -> ValueRef {\n+pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: TypeRef) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, T_ptr(t));\n         assert!(cx.const_globals.insert(b as int, a));\n         b\n     }\n }\n \n-pub fn const_vec(cx: @CrateContext, e: @ast::expr, es: &[@ast::expr])\n+pub fn const_vec(cx: @mut CrateContext, e: @ast::expr, es: &[@ast::expr])\n     -> (ValueRef, ValueRef, TypeRef) {\n     unsafe {\n         let vec_ty = ty::expr_ty(cx.tcx, e);\n@@ -100,7 +100,7 @@ pub fn const_vec(cx: @CrateContext, e: @ast::expr, es: &[@ast::expr])\n     }\n }\n \n-fn const_addr_of(cx: @CrateContext, cv: ValueRef) -> ValueRef {\n+fn const_addr_of(cx: @mut CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n         let gv = do str::as_c_str(\"const\") |name| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv), name)\n@@ -112,7 +112,7 @@ fn const_addr_of(cx: @CrateContext, cv: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_ptr(cx: @CrateContext, v: ValueRef) -> ValueRef {\n+fn const_deref_ptr(cx: @mut CrateContext, v: ValueRef) -> ValueRef {\n     let v = match cx.const_globals.find(&(v as int)) {\n         Some(&v) => v,\n         None => v\n@@ -123,13 +123,13 @@ fn const_deref_ptr(cx: @CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_newtype(cx: @CrateContext, v: ValueRef, t: ty::t)\n+fn const_deref_newtype(cx: @mut CrateContext, v: ValueRef, t: ty::t)\n     -> ValueRef {\n     let repr = adt::represent_type(cx, t);\n     adt::const_get_field(cx, repr, v, 0, 0)\n }\n \n-fn const_deref(cx: @CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n+fn const_deref(cx: @mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     -> (ValueRef, ty::t) {\n     match ty::deref(cx.tcx, t, explicit) {\n         Some(ref mt) => {\n@@ -155,10 +155,9 @@ fn const_deref(cx: @CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     }\n }\n \n-pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n-    let mut def_id = def_id;\n-    if !ast_util::is_local(def_id) ||\n-       !cx.const_values.contains_key(&def_id.node) {\n+pub fn get_const_val(cx: @mut CrateContext, mut def_id: ast::def_id) -> ValueRef {\n+    let contains_key = cx.const_values.contains_key(&def_id.node);\n+    if !ast_util::is_local(def_id) || !contains_key {\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id, true);\n         }\n@@ -174,19 +173,20 @@ pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n     cx.const_values.get_copy(&def_id.node)\n }\n \n-pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n+pub fn const_expr(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n     let mut llconst = const_expr_unadjusted(cx, e);\n     let ety = ty::expr_ty(cx.tcx, e);\n-    match cx.tcx.adjustments.find(&e.id) {\n+    let adjustment = cx.tcx.adjustments.find_copy(&e.id);\n+    match adjustment {\n         None => { }\n-        Some(&@ty::AutoAddEnv(ty::re_static, ast::BorrowedSigil)) => {\n+        Some(@ty::AutoAddEnv(ty::re_static, ast::BorrowedSigil)) => {\n             llconst = C_struct([llconst, C_null(T_opaque_box_ptr(cx))])\n         }\n-        Some(&@ty::AutoAddEnv(ref r, ref s)) => {\n+        Some(@ty::AutoAddEnv(ref r, ref s)) => {\n             cx.sess.span_bug(e.span, fmt!(\"unexpected static function: \\\n                                            region %? sigil %?\", *r, *s))\n         }\n-        Some(&@ty::AutoDerefRef(ref adj)) => {\n+        Some(@ty::AutoDerefRef(ref adj)) => {\n             let mut ty = ety;\n             let mut maybe_ptr = None;\n             for adj.autoderefs.times {\n@@ -246,7 +246,7 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n     llconst\n }\n \n-fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n+fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n     unsafe {\n         let _icx = cx.insn_ctxt(\"const_expr\");\n         return match e.node {\n@@ -445,7 +445,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               (expr::cast_enum, expr::cast_integral) |\n               (expr::cast_enum, expr::cast_float)  => {\n                 let repr = adt::represent_type(cx, basety);\n-                let iv = C_int(cx, adt::const_get_discrim(cx, repr, v));\n+                let discr = adt::const_get_discrim(cx, repr, v);\n+                let iv = C_int(cx, discr);\n                 let ety_cast = expr::cast_type_kind(ety);\n                 match ety_cast {\n                     expr::cast_integral => {\n@@ -470,17 +471,20 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             }\n           }\n           ast::expr_addr_of(ast::m_imm, sub) => {\n-              const_addr_of(cx, const_expr(cx, sub))\n+              let e = const_expr(cx, sub);\n+              const_addr_of(cx, e)\n           }\n           ast::expr_tup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n-              adt::trans_const(cx, repr, 0, es.map(|e| const_expr(cx, *e)))\n+              let vals = es.map(|&e| const_expr(cx, e));\n+              adt::trans_const(cx, repr, 0, vals)\n           }\n           ast::expr_struct(_, ref fs, None) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n-              do expr::with_field_tys(cx.tcx, ety, Some(e.id))\n+              let tcx = cx.tcx;\n+              do expr::with_field_tys(tcx, ety, Some(e.id))\n                   |discr, field_tys| {\n                   let cs = field_tys.map(|field_ty| {\n                       match fs.find(|f| field_ty.ident == f.node.ident) {\n@@ -522,7 +526,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n           }\n           ast::expr_path(pth) => {\n             assert_eq!(pth.types.len(), 0);\n-            match cx.tcx.def_map.find(&e.id) {\n+            let tcx = cx.tcx;\n+            match tcx.def_map.find(&e.id) {\n                 Some(&ast::def_fn(def_id, _purity)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx, def_id).ty;\n@@ -554,21 +559,22 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             }\n           }\n           ast::expr_call(callee, ref args, _) => {\n-              match cx.tcx.def_map.find(&callee.id) {\n+              let tcx = cx.tcx;\n+              match tcx.def_map.find(&callee.id) {\n                   Some(&ast::def_struct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n-                      adt::trans_const(cx, repr, 0,\n-                                       args.map(|a| const_expr(cx, *a)))\n+                      let arg_vals = args.map(|a| const_expr(cx, *a));\n+                      adt::trans_const(cx, repr, 0, arg_vals)\n                   }\n                   Some(&ast::def_variant(enum_did, variant_did)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx,\n                                                            enum_did,\n                                                            variant_did);\n-                      adt::trans_const(cx, repr, vinfo.disr_val,\n-                                       args.map(|a| const_expr(cx, *a)))\n+                      let arg_vals = args.map(|a| const_expr(cx, *a));\n+                      adt::trans_const(cx, repr, vinfo.disr_val, arg_vals)\n                   }\n                   _ => cx.sess.span_bug(e.span, \"expected a struct or variant def\")\n               }\n@@ -580,7 +586,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n     }\n }\n \n-pub fn trans_const(ccx: @CrateContext, _e: @ast::expr, id: ast::node_id) {\n+pub fn trans_const(ccx: @mut CrateContext, _e: @ast::expr, id: ast::node_id) {\n     unsafe {\n         let _icx = ccx.insn_ctxt(\"trans_const\");\n         let g = base::get_item_val(ccx, id);"}, {"sha": "75d7aaa88a6d0c81e616cd8e033a2d968b50f387", "filename": "src/librustc/middle/trans/context.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use back::{upcall};\n+use driver::session;\n+use lib::llvm::{ContextRef, ModuleRef, ValueRef, TypeRef};\n+use lib::llvm::{llvm, TargetData, TypeNames};\n+use lib::llvm::{mk_target_data, mk_type_names};\n+use lib;\n+use metadata::common::LinkMeta;\n+use middle::astencode;\n+use middle::resolve;\n+use middle::trans::adt;\n+use middle::trans::base;\n+use middle::trans::debuginfo;\n+use middle::trans::reachable;\n+use middle::trans::shape;\n+use middle::trans::type_use;\n+use middle::ty;\n+\n+use core::hash;\n+use core::hashmap::{HashMap, HashSet};\n+use core::str;\n+use core::local_data;\n+use syntax::ast;\n+\n+use middle::trans::common::{ExternMap,tydesc_info,BuilderRef_res,Stats,namegen,addrspace_gen};\n+use middle::trans::common::{mono_id,T_int,T_float,T_tydesc,T_opaque_vec};\n+use middle::trans::common::{new_namegen,new_addrspace_gen};\n+\n+use middle::trans::base::{decl_crate_map};\n+\n+use middle::trans::shape::{mk_ctxt};\n+\n+pub struct CrateContext {\n+     sess: session::Session,\n+     llmod: ModuleRef,\n+     llcx: ContextRef,\n+     td: TargetData,\n+     tn: @TypeNames,\n+     externs: ExternMap,\n+     intrinsics: HashMap<&'static str, ValueRef>,\n+     item_vals: HashMap<ast::node_id, ValueRef>,\n+     exp_map2: resolve::ExportMap2,\n+     reachable: reachable::map,\n+     item_symbols: HashMap<ast::node_id, ~str>,\n+     link_meta: LinkMeta,\n+     enum_sizes: HashMap<ty::t, uint>,\n+     discrims: HashMap<ast::def_id, ValueRef>,\n+     discrim_symbols: HashMap<ast::node_id, @str>,\n+     tydescs: HashMap<ty::t, @mut tydesc_info>,\n+     // Set when running emit_tydescs to enforce that no more tydescs are\n+     // created.\n+     finished_tydescs: bool,\n+     // Track mapping of external ids to local items imported for inlining\n+     external: HashMap<ast::def_id, Option<ast::node_id>>,\n+     // Cache instances of monomorphized functions\n+     monomorphized: HashMap<mono_id, ValueRef>,\n+     monomorphizing: HashMap<ast::def_id, uint>,\n+     // Cache computed type parameter uses (see type_use.rs)\n+     type_use_cache: HashMap<ast::def_id, @~[type_use::type_uses]>,\n+     // Cache generated vtables\n+     vtables: HashMap<mono_id, ValueRef>,\n+     // Cache of constant strings,\n+     const_cstr_cache: HashMap<@str, ValueRef>,\n+\n+     // Reverse-direction for const ptrs cast from globals.\n+     // Key is an int, cast from a ValueRef holding a *T,\n+     // Val is a ValueRef holding a *[T].\n+     //\n+     // Needed because LLVM loses pointer->pointee association\n+     // when we ptrcast, and we have to ptrcast during translation\n+     // of a [T] const because we form a slice, a [*T,int] pair, not\n+     // a pointer to an LLVM array type.\n+     const_globals: HashMap<int, ValueRef>,\n+\n+     // Cache of emitted const values\n+     const_values: HashMap<ast::node_id, ValueRef>,\n+\n+     // Cache of external const values\n+     extern_const_values: HashMap<ast::def_id, ValueRef>,\n+\n+     impl_method_cache: HashMap<(ast::def_id, ast::ident), ast::def_id>,\n+\n+     module_data: HashMap<~str, ValueRef>,\n+     lltypes: HashMap<ty::t, TypeRef>,\n+     llsizingtypes: HashMap<ty::t, TypeRef>,\n+     adt_reprs: HashMap<ty::t, @adt::Repr>,\n+     names: namegen,\n+     next_addrspace: addrspace_gen,\n+     symbol_hasher: hash::State,\n+     type_hashcodes: HashMap<ty::t, @str>,\n+     type_short_names: HashMap<ty::t, ~str>,\n+     all_llvm_symbols: HashSet<@str>,\n+     tcx: ty::ctxt,\n+     maps: astencode::Maps,\n+     stats: Stats,\n+     upcalls: @upcall::Upcalls,\n+     tydesc_type: TypeRef,\n+     int_type: TypeRef,\n+     float_type: TypeRef,\n+     opaque_vec_type: TypeRef,\n+     builder: BuilderRef_res,\n+     shape_cx: shape::Ctxt,\n+     crate_map: ValueRef,\n+     // Set when at least one function uses GC. Needed so that\n+     // decl_gc_metadata knows whether to link to the module metadata, which\n+     // is not emitted by LLVM's GC pass when no functions use GC.\n+     uses_gc: bool,\n+     dbg_cx: Option<debuginfo::DebugContext>,\n+     do_not_commit_warning_issued: bool\n+}\n+\n+impl CrateContext {\n+    pub fn new(sess: session::Session, name: &str, tcx: ty::ctxt,\n+               emap2: resolve::ExportMap2, maps: astencode::Maps,\n+               symbol_hasher: hash::State, link_meta: LinkMeta,\n+               reachable: reachable::map) -> CrateContext {\n+        unsafe {\n+            let llcx = llvm::LLVMContextCreate();\n+            set_task_llcx(llcx);\n+            let llmod = str::as_c_str(name, |buf| {\n+                llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n+            });\n+            let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n+            let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n+            str::as_c_str(data_layout, |buf| llvm::LLVMSetDataLayout(llmod, buf));\n+            str::as_c_str(targ_triple, |buf| llvm::LLVMSetTarget(llmod, buf));\n+            let targ_cfg = sess.targ_cfg;\n+            let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n+            let tn = mk_type_names();\n+            let mut intrinsics = base::declare_intrinsics(llmod);\n+            if sess.opts.extra_debuginfo {\n+                base::declare_dbg_intrinsics(llmod, &mut intrinsics);\n+            }\n+            let int_type = T_int(targ_cfg);\n+            let float_type = T_float(targ_cfg);\n+            let tydesc_type = T_tydesc(targ_cfg);\n+            lib::llvm::associate_type(tn, @\"tydesc\", tydesc_type);\n+            let crate_map = decl_crate_map(sess, link_meta, llmod);\n+            let dbg_cx = if sess.opts.debuginfo {\n+                Some(debuginfo::mk_ctxt(name.to_owned()))\n+            } else {\n+                None\n+            };\n+\n+            CrateContext {\n+                  sess: sess,\n+                  llmod: llmod,\n+                  llcx: llcx,\n+                  td: td,\n+                  tn: tn,\n+                  externs: HashMap::new(),\n+                  intrinsics: intrinsics,\n+                  item_vals: HashMap::new(),\n+                  exp_map2: emap2,\n+                  reachable: reachable,\n+                  item_symbols: HashMap::new(),\n+                  link_meta: link_meta,\n+                  enum_sizes: HashMap::new(),\n+                  discrims: HashMap::new(),\n+                  discrim_symbols: HashMap::new(),\n+                  tydescs: HashMap::new(),\n+                  finished_tydescs: false,\n+                  external: HashMap::new(),\n+                  monomorphized: HashMap::new(),\n+                  monomorphizing: HashMap::new(),\n+                  type_use_cache: HashMap::new(),\n+                  vtables: HashMap::new(),\n+                  const_cstr_cache: HashMap::new(),\n+                  const_globals: HashMap::new(),\n+                  const_values: HashMap::new(),\n+                  extern_const_values: HashMap::new(),\n+                  impl_method_cache: HashMap::new(),\n+                  module_data: HashMap::new(),\n+                  lltypes: HashMap::new(),\n+                  llsizingtypes: HashMap::new(),\n+                  adt_reprs: HashMap::new(),\n+                  names: new_namegen(),\n+                  next_addrspace: new_addrspace_gen(),\n+                  symbol_hasher: symbol_hasher,\n+                  type_hashcodes: HashMap::new(),\n+                  type_short_names: HashMap::new(),\n+                  all_llvm_symbols: HashSet::new(),\n+                  tcx: tcx,\n+                  maps: maps,\n+                  stats: Stats {\n+                    n_static_tydescs: 0u,\n+                    n_glues_created: 0u,\n+                    n_null_glues: 0u,\n+                    n_real_glues: 0u,\n+                    n_fns: 0u,\n+                    n_monos: 0u,\n+                    n_inlines: 0u,\n+                    n_closures: 0u,\n+                    llvm_insn_ctxt: ~[],\n+                    llvm_insns: HashMap::new(),\n+                    fn_times: ~[]\n+                  },\n+                  upcalls: upcall::declare_upcalls(targ_cfg, llmod),\n+                  tydesc_type: tydesc_type,\n+                  int_type: int_type,\n+                  float_type: float_type,\n+                  opaque_vec_type: T_opaque_vec(targ_cfg),\n+                  builder: BuilderRef_res(unsafe {\n+                      llvm::LLVMCreateBuilderInContext(llcx)\n+                  }),\n+                  shape_cx: mk_ctxt(llmod),\n+                  crate_map: crate_map,\n+                  uses_gc: false,\n+                  dbg_cx: dbg_cx,\n+                  do_not_commit_warning_issued: false\n+            }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl Drop for CrateContext {\n+    fn finalize(&self) {\n+        unsafe {\n+            unset_task_llcx();\n+        }\n+    }\n+}\n+\n+fn task_local_llcx_key(_v: @ContextRef) {}\n+\n+pub fn task_llcx() -> ContextRef {\n+    let opt = unsafe { local_data::local_data_get(task_local_llcx_key) };\n+    *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")\n+}\n+\n+unsafe fn set_task_llcx(c: ContextRef) {\n+    local_data::local_data_set(task_local_llcx_key, @c);\n+}\n+\n+unsafe fn unset_task_llcx() {\n+    local_data::local_data_pop(task_local_llcx_key);\n+}"}, {"sha": "b0276cf0e29a5b03f8031293bef550c159c005ee", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -844,7 +844,7 @@ impl DatumBlock {\n         rslt(self.bcx, self.datum.to_appropriate_llval(self.bcx))\n     }\n \n-    pub fn ccx(&self) -> @CrateContext {\n+    pub fn ccx(&self) -> @mut CrateContext {\n         self.bcx.ccx()\n     }\n "}, {"sha": "7a8ebb4abfddfa03e22845cc3ebab8b63e850766", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -13,7 +13,7 @@ use core::prelude::*;\n use driver::session;\n use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n-use middle::trans::base::task_llcx;\n+use middle::trans::context::task_llcx;\n use middle::trans::common::*;\n use middle::trans::machine;\n use middle::trans::type_of;\n@@ -96,7 +96,7 @@ fn llnull() -> ValueRef {\n     }\n }\n \n-fn add_named_metadata(cx: @CrateContext, name: ~str, val: ValueRef) {\n+fn add_named_metadata(cx: &CrateContext, name: ~str, val: ValueRef) {\n     str::as_c_str(name, |sbuf| {\n         unsafe {\n             llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf, val)\n@@ -208,7 +208,7 @@ fn cached_metadata<T:Copy>(cache: metadata_cache,\n     return option::None;\n }\n \n-fn create_compile_unit(cx: @CrateContext) -> @Metadata<CompileUnitMetadata> {\n+fn create_compile_unit(cx: &mut CrateContext) -> @Metadata<CompileUnitMetadata> {\n     let cache = get_cache(cx);\n     let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n     let tg = CompileUnitTag;\n@@ -244,8 +244,8 @@ fn create_compile_unit(cx: @CrateContext) -> @Metadata<CompileUnitMetadata> {\n     return mdval;\n }\n \n-fn get_cache(cx: @CrateContext) -> metadata_cache {\n-    (/*bad*/copy cx.dbg_cx).get().llmetadata\n+fn get_cache(cx: &CrateContext) -> metadata_cache {\n+    cx.dbg_cx.get_ref().llmetadata\n }\n \n fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n@@ -257,7 +257,7 @@ fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n     }, work_dir.to_owned())\n }\n \n-fn create_file(cx: @CrateContext, full_path: ~str)\n+fn create_file(cx: &mut CrateContext, full_path: ~str)\n     -> @Metadata<FileMetadata> {\n     let cache = get_cache(cx);;\n     let tg = FileDescriptorTag;\n@@ -290,9 +290,8 @@ fn line_from_span(cm: @codemap::CodeMap, sp: span) -> uint {\n     cm.lookup_char_pos(sp.lo).line\n }\n \n-fn create_block(cx: block) -> @Metadata<BlockMetadata> {\n+fn create_block(mut cx: block) -> @Metadata<BlockMetadata> {\n     let cache = get_cache(cx.ccx());\n-    let mut cx = cx;\n     while cx.node_info.is_none() {\n         match cx.parent {\n           Some(b) => cx = b,\n@@ -340,13 +339,13 @@ fn create_block(cx: block) -> @Metadata<BlockMetadata> {\n     return mdval;\n }\n \n-fn size_and_align_of(cx: @CrateContext, t: ty::t) -> (int, int) {\n+fn size_and_align_of(cx: &mut CrateContext, t: ty::t) -> (int, int) {\n     let llty = type_of::type_of(cx, t);\n     (machine::llsize_of_real(cx, llty) as int,\n      machine::llalign_of_pref(cx, llty) as int)\n }\n \n-fn create_basic_type(cx: @CrateContext, t: ty::t, span: span)\n+fn create_basic_type(cx: &mut CrateContext, t: ty::t, span: span)\n     -> @Metadata<TyDescMetadata> {\n     let cache = get_cache(cx);\n     let tg = BasicTypeDescriptorTag;\n@@ -408,7 +407,7 @@ fn create_basic_type(cx: @CrateContext, t: ty::t, span: span)\n     return mdval;\n }\n \n-fn create_pointer_type(cx: @CrateContext, t: ty::t, span: span,\n+fn create_pointer_type(cx: &mut CrateContext, t: ty::t, span: span,\n                        pointee: @Metadata<TyDescMetadata>)\n     -> @Metadata<TyDescMetadata> {\n     let tg = PointerTypeTag;\n@@ -498,7 +497,7 @@ fn add_member(cx: @mut StructCtxt,\n     cx.total_size += size * 8;\n }\n \n-fn create_struct(cx: @CrateContext, t: ty::t, fields: ~[ty::field],\n+fn create_struct(cx: &mut CrateContext, t: ty::t, fields: ~[ty::field],\n                  span: span) -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname.to_owned());\n@@ -521,7 +520,7 @@ fn create_struct(cx: @CrateContext, t: ty::t, fields: ~[ty::field],\n     return mdval;\n }\n \n-fn create_tuple(cx: @CrateContext, t: ty::t, elements: &[ty::t], span: span)\n+fn create_tuple(cx: &mut CrateContext, t: ty::t, elements: &[ty::t], span: span)\n     -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname.to_owned());\n@@ -555,7 +554,7 @@ fn voidptr() -> (ValueRef, int, int) {\n     return (vp, size, align);\n }\n \n-fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n+fn create_boxed_type(cx: &mut CrateContext, contents: ty::t,\n                      span: span, boxed: @Metadata<TyDescMetadata>)\n     -> @Metadata<TyDescMetadata> {\n     //let tg = StructureTypeTag;\n@@ -624,7 +623,7 @@ fn create_composite_type(type_tag: int, name: &str, file: ValueRef,\n     return llmdnode(lldata);\n }\n \n-fn create_fixed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n+fn create_fixed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n                     len: int, span: span) -> @Metadata<TyDescMetadata> {\n     let t_md = create_ty(cx, elem_t, span);\n     let fname = filename_from_span(cx, span);\n@@ -643,7 +642,7 @@ fn create_fixed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     }\n }\n \n-fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n+fn create_boxed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n                     vec_ty_span: codemap::span)\n     -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, vec_ty_span);\n@@ -695,7 +694,7 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     return mdval;\n }\n \n-fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n+fn create_vec_slice(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n     -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname.to_owned());\n@@ -717,7 +716,7 @@ fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n     return mdval;\n }\n \n-fn create_fn_ty(cx: @CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n+fn create_fn_ty(cx: &mut CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n                 span: span) -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname.to_owned());\n@@ -737,7 +736,7 @@ fn create_fn_ty(cx: @CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t\n     return mdval;\n }\n \n-fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n+fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n     -> @Metadata<TyDescMetadata> {\n     debug!(\"create_ty: %?\", ty::get(t));\n     /*let cache = get_cache(cx);\n@@ -817,7 +816,7 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n     }\n }\n \n-fn filename_from_span(cx: @CrateContext, sp: codemap::span) -> @str {\n+fn filename_from_span(cx: &CrateContext, sp: codemap::span) -> @str {\n     cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n }\n \n@@ -878,15 +877,15 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n         }\n     };\n     let declargs = ~[llmdnode([llptr]), mdnode];\n-    trans::build::Call(bcx, *cx.intrinsics.get(&(\"llvm.dbg.declare\")),\n+    trans::build::Call(bcx, cx.intrinsics.get_copy(&(\"llvm.dbg.declare\")),\n                        declargs);\n     return mdval;\n }\n \n pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     -> Option<@Metadata<ArgumentMetadata>> {\n     let fcx = bcx.fcx;\n-    let cx = *fcx.ccx;\n+    let cx = fcx.ccx;\n     let cache = get_cache(cx);\n     let tg = ArgVariableTag;\n     match cached_metadata::<@Metadata<ArgumentMetadata>>(\n@@ -927,7 +926,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n             let llptr = fcx.llargs.get_copy(&arg.id);\n             let declargs = ~[llmdnode([llptr]), mdnode];\n             trans::build::Call(bcx,\n-                               *cx.intrinsics.get(&(\"llvm.dbg.declare\")),\n+                               cx.intrinsics.get_copy(&(\"llvm.dbg.declare\")),\n                                declargs);\n             return Some(mdval);\n         }\n@@ -955,8 +954,7 @@ pub fn update_source_pos(cx: block, s: span) {\n }\n \n pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n-    let cx = *fcx.ccx;\n-    let dbg_cx = (/*bad*/copy cx.dbg_cx).get();\n+    let mut cx = fcx.ccx;\n \n     debug!(\"~~\");\n \n@@ -980,6 +978,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n       ast_map::node_expr(expr) => {\n         match expr.node {\n           ast::expr_fn_block(ref decl, _) => {\n+            let dbg_cx = cx.dbg_cx.get_ref();\n             ((dbg_cx.names)(\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,"}, {"sha": "cbe20afe91927aa8dbf2b94364be91d966632d98", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -171,7 +171,7 @@ pub enum Dest {\n }\n \n impl Dest {\n-    pub fn to_str(&self, ccx: @CrateContext) -> ~str {\n+    pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         match *self {\n             SaveIn(v) => fmt!(\"SaveIn(%s)\", val_str(ccx.tn, v)),\n             Ignore => ~\"Ignore\"\n@@ -946,7 +946,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n             ast::def_const(did) => {\n                 let const_ty = expr_ty(bcx, ref_expr);\n \n-                fn get_did(ccx: @CrateContext, did: ast::def_id)\n+                fn get_did(ccx: @mut CrateContext, did: ast::def_id)\n                     -> ast::def_id {\n                     if did.crate != ast::local_crate {\n                         inline::maybe_instantiate_inline(ccx, did, true)\n@@ -958,20 +958,21 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                 fn get_val(bcx: block, did: ast::def_id, const_ty: ty::t)\n                            -> ValueRef {\n                     // For external constants, we don't inline.\n-                    let extern_const_values =\n-                        &mut *bcx.ccx().extern_const_values;\n                     if did.crate == ast::local_crate {\n                         // The LLVM global has the type of its initializer,\n                         // which may not be equal to the enum's type for\n                         // non-C-like enums.\n-                        PointerCast(bcx,\n-                                    base::get_item_val(bcx.ccx(), did.node),\n-                                    T_ptr(type_of(bcx.ccx(), const_ty)))\n+                        let val = base::get_item_val(bcx.ccx(), did.node);\n+                        let pty = T_ptr(type_of(bcx.ccx(), const_ty));\n+                        PointerCast(bcx, val, pty)\n                     } else {\n-                        match extern_const_values.find(&did) {\n-                            None => {}  // Continue.\n-                            Some(llval) => {\n-                                return *llval;\n+                        {\n+                            let extern_const_values = &bcx.ccx().extern_const_values;\n+                            match extern_const_values.find(&did) {\n+                                None => {}  // Continue.\n+                                Some(llval) => {\n+                                    return *llval;\n+                                }\n                             }\n                         }\n \n@@ -984,6 +985,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                                 bcx.ccx().llmod,\n                                 llty,\n                                 transmute::<&u8,*i8>(&symbol[0]));\n+                            let extern_const_values = &mut bcx.ccx().extern_const_values;\n                             extern_const_values.insert(did, llval);\n                             llval\n                         }"}, {"sha": "40fa44d92ba49bdc7bd98acdb5aa09b2195d0bee", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -46,7 +46,7 @@ use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall,\n                   Cdecl, Aapcs, C};\n \n-fn abi_info(ccx: @CrateContext) -> @cabi::ABIInfo {\n+fn abi_info(ccx: @mut CrateContext) -> @cabi::ABIInfo {\n     return match ccx.sess.targ_cfg.arch {\n         X86 => cabi_x86::abi_info(ccx),\n         X86_64 => cabi_x86_64::abi_info(),\n@@ -55,7 +55,7 @@ fn abi_info(ccx: @CrateContext) -> @cabi::ABIInfo {\n     }\n }\n \n-pub fn link_name(ccx: @CrateContext, i: @ast::foreign_item) -> @str {\n+pub fn link_name(ccx: &CrateContext, i: @ast::foreign_item) -> @str {\n      match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n         None => ccx.sess.str_of(i.ident),\n         Some(ln) => ln,\n@@ -89,7 +89,7 @@ struct LlvmSignature {\n     sret: bool,\n }\n \n-fn foreign_signature(ccx: @CrateContext, fn_sig: &ty::FnSig)\n+fn foreign_signature(ccx: @mut CrateContext, fn_sig: &ty::FnSig)\n                      -> LlvmSignature {\n     /*!\n      * The ForeignSignature is the LLVM types of the arguments/return type\n@@ -108,7 +108,7 @@ fn foreign_signature(ccx: @CrateContext, fn_sig: &ty::FnSig)\n     }\n }\n \n-fn shim_types(ccx: @CrateContext, id: ast::node_id) -> ShimTypes {\n+fn shim_types(ccx: @mut CrateContext, id: ast::node_id) -> ShimTypes {\n     let fn_sig = match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n         ty::ty_bare_fn(ref fn_ty) => copy fn_ty.sig,\n         _ => ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\")\n@@ -141,7 +141,7 @@ type shim_ret_builder<'self> =\n               llargbundle: ValueRef,\n               llretval: ValueRef);\n \n-fn build_shim_fn_(ccx: @CrateContext,\n+fn build_shim_fn_(ccx: @mut CrateContext,\n                   shim_name: ~str,\n                   llbasefn: ValueRef,\n                   tys: &ShimTypes,\n@@ -184,7 +184,7 @@ type wrap_ret_builder<'self> = &'self fn(bcx: block,\n                                          tys: &ShimTypes,\n                                          llargbundle: ValueRef);\n \n-fn build_wrap_fn_(ccx: @CrateContext,\n+fn build_wrap_fn_(ccx: @mut CrateContext,\n                   tys: &ShimTypes,\n                   llshimfn: ValueRef,\n                   llwrapfn: ValueRef,\n@@ -198,7 +198,7 @@ fn build_wrap_fn_(ccx: @CrateContext,\n     // Patch up the return type if it's not immediate and we're returning via\n     // the C ABI.\n     if needs_c_return && !ty::type_is_immediate(tys.fn_sig.output) {\n-        let lloutputtype = type_of::type_of(*fcx.ccx, tys.fn_sig.output);\n+        let lloutputtype = type_of::type_of(fcx.ccx, tys.fn_sig.output);\n         fcx.llretptr = Some(alloca(raw_block(fcx, false, fcx.llstaticallocas),\n                                    lloutputtype));\n     }\n@@ -282,7 +282,7 @@ fn build_wrap_fn_(ccx: @CrateContext,\n // round of copies.  (In fact, the shim function itself is\n // unnecessary). We used to do this, in fact, and will perhaps do so\n // in the future.\n-pub fn trans_foreign_mod(ccx: @CrateContext,\n+pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                          path: &ast_map::path,\n                          foreign_mod: &ast::foreign_mod) {\n     let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");\n@@ -350,7 +350,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n         }\n     }\n \n-    fn build_foreign_fn(ccx: @CrateContext,\n+    fn build_foreign_fn(ccx: @mut CrateContext,\n                         id: ast::node_id,\n                         foreign_item: @ast::foreign_item,\n                         cc: lib::llvm::CallConv) {\n@@ -367,7 +367,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n         }\n     }\n \n-    fn build_shim_fn(ccx: @CrateContext,\n+    fn build_shim_fn(ccx: @mut CrateContext,\n                      foreign_item: @ast::foreign_item,\n                      tys: &ShimTypes,\n                      cc: lib::llvm::CallConv)\n@@ -415,7 +415,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n                        build_ret)\n     }\n \n-    fn base_fn(ccx: @CrateContext,\n+    fn base_fn(ccx: &CrateContext,\n                lname: &str,\n                tys: &ShimTypes,\n                cc: lib::llvm::CallConv)\n@@ -428,7 +428,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n \n     // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n     // over the place\n-    fn build_direct_fn(ccx: @CrateContext,\n+    fn build_direct_fn(ccx: @mut CrateContext,\n                        decl: ValueRef,\n                        item: @ast::foreign_item,\n                        tys: &ShimTypes,\n@@ -455,7 +455,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n \n     // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n     // over the place\n-    fn build_fast_ffi_fn(ccx: @CrateContext,\n+    fn build_fast_ffi_fn(ccx: @mut CrateContext,\n                          decl: ValueRef,\n                          item: @ast::foreign_item,\n                          tys: &ShimTypes,\n@@ -482,7 +482,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n         finish_fn(fcx, lltop);\n     }\n \n-    fn build_wrap_fn(ccx: @CrateContext,\n+    fn build_wrap_fn(ccx: @mut CrateContext,\n                      tys: &ShimTypes,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n@@ -546,7 +546,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n     }\n }\n \n-pub fn trans_intrinsic(ccx: @CrateContext,\n+pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        decl: ValueRef,\n                        item: @ast::foreign_item,\n                        path: ast_map::path,\n@@ -811,7 +811,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                                         None);\n         }\n         \"frame_address\" => {\n-            let frameaddress = *ccx.intrinsics.get(& &\"llvm.frameaddress\");\n+            let frameaddress = ccx.intrinsics.get_copy(& &\"llvm.frameaddress\");\n             let frameaddress_val = Call(bcx, frameaddress, [C_i32(0i32)]);\n             let star_u8 = ty::mk_imm_ptr(\n                 bcx.tcx(),\n@@ -857,7 +857,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memcpy.p0i8.p0i8.i32\");\n+            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memcpy.p0i8.p0i8.i32\");\n             Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n         \"memcpy64\" => {\n@@ -870,7 +870,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memcpy.p0i8.p0i8.i64\");\n+            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memcpy.p0i8.p0i8.i64\");\n             Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n         \"memmove32\" => {\n@@ -883,7 +883,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memmove.p0i8.p0i8.i32\");\n+            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memmove.p0i8.p0i8.i32\");\n             Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n         \"memmove64\" => {\n@@ -896,7 +896,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memmove.p0i8.p0i8.i64\");\n+            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memmove.p0i8.p0i8.i64\");\n             Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n         \"memset32\" => {\n@@ -909,7 +909,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let val = get_param(decl, first_real_arg + 1);\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memset.p0i8.i32\");\n+            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memset.p0i8.i32\");\n             Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n         }\n         \"memset64\" => {\n@@ -922,248 +922,248 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let val = get_param(decl, first_real_arg + 1);\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memset.p0i8.i64\");\n+            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memset.p0i8.i64\");\n             Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n         }\n         \"sqrtf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sqrtf = *ccx.intrinsics.get(& &\"llvm.sqrt.f32\");\n+            let sqrtf = ccx.intrinsics.get_copy(& &\"llvm.sqrt.f32\");\n             Store(bcx, Call(bcx, sqrtf, [x]), fcx.llretptr.get());\n         }\n         \"sqrtf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sqrtf = *ccx.intrinsics.get(& &\"llvm.sqrt.f64\");\n+            let sqrtf = ccx.intrinsics.get_copy(& &\"llvm.sqrt.f64\");\n             Store(bcx, Call(bcx, sqrtf, [x]), fcx.llretptr.get());\n         }\n         \"powif32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powif = *ccx.intrinsics.get(& &\"llvm.powi.f32\");\n+            let powif = ccx.intrinsics.get_copy(& &\"llvm.powi.f32\");\n             Store(bcx, Call(bcx, powif, [a, x]), fcx.llretptr.get());\n         }\n         \"powif64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powif = *ccx.intrinsics.get(& &\"llvm.powi.f64\");\n+            let powif = ccx.intrinsics.get_copy(& &\"llvm.powi.f64\");\n             Store(bcx, Call(bcx, powif, [a, x]), fcx.llretptr.get());\n         }\n         \"sinf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sinf = *ccx.intrinsics.get(& &\"llvm.sin.f32\");\n+            let sinf = ccx.intrinsics.get_copy(& &\"llvm.sin.f32\");\n             Store(bcx, Call(bcx, sinf, [x]), fcx.llretptr.get());\n         }\n         \"sinf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sinf = *ccx.intrinsics.get(& &\"llvm.sin.f64\");\n+            let sinf = ccx.intrinsics.get_copy(& &\"llvm.sin.f64\");\n             Store(bcx, Call(bcx, sinf, [x]), fcx.llretptr.get());\n         }\n         \"cosf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cosf = *ccx.intrinsics.get(& &\"llvm.cos.f32\");\n+            let cosf = ccx.intrinsics.get_copy(& &\"llvm.cos.f32\");\n             Store(bcx, Call(bcx, cosf, [x]), fcx.llretptr.get());\n         }\n         \"cosf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cosf = *ccx.intrinsics.get(& &\"llvm.cos.f64\");\n+            let cosf = ccx.intrinsics.get_copy(& &\"llvm.cos.f64\");\n             Store(bcx, Call(bcx, cosf, [x]), fcx.llretptr.get());\n         }\n         \"powf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powf = *ccx.intrinsics.get(& &\"llvm.pow.f32\");\n+            let powf = ccx.intrinsics.get_copy(& &\"llvm.pow.f32\");\n             Store(bcx, Call(bcx, powf, [a, x]), fcx.llretptr.get());\n         }\n         \"powf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powf = *ccx.intrinsics.get(& &\"llvm.pow.f64\");\n+            let powf = ccx.intrinsics.get_copy(& &\"llvm.pow.f64\");\n             Store(bcx, Call(bcx, powf, [a, x]), fcx.llretptr.get());\n         }\n         \"expf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let expf = *ccx.intrinsics.get(& &\"llvm.exp.f32\");\n+            let expf = ccx.intrinsics.get_copy(& &\"llvm.exp.f32\");\n             Store(bcx, Call(bcx, expf, [x]), fcx.llretptr.get());\n         }\n         \"expf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let expf = *ccx.intrinsics.get(& &\"llvm.exp.f64\");\n+            let expf = ccx.intrinsics.get_copy(& &\"llvm.exp.f64\");\n             Store(bcx, Call(bcx, expf, [x]), fcx.llretptr.get());\n         }\n         \"exp2f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let exp2f = *ccx.intrinsics.get(& &\"llvm.exp2.f32\");\n+            let exp2f = ccx.intrinsics.get_copy(& &\"llvm.exp2.f32\");\n             Store(bcx, Call(bcx, exp2f, [x]), fcx.llretptr.get());\n         }\n         \"exp2f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let exp2f = *ccx.intrinsics.get(& &\"llvm.exp2.f64\");\n+            let exp2f = ccx.intrinsics.get_copy(& &\"llvm.exp2.f64\");\n             Store(bcx, Call(bcx, exp2f, [x]), fcx.llretptr.get());\n         }\n         \"logf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let logf = *ccx.intrinsics.get(& &\"llvm.log.f32\");\n+            let logf = ccx.intrinsics.get_copy(& &\"llvm.log.f32\");\n             Store(bcx, Call(bcx, logf, [x]), fcx.llretptr.get());\n         }\n         \"logf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let logf = *ccx.intrinsics.get(& &\"llvm.log.f64\");\n+            let logf = ccx.intrinsics.get_copy(& &\"llvm.log.f64\");\n             Store(bcx, Call(bcx, logf, [x]), fcx.llretptr.get());\n         }\n         \"log10f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log10f = *ccx.intrinsics.get(& &\"llvm.log10.f32\");\n+            let log10f = ccx.intrinsics.get_copy(& &\"llvm.log10.f32\");\n             Store(bcx, Call(bcx, log10f, [x]), fcx.llretptr.get());\n         }\n         \"log10f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log10f = *ccx.intrinsics.get(& &\"llvm.log10.f64\");\n+            let log10f = ccx.intrinsics.get_copy(& &\"llvm.log10.f64\");\n             Store(bcx, Call(bcx, log10f, [x]), fcx.llretptr.get());\n         }\n         \"log2f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log2f = *ccx.intrinsics.get(& &\"llvm.log2.f32\");\n+            let log2f = ccx.intrinsics.get_copy(& &\"llvm.log2.f32\");\n             Store(bcx, Call(bcx, log2f, [x]), fcx.llretptr.get());\n         }\n         \"log2f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log2f = *ccx.intrinsics.get(& &\"llvm.log2.f64\");\n+            let log2f = ccx.intrinsics.get_copy(& &\"llvm.log2.f64\");\n             Store(bcx, Call(bcx, log2f, [x]), fcx.llretptr.get());\n         }\n         \"fmaf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = *ccx.intrinsics.get(& &\"llvm.fma.f32\");\n+            let fmaf = ccx.intrinsics.get_copy(& &\"llvm.fma.f32\");\n             Store(bcx, Call(bcx, fmaf, [a, b, c]), fcx.llretptr.get());\n         }\n         \"fmaf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = *ccx.intrinsics.get(& &\"llvm.fma.f64\");\n+            let fmaf = ccx.intrinsics.get_copy(& &\"llvm.fma.f64\");\n             Store(bcx, Call(bcx, fmaf, [a, b, c]), fcx.llretptr.get());\n         }\n         \"fabsf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let fabsf = *ccx.intrinsics.get(& &\"llvm.fabs.f32\");\n+            let fabsf = ccx.intrinsics.get_copy(& &\"llvm.fabs.f32\");\n             Store(bcx, Call(bcx, fabsf, [x]), fcx.llretptr.get());\n         }\n         \"fabsf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let fabsf = *ccx.intrinsics.get(& &\"llvm.fabs.f64\");\n+            let fabsf = ccx.intrinsics.get_copy(& &\"llvm.fabs.f64\");\n             Store(bcx, Call(bcx, fabsf, [x]), fcx.llretptr.get());\n         }\n         \"floorf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let floorf = *ccx.intrinsics.get(& &\"llvm.floor.f32\");\n+            let floorf = ccx.intrinsics.get_copy(& &\"llvm.floor.f32\");\n             Store(bcx, Call(bcx, floorf, [x]), fcx.llretptr.get());\n         }\n         \"floorf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let floorf = *ccx.intrinsics.get(& &\"llvm.floor.f64\");\n+            let floorf = ccx.intrinsics.get_copy(& &\"llvm.floor.f64\");\n             Store(bcx, Call(bcx, floorf, [x]), fcx.llretptr.get());\n         }\n         \"ceilf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ceilf = *ccx.intrinsics.get(& &\"llvm.ceil.f32\");\n+            let ceilf = ccx.intrinsics.get_copy(& &\"llvm.ceil.f32\");\n             Store(bcx, Call(bcx, ceilf, [x]), fcx.llretptr.get());\n         }\n         \"ceilf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ceilf = *ccx.intrinsics.get(& &\"llvm.ceil.f64\");\n+            let ceilf = ccx.intrinsics.get_copy(& &\"llvm.ceil.f64\");\n             Store(bcx, Call(bcx, ceilf, [x]), fcx.llretptr.get());\n         }\n         \"truncf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let truncf = *ccx.intrinsics.get(& &\"llvm.trunc.f32\");\n+            let truncf = ccx.intrinsics.get_copy(& &\"llvm.trunc.f32\");\n             Store(bcx, Call(bcx, truncf, [x]), fcx.llretptr.get());\n         }\n         \"truncf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let truncf = *ccx.intrinsics.get(& &\"llvm.trunc.f64\");\n+            let truncf = ccx.intrinsics.get_copy(& &\"llvm.trunc.f64\");\n             Store(bcx, Call(bcx, truncf, [x]), fcx.llretptr.get());\n         }\n         \"ctpop8\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = *ccx.intrinsics.get(& &\"llvm.ctpop.i8\");\n+            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i8\");\n             Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n         \"ctpop16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = *ccx.intrinsics.get(& &\"llvm.ctpop.i16\");\n+            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i16\");\n             Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n         \"ctpop32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = *ccx.intrinsics.get(& &\"llvm.ctpop.i32\");\n+            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i32\");\n             Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n         \"ctpop64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = *ccx.intrinsics.get(& &\"llvm.ctpop.i64\");\n+            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i64\");\n             Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n         \"ctlz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = *ccx.intrinsics.get(& &\"llvm.ctlz.i8\");\n+            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i8\");\n             Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n         \"ctlz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = *ccx.intrinsics.get(& &\"llvm.ctlz.i16\");\n+            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i16\");\n             Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n         \"ctlz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = *ccx.intrinsics.get(& &\"llvm.ctlz.i32\");\n+            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i32\");\n             Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n         \"ctlz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = *ccx.intrinsics.get(& &\"llvm.ctlz.i64\");\n+            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i64\");\n             Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n         \"cttz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = *ccx.intrinsics.get(& &\"llvm.cttz.i8\");\n+            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i8\");\n             Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n         \"cttz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = *ccx.intrinsics.get(& &\"llvm.cttz.i16\");\n+            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i16\");\n             Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n         \"cttz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = *ccx.intrinsics.get(& &\"llvm.cttz.i32\");\n+            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i32\");\n             Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n         \"cttz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = *ccx.intrinsics.get(& &\"llvm.cttz.i64\");\n+            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i64\");\n             Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n         \"bswap16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = *ccx.intrinsics.get(& &\"llvm.bswap.i16\");\n+            let cttz = ccx.intrinsics.get_copy(& &\"llvm.bswap.i16\");\n             Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n         }\n         \"bswap32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = *ccx.intrinsics.get(& &\"llvm.bswap.i32\");\n+            let cttz = ccx.intrinsics.get_copy(& &\"llvm.bswap.i32\");\n             Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n         }\n         \"bswap64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = *ccx.intrinsics.get(& &\"llvm.bswap.i64\");\n+            let cttz = ccx.intrinsics.get_copy(& &\"llvm.bswap.i64\");\n             Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n         }\n         _ => {\n@@ -1202,15 +1202,15 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n  *         R(args->z, NULL, args->x, args->y);\n  *     }\n  */\n-pub fn trans_foreign_fn(ccx: @CrateContext,\n+pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                         path: ast_map::path,\n                         decl: &ast::fn_decl,\n                         body: &ast::blk,\n                         llwrapfn: ValueRef,\n                         id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n-    fn build_rust_fn(ccx: @CrateContext,\n+    fn build_rust_fn(ccx: @mut CrateContext,\n                      path: ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n@@ -1238,7 +1238,7 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n         return llfndecl;\n     }\n \n-    fn build_shim_fn(ccx: @CrateContext,\n+    fn build_shim_fn(ccx: @mut CrateContext,\n                      path: ast_map::path,\n                      llrustfn: ValueRef,\n                      tys: &ShimTypes)\n@@ -1323,7 +1323,7 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n                        build_ret)\n     }\n \n-    fn build_wrap_fn(ccx: @CrateContext,\n+    fn build_wrap_fn(ccx: @mut CrateContext,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef,\n                      tys: &ShimTypes) {\n@@ -1376,7 +1376,7 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n     build_wrap_fn(ccx, llshimfn, llwrapfn, &tys)\n }\n \n-pub fn register_foreign_fn(ccx: @CrateContext,\n+pub fn register_foreign_fn(ccx: @mut CrateContext,\n                            sp: span,\n                            path: ast_map::path,\n                            node_id: ast::node_id,"}, {"sha": "3c43e8535f428910c09116612595d5bb90b40494", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -156,7 +156,7 @@ pub fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     }\n }\n \n-pub fn lazily_emit_all_tydesc_glue(ccx: @CrateContext,\n+pub fn lazily_emit_all_tydesc_glue(ccx: @mut CrateContext,\n                                    static_ti: @mut tydesc_info) {\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n@@ -218,7 +218,7 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     return t;\n }\n \n-pub fn lazily_emit_simplified_tydesc_glue(ccx: @CrateContext,\n+pub fn lazily_emit_simplified_tydesc_glue(ccx: @mut CrateContext,\n                                           field: uint,\n                                           ti: @mut tydesc_info) -> bool {\n     let _icx = ccx.insn_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n@@ -243,7 +243,7 @@ pub fn lazily_emit_simplified_tydesc_glue(ccx: @CrateContext,\n }\n \n \n-pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n+pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n                                field: uint,\n                                ti: @mut tydesc_info) {\n     let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n@@ -624,7 +624,7 @@ pub fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n \n \n // Chooses the addrspace for newly declared types.\n-pub fn declare_tydesc_addrspace(ccx: @CrateContext, t: ty::t) -> addrspace {\n+pub fn declare_tydesc_addrspace(ccx: &CrateContext, t: ty::t) -> addrspace {\n     if !ty::type_needs_drop(ccx.tcx, t) {\n         return default_addrspace;\n     } else if ty::type_is_immediate(t) {\n@@ -638,11 +638,10 @@ pub fn declare_tydesc_addrspace(ccx: @CrateContext, t: ty::t) -> addrspace {\n }\n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-pub fn declare_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n-    let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n+pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n-    assert!(!*ccx.finished_tydescs);\n+    assert!(!ccx.finished_tydescs);\n \n     let llty = type_of(ccx, t);\n \n@@ -680,7 +679,7 @@ pub fn declare_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n \n pub type glue_helper = @fn(block, ValueRef, ty::t);\n \n-pub fn declare_generic_glue(ccx: @CrateContext, t: ty::t, llfnty: TypeRef,\n+pub fn declare_generic_glue(ccx: @mut CrateContext, t: ty::t, llfnty: TypeRef,\n                             name: ~str) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n     let name = name;\n@@ -692,7 +691,7 @@ pub fn declare_generic_glue(ccx: @CrateContext, t: ty::t, llfnty: TypeRef,\n     return llfn;\n }\n \n-pub fn make_generic_glue_inner(ccx: @CrateContext,\n+pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n                                t: ty::t,\n                                llfn: ValueRef,\n                                helper: glue_helper)\n@@ -717,7 +716,7 @@ pub fn make_generic_glue_inner(ccx: @CrateContext,\n     return llfn;\n }\n \n-pub fn make_generic_glue(ccx: @CrateContext,\n+pub fn make_generic_glue(ccx: @mut CrateContext,\n                          t: ty::t,\n                          llfn: ValueRef,\n                          helper: glue_helper,\n@@ -738,12 +737,13 @@ pub fn make_generic_glue(ccx: @CrateContext,\n     return llval;\n }\n \n-pub fn emit_tydescs(ccx: @CrateContext) {\n-    let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n+pub fn emit_tydescs(ccx: &mut CrateContext) {\n+    //let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n-    *ccx.finished_tydescs = true;\n-    for ccx.tydescs.each_value |&val| {\n-        let glue_fn_ty = T_ptr(T_generic_glue_fn(ccx));\n+    ccx.finished_tydescs = true;\n+    let glue_fn_ty = T_ptr(T_generic_glue_fn(ccx));\n+    let tyds = &mut ccx.tydescs;\n+    for tyds.each_value |&val| {\n         let ti = val;\n \n         // Each of the glue functions needs to be cast to a generic type"}, {"sha": "b0aedbae79bfdf421b50d835bd98176effd7f993", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -27,7 +27,7 @@ use syntax::ast_util::local_def;\n // `translate` will be true if this function is allowed to translate the\n // item and false otherwise. Currently, this parameter is set to false when\n // translating default methods.\n-pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n+pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::def_id,\n                                 translate: bool)\n     -> ast::def_id {\n     let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");"}, {"sha": "fb94fe4752a32d339e3f8c6a866d73d471d9c0b7", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -22,15 +22,15 @@ use util::ppaux::ty_to_str;\n // compute sizeof / alignof\n \n // Returns the number of bytes clobbered by a Store to this type.\n-pub fn llsize_of_store(cx: @CrateContext, t: TypeRef) -> uint {\n+pub fn llsize_of_store(cx: &CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         return llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n     }\n }\n \n // Returns the number of bytes between successive elements of type T in an\n // array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n-pub fn llsize_of_alloc(cx: @CrateContext, t: TypeRef) -> uint {\n+pub fn llsize_of_alloc(cx: &CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         return llvm::LLVMABISizeOfType(cx.td.lltd, t) as uint;\n     }\n@@ -44,7 +44,7 @@ pub fn llsize_of_alloc(cx: @CrateContext, t: TypeRef) -> uint {\n // that LLVM *does* distinguish between e.g. a 1-bit value and an 8-bit value\n // at the codegen level! In general you should prefer `llbitsize_of_real`\n // below.\n-pub fn llsize_of_real(cx: @CrateContext, t: TypeRef) -> uint {\n+pub fn llsize_of_real(cx: &CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint;\n         if nbits & 7u != 0u {\n@@ -57,14 +57,14 @@ pub fn llsize_of_real(cx: @CrateContext, t: TypeRef) -> uint {\n }\n \n /// Returns the \"real\" size of the type in bits.\n-pub fn llbitsize_of_real(cx: @CrateContext, t: TypeRef) -> uint {\n+pub fn llbitsize_of_real(cx: &CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint\n     }\n }\n \n /// Returns the size of the type as an LLVM constant integer value.\n-pub fn llsize_of(cx: @CrateContext, t: TypeRef) -> ValueRef {\n+pub fn llsize_of(cx: &CrateContext, t: TypeRef) -> ValueRef {\n     // Once upon a time, this called LLVMSizeOf, which does a\n     // getelementptr(1) on a null pointer and casts to an int, in\n     // order to obtain the type size as a value without requiring the\n@@ -78,7 +78,7 @@ pub fn llsize_of(cx: @CrateContext, t: TypeRef) -> ValueRef {\n // Returns the \"default\" size of t (see above), or 1 if the size would\n // be zero.  This is important for things like vectors that expect\n // space to be consumed.\n-pub fn nonzero_llsize_of(cx: @CrateContext, t: TypeRef) -> ValueRef {\n+pub fn nonzero_llsize_of(cx: &CrateContext, t: TypeRef) -> ValueRef {\n     if llbitsize_of_real(cx, t) == 0 {\n         unsafe { llvm::LLVMConstInt(cx.int_type, 1, False) }\n     } else {\n@@ -90,7 +90,7 @@ pub fn nonzero_llsize_of(cx: @CrateContext, t: TypeRef) -> ValueRef {\n // The preferred alignment may be larger than the alignment used when\n // packing the type into structs. This will be used for things like\n // allocations inside a stack frame, which LLVM has a free hand in.\n-pub fn llalign_of_pref(cx: @CrateContext, t: TypeRef) -> uint {\n+pub fn llalign_of_pref(cx: &CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n     }\n@@ -99,7 +99,7 @@ pub fn llalign_of_pref(cx: @CrateContext, t: TypeRef) -> uint {\n // Returns the minimum alignment of a type required by the platform.\n // This is the alignment that will be used for struct fields, arrays,\n // and similar ABI-mandated things.\n-pub fn llalign_of_min(cx: @CrateContext, t: TypeRef) -> uint {\n+pub fn llalign_of_min(cx: &CrateContext, t: TypeRef) -> uint {\n     unsafe {\n         return llvm::LLVMABIAlignmentOfType(cx.td.lltd, t) as uint;\n     }\n@@ -108,15 +108,15 @@ pub fn llalign_of_min(cx: @CrateContext, t: TypeRef) -> uint {\n // Returns the \"default\" alignment of t, which is calculated by casting\n // null to a record containing a single-bit followed by a t value, then\n // doing gep(0,1) to get at the trailing (and presumably padded) t cell.\n-pub fn llalign_of(cx: @CrateContext, t: TypeRef) -> ValueRef {\n+pub fn llalign_of(cx: &CrateContext, t: TypeRef) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstIntCast(\n             llvm::LLVMAlignOf(t), cx.int_type, False);\n     }\n }\n \n // Computes the size of the data part of an enum.\n-pub fn static_size_of_enum(cx: @CrateContext, t: ty::t) -> uint {\n+pub fn static_size_of_enum(cx: &mut CrateContext, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(&t) {\n         return cx.enum_sizes.get_copy(&t);\n     }"}, {"sha": "c59b3f36779b789acaa41dd0233fe39407a569d1", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -42,7 +42,7 @@ for non-monomorphized methods only.  Other methods will\n be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n-pub fn trans_impl(ccx: @CrateContext,\n+pub fn trans_impl(ccx: @mut CrateContext,\n                   path: path,\n                   name: ast::ident,\n                   methods: &[@ast::method],\n@@ -102,7 +102,7 @@ Translates a (possibly monomorphized) method body.\n - `llfn`: the LLVM ValueRef for the method\n - `impl_id`: the node ID of the impl this method is inside\n */\n-pub fn trans_method(ccx: @CrateContext,\n+pub fn trans_method(ccx: @mut CrateContext,\n                     path: path,\n                     method: &ast::method,\n                     param_substs: Option<@param_substs>,\n@@ -378,44 +378,52 @@ pub fn method_from_methods(ms: &[@ast::method], name: ast::ident)\n     ms.find(|m| m.ident == name).map(|m| ast_util::local_def(m.id))\n }\n \n-pub fn method_with_name_or_default(ccx: @CrateContext,\n+pub fn method_with_name_or_default(ccx: @mut CrateContext,\n                                    impl_id: ast::def_id,\n                                    name: ast::ident) -> ast::def_id {\n-    *do ccx.impl_method_cache.find_or_insert_with((impl_id, name)) |_| {\n-        if impl_id.crate == ast::local_crate {\n-            match ccx.tcx.items.get_copy(&impl_id.node) {\n-                ast_map::node_item(@ast::item {\n-                                   node: ast::item_impl(_, _, _, ref ms), _\n-                                   }, _) => {\n-                    let did = method_from_methods(*ms, name);\n-                    if did.is_some() {\n-                        did.get()\n-                    } else {\n-                        // Look for a default method\n-                        let pmm = ccx.tcx.provided_methods;\n-                        match pmm.find(&impl_id) {\n-                            Some(pmis) => {\n-                                for pmis.each |pmi| {\n-                                    if pmi.method_info.ident == name {\n-                                        debug!(\"pmi.method_info.did = %?\", pmi.method_info.did);\n-                                        return pmi.method_info.did;\n+    let imp = ccx.impl_method_cache.find_copy(&(impl_id, name));\n+    match imp {\n+        Some(m) => m,\n+        None => {\n+            let imp = if impl_id.crate == ast::local_crate {\n+                match ccx.tcx.items.get_copy(&impl_id.node) {\n+                    ast_map::node_item(@ast::item {\n+                                       node: ast::item_impl(_, _, _, ref ms), _\n+                                       }, _) => {\n+                        let did = method_from_methods(*ms, name);\n+                        if did.is_some() {\n+                            did.get()\n+                        } else {\n+                            // Look for a default method\n+                            let pmm = ccx.tcx.provided_methods;\n+                            match pmm.find(&impl_id) {\n+                                Some(pmis) => {\n+                                    for pmis.each |pmi| {\n+                                        if pmi.method_info.ident == name {\n+                                            debug!(\"pmi.method_info.did = %?\", pmi.method_info.did);\n+                                            return pmi.method_info.did;\n+                                        }\n                                     }\n+                                    fail!()\n                                 }\n-                                fail!()\n+                                None => fail!()\n                             }\n-                            None => fail!()\n                         }\n                     }\n+                    _ => fail!(\"method_with_name\")\n                 }\n-                _ => fail!(\"method_with_name\")\n-            }\n-        } else {\n-            csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n+            } else {\n+                csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n+            };\n+\n+            ccx.impl_method_cache.insert((impl_id, name), imp);\n+\n+            imp\n         }\n     }\n }\n \n-pub fn method_ty_param_count(ccx: @CrateContext, m_id: ast::def_id,\n+pub fn method_ty_param_count(ccx: &CrateContext, m_id: ast::def_id,\n                              i_id: ast::def_id) -> uint {\n     debug!(\"method_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n     if m_id.crate == ast::local_crate {\n@@ -734,7 +742,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n     };\n }\n \n-pub fn vtable_id(ccx: @CrateContext,\n+pub fn vtable_id(ccx: @mut CrateContext,\n                  origin: &typeck::vtable_origin)\n               -> mono_id {\n     match origin {\n@@ -778,7 +786,7 @@ pub fn get_vtable(bcx: block,\n }\n \n /// Helper function to declare and initialize the vtable.\n-pub fn make_vtable(ccx: @CrateContext,\n+pub fn make_vtable(ccx: @mut CrateContext,\n                    tydesc: @mut tydesc_info,\n                    ptrs: &[ValueRef])\n                    -> ValueRef {"}, {"sha": "49cadfbcc81a3edea1061a72c53a9367fe358e04", "filename": "src/librustc/middle/trans/mod.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod macros;\n+pub mod inline;\n+pub mod monomorphize;\n+pub mod controlflow;\n+pub mod glue;\n+pub mod datum;\n+pub mod write_guard;\n+pub mod callee;\n+pub mod expr;\n+pub mod common;\n+pub mod context;\n+pub mod consts;\n+pub mod type_of;\n+pub mod build;\n+pub mod base;\n+pub mod _match;\n+pub mod uniq;\n+pub mod closure;\n+pub mod tvec;\n+pub mod meth;\n+pub mod cabi;\n+pub mod cabi_x86;\n+pub mod cabi_x86_64;\n+pub mod cabi_arm;\n+pub mod cabi_mips;\n+pub mod foreign;\n+pub mod reflect;\n+pub mod shape;\n+pub mod debuginfo;\n+pub mod type_use;\n+pub mod reachable;\n+pub mod machine;\n+pub mod adt;\n+pub mod asm;"}, {"sha": "df2831947130d2193b5d4bf3170dae94c833d908", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -40,7 +40,7 @@ use syntax::ast_util::local_def;\n use syntax::opt_vec;\n use syntax::abi::AbiSet;\n \n-pub fn monomorphic_fn(ccx: @CrateContext,\n+pub fn monomorphic_fn(ccx: @mut CrateContext,\n                       fn_id: ast::def_id,\n                       real_substs: &ty::substs,\n                       vtables: Option<typeck::vtable_res>,\n@@ -329,7 +329,7 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n     }\n }\n \n-pub fn make_mono_id(ccx: @CrateContext,\n+pub fn make_mono_id(ccx: @mut CrateContext,\n                     item: ast::def_id,\n                     substs: &[ty::t],\n                     vtables: Option<typeck::vtable_res>,"}, {"sha": "e4924e3a8db30bb16789894a6a402e47d193a64f", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -151,8 +151,7 @@ impl Reflector {\n     // Entrypoint\n     pub fn visit_ty(&mut self, t: ty::t) {\n         let bcx = self.bcx;\n-        debug!(\"reflect::visit_ty %s\",\n-               ty_to_str(bcx.ccx().tcx, t));\n+        debug!(\"reflect::visit_ty %s\", ty_to_str(bcx.ccx().tcx, t));\n \n         match ty::get(t).sty {\n           ty::ty_bot => self.leaf(~\"bot\"),\n@@ -312,16 +311,17 @@ impl Reflector {\n                 + self.c_size_and_align(t);\n             do self.bracketed(~\"enum\", enum_args) |this| {\n                 for variants.eachi |i, v| {\n+                    let name = ccx.sess.str_of(v.name);\n                     let variant_args = ~[this.c_uint(i),\n                                          this.c_int(v.disr_val),\n                                          this.c_uint(v.args.len()),\n-                                         this.c_slice(ccx.sess.str_of(v.name))];\n+                                         this.c_slice(name)];\n                     do this.bracketed(~\"enum_variant\", variant_args) |this| {\n                         for v.args.eachi |j, a| {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n-                            let offset = p2i(ccx, adt::trans_field_ptr(bcx, repr, null,\n-                                                                       v.disr_val, j));\n+                            let ptr = adt::trans_field_ptr(bcx, repr, null, v.disr_val, j);\n+                            let offset = p2i(ccx, ptr);\n                             let field_args = ~[this.c_uint(j),\n                                                offset,\n                                                this.c_tydesc(*a)];"}, {"sha": "89ffb4b5bbaa747e81db0ad078dc11b3eb37d651", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -25,8 +25,8 @@ pub struct Ctxt {\n     pad2: u32\n }\n \n-pub fn mk_global(ccx: @CrateContext,\n-                 name: ~str,\n+pub fn mk_global(ccx: &CrateContext,\n+                 name: &str,\n                  llval: ValueRef,\n                  internal: bool)\n               -> ValueRef {"}, {"sha": "11a4e82050d21db7f5a99b0e9102c5e4595ab346", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -151,7 +151,7 @@ pub struct VecTypes {\n }\n \n impl VecTypes {\n-    pub fn to_str(&self, ccx: @CrateContext) -> ~str {\n+    pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         fmt!(\"VecTypes {vec_ty=%s, unit_ty=%s, llunit_ty=%s, llunit_size=%s}\",\n              ty_to_str(ccx.tcx, self.vec_ty),\n              ty_to_str(ccx.tcx, self.unit_ty),"}, {"sha": "268d60d4417689e0741b582f4cfafd2ae06a1e86", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -21,21 +21,21 @@ use util::ppaux;\n \n use syntax::ast;\n \n-pub fn arg_is_indirect(_: @CrateContext, arg_ty: &ty::t) -> bool {\n+pub fn arg_is_indirect(_: &CrateContext, arg_ty: &ty::t) -> bool {\n     !ty::type_is_immediate(*arg_ty)\n }\n \n-pub fn type_of_explicit_arg(ccx: @CrateContext, arg_ty: &ty::t) -> TypeRef {\n+pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: &ty::t) -> TypeRef {\n     let llty = type_of(ccx, *arg_ty);\n     if arg_is_indirect(ccx, arg_ty) {T_ptr(llty)} else {llty}\n }\n \n-pub fn type_of_explicit_args(ccx: @CrateContext,\n+pub fn type_of_explicit_args(ccx: &mut CrateContext,\n                              inputs: &[ty::t]) -> ~[TypeRef] {\n     inputs.map(|arg_ty| type_of_explicit_arg(ccx, arg_ty))\n }\n \n-pub fn type_of_fn(cx: @CrateContext, inputs: &[ty::t], output: ty::t)\n+pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t)\n                -> TypeRef {\n     unsafe {\n         let mut atys: ~[TypeRef] = ~[];\n@@ -64,7 +64,7 @@ pub fn type_of_fn(cx: @CrateContext, inputs: &[ty::t], output: ty::t)\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty(cx: @CrateContext, fty: ty::t) -> TypeRef {\n+pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> TypeRef {\n     match ty::get(fty).sty {\n         ty::ty_closure(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n         ty::ty_bare_fn(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n@@ -74,7 +74,7 @@ pub fn type_of_fn_from_ty(cx: @CrateContext, fty: ty::t) -> TypeRef {\n     }\n }\n \n-pub fn type_of_non_gc_box(cx: @CrateContext, t: ty::t) -> TypeRef {\n+pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n     assert!(!ty::type_needs_infer(t));\n \n     let t_norm = ty::normalize_ty(cx.tcx, t);\n@@ -83,10 +83,12 @@ pub fn type_of_non_gc_box(cx: @CrateContext, t: ty::t) -> TypeRef {\n     } else {\n         match ty::get(t).sty {\n           ty::ty_box(mt) => {\n-            T_ptr(T_box(cx, type_of(cx, mt.ty)))\n+              let ty = type_of(cx, mt.ty);\n+              T_ptr(T_box(cx, ty))\n           }\n           ty::ty_uniq(mt) => {\n-            T_ptr(T_unique(cx, type_of(cx, mt.ty)))\n+              let ty = type_of(cx, mt.ty);\n+              T_ptr(T_unique(cx, ty))\n           }\n           _ => {\n             cx.sess.bug(\"non-box in type_of_non_gc_box\");\n@@ -107,7 +109,7 @@ pub fn type_of_non_gc_box(cx: @CrateContext, t: ty::t) -> TypeRef {\n //     recursive types. For example, `static_size_of_enum()` relies on this\n //     behavior.\n \n-pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n+pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n     match cx.llsizingtypes.find(&t) {\n         Some(t) => return *t,\n         None => ()\n@@ -146,7 +148,10 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n             T_array(sizing_type_of(cx, mt.ty), size)\n         }\n \n-        ty::ty_unboxed_vec(mt) => T_vec(cx, sizing_type_of(cx, mt.ty)),\n+        ty::ty_unboxed_vec(mt) => {\n+            let sz_ty = sizing_type_of(cx, mt.ty);\n+            T_vec(cx, sz_ty)\n+        }\n \n         ty::ty_tup(*) | ty::ty_enum(*) => {\n             let repr = adt::represent_type(cx, t);\n@@ -177,7 +182,7 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n }\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n-pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n+pub fn type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n     debug!(\"type_of %?: %?\", t, ty::get(t));\n \n     // Check the cache.\n@@ -223,22 +228,35 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n         T_box_ptr(T_box(cx, T_vec(cx, T_i8())))\n       }\n       ty::ty_evec(ref mt, ty::vstore_box) => {\n-        T_box_ptr(T_box(cx, T_vec(cx, type_of(cx, mt.ty))))\n+          let e_ty = type_of(cx, mt.ty);\n+          let v_ty = T_vec(cx, e_ty);\n+          T_box_ptr(T_box(cx, v_ty))\n+      }\n+      ty::ty_box(ref mt) => {\n+          let ty = type_of(cx, mt.ty);\n+          T_box_ptr(T_box(cx, ty))\n       }\n-      ty::ty_box(ref mt) => T_box_ptr(T_box(cx, type_of(cx, mt.ty))),\n       ty::ty_opaque_box => T_box_ptr(T_box(cx, T_i8())),\n-      ty::ty_uniq(ref mt) => T_unique_ptr(T_unique(cx, type_of(cx, mt.ty))),\n+      ty::ty_uniq(ref mt) => {\n+          let ty = type_of(cx, mt.ty);\n+          T_unique_ptr(T_unique(cx, ty))\n+      }\n       ty::ty_evec(ref mt, ty::vstore_uniq) => {\n-        T_unique_ptr(T_unique(cx, T_vec(cx, type_of(cx, mt.ty))))\n+          let ty = type_of(cx, mt.ty);\n+          let ty = T_vec(cx, ty);\n+          T_unique_ptr(T_unique(cx, ty))\n       }\n       ty::ty_unboxed_vec(ref mt) => {\n-        T_vec(cx, type_of(cx, mt.ty))\n+          let ty = type_of(cx, mt.ty);\n+          T_vec(cx, ty)\n       }\n       ty::ty_ptr(ref mt) => T_ptr(type_of(cx, mt.ty)),\n       ty::ty_rptr(_, ref mt) => T_ptr(type_of(cx, mt.ty)),\n \n       ty::ty_evec(ref mt, ty::vstore_slice(_)) => {\n-        T_struct([T_ptr(type_of(cx, mt.ty)), T_uint_ty(cx, ast::ty_u)], false)\n+          let p_ty = T_ptr(type_of(cx, mt.ty));\n+          let u_ty = T_uint_ty(cx, ast::ty_u);\n+          T_struct([p_ty, u_ty], false)\n       }\n \n       ty::ty_estr(ty::vstore_slice(_)) => {\n@@ -254,7 +272,10 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n       }\n \n       ty::ty_bare_fn(_) => T_ptr(type_of_fn_from_ty(cx, t)),\n-      ty::ty_closure(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n+      ty::ty_closure(_) => {\n+          let ty = type_of_fn_from_ty(cx, t);\n+          T_fn_pair(cx, ty)\n+      }\n       ty::ty_trait(_, _, store, _) => T_opaque_trait(cx, store),\n       ty::ty_type => T_ptr(cx.tydesc_type),\n       ty::ty_tup(*) => {\n@@ -310,7 +331,7 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n // Want refinements! (Or case classes, I guess\n pub enum named_ty { a_struct, an_enum }\n \n-pub fn llvm_type_name(cx: @CrateContext,\n+pub fn llvm_type_name(cx: &CrateContext,\n                       what: named_ty,\n                       did: ast::def_id,\n                       tps: &[ty::t]) -> ~str {\n@@ -330,18 +351,18 @@ pub fn llvm_type_name(cx: @CrateContext,\n     );\n }\n \n-pub fn type_of_dtor(ccx: @CrateContext, self_ty: ty::t) -> TypeRef {\n+pub fn type_of_dtor(ccx: &mut CrateContext, self_ty: ty::t) -> TypeRef {\n     T_fn([T_ptr(type_of(ccx, self_ty))] /* self */, T_nil())\n }\n \n-pub fn type_of_rooted(ccx: @CrateContext, t: ty::t) -> TypeRef {\n+pub fn type_of_rooted(ccx: &mut CrateContext, t: ty::t) -> TypeRef {\n     let addrspace = base::get_tydesc(ccx, t).addrspace;\n     debug!(\"type_of_rooted %s in addrspace %u\",\n            ppaux::ty_to_str(ccx.tcx, t), addrspace as uint);\n     return T_root(type_of(ccx, t), addrspace);\n }\n \n-pub fn type_of_glue_fn(ccx: @CrateContext) -> TypeRef {\n+pub fn type_of_glue_fn(ccx: &CrateContext) -> TypeRef {\n     let tydescpp = T_ptr(T_ptr(ccx.tydesc_type));\n     return T_fn([T_ptr(T_nil()), tydescpp, T_ptr(T_i8())], T_nil());\n }"}, {"sha": "8c4ff4415641fbfe713b5e235ad83cd6744c21ce", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -51,11 +51,11 @@ pub static use_repr: uint = 1;   /* Dependency on size/alignment/mode and\n pub static use_tydesc: uint = 2; /* Takes the tydesc, or compares */\n \n pub struct Context {\n-    ccx: @CrateContext,\n+    ccx: @mut CrateContext,\n     uses: @mut ~[type_uses]\n }\n \n-pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n+pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n     -> @~[type_uses] {\n     match ccx.type_use_cache.find(&fn_id) {\n       Some(uses) => return *uses,"}, {"sha": "1197693d1b6dfc3cddbe490609ee4266a1c28cfe", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/579c614e38303434bdb2926e192f69db041aec78/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=579c614e38303434bdb2926e192f69db041aec78", "patch": "@@ -61,41 +61,8 @@ use syntax::codemap;\n use syntax::diagnostic;\n \n pub mod middle {\n-    pub mod trans {\n-        pub mod macros;\n-        pub mod inline;\n-        pub mod monomorphize;\n-        pub mod controlflow;\n-        pub mod glue;\n-        pub mod datum;\n-        pub mod write_guard;\n-        pub mod callee;\n-        pub mod expr;\n-        pub mod common;\n-        pub mod consts;\n-        pub mod type_of;\n-        pub mod build;\n-        pub mod base;\n-        pub mod _match;\n-        pub mod uniq;\n-        pub mod closure;\n-        pub mod tvec;\n-        pub mod meth;\n-        pub mod cabi;\n-        pub mod cabi_x86;\n-        pub mod cabi_x86_64;\n-        pub mod cabi_arm;\n-        pub mod cabi_mips;\n-        pub mod foreign;\n-        pub mod reflect;\n-        pub mod shape;\n-        pub mod debuginfo;\n-        pub mod type_use;\n-        pub mod reachable;\n-        pub mod machine;\n-        pub mod adt;\n-        pub mod asm;\n-    }\n+    #[path = \"trans/mod.rs\"]\n+    pub mod trans;\n     pub mod ty;\n     pub mod subst;\n     pub mod resolve;"}]}