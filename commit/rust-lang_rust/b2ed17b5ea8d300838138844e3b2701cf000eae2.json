{"sha": "b2ed17b5ea8d300838138844e3b2701cf000eae2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZWQxN2I1ZWE4ZDMwMDgzODEzODg0NGUzYjI3MDFjZjAwMGVhZTI=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-04-06T00:50:08Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-04-06T00:50:08Z"}, "message": "No separator for `?`. No `?` as a separator.", "tree": {"sha": "4901f970d866136290ed8d70404d132eea51197c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4901f970d866136290ed8d70404d132eea51197c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2ed17b5ea8d300838138844e3b2701cf000eae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ed17b5ea8d300838138844e3b2701cf000eae2", "html_url": "https://github.com/rust-lang/rust/commit/b2ed17b5ea8d300838138844e3b2701cf000eae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2ed17b5ea8d300838138844e3b2701cf000eae2/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56714acc5eb0687ed9a7566fdebe5528657fc5b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/56714acc5eb0687ed9a7566fdebe5528657fc5b3", "html_url": "https://github.com/rust-lang/rust/commit/56714acc5eb0687ed9a7566fdebe5528657fc5b3"}], "stats": {"total": 224, "additions": 70, "deletions": 154}, "files": [{"sha": "30b993dda3de5d8829f4f0f327041444fc021a7e", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 22, "deletions": 67, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b2ed17b5ea8d300838138844e3b2701cf000eae2/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ed17b5ea8d300838138844e3b2701cf000eae2/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=b2ed17b5ea8d300838138844e3b2701cf000eae2", "patch": "@@ -389,72 +389,26 @@ where\n {\n     // We basically look at two token trees here, denoted as #1 and #2 below\n     let span = match parse_kleene_op(input, span) {\n-        // #1 is a `+` or `*` KleeneOp\n-        //\n-        // `?` is ambiguous: it could be a separator or a Kleene::ZeroOrOne, so we need to look\n-        // ahead one more token to be sure.\n-        Ok(Ok(op)) if op != KleeneOp::ZeroOrOne => return (None, op),\n-\n-        // #1 is `?` token, but it could be a Kleene::ZeroOrOne without a separator or it could\n-        // be a `?` separator followed by any Kleene operator. We need to look ahead 1 token to\n-        // find out which.\n-        Ok(Ok(op)) => {\n-            assert_eq!(op, KleeneOp::ZeroOrOne);\n-\n-            // Lookahead at #2. If it is a KleenOp, then #1 is a separator.\n-            let is_1_sep = if let Some(&tokenstream::TokenTree::Token(_, ref tok2)) = input.peek() {\n-                kleene_op(tok2).is_some()\n-            } else {\n-                false\n-            };\n-\n-            if is_1_sep {\n-                // #1 is a separator and #2 should be a KleepeOp::*\n-                // (N.B. We need to advance the input iterator.)\n-                match parse_kleene_op(input, span) {\n-                    // #2 is a KleeneOp (this is the only valid option) :)\n-                    Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n-                        if !features.macro_at_most_once_rep\n-                            && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-                        {\n-                            let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n-                            emit_feature_err(\n-                                sess,\n-                                \"macro_at_most_once_rep\",\n-                                span,\n-                                GateIssue::Language,\n-                                explain,\n-                            );\n-                        }\n-                        return (Some(token::Question), op);\n-                    }\n-                    Ok(Ok(op)) => return (Some(token::Question), op),\n-\n-                    // #2 is a random token (this is an error) :(\n-                    Ok(Err((_, span))) => span,\n-\n-                    // #2 is not even a token at all :(\n-                    Err(span) => span,\n-                }\n-            } else {\n-                if !features.macro_at_most_once_rep\n-                    && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-                {\n-                    let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n-                    emit_feature_err(\n-                        sess,\n-                        \"macro_at_most_once_rep\",\n-                        span,\n-                        GateIssue::Language,\n-                        explain,\n-                    );\n-                }\n-\n-                // #2 is a random tree and #1 is KleeneOp::ZeroOrOne\n-                return (None, op);\n+        // #1 is any KleeneOp (`?`)\n+        Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n+            if !features.macro_at_most_once_rep\n+                && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+            {\n+                let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n+                emit_feature_err(\n+                    sess,\n+                    \"macro_at_most_once_rep\",\n+                    span,\n+                    GateIssue::Language,\n+                    explain,\n+                );\n             }\n+            return (None, op);\n         }\n \n+        // #1 is any KleeneOp (`+`, `*`)\n+        Ok(Ok(op)) => return (None, op),\n+\n         // #1 is a separator followed by #2, a KleeneOp\n         Ok(Err((tok, span))) => match parse_kleene_op(input, span) {\n             // #2 is a KleeneOp :D\n@@ -470,8 +424,11 @@ where\n                         GateIssue::Language,\n                         explain,\n                     );\n+                } else {\n+                    sess.span_diagnostic\n+                        .span_err(span, \"`?` macro repetition does not allow a separator\");\n                 }\n-                return (Some(tok), op);\n+                return (None, op);\n             }\n             Ok(Ok(op)) => return (Some(tok), op),\n \n@@ -486,9 +443,7 @@ where\n         Err(span) => span,\n     };\n \n-    if !features.macro_at_most_once_rep\n-        && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-    {\n+    if !features.macro_at_most_once_rep && !attr::contains_name(attrs, \"allow_internal_unstable\") {\n         sess.span_diagnostic\n             .span_err(span, \"expected one of: `*`, `+`, or `?`\");\n     } else {"}, {"sha": "c08effe549328705ae5843475b2c4f54c5032033", "filename": "src/test/run-pass/macro-at-most-once-rep.rs", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2ed17b5ea8d300838138844e3b2701cf000eae2/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ed17b5ea8d300838138844e3b2701cf000eae2/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs?ref=b2ed17b5ea8d300838138844e3b2701cf000eae2", "patch": "@@ -32,25 +32,13 @@ macro_rules! foo {\n     } }\n }\n \n-macro_rules! baz {\n-    ($($a:ident),? ; $num:expr) => { { // comma separator is meaningless for `?`\n-        let mut x = 0;\n-\n-        $(\n-            x += $a;\n-         )?\n-\n-        assert_eq!(x, $num);\n-    } }\n-}\n-\n macro_rules! barplus {\n     ($($a:ident)?+ ; $num:expr) => { {\n         let mut x = 0;\n \n         $(\n             x += $a;\n-         )+\n+         )?\n \n         assert_eq!(x, $num);\n     } }\n@@ -62,7 +50,7 @@ macro_rules! barstar {\n \n         $(\n             x += $a;\n-         )*\n+         )?\n \n         assert_eq!(x, $num);\n     } }\n@@ -74,15 +62,10 @@ pub fn main() {\n     // accept 0 or 1 repetitions\n     foo!( ; 0);\n     foo!(a ; 1);\n-    baz!( ; 0);\n-    baz!(a ; 1);\n \n     // Make sure using ? as a separator works as before\n-    barplus!(a ; 1);\n-    barplus!(a?a ; 2);\n-    barplus!(a?a?a ; 3);\n-    barstar!( ; 0);\n-    barstar!(a ; 1);\n-    barstar!(a?a ; 2);\n-    barstar!(a?a?a ; 3);\n+    barplus!(+ ; 0);\n+    barplus!(a + ; 1);\n+    barstar!(* ; 0);\n+    barstar!(a * ; 1);\n }"}, {"sha": "63827ffeed045aed6a2fcc980a80ca610ef11e8c", "filename": "src/test/ui/macros/macro-at-most-once-rep-ambig.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b2ed17b5ea8d300838138844e3b2701cf000eae2/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ed17b5ea8d300838138844e3b2701cf000eae2/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs?ref=b2ed17b5ea8d300838138844e3b2701cf000eae2", "patch": "@@ -8,30 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// The logic for parsing Kleene operators in macros has a special case to disambiguate `?`.\n-// Specifically, `$(pat)?` is the ZeroOrOne operator whereas `$(pat)?+` or `$(pat)?*` are the\n-// ZeroOrMore and OneOrMore operators using `?` as a separator. These tests are intended to\n-// exercise that logic in the macro parser.\n-//\n-// Moreover, we also throw in some tests for using a separator with `?`, which is meaningless but\n-// included for consistency with `+` and `*`.\n-//\n-// This test focuses on error cases.\n+// Tests the behavior of various Kleene operators in macros with respect to `?` terminals. In\n+// particular, `?` in the position of a separator and of a Kleene operator is tested.\n \n #![feature(macro_at_most_once_rep)]\n \n+// should match `` and `a`\n macro_rules! foo {\n     ($(a)?) => {}\n }\n \n macro_rules! baz {\n-    ($(a),?) => {} // comma separator is meaningless for `?`\n+    ($(a),?) => {} //~ ERROR `?` macro repetition does not allow a separator\n }\n \n+// should match `+` and `a+`\n macro_rules! barplus {\n     ($(a)?+) => {}\n }\n \n+// should match `*` and `a*`\n macro_rules! barstar {\n     ($(a)?*) => {}\n }\n@@ -40,14 +36,14 @@ pub fn main() {\n     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n     foo!(a?a); //~ ERROR no rules expected the token `?`\n     foo!(a?); //~ ERROR no rules expected the token `?`\n-    baz!(a?a?a); //~ ERROR no rules expected the token `?`\n-    baz!(a?a); //~ ERROR no rules expected the token `?`\n-    baz!(a?); //~ ERROR no rules expected the token `?`\n-    baz!(a,); //~ ERROR unexpected end of macro invocation\n-    baz!(a?a?a,); //~ ERROR no rules expected the token `?`\n-    baz!(a?a,); //~ ERROR no rules expected the token `?`\n-    baz!(a?,); //~ ERROR no rules expected the token `?`\n     barplus!(); //~ ERROR unexpected end of macro invocation\n-    barplus!(a?); //~ ERROR unexpected end of macro invocation\n-    barstar!(a?); //~ ERROR unexpected end of macro invocation\n+    barstar!(); //~ ERROR unexpected end of macro invocation\n+    barplus!(a?); //~ ERROR no rules expected the token `?`\n+    barplus!(a); //~ ERROR unexpected end of macro invocation\n+    barstar!(a?); //~ ERROR no rules expected the token `?`\n+    barstar!(a); //~ ERROR unexpected end of macro invocation\n+    barplus!(+); // ok\n+    barstar!(*); // ok\n+    barplus!(a); // ok\n+    barstar!(a*); // ok\n }"}, {"sha": "eb355c70b559375c5efc5e1b810037f3d8898918", "filename": "src/test/ui/macros/macro-at-most-once-rep-ambig.stderr", "status": "modified", "additions": 27, "deletions": 45, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b2ed17b5ea8d300838138844e3b2701cf000eae2/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2ed17b5ea8d300838138844e3b2701cf000eae2/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr?ref=b2ed17b5ea8d300838138844e3b2701cf000eae2", "patch": "@@ -1,80 +1,62 @@\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:40:11\n+error: `?` macro repetition does not allow a separator\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:29:10\n    |\n-LL |     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:41:11\n-   |\n-LL |     foo!(a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:42:11\n-   |\n-LL |     foo!(a?); //~ ERROR no rules expected the token `?`\n-   |           ^\n+LL |     ($(a),?) => {} //~ ERROR `?` macro repetition does not allow a separator\n+   |          ^\n \n error: no rules expected the token `?`\n   --> $DIR/macro-at-most-once-rep-ambig.rs:43:11\n    |\n-LL |     baz!(a?a?a); //~ ERROR no rules expected the token `?`\n+LL |     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n    |           ^\n \n error: no rules expected the token `?`\n   --> $DIR/macro-at-most-once-rep-ambig.rs:44:11\n    |\n-LL |     baz!(a?a); //~ ERROR no rules expected the token `?`\n+LL |     foo!(a?a); //~ ERROR no rules expected the token `?`\n    |           ^\n \n error: no rules expected the token `?`\n   --> $DIR/macro-at-most-once-rep-ambig.rs:45:11\n    |\n-LL |     baz!(a?); //~ ERROR no rules expected the token `?`\n+LL |     foo!(a?); //~ ERROR no rules expected the token `?`\n    |           ^\n \n error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:46:11\n-   |\n-LL |     baz!(a,); //~ ERROR unexpected end of macro invocation\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:47:11\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:46:5\n    |\n-LL |     baz!(a?a?a,); //~ ERROR no rules expected the token `?`\n-   |           ^\n+LL |     barplus!(); //~ ERROR unexpected end of macro invocation\n+   |     ^^^^^^^^^^^\n \n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:48:11\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:47:5\n    |\n-LL |     baz!(a?a,); //~ ERROR no rules expected the token `?`\n-   |           ^\n+LL |     barstar!(); //~ ERROR unexpected end of macro invocation\n+   |     ^^^^^^^^^^^\n \n error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:49:11\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:48:15\n    |\n-LL |     baz!(a?,); //~ ERROR no rules expected the token `?`\n-   |           ^\n+LL |     barplus!(a?); //~ ERROR no rules expected the token `?`\n+   |               ^\n \n error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:50:5\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:49:14\n    |\n-LL |     barplus!(); //~ ERROR unexpected end of macro invocation\n-   |     ^^^^^^^^^^^\n+LL |     barplus!(a); //~ ERROR unexpected end of macro invocation\n+   |              ^\n \n-error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:51:15\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:50:15\n    |\n-LL |     barplus!(a?); //~ ERROR unexpected end of macro invocation\n+LL |     barstar!(a?); //~ ERROR no rules expected the token `?`\n    |               ^\n \n error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:52:15\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:51:14\n    |\n-LL |     barstar!(a?); //~ ERROR unexpected end of macro invocation\n-   |               ^\n+LL |     barstar!(a); //~ ERROR unexpected end of macro invocation\n+   |              ^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 10 previous errors\n "}]}