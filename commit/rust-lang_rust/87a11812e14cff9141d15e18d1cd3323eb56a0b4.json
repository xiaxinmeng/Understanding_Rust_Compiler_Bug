{"sha": "87a11812e14cff9141d15e18d1cd3323eb56a0b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YTExODEyZTE0Y2ZmOTE0MWQxNWUxOGQxY2QzMzIzZWI1NmEwYjQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-06-22T21:27:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-07T18:05:02Z"}, "message": "use the evaluation cache instead of the global fulfillment cache\n\nThe evaluation cache already exists, and it can handle differing\nparameter environments natively.\n\nFixes #39970.\nFixes #42796.", "tree": {"sha": "20abcc1e9b41317090c5f5d8bf3da972d4c4010d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20abcc1e9b41317090c5f5d8bf3da972d4c4010d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87a11812e14cff9141d15e18d1cd3323eb56a0b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87a11812e14cff9141d15e18d1cd3323eb56a0b4", "html_url": "https://github.com/rust-lang/rust/commit/87a11812e14cff9141d15e18d1cd3323eb56a0b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87a11812e14cff9141d15e18d1cd3323eb56a0b4/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16d1700337e87ab107e6bd08732f0a864c418aae", "url": "https://api.github.com/repos/rust-lang/rust/commits/16d1700337e87ab107e6bd08732f0a864c418aae", "html_url": "https://github.com/rust-lang/rust/commit/16d1700337e87ab107e6bd08732f0a864c418aae"}], "stats": {"total": 205, "additions": 99, "deletions": 106}, "files": [{"sha": "826d4a2815838bbb1c7ac9a059b91e50d3e08851", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 18, "deletions": 77, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=87a11812e14cff9141d15e18d1cd3323eb56a0b4", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::DepGraph;\n use infer::{InferCtxt, InferOk};\n-use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt, ToPredicate};\n+use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::marker::PhantomData;\n use syntax::ast;\n-use util::nodemap::{FxHashSet, NodeMap};\n+use util::nodemap::NodeMap;\n use hir::def_id::DefId;\n \n use super::CodeAmbiguity;\n@@ -34,11 +33,6 @@ impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     fn as_predicate(&self) -> &Self::Predicate { &self.obligation.predicate }\n }\n \n-pub struct GlobalFulfilledPredicates<'tcx> {\n-    set: FxHashSet<ty::PolyTraitPredicate<'tcx>>,\n-    dep_graph: DepGraph,\n-}\n-\n /// The fulfillment context is used to drive trait resolution.  It\n /// consists of a list of obligations that must be (eventually)\n /// satisfied. The job is to track which are satisfied, which yielded\n@@ -183,13 +177,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n         assert!(!infcx.is_in_snapshot());\n \n-        let tcx = infcx.tcx;\n-\n-        if tcx.fulfilled_predicates.borrow().check_duplicate(tcx, &obligation.predicate) {\n-            debug!(\"register_predicate_obligation: duplicate\");\n-            return\n-        }\n-\n         self.predicates.register_obligation(PendingPredicateObligation {\n             obligation,\n             stalled_on: vec![]\n@@ -264,13 +251,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             });\n             debug!(\"select: outcome={:?}\", outcome);\n \n-            // these are obligations that were proven to be true.\n-            for pending_obligation in outcome.completed {\n-                let predicate = &pending_obligation.obligation.predicate;\n-                selcx.tcx().fulfilled_predicates.borrow_mut()\n-                           .add_if_global(selcx.tcx(), predicate);\n-            }\n-\n             errors.extend(\n                 outcome.errors.into_iter()\n                               .map(|e| to_fulfillment_error(e)));\n@@ -375,21 +355,31 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n \n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n-            let tcx = selcx.tcx();\n-            if tcx.fulfilled_predicates.borrow().check_duplicate_trait(tcx, data) {\n-                return Ok(Some(vec![]));\n+            let trait_obligation = obligation.with(data.clone());\n+\n+            if data.is_global() {\n+                // no type variables present, can use evaluation for better caching.\n+                // FIXME: consider caching errors too.\n+                if\n+                    // make defaulted unit go through the slow path for better warnings,\n+                    // please remove this when the warnings are removed.\n+                    !trait_obligation.predicate.skip_binder().self_ty().is_defaulted_unit() &&\n+                    selcx.evaluate_obligation_conservatively(&obligation) {\n+                    debug!(\"selecting trait `{:?}` at depth {} evaluated to holds\",\n+                           data, obligation.recursion_depth);\n+                    return Ok(Some(vec![]))\n+                }\n             }\n \n-            let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n                 Ok(Some(vtable)) => {\n                     debug!(\"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n-                          data, obligation.recursion_depth);\n+                           data, obligation.recursion_depth);\n                     Ok(Some(vtable.nested_obligations()))\n                 }\n                 Ok(None) => {\n                     debug!(\"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n-                          data, obligation.recursion_depth);\n+                           data, obligation.recursion_depth);\n \n                     // This is a bit subtle: for the most part, the\n                     // only reason we can fail to make progress on\n@@ -568,55 +558,6 @@ fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n \n }\n \n-impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n-    pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'gcx> {\n-        GlobalFulfilledPredicates {\n-            set: FxHashSet(),\n-            dep_graph,\n-        }\n-    }\n-\n-    pub fn check_duplicate(&self, tcx: TyCtxt, key: &ty::Predicate<'tcx>) -> bool {\n-        if let ty::Predicate::Trait(ref data) = *key {\n-            self.check_duplicate_trait(tcx, data)\n-        } else {\n-            false\n-        }\n-    }\n-\n-    pub fn check_duplicate_trait(&self, tcx: TyCtxt, data: &ty::PolyTraitPredicate<'tcx>) -> bool {\n-        // For the global predicate registry, when we find a match, it\n-        // may have been computed by some other task, so we want to\n-        // add a read from the node corresponding to the predicate\n-        // processing to make sure we get the transitive dependencies.\n-        if self.set.contains(data) {\n-            debug_assert!(data.is_global());\n-            self.dep_graph.read(data.dep_node(tcx));\n-            debug!(\"check_duplicate: global predicate `{:?}` already proved elsewhere\", data);\n-\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn add_if_global(&mut self, tcx: TyCtxt<'a, 'gcx, 'tcx>, key: &ty::Predicate<'tcx>) {\n-        if let ty::Predicate::Trait(ref data) = *key {\n-            // We only add things to the global predicate registry\n-            // after the current task has proved them, and hence\n-            // already has the required read edges, so we don't need\n-            // to add any more edges here.\n-            if data.is_global() {\n-                if let Some(data) = tcx.lift_to_global(data) {\n-                    if self.set.insert(data.clone()) {\n-                        debug!(\"add_if_global: global predicate `{:?}` added\", data);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n fn to_fulfillment_error<'tcx>(\n     error: Error<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>>)\n     -> FulfillmentError<'tcx>"}, {"sha": "e14203b34a18072015a084ab97186a503cb4f593", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=87a11812e14cff9141d15e18d1cd3323eb56a0b4", "patch": "@@ -31,7 +31,7 @@ use syntax_pos::{Span, DUMMY_SP};\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n-pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n+pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};"}, {"sha": "bb46e8a8af127de2c5c751e1b7112866ee04ab89", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=87a11812e14cff9141d15e18d1cd3323eb56a0b4", "patch": "@@ -514,21 +514,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_predicate_recursively({:?})\",\n                obligation);\n \n-        let tcx = self.tcx();\n-\n-        // Check the cache from the tcx of predicates that we know\n-        // have been proven elsewhere. This cache only contains\n-        // predicates that are global in scope and hence unaffected by\n-        // the current environment.\n-        if tcx.fulfilled_predicates.borrow().check_duplicate(tcx, &obligation.predicate) {\n-            return EvaluatedToOk;\n-        }\n-\n         match obligation.predicate {\n             ty::Predicate::Trait(ref t) => {\n                 assert!(!t.has_escaping_regions());\n                 let obligation = obligation.with(t.clone());\n-                self.evaluate_obligation_recursively(previous_stack, &obligation)\n+                self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n             ty::Predicate::Equate(ref p) => {\n@@ -613,15 +603,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn evaluate_obligation_recursively<'o>(&mut self,\n-                                           previous_stack: TraitObligationStackList<'o, 'tcx>,\n-                                           obligation: &TraitObligation<'tcx>)\n-                                           -> EvaluationResult\n+    fn evaluate_trait_predicate_recursively<'o>(&mut self,\n+                                                previous_stack: TraitObligationStackList<'o, 'tcx>,\n+                                                mut obligation: TraitObligation<'tcx>)\n+                                                -> EvaluationResult\n     {\n-        debug!(\"evaluate_obligation_recursively({:?})\",\n+        debug!(\"evaluate_trait_predicate_recursively({:?})\",\n                obligation);\n \n-        let stack = self.push_stack(previous_stack, obligation);\n+        if !self.intercrate && obligation.is_global() {\n+            // If a param env is consistent, global obligations do not depend on its particular\n+            // value in order to work, so we can clear out the param env and get better\n+            // caching. (If the current param env is inconsistent, we don't care what happens).\n+            debug!(\"evaluate_trait_predicate_recursively({:?}) - in global\", obligation);\n+            obligation.param_env = ty::ParamEnv::empty(obligation.param_env.reveal);\n+        }\n+\n+        let stack = self.push_stack(previous_stack, &obligation);\n         let fresh_trait_ref = stack.fresh_trait_ref;\n         if let Some(result) = self.check_evaluation_cache(obligation.param_env, fresh_trait_ref) {\n             debug!(\"CACHE HIT: EVAL({:?})={:?}\",\n@@ -676,8 +674,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n         if unbound_input_types &&\n               stack.iter().skip(1).any(\n-                  |prev| self.match_fresh_trait_refs(&stack.fresh_trait_ref,\n-                                                     &prev.fresh_trait_ref))\n+                  |prev| stack.obligation.param_env == prev.obligation.param_env &&\n+                      self.match_fresh_trait_refs(&stack.fresh_trait_ref,\n+                                                  &prev.fresh_trait_ref))\n         {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, recursive --> giving up\",\n                    stack.fresh_trait_ref);\n@@ -706,7 +705,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         if let Some(rec_index) =\n             stack.iter()\n             .skip(1) // skip top-most frame\n-            .position(|prev| stack.fresh_trait_ref == prev.fresh_trait_ref)\n+            .position(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n+                      stack.fresh_trait_ref == prev.fresh_trait_ref)\n         {\n             debug!(\"evaluate_stack({:?}) --> recursive\",\n                    stack.fresh_trait_ref);"}, {"sha": "1f20993f96cfda71bee1e0064403575813df121b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=87a11812e14cff9141d15e18d1cd3323eb56a0b4", "patch": "@@ -507,12 +507,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Merge this with `selection_cache`?\n     pub evaluation_cache: traits::EvaluationCache<'tcx>,\n \n-    /// A set of predicates that have been fulfilled *somewhere*.\n-    /// This is used to avoid duplicate work. Predicates are only\n-    /// added to this set when they mention only \"global\" names\n-    /// (i.e., no type or lifetime parameters).\n-    pub fulfilled_predicates: RefCell<traits::GlobalFulfilledPredicates<'tcx>>,\n-\n     /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n     pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n \n@@ -686,7 +680,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let interners = CtxtInterners::new(arena);\n         let common_types = CommonTypes::new(&interners);\n         let dep_graph = hir.dep_graph.clone();\n-        let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n         let max_cnum = s.cstore.crates().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n         let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n         providers[LOCAL_CRATE] = local_providers;\n@@ -735,7 +728,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             named_region_map,\n             trait_map: resolutions.trait_map,\n             export_map: resolutions.export_map,\n-            fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             hir,\n             def_path_hash_to_def_id,\n             maps: maps::Maps::new(providers),"}, {"sha": "65ea1baa4a126e8885472cb3b8213b8b21609867", "filename": "src/test/compile-fail/issue-39970.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Ftest%2Fcompile-fail%2Fissue-39970.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Ftest%2Fcompile-fail%2Fissue-39970.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39970.rs?ref=87a11812e14cff9141d15e18d1cd3323eb56a0b4", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Array<'a> {\n+    type Element: 'a;\n+}\n+\n+trait Visit {\n+    fn visit() {}\n+}\n+\n+impl<'a> Array<'a> for () {\n+    type Element = &'a ();\n+}\n+\n+impl Visit for () where\n+    //(): for<'a> Array<'a, Element=&'a ()>, // No ICE\n+    (): for<'a> Array<'a, Element=()>, // ICE\n+{}\n+\n+fn main() {\n+    <() as Visit>::visit();\n+    //~^ ERROR type mismatch resolving `for<'a> <() as Array<'a>>::Element == ()`\n+}"}, {"sha": "10622eccbdcd19d9a47000d82a1661571bca80cb", "filename": "src/test/compile-fail/issue-42796.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Ftest%2Fcompile-fail%2Fissue-42796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a11812e14cff9141d15e18d1cd3323eb56a0b4/src%2Ftest%2Fcompile-fail%2Fissue-42796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-42796.rs?ref=87a11812e14cff9141d15e18d1cd3323eb56a0b4", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Mirror<Smoke> {\n+    type Image;\n+}\n+\n+impl<T, Smoke> Mirror<Smoke> for T {\n+    type Image = T;\n+}\n+\n+pub fn poison<S>(victim: String) where <String as Mirror<S>>::Image: Copy {\n+    loop { drop(victim); } //~ ERROR use of moved value\n+}\n+\n+fn main() {\n+    let s = \"Hello!\".to_owned();\n+    let mut s_copy = s;\n+    s_copy.push_str(\"World!\");\n+    \"0wned!\".to_owned();\n+    println!(\"{}\", s); //~ ERROR use of moved value\n+}"}]}