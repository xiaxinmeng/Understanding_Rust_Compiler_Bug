{"sha": "fa281fdf65f63da72abfef83abeb8bea37fddfd9", "node_id": "C_kwDOAAsO6NoAKGZhMjgxZmRmNjVmNjNkYTcyYWJmZWY4M2FiZWI4YmVhMzdmZGRmZDk", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-15T18:50:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-15T18:50:52Z"}, "message": "Rollup merge of #96065 - TaKO8Ki:use-`format-args-capture`-and-remove-unnecessary-nested-blocks, r=compiler-errors\n\nRefactor: Use `format-args-capture` and remove unnecessary nested blocks in rustc_typeck", "tree": {"sha": "bd7084e37d615bb22152fce22c7c9328f5316c4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd7084e37d615bb22152fce22c7c9328f5316c4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa281fdf65f63da72abfef83abeb8bea37fddfd9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiWb6MCRBK7hj4Ov3rIwAA51oIADChqMw15gEcyhMXCQ9lWitT\niCMh87Q7ZKkysfAogTy6MmUawAzht29wfba/hDCym5HVlo3mIrqIFTMqtvW3DxwG\npj9VmDrOYE5KAN/mboLeKy5AfunwKOhtw6pLozR1hbk6a4qF2lywjU4dOPcr2YLK\nfu85EfVrYpLK0ASFoxWQhKi4rUo6dRQocd6pJkl0RHgodI6RPN+F1lIfGoiII11+\nBP477G9shHw9zFwLxrvDBYO3isEZf4aHKRcxJZ2rz5uo/4o3Ynx4Lw+AUZk8mvJG\nxzPneaxkVEvyNkIzphTjl14iSzkbZqpLMCdjQEy3SptpDkz8LHALPI5TfaYSylQ=\n=QQ2b\n-----END PGP SIGNATURE-----\n", "payload": "tree bd7084e37d615bb22152fce22c7c9328f5316c4f\nparent 18a7ce32b68bf9e3ed3f7f516ed254a5e86a7851\nparent f9188ccef6d7754ccc4d48ce1ecca1af1d7270c9\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1650048652 +0200\ncommitter GitHub <noreply@github.com> 1650048652 +0200\n\nRollup merge of #96065 - TaKO8Ki:use-`format-args-capture`-and-remove-unnecessary-nested-blocks, r=compiler-errors\n\nRefactor: Use `format-args-capture` and remove unnecessary nested blocks in rustc_typeck\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa281fdf65f63da72abfef83abeb8bea37fddfd9", "html_url": "https://github.com/rust-lang/rust/commit/fa281fdf65f63da72abfef83abeb8bea37fddfd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa281fdf65f63da72abfef83abeb8bea37fddfd9/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18a7ce32b68bf9e3ed3f7f516ed254a5e86a7851", "url": "https://api.github.com/repos/rust-lang/rust/commits/18a7ce32b68bf9e3ed3f7f516ed254a5e86a7851", "html_url": "https://github.com/rust-lang/rust/commit/18a7ce32b68bf9e3ed3f7f516ed254a5e86a7851"}, {"sha": "f9188ccef6d7754ccc4d48ce1ecca1af1d7270c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9188ccef6d7754ccc4d48ce1ecca1af1d7270c9", "html_url": "https://github.com/rust-lang/rust/commit/f9188ccef6d7754ccc4d48ce1ecca1af1d7270c9"}], "stats": {"total": 1281, "additions": 605, "deletions": 676}, "files": [{"sha": "1c7e7c935c4a1c4ee378394a29ab4dbf8239681a", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -260,10 +260,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             &mut |err| {\n                 if let Some((span, msg)) = &ret_reason {\n                     err.span_label(*span, msg.as_str());\n-                } else if let ExprKind::Block(block, _) = &then_expr.kind {\n-                    if let Some(expr) = &block.expr {\n-                        err.span_label(expr.span, \"found here\".to_string());\n-                    }\n+                } else if let ExprKind::Block(block, _) = &then_expr.kind\n+                    && let Some(expr) = &block.expr\n+                {\n+                    err.span_label(expr.span, \"found here\".to_string());\n                 }\n                 err.note(\"`if` expressions without `else` evaluate to `()`\");\n                 err.help(\"consider adding an `else` block that evaluates to the expected type\");\n@@ -293,7 +293,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     return self.get_fn_decl(hir_id).and_then(|(fn_decl, _)| {\n                         let span = fn_decl.output.span();\n                         let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok()?;\n-                        Some((span, format!(\"expected `{}` because of this return type\", snippet)))\n+                        Some((span, format!(\"expected `{snippet}` because of this return type\")))\n                     });\n                 }\n             }"}, {"sha": "580fb7c3e0f063b289179fd5668d50bbda393d74", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -43,7 +43,7 @@ pub fn check_legal_trait_for_method_call(\n         let (sp, suggestion) = receiver\n             .and_then(|s| tcx.sess.source_map().span_to_snippet(s).ok())\n             .filter(|snippet| !snippet.is_empty())\n-            .map(|snippet| (expr_span, format!(\"drop({})\", snippet)))\n+            .map(|snippet| (expr_span, format!(\"drop({snippet})\")))\n             .unwrap_or_else(|| (span, \"drop\".to_string()));\n \n         err.span_suggestion(\n@@ -315,17 +315,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             hir::ExprKind::Tup(exp),\n             hir::ExprKind::Call(_, args),\n         ) = (parent_node, &callee_expr.kind, &call_expr.kind)\n+            && args.len() == exp.len()\n         {\n-            if args.len() == exp.len() {\n-                let start = callee_expr.span.shrink_to_hi();\n-                err.span_suggestion(\n-                    start,\n-                    \"consider separating array elements with a comma\",\n-                    \",\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                return true;\n-            }\n+            let start = callee_expr.span.shrink_to_hi();\n+            err.span_suggestion(\n+                start,\n+                \"consider separating array elements with a comma\",\n+                \",\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+            return true;\n         }\n         false\n     }\n@@ -373,15 +372,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ref t => {\n                 let mut unit_variant = None;\n                 let mut removal_span = call_expr.span;\n-                if let ty::Adt(adt_def, ..) = t {\n-                    if adt_def.is_enum() {\n-                        if let hir::ExprKind::Call(expr, _) = call_expr.kind {\n-                            removal_span =\n-                                expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n-                            unit_variant =\n-                                self.tcx.sess.source_map().span_to_snippet(expr.span).ok();\n-                        }\n-                    }\n+                if let ty::Adt(adt_def, ..) = t\n+                    && adt_def.is_enum()\n+                    && let hir::ExprKind::Call(expr, _) = call_expr.kind\n+                {\n+                    removal_span =\n+                        expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n+                    unit_variant =\n+                        self.tcx.sess.source_map().span_to_snippet(expr.span).ok();\n                 }\n \n                 let callee_ty = self.resolve_vars_if_possible(callee_ty);\n@@ -392,8 +390,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     E0618,\n                     \"expected function, found {}\",\n                     match unit_variant {\n-                        Some(ref path) => format!(\"enum variant `{}`\", path),\n-                        None => format!(\"`{}`\", callee_ty),\n+                        Some(ref path) => format!(\"enum variant `{path}`\"),\n+                        None => format!(\"`{callee_ty}`\"),\n                     }\n                 );\n \n@@ -408,8 +406,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_suggestion_verbose(\n                         removal_span,\n                         &format!(\n-                            \"`{}` is a unit variant, you need to write it without the parentheses\",\n-                            path\n+                            \"`{path}` is a unit variant, you need to write it without the parentheses\",\n                         ),\n                         String::new(),\n                         Applicability::MachineApplicable,\n@@ -452,14 +449,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let Some(span) = self.tcx.hir().res_span(def) {\n                     let callee_ty = callee_ty.to_string();\n                     let label = match (unit_variant, inner_callee_path) {\n-                        (Some(path), _) => Some(format!(\"`{}` defined here\", path)),\n+                        (Some(path), _) => Some(format!(\"`{path}` defined here\")),\n                         (_, Some(hir::QPath::Resolved(_, path))) => self\n                             .tcx\n                             .sess\n                             .source_map()\n                             .span_to_snippet(path.span)\n                             .ok()\n-                            .map(|p| format!(\"`{}` defined here returns `{}`\", p, callee_ty)),\n+                            .map(|p| format!(\"`{p}` defined here returns `{callee_ty}`\")),\n                         _ => {\n                             match def {\n                                 // Emit a different diagnostic for local variables, as they are not\n@@ -475,7 +472,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         self.tcx.def_path_str(def_id),\n                                     ))\n                                 }\n-                                _ => Some(format!(\"`{}` defined here\", callee_ty)),\n+                                _ => Some(format!(\"`{callee_ty}` defined here\")),\n                             }\n                         }\n                     };"}, {"sha": "049940d19a651b3622f278c0b829c3097abe27c2", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 70, "deletions": 76, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                             err.span_suggestion(\n                                 self.span,\n                                 \"compare with zero instead\",\n-                                format!(\"{} != 0\", snippet),\n+                                format!(\"{snippet} != 0\"),\n                                 Applicability::MachineApplicable,\n                             );\n                         }\n@@ -373,8 +373,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 let mut sugg = None;\n                 let mut sugg_mutref = false;\n                 if let ty::Ref(reg, cast_ty, mutbl) = *self.cast_ty.kind() {\n-                    if let ty::RawPtr(TypeAndMut { ty: expr_ty, .. }) = *self.expr_ty.kind() {\n-                        if fcx\n+                    if let ty::RawPtr(TypeAndMut { ty: expr_ty, .. }) = *self.expr_ty.kind()\n+                        && fcx\n                             .try_coerce(\n                                 self.expr,\n                                 fcx.tcx.mk_ref(\n@@ -386,27 +386,25 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                                 None,\n                             )\n                             .is_ok()\n-                        {\n-                            sugg = Some((format!(\"&{}*\", mutbl.prefix_str()), cast_ty == expr_ty));\n-                        }\n-                    } else if let ty::Ref(expr_reg, expr_ty, expr_mutbl) = *self.expr_ty.kind() {\n-                        if expr_mutbl == Mutability::Not\n-                            && mutbl == Mutability::Mut\n-                            && fcx\n-                                .try_coerce(\n-                                    self.expr,\n-                                    fcx.tcx.mk_ref(\n-                                        expr_reg,\n-                                        TypeAndMut { ty: expr_ty, mutbl: Mutability::Mut },\n-                                    ),\n-                                    self.cast_ty,\n-                                    AllowTwoPhase::No,\n-                                    None,\n-                                )\n-                                .is_ok()\n-                        {\n-                            sugg_mutref = true;\n-                        }\n+                    {\n+                        sugg = Some((format!(\"&{}*\", mutbl.prefix_str()), cast_ty == expr_ty));\n+                    } else if let ty::Ref(expr_reg, expr_ty, expr_mutbl) = *self.expr_ty.kind()\n+                        && expr_mutbl == Mutability::Not\n+                        && mutbl == Mutability::Mut\n+                        && fcx\n+                            .try_coerce(\n+                                self.expr,\n+                                fcx.tcx.mk_ref(\n+                                    expr_reg,\n+                                    TypeAndMut { ty: expr_ty, mutbl: Mutability::Mut },\n+                                ),\n+                                self.cast_ty,\n+                                AllowTwoPhase::No,\n+                                None,\n+                            )\n+                            .is_ok()\n+                    {\n+                        sugg_mutref = true;\n                     }\n \n                     if !sugg_mutref\n@@ -423,8 +421,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     {\n                         sugg = Some((format!(\"&{}\", mutbl.prefix_str()), false));\n                     }\n-                } else if let ty::RawPtr(TypeAndMut { mutbl, .. }) = *self.cast_ty.kind() {\n-                    if fcx\n+                } else if let ty::RawPtr(TypeAndMut { mutbl, .. }) = *self.cast_ty.kind()\n+                    && fcx\n                         .try_coerce(\n                             self.expr,\n                             fcx.tcx.mk_ref(\n@@ -436,9 +434,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                             None,\n                         )\n                         .is_ok()\n-                    {\n-                        sugg = Some((format!(\"&{}\", mutbl.prefix_str()), false));\n-                    }\n+                {\n+                    sugg = Some((format!(\"&{}\", mutbl.prefix_str()), false));\n                 }\n                 if sugg_mutref {\n                     err.span_label(self.span, \"invalid cast\");\n@@ -483,28 +480,28 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 ) {\n                     let mut label = true;\n                     // Check `impl From<self.expr_ty> for self.cast_ty {}` for accurate suggestion:\n-                    if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr_span) {\n-                        if let Some(from_trait) = fcx.tcx.get_diagnostic_item(sym::From) {\n-                            let ty = fcx.resolve_vars_if_possible(self.cast_ty);\n-                            // Erase regions to avoid panic in `prove_value` when calling\n-                            // `type_implements_trait`.\n-                            let ty = fcx.tcx.erase_regions(ty);\n-                            let expr_ty = fcx.resolve_vars_if_possible(self.expr_ty);\n-                            let expr_ty = fcx.tcx.erase_regions(expr_ty);\n-                            let ty_params = fcx.tcx.mk_substs_trait(expr_ty, &[]);\n-                            if fcx\n-                                .infcx\n-                                .type_implements_trait(from_trait, ty, ty_params, fcx.param_env)\n-                                .must_apply_modulo_regions()\n-                            {\n-                                label = false;\n-                                err.span_suggestion(\n-                                    self.span,\n-                                    \"consider using the `From` trait instead\",\n-                                    format!(\"{}::from({})\", self.cast_ty, snippet),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n+                    if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr_span)\n+                        && let Some(from_trait) = fcx.tcx.get_diagnostic_item(sym::From)\n+                    {\n+                        let ty = fcx.resolve_vars_if_possible(self.cast_ty);\n+                        // Erase regions to avoid panic in `prove_value` when calling\n+                        // `type_implements_trait`.\n+                        let ty = fcx.tcx.erase_regions(ty);\n+                        let expr_ty = fcx.resolve_vars_if_possible(self.expr_ty);\n+                        let expr_ty = fcx.tcx.erase_regions(expr_ty);\n+                        let ty_params = fcx.tcx.mk_substs_trait(expr_ty, &[]);\n+                        if fcx\n+                            .infcx\n+                            .type_implements_trait(from_trait, ty, ty_params, fcx.param_env)\n+                            .must_apply_modulo_regions()\n+                        {\n+                            label = false;\n+                            err.span_suggestion(\n+                                self.span,\n+                                \"consider using the `From` trait instead\",\n+                                format!(\"{}::from({})\", self.cast_ty, snippet),\n+                                Applicability::MaybeIncorrect,\n+                            );\n                         }\n                     }\n                     let msg = \"an `as` expression can only be used to convert between primitive \\\n@@ -627,10 +624,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         }\n                     }\n                 } else {\n-                    let msg = &format!(\n-                        \"consider using an implicit coercion to `&{}{}` instead\",\n-                        mtstr, tstr\n-                    );\n+                    let msg =\n+                        &format!(\"consider using an implicit coercion to `&{mtstr}{tstr}` instead\");\n                     err.span_help(self.span, msg);\n                 }\n             }\n@@ -640,14 +635,14 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         err.span_suggestion(\n                             self.cast_span,\n                             \"you can cast to a `Box` instead\",\n-                            format!(\"Box<{}>\", s),\n+                            format!(\"Box<{s}>\"),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n                     Err(_) => {\n                         err.span_help(\n                             self.cast_span,\n-                            &format!(\"you might have meant `Box<{}>`\", tstr),\n+                            &format!(\"you might have meant `Box<{tstr}>`\"),\n                         );\n                     }\n                 }\n@@ -678,8 +673,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             ))\n             .help(&format!(\n                 \"cast can be replaced by coercion; this might \\\n-                                   require {}a temporary variable\",\n-                type_asc_or\n+                                   require {type_asc_or}a temporary variable\"\n             ))\n             .emit();\n         });\n@@ -969,21 +963,21 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn cenum_impl_drop_lint(&self, fcx: &FnCtxt<'a, 'tcx>) {\n-        if let ty::Adt(d, _) = self.expr_ty.kind() {\n-            if d.has_dtor(fcx.tcx) {\n-                fcx.tcx.struct_span_lint_hir(\n-                    lint::builtin::CENUM_IMPL_DROP_CAST,\n-                    self.expr.hir_id,\n-                    self.span,\n-                    |err| {\n-                        err.build(&format!(\n-                            \"cannot cast enum `{}` into integer `{}` because it implements `Drop`\",\n-                            self.expr_ty, self.cast_ty\n-                        ))\n-                        .emit();\n-                    },\n-                );\n-            }\n+        if let ty::Adt(d, _) = self.expr_ty.kind()\n+            && d.has_dtor(fcx.tcx)\n+        {\n+            fcx.tcx.struct_span_lint_hir(\n+                lint::builtin::CENUM_IMPL_DROP_CAST,\n+                self.expr.hir_id,\n+                self.span,\n+                |err| {\n+                    err.build(&format!(\n+                        \"cannot cast enum `{}` into integer `{}` because it implements `Drop`\",\n+                        self.expr_ty, self.cast_ty\n+                    ))\n+                    .emit();\n+                },\n+            );\n         }\n     }\n \n@@ -1007,7 +1001,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     err.span_suggestion(\n                         self.span,\n                         msg,\n-                        format!(\"({}).addr(){}\", snippet, scalar_cast),\n+                        format!(\"({snippet}).addr(){scalar_cast}\"),\n                         Applicability::MaybeIncorrect\n                     );\n                 } else {\n@@ -1038,7 +1032,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     err.span_suggestion(\n                         self.span,\n                         msg,\n-                        format!(\"(...).with_addr({})\", snippet),\n+                        format!(\"(...).with_addr({snippet})\"),\n                         Applicability::HasPlaceholders,\n                     );\n                 } else {"}, {"sha": "314236b1cdfbcbeec787166b1aac931aee4b9c5b", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 153, "deletions": 157, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -43,8 +43,7 @@ pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Ab\n                 tcx.sess,\n                 span,\n                 E0570,\n-                \"`{}` is not a supported ABI for the current target\",\n-                abi\n+                \"`{abi}` is not a supported ABI for the current target\",\n             )\n             .emit();\n         }\n@@ -249,84 +248,84 @@ pub(super) fn check_fn<'a, 'tcx>(\n     fcx.demand_suptype(span, declared_ret_ty, actual_return_ty);\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n-    if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n-        if panic_impl_did == hir.local_def_id(fn_id).to_def_id() {\n-            if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n-                if *declared_ret_ty.kind() != ty::Never {\n-                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n-                }\n+    if let Some(panic_impl_did) = tcx.lang_items().panic_impl()\n+        && panic_impl_did == hir.local_def_id(fn_id).to_def_id()\n+    {\n+        if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n+            if *declared_ret_ty.kind() != ty::Never {\n+                sess.span_err(decl.output.span(), \"return type should be `!`\");\n+            }\n \n-                let inputs = fn_sig.inputs();\n-                let span = hir.span(fn_id);\n-                if inputs.len() == 1 {\n-                    let arg_is_panic_info = match *inputs[0].kind() {\n-                        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n-                            ty::Adt(ref adt, _) => {\n-                                adt.did() == panic_info_did\n-                                    && mutbl == hir::Mutability::Not\n-                                    && !region.is_static()\n-                            }\n-                            _ => false,\n-                        },\n+            let inputs = fn_sig.inputs();\n+            let span = hir.span(fn_id);\n+            if inputs.len() == 1 {\n+                let arg_is_panic_info = match *inputs[0].kind() {\n+                    ty::Ref(region, ty, mutbl) => match *ty.kind() {\n+                        ty::Adt(ref adt, _) => {\n+                            adt.did() == panic_info_did\n+                                && mutbl == hir::Mutability::Not\n+                                && !region.is_static()\n+                        }\n                         _ => false,\n-                    };\n-\n-                    if !arg_is_panic_info {\n-                        sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n-                    }\n+                    },\n+                    _ => false,\n+                };\n \n-                    if let Node::Item(item) = hir.get(fn_id)\n-                        && let ItemKind::Fn(_, ref generics, _) = item.kind\n-                        && !generics.params.is_empty()\n-                    {\n-                                sess.span_err(span, \"should have no type parameters\");\n-                            }\n-                } else {\n-                    let span = sess.source_map().guess_head_span(span);\n-                    sess.span_err(span, \"function should have one argument\");\n+                if !arg_is_panic_info {\n+                    sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n                 }\n+\n+                if let Node::Item(item) = hir.get(fn_id)\n+                    && let ItemKind::Fn(_, ref generics, _) = item.kind\n+                    && !generics.params.is_empty()\n+                {\n+                            sess.span_err(span, \"should have no type parameters\");\n+                        }\n             } else {\n-                sess.err(\"language item required, but not found: `panic_info`\");\n+                let span = sess.source_map().guess_head_span(span);\n+                sess.span_err(span, \"function should have one argument\");\n             }\n+        } else {\n+            sess.err(\"language item required, but not found: `panic_info`\");\n         }\n     }\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n-    if let Some(alloc_error_handler_did) = tcx.lang_items().oom() {\n-        if alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id() {\n-            if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n-                if *declared_ret_ty.kind() != ty::Never {\n-                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n-                }\n-\n-                let inputs = fn_sig.inputs();\n-                let span = hir.span(fn_id);\n-                if inputs.len() == 1 {\n-                    let arg_is_alloc_layout = match inputs[0].kind() {\n-                        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n-                        _ => false,\n-                    };\n+    if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n+        && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n+    {\n+        if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n+            if *declared_ret_ty.kind() != ty::Never {\n+                sess.span_err(decl.output.span(), \"return type should be `!`\");\n+            }\n \n-                    if !arg_is_alloc_layout {\n-                        sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n-                    }\n+            let inputs = fn_sig.inputs();\n+            let span = hir.span(fn_id);\n+            if inputs.len() == 1 {\n+                let arg_is_alloc_layout = match inputs[0].kind() {\n+                    ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n+                    _ => false,\n+                };\n \n-                    if let Node::Item(item) = hir.get(fn_id)\n-                        && let ItemKind::Fn(_, ref generics, _) = item.kind\n-                        && !generics.params.is_empty()\n-                    {\n-                                sess.span_err(\n-                                    span,\n-                            \"`#[alloc_error_handler]` function should have no type parameters\",\n-                                );\n-                            }\n-                } else {\n-                    let span = sess.source_map().guess_head_span(span);\n-                    sess.span_err(span, \"function should have one argument\");\n+                if !arg_is_alloc_layout {\n+                    sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n                 }\n+\n+                if let Node::Item(item) = hir.get(fn_id)\n+                    && let ItemKind::Fn(_, ref generics, _) = item.kind\n+                    && !generics.params.is_empty()\n+                {\n+                            sess.span_err(\n+                                span,\n+                        \"`#[alloc_error_handler]` function should have no type parameters\",\n+                            );\n+                        }\n             } else {\n-                sess.err(\"language item required, but not found: `alloc_layout`\");\n+                let span = sess.source_map().guess_head_span(span);\n+                sess.span_err(span, \"function should have one argument\");\n             }\n+        } else {\n+            sess.err(\"language item required, but not found: `alloc_layout`\");\n         }\n     }\n \n@@ -670,7 +669,7 @@ fn check_opaque_meets_bounds<'tcx>(\n             Err(ty_err) => {\n                 tcx.sess.delay_span_bug(\n                     span,\n-                    &format!(\"could not unify `{}` with revealed type:\\n{}\", hidden_type, ty_err,),\n+                    &format!(\"could not unify `{hidden_type}` with revealed type:\\n{ty_err}\"),\n                 );\n             }\n         }\n@@ -817,10 +816,9 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                             tcx.sess,\n                             item.span,\n                             E0044,\n-                            \"foreign items may not have {} parameters\",\n-                            kinds,\n+                            \"foreign items may not have {kinds} parameters\",\n                         )\n-                        .span_label(item.span, &format!(\"can't have {} parameters\", kinds))\n+                        .span_label(item.span, &format!(\"can't have {kinds} parameters\"))\n                         .help(\n                             // FIXME: once we start storing spans for type arguments, turn this\n                             // into a suggestion.\n@@ -1065,68 +1063,67 @@ pub(super) fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalD\n \n pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n     let t = tcx.type_of(def_id);\n-    if let ty::Adt(def, substs) = t.kind() {\n-        if def.is_struct() {\n-            let fields = &def.non_enum_variant().fields;\n-            if fields.is_empty() {\n+    if let ty::Adt(def, substs) = t.kind()\n+        && def.is_struct()\n+    {\n+        let fields = &def.non_enum_variant().fields;\n+        if fields.is_empty() {\n+            struct_span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\").emit();\n+            return;\n+        }\n+        let e = fields[0].ty(tcx, substs);\n+        if !fields.iter().all(|f| f.ty(tcx, substs) == e) {\n+            struct_span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\")\n+                .span_label(sp, \"SIMD elements must have the same type\")\n+                .emit();\n+            return;\n+        }\n+\n+        let len = if let ty::Array(_ty, c) = e.kind() {\n+            c.try_eval_usize(tcx, tcx.param_env(def.did()))\n+        } else {\n+            Some(fields.len() as u64)\n+        };\n+        if let Some(len) = len {\n+            if len == 0 {\n                 struct_span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\").emit();\n                 return;\n-            }\n-            let e = fields[0].ty(tcx, substs);\n-            if !fields.iter().all(|f| f.ty(tcx, substs) == e) {\n-                struct_span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\")\n-                    .span_label(sp, \"SIMD elements must have the same type\")\n-                    .emit();\n+            } else if len > MAX_SIMD_LANES {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    sp,\n+                    E0075,\n+                    \"SIMD vector cannot have more than {MAX_SIMD_LANES} elements\",\n+                )\n+                .emit();\n                 return;\n             }\n+        }\n \n-            let len = if let ty::Array(_ty, c) = e.kind() {\n-                c.try_eval_usize(tcx, tcx.param_env(def.did()))\n-            } else {\n-                Some(fields.len() as u64)\n-            };\n-            if let Some(len) = len {\n-                if len == 0 {\n-                    struct_span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\").emit();\n-                    return;\n-                } else if len > MAX_SIMD_LANES {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        sp,\n-                        E0075,\n-                        \"SIMD vector cannot have more than {} elements\",\n-                        MAX_SIMD_LANES,\n-                    )\n-                    .emit();\n-                    return;\n-                }\n-            }\n-\n-            // Check that we use types valid for use in the lanes of a SIMD \"vector register\"\n-            // These are scalar types which directly match a \"machine\" type\n-            // Yes: Integers, floats, \"thin\" pointers\n-            // No: char, \"fat\" pointers, compound types\n-            match e.kind() {\n-                ty::Param(_) => (), // pass struct<T>(T, T, T, T) through, let monomorphization catch errors\n-                ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::RawPtr(_) => (), // struct(u8, u8, u8, u8) is ok\n-                ty::Array(t, _) if matches!(t.kind(), ty::Param(_)) => (), // pass struct<T>([T; N]) through, let monomorphization catch errors\n-                ty::Array(t, _clen)\n-                    if matches!(\n-                        t.kind(),\n-                        ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::RawPtr(_)\n-                    ) =>\n-                { /* struct([f32; 4]) is ok */ }\n-                _ => {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        sp,\n-                        E0077,\n-                        \"SIMD vector element type should be a \\\n-                         primitive scalar (integer/float/pointer) type\"\n-                    )\n-                    .emit();\n-                    return;\n-                }\n+        // Check that we use types valid for use in the lanes of a SIMD \"vector register\"\n+        // These are scalar types which directly match a \"machine\" type\n+        // Yes: Integers, floats, \"thin\" pointers\n+        // No: char, \"fat\" pointers, compound types\n+        match e.kind() {\n+            ty::Param(_) => (), // pass struct<T>(T, T, T, T) through, let monomorphization catch errors\n+            ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::RawPtr(_) => (), // struct(u8, u8, u8, u8) is ok\n+            ty::Array(t, _) if matches!(t.kind(), ty::Param(_)) => (), // pass struct<T>([T; N]) through, let monomorphization catch errors\n+            ty::Array(t, _clen)\n+                if matches!(\n+                    t.kind(),\n+                    ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::RawPtr(_)\n+                ) =>\n+            { /* struct([f32; 4]) is ok */ }\n+            _ => {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    sp,\n+                    E0077,\n+                    \"SIMD vector element type should be a \\\n+                        primitive scalar (integer/float/pointer) type\"\n+                )\n+                .emit();\n+                return;\n             }\n         }\n     }\n@@ -1189,7 +1186,7 @@ pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: ty::AdtDef<'_>) {\n                                     ident\n                                 )\n                             } else {\n-                                format!(\"...which contains a field of type `{}`\", ident)\n+                                format!(\"...which contains a field of type `{ident}`\")\n                             },\n                         );\n                         first = false;\n@@ -1215,13 +1212,12 @@ pub(super) fn check_packed_inner(\n \n             stack.push(def_id);\n             for field in &def.non_enum_variant().fields {\n-                if let ty::Adt(def, _) = field.ty(tcx, substs).kind() {\n-                    if !stack.contains(&def.did()) {\n-                        if let Some(mut defs) = check_packed_inner(tcx, def.did(), stack) {\n-                            defs.push((def.did(), field.ident(tcx).span));\n-                            return Some(defs);\n-                        }\n-                    }\n+                if let ty::Adt(def, _) = field.ty(tcx, substs).kind()\n+                    && !stack.contains(&def.did())\n+                    && let Some(mut defs) = check_packed_inner(tcx, def.did(), stack)\n+                {\n+                    defs.push((def.did(), field.ident(tcx).span));\n+                    return Some(defs);\n                 }\n             }\n             stack.pop();\n@@ -1370,8 +1366,8 @@ fn check_enum<'tcx>(\n                 \"discriminant value `{}` already exists\",\n                 discr.val,\n             )\n-            .span_label(i_span, format!(\"first use of {}\", display_discr_i))\n-            .span_label(span, format!(\"enum already has {}\", display_discr))\n+            .span_label(i_span, format!(\"first use of {display_discr_i}\"))\n+            .span_label(span, format!(\"enum already has {display_discr}\"))\n             .emit();\n         }\n         disr_vals.push(discr);\n@@ -1393,7 +1389,7 @@ fn display_discriminant_value<'tcx>(\n             && let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node\n             && evaluated != *lit_value\n         {\n-                    return format!(\"`{}` (overflowed from `{}`)\", evaluated, lit_value);\n+                    return format!(\"`{evaluated}` (overflowed from `{lit_value}`)\");\n         }\n     }\n     format!(\"`{}`\", evaluated)\n@@ -1422,28 +1418,28 @@ pub(super) fn check_type_params_are_used<'tcx>(\n     }\n \n     for leaf in ty.walk() {\n-        if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n-            if let ty::Param(param) = leaf_ty.kind() {\n-                debug!(\"found use of ty param {:?}\", param);\n-                params_used.insert(param.index);\n-            }\n+        if let GenericArgKind::Type(leaf_ty) = leaf.unpack()\n+            && let ty::Param(param) = leaf_ty.kind()\n+        {\n+            debug!(\"found use of ty param {:?}\", param);\n+            params_used.insert(param.index);\n         }\n     }\n \n     for param in &generics.params {\n-        if !params_used.contains(param.index) {\n-            if let ty::GenericParamDefKind::Type { .. } = param.kind {\n-                let span = tcx.def_span(param.def_id);\n-                struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0091,\n-                    \"type parameter `{}` is unused\",\n-                    param.name,\n-                )\n-                .span_label(span, \"unused type parameter\")\n-                .emit();\n-            }\n+        if !params_used.contains(param.index)\n+            && let ty::GenericParamDefKind::Type { .. } = param.kind\n+        {\n+            let span = tcx.def_span(param.def_id);\n+            struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0091,\n+                \"type parameter `{}` is unused\",\n+                param.name,\n+            )\n+            .span_label(span, \"unused type parameter\")\n+            .emit();\n         }\n     }\n }\n@@ -1534,10 +1530,10 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> E\n                 for def_id in visitor.0 {\n                     let ty_span = tcx.def_span(def_id);\n                     if !seen.contains(&ty_span) {\n-                        err.span_label(ty_span, &format!(\"returning this opaque type `{}`\", ty));\n+                        err.span_label(ty_span, &format!(\"returning this opaque type `{ty}`\"));\n                         seen.insert(ty_span);\n                     }\n-                    err.span_label(sp, &format!(\"returning here with type `{}`\", ty));\n+                    err.span_label(sp, &format!(\"returning here with type `{ty}`\"));\n                 }\n             }\n         }"}, {"sha": "3162de38aaea1ca7e0afca8911d43373d1522eb4", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 39, "deletions": 44, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -632,11 +632,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                         let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();\n                         if let (ty::Dynamic(ref data_a, ..), ty::Dynamic(ref data_b, ..)) =\n                             (self_ty.kind(), unsize_ty.kind())\n+                            && data_a.principal_def_id() != data_b.principal_def_id()\n                         {\n-                            if data_a.principal_def_id() != data_b.principal_def_id() {\n-                                debug!(\"coerce_unsized: found trait upcasting coercion\");\n-                                has_trait_upcasting_coercion = true;\n-                            }\n+                            debug!(\"coerce_unsized: found trait upcasting coercion\");\n+                            has_trait_upcasting_coercion = true;\n                         }\n                         if let ty::Tuple(..) = unsize_ty.kind() {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n@@ -732,13 +731,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n         G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n     {\n-        if let ty::FnPtr(fn_ty_b) = b.kind() {\n-            if let (hir::Unsafety::Normal, hir::Unsafety::Unsafe) =\n+        if let ty::FnPtr(fn_ty_b) = b.kind()\n+            && let (hir::Unsafety::Normal, hir::Unsafety::Unsafe) =\n                 (fn_ty_a.unsafety(), fn_ty_b.unsafety())\n-            {\n-                let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n-                return self.unify_and(unsafe_a, b, to_unsafe);\n-            }\n+        {\n+            let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n+            return self.unify_and(unsafe_a, b, to_unsafe);\n         }\n         self.unify_and(a, b, normal)\n     }\n@@ -783,12 +781,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 }\n \n                 // Safe `#[target_feature]` functions are not assignable to safe fn pointers (RFC 2396).\n-                if let ty::FnDef(def_id, _) = *a.kind() {\n-                    if b_sig.unsafety() == hir::Unsafety::Normal\n-                        && !self.tcx.codegen_fn_attrs(def_id).target_features.is_empty()\n-                    {\n-                        return Err(TypeError::TargetFeatureCast(def_id));\n-                    }\n+                if let ty::FnDef(def_id, _) = *a.kind()\n+                    && b_sig.unsafety() == hir::Unsafety::Normal\n+                    && !self.tcx.codegen_fn_attrs(def_id).target_features.is_empty()\n+                {\n+                    return Err(TypeError::TargetFeatureCast(def_id));\n                 }\n \n                 let InferOk { value: a_sig, obligations: o1 } =\n@@ -1540,23 +1537,22 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 fcx.tcx.hir().get_if_cause(expr.hir_id),\n                 expected.is_unit(),\n                 pointing_at_return_type,\n-            ) {\n+            )\n                 // If the block is from an external macro or try (`?`) desugaring, then\n                 // do not suggest adding a semicolon, because there's nowhere to put it.\n                 // See issues #81943 and #87051.\n-                if matches!(\n+                && matches!(\n                     cond_expr.span.desugaring_kind(),\n                     None | Some(DesugaringKind::WhileLoop)\n                 ) && !in_external_macro(fcx.tcx.sess, cond_expr.span)\n                     && !matches!(\n                         cond_expr.kind,\n                         hir::ExprKind::Match(.., hir::MatchSource::TryDesugar)\n                     )\n-                {\n-                    err.span_label(cond_expr.span, \"expected this to be `()`\");\n-                    if expr.can_have_side_effects() {\n-                        fcx.suggest_semicolon_at_end(cond_expr.span, &mut err);\n-                    }\n+            {\n+                err.span_label(cond_expr.span, \"expected this to be `()`\");\n+                if expr.can_have_side_effects() {\n+                    fcx.suggest_semicolon_at_end(cond_expr.span, &mut err);\n                 }\n             }\n             fcx.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n@@ -1636,28 +1632,27 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         let has_impl = snippet_iter.next().map_or(false, |s| s == \"impl\");\n         // Only suggest `Box<dyn Trait>` if `Trait` in `impl Trait` is object safe.\n         let mut is_object_safe = false;\n-        if let hir::FnRetTy::Return(ty) = fn_output {\n+        if let hir::FnRetTy::Return(ty) = fn_output\n             // Get the return type.\n-            if let hir::TyKind::OpaqueDef(..) = ty.kind {\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n-                // Get the `impl Trait`'s `DefId`.\n-                if let ty::Opaque(def_id, _) = ty.kind() {\n-                    // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n-                    // get the `Trait`'s `DefId`.\n-                    if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) =\n-                        fcx.tcx.hir().expect_item(def_id.expect_local()).kind\n-                    {\n-                        // Are of this `impl Trait`'s traits object safe?\n-                        is_object_safe = bounds.iter().all(|bound| {\n-                            bound\n-                                .trait_ref()\n-                                .and_then(|t| t.trait_def_id())\n-                                .map_or(false, |def_id| {\n-                                    fcx.tcx.object_safety_violations(def_id).is_empty()\n-                                })\n+            && let hir::TyKind::OpaqueDef(..) = ty.kind\n+        {\n+            let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n+            // Get the `impl Trait`'s `DefId`.\n+            if let ty::Opaque(def_id, _) = ty.kind()\n+                // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n+                // get the `Trait`'s `DefId`.\n+                && let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) =\n+                    fcx.tcx.hir().expect_item(def_id.expect_local()).kind\n+            {\n+                // Are of this `impl Trait`'s traits object safe?\n+                is_object_safe = bounds.iter().all(|bound| {\n+                    bound\n+                        .trait_ref()\n+                        .and_then(|t| t.trait_def_id())\n+                        .map_or(false, |def_id| {\n+                            fcx.tcx.object_safety_violations(def_id).is_empty()\n                         })\n-                    }\n-                }\n+                })\n             }\n         };\n         if has_impl {\n@@ -1703,7 +1698,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             && let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty)\n             && let ty::Dynamic(..) = ty.kind()\n         {\n-                    return true;\n+            return true;\n         }\n         false\n     }"}, {"sha": "4aa46c21fce91313288e77f433de1eaee71c9b23", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -315,7 +315,7 @@ fn compare_predicate_entailment<'tcx>(\n                         ExplicitSelf::ByReference(_, hir::Mutability::Mut) => {\n                             \"&mut self\".to_owned()\n                         }\n-                        _ => format!(\"self: {}\", ty),\n+                        _ => format!(\"self: {ty}\"),\n                     };\n \n                     // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n@@ -526,7 +526,7 @@ fn compare_self_type<'tcx>(\n                 ExplicitSelf::ByValue => \"self\".to_owned(),\n                 ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n                 ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n-                _ => format!(\"self: {}\", self_arg_ty),\n+                _ => format!(\"self: {self_arg_ty}\"),\n             }\n         })\n     };\n@@ -544,9 +544,9 @@ fn compare_self_type<'tcx>(\n                 trait_m.name,\n                 self_descr\n             );\n-            err.span_label(impl_m_span, format!(\"`{}` used in impl\", self_descr));\n+            err.span_label(impl_m_span, format!(\"`{self_descr}` used in impl\"));\n             if let Some(span) = tcx.hir().span_if_local(trait_m.def_id) {\n-                err.span_label(span, format!(\"trait method declared without `{}`\", self_descr));\n+                err.span_label(span, format!(\"trait method declared without `{self_descr}`\"));\n             } else {\n                 err.note_trait_signature(trait_m.name.to_string(), trait_m.signature(tcx));\n             }\n@@ -564,9 +564,9 @@ fn compare_self_type<'tcx>(\n                 trait_m.name,\n                 self_descr\n             );\n-            err.span_label(impl_m_span, format!(\"expected `{}` in impl\", self_descr));\n+            err.span_label(impl_m_span, format!(\"expected `{self_descr}` in impl\"));\n             if let Some(span) = tcx.hir().span_if_local(trait_m.def_id) {\n-                err.span_label(span, format!(\"`{}` used in trait\", self_descr));\n+                err.span_label(span, format!(\"`{self_descr}` used in trait\"));\n             } else {\n                 err.note_trait_signature(trait_m.name.to_string(), trait_m.signature(tcx));\n             }\n@@ -668,7 +668,7 @@ fn compare_number_of_generics<'tcx>(\n                     err.span_label(*span, \"\");\n                 }\n             } else {\n-                suffix = Some(format!(\", expected {}\", trait_count));\n+                suffix = Some(format!(\", expected {trait_count}\"));\n             }\n \n             if let Some(span) = span {\n@@ -873,12 +873,10 @@ fn compare_synthetic_generics<'tcx>(\n                                 intravisit::walk_ty(self, ty);\n                                 if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) =\n                                     ty.kind\n+                                    && let Res::Def(DefKind::TyParam, def_id) = path.res\n+                                    && def_id == self.1\n                                 {\n-                                    if let Res::Def(DefKind::TyParam, def_id) = path.res {\n-                                        if def_id == self.1 {\n-                                            self.0 = Some(ty.span);\n-                                        }\n-                                    }\n+                                    self.0 = Some(ty.span);\n                                 }\n                             }\n                         }\n@@ -908,7 +906,7 @@ fn compare_synthetic_generics<'tcx>(\n                                 // delete generic parameters\n                                 (impl_m.generics.span, String::new()),\n                                 // replace param usage with `impl Trait`\n-                                (span, format!(\"impl {}\", bounds)),\n+                                (span, format!(\"impl {bounds}\")),\n                             ],\n                             Applicability::MaybeIncorrect,\n                         );\n@@ -972,7 +970,7 @@ fn compare_const_param_types<'tcx>(\n                 &format!(\n                     \"the const parameter{} has type `{}`, but the declaration \\\n                               in trait `{}` has type `{}`\",\n-                    &impl_ident.map_or_else(|| \"\".to_string(), |ident| format!(\" `{}`\", ident)),\n+                    &impl_ident.map_or_else(|| \"\".to_string(), |ident| format!(\" `{ident}`\")),\n                     impl_ty,\n                     tcx.def_path_str(trait_m.def_id),\n                     trait_ty"}, {"sha": "7c5a312c40e628589b6529b0ef9e25ef827b98c5", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 131, "deletions": 141, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -241,13 +241,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // We are pointing at the binding's type or initializer value, but it's pattern\n                     // is in a different line, so we point at both.\n                     err.span_label(secondary_span, \"expected due to the type of this binding\");\n-                    err.span_label(primary_span, &format!(\"expected due to this{}\", post_message));\n+                    err.span_label(primary_span, &format!(\"expected due to this{post_message}\"));\n                 } else if post_message == \"\" {\n                     // We are pointing at either the assignment lhs or the binding def pattern.\n                     err.span_label(primary_span, \"expected due to the type of this binding\");\n                 } else {\n                     // We are pointing at the binding's type or initializer value.\n-                    err.span_label(primary_span, &format!(\"expected due to this{}\", post_message));\n+                    err.span_label(primary_span, &format!(\"expected due to this{post_message}\"));\n                 }\n \n                 if !lhs.is_syntactic_place_expr() {\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     \"try adding an expression at the end of the block\",\n                                     return_suggestions\n                                         .into_iter()\n-                                        .map(|r| format!(\"{}\\n{}{}\", semicolon, indent, r)),\n+                                        .map(|r| format!(\"{semicolon}\\n{indent}{r}\")),\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n@@ -344,10 +344,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let variant_path =\n                             with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n                         // FIXME #56861: DRYer prelude filtering\n-                        if let Some(path) = variant_path.strip_prefix(\"std::prelude::\") {\n-                            if let Some((_, path)) = path.split_once(\"::\") {\n-                                return Some(path.to_string());\n-                            }\n+                        if let Some(path) = variant_path.strip_prefix(\"std::prelude::\")\n+                            && let Some((_, path)) = path.split_once(\"::\")\n+                        {\n+                            return Some(path.to_string());\n                         }\n                         Some(variant_path)\n                     } else {\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .collect();\n \n             let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                Some(ident) => format!(\"{}: \", ident),\n+                Some(ident) => format!(\"{ident}: \"),\n                 None => String::new(),\n             };\n \n@@ -366,9 +366,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 [variant] => {\n                     // Just a single matching variant.\n                     err.multipart_suggestion_verbose(\n-                        &format!(\"try wrapping the expression in `{}`\", variant),\n+                        &format!(\"try wrapping the expression in `{variant}`\"),\n                         vec![\n-                            (expr.span.shrink_to_lo(), format!(\"{}{}(\", prefix, variant)),\n+                            (expr.span.shrink_to_lo(), format!(\"{prefix}{variant}(\")),\n                             (expr.span.shrink_to_hi(), \")\".to_string()),\n                         ],\n                         Applicability::MaybeIncorrect,\n@@ -383,7 +383,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ),\n                         compatible_variants.into_iter().map(|variant| {\n                             vec![\n-                                (expr.span.shrink_to_lo(), format!(\"{}{}(\", prefix, variant)),\n+                                (expr.span.shrink_to_lo(), format!(\"{prefix}{variant}(\")),\n                                 (expr.span.shrink_to_hi(), \")\".to_string()),\n                             ]\n                         }),\n@@ -680,7 +680,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             _ if is_range_literal(expr) => true,\n                             _ => false,\n                         };\n-                        let sugg_expr = if needs_parens { format!(\"({})\", src) } else { src };\n+                        let sugg_expr = if needs_parens { format!(\"({src})\") } else { src };\n \n                         if let Some(sugg) = self.can_use_as_ref(expr) {\n                             return Some((\n@@ -693,7 +693,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n \n                         let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                            Some(ident) => format!(\"{}: \", ident),\n+                            Some(ident) => format!(\"{ident}: \"),\n                             None => String::new(),\n                         };\n \n@@ -727,14 +727,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             hir::Mutability::Mut => (\n                                 sp,\n                                 \"consider mutably borrowing here\".to_string(),\n-                                format!(\"{}&mut {}\", prefix, sugg_expr),\n+                                format!(\"{prefix}&mut {sugg_expr}\"),\n                                 Applicability::MachineApplicable,\n                                 false,\n                             ),\n                             hir::Mutability::Not => (\n                                 sp,\n                                 \"consider borrowing here\".to_string(),\n-                                format!(\"{}&{}\", prefix, sugg_expr),\n+                                format!(\"{prefix}&{sugg_expr}\"),\n                                 Applicability::MachineApplicable,\n                                 false,\n                             ),\n@@ -758,96 +758,94 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if let Some(call_span) =\n                         iter::successors(Some(expr.span), |s| s.parent_callsite())\n                             .find(|&s| sp.contains(s))\n+                        && sm.span_to_snippet(call_span).is_ok()\n                     {\n-                        if sm.span_to_snippet(call_span).is_ok() {\n-                            return Some((\n-                                sp.with_hi(call_span.lo()),\n-                                \"consider removing the borrow\".to_string(),\n-                                String::new(),\n-                                Applicability::MachineApplicable,\n-                                true,\n-                            ));\n-                        }\n-                    }\n-                    return None;\n-                }\n-                if sp.contains(expr.span) {\n-                    if sm.span_to_snippet(expr.span).is_ok() {\n                         return Some((\n-                            sp.with_hi(expr.span.lo()),\n+                            sp.with_hi(call_span.lo()),\n                             \"consider removing the borrow\".to_string(),\n                             String::new(),\n                             Applicability::MachineApplicable,\n                             true,\n                         ));\n                     }\n+                    return None;\n+                }\n+                if sp.contains(expr.span)\n+                    && sm.span_to_snippet(expr.span).is_ok()\n+                {\n+                    return Some((\n+                        sp.with_hi(expr.span.lo()),\n+                        \"consider removing the borrow\".to_string(),\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                        true,\n+                    ));\n                 }\n             }\n             (\n                 _,\n                 &ty::RawPtr(TypeAndMut { ty: ty_b, mutbl: mutbl_b }),\n                 &ty::Ref(_, ty_a, mutbl_a),\n             ) => {\n-                if let Some(steps) = self.deref_steps(ty_a, ty_b) {\n+                if let Some(steps) = self.deref_steps(ty_a, ty_b)\n                     // Only suggest valid if dereferencing needed.\n-                    if steps > 0 {\n-                        // The pointer type implements `Copy` trait so the suggestion is always valid.\n-                        if let Ok(src) = sm.span_to_snippet(sp) {\n-                            let derefs = \"*\".repeat(steps);\n-                            if let Some((span, src, applicability)) = match mutbl_b {\n+                    && steps > 0\n+                    // The pointer type implements `Copy` trait so the suggestion is always valid.\n+                    && let Ok(src) = sm.span_to_snippet(sp)\n+                {\n+                    let derefs = \"*\".repeat(steps);\n+                    if let Some((span, src, applicability)) = match mutbl_b {\n+                        hir::Mutability::Mut => {\n+                            let new_prefix = \"&mut \".to_owned() + &derefs;\n+                            match mutbl_a {\n                                 hir::Mutability::Mut => {\n-                                    let new_prefix = \"&mut \".to_owned() + &derefs;\n-                                    match mutbl_a {\n-                                        hir::Mutability::Mut => {\n-                                            replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n-                                                let pos = sp.lo() + BytePos(5);\n-                                                let sp = sp.with_lo(pos).with_hi(pos);\n-                                                (sp, derefs, Applicability::MachineApplicable)\n-                                            })\n-                                        }\n-                                        hir::Mutability::Not => {\n-                                            replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n-                                                let pos = sp.lo() + BytePos(1);\n-                                                let sp = sp.with_lo(pos).with_hi(pos);\n-                                                (\n-                                                    sp,\n-                                                    format!(\"mut {}\", derefs),\n-                                                    Applicability::Unspecified,\n-                                                )\n-                                            })\n-                                        }\n-                                    }\n+                                    replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n+                                        let pos = sp.lo() + BytePos(5);\n+                                        let sp = sp.with_lo(pos).with_hi(pos);\n+                                        (sp, derefs, Applicability::MachineApplicable)\n+                                    })\n                                 }\n                                 hir::Mutability::Not => {\n-                                    let new_prefix = \"&\".to_owned() + &derefs;\n-                                    match mutbl_a {\n-                                        hir::Mutability::Mut => {\n-                                            replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n-                                                let lo = sp.lo() + BytePos(1);\n-                                                let hi = sp.lo() + BytePos(5);\n-                                                let sp = sp.with_lo(lo).with_hi(hi);\n-                                                (sp, derefs, Applicability::MachineApplicable)\n-                                            })\n-                                        }\n-                                        hir::Mutability::Not => {\n-                                            replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n-                                                let pos = sp.lo() + BytePos(1);\n-                                                let sp = sp.with_lo(pos).with_hi(pos);\n-                                                (sp, derefs, Applicability::MachineApplicable)\n-                                            })\n-                                        }\n-                                    }\n+                                    replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n+                                        let pos = sp.lo() + BytePos(1);\n+                                        let sp = sp.with_lo(pos).with_hi(pos);\n+                                        (\n+                                            sp,\n+                                            format!(\"mut {derefs}\"),\n+                                            Applicability::Unspecified,\n+                                        )\n+                                    })\n                                 }\n-                            } {\n-                                return Some((\n-                                    span,\n-                                    \"consider dereferencing\".to_string(),\n-                                    src,\n-                                    applicability,\n-                                    true,\n-                                ));\n                             }\n                         }\n+                        hir::Mutability::Not => {\n+                            let new_prefix = \"&\".to_owned() + &derefs;\n+                            match mutbl_a {\n+                                hir::Mutability::Mut => {\n+                                    replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n+                                        let lo = sp.lo() + BytePos(1);\n+                                        let hi = sp.lo() + BytePos(5);\n+                                        let sp = sp.with_lo(lo).with_hi(hi);\n+                                        (sp, derefs, Applicability::MachineApplicable)\n+                                    })\n+                                }\n+                                hir::Mutability::Not => {\n+                                    replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n+                                        let pos = sp.lo() + BytePos(1);\n+                                        let sp = sp.with_lo(pos).with_hi(pos);\n+                                        (sp, derefs, Applicability::MachineApplicable)\n+                                    })\n+                                }\n+                            }\n+                        }\n+                    } {\n+                        return Some((\n+                            span,\n+                            \"consider dereferencing\".to_string(),\n+                            src,\n+                            applicability,\n+                            true,\n+                        ));\n                     }\n                 }\n             }\n@@ -908,7 +906,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // Suggest removing `&` if we have removed any, otherwise suggest just\n                         // dereferencing the remaining number of steps.\n                         let message = if remove.is_empty() {\n-                            format!(\"consider {}\", deref_kind)\n+                            format!(\"consider {deref_kind}\")\n                         } else {\n                             format!(\n                                 \"consider removing the `{}` and {} instead\",\n@@ -918,7 +916,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         };\n \n                         let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                            Some(ident) => format!(\"{}: \", ident),\n+                            Some(ident) => format!(\"{ident}: \"),\n                             None => String::new(),\n                         };\n \n@@ -994,35 +992,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n-        if let hir::ExprKind::Call(path, args) = &expr.kind {\n-            if let (hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)), 1) =\n+        if let hir::ExprKind::Call(path, args) = &expr.kind\n+            && let (hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)), 1) =\n                 (&path.kind, args.len())\n-            {\n-                // `expr` is a conversion like `u32::from(val)`, do not suggest anything (#63697).\n-                if let (hir::TyKind::Path(hir::QPath::Resolved(None, base_ty_path)), sym::from) =\n-                    (&base_ty.kind, path_segment.ident.name)\n-                {\n-                    if let Some(ident) = &base_ty_path.segments.iter().map(|s| s.ident).next() {\n-                        match ident.name {\n-                            sym::i128\n-                            | sym::i64\n-                            | sym::i32\n-                            | sym::i16\n-                            | sym::i8\n-                            | sym::u128\n-                            | sym::u64\n-                            | sym::u32\n-                            | sym::u16\n-                            | sym::u8\n-                            | sym::isize\n-                            | sym::usize\n-                                if base_ty_path.segments.len() == 1 =>\n-                            {\n-                                return false;\n-                            }\n-                            _ => {}\n-                        }\n+            // `expr` is a conversion like `u32::from(val)`, do not suggest anything (#63697).\n+            && let (hir::TyKind::Path(hir::QPath::Resolved(None, base_ty_path)), sym::from) =\n+                (&base_ty.kind, path_segment.ident.name)\n+        {\n+            if let Some(ident) = &base_ty_path.segments.iter().map(|s| s.ident).next() {\n+                match ident.name {\n+                    sym::i128\n+                    | sym::i64\n+                    | sym::i32\n+                    | sym::i16\n+                    | sym::i8\n+                    | sym::u128\n+                    | sym::u64\n+                    | sym::u32\n+                    | sym::u16\n+                    | sym::u8\n+                    | sym::isize\n+                    | sym::usize\n+                        if base_ty_path.segments.len() == 1 =>\n+                    {\n+                        return false;\n                     }\n+                    _ => {}\n                 }\n             }\n         }\n@@ -1042,8 +1037,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expected_ty,\n         );\n         let lit_msg = format!(\n-            \"change the type of the numeric literal from `{}` to `{}`\",\n-            checked_ty, expected_ty,\n+            \"change the type of the numeric literal from `{checked_ty}` to `{expected_ty}`\",\n         );\n \n         let close_paren = if expr.precedence().order() < PREC_POSTFIX {\n@@ -1054,10 +1048,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let mut cast_suggestion = sugg.clone();\n-        cast_suggestion\n-            .push((expr.span.shrink_to_hi(), format!(\"{} as {}\", close_paren, expected_ty)));\n+        cast_suggestion.push((expr.span.shrink_to_hi(), format!(\"{close_paren} as {expected_ty}\")));\n         let mut into_suggestion = sugg.clone();\n-        into_suggestion.push((expr.span.shrink_to_hi(), format!(\"{}.into()\", close_paren)));\n+        into_suggestion.push((expr.span.shrink_to_hi(), format!(\"{close_paren}.into()\")));\n         let mut suffix_suggestion = sugg.clone();\n         suffix_suggestion.push((\n             if matches!(\n@@ -1074,7 +1067,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n             if expr.precedence().order() < PREC_POSTFIX {\n                 // Readd `)`\n-                format!(\"{})\", expected_ty)\n+                format!(\"{expected_ty})\")\n             } else {\n                 expected_ty.to_string()\n             },\n@@ -1108,20 +1101,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (lhs_expr_and_src, exp_to_found_is_fallible)\n                 {\n                     let msg = format!(\n-                        \"you can convert `{}` from `{}` to `{}`, matching the type of `{}`\",\n-                        lhs_src, expected_ty, checked_ty, src\n+                        \"you can convert `{lhs_src}` from `{expected_ty}` to `{checked_ty}`, matching the type of `{src}`\",\n                     );\n                     let suggestion = vec![\n-                        (lhs_expr.span.shrink_to_lo(), format!(\"{}::from(\", checked_ty)),\n+                        (lhs_expr.span.shrink_to_lo(), format!(\"{checked_ty}::from(\")),\n                         (lhs_expr.span.shrink_to_hi(), \")\".to_string()),\n                     ];\n                     (msg, suggestion)\n                 } else {\n-                    let msg = format!(\"{} and panic if the converted value doesn't fit\", msg);\n+                    let msg = format!(\"{msg} and panic if the converted value doesn't fit\");\n                     let mut suggestion = sugg.clone();\n                     suggestion.push((\n                         expr.span.shrink_to_hi(),\n-                        format!(\"{}.try_into().unwrap()\", close_paren),\n+                        format!(\"{close_paren}.try_into().unwrap()\"),\n                     ));\n                     (msg, suggestion)\n                 };\n@@ -1151,7 +1143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // We now know that converting either the lhs or rhs is fallible. Before we\n                     // suggest a fallible conversion, check if the value can never fit in the\n                     // expected type.\n-                    let msg = format!(\"`{}` cannot fit into type `{}`\", src, expected_ty);\n+                    let msg = format!(\"`{src}` cannot fit into type `{expected_ty}`\");\n                     err.note(&msg);\n                     return;\n                 } else if in_const_context {\n@@ -1229,7 +1221,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else if can_cast {\n                     // Missing try_into implementation for `f64` to `f32`\n                     err.multipart_suggestion_verbose(\n-                        &format!(\"{}, producing the closest possible value\", cast_msg),\n+                        &format!(\"{cast_msg}, producing the closest possible value\"),\n                         cast_suggestion,\n                         Applicability::MaybeIncorrect, // lossy conversion\n                     );\n@@ -1246,7 +1238,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else if can_cast {\n                     // Missing try_into implementation for `{float}` to `{integer}`\n                     err.multipart_suggestion_verbose(\n-                        &format!(\"{}, rounding the float towards zero\", msg),\n+                        &format!(\"{msg}, rounding the float towards zero\"),\n                         cast_suggestion,\n                         Applicability::MaybeIncorrect, // lossy conversion\n                     );\n@@ -1258,8 +1250,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if exp.bit_width() > found.bit_width().unwrap_or(256) {\n                     err.multipart_suggestion_verbose(\n                         &format!(\n-                            \"{}, producing the floating point representation of the integer\",\n-                            msg,\n+                            \"{msg}, producing the floating point representation of the integer\",\n                         ),\n                         into_suggestion,\n                         Applicability::MachineApplicable,\n@@ -1274,9 +1265,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // Missing try_into implementation for `{integer}` to `{float}`\n                     err.multipart_suggestion_verbose(\n                         &format!(\n-                            \"{}, producing the floating point representation of the integer, \\\n+                            \"{cast_msg}, producing the floating point representation of the integer, \\\n                                  rounded if necessary\",\n-                            cast_msg,\n                         ),\n                         cast_suggestion,\n                         Applicability::MaybeIncorrect, // lossy conversion\n@@ -1321,7 +1311,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &ty::Char,\n             ) => {\n                 err.multipart_suggestion_verbose(\n-                    &format!(\"{}, since a `char` always occupies 4 bytes\", cast_msg,),\n+                    &format!(\"{cast_msg}, since a `char` always occupies 4 bytes\"),\n                     cast_suggestion,\n                     Applicability::MachineApplicable,\n                 );\n@@ -1333,22 +1323,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     // Report the type inferred by the return statement.\n     fn report_closure_inferred_return_type(&self, err: &mut Diagnostic, expected: Ty<'tcx>) {\n-        if let Some(sp) = self.ret_coercion_span.get() {\n+        if let Some(sp) = self.ret_coercion_span.get()\n             // If the closure has an explicit return type annotation, or if\n             // the closure's return type has been inferred from outside\n             // requirements (such as an Fn* trait bound), then a type error\n             // may occur at the first return expression we see in the closure\n             // (if it conflicts with the declared return type). Skip adding a\n             // note in this case, since it would be incorrect.\n-            if !self.return_type_pre_known {\n-                err.span_note(\n-                    sp,\n-                    &format!(\n-                        \"return type inferred to be `{}` here\",\n-                        self.resolve_vars_if_possible(expected)\n-                    ),\n-                );\n-            }\n+            && !self.return_type_pre_known\n+        {\n+            err.span_note(\n+                sp,\n+                &format!(\n+                    \"return type inferred to be `{}` here\",\n+                    self.resolve_vars_if_possible(expected)\n+                ),\n+            );\n         }\n     }\n }"}, {"sha": "3bc92166543d4a2ece577248c035d740abc0bc1e", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -57,7 +57,7 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n             let span = tcx.def_span(drop_impl_did);\n             let reported = tcx.sess.delay_span_bug(\n                 span,\n-                &format!(\"should have been rejected by coherence check: {}\", dtor_self_type),\n+                &format!(\"should have been rejected by coherence check: {dtor_self_type}\"),\n             );\n             Err(reported)\n         }\n@@ -104,8 +104,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n                     item_span,\n                     &format!(\n                         \"use the same sequence of generic type, lifetime and const parameters \\\n-                        as the {} definition\",\n-                        self_descr,\n+                        as the {self_descr} definition\",\n                     ),\n                 )\n                 .emit();\n@@ -262,9 +261,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n                 tcx.sess,\n                 predicate_sp,\n                 E0367,\n-                \"`Drop` impl requires `{}` but the {} it is implemented for does not\",\n-                predicate,\n-                self_descr,\n+                \"`Drop` impl requires `{predicate}` but the {self_descr} it is implemented for does not\",\n             )\n             .span_note(item_span, \"the implementor must specify the same requirement\")\n             .emit();"}, {"sha": "4d15dd715f1fcf61b8ea8ade03cd4f1395a9c06c", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 54, "deletions": 69, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -181,13 +181,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // make this code only run with -Zverbose because it is probably slow\n             if let Ok(lint_str) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n                 if !lint_str.contains('\\n') {\n-                    debug!(\"expr text: {}\", lint_str);\n+                    debug!(\"expr text: {lint_str}\");\n                 } else {\n                     let mut lines = lint_str.lines();\n                     if let Some(line0) = lines.next() {\n                         let remaining_lines = lines.count();\n-                        debug!(\"expr text: {}\", line0);\n-                        debug!(\"expr text: ...(and {} more lines)\", remaining_lines);\n+                        debug!(\"expr text: {line0}\");\n+                        debug!(\"expr text: ...(and {remaining_lines} more lines)\");\n                     }\n                 }\n             }\n@@ -375,8 +375,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             expr.span,\n                             oprnd_t,\n                             E0614,\n-                            \"type `{}` cannot be dereferenced\",\n-                            oprnd_t,\n+                            \"type `{oprnd_t}` cannot be dereferenced\",\n                         );\n                         let sp = tcx.sess.source_map().start_point(expr.span);\n                         if let Some(sp) =\n@@ -652,7 +651,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 err.span_suggestion(\n                                     expr.span,\n                                     \"give it a value of the expected type\",\n-                                    format!(\"break{} {}\", label, val),\n+                                    format!(\"break{label} {val}\"),\n                                     Applicability::HasPlaceholders,\n                                 );\n                             }\n@@ -780,7 +779,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                             db.span_label(\n                                 span,\n-                                format!(\"expected `{}` because of this return type\", snippet),\n+                                format!(\"expected `{snippet}` because of this return type\"),\n                             );\n                         }\n                     },\n@@ -1611,15 +1610,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut truncated_fields_error = String::new();\n         let remaining_fields_names = match &displayable_field_names[..] {\n             [field1] => format!(\"`{}`\", field1),\n-            [field1, field2] => format!(\"`{}` and `{}`\", field1, field2),\n-            [field1, field2, field3] => format!(\"`{}`, `{}` and `{}`\", field1, field2, field3),\n+            [field1, field2] => format!(\"`{field1}` and `{field2}`\"),\n+            [field1, field2, field3] => format!(\"`{field1}`, `{field2}` and `{field3}`\"),\n             _ => {\n                 truncated_fields_error =\n                     format!(\" and {} other field{}\", len - 3, pluralize!(len - 3));\n                 displayable_field_names\n                     .iter()\n                     .take(3)\n-                    .map(|n| format!(\"`{}`\", n))\n+                    .map(|n| format!(\"`{n}`\"))\n                     .collect::<Vec<_>>()\n                     .join(\", \")\n             }\n@@ -1635,10 +1634,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             truncated_fields_error,\n             adt_ty\n         );\n-        err.span_label(\n-            span,\n-            format!(\"missing {}{}\", remaining_fields_names, truncated_fields_error),\n-        );\n+        err.span_label(span, format!(\"missing {remaining_fields_names}{truncated_fields_error}\"));\n \n         // If the last field is a range literal, but it isn't supposed to be, then they probably\n         // meant to use functional update syntax.\n@@ -1693,8 +1689,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(\n             span,\n             &format!(\n-                \"cannot construct `{}` with struct literal syntax due to inaccessible fields\",\n-                adt_ty,\n+                \"cannot construct `{adt_ty}` with struct literal syntax due to inaccessible fields\",\n             ),\n         );\n     }\n@@ -1807,7 +1802,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             } else {\n                                 err.span_label(\n                                     field.ident.span,\n-                                    format!(\"`{}` does not have this field\", ty),\n+                                    format!(\"`{ty}` does not have this field\"),\n                                 );\n                             }\n                             let available_field_names =\n@@ -1973,8 +1968,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 field.span,\n                 expr_t,\n                 E0610,\n-                \"`{}` is a primitive type and therefore doesn't have fields\",\n-                expr_t\n+                \"`{expr_t}` is a primitive type and therefore doesn't have fields\",\n             )\n             .emit();\n         }\n@@ -2018,7 +2012,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n         if add_label {\n-            err.span_label(field_ident.span, &format!(\"field not found in `{}`\", ty));\n+            err.span_label(field_ident.span, &format!(\"field not found in `{ty}`\"));\n         }\n     }\n \n@@ -2077,18 +2071,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx().sess,\n             field.span,\n             E0616,\n-            \"field `{}` of {} `{}` is private\",\n-            field,\n-            kind_name,\n-            struct_path\n+            \"field `{field}` of {kind_name} `{struct_path}` is private\",\n         );\n         err.span_label(field.span, \"private field\");\n         // Also check if an accessible method exists, which is often what is meant.\n         if self.method_exists(field, expr_t, expr.hir_id, false) && !self.expr_in_place(expr.hir_id)\n         {\n             self.suggest_method_call(\n                 &mut err,\n-                &format!(\"a method `{}` also exists, call it with parentheses\", field),\n+                &format!(\"a method `{field}` also exists, call it with parentheses\"),\n                 field,\n                 expr_t,\n                 expr,\n@@ -2104,9 +2095,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             field.span,\n             expr_t,\n             E0615,\n-            \"attempted to take value of method `{}` on type `{}`\",\n-            field,\n-            expr_t\n+            \"attempted to take value of method `{field}` on type `{expr_t}`\",\n         );\n         err.span_label(field.span, \"method, not a field\");\n         let expr_is_call =\n@@ -2150,27 +2139,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             let mut found = false;\n \n-            if let ty::RawPtr(ty_and_mut) = expr_t.kind() {\n-                if let ty::Adt(adt_def, _) = ty_and_mut.ty.kind() {\n-                    if adt_def.variants().len() == 1\n-                        && adt_def\n-                            .variants()\n-                            .iter()\n-                            .next()\n-                            .unwrap()\n-                            .fields\n-                            .iter()\n-                            .any(|f| f.ident(self.tcx) == field)\n-                    {\n-                        if let Some(dot_loc) = expr_snippet.rfind('.') {\n-                            found = true;\n-                            err.span_suggestion(\n-                                expr.span.with_hi(expr.span.lo() + BytePos::from_usize(dot_loc)),\n-                                \"to access the field, dereference first\",\n-                                format!(\"(*{})\", &expr_snippet[0..dot_loc]),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n+            if let ty::RawPtr(ty_and_mut) = expr_t.kind()\n+                && let ty::Adt(adt_def, _) = ty_and_mut.ty.kind()\n+            {\n+                if adt_def.variants().len() == 1\n+                    && adt_def\n+                        .variants()\n+                        .iter()\n+                        .next()\n+                        .unwrap()\n+                        .fields\n+                        .iter()\n+                        .any(|f| f.ident(self.tcx) == field)\n+                {\n+                    if let Some(dot_loc) = expr_snippet.rfind('.') {\n+                        found = true;\n+                        err.span_suggestion(\n+                            expr.span.with_hi(expr.span.lo() + BytePos::from_usize(dot_loc)),\n+                            \"to access the field, dereference first\",\n+                            format!(\"(*{})\", &expr_snippet[0..dot_loc]),\n+                            Applicability::MaybeIncorrect,\n+                        );\n                     }\n                 }\n             }\n@@ -2197,7 +2186,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let param_span = self.tcx.hir().span(param_hir_id);\n         let param_name = self.tcx.hir().ty_param_name(param_def_id.expect_local());\n \n-        err.span_label(param_span, &format!(\"type parameter '{}' declared here\", param_name));\n+        err.span_label(param_span, &format!(\"type parameter '{param_name}' declared here\"));\n     }\n \n     fn suggest_fields_on_recordish(\n@@ -2239,17 +2228,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         if let (Some(len), Ok(user_index)) =\n             (len.try_eval_usize(self.tcx, self.param_env), field.as_str().parse::<u64>())\n+            && let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span)\n         {\n-            if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n-                let help = \"instead of using tuple indexing, use array indexing\";\n-                let suggestion = format!(\"{}[{}]\", base, field);\n-                let applicability = if len < user_index {\n-                    Applicability::MachineApplicable\n-                } else {\n-                    Applicability::MaybeIncorrect\n-                };\n-                err.span_suggestion(expr.span, help, suggestion, applicability);\n-            }\n+            let help = \"instead of using tuple indexing, use array indexing\";\n+            let suggestion = format!(\"{base}[{field}]\");\n+            let applicability = if len < user_index {\n+                Applicability::MachineApplicable\n+            } else {\n+                Applicability::MaybeIncorrect\n+            };\n+            err.span_suggestion(expr.span, help, suggestion, applicability);\n         }\n     }\n \n@@ -2261,8 +2249,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: Ident,\n     ) {\n         if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n-            let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n-            let suggestion = format!(\"(*{}).{}\", base, field);\n+            let msg = format!(\"`{base}` is a raw pointer; try dereferencing it\");\n+            let suggestion = format!(\"(*{base}).{field}\");\n             err.span_suggestion(expr.span, &msg, suggestion, Applicability::MaybeIncorrect);\n         }\n     }\n@@ -2281,9 +2269,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             field.span,\n             expr_t,\n             E0609,\n-            \"no field `{}` on type `{}`\",\n-            field,\n-            expr_t\n+            \"no field `{field}` on type `{expr_t}`\",\n         );\n \n         // try to add a suggestion in case the field is a nested field of a field of the Adt\n@@ -2307,7 +2293,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_suggestion_verbose(\n                         field.span.shrink_to_lo(),\n                         \"one of the expressions' fields has a field of the same name\",\n-                        format!(\"{}.\", field_path_str),\n+                        format!(\"{field_path_str}.\"),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }\n@@ -2419,8 +2405,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         expr.span,\n                         base_t,\n                         E0608,\n-                        \"cannot index into a value of type `{}`\",\n-                        base_t\n+                        \"cannot index into a value of type `{base_t}`\",\n                     );\n                     // Try to give some advice about indexing tuples.\n                     if let ty::Tuple(..) = base_t.kind() {\n@@ -2434,7 +2419,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     err.span_suggestion(\n                                         expr.span,\n                                         \"to access tuple elements, use\",\n-                                        format!(\"{}.{}\", snip, i),\n+                                        format!(\"{snip}.{i}\"),\n                                         Applicability::MachineApplicable,\n                                     );\n                                     needs_note = false;"}, {"sha": "15edc11a4974d53e26a4c42b9e8a3f90868f70ec", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -567,7 +567,7 @@ pub fn check_must_not_suspend_ty<'tcx>(\n                 _ => None,\n             };\n             for (i, ty) in fields.iter().enumerate() {\n-                let descr_post = &format!(\" in tuple element {}\", i);\n+                let descr_post = &format!(\" in tuple element {i}\");\n                 let span = comps.and_then(|c| c.get(i)).map(|e| e.span).unwrap_or(data.source_span);\n                 if check_must_not_suspend_ty(\n                     fcx,"}, {"sha": "78e7758067942c3f16a45c11b5cafd39daa71b6a", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -484,14 +484,14 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n                 }\n                 Err(_) => {\n                     let msg =\n-                        format!(\"unrecognized platform-specific intrinsic function: `{}`\", name);\n+                        format!(\"unrecognized platform-specific intrinsic function: `{name}`\");\n                     tcx.sess.struct_span_err(it.span, &msg).emit();\n                     return;\n                 }\n             }\n         }\n         _ => {\n-            let msg = format!(\"unrecognized platform-specific intrinsic function: `{}`\", name);\n+            let msg = format!(\"unrecognized platform-specific intrinsic function: `{name}`\");\n             tcx.sess.struct_span_err(it.span, &msg).emit();\n             return;\n         }"}, {"sha": "043472e37f5f4ee6f5df89818bdb52493f0281dc", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -553,13 +553,13 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId, span: S\n     // `#[link_section]` may contain arbitrary, or even undefined bytes, but it is\n     // the consumer's responsibility to ensure all bytes that have been read\n     // have defined values.\n-    if let Ok(alloc) = tcx.eval_static_initializer(id.to_def_id()) {\n-        if alloc.inner().relocations().len() != 0 {\n-            let msg = \"statics with a custom `#[link_section]` must be a \\\n-                           simple list of bytes on the wasm target with no \\\n-                           extra levels of indirection such as references\";\n-            tcx.sess.span_err(span, msg);\n-        }\n+    if let Ok(alloc) = tcx.eval_static_initializer(id.to_def_id())\n+        && alloc.inner().relocations().len() != 0\n+    {\n+        let msg = \"statics with a custom `#[link_section]` must be a \\\n+                        simple list of bytes on the wasm target with no \\\n+                        extra levels of indirection such as references\";\n+        tcx.sess.span_err(span, msg);\n     }\n }\n \n@@ -587,7 +587,7 @@ fn report_forbidden_specialization(\n             ));\n         }\n         Err(cname) => {\n-            err.note(&format!(\"parent implementation is in crate `{}`\", cname));\n+            err.note(&format!(\"parent implementation is in crate `{cname}`\"));\n         }\n     }\n \n@@ -610,10 +610,9 @@ fn missing_items_err(\n         tcx.sess,\n         impl_span,\n         E0046,\n-        \"not all trait items implemented, missing: `{}`\",\n-        missing_items_msg\n+        \"not all trait items implemented, missing: `{missing_items_msg}`\",\n     );\n-    err.span_label(impl_span, format!(\"missing `{}` in implementation\", missing_items_msg));\n+    err.span_label(impl_span, format!(\"missing `{missing_items_msg}` in implementation\"));\n \n     // `Span` before impl block closing brace.\n     let hi = full_impl_span.hi() - BytePos(1);\n@@ -628,7 +627,7 @@ fn missing_items_err(\n     for trait_item in missing_items {\n         let snippet = suggestion_signature(trait_item, tcx);\n         let code = format!(\"{}{}\\n{}\", padding, snippet, padding);\n-        let msg = format!(\"implement the missing item: `{}`\", snippet);\n+        let msg = format!(\"implement the missing item: `{snippet}`\");\n         let appl = Applicability::HasPlaceholders;\n         if let Some(span) = tcx.hir().span_if_local(trait_item.def_id) {\n             err.span_label(span, format!(\"`{}` from trait\", trait_item.name));\n@@ -653,10 +652,9 @@ fn missing_items_must_implement_one_of_err(\n         tcx.sess,\n         impl_span,\n         E0046,\n-        \"not all trait items implemented, missing one of: `{}`\",\n-        missing_items_msg\n+        \"not all trait items implemented, missing one of: `{missing_items_msg}`\",\n     );\n-    err.span_label(impl_span, format!(\"missing one of `{}` in implementation\", missing_items_msg));\n+    err.span_label(impl_span, format!(\"missing one of `{missing_items_msg}` in implementation\"));\n \n     if let Some(annotation_span) = annotation_span {\n         err.span_note(annotation_span, \"required because of this annotation\");\n@@ -749,27 +747,28 @@ fn fn_sig_suggestion<'tcx>(\n             Some(match ty.kind() {\n                 ty::Param(_) if assoc.fn_has_self_parameter && i == 0 => \"self\".to_string(),\n                 ty::Ref(reg, ref_ty, mutability) if i == 0 => {\n-                    let reg = match &format!(\"{}\", reg)[..] {\n-                        \"'_\" | \"\" => String::new(),\n-                        reg => format!(\"{} \", reg),\n+                    let reg = format!(\"{reg} \");\n+                    let reg = match &reg[..] {\n+                        \"'_ \" | \" \" => \"\",\n+                        reg => reg,\n                     };\n                     if assoc.fn_has_self_parameter {\n                         match ref_ty.kind() {\n                             ty::Param(param) if param.name == kw::SelfUpper => {\n                                 format!(\"&{}{}self\", reg, mutability.prefix_str())\n                             }\n \n-                            _ => format!(\"self: {}\", ty),\n+                            _ => format!(\"self: {ty}\"),\n                         }\n                     } else {\n-                        format!(\"_: {}\", ty)\n+                        format!(\"_: {ty}\")\n                     }\n                 }\n                 _ => {\n                     if assoc.fn_has_self_parameter && i == 0 {\n-                        format!(\"self: {}\", ty)\n+                        format!(\"self: {ty}\")\n                     } else {\n-                        format!(\"_: {}\", ty)\n+                        format!(\"_: {ty}\")\n                     }\n                 }\n             })\n@@ -779,7 +778,7 @@ fn fn_sig_suggestion<'tcx>(\n         .collect::<Vec<String>>()\n         .join(\", \");\n     let output = sig.output();\n-    let output = if !output.is_unit() { format!(\" -> {}\", output) } else { String::new() };\n+    let output = if !output.is_unit() { format!(\" -> {output}\") } else { String::new() };\n \n     let unsafety = sig.unsafety.prefix_str();\n     let (generics, where_clauses) = bounds_from_generic_predicates(tcx, predicates);\n@@ -789,10 +788,7 @@ fn fn_sig_suggestion<'tcx>(\n     // lifetimes between the `impl` and the `trait`, but this should be good enough to\n     // fill in a significant portion of the missing code, and other subsequent\n     // suggestions can help the user fix the code.\n-    format!(\n-        \"{}fn {}{}({}){}{} {{ todo!() }}\",\n-        unsafety, ident, generics, args, output, where_clauses\n-    )\n+    format!(\"{unsafety}fn {ident}{generics}({args}){output}{where_clauses} {{ todo!() }}\")\n }\n \n /// Return placeholder code for the given associated item.\n@@ -830,7 +826,7 @@ fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>, sp: Span, d\n         .map(|variant| tcx.hir().span_if_local(variant.def_id).unwrap())\n         .collect();\n     let msg = format!(\"needs exactly one variant, but has {}\", adt.variants().len(),);\n-    let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {}\", msg);\n+    let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {msg}\");\n     err.span_label(sp, &msg);\n     if let [start @ .., end] = &*variant_spans {\n         for variant_span in start {\n@@ -850,7 +846,7 @@ fn bad_non_zero_sized_fields<'tcx>(\n     field_spans: impl Iterator<Item = Span>,\n     sp: Span,\n ) {\n-    let msg = format!(\"needs at most one non-zero-sized field, but has {}\", field_count);\n+    let msg = format!(\"needs at most one non-zero-sized field, but has {field_count}\");\n     let mut err = struct_span_err!(\n         tcx.sess,\n         sp,\n@@ -877,7 +873,7 @@ fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span) {\n         tcx.sess\n             .source_map()\n             .span_to_snippet(span)\n-            .map_or_else(|_| String::new(), |s| format!(\" `{}`\", s)),\n+            .map_or_else(|_| String::new(), |s| format!(\" `{s}`\",)),\n     )\n     .emit();\n }"}, {"sha": "f3dcf5fff74cc39bd4562826d12b1263616f6d73", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -405,16 +405,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut pat_ty = ty;\n         if let hir::ExprKind::Lit(Spanned { node: ast::LitKind::ByteStr(_), .. }) = lt.kind {\n             let expected = self.structurally_resolved_type(span, expected);\n-            if let ty::Ref(_, inner_ty, _) = expected.kind() {\n-                if matches!(inner_ty.kind(), ty::Slice(_)) {\n-                    let tcx = self.tcx;\n-                    trace!(?lt.hir_id.local_id, \"polymorphic byte string lit\");\n-                    self.typeck_results\n-                        .borrow_mut()\n-                        .treat_byte_string_as_slice\n-                        .insert(lt.hir_id.local_id);\n-                    pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n-                }\n+            if let ty::Ref(_, inner_ty, _) = expected.kind()\n+                && matches!(inner_ty.kind(), ty::Slice(_))\n+            {\n+                let tcx = self.tcx;\n+                trace!(?lt.hir_id.local_id, \"polymorphic byte string lit\");\n+                self.typeck_results\n+                    .borrow_mut()\n+                    .treat_byte_string_as_slice\n+                    .insert(lt.hir_id.local_id);\n+                pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n             }\n         }\n \n@@ -481,14 +481,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Unify each side with `expected`.\n         // Subtyping doesn't matter here, as the value is some kind of scalar.\n         let demand_eqtype = |x: &mut _, y| {\n-            if let Some((ref mut fail, x_ty, x_span)) = *x {\n-                if let Some(mut err) = self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti) {\n-                    if let Some((_, y_ty, y_span)) = y {\n-                        self.endpoint_has_type(&mut err, y_span, y_ty);\n-                    }\n-                    err.emit();\n-                    *fail = true;\n-                };\n+            if let Some((ref mut fail, x_ty, x_span)) = *x\n+                && let Some(mut err) = self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti)\n+            {\n+                if let Some((_, y_ty, y_span)) = y {\n+                    self.endpoint_has_type(&mut err, y_span, y_ty);\n+                }\n+                err.emit();\n+                *fail = true;\n             }\n         };\n         demand_eqtype(&mut lhs, rhs);\n@@ -630,7 +630,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some(mut err) = self.demand_eqtype_pat_diag(span, var_ty, ty, ti) {\n             let hir = self.tcx.hir();\n             let var_ty = self.resolve_vars_with_obligations(var_ty);\n-            let msg = format!(\"first introduced with type `{}` here\", var_ty);\n+            let msg = format!(\"first introduced with type `{var_ty}` here\");\n             err.span_label(hir.span(var_id), msg);\n             let in_match = hir.parent_iter(var_id).any(|(_, n)| {\n                 matches!(\n@@ -665,8 +665,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 {\n                     err.span_suggestion(\n                         *span,\n-                        &format!(\"did you mean `{}`\", snippet),\n-                        format!(\" &{}\", expected),\n+                        &format!(\"did you mean `{snippet}`\"),\n+                        format!(\" &{expected}\"),\n                         Applicability::MachineApplicable,\n                     );\n                 }\n@@ -701,7 +701,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"type `{}` cannot be dereferenced\",\n                         type_str\n                     );\n-                    err.span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str));\n+                    err.span_label(span, format!(\"type `{type_str}` cannot be dereferenced\"));\n                     if self.tcx.sess.teach(&err.get_code().unwrap()) {\n                         err.note(CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ);\n                     }\n@@ -918,7 +918,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 path_str\n             );\n \n-            let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n+            let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{msg}\");\n             match res {\n                 Res::Def(DefKind::Fn | DefKind::AssocFn, _) => {\n                     err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n@@ -1396,8 +1396,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     pat.span,\n                     E0769,\n-                    \"tuple variant `{}` written as struct variant\",\n-                    path\n+                    \"tuple variant `{path}` written as struct variant\",\n                 );\n                 err.span_suggestion_verbose(\n                     qpath.span().shrink_to_hi().to(pat.span.shrink_to_hi()),\n@@ -1422,8 +1421,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             sess,\n             pat.span,\n             E0638,\n-            \"`..` required with {} marked as non-exhaustive\",\n-            descr\n+            \"`..` required with {descr} marked as non-exhaustive\",\n         );\n         err.span_suggestion_verbose(\n             sp_comma,\n@@ -1442,8 +1440,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"field `{}` bound multiple times in the pattern\",\n             ident\n         )\n-        .span_label(span, format!(\"multiple uses of `{}` in pattern\", ident))\n-        .span_label(other_field, format!(\"first use of `{}`\", ident))\n+        .span_label(span, format!(\"multiple uses of `{ident}` in pattern\"))\n+        .span_label(other_field, format!(\"first use of `{ident}`\"))\n         .emit();\n     }\n "}, {"sha": "2e0f37eba232d4762d11b13ae1880f6b4fc6d05d", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -74,20 +74,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(ty);\n         let mut err = self.tcx.sess.struct_span_err(\n             span,\n-            &format!(\"negative integers cannot be used to index on a `{}`\", ty),\n+            &format!(\"negative integers cannot be used to index on a `{ty}`\"),\n         );\n-        err.span_label(span, &format!(\"cannot use a negative integer for indexing on `{}`\", ty));\n+        err.span_label(span, &format!(\"cannot use a negative integer for indexing on `{ty}`\"));\n         if let (hir::ExprKind::Path(..), Ok(snippet)) =\n             (&base_expr.kind, self.tcx.sess.source_map().span_to_snippet(base_expr.span))\n         {\n             // `foo[-1]` to `foo[foo.len() - 1]`\n             err.span_suggestion_verbose(\n                 span.shrink_to_lo(),\n                 &format!(\n-                    \"to access an element starting from the end of the `{}`, compute the index\",\n-                    ty,\n+                    \"to access an element starting from the end of the `{ty}`, compute the index\",\n                 ),\n-                format!(\"{}.len() \", snippet),\n+                format!(\"{snippet}.len() \"),\n                 Applicability::MachineApplicable,\n             );\n         }\n@@ -314,32 +313,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.typeck_results.borrow_mut().adjustments_mut().remove(expr.hir_id);\n             if let Some(mut adjustments) = previous_adjustments {\n                 for adjustment in &mut adjustments {\n-                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n-                        if let Some(ok) = self.try_mutable_overloaded_place_op(\n+                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind\n+                        && let Some(ok) = self.try_mutable_overloaded_place_op(\n                             expr.span,\n                             source,\n                             &[],\n                             PlaceOp::Deref,\n-                        ) {\n-                            let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n-                                *deref = OverloadedDeref { region, mutbl, span: deref.span };\n-                            }\n-                            // If this is a union field, also throw an error for `DerefMut` of `ManuallyDrop` (see RFC 2514).\n-                            // This helps avoid accidental drops.\n-                            if inside_union\n-                                && source.ty_adt_def().map_or(false, |adt| adt.is_manually_drop())\n-                            {\n-                                let mut err = self.tcx.sess.struct_span_err(\n-                                    expr.span,\n-                                    \"not automatically applying `DerefMut` on `ManuallyDrop` union field\",\n-                                );\n-                                err.help(\n-                                    \"writing to this reference calls the destructor for the old value\",\n-                                );\n-                                err.help(\"add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\");\n-                                err.emit();\n-                            }\n+                        )\n+                    {\n+                        let method = self.register_infer_ok_obligations(ok);\n+                        if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n+                            *deref = OverloadedDeref { region, mutbl, span: deref.span };\n+                        }\n+                        // If this is a union field, also throw an error for `DerefMut` of `ManuallyDrop` (see RFC 2514).\n+                        // This helps avoid accidental drops.\n+                        if inside_union\n+                            && source.ty_adt_def().map_or(false, |adt| adt.is_manually_drop())\n+                        {\n+                            let mut err = self.tcx.sess.struct_span_err(\n+                                expr.span,\n+                                \"not automatically applying `DerefMut` on `ManuallyDrop` union field\",\n+                            );\n+                            err.help(\n+                                \"writing to this reference calls the destructor for the old value\",\n+                            );\n+                            err.help(\"add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\");\n+                            err.emit();\n                         }\n                     }\n                     source = adjustment.target;"}, {"sha": "e37e83e748733ac9b074b9ac15fb7bfc234fb886", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -317,13 +317,8 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.body_id = body_id.hir_id;\n         self.body_owner = self.tcx.hir().body_owner_def_id(body_id);\n \n-        let fn_sig = {\n-            match self.typeck_results.borrow().liberated_fn_sigs().get(id) {\n-                Some(f) => *f,\n-                None => {\n-                    bug!(\"No fn-sig entry for id={:?}\", id);\n-                }\n-            }\n+        let Some(fn_sig) = self.typeck_results.borrow().liberated_fn_sigs().get(id) else {\n+            bug!(\"No fn-sig entry for id={:?}\", id);\n         };\n \n         // Collect the types from which we create inferred bounds.\n@@ -642,12 +637,9 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id, .. }| {\n                 // `ref x` pattern\n-                if let PatKind::Binding(..) = kind {\n-                    if let Some(ty::BindByReference(mutbl)) =\n-                        mc.typeck_results.extract_binding_mode(self.tcx.sess, *hir_id, *span)\n-                    {\n-                        self.link_region_from_node_type(*span, *hir_id, mutbl, sub_cmt);\n-                    }\n+                if let PatKind::Binding(..) = kind\n+                    && let Some(ty::BindByReference(mutbl)) = mc.typeck_results.extract_binding_mode(self.tcx.sess, *hir_id, *span) {\n+                    self.link_region_from_node_type(*span, *hir_id, mutbl, sub_cmt);\n                 }\n             })\n         }));"}, {"sha": "9dbb813293263af994eb12d4f17997860c482cbc", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -862,7 +862,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             diagnostics_builder.span_suggestion(\n                                 closure_body_span.with_lo(closure_body_span.lo() + BytePos::from_usize(line1.len())).shrink_to_lo(),\n                                 &diagnostic_msg,\n-                                format!(\"\\n{}{};\", indent, migration_string),\n+                                format!(\"\\n{indent}{migration_string};\"),\n                                 Applicability::MachineApplicable,\n                             );\n                         } else if line1.starts_with('{') {\n@@ -873,7 +873,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             diagnostics_builder.span_suggestion(\n                                 closure_body_span.with_lo(closure_body_span.lo() + BytePos(1)).shrink_to_lo(),\n                                 &diagnostic_msg,\n-                                format!(\" {};\", migration_string),\n+                                format!(\" {migration_string};\"),\n                                 Applicability::MachineApplicable,\n                             );\n                         } else {\n@@ -882,7 +882,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             diagnostics_builder.multipart_suggestion(\n                                 &diagnostic_msg,\n                                 vec![\n-                                    (closure_body_span.shrink_to_lo(), format!(\"{{ {}; \", migration_string)),\n+                                    (closure_body_span.shrink_to_lo(), format!(\"{{ {migration_string}; \")),\n                                     (closure_body_span.shrink_to_hi(), \" }\".to_string()),\n                                 ],\n                                 Applicability::MachineApplicable\n@@ -1527,7 +1527,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx.sess.struct_span_err(closure_span, \"First Pass analysis includes:\");\n             for (place, capture_info) in capture_information {\n                 let capture_str = construct_capture_info_string(self.tcx, place, capture_info);\n-                let output_str = format!(\"Capturing {}\", capture_str);\n+                let output_str = format!(\"Capturing {capture_str}\");\n \n                 let span =\n                     capture_info.path_expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n@@ -1552,7 +1552,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                         let capture_str =\n                             construct_capture_info_string(self.tcx, place, capture_info);\n-                        let output_str = format!(\"Min Capture {}\", capture_str);\n+                        let output_str = format!(\"Min Capture {capture_str}\");\n \n                         if capture.info.path_expr_id != capture.info.capture_kind_expr_id {\n                             let path_span = capture_info\n@@ -1969,7 +1969,7 @@ fn construct_place_string<'tcx>(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String\n         projections_str.push_str(proj.as_str());\n     }\n \n-    format!(\"{}[{}]\", variable_name, projections_str)\n+    format!(\"{variable_name}[{projections_str}]\")\n }\n \n fn construct_capture_kind_reason_string<'tcx>(\n@@ -1984,13 +1984,13 @@ fn construct_capture_kind_reason_string<'tcx>(\n         ty::UpvarCapture::ByRef(kind) => format!(\"{:?}\", kind),\n     };\n \n-    format!(\"{} captured as {} here\", place_str, capture_kind_str)\n+    format!(\"{place_str} captured as {capture_kind_str} here\")\n }\n \n fn construct_path_string<'tcx>(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n     let place_str = construct_place_string(tcx, place);\n \n-    format!(\"{} used here\", place_str)\n+    format!(\"{place_str} used here\")\n }\n \n fn construct_capture_info_string<'tcx>(\n@@ -2004,7 +2004,7 @@ fn construct_capture_info_string<'tcx>(\n         ty::UpvarCapture::ByValue => \"ByValue\".into(),\n         ty::UpvarCapture::ByRef(kind) => format!(\"{:?}\", kind),\n     };\n-    format!(\"{} -> {}\", place_str, capture_kind_str)\n+    format!(\"{place_str} -> {capture_kind_str}\")\n }\n \n fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n@@ -2035,16 +2035,16 @@ fn migration_suggestion_for_2229(\n         .collect::<Vec<_>>();\n \n     let migration_ref_concat =\n-        need_migrations_variables.iter().map(|v| format!(\"&{}\", v)).collect::<Vec<_>>().join(\", \");\n+        need_migrations_variables.iter().map(|v| format!(\"&{v}\")).collect::<Vec<_>>().join(\", \");\n \n     let migration_string = if 1 == need_migrations.len() {\n-        format!(\"let _ = {}\", migration_ref_concat)\n+        format!(\"let _ = {migration_ref_concat}\")\n     } else {\n-        format!(\"let _ = ({})\", migration_ref_concat)\n+        format!(\"let _ = ({migration_ref_concat})\")\n     };\n \n     let migrated_variables_concat =\n-        need_migrations_variables.iter().map(|v| format!(\"`{}`\", v)).collect::<Vec<_>>().join(\", \");\n+        need_migrations_variables.iter().map(|v| format!(\"`{v}`\")).collect::<Vec<_>>().join(\", \");\n \n     (migration_string, migrated_variables_concat)\n }"}, {"sha": "4e3e32670e96e0b29f32190317bc55ce924a6f0b", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa281fdf65f63da72abfef83abeb8bea37fddfd9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=fa281fdf65f63da72abfef83abeb8bea37fddfd9", "patch": "@@ -230,8 +230,7 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                         .struct_span_err(\n                             self_ty.span,\n                             &format!(\n-                                \"first argument of `call` in `{}` lang item must be a reference\",\n-                                fn_lang_item_name\n+                                \"first argument of `call` in `{fn_lang_item_name}` lang item must be a reference\",\n                             ),\n                         )\n                         .emit();\n@@ -241,8 +240,7 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     .struct_span_err(\n                         *span,\n                         &format!(\n-                            \"`call` function in `{}` lang item takes exactly two arguments\",\n-                            fn_lang_item_name\n+                            \"`call` function in `{fn_lang_item_name}` lang item takes exactly two arguments\",\n                         ),\n                     )\n                     .emit();\n@@ -252,8 +250,7 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                 .struct_span_err(\n                     trait_item.span,\n                     &format!(\n-                        \"`call` trait item in `{}` lang item must be a function\",\n-                        fn_lang_item_name\n+                        \"`call` trait item in `{fn_lang_item_name}` lang item must be a function\",\n                     ),\n                 )\n                 .emit();\n@@ -432,7 +429,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n             );\n             err.span_suggestion(\n                 gat_item_hir.generics.where_clause.tail_span_for_suggestion(),\n-                &format!(\"add the required where clause{}\", plural),\n+                &format!(\"add the required where clause{plural}\"),\n                 suggestion,\n                 Applicability::MachineApplicable,\n             );\n@@ -523,7 +520,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n             // In our example, requires that `Self: 'a`\n             if ty_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *ty, *region_a) {\n                 debug!(?ty_idx, ?region_a_idx);\n-                debug!(\"required clause: {} must outlive {}\", ty, region_a);\n+                debug!(\"required clause: {ty} must outlive {region_a}\");\n                 // Translate into the generic parameters of the GAT. In\n                 // our example, the type was `Self`, which will also be\n                 // `Self` in the GAT.\n@@ -560,7 +557,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n             }\n             if region_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *region_a, *region_b) {\n                 debug!(?region_a_idx, ?region_b_idx);\n-                debug!(\"required clause: {} must outlive {}\", region_a, region_b);\n+                debug!(\"required clause: {region_a} must outlive {region_b}\");\n                 // Translate into the generic parameters of the GAT.\n                 let region_a_param = gat_generics.param_at(*region_a_idx, tcx);\n                 let region_a_param =\n@@ -869,7 +866,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                         )\n                         .span_label(\n                             hir_ty.span,\n-                            format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n+                            format!(\"`{ty}` doesn't derive both `PartialEq` and `Eq`\"),\n                         )\n                         .emit();\n                     }\n@@ -884,7 +881,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                     ty::RawPtr(_) => Some(\"raw pointers\"),\n                     _ => {\n                         is_ptr = false;\n-                        err_ty_str = format!(\"`{}`\", ty);\n+                        err_ty_str = format!(\"`{ty}`\");\n                         Some(err_ty_str.as_str())\n                     }\n                 };\n@@ -894,16 +891,14 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                         tcx.sess.span_err(\n                             hir_ty.span,\n                             &format!(\n-                                \"using {} as const generic parameters is forbidden\",\n-                                unsupported_type\n+                                \"using {unsupported_type} as const generic parameters is forbidden\",\n                             ),\n                         );\n                     } else {\n                         let mut err = tcx.sess.struct_span_err(\n                             hir_ty.span,\n                             &format!(\n-                                \"{} is forbidden as the type of a const generic parameter\",\n-                                unsupported_type\n+                                \"{unsupported_type} is forbidden as the type of a const generic parameter\",\n                             ),\n                         );\n                         err.note(\"the only supported types are integers, `bool` and `char`\");\n@@ -1567,9 +1562,8 @@ fn check_method_receiver<'fcx, 'tcx>(\n                     sym::arbitrary_self_types,\n                     span,\n                     &format!(\n-                        \"`{}` cannot be used as the type of `self` without \\\n+                        \"`{receiver_ty}` cannot be used as the type of `self` without \\\n                          the `arbitrary_self_types` feature\",\n-                        receiver_ty,\n                     ),\n                 )\n                 .help(HELP_FOR_SELF_TYPE)\n@@ -1587,8 +1581,7 @@ fn e0307<'tcx>(fcx: &FnCtxt<'_, 'tcx>, span: Span, receiver_ty: Ty<'_>) {\n         fcx.tcx.sess.diagnostic(),\n         span,\n         E0307,\n-        \"invalid `self` parameter type: {}\",\n-        receiver_ty,\n+        \"invalid `self` parameter type: {receiver_ty}\"\n     )\n     .note(\"type of `self` must be `Self` or a type that dereferences to it\")\n     .help(HELP_FOR_SELF_TYPE)\n@@ -1793,7 +1786,7 @@ fn report_bivariance(\n             tcx.def_path_str(def_id),\n         )\n     } else {\n-        format!(\"consider removing `{}` or referring to it in a field\", param_name)\n+        format!(\"consider removing `{param_name}` or referring to it in a field\")\n     };\n     err.help(&msg);\n \n@@ -1993,8 +1986,7 @@ fn error_392(\n     span: Span,\n     param_name: Symbol,\n ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n-    let mut err =\n-        struct_span_err!(tcx.sess, span, E0392, \"parameter `{}` is never used\", param_name);\n+    let mut err = struct_span_err!(tcx.sess, span, E0392, \"parameter `{param_name}` is never used\");\n     err.span_label(span, \"unused parameter\");\n     err\n }"}]}