{"sha": "3dfb6ca8e26f6bb9232a4c6a7afef90f4abf54dd", "node_id": "C_kwDOAAsO6NoAKDNkZmI2Y2E4ZTI2ZjZiYjkyMzJhNGM2YTdhZmVmOTBmNGFiZjU0ZGQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-28T16:25:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-28T16:25:50Z"}, "message": "Rollup merge of #105006 - RalfJung:scalar-pair-alignment, r=eddyb\n\nstricter alignment enforcement for ScalarPair\n\n`@eddyb` [indicated](https://github.com/rust-lang/rust/pull/103926#discussion_r1033315005) that alignment violating this check might be a bug. So let's see what the test suite says.\n\n(Only the 2nd commit actually changes behavior... but I couldn't not do that other cleanup.^^)\n\nDoes the PR CI runner even enable debug assertions though...?", "tree": {"sha": "0f33b88b1a3842bed80689bb9fd4b74506071d52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f33b88b1a3842bed80689bb9fd4b74506071d52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dfb6ca8e26f6bb9232a4c6a7afef90f4abf54dd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjhOEOCRBK7hj4Ov3rIwAAcGkIAJR7bZC+vnq3JAEIyPzD83bi\nWkHTq3c0om9/998JVThz3XS21gh/2GLzTtZ1XjY67SzuLF0i+UwHI5AQdrdmFYly\n9JnCju9CnfQDBjYSLwH6N2mvvUNwcIkO/y6FWn0OT9obmKlZkw9UeVyJe7ZUIXJs\nbaQnIBvWm4vO9aM1wYPHsu6LUwQQQhVvT34Ef3P73/DxmFv+NtSIe0DA7jK3dwjz\nCk6VeqpfRgbPpgH6ilkup14VCLfuXCquvm2TSEaEy66RUXynNN0um5NLGMU2njuW\nnRy0+W/Q5zEpz+RUmN7bOgSYxKRhUp9cs2btDdUuBLcD5UNLoTZEutkRrLVKCF8=\n=D3jp\n-----END PGP SIGNATURE-----\n", "payload": "tree 0f33b88b1a3842bed80689bb9fd4b74506071d52\nparent 95de06bb5a8168d61699e621b3af8af9ddeab36f\nparent 891a4da4f3cf99d5ee6413d9a6948031306179af\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1669652750 +0100\ncommitter GitHub <noreply@github.com> 1669652750 +0100\n\nRollup merge of #105006 - RalfJung:scalar-pair-alignment, r=eddyb\n\nstricter alignment enforcement for ScalarPair\n\n`@eddyb` [indicated](https://github.com/rust-lang/rust/pull/103926#discussion_r1033315005) that alignment violating this check might be a bug. So let's see what the test suite says.\n\n(Only the 2nd commit actually changes behavior... but I couldn't not do that other cleanup.^^)\n\nDoes the PR CI runner even enable debug assertions though...?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dfb6ca8e26f6bb9232a4c6a7afef90f4abf54dd", "html_url": "https://github.com/rust-lang/rust/commit/3dfb6ca8e26f6bb9232a4c6a7afef90f4abf54dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dfb6ca8e26f6bb9232a4c6a7afef90f4abf54dd/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95de06bb5a8168d61699e621b3af8af9ddeab36f", "url": "https://api.github.com/repos/rust-lang/rust/commits/95de06bb5a8168d61699e621b3af8af9ddeab36f", "html_url": "https://github.com/rust-lang/rust/commit/95de06bb5a8168d61699e621b3af8af9ddeab36f"}, {"sha": "891a4da4f3cf99d5ee6413d9a6948031306179af", "url": "https://api.github.com/repos/rust-lang/rust/commits/891a4da4f3cf99d5ee6413d9a6948031306179af", "html_url": "https://github.com/rust-lang/rust/commit/891a4da4f3cf99d5ee6413d9a6948031306179af"}], "stats": {"total": 534, "additions": 272, "deletions": 262}, "files": [{"sha": "a5311dbd1b77025b32d282d9cf689d70c5e53fcd", "filename": "compiler/rustc_ty_utils/src/layout_sanity_check.rs", "status": "modified", "additions": 272, "deletions": 262, "changes": 534, "blob_url": "https://github.com/rust-lang/rust/blob/3dfb6ca8e26f6bb9232a4c6a7afef90f4abf54dd/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dfb6ca8e26f6bb9232a4c6a7afef90f4abf54dd/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs?ref=3dfb6ca8e26f6bb9232a4c6a7afef90f4abf54dd", "patch": "@@ -20,283 +20,293 @@ pub(super) fn sanity_check_layout<'tcx>(\n         bug!(\"size is not a multiple of align, in the following layout:\\n{layout:#?}\");\n     }\n \n-    if cfg!(debug_assertions) {\n-        /// Yields non-ZST fields of the type\n-        fn non_zst_fields<'tcx, 'a>(\n-            cx: &'a LayoutCx<'tcx, TyCtxt<'tcx>>,\n-            layout: &'a TyAndLayout<'tcx>,\n-        ) -> impl Iterator<Item = (Size, TyAndLayout<'tcx>)> + 'a {\n-            (0..layout.layout.fields().count()).filter_map(|i| {\n-                let field = layout.field(cx, i);\n-                // Also checking `align == 1` here leads to test failures in\n-                // `layout/zero-sized-array-union.rs`, where a type has a zero-size field with\n-                // alignment 4 that still gets ignored during layout computation (which is okay\n-                // since other fields already force alignment 4).\n-                let zst = field.is_zst();\n-                (!zst).then(|| (layout.fields.offset(i), field))\n-            })\n-        }\n+    if !cfg!(debug_assertions) {\n+        // Stop here, the rest is kind of expensive.\n+        return;\n+    }\n \n-        fn skip_newtypes<'tcx>(\n-            cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n-            layout: &TyAndLayout<'tcx>,\n-        ) -> TyAndLayout<'tcx> {\n-            if matches!(layout.layout.variants(), Variants::Multiple { .. }) {\n-                // Definitely not a newtype of anything.\n-                return *layout;\n-            }\n-            let mut fields = non_zst_fields(cx, layout);\n-            let Some(first) = fields.next() else {\n-                // No fields here, so this could be a primitive or enum -- either way it's not a newtype around a thing\n-                return *layout\n-            };\n-            if fields.next().is_none() {\n-                let (offset, first) = first;\n-                if offset == Size::ZERO && first.layout.size() == layout.size {\n-                    // This is a newtype, so keep recursing.\n-                    // FIXME(RalfJung): I don't think it would be correct to do any checks for\n-                    // alignment here, so we don't. Is that correct?\n-                    return skip_newtypes(cx, &first);\n-                }\n+    /// Yields non-ZST fields of the type\n+    fn non_zst_fields<'tcx, 'a>(\n+        cx: &'a LayoutCx<'tcx, TyCtxt<'tcx>>,\n+        layout: &'a TyAndLayout<'tcx>,\n+    ) -> impl Iterator<Item = (Size, TyAndLayout<'tcx>)> + 'a {\n+        (0..layout.layout.fields().count()).filter_map(|i| {\n+            let field = layout.field(cx, i);\n+            // Also checking `align == 1` here leads to test failures in\n+            // `layout/zero-sized-array-union.rs`, where a type has a zero-size field with\n+            // alignment 4 that still gets ignored during layout computation (which is okay\n+            // since other fields already force alignment 4).\n+            let zst = field.is_zst();\n+            (!zst).then(|| (layout.fields.offset(i), field))\n+        })\n+    }\n+\n+    fn skip_newtypes<'tcx>(\n+        cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+        layout: &TyAndLayout<'tcx>,\n+    ) -> TyAndLayout<'tcx> {\n+        if matches!(layout.layout.variants(), Variants::Multiple { .. }) {\n+            // Definitely not a newtype of anything.\n+            return *layout;\n+        }\n+        let mut fields = non_zst_fields(cx, layout);\n+        let Some(first) = fields.next() else {\n+            // No fields here, so this could be a primitive or enum -- either way it's not a newtype around a thing\n+            return *layout\n+        };\n+        if fields.next().is_none() {\n+            let (offset, first) = first;\n+            if offset == Size::ZERO && first.layout.size() == layout.size {\n+                // This is a newtype, so keep recursing.\n+                // FIXME(RalfJung): I don't think it would be correct to do any checks for\n+                // alignment here, so we don't. Is that correct?\n+                return skip_newtypes(cx, &first);\n             }\n-            // No more newtypes here.\n-            *layout\n         }\n+        // No more newtypes here.\n+        *layout\n+    }\n \n-        fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n-            match layout.layout.abi() {\n-                Abi::Scalar(scalar) => {\n-                    // No padding in scalars.\n-                    let size = scalar.size(cx);\n-                    let align = scalar.align(cx).abi;\n-                    assert_eq!(\n-                        layout.layout.size(),\n-                        size,\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    assert_eq!(\n-                        layout.layout.align().abi,\n-                        align,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    // Check that this matches the underlying field.\n-                    let inner = skip_newtypes(cx, layout);\n-                    assert!(\n-                        matches!(inner.layout.abi(), Abi::Scalar(_)),\n-                        \"`Scalar` type {} is newtype around non-`Scalar` type {}\",\n-                        layout.ty,\n-                        inner.ty\n-                    );\n-                    match inner.layout.fields() {\n-                        FieldsShape::Primitive => {\n-                            // Fine.\n-                        }\n-                        FieldsShape::Union(..) => {\n-                            // FIXME: I guess we could also check something here? Like, look at all fields?\n-                            return;\n-                        }\n-                        FieldsShape::Arbitrary { .. } => {\n-                            // Should be an enum, the only field is the discriminant.\n-                            assert!(\n-                                inner.ty.is_enum(),\n-                                \"`Scalar` layout for non-primitive non-enum type {}\",\n-                                inner.ty\n-                            );\n-                            assert_eq!(\n-                                inner.layout.fields().count(),\n-                                1,\n-                                \"`Scalar` layout for multiple-field type in {inner:#?}\",\n-                            );\n-                            let offset = inner.layout.fields().offset(0);\n-                            let field = inner.field(cx, 0);\n-                            // The field should be at the right offset, and match the `scalar` layout.\n-                            assert_eq!(\n-                                offset,\n-                                Size::ZERO,\n-                                \"`Scalar` field at non-0 offset in {inner:#?}\",\n-                            );\n-                            assert_eq!(\n-                                field.size, size,\n-                                \"`Scalar` field with bad size in {inner:#?}\",\n-                            );\n-                            assert_eq!(\n-                                field.align.abi, align,\n-                                \"`Scalar` field with bad align in {inner:#?}\",\n-                            );\n-                            assert!(\n-                                matches!(field.abi, Abi::Scalar(_)),\n-                                \"`Scalar` field with bad ABI in {inner:#?}\",\n-                            );\n-                        }\n-                        _ => {\n-                            panic!(\"`Scalar` layout for non-primitive non-enum type {}\", inner.ty);\n-                        }\n+    fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n+        match layout.layout.abi() {\n+            Abi::Scalar(scalar) => {\n+                // No padding in scalars.\n+                let size = scalar.size(cx);\n+                let align = scalar.align(cx).abi;\n+                assert_eq!(\n+                    layout.layout.size(),\n+                    size,\n+                    \"size mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                assert_eq!(\n+                    layout.layout.align().abi,\n+                    align,\n+                    \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                // Check that this matches the underlying field.\n+                let inner = skip_newtypes(cx, layout);\n+                assert!(\n+                    matches!(inner.layout.abi(), Abi::Scalar(_)),\n+                    \"`Scalar` type {} is newtype around non-`Scalar` type {}\",\n+                    layout.ty,\n+                    inner.ty\n+                );\n+                match inner.layout.fields() {\n+                    FieldsShape::Primitive => {\n+                        // Fine.\n                     }\n-                }\n-                Abi::ScalarPair(scalar1, scalar2) => {\n-                    // Sanity-check scalar pairs. These are a bit more flexible and support\n-                    // padding, but we can at least ensure both fields actually fit into the layout\n-                    // and the alignment requirement has not been weakened.\n-                    let size1 = scalar1.size(cx);\n-                    let align1 = scalar1.align(cx).abi;\n-                    let size2 = scalar2.size(cx);\n-                    let align2 = scalar2.align(cx).abi;\n-                    assert!(\n-                        layout.layout.align().abi >= cmp::max(align1, align2),\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\",\n-                    );\n-                    let field2_offset = size1.align_to(align2);\n-                    assert!(\n-                        layout.layout.size() >= field2_offset + size2,\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    // Check that the underlying pair of fields matches.\n-                    let inner = skip_newtypes(cx, layout);\n-                    assert!(\n-                        matches!(inner.layout.abi(), Abi::ScalarPair(..)),\n-                        \"`ScalarPair` type {} is newtype around non-`ScalarPair` type {}\",\n-                        layout.ty,\n-                        inner.ty\n-                    );\n-                    if matches!(inner.layout.variants(), Variants::Multiple { .. }) {\n-                        // FIXME: ScalarPair for enums is enormously complicated and it is very hard\n-                        // to check anything about them.\n+                    FieldsShape::Union(..) => {\n+                        // FIXME: I guess we could also check something here? Like, look at all fields?\n                         return;\n                     }\n-                    match inner.layout.fields() {\n-                        FieldsShape::Arbitrary { .. } => {\n-                            // Checked below.\n-                        }\n-                        FieldsShape::Union(..) => {\n-                            // FIXME: I guess we could also check something here? Like, look at all fields?\n-                            return;\n-                        }\n-                        _ => {\n-                            panic!(\"`ScalarPair` layout with unexpected field shape in {inner:#?}\");\n-                        }\n+                    FieldsShape::Arbitrary { .. } => {\n+                        // Should be an enum, the only field is the discriminant.\n+                        assert!(\n+                            inner.ty.is_enum(),\n+                            \"`Scalar` layout for non-primitive non-enum type {}\",\n+                            inner.ty\n+                        );\n+                        assert_eq!(\n+                            inner.layout.fields().count(),\n+                            1,\n+                            \"`Scalar` layout for multiple-field type in {inner:#?}\",\n+                        );\n+                        let offset = inner.layout.fields().offset(0);\n+                        let field = inner.field(cx, 0);\n+                        // The field should be at the right offset, and match the `scalar` layout.\n+                        assert_eq!(\n+                            offset,\n+                            Size::ZERO,\n+                            \"`Scalar` field at non-0 offset in {inner:#?}\",\n+                        );\n+                        assert_eq!(field.size, size, \"`Scalar` field with bad size in {inner:#?}\",);\n+                        assert_eq!(\n+                            field.align.abi, align,\n+                            \"`Scalar` field with bad align in {inner:#?}\",\n+                        );\n+                        assert!(\n+                            matches!(field.abi, Abi::Scalar(_)),\n+                            \"`Scalar` field with bad ABI in {inner:#?}\",\n+                        );\n+                    }\n+                    _ => {\n+                        panic!(\"`Scalar` layout for non-primitive non-enum type {}\", inner.ty);\n                     }\n-                    let mut fields = non_zst_fields(cx, &inner);\n-                    let (offset1, field1) = fields.next().unwrap_or_else(|| {\n-                        panic!(\"`ScalarPair` layout for type with not even one non-ZST field: {inner:#?}\")\n-                    });\n-                    let (offset2, field2) = fields.next().unwrap_or_else(|| {\n-                        panic!(\"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\")\n-                    });\n-                    assert!(\n-                        fields.next().is_none(),\n-                        \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n-                    );\n-                    // The fields might be in opposite order.\n-                    let (offset1, field1, offset2, field2) = if offset1 <= offset2 {\n-                        (offset1, field1, offset2, field2)\n-                    } else {\n-                        (offset2, field2, offset1, field1)\n-                    };\n-                    // The fields should be at the right offset, and match the `scalar` layout.\n-                    assert_eq!(\n-                        offset1,\n-                        Size::ZERO,\n-                        \"`ScalarPair` first field at non-0 offset in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field1.size, size1,\n-                        \"`ScalarPair` first field with bad size in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field1.align.abi, align1,\n-                        \"`ScalarPair` first field with bad align in {inner:#?}\",\n-                    );\n-                    assert!(\n-                        matches!(field1.abi, Abi::Scalar(_)),\n-                        \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        offset2, field2_offset,\n-                        \"`ScalarPair` second field at bad offset in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field2.size, size2,\n-                        \"`ScalarPair` second field with bad size in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field2.align.abi, align2,\n-                        \"`ScalarPair` second field with bad align in {inner:#?}\",\n-                    );\n-                    assert!(\n-                        matches!(field2.abi, Abi::Scalar(_)),\n-                        \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n-                    );\n                 }\n-                Abi::Vector { count, element } => {\n-                    // No padding in vectors. Alignment can be strengthened, though.\n-                    assert!(\n-                        layout.layout.align().abi >= element.align(cx).abi,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    let size = element.size(cx) * count;\n-                    assert_eq!(\n-                        layout.layout.size(),\n-                        size.align_to(cx.data_layout().vector_align(size).abi),\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n+            }\n+            Abi::ScalarPair(scalar1, scalar2) => {\n+                // Sanity-check scalar pairs. Computing the expected size and alignment is a bit of work.\n+                let size1 = scalar1.size(cx);\n+                let align1 = scalar1.align(cx).abi;\n+                let size2 = scalar2.size(cx);\n+                let align2 = scalar2.align(cx).abi;\n+                let align = cmp::max(align1, align2);\n+                let field2_offset = size1.align_to(align2);\n+                let size = (field2_offset + size2).align_to(align);\n+                assert_eq!(\n+                    layout.layout.size(),\n+                    size,\n+                    \"size mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                assert_eq!(\n+                    layout.layout.align().abi,\n+                    align,\n+                    \"alignment mismatch between ABI and layout in {layout:#?}\",\n+                );\n+                // Check that the underlying pair of fields matches.\n+                let inner = skip_newtypes(cx, layout);\n+                assert!(\n+                    matches!(inner.layout.abi(), Abi::ScalarPair(..)),\n+                    \"`ScalarPair` type {} is newtype around non-`ScalarPair` type {}\",\n+                    layout.ty,\n+                    inner.ty\n+                );\n+                if matches!(inner.layout.variants(), Variants::Multiple { .. }) {\n+                    // FIXME: ScalarPair for enums is enormously complicated and it is very hard\n+                    // to check anything about them.\n+                    return;\n+                }\n+                match inner.layout.fields() {\n+                    FieldsShape::Arbitrary { .. } => {\n+                        // Checked below.\n+                    }\n+                    FieldsShape::Union(..) => {\n+                        // FIXME: I guess we could also check something here? Like, look at all fields?\n+                        return;\n+                    }\n+                    _ => {\n+                        panic!(\"`ScalarPair` layout with unexpected field shape in {inner:#?}\");\n+                    }\n                 }\n-                Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n+                let mut fields = non_zst_fields(cx, &inner);\n+                let (offset1, field1) = fields.next().unwrap_or_else(|| {\n+                    panic!(\n+                        \"`ScalarPair` layout for type with not even one non-ZST field: {inner:#?}\"\n+                    )\n+                });\n+                let (offset2, field2) = fields.next().unwrap_or_else(|| {\n+                    panic!(\n+                        \"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\"\n+                    )\n+                });\n+                assert!(\n+                    fields.next().is_none(),\n+                    \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n+                );\n+                // The fields might be in opposite order.\n+                let (offset1, field1, offset2, field2) = if offset1 <= offset2 {\n+                    (offset1, field1, offset2, field2)\n+                } else {\n+                    (offset2, field2, offset1, field1)\n+                };\n+                // The fields should be at the right offset, and match the `scalar` layout.\n+                assert_eq!(\n+                    offset1,\n+                    Size::ZERO,\n+                    \"`ScalarPair` first field at non-0 offset in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field1.size, size1,\n+                    \"`ScalarPair` first field with bad size in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field1.align.abi, align1,\n+                    \"`ScalarPair` first field with bad align in {inner:#?}\",\n+                );\n+                assert!(\n+                    matches!(field1.abi, Abi::Scalar(_)),\n+                    \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    offset2, field2_offset,\n+                    \"`ScalarPair` second field at bad offset in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field2.size, size2,\n+                    \"`ScalarPair` second field with bad size in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field2.align.abi, align2,\n+                    \"`ScalarPair` second field with bad align in {inner:#?}\",\n+                );\n+                assert!(\n+                    matches!(field2.abi, Abi::Scalar(_)),\n+                    \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n+                );\n             }\n+            Abi::Vector { count, element } => {\n+                // No padding in vectors, except possibly for trailing padding to make the size a multiple of align.\n+                let size = element.size(cx) * count;\n+                let align = cx.data_layout().vector_align(size).abi;\n+                let size = size.align_to(align); // needed e.g. for vectors of size 3\n+                assert!(align >= element.align(cx).abi); // just sanity-checking `vector_align`.\n+                assert_eq!(\n+                    layout.layout.size(),\n+                    size,\n+                    \"size mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                assert_eq!(\n+                    layout.layout.align().abi,\n+                    align,\n+                    \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                // FIXME: Do some kind of check of the inner type, like for Scalar and ScalarPair.\n+            }\n+            Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n         }\n+    }\n \n-        check_layout_abi(cx, layout);\n+    check_layout_abi(cx, layout);\n \n-        if let Variants::Multiple { variants, .. } = &layout.variants {\n-            for variant in variants.iter() {\n-                // No nested \"multiple\".\n-                assert!(matches!(variant.variants, Variants::Single { .. }));\n-                // Variants should have the same or a smaller size as the full thing,\n-                // and same for alignment.\n-                if variant.size > layout.size {\n-                    bug!(\n-                        \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n-                        layout.size.bytes(),\n-                        variant.size.bytes(),\n-                    )\n-                }\n-                if variant.align.abi > layout.align.abi {\n-                    bug!(\n-                        \"Type with alignment {} bytes has variant with alignment {} bytes: {layout:#?}\",\n-                        layout.align.abi.bytes(),\n-                        variant.align.abi.bytes(),\n-                    )\n-                }\n-                // Skip empty variants.\n-                if variant.size == Size::ZERO\n-                    || variant.fields.count() == 0\n-                    || variant.abi.is_uninhabited()\n-                {\n-                    // These are never actually accessed anyway, so we can skip the coherence check\n-                    // for them. They also fail that check, since they have\n-                    // `Aggregate`/`Uninhbaited` ABI even when the main type is\n-                    // `Scalar`/`ScalarPair`. (Note that sometimes, variants with fields have size\n-                    // 0, and sometimes, variants without fields have non-0 size.)\n-                    continue;\n-                }\n-                // The top-level ABI and the ABI of the variants should be coherent.\n-                let scalar_coherent = |s1: Scalar, s2: Scalar| {\n-                    s1.size(cx) == s2.size(cx) && s1.align(cx) == s2.align(cx)\n-                };\n-                let abi_coherent = match (layout.abi, variant.abi) {\n-                    (Abi::Scalar(s1), Abi::Scalar(s2)) => scalar_coherent(s1, s2),\n-                    (Abi::ScalarPair(a1, b1), Abi::ScalarPair(a2, b2)) => {\n-                        scalar_coherent(a1, a2) && scalar_coherent(b1, b2)\n-                    }\n-                    (Abi::Uninhabited, _) => true,\n-                    (Abi::Aggregate { .. }, _) => true,\n-                    _ => false,\n-                };\n-                if !abi_coherent {\n-                    bug!(\n-                        \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n-                        variant\n-                    );\n+    if let Variants::Multiple { variants, .. } = &layout.variants {\n+        for variant in variants.iter() {\n+            // No nested \"multiple\".\n+            assert!(matches!(variant.variants, Variants::Single { .. }));\n+            // Variants should have the same or a smaller size as the full thing,\n+            // and same for alignment.\n+            if variant.size > layout.size {\n+                bug!(\n+                    \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n+                    layout.size.bytes(),\n+                    variant.size.bytes(),\n+                )\n+            }\n+            if variant.align.abi > layout.align.abi {\n+                bug!(\n+                    \"Type with alignment {} bytes has variant with alignment {} bytes: {layout:#?}\",\n+                    layout.align.abi.bytes(),\n+                    variant.align.abi.bytes(),\n+                )\n+            }\n+            // Skip empty variants.\n+            if variant.size == Size::ZERO\n+                || variant.fields.count() == 0\n+                || variant.abi.is_uninhabited()\n+            {\n+                // These are never actually accessed anyway, so we can skip the coherence check\n+                // for them. They also fail that check, since they have\n+                // `Aggregate`/`Uninhbaited` ABI even when the main type is\n+                // `Scalar`/`ScalarPair`. (Note that sometimes, variants with fields have size\n+                // 0, and sometimes, variants without fields have non-0 size.)\n+                continue;\n+            }\n+            // The top-level ABI and the ABI of the variants should be coherent.\n+            let scalar_coherent =\n+                |s1: Scalar, s2: Scalar| s1.size(cx) == s2.size(cx) && s1.align(cx) == s2.align(cx);\n+            let abi_coherent = match (layout.abi, variant.abi) {\n+                (Abi::Scalar(s1), Abi::Scalar(s2)) => scalar_coherent(s1, s2),\n+                (Abi::ScalarPair(a1, b1), Abi::ScalarPair(a2, b2)) => {\n+                    scalar_coherent(a1, a2) && scalar_coherent(b1, b2)\n                 }\n+                (Abi::Uninhabited, _) => true,\n+                (Abi::Aggregate { .. }, _) => true,\n+                _ => false,\n+            };\n+            if !abi_coherent {\n+                bug!(\n+                    \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n+                    variant\n+                );\n             }\n         }\n     }"}]}