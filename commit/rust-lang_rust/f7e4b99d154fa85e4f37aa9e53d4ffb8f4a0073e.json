{"sha": "f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZTRiOTlkMTU0ZmE4NWU0ZjM3YWE5ZTUzZDRmZmI4ZjRhMDA3M2U=", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2020-07-21T10:08:55Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2020-07-21T10:11:46Z"}, "message": "Replace remaining insta uses", "tree": {"sha": "fb2ed3661d92e1719b118a774c349e246b7bcb4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb2ed3661d92e1719b118a774c349e246b7bcb4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e", "html_url": "https://github.com/rust-lang/rust/commit/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9518e2f9d69dbb4a9ddd4a8bab87cf16a41fca03", "url": "https://api.github.com/repos/rust-lang/rust/commits/9518e2f9d69dbb4a9ddd4a8bab87cf16a41fca03", "html_url": "https://github.com/rust-lang/rust/commit/9518e2f9d69dbb4a9ddd4a8bab87cf16a41fca03"}], "stats": {"total": 10731, "additions": 5366, "deletions": 5365}, "files": [{"sha": "24c53eb022251b16891a871c8684045be62e2d78", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 310, "deletions": 310, "changes": 620, "blob_url": "https://github.com/rust-lang/rust/blob/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e", "patch": "@@ -1,9 +1,9 @@\n use std::fs;\n \n-use insta::assert_snapshot;\n+use expect::expect;\n use test_utils::project_dir;\n \n-use super::{check_types, infer};\n+use super::{check_infer, check_types};\n \n #[test]\n fn cfg_impl_def() {\n@@ -46,204 +46,204 @@ impl S {\n \n #[test]\n fn infer_macros_expanded() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct Foo(Vec<i32>);\n-\n-macro_rules! foo {\n-    ($($item:expr),*) => {\n-            {\n-                Foo(vec![$($item,)*])\n-            }\n-    };\n-}\n+    check_infer(\n+        r#\"\n+        struct Foo(Vec<i32>);\n+\n+        macro_rules! foo {\n+            ($($item:expr),*) => {\n+                    {\n+                        Foo(vec![$($item,)*])\n+                    }\n+            };\n+        }\n \n-fn main() {\n-    let x = foo!(1,2);\n-}\n-\"#),\n-        @r###\"\n-    !0..17 '{Foo(v...,2,])}': Foo\n-    !1..4 'Foo': Foo({unknown}) -> Foo\n-    !1..16 'Foo(vec![1,2,])': Foo\n-    !5..15 'vec![1,2,]': {unknown}\n-    155..181 '{     ...,2); }': ()\n-    165..166 'x': Foo\n-    \"###\n+        fn main() {\n+            let x = foo!(1,2);\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..17 '{Foo(v...,2,])}': Foo\n+            !1..4 'Foo': Foo({unknown}) -> Foo\n+            !1..16 'Foo(vec![1,2,])': Foo\n+            !5..15 'vec![1,2,]': {unknown}\n+            155..181 '{     ...,2); }': ()\n+            165..166 'x': Foo\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_legacy_textual_scoped_macros_expanded() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct Foo(Vec<i32>);\n-\n-#[macro_use]\n-mod m {\n-    macro_rules! foo {\n-        ($($item:expr),*) => {\n-            {\n-                Foo(vec![$($item,)*])\n+    check_infer(\n+        r#\"\n+        struct Foo(Vec<i32>);\n+\n+        #[macro_use]\n+        mod m {\n+            macro_rules! foo {\n+                ($($item:expr),*) => {\n+                    {\n+                        Foo(vec![$($item,)*])\n+                    }\n+                };\n             }\n-        };\n-    }\n-}\n+        }\n \n-fn main() {\n-    let x = foo!(1,2);\n-    let y = crate::foo!(1,2);\n-}\n-\"#),\n-        @r###\"\n-    !0..17 '{Foo(v...,2,])}': Foo\n-    !1..4 'Foo': Foo({unknown}) -> Foo\n-    !1..16 'Foo(vec![1,2,])': Foo\n-    !5..15 'vec![1,2,]': {unknown}\n-    194..250 '{     ...,2); }': ()\n-    204..205 'x': Foo\n-    227..228 'y': {unknown}\n-    231..247 'crate:...!(1,2)': {unknown}\n-    \"###\n+        fn main() {\n+            let x = foo!(1,2);\n+            let y = crate::foo!(1,2);\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..17 '{Foo(v...,2,])}': Foo\n+            !1..4 'Foo': Foo({unknown}) -> Foo\n+            !1..16 'Foo(vec![1,2,])': Foo\n+            !5..15 'vec![1,2,]': {unknown}\n+            194..250 '{     ...,2); }': ()\n+            204..205 'x': Foo\n+            227..228 'y': {unknown}\n+            231..247 'crate:...!(1,2)': {unknown}\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_path_qualified_macros_expanded() {\n-    assert_snapshot!(\n-        infer(r#\"\n-#[macro_export]\n-macro_rules! foo {\n-    () => { 42i32 }\n-}\n+    check_infer(\n+        r#\"\n+        #[macro_export]\n+        macro_rules! foo {\n+            () => { 42i32 }\n+        }\n \n-mod m {\n-    pub use super::foo as bar;\n-}\n+        mod m {\n+            pub use super::foo as bar;\n+        }\n \n-fn main() {\n-    let x = crate::foo!();\n-    let y = m::bar!();\n-}\n-\"#),\n-        @r###\"\n-    !0..5 '42i32': i32\n-    !0..5 '42i32': i32\n-    110..163 '{     ...!(); }': ()\n-    120..121 'x': i32\n-    147..148 'y': i32\n-    \"###\n+        fn main() {\n+            let x = crate::foo!();\n+            let y = m::bar!();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..5 '42i32': i32\n+            !0..5 '42i32': i32\n+            110..163 '{     ...!(); }': ()\n+            120..121 'x': i32\n+            147..148 'y': i32\n+        \"#]],\n     );\n }\n \n #[test]\n fn expr_macro_expanded_in_various_places() {\n-    assert_snapshot!(\n-        infer(r#\"\n-macro_rules! spam {\n-    () => (1isize);\n-}\n-\n-fn spam() {\n-    spam!();\n-    (spam!());\n-    spam!().spam(spam!());\n-    for _ in spam!() {}\n-    || spam!();\n-    while spam!() {}\n-    break spam!();\n-    return spam!();\n-    match spam!() {\n-        _ if spam!() => spam!(),\n-    }\n-    spam!()(spam!());\n-    Spam { spam: spam!() };\n-    spam!()[spam!()];\n-    await spam!();\n-    spam!() as usize;\n-    &spam!();\n-    -spam!();\n-    spam!()..spam!();\n-    spam!() + spam!();\n-}\n-\"#),\n-        @r###\"\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    !0..6 '1isize': isize\n-    53..456 '{     ...!(); }': ()\n-    87..108 'spam!(...am!())': {unknown}\n-    114..133 'for _ ...!() {}': ()\n-    118..119 '_': {unknown}\n-    131..133 '{}': ()\n-    138..148 '|| spam!()': || -> isize\n-    154..170 'while ...!() {}': ()\n-    168..170 '{}': ()\n-    175..188 'break spam!()': !\n-    194..208 'return spam!()': !\n-    214..268 'match ...     }': isize\n-    238..239 '_': isize\n-    273..289 'spam!(...am!())': {unknown}\n-    295..317 'Spam {...m!() }': {unknown}\n-    323..339 'spam!(...am!()]': {unknown}\n-    364..380 'spam!(... usize': usize\n-    386..394 '&spam!()': &isize\n-    400..408 '-spam!()': isize\n-    414..430 'spam!(...pam!()': {unknown}\n-    436..453 'spam!(...pam!()': isize\n-    \"###\n+    check_infer(\n+        r#\"\n+        macro_rules! spam {\n+            () => (1isize);\n+        }\n+\n+        fn spam() {\n+            spam!();\n+            (spam!());\n+            spam!().spam(spam!());\n+            for _ in spam!() {}\n+            || spam!();\n+            while spam!() {}\n+            break spam!();\n+            return spam!();\n+            match spam!() {\n+                _ if spam!() => spam!(),\n+            }\n+            spam!()(spam!());\n+            Spam { spam: spam!() };\n+            spam!()[spam!()];\n+            await spam!();\n+            spam!() as usize;\n+            &spam!();\n+            -spam!();\n+            spam!()..spam!();\n+            spam!() + spam!();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            53..456 '{     ...!(); }': ()\n+            87..108 'spam!(...am!())': {unknown}\n+            114..133 'for _ ...!() {}': ()\n+            118..119 '_': {unknown}\n+            131..133 '{}': ()\n+            138..148 '|| spam!()': || -> isize\n+            154..170 'while ...!() {}': ()\n+            168..170 '{}': ()\n+            175..188 'break spam!()': !\n+            194..208 'return spam!()': !\n+            214..268 'match ...     }': isize\n+            238..239 '_': isize\n+            273..289 'spam!(...am!())': {unknown}\n+            295..317 'Spam {...m!() }': {unknown}\n+            323..339 'spam!(...am!()]': {unknown}\n+            364..380 'spam!(... usize': usize\n+            386..394 '&spam!()': &isize\n+            400..408 '-spam!()': isize\n+            414..430 'spam!(...pam!()': {unknown}\n+            436..453 'spam!(...pam!()': isize\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_type_value_macro_having_same_name() {\n-    assert_snapshot!(\n-        infer(r#\"\n-#[macro_export]\n-macro_rules! foo {\n-    () => {\n-        mod foo {\n-            pub use super::foo;\n+    check_infer(\n+        r#\"\n+        #[macro_export]\n+        macro_rules! foo {\n+            () => {\n+                mod foo {\n+                    pub use super::foo;\n+                }\n+            };\n+            ($x:tt) => {\n+                $x\n+            };\n         }\n-    };\n-    ($x:tt) => {\n-        $x\n-    };\n-}\n \n-foo!();\n+        foo!();\n \n-fn foo() {\n-    let foo = foo::foo!(42i32);\n-}\n-\"#),\n-        @r###\"\n-    !0..5 '42i32': i32\n-    170..205 '{     ...32); }': ()\n-    180..183 'foo': i32\n-    \"###\n+        fn foo() {\n+            let foo = foo::foo!(42i32);\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..5 '42i32': i32\n+            170..205 '{     ...32); }': ()\n+            180..183 'foo': i32\n+        \"#]],\n     );\n }\n \n@@ -372,50 +372,50 @@ expand!();\n \n #[test]\n fn infer_type_value_non_legacy_macro_use_as() {\n-    assert_snapshot!(\n-        infer(r#\"\n-mod m {\n-    macro_rules! _foo {\n-        ($x:ident) => { type $x = u64; }\n-    }\n-    pub(crate) use _foo as foo;\n-}\n+    check_infer(\n+        r#\"\n+        mod m {\n+            macro_rules! _foo {\n+                ($x:ident) => { type $x = u64; }\n+            }\n+            pub(crate) use _foo as foo;\n+        }\n \n-m::foo!(foo);\n-use foo as bar;\n-fn f() -> bar { 0 }\n-fn main() {\n-    let _a  = f();\n-}\n-\"#),\n-        @r###\"\n-    158..163 '{ 0 }': u64\n-    160..161 '0': u64\n-    174..196 '{     ...f(); }': ()\n-    184..186 '_a': u64\n-    190..191 'f': fn f() -> u64\n-    190..193 'f()': u64\n-    \"###\n+        m::foo!(foo);\n+        use foo as bar;\n+        fn f() -> bar { 0 }\n+        fn main() {\n+            let _a  = f();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            158..163 '{ 0 }': u64\n+            160..161 '0': u64\n+            174..196 '{     ...f(); }': ()\n+            184..186 '_a': u64\n+            190..191 'f': fn f() -> u64\n+            190..193 'f()': u64\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_local_macro() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn main() {\n-    macro_rules! foo {\n-        () => { 1usize }\n-    }\n-    let _a  = foo!();\n-}\n-\"#),\n-        @r###\"\n-    !0..6 '1usize': usize\n-    10..89 '{     ...!(); }': ()\n-    16..65 'macro_...     }': {unknown}\n-    74..76 '_a': usize\n-    \"###\n+    check_infer(\n+        r#\"\n+        fn main() {\n+            macro_rules! foo {\n+                () => { 1usize }\n+            }\n+            let _a  = foo!();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..6 '1usize': usize\n+            10..89 '{     ...!(); }': ()\n+            16..65 'macro_...     }': {unknown}\n+            74..76 '_a': usize\n+        \"#]],\n     );\n }\n \n@@ -446,77 +446,77 @@ macro_rules! bar {\n \n #[test]\n fn infer_builtin_macros_line() {\n-    assert_snapshot!(\n-        infer(r#\"\n-#[rustc_builtin_macro]\n-macro_rules! line {() => {}}\n+    check_infer(\n+        r#\"\n+        #[rustc_builtin_macro]\n+        macro_rules! line {() => {}}\n \n-fn main() {\n-    let x = line!();\n-}\n-\"#),\n-        @r###\"\n-    !0..1 '0': i32\n-    63..87 '{     ...!(); }': ()\n-    73..74 'x': i32\n-    \"###\n+        fn main() {\n+            let x = line!();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..1 '0': i32\n+            63..87 '{     ...!(); }': ()\n+            73..74 'x': i32\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_builtin_macros_file() {\n-    assert_snapshot!(\n-        infer(r#\"\n-#[rustc_builtin_macro]\n-macro_rules! file {() => {}}\n+    check_infer(\n+        r#\"\n+        #[rustc_builtin_macro]\n+        macro_rules! file {() => {}}\n \n-fn main() {\n-    let x = file!();\n-}\n-\"#),\n-        @r###\"\n-    !0..2 '\"\"': &str\n-    63..87 '{     ...!(); }': ()\n-    73..74 'x': &str\n-    \"###\n+        fn main() {\n+            let x = file!();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..2 '\"\"': &str\n+            63..87 '{     ...!(); }': ()\n+            73..74 'x': &str\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_builtin_macros_column() {\n-    assert_snapshot!(\n-        infer(r#\"\n-#[rustc_builtin_macro]\n-macro_rules! column {() => {}}\n+    check_infer(\n+        r#\"\n+        #[rustc_builtin_macro]\n+        macro_rules! column {() => {}}\n \n-fn main() {\n-    let x = column!();\n-}\n-\"#),\n-        @r###\"\n-    !0..1 '0': i32\n-    65..91 '{     ...!(); }': ()\n-    75..76 'x': i32\n-    \"###\n+        fn main() {\n+            let x = column!();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..1 '0': i32\n+            65..91 '{     ...!(); }': ()\n+            75..76 'x': i32\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_builtin_macros_concat() {\n-    assert_snapshot!(\n-        infer(r#\"\n-#[rustc_builtin_macro]\n-macro_rules! concat {() => {}}\n+    check_infer(\n+        r#\"\n+        #[rustc_builtin_macro]\n+        macro_rules! concat {() => {}}\n \n-fn main() {\n-    let x = concat!(\"hello\", concat!(\"world\", \"!\"));\n-}\n-\"#),\n-        @r###\"\n-    !0..13 '\"helloworld!\"': &str\n-    65..121 '{     ...\")); }': ()\n-    75..76 'x': &str\n-    \"###\n+        fn main() {\n+            let x = concat!(\"hello\", concat!(\"world\", \"!\"));\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..13 '\"helloworld!\"': &str\n+            65..121 '{     ...\")); }': ()\n+            75..76 'x': &str\n+        \"#]],\n     );\n }\n \n@@ -622,50 +622,50 @@ macro_rules! include {() => {}}\n include!(\"main.rs\");\n \n fn main() {\n-    0\n+            0\n } //^ i32\n \"#,\n     );\n }\n \n #[test]\n fn infer_builtin_macros_concat_with_lazy() {\n-    assert_snapshot!(\n-        infer(r#\"\n-macro_rules! hello {() => {\"hello\"}}\n+    check_infer(\n+        r#\"\n+        macro_rules! hello {() => {\"hello\"}}\n \n-#[rustc_builtin_macro]\n-macro_rules! concat {() => {}}\n+        #[rustc_builtin_macro]\n+        macro_rules! concat {() => {}}\n \n-fn main() {\n-    let x = concat!(hello!(), concat!(\"world\", \"!\"));\n-}\n-\"#),\n-        @r###\"\n-    !0..13 '\"helloworld!\"': &str\n-    103..160 '{     ...\")); }': ()\n-    113..114 'x': &str\n-    \"###\n+        fn main() {\n+            let x = concat!(hello!(), concat!(\"world\", \"!\"));\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..13 '\"helloworld!\"': &str\n+            103..160 '{     ...\")); }': ()\n+            113..114 'x': &str\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_builtin_macros_env() {\n-    assert_snapshot!(\n-        infer(r#\"\n-//- /main.rs env:foo=bar\n-#[rustc_builtin_macro]\n-macro_rules! env {() => {}}\n+    check_infer(\n+        r#\"\n+        //- /main.rs env:foo=bar\n+        #[rustc_builtin_macro]\n+        macro_rules! env {() => {}}\n \n-fn main() {\n-    let x = env!(\"foo\");\n-}\n-\"#),\n-        @r###\"\n-    !0..22 '\"__RA_...TED__\"': &str\n-    62..90 '{     ...o\"); }': ()\n-    72..73 'x': &str\n-    \"###\n+        fn main() {\n+            let x = env!(\"foo\");\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..22 '\"__RA_...TED__\"': &str\n+            62..90 '{     ...o\"); }': ()\n+            72..73 'x': &str\n+        \"#]],\n     );\n }\n \n@@ -763,25 +763,25 @@ fn test() {\n \n #[test]\n fn macro_in_arm() {\n-    assert_snapshot!(\n-        infer(r#\"\n-macro_rules! unit {\n-    () => { () };\n-}\n+    check_infer(\n+        r#\"\n+        macro_rules! unit {\n+            () => { () };\n+        }\n \n-fn main() {\n-    let x = match () {\n-        unit!() => 92u32,\n-    };\n-}\n-\"#),\n-        @r###\"\n-    51..110 '{     ...  }; }': ()\n-    61..62 'x': u32\n-    65..107 'match ...     }': u32\n-    71..73 '()': ()\n-    84..91 'unit!()': ()\n-    95..100 '92u32': u32\n-    \"###\n+        fn main() {\n+            let x = match () {\n+                unit!() => 92u32,\n+            };\n+        }\n+        \"#,\n+        expect![[r#\"\n+            51..110 '{     ...  }; }': ()\n+            61..62 'x': u32\n+            65..107 'match ...     }': u32\n+            71..73 '()': ()\n+            84..91 'unit!()': ()\n+            95..100 '92u32': u32\n+        \"#]],\n     );\n }"}, {"sha": "fa68355aa84734d9b95dfaf72866c0bf6bc6f6cc", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 575, "deletions": 575, "changes": 1150, "blob_url": "https://github.com/rust-lang/rust/blob/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e", "patch": "@@ -1,245 +1,245 @@\n-use insta::assert_snapshot;\n+use expect::expect;\n \n-use super::{check_types, infer};\n+use super::{check_infer, check_types};\n \n #[test]\n fn infer_slice_method() {\n-    assert_snapshot!(\n-        infer(r#\"\n-#[lang = \"slice\"]\n-impl<T> [T] {\n-    fn foo(&self) -> T {\n-        loop {}\n-    }\n-}\n-\n-#[lang = \"slice_alloc\"]\n-impl<T> [T] {}\n-\n-fn test(x: &[u8]) {\n-    <[_]>::foo(x);\n-}\n-\"#),\n-        @r###\"\n-    44..48 'self': &[T]\n-    55..78 '{     ...     }': T\n-    65..72 'loop {}': !\n-    70..72 '{}': ()\n-    130..131 'x': &[u8]\n-    140..162 '{     ...(x); }': ()\n-    146..156 '<[_]>::foo': fn foo<u8>(&[u8]) -> u8\n-    146..159 '<[_]>::foo(x)': u8\n-    157..158 'x': &[u8]\n-    \"###\n+    check_infer(\n+        r#\"\n+        #[lang = \"slice\"]\n+        impl<T> [T] {\n+            fn foo(&self) -> T {\n+                loop {}\n+            }\n+        }\n+\n+        #[lang = \"slice_alloc\"]\n+        impl<T> [T] {}\n+\n+        fn test(x: &[u8]) {\n+            <[_]>::foo(x);\n+        }\n+        \"#,\n+        expect![[r#\"\n+            44..48 'self': &[T]\n+            55..78 '{     ...     }': T\n+            65..72 'loop {}': !\n+            70..72 '{}': ()\n+            130..131 'x': &[u8]\n+            140..162 '{     ...(x); }': ()\n+            146..156 '<[_]>::foo': fn foo<u8>(&[u8]) -> u8\n+            146..159 '<[_]>::foo(x)': u8\n+            157..158 'x': &[u8]\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_associated_method_struct() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct A { x: u32 }\n-\n-impl A {\n-    fn new() -> A {\n-        A { x: 0 }\n-    }\n-}\n-fn test() {\n-    let a = A::new();\n-    a.x;\n-}\n-\"#),\n-        @r###\"\n-    48..74 '{     ...     }': A\n-    58..68 'A { x: 0 }': A\n-    65..66 '0': u32\n-    87..121 '{     ...a.x; }': ()\n-    97..98 'a': A\n-    101..107 'A::new': fn new() -> A\n-    101..109 'A::new()': A\n-    115..116 'a': A\n-    115..118 'a.x': u32\n-    \"###\n+    check_infer(\n+        r#\"\n+        struct A { x: u32 }\n+\n+        impl A {\n+            fn new() -> A {\n+                A { x: 0 }\n+            }\n+        }\n+        fn test() {\n+            let a = A::new();\n+            a.x;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            48..74 '{     ...     }': A\n+            58..68 'A { x: 0 }': A\n+            65..66 '0': u32\n+            87..121 '{     ...a.x; }': ()\n+            97..98 'a': A\n+            101..107 'A::new': fn new() -> A\n+            101..109 'A::new()': A\n+            115..116 'a': A\n+            115..118 'a.x': u32\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_associated_method_enum() {\n-    assert_snapshot!(\n-        infer(r#\"\n-enum A { B, C }\n-\n-impl A {\n-    pub fn b() -> A {\n-        A::B\n-    }\n-    pub fn c() -> A {\n-        A::C\n-    }\n-}\n-fn test() {\n-    let a = A::b();\n-    a;\n-    let c = A::c();\n-    c;\n-}\n-\"#),\n-        @r###\"\n-    46..66 '{     ...     }': A\n-    56..60 'A::B': A\n-    87..107 '{     ...     }': A\n-    97..101 'A::C': A\n-    120..177 '{     ...  c; }': ()\n-    130..131 'a': A\n-    134..138 'A::b': fn b() -> A\n-    134..140 'A::b()': A\n-    146..147 'a': A\n-    157..158 'c': A\n-    161..165 'A::c': fn c() -> A\n-    161..167 'A::c()': A\n-    173..174 'c': A\n-    \"###\n+    check_infer(\n+        r#\"\n+        enum A { B, C }\n+\n+        impl A {\n+            pub fn b() -> A {\n+                A::B\n+            }\n+            pub fn c() -> A {\n+                A::C\n+            }\n+        }\n+        fn test() {\n+            let a = A::b();\n+            a;\n+            let c = A::c();\n+            c;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            46..66 '{     ...     }': A\n+            56..60 'A::B': A\n+            87..107 '{     ...     }': A\n+            97..101 'A::C': A\n+            120..177 '{     ...  c; }': ()\n+            130..131 'a': A\n+            134..138 'A::b': fn b() -> A\n+            134..140 'A::b()': A\n+            146..147 'a': A\n+            157..158 'c': A\n+            161..165 'A::c': fn c() -> A\n+            161..167 'A::c()': A\n+            173..174 'c': A\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_associated_method_with_modules() {\n-    assert_snapshot!(\n-        infer(r#\"\n-mod a {\n-    struct A;\n-    impl A { pub fn thing() -> A { A {} }}\n-}\n-\n-mod b {\n-    struct B;\n-    impl B { pub fn thing() -> u32 { 99 }}\n-\n-    mod c {\n-        struct C;\n-        impl C { pub fn thing() -> C { C {} }}\n-    }\n-}\n-use b::c;\n-\n-fn test() {\n-    let x = a::A::thing();\n-    let y = b::B::thing();\n-    let z = c::C::thing();\n-}\n-\"#),\n-        @r###\"\n-    55..63 '{ A {} }': A\n-    57..61 'A {}': A\n-    125..131 '{ 99 }': u32\n-    127..129 '99': u32\n-    201..209 '{ C {} }': C\n-    203..207 'C {}': C\n-    240..324 '{     ...g(); }': ()\n-    250..251 'x': A\n-    254..265 'a::A::thing': fn thing() -> A\n-    254..267 'a::A::thing()': A\n-    277..278 'y': u32\n-    281..292 'b::B::thing': fn thing() -> u32\n-    281..294 'b::B::thing()': u32\n-    304..305 'z': C\n-    308..319 'c::C::thing': fn thing() -> C\n-    308..321 'c::C::thing()': C\n-    \"###\n+    check_infer(\n+        r#\"\n+        mod a {\n+            struct A;\n+            impl A { pub fn thing() -> A { A {} }}\n+        }\n+\n+        mod b {\n+            struct B;\n+            impl B { pub fn thing() -> u32 { 99 }}\n+\n+            mod c {\n+                struct C;\n+                impl C { pub fn thing() -> C { C {} }}\n+            }\n+        }\n+        use b::c;\n+\n+        fn test() {\n+            let x = a::A::thing();\n+            let y = b::B::thing();\n+            let z = c::C::thing();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            55..63 '{ A {} }': A\n+            57..61 'A {}': A\n+            125..131 '{ 99 }': u32\n+            127..129 '99': u32\n+            201..209 '{ C {} }': C\n+            203..207 'C {}': C\n+            240..324 '{     ...g(); }': ()\n+            250..251 'x': A\n+            254..265 'a::A::thing': fn thing() -> A\n+            254..267 'a::A::thing()': A\n+            277..278 'y': u32\n+            281..292 'b::B::thing': fn thing() -> u32\n+            281..294 'b::B::thing()': u32\n+            304..305 'z': C\n+            308..319 'c::C::thing': fn thing() -> C\n+            308..321 'c::C::thing()': C\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_associated_method_generics() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct Gen<T> {\n-    val: T\n-}\n-\n-impl<T> Gen<T> {\n-    pub fn make(val: T) -> Gen<T> {\n-        Gen { val }\n-    }\n-}\n-\n-fn test() {\n-    let a = Gen::make(0u32);\n-}\n-\"#),\n-        @r###\"\n-    63..66 'val': T\n-    81..108 '{     ...     }': Gen<T>\n-    91..102 'Gen { val }': Gen<T>\n-    97..100 'val': T\n-    122..154 '{     ...32); }': ()\n-    132..133 'a': Gen<u32>\n-    136..145 'Gen::make': fn make<u32>(u32) -> Gen<u32>\n-    136..151 'Gen::make(0u32)': Gen<u32>\n-    146..150 '0u32': u32\n-    \"###\n+    check_infer(\n+        r#\"\n+        struct Gen<T> {\n+            val: T\n+        }\n+\n+        impl<T> Gen<T> {\n+            pub fn make(val: T) -> Gen<T> {\n+                Gen { val }\n+            }\n+        }\n+\n+        fn test() {\n+            let a = Gen::make(0u32);\n+        }\n+        \"#,\n+        expect![[r#\"\n+            63..66 'val': T\n+            81..108 '{     ...     }': Gen<T>\n+            91..102 'Gen { val }': Gen<T>\n+            97..100 'val': T\n+            122..154 '{     ...32); }': ()\n+            132..133 'a': Gen<u32>\n+            136..145 'Gen::make': fn make<u32>(u32) -> Gen<u32>\n+            136..151 'Gen::make(0u32)': Gen<u32>\n+            146..150 '0u32': u32\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_associated_method_generics_without_args() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct Gen<T> {\n-    val: T\n-}\n-\n-impl<T> Gen<T> {\n-    pub fn make() -> Gen<T> {\n-        loop { }\n-    }\n-}\n-\n-fn test() {\n-    let a = Gen::<u32>::make();\n-}\n-\"#),\n-        @r###\"\n-    75..99 '{     ...     }': Gen<T>\n-    85..93 'loop { }': !\n-    90..93 '{ }': ()\n-    113..148 '{     ...e(); }': ()\n-    123..124 'a': Gen<u32>\n-    127..143 'Gen::<...::make': fn make<u32>() -> Gen<u32>\n-    127..145 'Gen::<...make()': Gen<u32>\n-    \"###\n+    check_infer(\n+        r#\"\n+        struct Gen<T> {\n+            val: T\n+        }\n+\n+        impl<T> Gen<T> {\n+            pub fn make() -> Gen<T> {\n+                loop { }\n+            }\n+        }\n+\n+        fn test() {\n+            let a = Gen::<u32>::make();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            75..99 '{     ...     }': Gen<T>\n+            85..93 'loop { }': !\n+            90..93 '{ }': ()\n+            113..148 '{     ...e(); }': ()\n+            123..124 'a': Gen<u32>\n+            127..143 'Gen::<...::make': fn make<u32>() -> Gen<u32>\n+            127..145 'Gen::<...make()': Gen<u32>\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_associated_method_generics_2_type_params_without_args() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct Gen<T, U> {\n-    val: T,\n-    val2: U,\n-}\n-\n-impl<T> Gen<u32, T> {\n-    pub fn make() -> Gen<u32,T> {\n-        loop { }\n-    }\n-}\n-\n-fn test() {\n-    let a = Gen::<u32, u64>::make();\n-}\n-\"#),\n-        @r###\"\n-    101..125 '{     ...     }': Gen<u32, T>\n-    111..119 'loop { }': !\n-    116..119 '{ }': ()\n-    139..179 '{     ...e(); }': ()\n-    149..150 'a': Gen<u32, u64>\n-    153..174 'Gen::<...::make': fn make<u64>() -> Gen<u32, u64>\n-    153..176 'Gen::<...make()': Gen<u32, u64>\n-    \"###\n+    check_infer(\n+        r#\"\n+        struct Gen<T, U> {\n+            val: T,\n+            val2: U,\n+        }\n+\n+        impl<T> Gen<u32, T> {\n+            pub fn make() -> Gen<u32,T> {\n+                loop { }\n+            }\n+        }\n+\n+        fn test() {\n+            let a = Gen::<u32, u64>::make();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            101..125 '{     ...     }': Gen<u32, T>\n+            111..119 'loop { }': !\n+            116..119 '{ }': ()\n+            139..179 '{     ...e(); }': ()\n+            149..150 'a': Gen<u32, u64>\n+            153..174 'Gen::<...::make': fn make<u64>() -> Gen<u32, u64>\n+            153..176 'Gen::<...make()': Gen<u32, u64>\n+        \"#]],\n     );\n }\n \n@@ -267,416 +267,416 @@ mod foo {\n #[test]\n fn infer_trait_method_simple() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait1 {\n-    fn method(&self) -> u32;\n-}\n-struct S1;\n-impl Trait1 for S1 {}\n-trait Trait2 {\n-    fn method(&self) -> i128;\n-}\n-struct S2;\n-impl Trait2 for S2 {}\n-fn test() {\n-    S1.method(); // -> u32\n-    S2.method(); // -> i128\n-}\n-\"#),\n-        @r###\"\n-    30..34 'self': &Self\n-    109..113 'self': &Self\n-    169..227 '{     ...i128 }': ()\n-    175..177 'S1': S1\n-    175..186 'S1.method()': u32\n-    202..204 'S2': S2\n-    202..213 'S2.method()': i128\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait1 {\n+            fn method(&self) -> u32;\n+        }\n+        struct S1;\n+        impl Trait1 for S1 {}\n+        trait Trait2 {\n+            fn method(&self) -> i128;\n+        }\n+        struct S2;\n+        impl Trait2 for S2 {}\n+        fn test() {\n+            S1.method(); // -> u32\n+            S2.method(); // -> i128\n+        }\n+        \"#,\n+        expect![[r#\"\n+            30..34 'self': &Self\n+            109..113 'self': &Self\n+            169..227 '{     ...i128 }': ()\n+            175..177 'S1': S1\n+            175..186 'S1.method()': u32\n+            202..204 'S2': S2\n+            202..213 'S2.method()': i128\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_scoped() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    assert_snapshot!(\n-        infer(r#\"\n-struct S;\n-mod foo {\n-    pub trait Trait1 {\n-        fn method(&self) -> u32;\n-    }\n-    impl Trait1 for super::S {}\n-}\n-mod bar {\n-    pub trait Trait2 {\n-        fn method(&self) -> i128;\n-    }\n-    impl Trait2 for super::S {}\n-}\n-\n-mod foo_test {\n-    use super::S;\n-    use super::foo::Trait1;\n-    fn test() {\n-        S.method(); // -> u32\n-    }\n-}\n-\n-mod bar_test {\n-    use super::S;\n-    use super::bar::Trait2;\n-    fn test() {\n-        S.method(); // -> i128\n-    }\n-}\n-\"#),\n-        @r###\"\n-    62..66 'self': &Self\n-    168..172 'self': &Self\n-    299..336 '{     ...     }': ()\n-    309..310 'S': S\n-    309..319 'S.method()': u32\n-    415..453 '{     ...     }': ()\n-    425..426 'S': S\n-    425..435 'S.method()': i128\n-    \"###\n+    check_infer(\n+        r#\"\n+        struct S;\n+        mod foo {\n+            pub trait Trait1 {\n+                fn method(&self) -> u32;\n+            }\n+            impl Trait1 for super::S {}\n+        }\n+        mod bar {\n+            pub trait Trait2 {\n+                fn method(&self) -> i128;\n+            }\n+            impl Trait2 for super::S {}\n+        }\n+\n+        mod foo_test {\n+            use super::S;\n+            use super::foo::Trait1;\n+            fn test() {\n+                S.method(); // -> u32\n+            }\n+        }\n+\n+        mod bar_test {\n+            use super::S;\n+            use super::bar::Trait2;\n+            fn test() {\n+                S.method(); // -> i128\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            62..66 'self': &Self\n+            168..172 'self': &Self\n+            299..336 '{     ...     }': ()\n+            309..310 'S': S\n+            309..319 'S.method()': u32\n+            415..453 '{     ...     }': ()\n+            425..426 'S': S\n+            425..435 'S.method()': i128\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_generic_1() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait<T> {\n-    fn method(&self) -> T;\n-}\n-struct S;\n-impl Trait<u32> for S {}\n-fn test() {\n-    S.method();\n-}\n-\"#),\n-        @r###\"\n-    32..36 'self': &Self\n-    91..110 '{     ...d(); }': ()\n-    97..98 'S': S\n-    97..107 'S.method()': u32\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait<T> {\n+            fn method(&self) -> T;\n+        }\n+        struct S;\n+        impl Trait<u32> for S {}\n+        fn test() {\n+            S.method();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            32..36 'self': &Self\n+            91..110 '{     ...d(); }': ()\n+            97..98 'S': S\n+            97..107 'S.method()': u32\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_generic_more_params() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait<T1, T2, T3> {\n-    fn method1(&self) -> (T1, T2, T3);\n-    fn method2(&self) -> (T3, T2, T1);\n-}\n-struct S1;\n-impl Trait<u8, u16, u32> for S1 {}\n-struct S2;\n-impl<T> Trait<i8, i16, T> for S2 {}\n-fn test() {\n-    S1.method1(); // u8, u16, u32\n-    S1.method2(); // u32, u16, u8\n-    S2.method1(); // i8, i16, {unknown}\n-    S2.method2(); // {unknown}, i16, i8\n-}\n-\"#),\n-        @r###\"\n-    42..46 'self': &Self\n-    81..85 'self': &Self\n-    209..360 '{     ..., i8 }': ()\n-    215..217 'S1': S1\n-    215..227 'S1.method1()': (u8, u16, u32)\n-    249..251 'S1': S1\n-    249..261 'S1.method2()': (u32, u16, u8)\n-    283..285 'S2': S2\n-    283..295 'S2.method1()': (i8, i16, {unknown})\n-    323..325 'S2': S2\n-    323..335 'S2.method2()': ({unknown}, i16, i8)\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait<T1, T2, T3> {\n+            fn method1(&self) -> (T1, T2, T3);\n+            fn method2(&self) -> (T3, T2, T1);\n+        }\n+        struct S1;\n+        impl Trait<u8, u16, u32> for S1 {}\n+        struct S2;\n+        impl<T> Trait<i8, i16, T> for S2 {}\n+        fn test() {\n+            S1.method1(); // u8, u16, u32\n+            S1.method2(); // u32, u16, u8\n+            S2.method1(); // i8, i16, {unknown}\n+            S2.method2(); // {unknown}, i16, i8\n+        }\n+        \"#,\n+        expect![[r#\"\n+            42..46 'self': &Self\n+            81..85 'self': &Self\n+            209..360 '{     ..., i8 }': ()\n+            215..217 'S1': S1\n+            215..227 'S1.method1()': (u8, u16, u32)\n+            249..251 'S1': S1\n+            249..261 'S1.method2()': (u32, u16, u8)\n+            283..285 'S2': S2\n+            283..295 'S2.method1()': (i8, i16, {unknown})\n+            323..325 'S2': S2\n+            323..335 'S2.method2()': ({unknown}, i16, i8)\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_generic_2() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait<T> {\n-    fn method(&self) -> T;\n-}\n-struct S<T>(T);\n-impl<U> Trait<U> for S<U> {}\n-fn test() {\n-    S(1u32).method();\n-}\n-\"#),\n-        @r###\"\n-    32..36 'self': &Self\n-    101..126 '{     ...d(); }': ()\n-    107..108 'S': S<u32>(u32) -> S<u32>\n-    107..114 'S(1u32)': S<u32>\n-    107..123 'S(1u32...thod()': u32\n-    109..113 '1u32': u32\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait<T> {\n+            fn method(&self) -> T;\n+        }\n+        struct S<T>(T);\n+        impl<U> Trait<U> for S<U> {}\n+        fn test() {\n+            S(1u32).method();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            32..36 'self': &Self\n+            101..126 '{     ...d(); }': ()\n+            107..108 'S': S<u32>(u32) -> S<u32>\n+            107..114 'S(1u32)': S<u32>\n+            107..123 'S(1u32...thod()': u32\n+            109..113 '1u32': u32\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_assoc_method() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Default {\n-    fn default() -> Self;\n-}\n-struct S;\n-impl Default for S {}\n-fn test() {\n-    let s1: S = Default::default();\n-    let s2 = S::default();\n-    let s3 = <S as Default>::default();\n-}\n-\"#),\n-        @r###\"\n-    86..192 '{     ...t(); }': ()\n-    96..98 's1': S\n-    104..120 'Defaul...efault': fn default<S>() -> S\n-    104..122 'Defaul...ault()': S\n-    132..134 's2': S\n-    137..147 'S::default': fn default<S>() -> S\n-    137..149 'S::default()': S\n-    159..161 's3': S\n-    164..187 '<S as ...efault': fn default<S>() -> S\n-    164..189 '<S as ...ault()': S\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Default {\n+            fn default() -> Self;\n+        }\n+        struct S;\n+        impl Default for S {}\n+        fn test() {\n+            let s1: S = Default::default();\n+            let s2 = S::default();\n+            let s3 = <S as Default>::default();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            86..192 '{     ...t(); }': ()\n+            96..98 's1': S\n+            104..120 'Defaul...efault': fn default<S>() -> S\n+            104..122 'Defaul...ault()': S\n+            132..134 's2': S\n+            137..147 'S::default': fn default<S>() -> S\n+            137..149 'S::default()': S\n+            159..161 's3': S\n+            164..187 '<S as ...efault': fn default<S>() -> S\n+            164..189 '<S as ...ault()': S\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_assoc_method_generics_1() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait<T> {\n-    fn make() -> T;\n-}\n-struct S;\n-impl Trait<u32> for S {}\n-struct G<T>;\n-impl<T> Trait<T> for G<T> {}\n-fn test() {\n-    let a = S::make();\n-    let b = G::<u64>::make();\n-    let c: f64 = G::make();\n-}\n-\"#),\n-        @r###\"\n-    126..210 '{     ...e(); }': ()\n-    136..137 'a': u32\n-    140..147 'S::make': fn make<S, u32>() -> u32\n-    140..149 'S::make()': u32\n-    159..160 'b': u64\n-    163..177 'G::<u64>::make': fn make<G<u64>, u64>() -> u64\n-    163..179 'G::<u6...make()': u64\n-    189..190 'c': f64\n-    198..205 'G::make': fn make<G<f64>, f64>() -> f64\n-    198..207 'G::make()': f64\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait<T> {\n+            fn make() -> T;\n+        }\n+        struct S;\n+        impl Trait<u32> for S {}\n+        struct G<T>;\n+        impl<T> Trait<T> for G<T> {}\n+        fn test() {\n+            let a = S::make();\n+            let b = G::<u64>::make();\n+            let c: f64 = G::make();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            126..210 '{     ...e(); }': ()\n+            136..137 'a': u32\n+            140..147 'S::make': fn make<S, u32>() -> u32\n+            140..149 'S::make()': u32\n+            159..160 'b': u64\n+            163..177 'G::<u64>::make': fn make<G<u64>, u64>() -> u64\n+            163..179 'G::<u6...make()': u64\n+            189..190 'c': f64\n+            198..205 'G::make': fn make<G<f64>, f64>() -> f64\n+            198..207 'G::make()': f64\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_assoc_method_generics_2() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait<T> {\n-    fn make<U>() -> (T, U);\n-}\n-struct S;\n-impl Trait<u32> for S {}\n-struct G<T>;\n-impl<T> Trait<T> for G<T> {}\n-fn test() {\n-    let a = S::make::<i64>();\n-    let b: (_, i64) = S::make();\n-    let c = G::<u32>::make::<i64>();\n-    let d: (u32, _) = G::make::<i64>();\n-    let e: (u32, i64) = G::make();\n-}\n-\"#),\n-        @r###\"\n-    134..312 '{     ...e(); }': ()\n-    144..145 'a': (u32, i64)\n-    148..162 'S::make::<i64>': fn make<S, u32, i64>() -> (u32, i64)\n-    148..164 'S::mak...i64>()': (u32, i64)\n-    174..175 'b': (u32, i64)\n-    188..195 'S::make': fn make<S, u32, i64>() -> (u32, i64)\n-    188..197 'S::make()': (u32, i64)\n-    207..208 'c': (u32, i64)\n-    211..232 'G::<u3...:<i64>': fn make<G<u32>, u32, i64>() -> (u32, i64)\n-    211..234 'G::<u3...i64>()': (u32, i64)\n-    244..245 'd': (u32, i64)\n-    258..272 'G::make::<i64>': fn make<G<u32>, u32, i64>() -> (u32, i64)\n-    258..274 'G::mak...i64>()': (u32, i64)\n-    284..285 'e': (u32, i64)\n-    300..307 'G::make': fn make<G<u32>, u32, i64>() -> (u32, i64)\n-    300..309 'G::make()': (u32, i64)\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait<T> {\n+            fn make<U>() -> (T, U);\n+        }\n+        struct S;\n+        impl Trait<u32> for S {}\n+        struct G<T>;\n+        impl<T> Trait<T> for G<T> {}\n+        fn test() {\n+            let a = S::make::<i64>();\n+            let b: (_, i64) = S::make();\n+            let c = G::<u32>::make::<i64>();\n+            let d: (u32, _) = G::make::<i64>();\n+            let e: (u32, i64) = G::make();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            134..312 '{     ...e(); }': ()\n+            144..145 'a': (u32, i64)\n+            148..162 'S::make::<i64>': fn make<S, u32, i64>() -> (u32, i64)\n+            148..164 'S::mak...i64>()': (u32, i64)\n+            174..175 'b': (u32, i64)\n+            188..195 'S::make': fn make<S, u32, i64>() -> (u32, i64)\n+            188..197 'S::make()': (u32, i64)\n+            207..208 'c': (u32, i64)\n+            211..232 'G::<u3...:<i64>': fn make<G<u32>, u32, i64>() -> (u32, i64)\n+            211..234 'G::<u3...i64>()': (u32, i64)\n+            244..245 'd': (u32, i64)\n+            258..272 'G::make::<i64>': fn make<G<u32>, u32, i64>() -> (u32, i64)\n+            258..274 'G::mak...i64>()': (u32, i64)\n+            284..285 'e': (u32, i64)\n+            300..307 'G::make': fn make<G<u32>, u32, i64>() -> (u32, i64)\n+            300..309 'G::make()': (u32, i64)\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_assoc_method_generics_3() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait<T> {\n-    fn make() -> (Self, T);\n-}\n-struct S<T>;\n-impl Trait<i64> for S<i32> {}\n-fn test() {\n-    let a = S::make();\n-}\n-\"#),\n-        @r###\"\n-    100..126 '{     ...e(); }': ()\n-    110..111 'a': (S<i32>, i64)\n-    114..121 'S::make': fn make<S<i32>, i64>() -> (S<i32>, i64)\n-    114..123 'S::make()': (S<i32>, i64)\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait<T> {\n+            fn make() -> (Self, T);\n+        }\n+        struct S<T>;\n+        impl Trait<i64> for S<i32> {}\n+        fn test() {\n+            let a = S::make();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            100..126 '{     ...e(); }': ()\n+            110..111 'a': (S<i32>, i64)\n+            114..121 'S::make': fn make<S<i32>, i64>() -> (S<i32>, i64)\n+            114..123 'S::make()': (S<i32>, i64)\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_assoc_method_generics_4() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait<T> {\n-    fn make() -> (Self, T);\n-}\n-struct S<T>;\n-impl Trait<i64> for S<u64> {}\n-impl Trait<i32> for S<u32> {}\n-fn test() {\n-    let a: (S<u64>, _) = S::make();\n-    let b: (_, i32) = S::make();\n-}\n-\"#),\n-        @r###\"\n-    130..202 '{     ...e(); }': ()\n-    140..141 'a': (S<u64>, i64)\n-    157..164 'S::make': fn make<S<u64>, i64>() -> (S<u64>, i64)\n-    157..166 'S::make()': (S<u64>, i64)\n-    176..177 'b': (S<u32>, i32)\n-    190..197 'S::make': fn make<S<u32>, i32>() -> (S<u32>, i32)\n-    190..199 'S::make()': (S<u32>, i32)\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait<T> {\n+            fn make() -> (Self, T);\n+        }\n+        struct S<T>;\n+        impl Trait<i64> for S<u64> {}\n+        impl Trait<i32> for S<u32> {}\n+        fn test() {\n+            let a: (S<u64>, _) = S::make();\n+            let b: (_, i32) = S::make();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            130..202 '{     ...e(); }': ()\n+            140..141 'a': (S<u64>, i64)\n+            157..164 'S::make': fn make<S<u64>, i64>() -> (S<u64>, i64)\n+            157..166 'S::make()': (S<u64>, i64)\n+            176..177 'b': (S<u32>, i32)\n+            190..197 'S::make': fn make<S<u32>, i32>() -> (S<u32>, i32)\n+            190..199 'S::make()': (S<u32>, i32)\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_assoc_method_generics_5() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait<T> {\n-    fn make<U>() -> (Self, T, U);\n-}\n-struct S<T>;\n-impl Trait<i64> for S<u64> {}\n-fn test() {\n-    let a = <S as Trait<i64>>::make::<u8>();\n-    let b: (S<u64>, _, _) = Trait::<i64>::make::<u8>();\n-}\n-\"#),\n-        @r###\"\n-    106..210 '{     ...>(); }': ()\n-    116..117 'a': (S<u64>, i64, u8)\n-    120..149 '<S as ...::<u8>': fn make<S<u64>, i64, u8>() -> (S<u64>, i64, u8)\n-    120..151 '<S as ...<u8>()': (S<u64>, i64, u8)\n-    161..162 'b': (S<u64>, i64, u8)\n-    181..205 'Trait:...::<u8>': fn make<S<u64>, i64, u8>() -> (S<u64>, i64, u8)\n-    181..207 'Trait:...<u8>()': (S<u64>, i64, u8)\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait<T> {\n+            fn make<U>() -> (Self, T, U);\n+        }\n+        struct S<T>;\n+        impl Trait<i64> for S<u64> {}\n+        fn test() {\n+            let a = <S as Trait<i64>>::make::<u8>();\n+            let b: (S<u64>, _, _) = Trait::<i64>::make::<u8>();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            106..210 '{     ...>(); }': ()\n+            116..117 'a': (S<u64>, i64, u8)\n+            120..149 '<S as ...::<u8>': fn make<S<u64>, i64, u8>() -> (S<u64>, i64, u8)\n+            120..151 '<S as ...<u8>()': (S<u64>, i64, u8)\n+            161..162 'b': (S<u64>, i64, u8)\n+            181..205 'Trait:...::<u8>': fn make<S<u64>, i64, u8>() -> (S<u64>, i64, u8)\n+            181..207 'Trait:...<u8>()': (S<u64>, i64, u8)\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_call_trait_method_on_generic_param_1() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait {\n-    fn method(&self) -> u32;\n-}\n-fn test<T: Trait>(t: T) {\n-    t.method();\n-}\n-\"#),\n-        @r###\"\n-    29..33 'self': &Self\n-    63..64 't': T\n-    69..88 '{     ...d(); }': ()\n-    75..76 't': T\n-    75..85 't.method()': u32\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait {\n+            fn method(&self) -> u32;\n+        }\n+        fn test<T: Trait>(t: T) {\n+            t.method();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            29..33 'self': &Self\n+            63..64 't': T\n+            69..88 '{     ...d(); }': ()\n+            75..76 't': T\n+            75..85 't.method()': u32\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_call_trait_method_on_generic_param_2() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait<T> {\n-    fn method(&self) -> T;\n-}\n-fn test<U, T: Trait<U>>(t: T) {\n-    t.method();\n-}\n-\"#),\n-        @r###\"\n-    32..36 'self': &Self\n-    70..71 't': T\n-    76..95 '{     ...d(); }': ()\n-    82..83 't': T\n-    82..92 't.method()': U\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait<T> {\n+            fn method(&self) -> T;\n+        }\n+        fn test<U, T: Trait<U>>(t: T) {\n+            t.method();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            32..36 'self': &Self\n+            70..71 't': T\n+            76..95 '{     ...d(); }': ()\n+            82..83 't': T\n+            82..92 't.method()': U\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_with_multiple_trait_impls() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Into<T> {\n-    fn into(self) -> T;\n-}\n-struct S;\n-impl Into<u32> for S {}\n-impl Into<u64> for S {}\n-fn test() {\n-    let x: u32 = S.into();\n-    let y: u64 = S.into();\n-    let z = Into::<u64>::into(S);\n-}\n-\"#),\n-        @r###\"\n-    28..32 'self': Self\n-    110..201 '{     ...(S); }': ()\n-    120..121 'x': u32\n-    129..130 'S': S\n-    129..137 'S.into()': u32\n-    147..148 'y': u64\n-    156..157 'S': S\n-    156..164 'S.into()': u64\n-    174..175 'z': u64\n-    178..195 'Into::...::into': fn into<S, u64>(S) -> u64\n-    178..198 'Into::...nto(S)': u64\n-    196..197 'S': S\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Into<T> {\n+            fn into(self) -> T;\n+        }\n+        struct S;\n+        impl Into<u32> for S {}\n+        impl Into<u64> for S {}\n+        fn test() {\n+            let x: u32 = S.into();\n+            let y: u64 = S.into();\n+            let z = Into::<u64>::into(S);\n+        }\n+        \"#,\n+        expect![[r#\"\n+            28..32 'self': Self\n+            110..201 '{     ...(S); }': ()\n+            120..121 'x': u32\n+            129..130 'S': S\n+            129..137 'S.into()': u32\n+            147..148 'y': u64\n+            156..157 'S': S\n+            156..164 'S.into()': u64\n+            174..175 'z': u64\n+            178..195 'Into::...::into': fn into<S, u64>(S) -> u64\n+            178..198 'Into::...nto(S)': u64\n+            196..197 'S': S\n+        \"#]],\n     );\n }\n \n@@ -1023,31 +1023,31 @@ fn test() { (S {}).method(); }\n \n #[test]\n fn dyn_trait_super_trait_not_in_scope() {\n-    assert_snapshot!(\n-        infer(r#\"\n-mod m {\n-    pub trait SuperTrait {\n-        fn foo(&self) -> u32 { 0 }\n-    }\n-}\n-trait Trait: m::SuperTrait {}\n-\n-struct S;\n-impl m::SuperTrait for S {}\n-impl Trait for S {}\n-\n-fn test(d: &dyn Trait) {\n-    d.foo();\n-}\n-\"#),\n-        @r###\"\n-    51..55 'self': &Self\n-    64..69 '{ 0 }': u32\n-    66..67 '0': u32\n-    176..177 'd': &dyn Trait\n-    191..207 '{     ...o(); }': ()\n-    197..198 'd': &dyn Trait\n-    197..204 'd.foo()': u32\n-    \"###\n+    check_infer(\n+        r#\"\n+        mod m {\n+            pub trait SuperTrait {\n+                fn foo(&self) -> u32 { 0 }\n+            }\n+        }\n+        trait Trait: m::SuperTrait {}\n+\n+        struct S;\n+        impl m::SuperTrait for S {}\n+        impl Trait for S {}\n+\n+        fn test(d: &dyn Trait) {\n+            d.foo();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            51..55 'self': &Self\n+            64..69 '{ 0 }': u32\n+            66..67 '0': u32\n+            176..177 'd': &dyn Trait\n+            191..207 '{     ...o(); }': ()\n+            197..198 'd': &dyn Trait\n+            197..204 'd.foo()': u32\n+        \"#]],\n     );\n }"}, {"sha": "39fabf7eb553da78447cfd7ea5af7aed6543e5d7", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 552, "deletions": 550, "changes": 1102, "blob_url": "https://github.com/rust-lang/rust/blob/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e", "patch": "@@ -1,561 +1,561 @@\n-use insta::assert_snapshot;\n+use expect::expect;\n use test_utils::mark;\n \n-use super::{infer, infer_with_mismatches};\n+use super::{check_infer, check_infer_with_mismatches};\n \n #[test]\n fn infer_pattern() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test(x: &i32) {\n-    let y = x;\n-    let &z = x;\n-    let a = z;\n-    let (c, d) = (1, \"hello\");\n-\n-    for (e, f) in some_iter {\n-        let g = e;\n-    }\n-\n-    if let [val] = opt {\n-        let h = val;\n-    }\n-\n-    let lambda = |a: u64, b, c: i32| { a + b; c };\n-\n-    let ref ref_to_x = x;\n-    let mut mut_x = x;\n-    let ref mut mut_ref_to_x = x;\n-    let k = mut_ref_to_x;\n-}\n-\"#),\n-        @r###\"\n-    8..9 'x': &i32\n-    17..368 '{     ...o_x; }': ()\n-    27..28 'y': &i32\n-    31..32 'x': &i32\n-    42..44 '&z': &i32\n-    43..44 'z': i32\n-    47..48 'x': &i32\n-    58..59 'a': i32\n-    62..63 'z': i32\n-    73..79 '(c, d)': (i32, &str)\n-    74..75 'c': i32\n-    77..78 'd': &str\n-    82..94 '(1, \"hello\")': (i32, &str)\n-    83..84 '1': i32\n-    86..93 '\"hello\"': &str\n-    101..151 'for (e...     }': ()\n-    105..111 '(e, f)': ({unknown}, {unknown})\n-    106..107 'e': {unknown}\n-    109..110 'f': {unknown}\n-    115..124 'some_iter': {unknown}\n-    125..151 '{     ...     }': ()\n-    139..140 'g': {unknown}\n-    143..144 'e': {unknown}\n-    157..204 'if let...     }': ()\n-    164..169 '[val]': [{unknown}]\n-    165..168 'val': {unknown}\n-    172..175 'opt': [{unknown}]\n-    176..204 '{     ...     }': ()\n-    190..191 'h': {unknown}\n-    194..197 'val': {unknown}\n-    214..220 'lambda': |u64, u64, i32| -> i32\n-    223..255 '|a: u6...b; c }': |u64, u64, i32| -> i32\n-    224..225 'a': u64\n-    232..233 'b': u64\n-    235..236 'c': i32\n-    243..255 '{ a + b; c }': i32\n-    245..246 'a': u64\n-    245..250 'a + b': u64\n-    249..250 'b': u64\n-    252..253 'c': i32\n-    266..278 'ref ref_to_x': &&i32\n-    281..282 'x': &i32\n-    292..301 'mut mut_x': &i32\n-    304..305 'x': &i32\n-    315..335 'ref mu...f_to_x': &mut &i32\n-    338..339 'x': &i32\n-    349..350 'k': &mut &i32\n-    353..365 'mut_ref_to_x': &mut &i32\n-    \"###\n+    check_infer(\n+        r#\"\n+        fn test(x: &i32) {\n+            let y = x;\n+            let &z = x;\n+            let a = z;\n+            let (c, d) = (1, \"hello\");\n+\n+            for (e, f) in some_iter {\n+                let g = e;\n+            }\n+\n+            if let [val] = opt {\n+                let h = val;\n+            }\n+\n+            let lambda = |a: u64, b, c: i32| { a + b; c };\n+\n+            let ref ref_to_x = x;\n+            let mut mut_x = x;\n+            let ref mut mut_ref_to_x = x;\n+            let k = mut_ref_to_x;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            8..9 'x': &i32\n+            17..368 '{     ...o_x; }': ()\n+            27..28 'y': &i32\n+            31..32 'x': &i32\n+            42..44 '&z': &i32\n+            43..44 'z': i32\n+            47..48 'x': &i32\n+            58..59 'a': i32\n+            62..63 'z': i32\n+            73..79 '(c, d)': (i32, &str)\n+            74..75 'c': i32\n+            77..78 'd': &str\n+            82..94 '(1, \"hello\")': (i32, &str)\n+            83..84 '1': i32\n+            86..93 '\"hello\"': &str\n+            101..151 'for (e...     }': ()\n+            105..111 '(e, f)': ({unknown}, {unknown})\n+            106..107 'e': {unknown}\n+            109..110 'f': {unknown}\n+            115..124 'some_iter': {unknown}\n+            125..151 '{     ...     }': ()\n+            139..140 'g': {unknown}\n+            143..144 'e': {unknown}\n+            157..204 'if let...     }': ()\n+            164..169 '[val]': [{unknown}]\n+            165..168 'val': {unknown}\n+            172..175 'opt': [{unknown}]\n+            176..204 '{     ...     }': ()\n+            190..191 'h': {unknown}\n+            194..197 'val': {unknown}\n+            214..220 'lambda': |u64, u64, i32| -> i32\n+            223..255 '|a: u6...b; c }': |u64, u64, i32| -> i32\n+            224..225 'a': u64\n+            232..233 'b': u64\n+            235..236 'c': i32\n+            243..255 '{ a + b; c }': i32\n+            245..246 'a': u64\n+            245..250 'a + b': u64\n+            249..250 'b': u64\n+            252..253 'c': i32\n+            266..278 'ref ref_to_x': &&i32\n+            281..282 'x': &i32\n+            292..301 'mut mut_x': &i32\n+            304..305 'x': &i32\n+            315..335 'ref mu...f_to_x': &mut &i32\n+            338..339 'x': &i32\n+            349..350 'k': &mut &i32\n+            353..365 'mut_ref_to_x': &mut &i32\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_literal_pattern() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-fn any<T>() -> T { loop {} }\n-fn test(x: &i32) {\n-    if let \"foo\" = any() {}\n-    if let 1 = any() {}\n-    if let 1u32 = any() {}\n-    if let 1f32 = any() {}\n-    if let 1.0 = any() {}\n-    if let true = any() {}\n-}\n-\"#, true),\n-        @r###\"\n-    17..28 '{ loop {} }': T\n-    19..26 'loop {}': !\n-    24..26 '{}': ()\n-    37..38 'x': &i32\n-    46..208 '{     ...) {} }': ()\n-    52..75 'if let...y() {}': ()\n-    59..64 '\"foo\"': &str\n-    59..64 '\"foo\"': &str\n-    67..70 'any': fn any<&str>() -> &str\n-    67..72 'any()': &str\n-    73..75 '{}': ()\n-    80..99 'if let...y() {}': ()\n-    87..88 '1': i32\n-    87..88 '1': i32\n-    91..94 'any': fn any<i32>() -> i32\n-    91..96 'any()': i32\n-    97..99 '{}': ()\n-    104..126 'if let...y() {}': ()\n-    111..115 '1u32': u32\n-    111..115 '1u32': u32\n-    118..121 'any': fn any<u32>() -> u32\n-    118..123 'any()': u32\n-    124..126 '{}': ()\n-    131..153 'if let...y() {}': ()\n-    138..142 '1f32': f32\n-    138..142 '1f32': f32\n-    145..148 'any': fn any<f32>() -> f32\n-    145..150 'any()': f32\n-    151..153 '{}': ()\n-    158..179 'if let...y() {}': ()\n-    165..168 '1.0': f64\n-    165..168 '1.0': f64\n-    171..174 'any': fn any<f64>() -> f64\n-    171..176 'any()': f64\n-    177..179 '{}': ()\n-    184..206 'if let...y() {}': ()\n-    191..195 'true': bool\n-    191..195 'true': bool\n-    198..201 'any': fn any<bool>() -> bool\n-    198..203 'any()': bool\n-    204..206 '{}': ()\n-    \"###\n+    check_infer_with_mismatches(\n+        r#\"\n+        fn any<T>() -> T { loop {} }\n+        fn test(x: &i32) {\n+            if let \"foo\" = any() {}\n+            if let 1 = any() {}\n+            if let 1u32 = any() {}\n+            if let 1f32 = any() {}\n+            if let 1.0 = any() {}\n+            if let true = any() {}\n+        }\n+        \"#,\n+        expect![[r#\"\n+            17..28 '{ loop {} }': T\n+            19..26 'loop {}': !\n+            24..26 '{}': ()\n+            37..38 'x': &i32\n+            46..208 '{     ...) {} }': ()\n+            52..75 'if let...y() {}': ()\n+            59..64 '\"foo\"': &str\n+            59..64 '\"foo\"': &str\n+            67..70 'any': fn any<&str>() -> &str\n+            67..72 'any()': &str\n+            73..75 '{}': ()\n+            80..99 'if let...y() {}': ()\n+            87..88 '1': i32\n+            87..88 '1': i32\n+            91..94 'any': fn any<i32>() -> i32\n+            91..96 'any()': i32\n+            97..99 '{}': ()\n+            104..126 'if let...y() {}': ()\n+            111..115 '1u32': u32\n+            111..115 '1u32': u32\n+            118..121 'any': fn any<u32>() -> u32\n+            118..123 'any()': u32\n+            124..126 '{}': ()\n+            131..153 'if let...y() {}': ()\n+            138..142 '1f32': f32\n+            138..142 '1f32': f32\n+            145..148 'any': fn any<f32>() -> f32\n+            145..150 'any()': f32\n+            151..153 '{}': ()\n+            158..179 'if let...y() {}': ()\n+            165..168 '1.0': f64\n+            165..168 '1.0': f64\n+            171..174 'any': fn any<f64>() -> f64\n+            171..176 'any()': f64\n+            177..179 '{}': ()\n+            184..206 'if let...y() {}': ()\n+            191..195 'true': bool\n+            191..195 'true': bool\n+            198..201 'any': fn any<bool>() -> bool\n+            198..203 'any()': bool\n+            204..206 '{}': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_range_pattern() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-fn test(x: &i32) {\n-    if let 1..76 = 2u32 {}\n-    if let 1..=76 = 2u32 {}\n-}\n-\"#, true),\n-        @r###\"\n-    8..9 'x': &i32\n-    17..75 '{     ...2 {} }': ()\n-    23..45 'if let...u32 {}': ()\n-    30..35 '1..76': u32\n-    38..42 '2u32': u32\n-    43..45 '{}': ()\n-    50..73 'if let...u32 {}': ()\n-    57..63 '1..=76': u32\n-    66..70 '2u32': u32\n-    71..73 '{}': ()\n-    \"###\n+    check_infer_with_mismatches(\n+        r#\"\n+        fn test(x: &i32) {\n+            if let 1..76 = 2u32 {}\n+            if let 1..=76 = 2u32 {}\n+        }\n+        \"#,\n+        expect![[r#\"\n+            8..9 'x': &i32\n+            17..75 '{     ...2 {} }': ()\n+            23..45 'if let...u32 {}': ()\n+            30..35 '1..76': u32\n+            38..42 '2u32': u32\n+            43..45 '{}': ()\n+            50..73 'if let...u32 {}': ()\n+            57..63 '1..=76': u32\n+            66..70 '2u32': u32\n+            71..73 '{}': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_pattern_match_ergonomics() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct A<T>(T);\n+    check_infer(\n+        r#\"\n+        struct A<T>(T);\n \n-fn test() {\n-    let A(n) = &A(1);\n-    let A(n) = &mut A(1);\n-}\n-\"#),\n-    @r###\"\n-    27..78 '{     ...(1); }': ()\n-    37..41 'A(n)': A<i32>\n-    39..40 'n': &i32\n-    44..49 '&A(1)': &A<i32>\n-    45..46 'A': A<i32>(i32) -> A<i32>\n-    45..49 'A(1)': A<i32>\n-    47..48 '1': i32\n-    59..63 'A(n)': A<i32>\n-    61..62 'n': &mut i32\n-    66..75 '&mut A(1)': &mut A<i32>\n-    71..72 'A': A<i32>(i32) -> A<i32>\n-    71..75 'A(1)': A<i32>\n-    73..74 '1': i32\n-    \"###\n+        fn test() {\n+            let A(n) = &A(1);\n+            let A(n) = &mut A(1);\n+        }\n+        \"#,\n+        expect![[r#\"\n+            27..78 '{     ...(1); }': ()\n+            37..41 'A(n)': A<i32>\n+            39..40 'n': &i32\n+            44..49 '&A(1)': &A<i32>\n+            45..46 'A': A<i32>(i32) -> A<i32>\n+            45..49 'A(1)': A<i32>\n+            47..48 '1': i32\n+            59..63 'A(n)': A<i32>\n+            61..62 'n': &mut i32\n+            66..75 '&mut A(1)': &mut A<i32>\n+            71..72 'A': A<i32>(i32) -> A<i32>\n+            71..75 'A(1)': A<i32>\n+            73..74 '1': i32\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_pattern_match_ergonomics_ref() {\n     mark::check!(match_ergonomics_ref);\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test() {\n-    let v = &(1, &2);\n-    let (_, &w) = v;\n-}\n-\"#),\n-    @r###\"\n-    10..56 '{     ...= v; }': ()\n-    20..21 'v': &(i32, &i32)\n-    24..32 '&(1, &2)': &(i32, &i32)\n-    25..32 '(1, &2)': (i32, &i32)\n-    26..27 '1': i32\n-    29..31 '&2': &i32\n-    30..31 '2': i32\n-    42..49 '(_, &w)': (i32, &i32)\n-    43..44 '_': i32\n-    46..48 '&w': &i32\n-    47..48 'w': i32\n-    52..53 'v': &(i32, &i32)\n-    \"###\n+    check_infer(\n+        r#\"\n+        fn test() {\n+            let v = &(1, &2);\n+            let (_, &w) = v;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            10..56 '{     ...= v; }': ()\n+            20..21 'v': &(i32, &i32)\n+            24..32 '&(1, &2)': &(i32, &i32)\n+            25..32 '(1, &2)': (i32, &i32)\n+            26..27 '1': i32\n+            29..31 '&2': &i32\n+            30..31 '2': i32\n+            42..49 '(_, &w)': (i32, &i32)\n+            43..44 '_': i32\n+            46..48 '&w': &i32\n+            47..48 'w': i32\n+            52..53 'v': &(i32, &i32)\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_pattern_match_slice() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test() {\n-    let slice: &[f64] = &[0.0];\n-    match slice {\n-        &[] => {},\n-        &[a] => {\n-            a;\n-        },\n-        &[b, c] => {\n-            b;\n-            c;\n+    check_infer(\n+        r#\"\n+        fn test() {\n+            let slice: &[f64] = &[0.0];\n+            match slice {\n+                &[] => {},\n+                &[a] => {\n+                    a;\n+                },\n+                &[b, c] => {\n+                    b;\n+                    c;\n+                }\n+                _ => {}\n+            }\n         }\n-        _ => {}\n-    }\n-}\n-\"#),\n-    @r###\"\n-    10..209 '{     ...   } }': ()\n-    20..25 'slice': &[f64]\n-    36..42 '&[0.0]': &[f64; _]\n-    37..42 '[0.0]': [f64; _]\n-    38..41 '0.0': f64\n-    48..207 'match ...     }': ()\n-    54..59 'slice': &[f64]\n-    70..73 '&[]': &[f64]\n-    71..73 '[]': [f64]\n-    77..79 '{}': ()\n-    89..93 '&[a]': &[f64]\n-    90..93 '[a]': [f64]\n-    91..92 'a': f64\n-    97..123 '{     ...     }': ()\n-    111..112 'a': f64\n-    133..140 '&[b, c]': &[f64]\n-    134..140 '[b, c]': [f64]\n-    135..136 'b': f64\n-    138..139 'c': f64\n-    144..185 '{     ...     }': ()\n-    158..159 'b': f64\n-    173..174 'c': f64\n-    194..195 '_': &[f64]\n-    199..201 '{}': ()\n-    \"###\n+        \"#,\n+        expect![[r#\"\n+            10..209 '{     ...   } }': ()\n+            20..25 'slice': &[f64]\n+            36..42 '&[0.0]': &[f64; _]\n+            37..42 '[0.0]': [f64; _]\n+            38..41 '0.0': f64\n+            48..207 'match ...     }': ()\n+            54..59 'slice': &[f64]\n+            70..73 '&[]': &[f64]\n+            71..73 '[]': [f64]\n+            77..79 '{}': ()\n+            89..93 '&[a]': &[f64]\n+            90..93 '[a]': [f64]\n+            91..92 'a': f64\n+            97..123 '{     ...     }': ()\n+            111..112 'a': f64\n+            133..140 '&[b, c]': &[f64]\n+            134..140 '[b, c]': [f64]\n+            135..136 'b': f64\n+            138..139 'c': f64\n+            144..185 '{     ...     }': ()\n+            158..159 'b': f64\n+            173..174 'c': f64\n+            194..195 '_': &[f64]\n+            199..201 '{}': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_pattern_match_string_literal() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-fn test() {\n-    let s: &str = \"hello\";\n-    match s {\n-        \"hello\" => {}\n-        _ => {}\n-    }\n-}\n-\"#, true),\n-    @r###\"\n-    10..98 '{     ...   } }': ()\n-    20..21 's': &str\n-    30..37 '\"hello\"': &str\n-    43..96 'match ...     }': ()\n-    49..50 's': &str\n-    61..68 '\"hello\"': &str\n-    61..68 '\"hello\"': &str\n-    72..74 '{}': ()\n-    83..84 '_': &str\n-    88..90 '{}': ()\n-    \"###\n+    check_infer_with_mismatches(\n+        r#\"\n+        fn test() {\n+            let s: &str = \"hello\";\n+            match s {\n+                \"hello\" => {}\n+                _ => {}\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            10..98 '{     ...   } }': ()\n+            20..21 's': &str\n+            30..37 '\"hello\"': &str\n+            43..96 'match ...     }': ()\n+            49..50 's': &str\n+            61..68 '\"hello\"': &str\n+            61..68 '\"hello\"': &str\n+            72..74 '{}': ()\n+            83..84 '_': &str\n+            88..90 '{}': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_pattern_match_or() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-fn test() {\n-    let s: &str = \"hello\";\n-    match s {\n-        \"hello\" | \"world\" => {}\n-        _ => {}\n-    }\n-}\n-\"#, true),\n-    @r###\"\n-    10..108 '{     ...   } }': ()\n-    20..21 's': &str\n-    30..37 '\"hello\"': &str\n-    43..106 'match ...     }': ()\n-    49..50 's': &str\n-    61..68 '\"hello\"': &str\n-    61..68 '\"hello\"': &str\n-    61..78 '\"hello...world\"': &str\n-    71..78 '\"world\"': &str\n-    71..78 '\"world\"': &str\n-    82..84 '{}': ()\n-    93..94 '_': &str\n-    98..100 '{}': ()\n-    \"###\n+    check_infer_with_mismatches(\n+        r#\"\n+        fn test() {\n+            let s: &str = \"hello\";\n+            match s {\n+                \"hello\" | \"world\" => {}\n+                _ => {}\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            10..108 '{     ...   } }': ()\n+            20..21 's': &str\n+            30..37 '\"hello\"': &str\n+            43..106 'match ...     }': ()\n+            49..50 's': &str\n+            61..68 '\"hello\"': &str\n+            61..68 '\"hello\"': &str\n+            61..78 '\"hello...world\"': &str\n+            71..78 '\"world\"': &str\n+            71..78 '\"world\"': &str\n+            82..84 '{}': ()\n+            93..94 '_': &str\n+            98..100 '{}': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_pattern_match_arr() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test() {\n-    let arr: [f64; 2] = [0.0, 1.0];\n-    match arr {\n-        [1.0, a] => {\n-            a;\n-        },\n-        [b, c] => {\n-            b;\n-            c;\n+    check_infer(\n+        r#\"\n+        fn test() {\n+            let arr: [f64; 2] = [0.0, 1.0];\n+            match arr {\n+                [1.0, a] => {\n+                    a;\n+                },\n+                [b, c] => {\n+                    b;\n+                    c;\n+                }\n+            }\n         }\n-    }\n-}\n-\"#),\n-    @r###\"\n-    10..179 '{     ...   } }': ()\n-    20..23 'arr': [f64; _]\n-    36..46 '[0.0, 1.0]': [f64; _]\n-    37..40 '0.0': f64\n-    42..45 '1.0': f64\n-    52..177 'match ...     }': ()\n-    58..61 'arr': [f64; _]\n-    72..80 '[1.0, a]': [f64; _]\n-    73..76 '1.0': f64\n-    73..76 '1.0': f64\n-    78..79 'a': f64\n-    84..110 '{     ...     }': ()\n-    98..99 'a': f64\n-    120..126 '[b, c]': [f64; _]\n-    121..122 'b': f64\n-    124..125 'c': f64\n-    130..171 '{     ...     }': ()\n-    144..145 'b': f64\n-    159..160 'c': f64\n-    \"###\n+        \"#,\n+        expect![[r#\"\n+            10..179 '{     ...   } }': ()\n+            20..23 'arr': [f64; _]\n+            36..46 '[0.0, 1.0]': [f64; _]\n+            37..40 '0.0': f64\n+            42..45 '1.0': f64\n+            52..177 'match ...     }': ()\n+            58..61 'arr': [f64; _]\n+            72..80 '[1.0, a]': [f64; _]\n+            73..76 '1.0': f64\n+            73..76 '1.0': f64\n+            78..79 'a': f64\n+            84..110 '{     ...     }': ()\n+            98..99 'a': f64\n+            120..126 '[b, c]': [f64; _]\n+            121..122 'b': f64\n+            124..125 'c': f64\n+            130..171 '{     ...     }': ()\n+            144..145 'b': f64\n+            159..160 'c': f64\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_adt_pattern() {\n-    assert_snapshot!(\n-        infer(r#\"\n-enum E {\n-    A { x: usize },\n-    B\n-}\n+    check_infer(\n+        r#\"\n+        enum E {\n+            A { x: usize },\n+            B\n+        }\n \n-struct S(u32, E);\n+        struct S(u32, E);\n \n-fn test() {\n-    let e = E::A { x: 3 };\n+        fn test() {\n+            let e = E::A { x: 3 };\n \n-    let S(y, z) = foo;\n-    let E::A { x: new_var } = e;\n+            let S(y, z) = foo;\n+            let E::A { x: new_var } = e;\n \n-    match e {\n-        E::A { x } => x,\n-        E::B if foo => 1,\n-        E::B => 10,\n-    };\n+            match e {\n+                E::A { x } => x,\n+                E::B if foo => 1,\n+                E::B => 10,\n+            };\n \n-    let ref d @ E::A { .. } = e;\n-    d;\n-}\n-\"#),\n-        @r###\"\n-    67..288 '{     ...  d; }': ()\n-    77..78 'e': E\n-    81..94 'E::A { x: 3 }': E\n-    91..92 '3': usize\n-    105..112 'S(y, z)': S\n-    107..108 'y': u32\n-    110..111 'z': E\n-    115..118 'foo': S\n-    128..147 'E::A {..._var }': E\n-    138..145 'new_var': usize\n-    150..151 'e': E\n-    158..244 'match ...     }': usize\n-    164..165 'e': E\n-    176..186 'E::A { x }': E\n-    183..184 'x': usize\n-    190..191 'x': usize\n-    201..205 'E::B': E\n-    209..212 'foo': bool\n-    216..217 '1': usize\n-    227..231 'E::B': E\n-    235..237 '10': usize\n-    255..274 'ref d ...{ .. }': &E\n-    263..274 'E::A { .. }': E\n-    277..278 'e': E\n-    284..285 'd': &E\n-    \"###\n+            let ref d @ E::A { .. } = e;\n+            d;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            67..288 '{     ...  d; }': ()\n+            77..78 'e': E\n+            81..94 'E::A { x: 3 }': E\n+            91..92 '3': usize\n+            105..112 'S(y, z)': S\n+            107..108 'y': u32\n+            110..111 'z': E\n+            115..118 'foo': S\n+            128..147 'E::A {..._var }': E\n+            138..145 'new_var': usize\n+            150..151 'e': E\n+            158..244 'match ...     }': usize\n+            164..165 'e': E\n+            176..186 'E::A { x }': E\n+            183..184 'x': usize\n+            190..191 'x': usize\n+            201..205 'E::B': E\n+            209..212 'foo': bool\n+            216..217 '1': usize\n+            227..231 'E::B': E\n+            235..237 '10': usize\n+            255..274 'ref d ...{ .. }': &E\n+            263..274 'E::A { .. }': E\n+            277..278 'e': E\n+            284..285 'd': &E\n+        \"#]],\n     );\n }\n \n #[test]\n fn enum_variant_through_self_in_pattern() {\n-    assert_snapshot!(\n-        infer(r#\"\n-enum E {\n-    A { x: usize },\n-    B(usize),\n-    C\n-}\n+    check_infer(\n+        r#\"\n+        enum E {\n+            A { x: usize },\n+            B(usize),\n+            C\n+        }\n \n-impl E {\n-    fn test() {\n-        match (loop {}) {\n-            Self::A { x } => { x; },\n-            Self::B(x) => { x; },\n-            Self::C => {},\n-        };\n-    }\n-}\n-\"#),\n-        @r###\"\n-    75..217 '{     ...     }': ()\n-    85..210 'match ...     }': ()\n-    92..99 'loop {}': !\n-    97..99 '{}': ()\n-    115..128 'Self::A { x }': E\n-    125..126 'x': usize\n-    132..138 '{ x; }': ()\n-    134..135 'x': usize\n-    152..162 'Self::B(x)': E\n-    160..161 'x': usize\n-    166..172 '{ x; }': ()\n-    168..169 'x': usize\n-    186..193 'Self::C': E\n-    197..199 '{}': ()\n-    \"###\n+        impl E {\n+            fn test() {\n+                match (loop {}) {\n+                    Self::A { x } => { x; },\n+                    Self::B(x) => { x; },\n+                    Self::C => {},\n+                };\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            75..217 '{     ...     }': ()\n+            85..210 'match ...     }': ()\n+            92..99 'loop {}': !\n+            97..99 '{}': ()\n+            115..128 'Self::A { x }': E\n+            125..126 'x': usize\n+            132..138 '{ x; }': ()\n+            134..135 'x': usize\n+            152..162 'Self::B(x)': E\n+            160..161 'x': usize\n+            166..172 '{ x; }': ()\n+            168..169 'x': usize\n+            186..193 'Self::C': E\n+            197..199 '{}': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_generics_in_patterns() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct A<T> {\n-    x: T,\n-}\n+    check_infer(\n+        r#\"\n+        struct A<T> {\n+            x: T,\n+        }\n \n-enum Option<T> {\n-    Some(T),\n-    None,\n-}\n+        enum Option<T> {\n+            Some(T),\n+            None,\n+        }\n \n-fn test(a1: A<u32>, o: Option<u64>) {\n-    let A { x: x2 } = a1;\n-    let A::<i64> { x: x3 } = A { x: 1 };\n-    match o {\n-        Option::Some(t) => t,\n-        _ => 1,\n-    };\n-}\n-\"#),\n-        @r###\"\n-    78..80 'a1': A<u32>\n-    90..91 'o': Option<u64>\n-    106..243 '{     ...  }; }': ()\n-    116..127 'A { x: x2 }': A<u32>\n-    123..125 'x2': u32\n-    130..132 'a1': A<u32>\n-    142..160 'A::<i6...: x3 }': A<i64>\n-    156..158 'x3': i64\n-    163..173 'A { x: 1 }': A<i64>\n-    170..171 '1': i64\n-    179..240 'match ...     }': u64\n-    185..186 'o': Option<u64>\n-    197..212 'Option::Some(t)': Option<u64>\n-    210..211 't': u64\n-    216..217 't': u64\n-    227..228 '_': Option<u64>\n-    232..233 '1': u64\n-    \"###\n+        fn test(a1: A<u32>, o: Option<u64>) {\n+            let A { x: x2 } = a1;\n+            let A::<i64> { x: x3 } = A { x: 1 };\n+            match o {\n+                Option::Some(t) => t,\n+                _ => 1,\n+            };\n+        }\n+        \"#,\n+        expect![[r#\"\n+            78..80 'a1': A<u32>\n+            90..91 'o': Option<u64>\n+            106..243 '{     ...  }; }': ()\n+            116..127 'A { x: x2 }': A<u32>\n+            123..125 'x2': u32\n+            130..132 'a1': A<u32>\n+            142..160 'A::<i6...: x3 }': A<i64>\n+            156..158 'x3': i64\n+            163..173 'A { x: 1 }': A<i64>\n+            170..171 '1': i64\n+            179..240 'match ...     }': u64\n+            185..186 'o': Option<u64>\n+            197..212 'Option::Some(t)': Option<u64>\n+            210..211 't': u64\n+            216..217 't': u64\n+            227..228 '_': Option<u64>\n+            232..233 '1': u64\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_const_pattern() {\n-    assert_snapshot!(\n-        infer_with_mismatches(r#\"\n-enum Option<T> { None }\n-use Option::None;\n-struct Foo;\n-const Bar: usize = 1;\n-\n-fn test() {\n-    let a: Option<u32> = None;\n-    let b: Option<i64> = match a {\n-        None => None,\n-    };\n-    let _: () = match () { Foo => Foo }; // Expected mismatch\n-    let _: () = match () { Bar => Bar }; // Expected mismatch\n-}\n-\"#, true),\n-        @r###\"\n-    73..74 '1': usize\n-    87..309 '{     ...atch }': ()\n-    97..98 'a': Option<u32>\n-    114..118 'None': Option<u32>\n-    128..129 'b': Option<i64>\n-    145..182 'match ...     }': Option<i64>\n-    151..152 'a': Option<u32>\n-    163..167 'None': Option<u32>\n-    171..175 'None': Option<i64>\n-    192..193 '_': ()\n-    200..223 'match ... Foo }': Foo\n-    206..208 '()': ()\n-    211..214 'Foo': Foo\n-    218..221 'Foo': Foo\n-    254..255 '_': ()\n-    262..285 'match ... Bar }': usize\n-    268..270 '()': ()\n-    273..276 'Bar': usize\n-    280..283 'Bar': usize\n-    200..223: expected (), got Foo\n-    262..285: expected (), got usize\n-    \"###\n+    check_infer_with_mismatches(\n+        r#\"\n+        enum Option<T> { None }\n+        use Option::None;\n+        struct Foo;\n+        const Bar: usize = 1;\n+\n+        fn test() {\n+            let a: Option<u32> = None;\n+            let b: Option<i64> = match a {\n+                None => None,\n+            };\n+            let _: () = match () { Foo => Foo }; // Expected mismatch\n+            let _: () = match () { Bar => Bar }; // Expected mismatch\n+        }\n+        \"#,\n+        expect![[r#\"\n+            73..74 '1': usize\n+            87..309 '{     ...atch }': ()\n+            97..98 'a': Option<u32>\n+            114..118 'None': Option<u32>\n+            128..129 'b': Option<i64>\n+            145..182 'match ...     }': Option<i64>\n+            151..152 'a': Option<u32>\n+            163..167 'None': Option<u32>\n+            171..175 'None': Option<i64>\n+            192..193 '_': ()\n+            200..223 'match ... Foo }': Foo\n+            206..208 '()': ()\n+            211..214 'Foo': Foo\n+            218..221 'Foo': Foo\n+            254..255 '_': ()\n+            262..285 'match ... Bar }': usize\n+            268..270 '()': ()\n+            273..276 'Bar': usize\n+            280..283 'Bar': usize\n+            200..223: expected (), got Foo\n+            262..285: expected (), got usize\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_guard() {\n-    assert_snapshot!(\n-        infer(r#\"\n+    check_infer(\n+        r#\"\n struct S;\n impl S { fn foo(&self) -> bool { false } }\n \n@@ -564,91 +564,93 @@ fn main() {\n         s if s.foo() => (),\n     }\n }\n-    \"#), @r###\"\n-    27..31 'self': &S\n-    41..50 '{ false }': bool\n-    43..48 'false': bool\n-    64..115 '{     ...   } }': ()\n-    70..113 'match ...     }': ()\n-    76..77 'S': S\n-    88..89 's': S\n-    93..94 's': S\n-    93..100 's.foo()': bool\n-    104..106 '()': ()\n-    \"###)\n+        \"#,\n+        expect![[r#\"\n+            27..31 'self': &S\n+            41..50 '{ false }': bool\n+            43..48 'false': bool\n+            64..115 '{     ...   } }': ()\n+            70..113 'match ...     }': ()\n+            76..77 'S': S\n+            88..89 's': S\n+            93..94 's': S\n+            93..100 's.foo()': bool\n+            104..106 '()': ()\n+    \"#]],\n+    )\n }\n \n #[test]\n fn match_ergonomics_in_closure_params() {\n-    assert_snapshot!(\n-        infer(r#\"\n-#[lang = \"fn_once\"]\n-trait FnOnce<Args> {\n-    type Output;\n-}\n+    check_infer(\n+        r#\"\n+        #[lang = \"fn_once\"]\n+        trait FnOnce<Args> {\n+            type Output;\n+        }\n \n-fn foo<T, U, F: FnOnce(T) -> U>(t: T, f: F) -> U { loop {} }\n+        fn foo<T, U, F: FnOnce(T) -> U>(t: T, f: F) -> U { loop {} }\n \n-fn test() {\n-    foo(&(1, \"a\"), |&(x, y)| x); // normal, no match ergonomics\n-    foo(&(1, \"a\"), |(x, y)| x);\n-}\n-\"#),\n-        @r###\"\n-    93..94 't': T\n-    99..100 'f': F\n-    110..121 '{ loop {} }': U\n-    112..119 'loop {}': !\n-    117..119 '{}': ()\n-    133..232 '{     ... x); }': ()\n-    139..142 'foo': fn foo<&(i32, &str), i32, |&(i32, &str)| -> i32>(&(i32, &str), |&(i32, &str)| -> i32) -> i32\n-    139..166 'foo(&(...y)| x)': i32\n-    143..152 '&(1, \"a\")': &(i32, &str)\n-    144..152 '(1, \"a\")': (i32, &str)\n-    145..146 '1': i32\n-    148..151 '\"a\"': &str\n-    154..165 '|&(x, y)| x': |&(i32, &str)| -> i32\n-    155..162 '&(x, y)': &(i32, &str)\n-    156..162 '(x, y)': (i32, &str)\n-    157..158 'x': i32\n-    160..161 'y': &str\n-    164..165 'x': i32\n-    203..206 'foo': fn foo<&(i32, &str), &i32, |&(i32, &str)| -> &i32>(&(i32, &str), |&(i32, &str)| -> &i32) -> &i32\n-    203..229 'foo(&(...y)| x)': &i32\n-    207..216 '&(1, \"a\")': &(i32, &str)\n-    208..216 '(1, \"a\")': (i32, &str)\n-    209..210 '1': i32\n-    212..215 '\"a\"': &str\n-    218..228 '|(x, y)| x': |&(i32, &str)| -> &i32\n-    219..225 '(x, y)': (i32, &str)\n-    220..221 'x': &i32\n-    223..224 'y': &&str\n-    227..228 'x': &i32\n-    \"###\n+        fn test() {\n+            foo(&(1, \"a\"), |&(x, y)| x); // normal, no match ergonomics\n+            foo(&(1, \"a\"), |(x, y)| x);\n+        }\n+        \"#,\n+        expect![[r#\"\n+            93..94 't': T\n+            99..100 'f': F\n+            110..121 '{ loop {} }': U\n+            112..119 'loop {}': !\n+            117..119 '{}': ()\n+            133..232 '{     ... x); }': ()\n+            139..142 'foo': fn foo<&(i32, &str), i32, |&(i32, &str)| -> i32>(&(i32, &str), |&(i32, &str)| -> i32) -> i32\n+            139..166 'foo(&(...y)| x)': i32\n+            143..152 '&(1, \"a\")': &(i32, &str)\n+            144..152 '(1, \"a\")': (i32, &str)\n+            145..146 '1': i32\n+            148..151 '\"a\"': &str\n+            154..165 '|&(x, y)| x': |&(i32, &str)| -> i32\n+            155..162 '&(x, y)': &(i32, &str)\n+            156..162 '(x, y)': (i32, &str)\n+            157..158 'x': i32\n+            160..161 'y': &str\n+            164..165 'x': i32\n+            203..206 'foo': fn foo<&(i32, &str), &i32, |&(i32, &str)| -> &i32>(&(i32, &str), |&(i32, &str)| -> &i32) -> &i32\n+            203..229 'foo(&(...y)| x)': &i32\n+            207..216 '&(1, \"a\")': &(i32, &str)\n+            208..216 '(1, \"a\")': (i32, &str)\n+            209..210 '1': i32\n+            212..215 '\"a\"': &str\n+            218..228 '|(x, y)| x': |&(i32, &str)| -> &i32\n+            219..225 '(x, y)': (i32, &str)\n+            220..221 'x': &i32\n+            223..224 'y': &&str\n+            227..228 'x': &i32\n+        \"#]],\n     );\n }\n \n #[test]\n fn slice_tail_pattern() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn foo(params: &[i32]) {\n-    match params {\n-        [head, tail @ ..] => {\n+    check_infer(\n+        r#\"\n+        fn foo(params: &[i32]) {\n+            match params {\n+                [head, tail @ ..] => {\n+                }\n+            }\n         }\n-    }\n-}\n-\"#),\n-        @r###\"\n-    7..13 'params': &[i32]\n-    23..92 '{     ...   } }': ()\n-    29..90 'match ...     }': ()\n-    35..41 'params': &[i32]\n-    52..69 '[head,... @ ..]': [i32]\n-    53..57 'head': &i32\n-    59..68 'tail @ ..': &[i32]\n-    66..68 '..': [i32]\n-    73..84 '{         }': ()\n-    \"###\n+        \"#,\n+        expect![[r#\"\n+            7..13 'params': &[i32]\n+            23..92 '{     ...   } }': ()\n+            29..90 'match ...     }': ()\n+            35..41 'params': &[i32]\n+            52..69 '[head,... @ ..]': [i32]\n+            53..57 'head': &i32\n+            59..68 'tail @ ..': &[i32]\n+            66..68 '..': [i32]\n+            73..84 '{         }': ()\n+        \"#]],\n     );\n }"}, {"sha": "b9ab0f3576a9d3803e66b6bb0445c2ff33b039b9", "filename": "crates/ra_hir_ty/src/tests/regression.rs", "status": "modified", "additions": 588, "deletions": 584, "changes": 1172, "blob_url": "https://github.com/rust-lang/rust/blob/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e", "patch": "@@ -1,401 +1,402 @@\n-use insta::assert_snapshot;\n+use expect::expect;\n use test_utils::mark;\n \n-use super::{check_types, infer};\n+use super::{check_infer, check_types};\n \n #[test]\n fn bug_484() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test() {\n-   let x = if true {};\n-}\n-\"#),\n-        @r###\"\n-    10..36 '{    l... {}; }': ()\n-    19..20 'x': ()\n-    23..33 'if true {}': ()\n-    26..30 'true': bool\n-    31..33 '{}': ()\n-    \"###\n+    check_infer(\n+        r#\"\n+        fn test() {\n+            let x = if true {};\n+        }\n+        \"#,\n+        expect![[r#\"\n+            10..37 '{     ... {}; }': ()\n+            20..21 'x': ()\n+            24..34 'if true {}': ()\n+            27..31 'true': bool\n+            32..34 '{}': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn no_panic_on_field_of_enum() {\n-    assert_snapshot!(\n-        infer(r#\"\n-enum X {}\n-\n-fn test(x: X) {\n-    x.some_field;\n-}\n-\"#),\n-        @r###\"\n-    19..20 'x': X\n-    25..46 '{     ...eld; }': ()\n-    31..32 'x': X\n-    31..43 'x.some_field': {unknown}\n-    \"###\n+    check_infer(\n+        r#\"\n+        enum X {}\n+\n+        fn test(x: X) {\n+            x.some_field;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            19..20 'x': X\n+            25..46 '{     ...eld; }': ()\n+            31..32 'x': X\n+            31..43 'x.some_field': {unknown}\n+        \"#]],\n     );\n }\n \n #[test]\n fn bug_585() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test() {\n-    X {};\n-    match x {\n-        A::B {} => (),\n-        A::Y() => (),\n-    }\n-}\n-\"#),\n-        @r###\"\n-    10..88 '{     ...   } }': ()\n-    16..20 'X {}': {unknown}\n-    26..86 'match ...     }': ()\n-    32..33 'x': {unknown}\n-    44..51 'A::B {}': {unknown}\n-    55..57 '()': ()\n-    67..73 'A::Y()': {unknown}\n-    77..79 '()': ()\n-    \"###\n+    check_infer(\n+        r#\"\n+        fn test() {\n+            X {};\n+            match x {\n+                A::B {} => (),\n+                A::Y() => (),\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            10..88 '{     ...   } }': ()\n+            16..20 'X {}': {unknown}\n+            26..86 'match ...     }': ()\n+            32..33 'x': {unknown}\n+            44..51 'A::B {}': {unknown}\n+            55..57 '()': ()\n+            67..73 'A::Y()': {unknown}\n+            77..79 '()': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn bug_651() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn quux() {\n-    let y = 92;\n-    1 + y;\n-}\n-\"#),\n-        @r###\"\n-    10..40 '{     ...+ y; }': ()\n-    20..21 'y': i32\n-    24..26 '92': i32\n-    32..33 '1': i32\n-    32..37 '1 + y': i32\n-    36..37 'y': i32\n-    \"###\n+    check_infer(\n+        r#\"\n+        fn quux() {\n+            let y = 92;\n+            1 + y;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            10..40 '{     ...+ y; }': ()\n+            20..21 'y': i32\n+            24..26 '92': i32\n+            32..33 '1': i32\n+            32..37 '1 + y': i32\n+            36..37 'y': i32\n+        \"#]],\n     );\n }\n \n #[test]\n fn recursive_vars() {\n     mark::check!(type_var_cycles_resolve_completely);\n     mark::check!(type_var_cycles_resolve_as_possible);\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test() {\n-    let y = unknown;\n-    [y, &y];\n-}\n-\"#),\n-        @r###\"\n-    10..47 '{     ...&y]; }': ()\n-    20..21 'y': &{unknown}\n-    24..31 'unknown': &{unknown}\n-    37..44 '[y, &y]': [&&{unknown}; _]\n-    38..39 'y': &{unknown}\n-    41..43 '&y': &&{unknown}\n-    42..43 'y': &{unknown}\n-    \"###\n+    check_infer(\n+        r#\"\n+        fn test() {\n+            let y = unknown;\n+            [y, &y];\n+        }\n+        \"#,\n+        expect![[r#\"\n+            10..47 '{     ...&y]; }': ()\n+            20..21 'y': &{unknown}\n+            24..31 'unknown': &{unknown}\n+            37..44 '[y, &y]': [&&{unknown}; _]\n+            38..39 'y': &{unknown}\n+            41..43 '&y': &&{unknown}\n+            42..43 'y': &{unknown}\n+        \"#]],\n     );\n }\n \n #[test]\n fn recursive_vars_2() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test() {\n-    let x = unknown;\n-    let y = unknown;\n-    [(x, y), (&y, &x)];\n-}\n-\"#),\n-        @r###\"\n-    10..79 '{     ...x)]; }': ()\n-    20..21 'x': &&{unknown}\n-    24..31 'unknown': &&{unknown}\n-    41..42 'y': &&{unknown}\n-    45..52 'unknown': &&{unknown}\n-    58..76 '[(x, y..., &x)]': [(&&&{unknown}, &&&{unknown}); _]\n-    59..65 '(x, y)': (&&&{unknown}, &&&{unknown})\n-    60..61 'x': &&{unknown}\n-    63..64 'y': &&{unknown}\n-    67..75 '(&y, &x)': (&&&{unknown}, &&&{unknown})\n-    68..70 '&y': &&&{unknown}\n-    69..70 'y': &&{unknown}\n-    72..74 '&x': &&&{unknown}\n-    73..74 'x': &&{unknown}\n-    \"###\n+    check_infer(\n+        r#\"\n+        fn test() {\n+            let x = unknown;\n+            let y = unknown;\n+            [(x, y), (&y, &x)];\n+        }\n+        \"#,\n+        expect![[r#\"\n+            10..79 '{     ...x)]; }': ()\n+            20..21 'x': &&{unknown}\n+            24..31 'unknown': &&{unknown}\n+            41..42 'y': &&{unknown}\n+            45..52 'unknown': &&{unknown}\n+            58..76 '[(x, y..., &x)]': [(&&&{unknown}, &&&{unknown}); _]\n+            59..65 '(x, y)': (&&&{unknown}, &&&{unknown})\n+            60..61 'x': &&{unknown}\n+            63..64 'y': &&{unknown}\n+            67..75 '(&y, &x)': (&&&{unknown}, &&&{unknown})\n+            68..70 '&y': &&&{unknown}\n+            69..70 'y': &&{unknown}\n+            72..74 '&x': &&&{unknown}\n+            73..74 'x': &&{unknown}\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_std_crash_1() {\n     // caused stack overflow, taken from std\n-    assert_snapshot!(\n-        infer(r#\"\n-enum Maybe<T> {\n-    Real(T),\n-    Fake,\n-}\n+    check_infer(\n+        r#\"\n+        enum Maybe<T> {\n+            Real(T),\n+            Fake,\n+        }\n \n-fn write() {\n-    match something_unknown {\n-        Maybe::Real(ref mut something) => (),\n-    }\n-}\n-\"#),\n-        @r###\"\n-    53..138 '{     ...   } }': ()\n-    59..136 'match ...     }': ()\n-    65..82 'someth...nknown': Maybe<{unknown}>\n-    93..123 'Maybe:...thing)': Maybe<{unknown}>\n-    105..122 'ref mu...ething': &mut {unknown}\n-    127..129 '()': ()\n-    \"###\n+        fn write() {\n+            match something_unknown {\n+                Maybe::Real(ref mut something) => (),\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            53..138 '{     ...   } }': ()\n+            59..136 'match ...     }': ()\n+            65..82 'someth...nknown': Maybe<{unknown}>\n+            93..123 'Maybe:...thing)': Maybe<{unknown}>\n+            105..122 'ref mu...ething': &mut {unknown}\n+            127..129 '()': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_std_crash_2() {\n     mark::check!(type_var_resolves_to_int_var);\n     // caused \"equating two type variables, ...\", taken from std\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test_line_buffer() {\n-    &[0, b'\\n', 1, b'\\n'];\n-}\n-\"#),\n-        @r###\"\n-    22..52 '{     ...n']; }': ()\n-    28..49 '&[0, b...b'\\n']': &[u8; _]\n-    29..49 '[0, b'...b'\\n']': [u8; _]\n-    30..31 '0': u8\n-    33..38 'b'\\n'': u8\n-    40..41 '1': u8\n-    43..48 'b'\\n'': u8\n-    \"###\n+    check_infer(\n+        r#\"\n+        fn test_line_buffer() {\n+            &[0, b'\\n', 1, b'\\n'];\n+        }\n+        \"#,\n+        expect![[r#\"\n+            22..52 '{     ...n']; }': ()\n+            28..49 '&[0, b...b'\\n']': &[u8; _]\n+            29..49 '[0, b'...b'\\n']': [u8; _]\n+            30..31 '0': u8\n+            33..38 'b'\\n'': u8\n+            40..41 '1': u8\n+            43..48 'b'\\n'': u8\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_std_crash_3() {\n     // taken from rustc\n-    assert_snapshot!(\n-        infer(r#\"\n-pub fn compute() {\n-    match nope!() {\n-        SizeSkeleton::Pointer { non_zero: true, tail } => {}\n-    }\n-}\n-\"#),\n-        @r###\"\n-    17..107 '{     ...   } }': ()\n-    23..105 'match ...     }': ()\n-    29..36 'nope!()': {unknown}\n-    47..93 'SizeSk...tail }': {unknown}\n-    81..85 'true': bool\n-    81..85 'true': bool\n-    87..91 'tail': {unknown}\n-    97..99 '{}': ()\n-    \"###\n+    check_infer(\n+        r#\"\n+        pub fn compute() {\n+            match nope!() {\n+                SizeSkeleton::Pointer { non_zero: true, tail } => {}\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            17..107 '{     ...   } }': ()\n+            23..105 'match ...     }': ()\n+            29..36 'nope!()': {unknown}\n+            47..93 'SizeSk...tail }': {unknown}\n+            81..85 'true': bool\n+            81..85 'true': bool\n+            87..91 'tail': {unknown}\n+            97..99 '{}': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_std_crash_4() {\n     // taken from rustc\n-    assert_snapshot!(\n-        infer(r#\"\n-pub fn primitive_type() {\n-    match *self {\n-        BorrowedRef { type_: Primitive(p), ..} => {},\n-    }\n-}\n-\"#),\n-        @r###\"\n-    24..105 '{     ...   } }': ()\n-    30..103 'match ...     }': ()\n-    36..41 '*self': {unknown}\n-    37..41 'self': {unknown}\n-    52..90 'Borrow...), ..}': {unknown}\n-    73..85 'Primitive(p)': {unknown}\n-    83..84 'p': {unknown}\n-    94..96 '{}': ()\n-    \"###\n+    check_infer(\n+        r#\"\n+        pub fn primitive_type() {\n+            match *self {\n+                BorrowedRef { type_: Primitive(p), ..} => {},\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            24..105 '{     ...   } }': ()\n+            30..103 'match ...     }': ()\n+            36..41 '*self': {unknown}\n+            37..41 'self': {unknown}\n+            52..90 'Borrow...), ..}': {unknown}\n+            73..85 'Primitive(p)': {unknown}\n+            83..84 'p': {unknown}\n+            94..96 '{}': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_std_crash_5() {\n     // taken from rustc\n-    assert_snapshot!(\n-        infer(r#\"\n-fn extra_compiler_flags() {\n-    for content in doesnt_matter {\n-        let name = if doesnt_matter {\n-            first\n-        } else {\n-            &content\n-        };\n-\n-        let content = if ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.contains(&name) {\n-            name\n-        } else {\n-            content\n-        };\n-    }\n-}\n-\"#),\n-        @r###\"\n-    26..322 '{     ...   } }': ()\n-    32..320 'for co...     }': ()\n-    36..43 'content': &{unknown}\n-    47..60 'doesnt_matter': {unknown}\n-    61..320 '{     ...     }': ()\n-    75..79 'name': &&{unknown}\n-    82..166 'if doe...     }': &&{unknown}\n-    85..98 'doesnt_matter': bool\n-    99..128 '{     ...     }': &&{unknown}\n-    113..118 'first': &&{unknown}\n-    134..166 '{     ...     }': &&{unknown}\n-    148..156 '&content': &&{unknown}\n-    149..156 'content': &{unknown}\n-    181..188 'content': &{unknown}\n-    191..313 'if ICE...     }': &{unknown}\n-    194..231 'ICE_RE..._VALUE': {unknown}\n-    194..247 'ICE_RE...&name)': bool\n-    241..246 '&name': &&&{unknown}\n-    242..246 'name': &&{unknown}\n-    248..276 '{     ...     }': &&{unknown}\n-    262..266 'name': &&{unknown}\n-    282..313 '{     ...     }': &{unknown}\n-    296..303 'content': &{unknown}\n-    \"###\n+    check_infer(\n+        r#\"\n+        fn extra_compiler_flags() {\n+            for content in doesnt_matter {\n+                let name = if doesnt_matter {\n+                    first\n+                } else {\n+                    &content\n+                };\n+\n+                let content = if ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.contains(&name) {\n+                    name\n+                } else {\n+                    content\n+                };\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            26..322 '{     ...   } }': ()\n+            32..320 'for co...     }': ()\n+            36..43 'content': &{unknown}\n+            47..60 'doesnt_matter': {unknown}\n+            61..320 '{     ...     }': ()\n+            75..79 'name': &&{unknown}\n+            82..166 'if doe...     }': &&{unknown}\n+            85..98 'doesnt_matter': bool\n+            99..128 '{     ...     }': &&{unknown}\n+            113..118 'first': &&{unknown}\n+            134..166 '{     ...     }': &&{unknown}\n+            148..156 '&content': &&{unknown}\n+            149..156 'content': &{unknown}\n+            181..188 'content': &{unknown}\n+            191..313 'if ICE...     }': &{unknown}\n+            194..231 'ICE_RE..._VALUE': {unknown}\n+            194..247 'ICE_RE...&name)': bool\n+            241..246 '&name': &&&{unknown}\n+            242..246 'name': &&{unknown}\n+            248..276 '{     ...     }': &&{unknown}\n+            262..266 'name': &&{unknown}\n+            282..313 '{     ...     }': &{unknown}\n+            296..303 'content': &{unknown}\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_nested_generics_crash() {\n     // another crash found typechecking rustc\n-    assert_snapshot!(\n-        infer(r#\"\n-struct Canonical<V> {\n-    value: V,\n-}\n-struct QueryResponse<V> {\n-    value: V,\n-}\n-fn test<R>(query_response: Canonical<QueryResponse<R>>) {\n-    &query_response.value;\n-}\n-\"#),\n-        @r###\"\n-    91..105 'query_response': Canonical<QueryResponse<R>>\n-    136..166 '{     ...lue; }': ()\n-    142..163 '&query....value': &QueryResponse<R>\n-    143..157 'query_response': Canonical<QueryResponse<R>>\n-    143..163 'query_....value': QueryResponse<R>\n-    \"###\n+    check_infer(\n+        r#\"\n+        struct Canonical<V> {\n+            value: V,\n+        }\n+        struct QueryResponse<V> {\n+            value: V,\n+        }\n+        fn test<R>(query_response: Canonical<QueryResponse<R>>) {\n+            &query_response.value;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            91..105 'query_response': Canonical<QueryResponse<R>>\n+            136..166 '{     ...lue; }': ()\n+            142..163 '&query....value': &QueryResponse<R>\n+            143..157 'query_response': Canonical<QueryResponse<R>>\n+            143..163 'query_....value': QueryResponse<R>\n+        \"#]],\n     );\n }\n \n #[test]\n fn infer_paren_macro_call() {\n-    assert_snapshot!(\n-        infer(r#\"\n-macro_rules! bar { () => {0u32} }\n-fn test() {\n-    let a = (bar!());\n-}\n-\"#),\n-        @r###\"\n-    !0..4 '0u32': u32\n-    44..69 '{     ...()); }': ()\n-    54..55 'a': u32\n-    \"###\n+    check_infer(\n+        r#\"\n+        macro_rules! bar { () => {0u32} }\n+        fn test() {\n+            let a = (bar!());\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..4 '0u32': u32\n+            44..69 '{     ...()); }': ()\n+            54..55 'a': u32\n+        \"#]],\n     );\n }\n \n #[test]\n fn bug_1030() {\n-    assert_snapshot!(infer(r#\"\n-struct HashSet<T, H>;\n-struct FxHasher;\n-type FxHashSet<T> = HashSet<T, FxHasher>;\n+    check_infer(\n+        r#\"\n+        struct HashSet<T, H>;\n+        struct FxHasher;\n+        type FxHashSet<T> = HashSet<T, FxHasher>;\n \n-impl<T, H> HashSet<T, H> {\n-    fn default() -> HashSet<T, H> {}\n-}\n+        impl<T, H> HashSet<T, H> {\n+            fn default() -> HashSet<T, H> {}\n+        }\n \n-pub fn main_loop() {\n-    FxHashSet::default();\n-}\n-\"#),\n-    @r###\"\n-    143..145 '{}': ()\n-    168..197 '{     ...t(); }': ()\n-    174..192 'FxHash...efault': fn default<{unknown}, FxHasher>() -> HashSet<{unknown}, FxHasher>\n-    174..194 'FxHash...ault()': HashSet<{unknown}, FxHasher>\n-    \"###\n+        pub fn main_loop() {\n+            FxHashSet::default();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            143..145 '{}': ()\n+            168..197 '{     ...t(); }': ()\n+            174..192 'FxHash...efault': fn default<{unknown}, FxHasher>() -> HashSet<{unknown}, FxHasher>\n+            174..194 'FxHash...ault()': HashSet<{unknown}, FxHasher>\n+        \"#]],\n     );\n }\n \n #[test]\n fn issue_2669() {\n-    assert_snapshot!(\n-        infer(\n-            r#\"trait A {}\n-    trait Write {}\n-    struct Response<T> {}\n-\n-    trait D {\n-        fn foo();\n-    }\n+    check_infer(\n+        r#\"\n+        trait A {}\n+        trait Write {}\n+        struct Response<T> {}\n+\n+        trait D {\n+            fn foo();\n+        }\n \n-    impl<T:A> D for Response<T> {\n-        fn foo() {\n-            end();\n-            fn end<W: Write>() {\n-                let _x: T =  loop {};\n+        impl<T:A> D for Response<T> {\n+            fn foo() {\n+                end();\n+                fn end<W: Write>() {\n+                    let _x: T =  loop {};\n+                }\n             }\n         }\n-    }\"#\n-        ),\n-        @r###\"\n-    147..262 '{     ...     }': ()\n-    161..164 'end': fn end<{unknown}>()\n-    161..166 'end()': ()\n-    199..252 '{     ...     }': ()\n-    221..223 '_x': !\n-    230..237 'loop {}': !\n-    235..237 '{}': ()\n-    \"###\n+        \"#,\n+        expect![[r#\"\n+            119..214 '{     ...     }': ()\n+            129..132 'end': fn end<{unknown}>()\n+            129..134 'end()': ()\n+            163..208 '{     ...     }': ()\n+            181..183 '_x': !\n+            190..197 'loop {}': !\n+            195..197 '{}': ()\n+        \"#]],\n     )\n }\n \n #[test]\n fn issue_2705() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Trait {}\n-fn test() {\n-    <Trait<u32>>::foo()\n-}\n-\"#),\n-        @r###\"\n-    25..52 '{     ...oo() }': ()\n-    31..48 '<Trait...>::foo': {unknown}\n-    31..50 '<Trait...:foo()': ()\n-    \"###\n+    check_infer(\n+        r#\"\n+        trait Trait {}\n+        fn test() {\n+            <Trait<u32>>::foo()\n+        }\n+        \"#,\n+        expect![[r#\"\n+            25..52 '{     ...oo() }': ()\n+            31..48 '<Trait...>::foo': {unknown}\n+            31..50 '<Trait...:foo()': ()\n+        \"#]],\n     );\n }\n \n@@ -479,360 +480,363 @@ fn main() {\n \n #[test]\n fn issue_3999_slice() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn foo(params: &[usize]) {\n-    match params {\n-        [ps @ .., _] => {}\n-    }\n-}\n-\"#),\n-        @r###\"\n-    7..13 'params': &[usize]\n-    25..80 '{     ...   } }': ()\n-    31..78 'match ...     }': ()\n-    37..43 'params': &[usize]\n-    54..66 '[ps @ .., _]': [usize]\n-    55..62 'ps @ ..': &[usize]\n-    60..62 '..': [usize]\n-    64..65 '_': usize\n-    70..72 '{}': ()\n-    \"###\n+    check_infer(\n+        r#\"\n+        fn foo(params: &[usize]) {\n+            match params {\n+                [ps @ .., _] => {}\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            7..13 'params': &[usize]\n+            25..80 '{     ...   } }': ()\n+            31..78 'match ...     }': ()\n+            37..43 'params': &[usize]\n+            54..66 '[ps @ .., _]': [usize]\n+            55..62 'ps @ ..': &[usize]\n+            60..62 '..': [usize]\n+            64..65 '_': usize\n+            70..72 '{}': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn issue_3999_struct() {\n     // rust-analyzer should not panic on seeing this malformed\n     // record pattern.\n-    assert_snapshot!(\n-        infer(r#\"\n-struct Bar {\n-    a: bool,\n-}\n-fn foo(b: Bar) {\n-    match b {\n-        Bar { a: .. } => {},\n-    }\n-}\n-\"#),\n-        @r###\"\n-    35..36 'b': Bar\n-    43..95 '{     ...   } }': ()\n-    49..93 'match ...     }': ()\n-    55..56 'b': Bar\n-    67..80 'Bar { a: .. }': Bar\n-    76..78 '..': bool\n-    84..86 '{}': ()\n-    \"###\n+    check_infer(\n+        r#\"\n+        struct Bar {\n+            a: bool,\n+        }\n+        fn foo(b: Bar) {\n+            match b {\n+                Bar { a: .. } => {},\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            35..36 'b': Bar\n+            43..95 '{     ...   } }': ()\n+            49..93 'match ...     }': ()\n+            55..56 'b': Bar\n+            67..80 'Bar { a: .. }': Bar\n+            76..78 '..': bool\n+            84..86 '{}': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn issue_4235_name_conflicts() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct FOO {}\n-static FOO:FOO = FOO {};\n+    check_infer(\n+        r#\"\n+        struct FOO {}\n+        static FOO:FOO = FOO {};\n \n-impl FOO {\n-    fn foo(&self) {}\n-}\n+        impl FOO {\n+            fn foo(&self) {}\n+        }\n \n-fn main() {\n-    let a = &FOO;\n-    a.foo();\n-}\n-\"#), @r###\"\n-    31..37 'FOO {}': FOO\n-    63..67 'self': &FOO\n-    69..71 '{}': ()\n-    85..119 '{     ...o(); }': ()\n-    95..96 'a': &FOO\n-    99..103 '&FOO': &FOO\n-    100..103 'FOO': FOO\n-    109..110 'a': &FOO\n-    109..116 'a.foo()': ()\n-    \"###\n+        fn main() {\n+            let a = &FOO;\n+            a.foo();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            31..37 'FOO {}': FOO\n+            63..67 'self': &FOO\n+            69..71 '{}': ()\n+            85..119 '{     ...o(); }': ()\n+            95..96 'a': &FOO\n+            99..103 '&FOO': &FOO\n+            100..103 'FOO': FOO\n+            109..110 'a': &FOO\n+            109..116 'a.foo()': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn issue_4465_dollar_crate_at_type() {\n-    assert_snapshot!(\n-        infer(r#\"\n-pub struct Foo {}\n-pub fn anything<T>() -> T {\n-    loop {}\n-}\n-macro_rules! foo {\n-    () => {{\n-        let r: $crate::Foo = anything();\n-        r\n-    }};\n-}\n-fn main() {\n-    let _a = foo!();\n-}\n-\"#), @r###\"\n-    44..59 '{     loop {} }': T\n-    50..57 'loop {}': !\n-    55..57 '{}': ()\n-    !0..31 '{letr:...g();r}': Foo\n-    !4..5 'r': Foo\n-    !18..26 'anything': fn anything<Foo>() -> Foo\n-    !18..28 'anything()': Foo\n-    !29..30 'r': Foo\n-    163..187 '{     ...!(); }': ()\n-    173..175 '_a': Foo\n-    \"###);\n+    check_infer(\n+        r#\"\n+        pub struct Foo {}\n+        pub fn anything<T>() -> T {\n+            loop {}\n+        }\n+        macro_rules! foo {\n+            () => {{\n+                let r: $crate::Foo = anything();\n+                r\n+            }};\n+        }\n+        fn main() {\n+            let _a = foo!();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            44..59 '{     loop {} }': T\n+            50..57 'loop {}': !\n+            55..57 '{}': ()\n+            !0..31 '{letr:...g();r}': Foo\n+            !4..5 'r': Foo\n+            !18..26 'anything': fn anything<Foo>() -> Foo\n+            !18..28 'anything()': Foo\n+            !29..30 'r': Foo\n+            163..187 '{     ...!(); }': ()\n+            173..175 '_a': Foo\n+        \"#]],\n+    );\n }\n \n #[test]\n fn issue_4053_diesel_where_clauses() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait BoxedDsl<DB> {\n-    type Output;\n-    fn internal_into_boxed(self) -> Self::Output;\n-}\n+    check_infer(\n+        r#\"\n+        trait BoxedDsl<DB> {\n+            type Output;\n+            fn internal_into_boxed(self) -> Self::Output;\n+        }\n \n-struct SelectStatement<From, Select, Distinct, Where, Order, LimitOffset, GroupBy, Locking> {\n-    order: Order,\n-}\n+        struct SelectStatement<From, Select, Distinct, Where, Order, LimitOffset, GroupBy, Locking> {\n+            order: Order,\n+        }\n \n-trait QueryFragment<DB: Backend> {}\n+        trait QueryFragment<DB: Backend> {}\n \n-trait Into<T> { fn into(self) -> T; }\n+        trait Into<T> { fn into(self) -> T; }\n \n-impl<F, S, D, W, O, LOf, DB> BoxedDsl<DB>\n-    for SelectStatement<F, S, D, W, O, LOf, G>\n-where\n-    O: Into<dyn QueryFragment<DB>>,\n-{\n-    type Output = XXX;\n+        impl<F, S, D, W, O, LOf, DB> BoxedDsl<DB>\n+            for SelectStatement<F, S, D, W, O, LOf, G>\n+        where\n+            O: Into<dyn QueryFragment<DB>>,\n+        {\n+            type Output = XXX;\n \n-    fn internal_into_boxed(self) -> Self::Output {\n-        self.order.into();\n-    }\n-}\n-\"#),\n-        @r###\"\n-    65..69 'self': Self\n-    267..271 'self': Self\n-    466..470 'self': SelectStatement<F, S, D, W, O, LOf, {unknown}, {unknown}>\n-    488..522 '{     ...     }': ()\n-    498..502 'self': SelectStatement<F, S, D, W, O, LOf, {unknown}, {unknown}>\n-    498..508 'self.order': O\n-    498..515 'self.o...into()': dyn QueryFragment<DB>\n-    \"###\n+            fn internal_into_boxed(self) -> Self::Output {\n+                self.order.into();\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            65..69 'self': Self\n+            267..271 'self': Self\n+            466..470 'self': SelectStatement<F, S, D, W, O, LOf, {unknown}, {unknown}>\n+            488..522 '{     ...     }': ()\n+            498..502 'self': SelectStatement<F, S, D, W, O, LOf, {unknown}, {unknown}>\n+            498..508 'self.order': O\n+            498..515 'self.o...into()': dyn QueryFragment<DB>\n+        \"#]],\n     );\n }\n \n #[test]\n fn issue_4953() {\n-    assert_snapshot!(\n-        infer(r#\"\n-pub struct Foo(pub i64);\n-impl Foo {\n-    fn test() -> Self { Self(0i64) }\n-}\n-\"#),\n-        @r###\"\n-    58..72 '{ Self(0i64) }': Foo\n-    60..64 'Self': Foo(i64) -> Foo\n-    60..70 'Self(0i64)': Foo\n-    65..69 '0i64': i64\n-    \"###\n+    check_infer(\n+        r#\"\n+        pub struct Foo(pub i64);\n+        impl Foo {\n+            fn test() -> Self { Self(0i64) }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            58..72 '{ Self(0i64) }': Foo\n+            60..64 'Self': Foo(i64) -> Foo\n+            60..70 'Self(0i64)': Foo\n+            65..69 '0i64': i64\n+        \"#]],\n     );\n-    assert_snapshot!(\n-        infer(r#\"\n-pub struct Foo<T>(pub T);\n-impl Foo<i64> {\n-    fn test() -> Self { Self(0i64) }\n-}\n-\"#),\n-        @r###\"\n-    64..78 '{ Self(0i64) }': Foo<i64>\n-    66..70 'Self': Foo<i64>(i64) -> Foo<i64>\n-    66..76 'Self(0i64)': Foo<i64>\n-    71..75 '0i64': i64\n-    \"###\n+    check_infer(\n+        r#\"\n+        pub struct Foo<T>(pub T);\n+        impl Foo<i64> {\n+            fn test() -> Self { Self(0i64) }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            64..78 '{ Self(0i64) }': Foo<i64>\n+            66..70 'Self': Foo<i64>(i64) -> Foo<i64>\n+            66..76 'Self(0i64)': Foo<i64>\n+            71..75 '0i64': i64\n+        \"#]],\n     );\n }\n \n #[test]\n fn issue_4931() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Div<T> {\n-    type Output;\n-}\n+    check_infer(\n+        r#\"\n+        trait Div<T> {\n+            type Output;\n+        }\n \n-trait CheckedDiv: Div<()> {}\n+        trait CheckedDiv: Div<()> {}\n \n-trait PrimInt: CheckedDiv<Output = ()> {\n-    fn pow(self);\n-}\n+        trait PrimInt: CheckedDiv<Output = ()> {\n+            fn pow(self);\n+        }\n \n-fn check<T: PrimInt>(i: T) {\n-    i.pow();\n-}\n-\"#),\n-        @r###\"\n-    117..121 'self': Self\n-    148..149 'i': T\n-    154..170 '{     ...w(); }': ()\n-    160..161 'i': T\n-    160..167 'i.pow()': ()\n-    \"###\n+        fn check<T: PrimInt>(i: T) {\n+            i.pow();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            117..121 'self': Self\n+            148..149 'i': T\n+            154..170 '{     ...w(); }': ()\n+            160..161 'i': T\n+            160..167 'i.pow()': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn issue_4885() {\n-    assert_snapshot!(\n-        infer(r#\"\n-#[lang = \"coerce_unsized\"]\n-pub trait CoerceUnsized<T> {}\n-\n-trait Future {\n-    type Output;\n-}\n-trait Foo<R> {\n-    type Bar;\n-}\n-fn foo<R, K>(key: &K) -> impl Future<Output = K::Bar>\n-where\n-    K: Foo<R>,\n-{\n-    bar(key)\n-}\n-fn bar<R, K>(key: &K) -> impl Future<Output = K::Bar>\n-where\n-    K: Foo<R>,\n-{\n-}\n-\"#),\n-        @r###\"\n-    136..139 'key': &K\n-    198..214 '{     ...key) }': impl Future<Output = <K as Foo<R>>::Bar>\n-    204..207 'bar': fn bar<R, K>(&K) -> impl Future<Output = <K as Foo<R>>::Bar>\n-    204..212 'bar(key)': impl Future<Output = <K as Foo<R>>::Bar>\n-    208..211 'key': &K\n-    228..231 'key': &K\n-    290..293 '{ }': ()\n-    \"###\n+    check_infer(\n+        r#\"\n+        #[lang = \"coerce_unsized\"]\n+        pub trait CoerceUnsized<T> {}\n+\n+        trait Future {\n+            type Output;\n+        }\n+        trait Foo<R> {\n+            type Bar;\n+        }\n+        fn foo<R, K>(key: &K) -> impl Future<Output = K::Bar>\n+        where\n+            K: Foo<R>,\n+        {\n+            bar(key)\n+        }\n+        fn bar<R, K>(key: &K) -> impl Future<Output = K::Bar>\n+        where\n+            K: Foo<R>,\n+        {\n+        }\n+        \"#,\n+        expect![[r#\"\n+            136..139 'key': &K\n+            198..214 '{     ...key) }': impl Future<Output = <K as Foo<R>>::Bar>\n+            204..207 'bar': fn bar<R, K>(&K) -> impl Future<Output = <K as Foo<R>>::Bar>\n+            204..212 'bar(key)': impl Future<Output = <K as Foo<R>>::Bar>\n+            208..211 'key': &K\n+            228..231 'key': &K\n+            290..293 '{ }': ()\n+        \"#]],\n     );\n }\n \n #[test]\n fn issue_4800() {\n-    assert_snapshot!(\n-        infer(r#\"\n-trait Debug {}\n+    check_infer(\n+        r#\"\n+        trait Debug {}\n \n-struct Foo<T>;\n+        struct Foo<T>;\n \n-type E1<T> = (T, T, T);\n-type E2<T> = E1<E1<E1<(T, T, T)>>>;\n+        type E1<T> = (T, T, T);\n+        type E2<T> = E1<E1<E1<(T, T, T)>>>;\n \n-impl Debug for Foo<E2<()>> {}\n+        impl Debug for Foo<E2<()>> {}\n \n-struct Request;\n+        struct Request;\n \n-pub trait Future {\n-    type Output;\n-}\n+        pub trait Future {\n+            type Output;\n+        }\n \n-pub struct PeerSet<D>;\n+        pub struct PeerSet<D>;\n \n-impl<D> Service<Request> for PeerSet<D>\n-where\n-    D: Discover,\n-    D::Key: Debug,\n-{\n-    type Error = ();\n-    type Future = dyn Future<Output = Self::Error>;\n+        impl<D> Service<Request> for PeerSet<D>\n+        where\n+            D: Discover,\n+            D::Key: Debug,\n+        {\n+            type Error = ();\n+            type Future = dyn Future<Output = Self::Error>;\n \n-    fn call(&mut self) -> Self::Future {\n-        loop {}\n-    }\n-}\n+            fn call(&mut self) -> Self::Future {\n+                loop {}\n+            }\n+        }\n \n-pub trait Discover {\n-    type Key;\n-}\n+        pub trait Discover {\n+            type Key;\n+        }\n \n-pub trait Service<Request> {\n-    type Error;\n-    type Future: Future<Output = Self::Error>;\n-    fn call(&mut self) -> Self::Future;\n-}\n-\"#),\n-        @r###\"\n-    379..383 'self': &mut PeerSet<D>\n-    401..424 '{     ...     }': dyn Future<Output = ()>\n-    411..418 'loop {}': !\n-    416..418 '{}': ()\n-    575..579 'self': &mut Self\n-    \"###\n+        pub trait Service<Request> {\n+            type Error;\n+            type Future: Future<Output = Self::Error>;\n+            fn call(&mut self) -> Self::Future;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            379..383 'self': &mut PeerSet<D>\n+            401..424 '{     ...     }': dyn Future<Output = ()>\n+            411..418 'loop {}': !\n+            416..418 '{}': ()\n+            575..579 'self': &mut Self\n+        \"#]],\n     );\n }\n \n #[test]\n fn issue_4966() {\n-    assert_snapshot!(\n-        infer(r#\"\n-pub trait IntoIterator {\n-    type Item;\n-}\n+    check_infer(\n+        r#\"\n+        pub trait IntoIterator {\n+            type Item;\n+        }\n \n-struct Repeat<A> { element: A }\n+        struct Repeat<A> { element: A }\n \n-struct Map<F> { f: F }\n+        struct Map<F> { f: F }\n \n-struct Vec<T> {}\n+        struct Vec<T> {}\n \n-#[lang = \"deref\"]\n-pub trait Deref {\n-    type Target;\n-}\n+        #[lang = \"deref\"]\n+        pub trait Deref {\n+            type Target;\n+        }\n \n-impl<T> Deref for Vec<T> {\n-    type Target = [T];\n-}\n+        impl<T> Deref for Vec<T> {\n+            type Target = [T];\n+        }\n \n-fn from_iter<A, T: IntoIterator<Item = A>>(iter: T) -> Vec<A> {}\n+        fn from_iter<A, T: IntoIterator<Item = A>>(iter: T) -> Vec<A> {}\n \n-fn main() {\n-    let inner = Map { f: |_: &f64| 0.0 };\n-\n-    let repeat = Repeat { element: inner };\n-\n-    let vec = from_iter(repeat);\n-\n-    vec.foo_bar();\n-}\n-\"#),\n-        @r###\"\n-    270..274 'iter': T\n-    289..291 '{}': ()\n-    303..447 '{     ...r(); }': ()\n-    313..318 'inner': Map<|&f64| -> f64>\n-    321..345 'Map { ... 0.0 }': Map<|&f64| -> f64>\n-    330..343 '|_: &f64| 0.0': |&f64| -> f64\n-    331..332 '_': &f64\n-    340..343 '0.0': f64\n-    356..362 'repeat': Repeat<Map<|&f64| -> f64>>\n-    365..390 'Repeat...nner }': Repeat<Map<|&f64| -> f64>>\n-    383..388 'inner': Map<|&f64| -> f64>\n-    401..404 'vec': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n-    407..416 'from_iter': fn from_iter<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>, Repeat<Map<|&f64| -> f64>>>(Repeat<Map<|&f64| -> f64>>) -> Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n-    407..424 'from_i...epeat)': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n-    417..423 'repeat': Repeat<Map<|&f64| -> f64>>\n-    431..434 'vec': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n-    431..444 'vec.foo_bar()': {unknown}\n-    \"###\n+        fn main() {\n+            let inner = Map { f: |_: &f64| 0.0 };\n+\n+            let repeat = Repeat { element: inner };\n+\n+            let vec = from_iter(repeat);\n+\n+            vec.foo_bar();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            270..274 'iter': T\n+            289..291 '{}': ()\n+            303..447 '{     ...r(); }': ()\n+            313..318 'inner': Map<|&f64| -> f64>\n+            321..345 'Map { ... 0.0 }': Map<|&f64| -> f64>\n+            330..343 '|_: &f64| 0.0': |&f64| -> f64\n+            331..332 '_': &f64\n+            340..343 '0.0': f64\n+            356..362 'repeat': Repeat<Map<|&f64| -> f64>>\n+            365..390 'Repeat...nner }': Repeat<Map<|&f64| -> f64>>\n+            383..388 'inner': Map<|&f64| -> f64>\n+            401..404 'vec': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n+            407..416 'from_iter': fn from_iter<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>, Repeat<Map<|&f64| -> f64>>>(Repeat<Map<|&f64| -> f64>>) -> Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n+            407..424 'from_i...epeat)': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n+            417..423 'repeat': Repeat<Map<|&f64| -> f64>>\n+            431..434 'vec': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n+            431..444 'vec.foo_bar()': {unknown}\n+        \"#]],\n     );\n }"}, {"sha": "3fd7d5cd4ffe62e17be68757cde70e48014d46ef", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 1707, "deletions": 1706, "changes": 3413, "blob_url": "https://github.com/rust-lang/rust/blob/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e"}, {"sha": "d3c4d3f2abd8308d99d10ffdb606faa67405f84a", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 1634, "deletions": 1640, "changes": 3274, "blob_url": "https://github.com/rust-lang/rust/blob/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=f7e4b99d154fa85e4f37aa9e53d4ffb8f4a0073e"}]}