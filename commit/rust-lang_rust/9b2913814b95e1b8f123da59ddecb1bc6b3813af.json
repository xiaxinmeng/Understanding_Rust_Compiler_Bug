{"sha": "9b2913814b95e1b8f123da59ddecb1bc6b3813af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMjkxMzgxNGI5NWUxYjhmMTIzZGE1OWRkZWNiMWJjNmIzODEzYWY=", "commit": {"author": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-09-06T15:14:01Z"}, "committer": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-09-09T00:32:03Z"}, "message": "as casts and block exprs", "tree": {"sha": "04b101f4130e088e35f7753a9b640eebf1797c20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04b101f4130e088e35f7753a9b640eebf1797c20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b2913814b95e1b8f123da59ddecb1bc6b3813af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b2913814b95e1b8f123da59ddecb1bc6b3813af", "html_url": "https://github.com/rust-lang/rust/commit/9b2913814b95e1b8f123da59ddecb1bc6b3813af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b2913814b95e1b8f123da59ddecb1bc6b3813af/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2987f4ba42b002c58ae485f7ae528cb29c3b1611", "url": "https://api.github.com/repos/rust-lang/rust/commits/2987f4ba42b002c58ae485f7ae528cb29c3b1611", "html_url": "https://github.com/rust-lang/rust/commit/2987f4ba42b002c58ae485f7ae528cb29c3b1611"}], "stats": {"total": 92, "additions": 57, "deletions": 35}, "files": [{"sha": "1158a9f4f80082ce26f14d1189914418f216d430", "filename": "compiler/rustc_middle/src/mir/abstract_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b2913814b95e1b8f123da59ddecb1bc6b3813af/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2913814b95e1b8f123da59ddecb1bc6b3813af/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs?ref=9b2913814b95e1b8f123da59ddecb1bc6b3813af", "patch": "@@ -1,5 +1,5 @@\n //! A subset of a mir body used for const evaluatability checking.\n-use crate::mir::{self, CastKind};\n+use crate::mir;\n use crate::ty::{self, Ty};\n \n rustc_index::newtype_index! {\n@@ -18,7 +18,7 @@ pub enum Node<'tcx> {\n     UnaryOp(mir::UnOp, NodeId),\n     FunctionCall(NodeId, &'tcx [NodeId]),\n     Block(&'tcx [NodeId], Option<NodeId>),\n-    Cast(CastKind, NodeId, Ty<'tcx>),\n+    Cast(NodeId, Ty<'tcx>),\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]"}, {"sha": "7d0f6767900a3019ab9bc84bc48daf0363dd18c2", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b2913814b95e1b8f123da59ddecb1bc6b3813af/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2913814b95e1b8f123da59ddecb1bc6b3813af/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=9b2913814b95e1b8f123da59ddecb1bc6b3813af", "patch": "@@ -158,7 +158,7 @@ where\n                 let leaf = leaf.subst(tcx, ct.substs);\n                 self.visit_const(leaf)\n             }\n-            ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n+            ACNode::Cast(_, ty) => self.visit_ty(ty),\n             ACNode::Block(_, _)\n             | ACNode::Binop(..)\n             | ACNode::UnaryOp(..)"}, {"sha": "461ebba58d9853f7a4034465ba054065b4b53da6", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 53, "deletions": 31, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9b2913814b95e1b8f123da59ddecb1bc6b3813af/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2913814b95e1b8f123da59ddecb1bc6b3813af/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=9b2913814b95e1b8f123da59ddecb1bc6b3813af", "patch": "@@ -92,7 +92,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n \n                         ControlFlow::CONTINUE\n                     }\n-                    Node::Cast(_, _, ty) => {\n+                    Node::Cast(_, ty) => {\n                         let ty = ty.subst(tcx, ct.substs);\n                         if ty.has_infer_types_or_consts() {\n                             failure_kind = FailureKind::MentionsInfer;\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 stmts.iter().for_each(|&id| self.nodes[id].used = true);\n                 opt_expr.map(|e| self.nodes[e].used = true);\n             }\n-            Node::Cast(_, operand, _) => {\n+            Node::Cast(operand, _) => {\n                 self.nodes[operand].used = true;\n             }\n         }\n@@ -335,6 +335,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             }\n         }\n \n+        // FIXME I dont even think we can get unused nodes anymore with thir abstract const\n         if let Some(&unused) = self.nodes.iter().find(|n| !n.used) {\n             self.error(Some(unused.span), \"dead code\")?;\n         }\n@@ -352,6 +353,8 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             &ExprKind::PlaceTypeAscription { source, .. } |\n             &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n \n+            // subtle: associated consts are literals this arm handles \n+            // `<T as Trait>::ASSOC` as well as `12` \n             &ExprKind::Literal { literal, .. }\n             | &ExprKind::StaticRef { literal, .. } => self.add_node(Node::Leaf(literal), node.span),\n \n@@ -375,14 +378,6 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 let arg = self.recurse_build(arg)?;\n                 self.add_node(Node::UnaryOp(op, arg), node.span)\n             },\n-            // HACK: without this arm the following doesn't compile:\n-            // ```\n-            // fn foo<const N: usize>(_: [(); N + 1]) {\n-            //     bar::<{ N + 1}>();\n-            // }\n-            // ```\n-            // we ought to properly handle this in `try_unify`\n-            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. }} => self.recurse_build(*e)?,\n             ExprKind::Block { body } => {\n                 let mut stmts = Vec::with_capacity(body.stmts.len());\n                 for &id in body.stmts.iter() {\n@@ -398,26 +393,34 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 let opt_expr = body.expr.map(|e| self.recurse_build(e)).transpose()?;\n                 self.add_node(Node::Block(stmts, opt_expr), node.span)\n             }\n-            &ExprKind::Cast { source } => todo!(),\n+            \n+            // ExprKind::Use happens when a `hir::ExprKind::Cast` is a \n+            // \"coercion cast\" i.e. using a coercion or is a no-op.\n+            // this is important so that `N as usize as usize` doesnt unify with `N as usize`\n+            &ExprKind::Use { source} \n+            | &ExprKind::Cast { source } => {\n+                let arg = self.recurse_build(source)?;\n+                self.add_node(Node::Cast(arg, node.ty), node.span)\n+            },\n             // never can arise even without panic/fail to terminate\n             &ExprKind::NeverToAny { source } => todo!(),\n-            // i think this is a dummy usage of the expr to allow coercions\n-            &ExprKind::Use { source } => todo!(),\n \n-            ExprKind::Return { .. }\n-            | ExprKind::Box { .. } // allocations not allowed in constants\n-            | ExprKind::AssignOp { .. }\n-            | ExprKind::AddressOf { .. } // FIXME(generic_const_exprs)\n-            | ExprKind::Borrow { .. } // FIXME(generic_const_exprs)\n-            | ExprKind::Deref { .. } // FIXME(generic_const_exprs)\n-            | ExprKind::Repeat { .. } // FIXME(generic_const_exprs)\n-            | ExprKind::Array { .. } // FIXME(generic_const_exprs)\n-            | ExprKind::Tuple { .. } // FIXME(generic_const_exprs)\n-            | ExprKind::Index { .. } // FIXME(generic_const_exprs)\n-            | ExprKind::Field { .. } // FIXME(generic_const_exprs)\n-            | ExprKind::ConstBlock { .. } // FIXME(generic_const_exprs)\n-            | ExprKind::Adt(_) // FIXME(generic_const_exprs) we *should* permit this but dont currently\n-            | ExprKind::Match { .. }\n+            // FIXME(generic_const_exprs) we want to support these\n+            ExprKind::AddressOf { .. }\n+            | ExprKind::Borrow { .. }\n+            | ExprKind::Deref { .. }\n+            | ExprKind::Repeat { .. }\n+            | ExprKind::Array { .. }\n+            | ExprKind::Tuple { .. }\n+            | ExprKind::Index { .. }\n+            | ExprKind::Field { .. }\n+            | ExprKind::ConstBlock { .. }\n+            | ExprKind::Adt(_) => return self.error(\n+                    Some(node.span), \n+                    \"unsupported operation in generic constant, this may be supported in the future\",\n+                ).map(|never| never),\n+\n+            ExprKind::Match { .. }\n             | ExprKind::VarRef { .. } //\n             | ExprKind::UpvarRef { .. } // we dont permit let stmts so...\n             | ExprKind::Closure { .. }\n@@ -433,6 +436,9 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             | ExprKind::Pointer { .. } // dont know if this is correct\n             | ExprKind::ThreadLocalRef(_)\n             | ExprKind::LlvmInlineAsm { .. }\n+            | ExprKind::Return { .. }\n+            | ExprKind::Box { .. } // allocations not allowed in constants\n+            | ExprKind::AssignOp { .. }\n             | ExprKind::InlineAsm { .. }\n             | ExprKind::Yield { .. } => return self.error(Some(node.span), \"unsupported operation in generic constant\").map(|never| never),\n         })\n@@ -521,7 +527,7 @@ where\n                 }\n                 ControlFlow::CONTINUE\n             }\n-            Node::Cast(_, operand, _) => recurse(tcx, ct.subtree(operand), f),\n+            Node::Cast(operand, _) => recurse(tcx, ct.subtree(operand), f),\n         }\n     }\n \n@@ -604,11 +610,27 @@ pub(super) fn try_unify<'tcx>(\n                 && iter::zip(a_args, b_args)\n                     .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn)))\n         }\n-        (Node::Cast(a_cast_kind, a_operand, a_ty), Node::Cast(b_cast_kind, b_operand, b_ty))\n-            if (a_ty == b_ty) && (a_cast_kind == b_cast_kind) =>\n+        (Node::Cast(a_operand, a_ty), Node::Cast(b_operand, b_ty))\n+            if (a_ty == b_ty) =>\n         {\n             try_unify(tcx, a.subtree(a_operand), b.subtree(b_operand))\n         }\n-        _ => false,\n+        (Node::Block(a_stmts, a_opt_expr), Node::Block(b_stmts, b_opt_expr))\n+            if a_stmts.len() == b_stmts.len() => {\n+            a_stmts.iter().zip(b_stmts.iter()).all(|(&a_stmt, &b_stmt)| {\n+                try_unify(tcx, a.subtree(a_stmt), b.subtree(b_stmt))\n+            }) && match (a_opt_expr, b_opt_expr) {\n+                (Some(a_expr), Some(b_expr)) => try_unify(tcx, a.subtree(a_expr), b.subtree(b_expr)),\n+                (None, None) => true,\n+                _ => false,\n+            }\n+        }\n+        // use this over `_ => false` to make adding variants to `Node` less error prone\n+        (Node::Block(..), _) \n+        | (Node::Cast(..), _) \n+        | (Node::FunctionCall(..), _) \n+        | (Node::UnaryOp(..), _) \n+        | (Node::Binop(..), _) \n+        | (Node::Leaf(..), _) => false,\n     }\n }"}, {"sha": "3527aede609a4336c58dae562256ae95960f9745", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b2913814b95e1b8f123da59ddecb1bc6b3813af/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2913814b95e1b8f123da59ddecb1bc6b3813af/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=9b2913814b95e1b8f123da59ddecb1bc6b3813af", "patch": "@@ -843,7 +843,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                         let leaf = leaf.subst(self.tcx, ct.substs);\n                         self.visit_const(leaf)\n                     }\n-                    Node::Cast(_, _, ty) => self.visit_ty(ty),\n+                    Node::Cast(_, ty) => self.visit_ty(ty),\n                     Node::Block(_, _)\n                     | Node::Binop(..)\n                     | Node::UnaryOp(..)"}]}