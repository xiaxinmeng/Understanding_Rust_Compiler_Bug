{"sha": "b38f9a5810f28563c45acb1ae8b82438649227c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzOGY5YTU4MTBmMjg1NjNjNDVhY2IxYWU4YjgyNDM4NjQ5MjI3Yzk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-22T17:31:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-22T17:31:39Z"}, "message": "Merge #4570\n\n4570: Use Chalk's built-in impls r=matklad a=flodiebold\n\nThis contains two changes:\r\n - Chalk has begun adding built-in representations of primitive types; use these in our type conversion logic. There's one somewhat 'iffy' part here, namely references; we don't keep track of lifetimes, but Chalk does, so it will expect a lifetime parameter on references. If we didn't provide that, it could cause crashes in Chalk code that expects the lifetime, so I rather hackily add an (always the same) lifetime placeholder during conversion. I expect that we'll fully switch to using Chalk's types everywhere before we add lifetime support, so I think this is the best solution for now.\r\n - let Chalk know about well-known traits (from lang items), so it can apply its built-in impls.\r\n\r\nBefore:\r\n```\r\nTotal expressions: 181485\r\nExpressions of unknown type: 2940 (1%)\r\nExpressions of partially unknown type: 2884 (1%)\r\nType mismatches: 901\r\nInference: 37.821210245s, 0b allocated 0b resident\r\nTotal: 53.399467609s, 0b allocated 0b resident\r\n```\r\n\r\nAfter:\r\n```\r\nTotal expressions: 181485\r\nExpressions of unknown type: 2923 (1%)\r\nExpressions of partially unknown type: 2879 (1%)\r\nType mismatches: 734\r\nInference: 39.157752509s, 0b allocated 0b resident\r\nTotal: 54.110767621s, 0b allocated 0b resident\r\n```\r\n\r\n(I will start splitting up `chalk.rs` in a separate PR, since it's getting pretty big...)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "ea6b68dcbd47a92a5615c74723ae69dafd7d47f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea6b68dcbd47a92a5615c74723ae69dafd7d47f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b38f9a5810f28563c45acb1ae8b82438649227c9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeyAx7CRBK7hj4Ov3rIwAAdHIIAJ/KCHU1YgvJ99WiAoptENQ6\nOcYimeeczQH1NHrsWklLBgQOQ1sPDF0p/98Tb11Yn4y5UXFTsTJ0oFlGt8mW+2YX\nvRo05wyEXgwax02TC70El4vnL1YnRsay81xgK2jlYHfx37Vnr5nJkbkg8PleJqvF\nDmqbhlXn4Vhwckx2VHXS1cDVvULpvT7pl4IbEZlAmmHDUzxzNVGY4W3DUu1USDvx\nb5IThB6pw/3nw+ZRk9pBC5UoZ7I9H1saU9p7n2WSXqlGw1WICJdgwB7qgAmKeLOc\nLzqZQ7WRu1gufkD4PzZ7H74STQvO2MgxsDv9eEPToUePpAJuBn5Q1cLvfEokxFQ=\n=svBw\n-----END PGP SIGNATURE-----\n", "payload": "tree ea6b68dcbd47a92a5615c74723ae69dafd7d47f9\nparent c5a22715809fa79b2c77d461c2161dbf5ebb411a\nparent e0f978018aad1a48390189ce54372913f324b2e3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1590168699 +0000\ncommitter GitHub <noreply@github.com> 1590168699 +0000\n\nMerge #4570\n\n4570: Use Chalk's built-in impls r=matklad a=flodiebold\n\nThis contains two changes:\r\n - Chalk has begun adding built-in representations of primitive types; use these in our type conversion logic. There's one somewhat 'iffy' part here, namely references; we don't keep track of lifetimes, but Chalk does, so it will expect a lifetime parameter on references. If we didn't provide that, it could cause crashes in Chalk code that expects the lifetime, so I rather hackily add an (always the same) lifetime placeholder during conversion. I expect that we'll fully switch to using Chalk's types everywhere before we add lifetime support, so I think this is the best solution for now.\r\n - let Chalk know about well-known traits (from lang items), so it can apply its built-in impls.\r\n\r\nBefore:\r\n```\r\nTotal expressions: 181485\r\nExpressions of unknown type: 2940 (1%)\r\nExpressions of partially unknown type: 2884 (1%)\r\nType mismatches: 901\r\nInference: 37.821210245s, 0b allocated 0b resident\r\nTotal: 53.399467609s, 0b allocated 0b resident\r\n```\r\n\r\nAfter:\r\n```\r\nTotal expressions: 181485\r\nExpressions of unknown type: 2923 (1%)\r\nExpressions of partially unknown type: 2879 (1%)\r\nType mismatches: 734\r\nInference: 39.157752509s, 0b allocated 0b resident\r\nTotal: 54.110767621s, 0b allocated 0b resident\r\n```\r\n\r\n(I will start splitting up `chalk.rs` in a separate PR, since it's getting pretty big...)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b38f9a5810f28563c45acb1ae8b82438649227c9", "html_url": "https://github.com/rust-lang/rust/commit/b38f9a5810f28563c45acb1ae8b82438649227c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b38f9a5810f28563c45acb1ae8b82438649227c9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5a22715809fa79b2c77d461c2161dbf5ebb411a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a22715809fa79b2c77d461c2161dbf5ebb411a", "html_url": "https://github.com/rust-lang/rust/commit/c5a22715809fa79b2c77d461c2161dbf5ebb411a"}, {"sha": "e0f978018aad1a48390189ce54372913f324b2e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f978018aad1a48390189ce54372913f324b2e3", "html_url": "https://github.com/rust-lang/rust/commit/e0f978018aad1a48390189ce54372913f324b2e3"}], "stats": {"total": 295, "additions": 277, "deletions": 18}, "files": [{"sha": "d962db3cc7923ad656ba75055709ce79bdc77c5d", "filename": "crates/ra_hir_def/src/lang_item.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b38f9a5810f28563c45acb1ae8b82438649227c9/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38f9a5810f28563c45acb1ae8b82438649227c9/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs?ref=b38f9a5810f28563c45acb1ae8b82438649227c9", "patch": "@@ -73,8 +73,8 @@ pub struct LangItems {\n }\n \n impl LangItems {\n-    pub fn target<'a>(&'a self, item: &str) -> Option<&'a LangItemTarget> {\n-        self.items.get(item)\n+    pub fn target(&self, item: &str) -> Option<LangItemTarget> {\n+        self.items.get(item).copied()\n     }\n \n     /// Salsa query. This will look for lang items in a specific crate.\n@@ -163,9 +163,13 @@ impl LangItems {\n     ) where\n         T: Into<AttrDefId> + Copy,\n     {\n-        let attrs = db.attrs(item.into());\n-        if let Some(lang_item_name) = attrs.by_key(\"lang\").string_value() {\n+        if let Some(lang_item_name) = lang_attr(db, item) {\n             self.items.entry(lang_item_name.clone()).or_insert_with(|| constructor(item));\n         }\n     }\n }\n+\n+pub fn lang_attr(db: &dyn DefDatabase, item: impl Into<AttrDefId> + Copy) -> Option<SmolStr> {\n+    let attrs = db.attrs(item.into());\n+    attrs.by_key(\"lang\").string_value().cloned()\n+}"}, {"sha": "6826610cb3b5fe29c6666b80b7f5094b2bf95755", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b38f9a5810f28563c45acb1ae8b82438649227c9/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38f9a5810f28563c45acb1ae8b82438649227c9/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=b38f9a5810f28563c45acb1ae8b82438649227c9", "patch": "@@ -2602,3 +2602,81 @@ fn test(x: &dyn Foo) {\n     \"###\n     );\n }\n+\n+#[test]\n+fn builtin_copy() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+struct IsCopy;\n+impl Copy for IsCopy {}\n+struct NotCopy;\n+\n+trait Test { fn test(&self) -> bool; }\n+impl<T: Copy> Test for T {}\n+\n+fn test() {\n+    IsCopy.test();\n+    NotCopy.test();\n+    (IsCopy, IsCopy).test();\n+    (IsCopy, NotCopy).test();\n+}\n+\"#, true),\n+        @r###\"\n+    111..115 'self': &Self\n+    167..268 '{     ...t(); }': ()\n+    173..179 'IsCopy': IsCopy\n+    173..186 'IsCopy.test()': bool\n+    192..199 'NotCopy': NotCopy\n+    192..206 'NotCopy.test()': {unknown}\n+    212..228 '(IsCop...sCopy)': (IsCopy, IsCopy)\n+    212..235 '(IsCop...test()': bool\n+    213..219 'IsCopy': IsCopy\n+    221..227 'IsCopy': IsCopy\n+    241..258 '(IsCop...tCopy)': (IsCopy, NotCopy)\n+    241..265 '(IsCop...test()': {unknown}\n+    242..248 'IsCopy': IsCopy\n+    250..257 'NotCopy': NotCopy\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn builtin_sized() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+trait Test { fn test(&self) -> bool; }\n+impl<T: Sized> Test for T {}\n+\n+fn test() {\n+    1u8.test();\n+    (*\"foo\").test(); // not Sized\n+    (1u8, 1u8).test();\n+    (1u8, *\"foo\").test(); // not Sized\n+}\n+\"#, true),\n+        @r###\"\n+    57..61 'self': &Self\n+    114..229 '{     ...ized }': ()\n+    120..123 '1u8': u8\n+    120..130 '1u8.test()': bool\n+    136..151 '(*\"foo\").test()': {unknown}\n+    137..143 '*\"foo\"': str\n+    138..143 '\"foo\"': &str\n+    170..180 '(1u8, 1u8)': (u8, u8)\n+    170..187 '(1u8, ...test()': bool\n+    171..174 '1u8': u8\n+    176..179 '1u8': u8\n+    193..206 '(1u8, *\"foo\")': (u8, str)\n+    193..213 '(1u8, ...test()': {unknown}\n+    194..197 '1u8': u8\n+    199..205 '*\"foo\"': str\n+    200..205 '\"foo\"': &str\n+    \"###\n+    );\n+}"}, {"sha": "7d3ad6eb4d0c360d39abfe013e8f09576ee85287", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 191, "deletions": 14, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/b38f9a5810f28563c45acb1ae8b82438649227c9/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38f9a5810f28563c45acb1ae8b82438649227c9/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=b38f9a5810f28563c45acb1ae8b82438649227c9", "patch": "@@ -5,20 +5,29 @@ use log::debug;\n \n use chalk_ir::{\n     cast::Cast, fold::shift::Shift, interner::HasInterner, GenericArg, Goal, GoalData,\n-    PlaceholderIndex, TypeName, UniverseIndex,\n+    PlaceholderIndex, Scalar, TypeName, UniverseIndex,\n };\n \n-use hir_def::{AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup, TypeAliasId};\n+use hir_def::{\n+    lang_item::{lang_attr, LangItemTarget},\n+    type_ref::Mutability,\n+    AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup, TypeAliasId,\n+};\n use ra_db::{\n     salsa::{InternId, InternKey},\n     CrateId,\n };\n \n use super::{builtin, AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n-    db::HirDatabase, display::HirDisplay, method_resolution::TyFingerprint, utils::generics,\n+    db::HirDatabase,\n+    display::HirDisplay,\n+    method_resolution::TyFingerprint,\n+    primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain},\n+    utils::generics,\n     ApplicationTy, DebruijnIndex, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n+use chalk_rust_ir::WellKnownTrait;\n \n pub(super) mod tls;\n \n@@ -330,6 +339,9 @@ impl ToChalk for Ty {\n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n         match self {\n             Ty::Apply(apply_ty) => {\n+                if let TypeCtor::Ref(m) = apply_ty.ctor {\n+                    return ref_to_chalk(db, m, apply_ty.parameters);\n+                }\n                 let name = apply_ty.ctor.to_chalk(db);\n                 let substitution = apply_ty.parameters.to_chalk(db);\n                 chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n@@ -373,6 +385,7 @@ impl ToChalk for Ty {\n         match chalk.data(&Interner).clone() {\n             chalk_ir::TyData::Apply(apply_ty) => match apply_ty.name {\n                 TypeName::Error => Ty::Unknown,\n+                TypeName::Ref(m) => ref_from_chalk(db, m, apply_ty.substitution),\n                 _ => {\n                     let ctor = from_chalk(db, apply_ty.name);\n                     let parameters = from_chalk(db, apply_ty.substitution);\n@@ -409,6 +422,41 @@ impl ToChalk for Ty {\n     }\n }\n \n+const LIFETIME_PLACEHOLDER: PlaceholderIndex =\n+    PlaceholderIndex { ui: UniverseIndex::ROOT, idx: usize::MAX };\n+\n+/// We currently don't model lifetimes, but Chalk does. So, we have to insert a\n+/// fake lifetime here, because Chalks built-in logic may expect it to be there.\n+fn ref_to_chalk(\n+    db: &dyn HirDatabase,\n+    mutability: Mutability,\n+    subst: Substs,\n+) -> chalk_ir::Ty<Interner> {\n+    let arg = subst[0].clone().to_chalk(db);\n+    let lifetime = LIFETIME_PLACEHOLDER.to_lifetime(&Interner);\n+    chalk_ir::ApplicationTy {\n+        name: TypeName::Ref(mutability.to_chalk(db)),\n+        substitution: chalk_ir::Substitution::from(\n+            &Interner,\n+            vec![lifetime.cast(&Interner), arg.cast(&Interner)],\n+        ),\n+    }\n+    .intern(&Interner)\n+}\n+\n+/// Here we remove the lifetime from the type we got from Chalk.\n+fn ref_from_chalk(\n+    db: &dyn HirDatabase,\n+    mutability: chalk_ir::Mutability,\n+    subst: chalk_ir::Substitution<Interner>,\n+) -> Ty {\n+    let tys = subst\n+        .iter(&Interner)\n+        .filter_map(|p| Some(from_chalk(db, p.ty(&Interner)?.clone())))\n+        .collect();\n+    Ty::apply(TypeCtor::Ref(from_chalk(db, mutability)), Substs(tys))\n+}\n+\n impl ToChalk for Substs {\n     type Chalk = chalk_ir::Substitution<Interner>;\n \n@@ -465,7 +513,31 @@ impl ToChalk for TypeCtor {\n                 let type_id = type_alias.to_chalk(db);\n                 TypeName::AssociatedType(type_id)\n             }\n-            _ => {\n+\n+            TypeCtor::Bool => TypeName::Scalar(Scalar::Bool),\n+            TypeCtor::Char => TypeName::Scalar(Scalar::Char),\n+            TypeCtor::Int(Uncertain::Known(int_ty)) => TypeName::Scalar(int_ty_to_chalk(int_ty)),\n+            TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X32 })) => {\n+                TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32))\n+            }\n+            TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X64 })) => {\n+                TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64))\n+            }\n+\n+            TypeCtor::Tuple { cardinality } => TypeName::Tuple(cardinality.into()),\n+            TypeCtor::RawPtr(mutability) => TypeName::Raw(mutability.to_chalk(db)),\n+            TypeCtor::Slice => TypeName::Slice,\n+            TypeCtor::Ref(mutability) => TypeName::Ref(mutability.to_chalk(db)),\n+            TypeCtor::Str => TypeName::Str,\n+\n+            TypeCtor::Int(Uncertain::Unknown)\n+            | TypeCtor::Float(Uncertain::Unknown)\n+            | TypeCtor::Adt(_)\n+            | TypeCtor::Array\n+            | TypeCtor::FnDef(_)\n+            | TypeCtor::FnPtr { .. }\n+            | TypeCtor::Never\n+            | TypeCtor::Closure { .. } => {\n                 // other TypeCtors get interned and turned into a chalk StructId\n                 let struct_id = db.intern_type_ctor(self).into();\n                 TypeName::Adt(struct_id)\n@@ -479,12 +551,27 @@ impl ToChalk for TypeCtor {\n             TypeName::AssociatedType(type_id) => TypeCtor::AssociatedType(from_chalk(db, type_id)),\n             TypeName::OpaqueType(_) => unreachable!(),\n \n-            TypeName::Scalar(_) => unreachable!(),\n-            TypeName::Tuple(_) => unreachable!(),\n-            TypeName::Raw(_) => unreachable!(),\n-            TypeName::Slice => unreachable!(),\n-            TypeName::Ref(_) => unreachable!(),\n-            TypeName::Str => unreachable!(),\n+            TypeName::Scalar(Scalar::Bool) => TypeCtor::Bool,\n+            TypeName::Scalar(Scalar::Char) => TypeCtor::Char,\n+            TypeName::Scalar(Scalar::Int(int_ty)) => TypeCtor::Int(Uncertain::Known(IntTy {\n+                signedness: Signedness::Signed,\n+                bitness: bitness_from_chalk_int(int_ty),\n+            })),\n+            TypeName::Scalar(Scalar::Uint(uint_ty)) => TypeCtor::Int(Uncertain::Known(IntTy {\n+                signedness: Signedness::Unsigned,\n+                bitness: bitness_from_chalk_uint(uint_ty),\n+            })),\n+            TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32)) => {\n+                TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X32 }))\n+            }\n+            TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64)) => {\n+                TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X64 }))\n+            }\n+            TypeName::Tuple(cardinality) => TypeCtor::Tuple { cardinality: cardinality as u16 },\n+            TypeName::Raw(mutability) => TypeCtor::RawPtr(from_chalk(db, mutability)),\n+            TypeName::Slice => TypeCtor::Slice,\n+            TypeName::Ref(mutability) => TypeCtor::Ref(from_chalk(db, mutability)),\n+            TypeName::Str => TypeCtor::Str,\n \n             TypeName::FnDef(_) => unreachable!(),\n \n@@ -496,6 +583,71 @@ impl ToChalk for TypeCtor {\n     }\n }\n \n+fn bitness_from_chalk_uint(uint_ty: chalk_ir::UintTy) -> IntBitness {\n+    use chalk_ir::UintTy;\n+\n+    match uint_ty {\n+        UintTy::Usize => IntBitness::Xsize,\n+        UintTy::U8 => IntBitness::X8,\n+        UintTy::U16 => IntBitness::X16,\n+        UintTy::U32 => IntBitness::X32,\n+        UintTy::U64 => IntBitness::X64,\n+        UintTy::U128 => IntBitness::X128,\n+    }\n+}\n+\n+fn bitness_from_chalk_int(int_ty: chalk_ir::IntTy) -> IntBitness {\n+    use chalk_ir::IntTy;\n+\n+    match int_ty {\n+        IntTy::Isize => IntBitness::Xsize,\n+        IntTy::I8 => IntBitness::X8,\n+        IntTy::I16 => IntBitness::X16,\n+        IntTy::I32 => IntBitness::X32,\n+        IntTy::I64 => IntBitness::X64,\n+        IntTy::I128 => IntBitness::X128,\n+    }\n+}\n+\n+fn int_ty_to_chalk(int_ty: IntTy) -> Scalar {\n+    use chalk_ir::{IntTy, UintTy};\n+\n+    match int_ty.signedness {\n+        Signedness::Signed => Scalar::Int(match int_ty.bitness {\n+            IntBitness::Xsize => IntTy::Isize,\n+            IntBitness::X8 => IntTy::I8,\n+            IntBitness::X16 => IntTy::I16,\n+            IntBitness::X32 => IntTy::I32,\n+            IntBitness::X64 => IntTy::I64,\n+            IntBitness::X128 => IntTy::I128,\n+        }),\n+        Signedness::Unsigned => Scalar::Uint(match int_ty.bitness {\n+            IntBitness::Xsize => UintTy::Usize,\n+            IntBitness::X8 => UintTy::U8,\n+            IntBitness::X16 => UintTy::U16,\n+            IntBitness::X32 => UintTy::U32,\n+            IntBitness::X64 => UintTy::U64,\n+            IntBitness::X128 => UintTy::U128,\n+        }),\n+    }\n+}\n+\n+impl ToChalk for Mutability {\n+    type Chalk = chalk_ir::Mutability;\n+    fn to_chalk(self, _db: &dyn HirDatabase) -> Self::Chalk {\n+        match self {\n+            Mutability::Shared => chalk_ir::Mutability::Not,\n+            Mutability::Mut => chalk_ir::Mutability::Mut,\n+        }\n+    }\n+    fn from_chalk(_db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n+        match chalk {\n+            chalk_ir::Mutability::Mut => Mutability::Mut,\n+            chalk_ir::Mutability::Not => Mutability::Shared,\n+        }\n+    }\n+}\n+\n impl ToChalk for Impl {\n     type Chalk = ImplId;\n \n@@ -907,10 +1059,15 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     }\n     fn well_known_trait_id(\n         &self,\n-        _well_known_trait: chalk_rust_ir::WellKnownTrait,\n+        well_known_trait: chalk_rust_ir::WellKnownTrait,\n     ) -> Option<chalk_ir::TraitId<Interner>> {\n-        // FIXME tell Chalk about well-known traits (here and in trait_datum)\n-        None\n+        let lang_attr = lang_attr_from_well_known_trait(well_known_trait);\n+        let lang_items = self.db.crate_lang_items(self.krate);\n+        let trait_ = match lang_items.target(lang_attr) {\n+            Some(LangItemTarget::TraitId(trait_)) => trait_,\n+            _ => return None,\n+        };\n+        Some(trait_.to_chalk(self.db))\n     }\n \n     fn program_clauses_for_env(\n@@ -1012,7 +1169,8 @@ pub(crate) fn trait_datum_query(\n     let associated_ty_ids =\n         trait_data.associated_types().map(|type_alias| type_alias.to_chalk(db)).collect();\n     let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses };\n-    let well_known = None; // FIXME set this (depending on lang items)\n+    let well_known =\n+        lang_attr(db.upcast(), trait_).and_then(|name| well_known_trait_from_lang_attr(&name));\n     let trait_datum = TraitDatum {\n         id: trait_id,\n         binders: make_binders(trait_datum_bound, bound_vars.len()),\n@@ -1023,6 +1181,25 @@ pub(crate) fn trait_datum_query(\n     Arc::new(trait_datum)\n }\n \n+fn well_known_trait_from_lang_attr(name: &str) -> Option<WellKnownTrait> {\n+    Some(match name {\n+        \"sized\" => WellKnownTrait::SizedTrait,\n+        \"copy\" => WellKnownTrait::CopyTrait,\n+        \"clone\" => WellKnownTrait::CloneTrait,\n+        \"drop\" => WellKnownTrait::DropTrait,\n+        _ => return None,\n+    })\n+}\n+\n+fn lang_attr_from_well_known_trait(attr: WellKnownTrait) -> &'static str {\n+    match attr {\n+        WellKnownTrait::SizedTrait => \"sized\",\n+        WellKnownTrait::CopyTrait => \"copy\",\n+        WellKnownTrait::CloneTrait => \"clone\",\n+        WellKnownTrait::DropTrait => \"drop\",\n+    }\n+}\n+\n pub(crate) fn struct_datum_query(\n     db: &dyn HirDatabase,\n     krate: CrateId,"}]}