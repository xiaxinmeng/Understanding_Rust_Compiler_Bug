{"sha": "2086f97bbd4f960d0a5872eddf6228d003c242f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwODZmOTdiYmQ0Zjk2MGQwYTU4NzJlZGRmNjIyOGQwMDNjMjQyZjE=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-02T06:56:12Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-02T06:56:12Z"}, "message": "Merge pull request #275 from Manishearth/shadow\n\nextended pattern matching", "tree": {"sha": "c27b6957520e56585ca707dc4b2c12f829dcbaa9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c27b6957520e56585ca707dc4b2c12f829dcbaa9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2086f97bbd4f960d0a5872eddf6228d003c242f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2086f97bbd4f960d0a5872eddf6228d003c242f1", "html_url": "https://github.com/rust-lang/rust/commit/2086f97bbd4f960d0a5872eddf6228d003c242f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2086f97bbd4f960d0a5872eddf6228d003c242f1/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91c3c978285041005b8002c1587b16c883fc0a0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/91c3c978285041005b8002c1587b16c883fc0a0f", "html_url": "https://github.com/rust-lang/rust/commit/91c3c978285041005b8002c1587b16c883fc0a0f"}, {"sha": "0fb7d1d2d98016b496c36606ab003fd5d0b7e994", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fb7d1d2d98016b496c36606ab003fd5d0b7e994", "html_url": "https://github.com/rust-lang/rust/commit/0fb7d1d2d98016b496c36606ab003fd5d0b7e994"}], "stats": {"total": 120, "additions": 88, "deletions": 32}, "files": [{"sha": "751077ec1d90b6f7ee6d68cd117a0ce65528c8d2", "filename": "src/shadow.rs", "status": "modified", "additions": 60, "deletions": 21, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2086f97bbd4f960d0a5872eddf6228d003c242f1/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2086f97bbd4f960d0a5872eddf6228d003c242f1/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=2086f97bbd4f960d0a5872eddf6228d003c242f1", "patch": "@@ -6,7 +6,7 @@ use syntax::visit::FnKind;\n use rustc::lint::{Context, LintArray, LintPass};\n use rustc::middle::def::Def::{DefVariant, DefStruct};\n \n-use utils::{in_external_macro, snippet, span_lint};\n+use utils::{in_external_macro, snippet, span_lint, span_note_and_lint};\n \n declare_lint!(pub SHADOW_SAME, Allow,\n     \"rebinding a name to itself, e.g. `let mut x = &mut x`\");\n@@ -60,8 +60,12 @@ fn check_decl(cx: &Context, decl: &Decl, bindings: &mut Vec<Name>) {\n     if let DeclLocal(ref local) = decl.node {\n         let Local{ ref pat, ref ty, ref init, id: _, span } = **local;\n         if let &Some(ref t) = ty { check_ty(cx, t, bindings) }\n-        if let &Some(ref o) = init { check_expr(cx, o, bindings) }\n-        check_pat(cx, pat, init, span, bindings);\n+        if let &Some(ref o) = init {\n+            check_expr(cx, o, bindings);\n+            check_pat(cx, pat, &Some(o), span, bindings);\n+        } else {\n+            check_pat(cx, pat, &None, span, bindings);\n+        }\n     }\n }\n \n@@ -72,8 +76,8 @@ fn is_binding(cx: &Context, pat: &Pat) -> bool {\n     }\n }\n \n-fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,\n-        bindings: &mut Vec<Name>) where T: Deref<Target=Expr> {\n+fn check_pat(cx: &Context, pat: &Pat, init: &Option<&Expr>, span: Span,\n+        bindings: &mut Vec<Name>) {\n     //TODO: match more stuff / destructuring\n     match pat.node {\n         PatIdent(_, ref ident, ref inner) => {\n@@ -88,22 +92,55 @@ fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,\n             if let Some(ref p) = *inner { check_pat(cx, p, init, span, bindings); }\n         },\n         //PatEnum(Path, Option<Vec<P<Pat>>>),\n-        //PatQPath(QSelf, Path),\n-        //PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n-        //PatTup(Vec<P<Pat>>),\n+        PatStruct(_, ref pfields, _) =>\n+            if let Some(ref init_struct) = *init {\n+                if let ExprStruct(_, ref efields, _) = init_struct.node {\n+                    for field in pfields {\n+                        let ident = field.node.ident;\n+                        let efield = efields.iter()\n+                            .find(|ref f| f.ident.node == ident)\n+                            .map(|f| &*f.expr);\n+                        check_pat(cx, &field.node.pat, &efield, span, bindings);\n+                    }\n+                } else {\n+                    for field in pfields {\n+                        check_pat(cx, &field.node.pat, init, span, bindings);\n+                    }\n+                }\n+            } else {\n+                for field in pfields {\n+                    check_pat(cx, &field.node.pat, &None, span, bindings);\n+                }\n+            },\n+        PatTup(ref inner) =>\n+            if let Some(ref init_tup) = *init {\n+                if let ExprTup(ref tup) = init_tup.node {\n+                    for (i, p) in inner.iter().enumerate() {\n+                        check_pat(cx, p, &Some(&tup[i]), p.span, bindings);\n+                    }\n+                } else {\n+                    for p in inner {\n+                        check_pat(cx, p, init, span, bindings);\n+                    }\n+                }\n+            } else {\n+                for p in inner {\n+                    check_pat(cx, p, &None, span, bindings);\n+                }\n+            },\n         PatBox(ref inner) => {\n             if let Some(ref initp) = *init {\n-                match initp.node {\n-                    ExprBox(_, ref inner_init) =>\n-                        check_pat(cx, inner, &Some(&**inner_init), span, bindings),\n-                    //TODO: ExprCall on Box::new\n-                    _ => check_pat(cx, inner, init, span, bindings),\n+                if let ExprBox(_, ref inner_init) = initp.node {\n+                    check_pat(cx, inner, &Some(&**inner_init), span, bindings);\n+                } else {\n+                    check_pat(cx, inner, init, span, bindings);\n                 }\n             } else {\n                 check_pat(cx, inner, init, span, bindings);\n             }\n         },\n-        //PatRegion(P<Pat>, Mutability),\n+        PatRegion(ref inner, _) =>\n+            check_pat(cx, inner, init, span, bindings),\n         //PatRange(P<Expr>, P<Expr>),\n         //PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n         _ => (),\n@@ -112,28 +149,30 @@ fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,\n \n fn lint_shadow<T>(cx: &Context, name: Name, span: Span, lspan: Span, init:\n         &Option<T>) where T: Deref<Target=Expr> {\n-    if let &Some(ref expr) = init {\n+    if let Some(ref expr) = *init {\n         if is_self_shadow(name, expr) {\n             span_lint(cx, SHADOW_SAME, span, &format!(\n                 \"{} is shadowed by itself in {}\",\n                 snippet(cx, lspan, \"_\"),\n                 snippet(cx, expr.span, \"..\")));\n         } else {\n             if contains_self(name, expr) {\n-                span_lint(cx, SHADOW_REUSE, span, &format!(\n+                span_note_and_lint(cx, SHADOW_REUSE, lspan, &format!(\n                     \"{} is shadowed by {} which reuses the original value\",\n                     snippet(cx, lspan, \"_\"),\n-                    snippet(cx, expr.span, \"..\")));\n+                    snippet(cx, expr.span, \"..\")),\n+                    expr.span, \"initialization happens here\");\n             } else {\n-                span_lint(cx, SHADOW_UNRELATED, span, &format!(\n-                    \"{} is shadowed by {} in this declaration\",\n+                span_note_and_lint(cx, SHADOW_UNRELATED, lspan, &format!(\n+                    \"{} is shadowed by {}\",\n                     snippet(cx, lspan, \"_\"),\n-                    snippet(cx, expr.span, \"..\")));\n+                    snippet(cx, expr.span, \"..\")),\n+                    expr.span, \"initialization happens here\");\n             }\n         }\n     } else {\n         span_lint(cx, SHADOW_UNRELATED, span, &format!(\n-            \"{} is shadowed in this declaration\", snippet(cx, lspan, \"_\")));\n+            \"{} shadows a previous declaration\", snippet(cx, lspan, \"_\")));\n     }\n }\n "}, {"sha": "2f9b86964c2332c762a625479e68612ac3deee30", "filename": "src/utils.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2086f97bbd4f960d0a5872eddf6228d003c242f1/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2086f97bbd4f960d0a5872eddf6228d003c242f1/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=2086f97bbd4f960d0a5872eddf6228d003c242f1", "patch": "@@ -23,7 +23,7 @@ pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n                 if info.callee.name() == \"closure expansion\" {\n                     return false;\n                 }\n-            }, \n+            },\n             ExpnFormat::MacroAttribute(..) => {\n                 // these are all plugins\n                 return true;\n@@ -177,14 +177,29 @@ pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n \n pub fn span_help_and_lint(cx: &Context, lint: &'static Lint, span: Span,\n         msg: &str, help: &str) {\n-    span_lint(cx, lint, span, msg);\n+    cx.span_lint(lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {\n         cx.sess().fileline_help(span, &format!(\"{}\\nfor further information \\\n             visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n             help, lint.name_lower()))\n     }\n }\n \n+pub fn span_note_and_lint(cx: &Context, lint: &'static Lint, span: Span,\n+        msg: &str, note_span: Span, note: &str) {\n+    cx.span_lint(lint, span, msg);\n+    if cx.current_level(lint) != Level::Allow {\n+        if note_span == span {\n+            cx.sess().fileline_note(note_span, note)\n+        } else {\n+            cx.sess().span_note(note_span, note)\n+        }\n+        cx.sess().fileline_help(span, &format!(\"for further information visit \\\n+            https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+            lint.name_lower()))\n+    }\n+}\n+\n /// return the base type for references and raw pointers\n pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n     match ty.sty {"}, {"sha": "07dc7c9ef83d23dae6e070b97f307149eb0fb711", "filename": "tests/compile-fail/matches.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2086f97bbd4f960d0a5872eddf6228d003c242f1/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2086f97bbd4f960d0a5872eddf6228d003c242f1/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=2086f97bbd4f960d0a5872eddf6228d003c242f1", "patch": "@@ -39,14 +39,16 @@ fn single_match(){\n }\n \n fn ref_pats() {\n-    let ref v = Some(0);\n-    match v {  //~ERROR instead of prefixing all patterns with `&`\n-        &Some(v) => println!(\"{:?}\", v),\n-        &None => println!(\"none\"),\n-    }\n-    match v {  // this doesn't trigger, we have a different pattern\n-        &Some(v) => println!(\"some\"),\n-        other => println!(\"other\"),\n+    {\n+        let ref v = Some(0);\n+        match v {  //~ERROR instead of prefixing all patterns with `&`\n+            &Some(v) => println!(\"{:?}\", v),\n+            &None => println!(\"none\"),\n+        }\n+        match v {  // this doesn't trigger, we have a different pattern\n+            &Some(v) => println!(\"some\"),\n+            other => println!(\"other\"),\n+        }\n     }\n     let ref tup = (1, 2);\n     match tup {  //~ERROR instead of prefixing all patterns with `&`"}, {"sha": "80d48f8416389f4bf19a88d95d345e25c1bcedda", "filename": "tests/compile-fail/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2086f97bbd4f960d0a5872eddf6228d003c242f1/tests%2Fcompile-fail%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2086f97bbd4f960d0a5872eddf6228d003c242f1/tests%2Fcompile-fail%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fshadow.rs?ref=2086f97bbd4f960d0a5872eddf6228d003c242f1", "patch": "@@ -18,7 +18,7 @@ fn main() {\n     let x = (1, x); //~ERROR: x is shadowed by (1, x) which reuses\n     let x = first(x); //~ERROR: x is shadowed by first(x) which reuses\n     let y = 1;\n-    let x = y; //~ERROR: x is shadowed by y in this declaration\n+    let x = y; //~ERROR: x is shadowed by y\n \n     let o = Some(1u8);\n "}]}