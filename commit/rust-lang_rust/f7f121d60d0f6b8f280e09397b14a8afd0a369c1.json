{"sha": "f7f121d60d0f6b8f280e09397b14a8afd0a369c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZjEyMWQ2MGQwZjZiOGYyODBlMDkzOTdiMTRhOGFmZDBhMzY5YzE=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-04-04T08:09:36Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-04-09T17:18:47Z"}, "message": "Add dylib loading code", "tree": {"sha": "5d239767123783ebf7f3a83b029d55a1c181c9e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d239767123783ebf7f3a83b029d55a1c181c9e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7f121d60d0f6b8f280e09397b14a8afd0a369c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f121d60d0f6b8f280e09397b14a8afd0a369c1", "html_url": "https://github.com/rust-lang/rust/commit/f7f121d60d0f6b8f280e09397b14a8afd0a369c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7f121d60d0f6b8f280e09397b14a8afd0a369c1/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dde9488559514e7d039cec9407e1f8627f665cd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/dde9488559514e7d039cec9407e1f8627f665cd0", "html_url": "https://github.com/rust-lang/rust/commit/dde9488559514e7d039cec9407e1f8627f665cd0"}], "stats": {"total": 278, "additions": 277, "deletions": 1}, "files": [{"sha": "5f7c52e0a17eaf1b7020571aca9be4d473223410", "filename": "Cargo.lock", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f7f121d60d0f6b8f280e09397b14a8afd0a369c1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f7f121d60d0f6b8f280e09397b14a8afd0a369c1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f7f121d60d0f6b8f280e09397b14a8afd0a369c1", "patch": "@@ -424,6 +424,17 @@ dependencies = [\n  \"regex\",\n ]\n \n+[[package]]\n+name = \"goblin\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ddd5e3132801a1ac34ac53b97acde50c4685414dd2f291b9ea52afa6f07468c8\"\n+dependencies = [\n+ \"log\",\n+ \"plain\",\n+ \"scroll\",\n+]\n+\n [[package]]\n name = \"heck\"\n version = \"0.3.1\"\n@@ -586,6 +597,15 @@ version = \"0.2.68\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dea0c0405123bba743ee3f91f49b1c7cfb684eef0da0a50110f758ccf24cdff0\"\n \n+[[package]]\n+name = \"libloading\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2c979a19ffb457f0273965c333053f3d586bf759bf7b683fbebc37f9a9ebedc4\"\n+dependencies = [\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"linked-hash-map\"\n version = \"0.5.2\"\n@@ -825,6 +845,12 @@ version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3ad1f1b834a05d42dae330066e9699a173b28185b3bdc3dbf14ca239585de8cc\"\n \n+[[package]]\n+name = \"plain\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b4596b6d070b27117e987119b4dac604f3c58cfb0b191112e24771b2faeac1a6\"\n+\n [[package]]\n name = \"ppv-lite86\"\n version = \"0.2.6\"\n@@ -1081,6 +1107,8 @@ version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata\",\n  \"difference\",\n+ \"goblin\",\n+ \"libloading\",\n  \"ra_mbe\",\n  \"ra_proc_macro\",\n  \"ra_tt\",\n@@ -1396,6 +1424,26 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n \n+[[package]]\n+name = \"scroll\"\n+version = \"0.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"abb2332cb595d33f7edd5700f4cbf94892e680c7f0ae56adab58a35190b66cb1\"\n+dependencies = [\n+ \"scroll_derive\",\n+]\n+\n+[[package]]\n+name = \"scroll_derive\"\n+version = \"0.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f8584eea9b9ff42825b46faf46a8c24d2cff13ec152fa2a50df788b87c07ee28\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"semver\"\n version = \"0.9.0\""}, {"sha": "437b8f475f195bce1c2d3f61f002957d99b92761", "filename": "crates/ra_proc_macro_srv/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7f121d60d0f6b8f280e09397b14a8afd0a369c1/crates%2Fra_proc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f7f121d60d0f6b8f280e09397b14a8afd0a369c1/crates%2Fra_proc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2FCargo.toml?ref=f7f121d60d0f6b8f280e09397b14a8afd0a369c1", "patch": "@@ -12,9 +12,11 @@ doctest = false\n ra_tt = { path = \"../ra_tt\" }\n ra_mbe = { path = \"../ra_mbe\" }\n ra_proc_macro = { path = \"../ra_proc_macro\" }\n+goblin = \"0.2.1\"\n+libloading = \"0.6.0\"\n \n [dev-dependencies]\n cargo_metadata = \"0.9.1\"\n difference = \"2.0.0\"\n # used as proc macro test target\n-serde_derive = \"=1.0.104\"\n\\ No newline at end of file\n+serde_derive = \"=1.0.104\""}, {"sha": "525c7ac7b5a973b26fc047c63f24faea63c7315a", "filename": "crates/ra_proc_macro_srv/src/dylib.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/f7f121d60d0f6b8f280e09397b14a8afd0a369c1/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f121d60d0f6b8f280e09397b14a8afd0a369c1/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs?ref=f7f121d60d0f6b8f280e09397b14a8afd0a369c1", "patch": "@@ -0,0 +1,220 @@\n+//! Handles dynamic library loading for proc macro\n+\n+use crate::{proc_macro::bridge, rustc_server::TokenStream};\n+use std::fs::File;\n+use std::io::Read;\n+use std::path::Path;\n+\n+use goblin::{mach::Mach, Object};\n+use libloading::Library;\n+use ra_proc_macro::ProcMacroKind;\n+\n+static NEW_REGISTRAR_SYMBOL: &str = \"__rustc_proc_macro_decls_\";\n+static _OLD_REGISTRAR_SYMBOL: &str = \"__rustc_derive_registrar_\";\n+\n+fn read_bytes(file: &Path) -> Option<Vec<u8>> {\n+    let mut fd = File::open(file).ok()?;\n+    let mut buffer = Vec::new();\n+    fd.read_to_end(&mut buffer).ok()?;\n+\n+    Some(buffer)\n+}\n+\n+fn get_symbols_from_lib(file: &Path) -> Option<Vec<String>> {\n+    let buffer = read_bytes(file)?;\n+    let object = Object::parse(&buffer).ok()?;\n+\n+    return match object {\n+        Object::Elf(elf) => {\n+            let symbols = elf.dynstrtab.to_vec().ok()?;\n+            let names = symbols.iter().map(|s| s.to_string()).collect();\n+\n+            Some(names)\n+        }\n+\n+        Object::PE(pe) => {\n+            let symbol_names =\n+                pe.exports.iter().flat_map(|s| s.name).map(|n| n.to_string()).collect();\n+            Some(symbol_names)\n+        }\n+\n+        Object::Mach(mach) => match mach {\n+            Mach::Binary(binary) => {\n+                let exports = binary.exports().ok()?;\n+                let names = exports.iter().map(|s| s.name.clone()).collect();\n+\n+                Some(names)\n+            }\n+\n+            Mach::Fat(_) => None,\n+        },\n+\n+        Object::Archive(_) | Object::Unknown(_) => None,\n+    };\n+}\n+\n+fn is_derive_registrar_symbol(symbol: &str) -> bool {\n+    symbol.contains(NEW_REGISTRAR_SYMBOL)\n+}\n+\n+fn find_registrar_symbol(file: &Path) -> Option<String> {\n+    let symbols = get_symbols_from_lib(file)?;\n+\n+    symbols.iter().find(|s| is_derive_registrar_symbol(s)).map(|s| s.to_string())\n+}\n+\n+/// Loads dynamic library in platform dependent manner.\n+///\n+/// For unix, you have to use RTLD_DEEPBIND flag to escape problems described\n+/// [here](https://github.com/fedochet/rust-proc-macro-panic-inside-panic-expample)\n+/// and [here](https://github.com/rust-lang/rust/issues/60593).\n+///\n+/// Usage of RTLD_DEEPBIND\n+/// [here](https://github.com/fedochet/rust-proc-macro-panic-inside-panic-expample/issues/1)\n+///\n+/// It seems that on Windows that behaviour is default, so we do nothing in that case.\n+#[cfg(windows)]\n+fn load_library(file: &Path) -> Result<Library, libloading::Error> {\n+    Library::new(file)\n+}\n+\n+#[cfg(unix)]\n+fn load_library(file: &Path) -> Result<Library, libloading::Error> {\n+    use libloading::os::unix::Library as UnixLibrary;\n+    use std::os::raw::c_int;\n+\n+    const RTLD_NOW: c_int = 0x00002;\n+    const RTLD_DEEPBIND: c_int = 0x00008;\n+\n+    UnixLibrary::open(Some(file), RTLD_NOW | RTLD_DEEPBIND).map(|lib| lib.into())\n+}\n+\n+struct ProcMacroLibraryLibloading {\n+    // Hold the dylib to prevent it for unloadeding\n+    #[allow(dead_code)]\n+    lib: Library,\n+    exported_macros: Vec<bridge::client::ProcMacro>,\n+}\n+\n+impl ProcMacroLibraryLibloading {\n+    fn open(file: &Path) -> Result<Self, String> {\n+        let symbol_name = find_registrar_symbol(file)\n+            .ok_or(format!(\"Cannot find registrar symbol in file {:?}\", file))?;\n+\n+        let lib = load_library(file).map_err(|e| e.to_string())?;\n+\n+        let exported_macros = {\n+            let macros: libloading::Symbol<&&[bridge::client::ProcMacro]> =\n+                unsafe { lib.get(symbol_name.as_bytes()) }.map_err(|e| e.to_string())?;\n+\n+            macros.to_vec()\n+        };\n+\n+        Ok(ProcMacroLibraryLibloading { lib, exported_macros })\n+    }\n+}\n+\n+type ProcMacroLibraryImpl = ProcMacroLibraryLibloading;\n+\n+pub struct Expander {\n+    libs: Vec<ProcMacroLibraryImpl>,\n+}\n+\n+impl Expander {\n+    pub fn new<P: AsRef<Path>>(lib: &P) -> Result<Expander, String> {\n+        let mut libs = vec![];\n+\n+        /* Some libraries for dynamic loading require canonicalized path (even when it is\n+        already absolute\n+        */\n+        let lib =\n+            lib.as_ref().canonicalize().expect(&format!(\"Cannot canonicalize {:?}\", lib.as_ref()));\n+\n+        let library = ProcMacroLibraryImpl::open(&lib)?;\n+        libs.push(library);\n+\n+        Ok(Expander { libs })\n+    }\n+\n+    pub fn expand(\n+        &self,\n+        macro_name: &str,\n+        macro_body: &ra_tt::Subtree,\n+        attributes: Option<&ra_tt::Subtree>,\n+    ) -> Result<ra_tt::Subtree, bridge::PanicMessage> {\n+        let parsed_body = TokenStream::with_subtree(macro_body.clone());\n+\n+        let parsed_attributes = attributes\n+            .map_or(crate::rustc_server::TokenStream::new(), |attr| {\n+                TokenStream::with_subtree(attr.clone())\n+            });\n+\n+        for lib in &self.libs {\n+            for proc_macro in &lib.exported_macros {\n+                match proc_macro {\n+                    bridge::client::ProcMacro::CustomDerive { trait_name, client, .. }\n+                        if *trait_name == macro_name =>\n+                    {\n+                        let res = client.run(\n+                            &crate::proc_macro::bridge::server::SameThread,\n+                            crate::rustc_server::Rustc::default(),\n+                            parsed_body,\n+                        );\n+\n+                        return res.map(|it| it.subtree);\n+                    }\n+\n+                    bridge::client::ProcMacro::Bang { name, client } if *name == macro_name => {\n+                        let res = client.run(\n+                            &crate::proc_macro::bridge::server::SameThread,\n+                            crate::rustc_server::Rustc::default(),\n+                            parsed_body,\n+                        );\n+\n+                        return res.map(|it| it.subtree);\n+                    }\n+\n+                    bridge::client::ProcMacro::Attr { name, client } if *name == macro_name => {\n+                        let res = client.run(\n+                            &crate::proc_macro::bridge::server::SameThread,\n+                            crate::rustc_server::Rustc::default(),\n+                            parsed_attributes,\n+                            parsed_body,\n+                        );\n+\n+                        return res.map(|it| it.subtree);\n+                    }\n+\n+                    _ => {\n+                        continue;\n+                    }\n+                }\n+            }\n+        }\n+\n+        Err(bridge::PanicMessage::String(\"Nothing to expand\".to_string()))\n+    }\n+\n+    pub fn list_macros(&self) -> Result<Vec<(String, ProcMacroKind)>, bridge::PanicMessage> {\n+        let mut result = vec![];\n+\n+        for lib in &self.libs {\n+            for proc_macro in &lib.exported_macros {\n+                let res = match proc_macro {\n+                    bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n+                        (trait_name.to_string(), ProcMacroKind::CustomDerive)\n+                    }\n+                    bridge::client::ProcMacro::Bang { name, .. } => {\n+                        (name.to_string(), ProcMacroKind::FuncLike)\n+                    }\n+                    bridge::client::ProcMacro::Attr { name, .. } => {\n+                        (name.to_string(), ProcMacroKind::Attr)\n+                    }\n+                };\n+                result.push(res);\n+            }\n+        }\n+\n+        Ok(result)\n+    }\n+}"}, {"sha": "f5a526dbf3507f264b05950adb12f7fe0d23329e", "filename": "crates/ra_proc_macro_srv/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7f121d60d0f6b8f280e09397b14a8afd0a369c1/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f121d60d0f6b8f280e09397b14a8afd0a369c1/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs?ref=f7f121d60d0f6b8f280e09397b14a8afd0a369c1", "patch": "@@ -17,6 +17,8 @@ mod proc_macro;\n #[doc(hidden)]\n mod rustc_server;\n \n+mod dylib;\n+\n use proc_macro::bridge::client::TokenStream;\n use ra_proc_macro::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n "}, {"sha": "ec0d356922d0191cfbf436ea6e897a1f6248bc5f", "filename": "crates/ra_proc_macro_srv/src/rustc_server.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7f121d60d0f6b8f280e09397b14a8afd0a369c1/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f121d60d0f6b8f280e09397b14a8afd0a369c1/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs?ref=f7f121d60d0f6b8f280e09397b14a8afd0a369c1", "patch": "@@ -34,6 +34,10 @@ impl TokenStream {\n         TokenStream { subtree: Default::default() }\n     }\n \n+    pub fn with_subtree(subtree: tt::Subtree) -> Self {\n+        TokenStream { subtree }\n+    }\n+\n     pub fn is_empty(&self) -> bool {\n         self.subtree.token_trees.is_empty()\n     }"}]}